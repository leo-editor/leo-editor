<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070610174018"><vh>Startup</vh>
<v t="ekr.20070325123558"><vh>@chapters</vh></v>
<v t="ekr.20050404094627"><vh>Buttons</vh>
<v t="ekr.20090712122931.10453"><vh>Disabled buttons</vh>
<v t="ekr.20041226081019"><vh>@@button Spell</vh></v>
<v t="ekr.20050812090111"><vh>@@button rst3</vh></v>
<v t="ekr.20050901054622"><vh>@@button Save</vh></v>
<v t="ekr.20050901055150"><vh>@@button promote</vh></v>
<v t="ekr.20050901060119"><vh>@@button def list</vh>
<v t="ekr.20050901061220"><vh>createDefList</vh></v>
</v>
<v t="ekr.20050901121617"><vh>@@button sentence</vh>
<v t="ekr.20050901121617.1"><vh>splitSentences</vh></v>
</v>
<v t="ekr.20050902080416"><vh>@@button reformat-paragraph</vh></v>
<v t="ekr.20060525104232"><vh>@@button rst-&gt;html</vh></v>
<v t="ekr.20060525110135"><vh>@@button rst-&gt;pdf</vh></v>
<v t="ekr.20060525110135.1"><vh>@@button rst-&gt;tex</vh></v>
<v t="ekr.20060525110217"><vh>@@button rst-&gt;rst</vh></v>
</v>
<v t="ekr.20091112060950.6677"><vh>@button Remove newlines</vh></v>
<v t="ville.20090705224948.5734"><vh>@button generate-userguide</vh>
<v t="ville.20090705225609.5736"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="ville.20090705225609.5738"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
<v t="sps.20100708203040.19008"><vh>@button generate-full-userguide</vh>
<v t="sps.20100708203040.19009"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="sps.20100708203040.19010"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
<v t="ekr.20091006063434.13802"><vh>@button rst3</vh></v>
<v t="ville.20090520232034.6345"><vh>@button rst-preview</vh></v>
</v>
<v t="ekr.20050407144417"><vh>@settings</vh>
<v t="ekr.20080923182326.1"><vh>@@bool create_nonexistent_directories = True</vh></v>
<v t="ekr.20080412124815.1"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20050407144342"><vh>@page http plugin</vh>
<v t="ekr.20050407144342.1"><vh>@bool http_active = False</vh></v>
<v t="ekr.20050407144342.2"><vh>@int  port = 8080</vh></v>
<v t="ekr.20050407144342.3"><vh>@string rst_http_attributename = rst_http_attribute</vh></v>
</v>
<v t="ekr.20050812123002"><vh>@page rst3 options</vh>
<v t="ekr.20050812123002.1"><vh>Http options...</vh>
<v t="ekr.20050812123002.2"><vh>@bool rst3_clear_http_attributes = False</vh></v>
<v t="ekr.20050812123002.3"><vh>@string rst3_http_attributename = 'rst_http_attribute'</vh></v>
<v t="ekr.20050812123002.4"><vh>@bool rst3_http_server_support = False</vh></v>
<v t="ekr.20050812123002.5"><vh>@string rst3_node_begin_marker = 'http-node-marker-'</vh></v>
</v>
<v t="ekr.20050812123002.6"><vh>@bool rst3_massage_body = False</vh></v>
<v t="ekr.20050812123002.7"><vh>@bool rst3_format_headlines = True</vh></v>
<v t="ekr.20050812123002.8"><vh>@bool rst3_write_intermediate_file = True</vh></v>
<v t="sps.20100708213227.44914"><vh>@string rst3_write_intermediate_extension = .html.txt</vh></v>
<v t="ekr.20051202072010"><vh>@string rst3_default_path =</vh></v>
</v>
</v>
<v t="ekr.20080923181012.1"><vh>@@rst ../test/new-directory/test.html</vh></v>
</v>
<v t="ekr.20050831195449"><vh>Read me first</vh></v>
<v t="ekr.20040414161647" a="E"><vh>Users Guide</vh>
<v t="ekr.20050831184021.3"><vh>Front matter</vh>
<v t="ekr.20040414172212"><vh>@rst html\frontMatter.html</vh>
<v t="ekr.20050812134441"><vh>@rst-no-head Links</vh></v>
<v t="ekr.20040414172218.4"><vh>Acknowledgements</vh>
<v t="ekr.20040416080538"><vh>@rst-no-head special mentions</vh></v>
</v>
<v t="ekr.20040414172218.5"><vh>@rst-ignore Python Copyright</vh></v>
<v t="ekr.20090221070927.1"><vh>Leo's MIT License</vh></v>
<v t="ekr.20040414174439"><vh>@rst-ignore DISCLAIMER OF LIABILITY</vh></v>
</v>
<v t="ekr.20040414172218.2"><vh>@rst-ignore Old Preface</vh></v>
</v>
<v t="ekr.20070701101808"><vh>Preface</vh>
<v t="ekr.20070701101809"><vh>@rst html\preface.html</vh>
<v t="ekr.20070701101809.1"><vh>@rst-no-head Links</vh></v>
<v t="ekr.20070723100037"><vh>@rst-no-head preface</vh></v>
</v>
</v>
<v t="ekr.20050831184021.4"><vh>What people are saying about Leo</vh>
<v t="ekr.20050830074716"><vh>@rst html\testimonials.html</vh>
<v t="ekr.20050830075229"><vh>@rst-no-head Links</vh></v>
<v t="ekr.20050830074815.1"><vh>Leo is revolutionary</vh></v>
<v t="ekr.20050830074815.2"><vh>Leo is a showcase Python/Tkinter application</vh></v>
<v t="ekr.20050830074815.3"><vh>Leo is fun, even addicting</vh></v>
<v t="ekr.20050830074815.4"><vh>Leo is a flexible, powerful IDE</vh></v>
<v t="ekr.20050830074815.5"><vh>Leo is a superb outliner</vh></v>
<v t="ekr.20050830074815.6"><vh>Leo is an excellent PIM</vh></v>
<v t="ekr.20050830074815.7"><vh>Leo extends, completes and simplifies literate programming</vh></v>
<v t="ekr.20050830074815.8"><vh>Leo is a superb documentation tool</vh></v>
<v t="ekr.20050830074815.9"><vh>Leo simplifies the understanding of complex systems</vh></v>
<v t="ekr.20050830074815.10"><vh>Leo is stable, well designed and well supported</vh></v>
<v t="ekr.20050830074815.11"><vh>Longer quotes...</vh>
<v t="ekr.20050830074815.12"><vh> Speed Ream's slashdot article</vh></v>
<v t="ekr.20050830074815.13"><vh>Joe Orr</vh></v>
<v t="ekr.20050830074815.14"><vh>Dan Winkler</vh></v>
<v t="ekr.20050830074815.15"><vh>Dan Winkler 2</vh></v>
<v t="ekr.20050830074815.16"><vh>Dan Winkler 3</vh></v>
</v>
</v>
</v>
<v t="ekr.20050831195331.1"><vh>FAQ</vh>
<v t="ekr.20050830115714"><vh>@rst html\FAQ.html</vh>
<v t="ekr.20050830120007"><vh>@rst-no-head Links</vh></v>
<v t="ekr.20090212054250.5"><vh>Getting Leo</vh>
<v t="ekr.20090501091345.2"><vh>@rst-option show-sections = False</vh>
<v t="ekr.20090212054250.6"><vh>Where can I get official releases of Leo?</vh></v>
<v t="ekr.20080603124653.1"><vh>How do I use bzr to get the latest sources from Leo's launchpad site?</vh></v>
<v t="ekr.20090212054250.7"><vh>How can I get recent bzr snapshots of Leo?</vh></v>
</v>
</v>
<v t="ekr.20070623145346"><vh>Installing Leo</vh>
<v t="ekr.20090501093330.1"><vh>@rst-option show-sections = False</vh>
<v t="ekr.20090202191501.7"><vh>Leo's installer failed, what do I do?</vh></v>
<v t="ekr.20060329101442"><vh>Nothing (or almost nothing) happens when I start Leo.  What should I do?</vh></v>
<v t="ekr.20050830115714.75"><vh>Leo is hanging on my Linux box.  What should I do?</vh></v>
<v t="ekr.20070623145346.1"><vh>Running Python setup.py install from the leo directory doesn't work.  Why not?</vh></v>
</v>
</v>
<v t="ekr.20050830115714.1"><vh>Learning to use Leo</vh>
<v t="ekr.20090501093330.2"><vh>@rst-option show-sections = False</vh>
<v t="ekr.20050830115714.2"><vh>What's the best way to learn to use Leo?</vh></v>
<v t="ekr.20050830115714.4"><vh>Why should I use clones?</vh></v>
<v t="ekr.20050830115714.5"><vh>Which should I use: @root trees or @thin trees?</vh></v>
<v t="ekr.20050830115714.7"><vh>When is using a section better than using a method?</vh></v>
<v t="ekr.20060111192108"><vh>When is deleting a node dangerous?</vh></v>
</v>
</v>
<v t="ekr.20050830115714.12"><vh>How should I use Leo with bzr/git/hg/svn/cvs?</vh></v>
<v t="ekr.20090706042206.14718"><vh>How can I use Leo cooperatively without sentinels?</vh></v>
<v t="ekr.20050830115714.13"><vh>Using external files</vh>
<v t="ekr.20090501093330.3"><vh>@rst-option show-sections = False</vh>
<v t="ekr.20050830115714.14"><vh>How do I inhibit sentinels in external files?</vh></v>
<v t="ekr.20050830115714.16"><vh>How do I prevent Leo from expanding sections?</vh></v>
<v t="ekr.20050830115714.18"><vh>How can I create Javascript comments?</vh></v>
<v t="ekr.20050830115714.19"><vh>How can I disable PHP comments?</vh></v>
<v t="ekr.20050830115714.20"><vh>How can I use Leo with unsupported languages?</vh></v>
<v t="ekr.20050830115714.21"><vh>How do I make external files start with a shebang line?</vh></v>
<v t="ekr.20050830115714.22"><vh>How do I use Leo to create CWEB files?</vh></v>
<v t="ekr.20050830115714.24"><vh>Can @file trees contain material not in the external file?</vh></v>
<v t="ekr.20050830115714.25"><vh>How can I use Leo with older C compilers</vh></v>
<v t="ekr.20060529053407"><vh>Why can't I use @ignore directives in @thin trees?</vh></v>
<v t="shadow.20080825171547.9"><vh>How can I avoid getting long lines in external files?</vh></v>
</v>
</v>
<v t="ekr.20050830115714.26"><vh>Customizing Leo</vh>
<v t="ekr.20090501093330.4"><vh>@rst-option show-sections = False</vh>
<v t="ekr.20050830115714.29"><vh>How can I add support for a new language?</vh></v>
<v t="ekr.20050830115714.30"><vh>How do I submit a plugin?</vh></v>
<v t="ekr.20050830120844"><vh>How do I add a new menu item from a plugin?</vh></v>
<v t="ekr.20060805094325"><vh>How can I use Leo's legacy key bindings?</vh></v>
<v t="ekr.20060915112109"><vh>How can I enable and disable support for psyco?</vh></v>
<v t="ekr.20091105080104.9031"><vh>How do I specify qt fonts?</vh></v>
</v>
</v>
<v t="ekr.20050830115714.118"><vh>Tips and techniques</vh>
<v t="ekr.20090501093330.5"><vh>@rst-option show-sections = False</vh>
<v t="ekr.20080527063511.1"><vh>What is an easy way to profile code?</vh></v>
<v t="ekr.20070622185234"><vh>How can I do a simple find and replace?</vh></v>
<v t="ekr.20050830120857"><vh>How can I use Leo to develop Leo itself?</vh></v>
<v t="ekr.20050830115714.74"><vh>How can I import many files at once?</vh></v>
<v t="ekr.20050830115714.119"><vh>How can I use two copies of Leo to advantage?</vh></v>
<v t="ekr.20050830115714.120"><vh>How can I display graphics in Leo?</vh></v>
<v t="ekr.20050830115714.113"><vh>How can I create a template .leo file?</vh></v>
<v t="ekr.20050830115714.116"><vh>How can I show Leo files with Excel?</vh></v>
<v t="ekr.20060822111759"><vh>How can I reuse @button nodes in multiple files?</vh></v>
</v>
</v>
<v t="ekr.20050830115714.76"><vh>Trouble shooting</vh>
<v t="ekr.20090501093330.6"><vh>@rst-option show-sections = False</vh>
<v t="ekr.20090130144433.1"><vh>How do I get help?</vh></v>
<v t="ekr.20090130144433.2"><vh>How do I report bugs?</vh></v>
<v t="ekr.20080813064908.2"><vh>My old .leo files won't load using Leo 4.5 or later. What should I do?</vh></v>
<v t="ekr.20060210070421"><vh>@rst-ignore I can't run Leo from a cvs sandbox.  What's going on?</vh></v>
<v t="ekr.20050908113904"><vh>Can I scroll the outline pane with the mouse wheel?</vh></v>
<v t="ekr.20050830115714.114"><vh>Control-Shift backspace doesn't work.  What should I do?</vh></v>
<v t="ekr.20050830115714.115"><vh>Error messages from the rst3 plugin aren't helpful. What can I do?</vh></v>
<v t="ekr.20050906090012"><vh>How can I run Leo from a console window?</vh></v>
<v t="ekr.20050830115714.77"><vh>How can I use Python's pdb debugger with Leo?</vh></v>
<v t="ekr.20050830115714.17"><vh>I can't write Imported files.  What's going on?</vh></v>
<v t="edream.110203163054.61"><vh>I don't see the Leo icon in Leo windows</vh></v>
<v t="ekr.20061021164213.1"><vh>Leo doesn't recognize commands with the caps-lock key down</vh></v>
<v t="ekr.20050830115714.75"></v>
<v t="ekr.20060323105214"><vh>Leo's Recent Files menu doesn't work from a cvs shandbox.  What's going on?</vh></v>
<v t="ekr.20060329101442"></v>
<v t="ekr.20050830115714.117"><vh>The new Python decorator syntax causes problems.  What can I do?</vh></v>
<v t="ekr.20070623145346.1"></v>
<v t="ekr.20070816092449"><vh>I can't run the LeoBridge module outside of leo/core.  What should I do?</vh></v>
<v t="ekr.20091105080104.11492"><vh>Why don't @font nodes work with the Qt gui?</vh></v>
</v>
</v>
<v t="ekr.20071026055929"><vh>Unicode issues</vh>
<v t="ekr.20090501093330.7"><vh>@rst-option show-sections = False</vh>
<v t="ekr.20061021164213"><vh>I can not enter non-ascii characters.  What can I do?</vh></v>
<v t="ekr.20050830115714.9"><vh>Some characters in external files look funny. What can I do?</vh></v>
<v t="ekr.20060917130130"><vh>I get weird results when defining unicode strings in scripts.  What is going on?</vh></v>
<v t="ekr.20050830115714.10"><vh>Some characters are garbled when importing files. What can I do?</vh></v>
<v t="ekr.20071026055929.1"><vh>Python's print statement shows 'byte hash' for unicode characters.  What can I do?</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050831195331.2"><vh>Chapter 1: Installing Leo</vh>
<v t="edream.110203163054.48"><vh>@rst html\install.html</vh>
<v t="ekr.20050901110110"><vh>@rst-no-head links</vh></v>
<v t="edream.110203163054.49"><vh>System requirements</vh></v>
<v t="ekr.20080408060320.784"><vh>Leo's HOME directory</vh></v>
<v t="edream.110203163054.50"><vh>How to install Leo on Linux</vh></v>
<v t="ekr.20090622091845.5623"><vh>Installing Leo on MacOS X</vh></v>
<v t="ekr.20070622141457"><vh>Installing Leo on Windows</vh></v>
<v t="vivainio.20080409164902.1"><vh>Tracking the development version</vh></v>
<v t="ekr.20050901174937"><vh>Running Leo</vh></v>
<v t="ekr.20090705111443.10370"><vh>Running Leo from a console window</vh></v>
<v t="ekr.20070629130418"><vh>Running Leo in batch mode</vh></v>
<v t="ekr.20060105145125"><vh>How to install the Aspell spell checker</vh></v>
</v>
</v>
<v t="ekr.20091130111843.6787"><vh>Chapter 2: The Leo Tutorial</vh>
<v t="ekr.20091130111843.6788"><vh>@rst html\intro.html</vh>
<v t="ekr.20091130111843.6810"><vh>@rst-no-head links</vh></v>
<v t="ekr.20091130111843.6814"><vh>Leo's main window</vh></v>
<v t="ekr.20091130111843.6816"><vh>Outline commands</vh></v>
<v t="ekr.20091130111843.6846"><vh>External files and @thin nodes</vh></v>
<v t="ekr.20091201091455.6809"><vh>Creating external files from outlines</vh>
<v t="ekr.20091201091455.6813"><vh>Section references</vh></v>
<v t="ekr.20091201091455.6814"><vh>The @others directive</vh></v>
<v t="ekr.20091201091455.6815"><vh>The @all directive</vh></v>
<v t="ekr.20091130111843.6838"><vh>Choosing between @others and sections</vh></v>
<v t="ekr.20091130111843.6839"><vh>Organizing programs as outlines</vh></v>
</v>
<v t="ekr.20091130111843.6817"><vh>Clones &amp; views</vh></v>
<v t="ekr.20091130194648.6811"><vh>More about directives</vh></v>
<v t="ekr.20091130111843.6840"><vh>Scripting, extending and customizing Leo</vh></v>
<v t="ekr.20091222125456.6641"><vh>Summary</vh></v>
<v t="ekr.20091130111843.6843"><vh>Further study</vh></v>
</v>
</v>
<v t="EKR.20040524104904.26" a="E"><vh>Chapter 3: Using Outlines</vh>
<v t="ekr.20050901101608" a="E"><vh>@rst html\outlines.html</vh>
<v t="ekr.20050901101608.1"><vh>@rst-no-head links</vh></v>
<v t="sps.20100710110337.12186"><vh>@rst-ignore-node DO NOT SORT THESE HEADLINES</vh></v>
<v t="sps.20100710110337.12187" a="E"><vh>Outline Related</vh>
<v t="ekr.20060929040750"><vh>Navigating through the outline</vh></v>
<v t="EKR.20040524104904.40"><vh>Expanding &amp; contracting nodes</vh></v>
<v t="EKR.20040524104904.36"><vh>Creating and destroying nodes</vh></v>
<v t="EKR.20040524104904.37"><vh>Cutting, pasting and deleting nodes</vh></v>
<v t="EKR.20040524104904.44"><vh>Moving &amp; Reorganizing nodes</vh></v>
<v t="EKR.20040524104904.27"><vh>Cloning nodes</vh></v>
<v t="EKR.20040524104904.43"><vh>Marking nodes</vh></v>
<v t="EKR.20040524104904.38"><vh>Dragging nodes</vh></v>
</v>
<v t="sps.20100710110337.12188"><vh>Body Related</vh>
<v t="EKR.20040524104904.39"><vh>Editing body text</vh></v>
<v t="EKR.20040524104904.41"><vh>Indenting body text automatically</vh></v>
<v t="ekr.20060920145745"><vh>Creating and destroying multiple body editors</vh></v>
</v>
<v t="sps.20100710110337.12189"><vh>Miscellaneous</vh>
<v t="EKR.20040524104904.48"><vh>Undoing operations</vh></v>
<v t="EKR.20040524104904.47"><vh>Resizing panes</vh></v>
<v t="EKR.20040524104904.45"><vh>Opening URL's automatically</vh></v>
<v t="ekr.20070623145346.2"><vh>Using chapters</vh></v>
</v>
</v>
</v>
<v t="ekr.20050831184021.5"><vh>Chapter 4: Programming with Leo</vh>
<v t="ekr.20050828061213"><vh>@rst html\directives.html</vh>
<v t="ekr.20050828160132"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050828061501.1"><vh>@rst-no-head Intro.</vh></v>
<v t="sps.20100712151944.7128"><vh>A Brief and Inaccurate History of Leo for Programming</vh></v>
<v t="sps.20100712151944.7132"><vh>Creating and using external files: recommendations</vh></v>
<v t="sps.20100712151944.7141"><vh>Overview: summary of directives</vh>
<v t="sps.20100712151944.7142"><vh>Body pane modifiers</vh></v>
<v t="sps.20100712151944.7143"><vh>List of @&lt;file&gt; Family Directives</vh>
<v t="sps.20100712151944.7144"><vh>External File Directives</vh></v>
<v t="sps.20100712151944.7145"><vh>Body Text Generation Modifiers</vh></v>
<v t="sps.20100712151944.7146"><vh>Tree Walk Modifiers</vh></v>
</v>
<v t="sps.20100712151944.7147"><vh>List of @root Family Directives</vh></v>
</v>
<v t="sps.20100712151944.7183"><vh>All About Directives</vh>
<v t="sps.20100712151944.7184"><vh>Body pane modifiers</vh>
<v t="sps.20100712151944.7185"><vh>@color, @nocolor, @nocolor-node and @killcolor</vh></v>
<v t="sps.20100712151944.7186"><vh>@wrap and @nowrap</vh></v>
</v>
<v t="sps.20100712151944.7187"><vh>\@&lt;file&gt; Directive Family</vh>
<v t="sps.20100712151944.7188"><vh>External file directives</vh>
<v t="sps.20100712151944.7189"><vh>\@asis</vh></v>
<v t="sps.20100712151944.7190"><vh>\@auto</vh>
<v t="sps.20100712151944.7191"><vh>Perfect import checks</vh></v>
<v t="sps.20100712151944.7192"><vh>Commands related to @auto</vh></v>
</v>
<v t="sps.20100712151944.7193"><vh>\@edit</vh></v>
<v t="sps.20100712151944.7194"><vh>\@file</vh></v>
<v t="sps.20100712151944.7195"><vh>\@nosent</vh></v>
<v t="sps.20100712151944.7196"><vh>\@path</vh></v>
<v t="sps.20100712151944.7197"><vh>\@shadow</vh></v>
<v t="sps.20100712151944.7198"><vh>\@thin</vh></v>
</v>
<v t="sps.20100712151944.7199"><vh>Text generation modifiers</vh>
<v t="sps.20100712151944.7200"><vh>@ and @doc</vh></v>
<v t="sps.20100712151944.7201"><vh>@c and @code</vh></v>
<v t="sps.20100712151944.7202"><vh>@comment</vh></v>
<v t="sps.20100712151944.7203"><vh>@delims</vh></v>
<v t="sps.20100712151944.7204"><vh>@encoding</vh></v>
<v t="sps.20100712151944.7205"><vh>@first</vh></v>
<v t="sps.20100712151944.7206"><vh>@language</vh>
<v t="sps.20100714141211.16549"><vh>@rst-ignore-node</vh></v>
</v>
<v t="sps.20100712151944.7207"><vh>@last</vh></v>
<v t="sps.20100712151944.7208"><vh>@lineending</vh></v>
<v t="sps.20100712151944.7209"><vh>@pagewidth</vh></v>
<v t="sps.20100712151944.7210"><vh>@raw and @end_raw</vh></v>
<v t="sps.20100712151944.7211"><vh>@tabwidth</vh></v>
</v>
<v t="sps.20100712151944.7213"><vh>Tree walk modifiers</vh>
<v t="sps.20100712151944.7214"><vh>&lt;&lt;section&gt;&gt;</vh></v>
<v t="sps.20100712151944.7215"><vh>@all</vh></v>
<v t="sps.20100712151944.7216"><vh>@ignore</vh></v>
<v t="sps.20100712151944.7217"><vh>@others</vh></v>
</v>
</v>
<v t="sps.20100712151944.7218"><vh>\@root Directive Family</vh>
<v t="sps.20100712151944.7259"><vh>\@root Explained</vh>
<v t="sps.20100712151944.7260"><vh>Sections and section definitions</vh></v>
<v t="sps.20100712151944.7261"><vh>Tangling @root trees with the Tangle commands</vh></v>
<v t="sps.20100712151944.7262"><vh>Untangling @root trees with the Untangle commands</vh></v>
</v>
<v t="sps.20100712151944.7253"><vh>External file directives</vh>
<v t="sps.20100712151944.7220"><vh>\@root</vh></v>
<v t="sps.20100712151944.7222"><vh>\@root-code and @root-doc</vh></v>
<v t="sps.20100712151944.7242"><vh>\@path</vh></v>
</v>
<v t="sps.20100712151944.7254"><vh>Text generation modifiers</vh>
<v t="sps.20100716120121.18081"><vh>@rst-ignore-node DO NOT SORT</vh></v>
<v t="sps.20100712151944.7224"><vh>@ and @doc</vh></v>
<v t="sps.20100712151944.7226"><vh>\&lt;&lt; named section &gt;&gt;, @c and @code</vh></v>
<v t="sps.20100716120121.18082"><vh>@language, @comment, and sentinels</vh>
<v t="sps.20100712151944.7236"><vh>@language</vh></v>
<v t="sps.20100712151944.7228"><vh>@comment</vh></v>
<v t="sps.20100716120121.18083"><vh>sentinels</vh></v>
</v>
<v t="sps.20100712151944.7248"><vh>@unit</vh></v>
<v t="sps.20100712151944.7232"><vh>@first</vh></v>
<v t="sps.20100712151944.7230"><vh>@encoding</vh></v>
<v t="sps.20100712151944.7234"><vh>@ignore</vh></v>
<v t="sps.20100716120121.22542"><vh>@lineending</vh></v>
<v t="sps.20100712151944.7244"><vh>@pagewidth</vh></v>
<v t="sps.20100712151944.7246"><vh>@tabwidth</vh></v>
<v t="sps.20100712151944.7238"><vh>@rst-ignore-node @last</vh></v>
<v t="sps.20100712151944.7250"><vh>@verbose, @terse, @quiet and @silent</vh></v>
</v>
</v>
</v>
<v t="EKR.20040524104904.282"><vh>@rst-ignore-node Converting @root trees to @file trees</vh></v>
<v t="ekr.20050828061501.43"><vh>CWEB mode</vh></v>
</v>
</v>
<v t="EKR.20040524104904.99"><vh>Chapter 5: Using Leo's Commands</vh>
<v t="ekr.20050901101608.2"><vh>@rst html\commands.html</vh>
<v t="ekr.20050901101852"><vh>@rst-no-head links</vh></v>
<v t="ekr.20060227102028.111"><vh>Autocompletion</vh></v>
<v t="ekr.20100504092040.17423"><vh>Calltips</vh></v>
<v t="ekr.20060420094611"><vh>The minibuffer</vh>
<v t="ekr.20060613062025.6"><vh>Basic editing commands</vh></v>
<v t="ekr.20060613062025.1"><vh>Debugging commands</vh></v>
<v t="ekr.20060613062025.4"><vh>Emacs commands</vh></v>
<v t="ekr.20060613062025.5"><vh>Find commands</vh></v>
<v t="ekr.20060613062025.9"><vh>Gui commands</vh></v>
<v t="ekr.20060613062025.2"><vh>Help commands</vh></v>
<v t="ekr.20060613062025.10"><vh>Mode commands</vh></v>
<v t="ekr.20060613062025.7"><vh>Outline commands</vh></v>
<v t="ekr.20060613062025.8"><vh>Miscellaneous commands</vh></v>
</v>
<v t="EKR.20040524104904.100"><vh>The File Menu</vh>
<v t="EKR.20040524104904.101"><vh>Loading, Saving and Reverting Files</vh></v>
<v t="EKR.20040524104904.102"><vh>Communicating with external editors</vh></v>
<v t="EKR.20040524104904.105"><vh>Tangling an outline: Producing external files</vh></v>
<v t="EKR.20040524104904.106"><vh>Untangling: updating an outline</vh></v>
<v t="EKR.20040524104904.108"><vh>Importing Files into Leo Outlines</vh></v>
<v t="EKR.20040524104904.109"><vh>Exporting Files from Leo Outlines</vh></v>
<v t="EKR.20040524104904.110"><vh>Quitting Leo</vh></v>
</v>
<v t="EKR.20040524104904.111"><vh>The Edit Menu</vh>
<v t="EKR.20040524104904.112"><vh>Undoing changes</vh></v>
<v t="EKR.20040524104904.113"><vh>Cutting, pasting and selecting text</vh></v>
<v t="EKR.20040524104904.114"><vh>Shifting body text</vh></v>
<v t="ekr.20050313102319"><vh>Adding and deleting comments in body text</vh></v>
<v t="EKR.20040524104904.115"><vh>Creating nodes from body text</vh></v>
<v t="EKR.20040524104904.116"><vh>Converting leading blanks and tabs in body text</vh></v>
<v t="EKR.20040524104904.117"><vh>Executing Python scripts in body text</vh></v>
<v t="EKR.20040524104904.118"><vh>Finding and changing text</vh></v>
<v t="ekr.20050902160924"><vh>Script search</vh></v>
<v t="EKR.20040524104904.134"><vh>Go To Line Number</vh></v>
<v t="EKR.20040524104904.136"><vh>Inserting the date and time</vh></v>
<v t="EKR.20040524104904.137"><vh>Reformatting paragraphs in body text</vh></v>
<v t="EKR.20040524104904.139"><vh>Matching brackets and parenthesis</vh></v>
</v>
<v t="EKR.20040524104904.143"><vh>The Outline Menu</vh>
<v t="EKR.20040524104904.144"><vh> Checking outlines</vh></v>
<v t="EKR.20040524104904.145"><vh> Creating &amp; cloning nodes</vh></v>
<v t="EKR.20040524104904.146"><vh> Cutting, pasting and deleting nodes</vh></v>
<v t="EKR.20040524104904.147"><vh> Expanding and contracting nodes</vh></v>
<v t="EKR.20040524104904.149"><vh> Marking nodes</vh></v>
<v t="EKR.20040524104904.150"><vh> Moving, sorting and reorganizing nodes</vh></v>
<v t="EKR.20040524104904.148"><vh> Hoisting &amp; De-hoisting nodes</vh></v>
</v>
<v t="EKR.20040524104904.151"><vh>The Window Menu</vh></v>
<v t="EKR.20040524104904.157"><vh>The Help Menu</vh></v>
</v>
</v>
<v t="EKR.20040524104904.161"><vh>Chapter 6: Leo and Literate Programming</vh>
<v t="ekr.20050901101608.3"><vh>@rst html\design.html</vh>
<v t="ekr.20050901101949"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.162"><vh>Why I like Literate Programming</vh></v>
<v t="EKR.20040524104904.173"><vh>How Leo Improves Literate Programming</vh></v>
<v t="EKR.20040524104904.181"><vh>How Leo Changes the Notion of Literate Programming</vh></v>
</v>
</v>
<v t="ekr.20050831195331.4"><vh>Chapter 7: Scripting Leo with Python</vh>
<v t="ekr.20040403171740"><vh>@rst html\scripting.html</vh>
<v t="ekr.20091104200540.6566"><vh>@rst-ignore</vh>
<v t="ekr.20091107181442.26607"><vh>old, too complicated intro</vh></v>
<v t="ekr.20091104200540.6567"><vh>details for later</vh></v>
</v>
<v t="ekr.20050812134441.1"><vh>@rst-no-head Links</vh></v>
<v t="ekr.20040403183229"><vh>Leo's most import objects</vh></v>
<v t="ekr.20070120075236"><vh>Predefined objects</vh></v>
<v t="ekr.20040403173920.3"><vh>g.es writes to the log pane</vh></v>
<v t="ekr.20040403175157.1"><vh>app.windowList: the list of all open frames</vh></v>
<v t="ekr.20040403173920.6"><vh>Getting and setting headline and body text</vh></v>
<v t="ekr.20090223065025.3"><vh>Getting and setting body text directly</vh></v>
<v t="ekr.20070122093626"><vh>Ensuring that positions are valid</vh></v>
<v t="ekr.20050902073404"><vh>About copying positions</vh></v>
<v t="ekr.20040403173920.9"><vh>Traversing outlines</vh>
<v t="ekr.20040403173920.10"><vh>c.all_positions &amp; c.all_unique_positions</vh></v>
<v t="ekr.20040403173920.13"><vh>p.children</vh></v>
<v t="ekr.20040403173920.14"><vh>p.parents &amp; p.self_and_parents</vh></v>
<v t="ekr.20040403173920.15"><vh>p.siblings &amp; p.following_siblings</vh></v>
<v t="ekr.20040403173920.16"><vh>p.subtree &amp; p.self_and_subtree</vh></v>
<v t="ekr.20040903100514"><vh>Testing whether a position is valid</vh></v>
</v>
<v t="ekr.20040403173920.17"><vh>Updating the screen</vh></v>
<v t="ekr.20040403173920.18"><vh>Invoking commands from scripts</vh></v>
<v t="ekr.20050907094633"><vh>Getting settings from @settings trees</vh></v>
<v t="ekr.20040403173920.19"><vh>Getting and setting preferences</vh></v>
<v t="ekr.20040403173920.21"><vh>Functions for finding and changing text from scripts</vh></v>
<v t="ekr.20040403173920.25"><vh>Functions defined in leoGlobals.py</vh></v>
<v t="ekr.20050903074833"><vh>Event handlers</vh>
<v t="ekr.20050903074833.1"><vh>@rst-no-head Summary of event handlers</vh></v>
<v t="ekr.20071021102946"><vh>Enabling idle time event handlers</vh></v>
</v>
<v t="ekr.20050417072710.1"><vh>How to make operations undoable</vh></v>
<v t="ekr.20040403173920.5"><vh>Redirecting output from scripts</vh></v>
<v t="ekr.20061003204952"><vh>Writing to different log tabs</vh></v>
<v t="ekr.20071026183116"><vh>Invoking dialogs using the g.app.gui class</vh></v>
<v t="ekr.20080109074102"><vh>Inserting and deleting icons</vh></v>
<v t="ekr.20051101171734"><vh>Customizing panes with different widgets</vh>
<v t="ekr.20061003204952.1"><vh>Official ivars</vh></v>
<v t="ekr.20061003212136"><vh>Common operations on Tk.Text widgets</vh></v>
<v t="ekr.20061003204952.2"><vh>Customizing the log pane</vh></v>
<v t="ekr.20061003204952.3"><vh>Customizing the body pane</vh></v>
<v t="ekr.20061003204952.4"><vh>Customizing the outine pane</vh></v>
</v>
<v t="ekr.20081205084002.2"><vh>Working with directives and paths</vh></v>
<v t="ekr.20040403173920.26"><vh>Summary of the vnode and position classes</vh>
<v t="ekr.20040411151245"><vh>generators</vh></v>
<v t="ekr.20040403173920.27"><vh>Getters</vh></v>
<v t="ekr.20040403173920.28"><vh>Setters</vh></v>
</v>
<v t="ekr.20050903161843"><vh>Creating script buttons</vh></v>
<v t="ekr.20040403173920.24"><vh>Running Leo in batch mode</vh></v>
<v t="ekr.20080922124033.1"><vh>Getting interactive input from scripts</vh></v>
<v t="ville.20090603183524.5672"><vh>Creating Leo commands with the @g.command decorator</vh></v>
<v t="ekr.20100506062734.11593"><vh>Modifying plugins with @script scripts</vh></v>
</v>
</v>
<v t="EKR.20040524104904.211"><vh>Chapter 8: Customizing Leo</vh>
<v t="ekr.20050901101608.4"><vh>@rst html\customizing.html</vh>
<v t="ekr.20050901102055"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.140"><vh>Specifying settings</vh>
<v t="ekr.20090116130002.1"><vh>Configuration directories</vh></v>
<v t="ekr.20090116094356.2"><vh>Search order for settings files</vh></v>
<v t="ekr.20090116094356.3"><vh>Safe rules for local settings</vh></v>
<v t="ekr.20070317043727"><vh>Organizer nodes</vh></v>
<v t="ekr.20080411111008.1"><vh>\@ignore and \@if nodes</vh></v>
<v t="ekr.20070317043727.2"><vh>Simple settings nodes</vh></v>
<v t="ekr.20070317043727.3"><vh>Complex settings nodes</vh>
<v t="ekr.20090116094356.5"><vh>\@button</vh></v>
<v t="ekr.20090116094356.6"><vh>\@commands</vh></v>
<v t="ekr.20090116094356.7"><vh>\@data</vh></v>
<v t="ekr.20090116094356.8"><vh>\@enabled-plugins</vh></v>
<v t="ekr.20090116094356.11"><vh>\@font</vh></v>
<v t="ekr.20090116094356.10"><vh>\@menuat</vh></v>
<v t="ekr.20090116094356.9"><vh>\@menus</vh></v>
<v t="ekr.20090116094356.14"><vh>\@mode</vh></v>
<v t="ekr.20090116094356.13"><vh>\@recentfiles</vh></v>
<v t="ekr.20090116094356.12"><vh>\@shortcuts</vh></v>
</v>
</v>
<v t="ekr.20060105214753"><vh>Input modes</vh></v>
<v t="ekr.20050306090601"><vh>Adding extensible attributes to nodes and .leo files</vh></v>
<v t="ekr.20050620150517"><vh>Specifying Tk options using .leo_xresources</vh></v>
<v t="ekr.20080310093038.4"><vh>Translating Leo's menus and messages</vh></v>
<v t="ekr.20100122073254.11655"><vh>Writing new importers</vh></v>
</v>
</v>
<v t="EKR.20040524104904.245"><vh>Chapter 9: History of Leo</vh>
<v t="ekr.20050901101608.5"><vh>@rst html\history.html</vh>
<v t="ekr.20050901102147"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050902105852"><vh>Beginnings</vh></v>
<v t="ekr.20050902105852.1"><vh>Breakthrough</vh></v>
<v t="ekr.20050902105852.2"><vh>Apple and YellowBox</vh></v>
<v t="ekr.20050902105852.3"><vh>Borland C++</vh></v>
<v t="ekr.20050902105852.4"><vh>Discovering Python</vh></v>
<v t="ekr.20050902105852.5"><vh>SourceForge</vh></v>
<v t="ekr.20050902105852.6"><vh>Allowing sentinel lines in external files</vh></v>
<v t="ekr.20050902105852.7"><vh>Untangling @file is easy!</vh></v>
<v t="ekr.20050902105852.8"><vh>Leo 3.x: Continuous improvement</vh></v>
<v t="ekr.20050902105852.9"><vh>Leo 4.0: Eliminating error 'recovery'</vh></v>
<v t="ekr.20050902105852.10"><vh>Leo 4.1: The debut of gnx's</vh></v>
<v t="ekr.20050902105852.11"><vh>Leo 4.2: Complete at last</vh></v>
<v t="ekr.20050902105852.12"><vh>Leo 4.3 Settings</vh></v>
<v t="ekr.20060629083935"><vh>Leo 4.4 The minibuffer and key bindings</vh></v>
<v t="ekr.20080315115427.568"><vh>Leo 4.4.4 Improvements</vh>
<v t="ekr.20080315115427.569"><vh>Leo 4.4.1</vh></v>
<v t="ekr.20080315115427.570"><vh>Leo 4.4.2</vh></v>
<v t="ekr.20080315115427.571"><vh>Leo 4.4.3</vh></v>
<v t="ekr.20080315115427.572"><vh>Leo 4.4.4</vh></v>
<v t="ekr.20080315115427.573"><vh>Leo 4.4.5</vh></v>
<v t="ekr.20080315115427.574"><vh>Leo 4.4.7 and Leo 4.4.8</vh></v>
</v>
<v t="ekr.20050902100834"><vh>@rst-ignore-tree Details</vh>
<v t="EKR.20040524104904.247"><vh>Versions</vh></v>
<v t="EKR.20040524104904.248"><vh>Designing @file trees</vh>
<v t="EKR.20040524104904.249"><vh>Deciding to do Leo2</vh></v>
<v t="EKR.20040524104904.250"><vh>A prototype</vh></v>
<v t="EKR.20040524104904.251"><vh>User interaction</vh></v>
<v t="EKR.20040524104904.252"><vh>The write code</vh></v>
<v t="EKR.20040524104904.253"><vh>The read code</vh></v>
<v t="EKR.20040524104904.254"><vh>The load/save code</vh></v>
<v t="EKR.20040524104904.255"><vh>Attributes, mirroring and dummy nodes</vh></v>
<v t="EKR.20040524104904.256"><vh>Clones</vh></v>
<v t="EKR.20040524104904.257"><vh>Error recovery, at last</vh></v>
</v>
</v>
</v>
</v>
<v t="EKR.20040524104904.261"><vh>Chapter 10: Theory of Operation</vh>
<v t="ekr.20050901101608.6"><vh>@rst html\theory.html</vh>
<v t="ekr.20050901102300"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.262"><vh>Overview</vh></v>
<v t="EKR.20040524104904.263"><vh>Nodes</vh></v>
<v t="EKR.20040524104904.264"><vh>Drawing and events</vh></v>
<v t="EKR.20040524104904.265"><vh>Clones</vh></v>
<v t="EKR.20040524104904.266"><vh>Find and change commands</vh></v>
<v t="EKR.20040524104904.267"><vh>Tangle and untangle commands</vh></v>
<v t="EKR.20040524104904.268"><vh>Unicode</vh></v>
<v t="EKR.20040524104904.269"><vh>Unlimited undo</vh></v>
<v t="ekr.20060602142732"><vh>Key bindings</vh></v>
</v>
</v>
<v t="ekr.20050901084134"><vh>Chapter 11: White papers</vh>
<v t="ekr.20050901092232"><vh>@rst html\whitepapers.html</vh>
<v t="ekr.20050901092232.1"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.259"><vh>@rst-ignore Tk is the future of Leo</vh></v>
<v t="EKR.20040524104904.260"><vh>Why I like Python</vh>
<v t="ekr.20050901092232.2"><vh>Clarity</vh></v>
<v t="ekr.20050901092232.3"><vh>Power</vh></v>
<v t="ekr.20050901092232.4"><vh>Safety</vh></v>
<v t="ekr.20050901092232.5"><vh>Speed</vh></v>
<v t="ekr.20050901092232.6"><vh>Conclusions</vh></v>
</v>
<v t="ekr.20060218085144"><vh>@rst-ignore Why Leo is special</vh>
<v t="ekr.20060218085144.1"><vh>1. You can execute Python scripts directly from anywhere in a Leo outline</vh></v>
<v t="ekr.20060218085144.2"><vh>2. Leo's outlines are the perfect tool for organizing scripts</vh></v>
<v t="ekr.20060218085144.3"><vh>3. Scripts can access the structure of Leo's outlines</vh></v>
<v t="ekr.20060218085144.4"><vh>4. Leo's nodes naturally separate data from meta-data</vh></v>
<v t="ekr.20060218085144.5"><vh>5. Leo is the ultimate platform for unit testing</vh></v>
<v t="ekr.20060218085144.6"><vh>6. Leo is the ultimate platform for finding and changing text.</vh></v>
<v t="ekr.20060218085144.7"><vh>7. Leo outlines are the ultimate filing cabinet</vh></v>
<v t="ekr.20060218095651"><vh>8: Script buttons</vh></v>
<v t="ekr.20060218092725"><vh>9: The rst3 plugin</vh></v>
<v t="ekr.20060218085144.8"><vh>Conclusion</vh></v>
</v>
<v t="ekr.20061129170454"><vh>@rst-ignore Allocating storage using lifetimes</vh>
<v t="ekr.20061129170155.2"><vh>Lifetime allocation</vh></v>
<v t="ekr.20061129175952"><vh>Typical lifetimes</vh></v>
<v t="ekr.20061129202238"><vh>Implications for pypy</vh></v>
</v>
</v>
</v>
<v t="ekr.20050912125144"><vh>Chapter 12: Plugins</vh>
<v t="ekr.20050912125144.1"><vh>@rst html\plugins.html</vh>
<v t="ekr.20050912125735"><vh>@rst-no-head links</vh></v>
<v t="ekr.20070814104719"><vh>Enabling plugins</vh></v>
<v t="ekr.20050912125735.868"><vh>Body pane</vh>
<v t="ekr.20050912125735.869"><vh>arrows.py</vh></v>
<v t="ekr.20050912125735.874"><vh>image.py</vh></v>
<v t="ekr.20050912125735.880"><vh>rClick.py</vh></v>
<v t="ekr.20050912125735.904"><vh>autocompleter.py</vh></v>
<v t="ekr.20050912125735.942"><vh>color_markup.py</vh></v>
<v t="ekr.20050912125735.974"><vh>script_io_to_body.py</vh></v>
</v>
<v t="ekr.20050912125735.26"><vh>Commands &amp; directives</vh>
<v t="ekr.20050912125735.82"><vh>add_directives.py</vh></v>
<v t="ekr.20050912125735.85"><vh>bibtex.py</vh></v>
<v t="ekr.20050912125735.98"><vh>ConceptualSort.py</vh></v>
<v t="ekr.20050912125735.245"><vh>datenodes.py</vh></v>
<v t="ekr.20050912125735.113"><vh>FileActions.py</vh></v>
<v t="ekr.20050912125735.129"><vh>groupOperations.py</vh></v>
<v t="ekr.20050912125735.28"><vh>import_cisco_config.py</vh></v>
<v t="ekr.20050912125735.273"><vh>Library.py</vh></v>
<v t="ekr.20050912125735.164"><vh>macros.py</vh></v>
<v t="ekr.20050912125735.314"><vh>mod_autosave.py</vh></v>
<v t="ekr.20050912125735.172"><vh>mod_read_dir_outline.py</vh></v>
<v t="ekr.20050912125735.184"><vh>mod_timestamp.py</vh></v>
<v t="TL.20090225194539.1"><vh>nodeActions.py</vh></v>
<v t="ekr.20050912125735.186"><vh>outline_export.py</vh></v>
<v t="ekr.20060928200600"><vh>paste_as_headlines.py</vh></v>
<v t="ekr.20050912125735.188"><vh>pretty_print.py</vh></v>
<v t="ekr.20050912125735.204"><vh>scheduler.py</vh></v>
<v t="ekr.20050912125735.318"><vh>table.py</vh></v>
<v t="ekr.20050912125735.225"><vh>templates.py</vh></v>
<v t="ekr.20060928201227"><vh>word_cound.py</vh></v>
</v>
<v t="bob.20080110214217"><vh>Dialogs</vh>
<v t="bob.20080110214217.1"><vh>gtkDialogs</vh></v>
</v>
<v t="ekr.20050912125735.334"><vh>Debugging &amp;  testing</vh>
<v t="ekr.20050912125735.335"><vh>failed_import.py</vh></v>
<v t="ekr.20050912125735.336"><vh>dump_globals.py</vh></v>
<v t="ekr.20050912125735.338"><vh>enable_gc.py</vh></v>
<v t="ekr.20050912125735.341"><vh>trace_gc.py</vh></v>
<v t="ekr.20050912125735.344"><vh>trace_keys.py</vh></v>
<v t="ekr.20050912125735.346"><vh>trace_tags.py</vh></v>
</v>
<v t="ekr.20050912125735.2712"><vh>External editors &amp; Open With</vh>
<v t="ekr.20050912125735.2713"><vh>mod_tempfname.py</vh></v>
<v t="ekr.20050912125735.2716"><vh>open_shell.py</vh></v>
<v t="ekr.20050912125735.2726"><vh>open_with.py</vh></v>
<v t="ekr.20050912125735.3209"><vh>temacs.py &amp; usetemacs.py</vh></v>
<v t="ekr.20050912125735.2736"><vh>vim.py</vh></v>
<v t="ekr.20050912125735.2749"><vh>word_export.py</vh></v>
<v t="ekr.20050912125735.2743"><vh>xemacs.py</vh></v>
</v>
<v t="ekr.20050912125735.2759"><vh>Files</vh>
<v t="tbrown.20091203211538.14165"><vh>active_path.py</vh>
<v t="tbrown.20091203211538.20637"><vh>Settings</vh></v>
</v>
<v t="ekr.20050912125735.2760"><vh>empty_leo_file.py</vh></v>
<v t="ekr.20060920054924"><vh>leoOPML.py</vh></v>
<v t="ekr.20050912125735.2763"><vh>lineNumbers.py</vh></v>
<v t="ekr.20050912125735.2768"><vh>multifile.py</vh></v>
<v t="ekr.20050912125735.2779"><vh>niceNosent.py</vh></v>
<v t="ekr.20060928200207.1"><vh>leoToRTF</vh></v>
<v t="ekr.20060928200207.2"><vh>leoToHTML</vh></v>
<v t="ekr.20060928200207.3"><vh>leoOPML</vh></v>
</v>
<v t="bob.20080110221203"><vh>Guis</vh>
<v t="bob.20080110221203.1"><vh>__wx_alt_gui.py</vh></v>
</v>
<v t="ekr.20050912125735.980"><vh>Icon and status areas</vh>
<v t="ekr.20060601112502"><vh>chapter_hoist.py</vh></v>
<v t="ekr.20050912125735.981"><vh>nav_buttons.py</vh></v>
<v t="ville.20090520232138.11304"><vh>nav_qt.py</vh></v>
<v t="ekr.20050912125735.1008"><vh>newButtons.py</vh></v>
<v t="ekr.20050912125735.1041"><vh>hoist.py</vh></v>
<v t="ekr.20050912125735.1050"><vh>nodenavigator.py</vh></v>
<v t="ekr.20050912125735.1072"><vh>searchbox.py</vh></v>
<v t="ekr.20060603081045"><vh>shortcut_button.py</vh></v>
<v t="bobjack.20080613141524.2"><vh>toolbar.py</vh></v>
<v t="ekr.20050912125735.1092"><vh>UNL.py</vh></v>
<v t="ville.20090520232138.11305"><vh>quicksearch.py</vh></v>
<v t="ville.20090520235245.10337"><vh>colorize_headlines.py</vh></v>
</v>
<v t="ekr.20050912125735.2786"><vh>LeoN</vh></v>
<v t="ekr.20050912125735.2826"><vh>Menus &amp; translations</vh>
<v t="ekr.20050912125735.2828"><vh>chinese_menu.py</vh></v>
<v t="ekr.20050912125735.2836"><vh>french_fm.py</vh></v>
<v t="ekr.20050912125735.2844"><vh>pie_menus.py</vh></v>
<v t="ville.20090704073251.9442"><vh>contextmenu.py</vh></v>
</v>
<v t="ekr.20050912125735.525"><vh>Nodes</vh>
<v t="ekr.20050912125735.526"><vh>at_folder.py</vh></v>
<v t="ekr.20050912125735.529"><vh>at_produce.py</vh></v>
<v t="ekr.20050912125735.540"><vh>at_view.py</vh></v>
<v t="ekr.20050912125735.699"><vh>autotrees.py</vh></v>
<v t="ekr.20050912125735.556"><vh>base64Packager.py</vh></v>
<v t="ekr.20050912125735.565"><vh>fastGotoNode.py</vh></v>
<v t="ekr.20050912125735.597"><vh>mod_labels.py</vh></v>
<v t="ekr.20091216113613.6638"><vh>quickmove.py</vh></v>
<v t="ekr.20050912125735.647"><vh>read_only_nodes.py</vh></v>
<v t="ekr.20050912125735.674"><vh>run_nodes.py</vh></v>
<v t="ekr.20060928201227.1"><vh>slideshow.py</vh></v>
<v t="ekr.20050912125735.694"><vh>startfile.py</vh></v>
</v>
<v t="ekr.20050912125735.2867"><vh>Plugins manager &amp; menu</vh>
<v t="ekr.20050912125735.3040"><vh>leoupdate.py</vh></v>
<v t="ekr.20050912125735.2918"><vh>plugin_manager.py</vh></v>
<v t="ekr.20050912125735.2869"><vh>plugins_menu.py</vh></v>
</v>
<v t="ekr.20050912125735.3056"><vh>Scripting</vh>
<v t="ekr.20050912125735.363"><vh>dyna_menu</vh></v>
<v t="ekr.20050912125735.3057"><vh>mod_scripting</vh></v>
</v>
<v t="ekr.20050912125735.3077"><vh>Servers</vh>
<v t="ekr.20050912125735.3078"><vh>mod_http.py</vh></v>
</v>
<v t="ekr.20050912125735.3136"><vh>Spell checking</vh>
<v t="ekr.20050912125735.3138"><vh>spellpyx.py</vh></v>
</v>
<v t="ekr.20050912125735.3559"><vh>Text formatting</vh>
<v t="ekr.20050912125735.3642"><vh>Leo to AsciiDoc</vh></v>
<v t="ekr.20050912125735.3832"><vh>rst3.py</vh></v>
<v t="ekr.20050912125735.3621"><vh>xsltWithNodes.py</vh></v>
</v>
<v t="ekr.20050912125735.1105"><vh>Windows</vh>
<v t="ekr.20050912125735.1135"><vh>cleo.py</vh></v>
<v t="ekr.20050912125735.1187"><vh>footprints.py</vh></v>
<v t="ekr.20050912125735.1285"><vh>EditAttributes.py</vh></v>
<v t="ekr.20050912125735.1299"><vh>maximizeNewWindows.py</vh></v>
<v t="ekr.20050912125735.1301"><vh>nodebar.py</vh></v>
<v t="ekr.20050912125735.1316"><vh>redirect_to_log.py</vh></v>
<v t="ekr.20050912125735.1317"><vh>TabbedLog.py</vh></v>
<v t="ekr.20050912125735.1323"><vh>UASearch.py</vh></v>
<v t="ekr.20050912125735.1333"><vh>UniversalScrolling.py</vh></v>
<v t="ekr.20050912125735.1342"><vh>URLloader.py</vh></v>
</v>
</v>
</v>
<v t="ekr.20060612102055"><vh>Chapter 13: Writing Plugins</vh>
<v t="ekr.20060612103240"><vh>@rst html\writingPlugins.html</vh>
<v t="ekr.20060612103824"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050903075144"><vh>Overview</vh></v>
<v t="EKR.20040524104904.240"><vh>Support for unit testing</vh></v>
<v t="ekr.20060621075135"><vh>Turning script buttons into plugins</vh></v>
<v t="EKR.20040524104904.224"><vh>Important security warnings</vh></v>
<v t="ekr.20071021101506"><vh>@rst-ignore menu convenience routines</vh></v>
</v>
</v>
<v t="ekr.20050831184021.1"><vh>Chapter 14: Leo and reStructuredText</vh>
<v t="ekr.20050818163826"><vh>@rst html\rstplugin3.html</vh>
<v t="ekr.20050818163826.1"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050818163826.2"><vh>Overview</vh></v>
<v t="ekr.20050818163826.3"><vh>Power features of @rst trees</vh></v>
<v t="ekr.20050818163826.4"><vh>Options</vh>
<v t="ekr.20050818163826.5"><vh>Options supporting the http plugin</vh></v>
<v t="ekr.20050818163826.6"><vh>Options that set command names</vh></v>
</v>
<v t="ekr.20050818163826.7"><vh>Headline Commands</vh></v>
<v t="ekr.20050818163826.8"><vh>Using doc parts</vh></v>
<v t="ekr.20050818163826.9"><vh>Setting defaults</vh></v>
<v t="ekr.20050818163826.10"><vh>The code-block directive</vh></v>
<v t="ekr.20050818163826.11"><vh>Required cascading style sheets</vh></v>
<v t="ekr.20050818163826.12"><vh>Notes about rST markup</vh></v>
<v t="ekr.20050818163826.13"><vh>Examples</vh></v>
<v t="ekr.20050818163826.14"><vh>Theory of operation</vh></v>
<v t="ekr.20060527103630"><vh>Controlling the rst3 command from scripts</vh></v>
<v t="ekr.20050818163826.16"><vh>Acknowledgements</vh></v>
</v>
</v>
<v t="ekr.20060430221745"><vh>Chapter 15: Controlling syntax coloring</vh>
<v t="ekr.20060430221745.1"><vh>@rst html\coloring.html</vh>
<v t="ekr.20060430222753"><vh>@rst-no-head links</vh></v>
<v t="ekr.20060430220749"><vh>Files</vh></v>
<v t="ekr.20060502084233"><vh>The colorizer's inner loop</vh></v>
<v t="ekr.20060502084233.1"><vh>Format of colorizer control files</vh>
<v t="ekr.20060502100550"><vh>Ruleset names</vh></v>
<v t="ekr.20060502090516"><vh>x.properties</vh></v>
<v t="ekr.20060510085547"><vh>Attribute dictionaries and x.attributesDictDict</vh></v>
<v t="ekr.20060502090516.1"><vh>Keyword dictionaries and x.keywordsDictDict</vh></v>
<v t="ekr.20060502090516.2"><vh>Rules, rules dictionaries and x.rulesDictDict</vh></v>
<v t="ekr.20060503072213"><vh>x.importDict and imported versus delegated rulesets</vh></v>
</v>
<v t="ekr.20060502122950"><vh>Rule methods</vh>
<v t="ekr.20060503064515"><vh>Arguments to rule methods</vh></v>
<v t="ekr.20060502122950.7"><vh>match_eol_span</vh></v>
<v t="ekr.20060502122950.10"><vh>match_eol_span_regexp</vh></v>
<v t="ekr.20060502122950.13"><vh>match_keywords</vh></v>
<v t="ekr.20060502122950.14"><vh>match_mark_following</vh></v>
<v t="ekr.20060502125223"><vh>match_mark_previous</vh></v>
<v t="ekr.20060502122950.40"><vh>match_seq</vh></v>
<v t="ekr.20060502122950.41"><vh>match_seq_regexp</vh></v>
<v t="ekr.20060502122950.42"><vh>match_span</vh></v>
<v t="ekr.20060502122950.47"><vh>match_span_regexp</vh></v>
<v t="ekr.20060502122950.48"><vh>match_terminate</vh></v>
</v>
<v t="ekr.20060830142929"><vh>Syntax coloring settings</vh></v>
<v t="ekr.20070724081553"><vh>The threading_colorizer plugin</vh></v>
</v>
</v>
<v t="ekr.20060527105211"><vh>Chapter 16: Debugging with Leo</vh>
<v t="ekr.20060527105617"><vh>@rst html\debuggers.html</vh>
<v t="ekr.20060527105804"><vh>@rst-no-head links</vh></v>
<v t="ekr.20070116062405"><vh>Using g.trace and g.pdb</vh></v>
<v t="ekr.20060527112801"><vh>Settings for winpdb</vh></v>
<v t="ekr.20070115172724"><vh>Debugging scripts with winpdb</vh>
<v t="ekr.20070115172724.1"><vh>The debug command</vh></v>
<v t="ekr.20070115172724.2"><vh>@button winpdb</vh></v>
<v t="ekr.20070115172724.3"><vh>The execute-script command with explicit debugger breaks</vh></v>
</v>
</v>
</v>
<v t="ekr.20060913164304"><vh>Chapter 17: Using ZODB with Leo</vh>
<v t="ekr.20060913164304.1"><vh>@rst html\zodb.html</vh>
<v t="ekr.20060913164311"><vh>@rst-no-head links</vh></v>
<v t="ekr.20060913170145"><vh>Configuring Leo to use zodb</vh></v>
<v t="ekr.20060913170403"><vh>Initing zodb</vh></v>
<v t="ekr.20060913170403.1"><vh>Writing data to zodb</vh></v>
<v t="ekr.20060913175437"><vh>Defining zodb keys</vh></v>
<v t="ekr.20060913170403.2"><vh>Reading data from zodb</vh></v>
<v t="ekr.20060913175437.1"><vh>About connections</vh></v>
<v t="ekr.20060913165542.1"><vh>Convenience routines</vh>
<v t="ekr.20060913165542.2"><vh>g.init_zodb (pathToZodbStorage,verbose=True)</vh></v>
<v t="ekr.20060913165542.3"><vh>v.detach()</vh></v>
</v>
</v>
</v>
<v t="ekr.20061025065357"><vh>Chapter 18: Leo and Emacs</vh>
<v t="ekr.20061025065357.1"><vh>@rst html\emacs.html</vh>
<v t="ekr.20061025065357.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20061025081359"><vh>Controlling Leo from Emacs using Pymacs</vh></v>
<v t="ekr.20061025070825.1"><vh>Functions in leoPymacs.py</vh></v>
<v t="ekr.20061025142434"><vh>The minibuffer</vh></v>
</v>
</v>
<v t="ekr.20070317033759"><vh>Chapter 19: Embedding Leo with the leoBridge module</vh>
<v t="ekr.20070317033759.1"><vh>@rst html\leoBridge.html</vh>
<v t="ekr.20070317033759.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20070317033759.3"><vh>The basics</vh></v>
<v t="ekr.20071210094621"><vh>Running leoBridge from within Leo</vh></v>
</v>
</v>
<v t="ekr.20070628083442"><vh>Chapter 20: Unit testing with Leo</vh>
<v t="ekr.20070628083442.1"><vh>@rst html\unitTesting.html</vh>
<v t="ekr.20070628083442.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20070704074747"><vh>Overview</vh></v>
<v t="ekr.20070628084351"><vh>Using @test nodes</vh></v>
<v t="ekr.20070628094515.1"><vh>Using @suite nodes</vh></v>
<v t="ekr.20070628094515.2"><vh>How the unit test commands work</vh></v>
<v t="ekr.20080729064227.6"><vh>@button timer</vh></v>
<v t="ekr.20080729064227.7"><vh>@button profile</vh></v>
</v>
</v>
<v t="ekr.20080203101507"><vh>Chapter 21: ILeo - the IPython bridge</vh>
<v t="ekr.20080203101507.1"><vh>@rst html\IPythonBridge.html</vh>
<v t="ekr.20080203101507.2"><vh>@rst-no-head links</vh></v>
<v t="vivainio.20080302174639.1"><vh>Introduction</vh></v>
<v t="vivainio.20080302174639.2"><vh>Installation and startup</vh></v>
<v t="vivainio.20080302174639.3"><vh>Accessing IPython from Leo</vh></v>
<v t="vivainio.20080302174639.4"><vh>Accessing Leo nodes from IPython</vh></v>
<v t="vivainio.20080302174639.5"><vh>@cl definitions</vh></v>
<v t="vivainio.20080302174639.6"><vh>Special node types</vh></v>
<v t="vivainio.20080401152121.2"><vh>Launching ILeo from IPython</vh></v>
<v t="vivainio.20080302174639.7"><vh>Declaring custom push-to-ipython handlers</vh></v>
<v t="vivainio.20080302174639.8"><vh>Example code snippets</vh></v>
<v t="vivainio.20080318125834.2"><vh>Example use case: pylab</vh></v>
<v t="vivainio.20080302194307"><vh>Magic functions</vh></v>
<v t="vivainio.20080302174639.9"><vh>Acknowledgements and history</vh></v>
<v t="vivainio.20080302174957"><vh>@rst-ignore Old documentation - not completely valid anymore</vh>
<v t="ekr.20080204100523.1"><vh>Commands</vh></v>
<v t="ekr.20080204100523"><vh>Startup</vh></v>
<v t="ekr.20080204100523.2"><vh>Scripting IPython from Leo</vh></v>
<v t="ekr.20080205080801"><vh>Scripting Leo from IPython</vh></v>
<v t="ekr.20080204100523.3"><vh>@rst-ignore User Settings</vh></v>
<v t="ekr.20080210101336"><vh>Acknowledgements</vh></v>
</v>
</v>
</v>
<v t="TL.20080804095315.1"><vh>Chapter 22: Using Vim with Leo</vh>
<v t="TL.20080804095315.2"><vh>@rst html\vimBindings.html</vh>
<v t="TL.20080804095315.3"><vh>@rst-no-head links</vh></v>
<v t="TL.20080804095315.11"><vh>Vim bindings</vh>
<v t="TL.20080804095315.4"><vh>Installing vim bindings</vh></v>
<v t="TL.20080804095315.5"><vh>General commands</vh></v>
<v t="TL.20080804095315.6"><vh>Body pane commands</vh></v>
<v t="TL.20080804095315.7"><vh>Outline commands</vh></v>
<v t="TL.20080804095315.8"><vh>Commands not supported</vh></v>
</v>
<v t="TL.20080804095315.9"><vh>Avoiding changes to 'tag' files</vh></v>
</v>
</v>
<v t="ekr.20080730212711.14"><vh>Chapter 23: Using @shadow</vh>
<v t="ekr.20080730212711.15"><vh>@rst html\atShadow.html</vh>
<v t="ekr.20080730212711.16"><vh>@rst-no-head links</vh></v>
<v t="ekr.20080730212711.39"><vh>Overview</vh></v>
<v t="ekr.20080730212711.42"><vh>Creating @shadow trees</vh></v>
<v t="ekr.20080730212711.40"><vh>What the update algorithm does</vh></v>
<v t="ekr.20080730212711.52"><vh>Aha: boundary cases don't matter</vh></v>
</v>
</v>
<v t="EKR.20040524104904.274"><vh>Appendices</vh>
<v t="ekr.20050831231852"><vh>@rst html\appendices.html</vh>
<v t="ekr.20050831232205"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.351"><vh>Bugs</vh></v>
<v t="EKR.20040524104904.307"><vh>Errors while tangling</vh></v>
<v t="EKR.20040524104904.327"><vh>Errors while untangling</vh></v>
<v t="EKR.20040524104904.333"><vh>Errors while reading @file nodes</vh></v>
<v t="EKR.20040524104904.336"><vh>Errors while writing @file nodes</vh></v>
<v t="EKR.20040524104904.357"><vh>Format of .leo files</vh></v>
<v t="ekr.20060921064744.1"><vh>Format of external files</vh></v>
<v t="EKR.20040524104904.354"><vh>Unicode reference</vh></v>
</v>
</v>
<v t="ekr.20091111112709.6671"><vh>Glossary</vh>
<v t="ekr.20091111112709.6672"><vh>@rst html\glossary.html</vh>
<v t="ekr.20091111112709.6676"><vh>@rst-no-head links</vh></v>
</v>
<v t="ekr.20091111112709.6677"><vh>To be rewritten</vh></v>
</v>
<v t="ekr.20060620094033"><vh>What's New...</vh>
<v t="ekr.20100129054823.11924"><vh>What's New in Leo 4.7</vh>
<v t="ekr.20100129054823.11925"><vh>@rst html\new-4-7.html</vh>
<v t="ekr.20100129054823.11926"><vh>@rst-no-head links</vh></v>
<v t="ekr.20100129054823.17680"><vh>Leo supports Python 3.x</vh></v>
<v t="ekr.20100129054823.11928"><vh>Improved file handling</vh></v>
<v t="ekr.20100129054823.11931"><vh>New command-line options</vh></v>
<v t="ekr.20100211221936.7098"><vh>New commands</vh></v>
<v t="ekr.20100129054823.11934"><vh>New settings</vh></v>
<v t="ekr.20100129054823.11935"><vh>Improved plugins</vh></v>
</v>
</v>
<v t="ekr.20090324145450.20"><vh>What's New in Leo 4.6</vh>
<v t="ekr.20090324145450.21"><vh>@rst html\new-4-6.html</vh>
<v t="ekr.20090324145450.22"><vh>@rst-no-head links</vh></v>
<v t="ekr.20090620073906.12095"><vh>Improved unit testing</vh></v>
<v t="ekr.20090324145450.23"><vh>Improved file handling</vh></v>
<v t="ekr.20090620082840.5608"><vh>Improved handling of rST files</vh></v>
<v t="ekr.20090324145450.27"><vh>New code features</vh></v>
<v t="ekr.20090324145450.36"><vh>New command-line options</vh></v>
<v t="ekr.20090324145450.40"><vh>New commands</vh></v>
<v t="ekr.20090324145450.46"><vh>New and improved directives</vh></v>
<v t="ekr.20090324145450.49"><vh>New settings</vh></v>
<v t="ekr.20090324145450.54"><vh>Plugins</vh></v>
</v>
</v>
<v t="ekr.20080806211440.185"><vh>What's New in Leo 4.5</vh>
<v t="ekr.20080806211440.186"><vh>@rst html\new-4-5.html</vh>
<v t="ekr.20080806211440.187"><vh>@rst-no-head links</vh></v>
<v t="ekr.20080806211440.188"><vh>Major new features</vh></v>
<v t="ekr.20080806211440.253"><vh>Major code reorganizations</vh></v>
<v t="ekr.20080806211440.256"><vh>Minor new features</vh></v>
<v t="ekr.20080806211440.189"><vh>New settings</vh></v>
</v>
</v>
<v t="ekr.20080314081157.127"><vh>What's New in Leo 4.4.8</vh>
<v t="ekr.20080314081157.121"><vh>@rst html\new-4-4-8.html</vh>
<v t="ekr.20080314081157.122"><vh>@rst-no-head links</vh></v>
<v t="ekr.20080314081157.124"><vh>New features</vh></v>
<v t="ekr.20080314081157.128"><vh>New and improved plugins</vh></v>
<v t="ekr.20080314081157.125"><vh>New settings</vh></v>
</v>
</v>
<v t="ekr.20071217093444"><vh>What's New in Leo 4.4.6</vh>
<v t="ekr.20071217093444.1"><vh>@rst html\new-4-4-6.html</vh>
<v t="ekr.20071217093444.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20071217093444.5"><vh>New commands</vh></v>
<v t="ekr.20080116071239"><vh>New features</vh></v>
<v t="ekr.20071217093444.6"><vh>New settings</vh></v>
</v>
</v>
<v t="ekr.20071116062917"><vh>What's New in Leo 4.4.5</vh>
<v t="ekr.20071116062917.1"><vh>@rst html\new-4-4-5.html</vh>
<v t="ekr.20071116062917.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20071116063202"><vh>Bug fixed</vh></v>
<v t="ekr.20071116062917.3"><vh>New features</vh></v>
<v t="ekr.20071116062917.18"><vh>New commands</vh></v>
<v t="ekr.20071116063649"><vh>New settings</vh></v>
</v>
</v>
<v t="ekr.20070809145744"><vh>What's New in Leo 4.4.4</vh>
<v t="ekr.20070809145744.1"><vh>@rst html\new-4-4-4.html</vh>
<v t="ekr.20070809145744.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20070809145744.3"><vh>@rst-ignore Important new features</vh></v>
<v t="ekr.20071004103659"><vh>The Great Graph Aha</vh></v>
<v t="ekr.20070806090226.15"><vh>Added support for @auto files</vh>
<v t="ekr.20070806095535.1"><vh>What @auto does</vh></v>
<v t="ekr.20070809141529"><vh>Perfect import checks</vh></v>
<v t="ekr.20070806101412"><vh>Commands related to @auto</vh></v>
<v t="ekr.20070806100055"><vh>Extending the code: adding new parsers</vh></v>
</v>
<v t="ekr.20070920092716"><vh>New commands for resolving cvs conflicts</vh></v>
<v t="ekr.20070809145744.5"><vh>New kinds of settings trees</vh>
<v t="ekr.20071001122703"><vh>@buttons trees</vh></v>
<v t="ekr.20071004110818"><vh>@menus trees</vh></v>
</v>
<v t="ekr.20070809145744.6"><vh>New plugins</vh></v>
<v t="ekr.20071005100213"><vh>Leo's core is now compatible with jython</vh></v>
<v t="ekr.20071026180804"><vh>Improved prototype for icons in headlines</vh></v>
<v t="ekr.20070809145744.7"><vh>Minor improvements</vh></v>
<v t="ekr.20070809145744.4"><vh>Summary of new commands</vh></v>
</v>
</v>
<v t="ekr.20070513113903"><vh>What's New in Leo 4.4.3</vh>
<v t="ekr.20070513113931"><vh>@rst html\new-4-4-3.html</vh>
<v t="ekr.20070513113931.1"><vh>@rst-no-head links</vh>
<v t="ekr.20070513115832.2"><vh>Important new features</vh></v>
<v t="ekr.20070513115832.1"><vh>New commands</vh></v>
<v t="ekr.20070513115832.3"><vh>New settings</vh></v>
<v t="ekr.20070513115832.4"><vh>Plugins</vh></v>
<v t="ekr.20070513115832.5"><vh>Minor improvements</vh></v>
</v>
</v>
</v>
<v t="ekr.20060928172457"><vh>What's New in Leo 4.4.2</vh>
<v t="ekr.20060928172457.1"><vh>@rst html\new-4-4-2.html</vh>
<v t="ekr.20060928172457.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20060929043325"><vh>A major code reorg</vh></v>
<v t="ekr.20061009111417.18"><vh>New commands</vh></v>
<v t="ekr.20060928172457.4"><vh>New features</vh></v>
<v t="ekr.20060928172457.5"><vh>New and improved plugins</vh></v>
<v t="ekr.20061009111417.11"><vh>Settings</vh></v>
<v t="ekr.20060929043325.1"><vh>ZODB scripting</vh></v>
</v>
</v>
<v t="ekr.20060620094033.1"><vh>What's New in Leo 4.4.1 and 4.4.1.1</vh>
<v t="ekr.20060620094645.310"><vh>@rst html\new-4-4-1.html</vh>
<v t="ekr.20060621132547"><vh>@rst-no-head links</vh></v>
<v t="ekr.20060620130636"><vh>New commands</vh></v>
<v t="ekr.20060620095949.15"><vh>New features</vh></v>
<v t="ekr.20060620130943"><vh>New and improved plugins</vh></v>
<v t="ekr.20060620095949.25"><vh>New settings</vh></v>
<v t="ekr.20070622212732"><vh>Improved settings</vh></v>
<v t="ekr.20060620095655"><vh>Minor improvements</vh></v>
</v>
</v>
<v t="ekr.20060620094033.2"><vh>What's New in Leo 4.4</vh>
<v t="ekr.20060620094425"><vh>@rst html\new-4-4.html</vh>
<v t="ekr.20060621132338"><vh>@rst-no-head links</vh></v>
<v t="ekr.20070622212132"><vh>New commands</vh></v>
<v t="ekr.20060620133820.16"><vh>New features</vh></v>
<v t="ekr.20071004101443.178"><vh>Added new convenience methods for scripts and plugins</vh></v>
<v t="ekr.20060620140130"><vh>New and improved plugins</vh></v>
<v t="ekr.20060620140228"><vh>New and improved settings</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20090717084250.10702"><vh>Other docs</vh>
<v t="ekr.20090428101858.1"><vh> How to generate Leo's Sphinx docs</vh></v>
<v t="EKR.20040524104904.380"><vh>OLD Glossary</vh>
<v t="ekr.20050901071041"><vh>@@rst html\glossary.html</vh>
<v t="ekr.20050901071300"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050901073048"><vh>@rst-no-head glossary</vh></v>
</v>
</v>
<v t="ekr.20080301071818"><vh>Home page</vh>
<v t="ekr.20080306071848"><vh>&lt;&lt; download ref &gt;&gt; (contains version number)</vh></v>
<v t="ekr.20080301071818.1"><vh>@thin html/front.html</vh></v>
</v>
<v t="ekr.20090711120622.10446"><vh>Screen shots page</vh>
<v t="ekr.20090711120622.10447"><vh>@rst html/screen-shots.html</vh>
<v t="ekr.20090811090022.14451"><vh>@rst-no-head links</vh></v>
<v t="ekr.20090811090022.14452"><vh>Windows screen shots</vh></v>
<v t="ekr.20090811090022.14453"><vh>Linux screen shots</vh></v>
</v>
</v>
<v t="ekr.20090428133936.2"><vh>@edit html\conf.py</vh></v>
<v t="ekr.20090428102353.1"><vh>@edit html\leo_toc.html.txt</vh></v>
<v t="ville.20090609182215.5676"><vh>@auto-rst treecaching.txt</vh></v>
<v t="ekr.20090526102407.10028"><vh>Important notes about Leo's code</vh>
<v t="ekr.20090526102407.10029"><vh>How to profile Leo</vh></v>
<v t="ekr.20090526102407.10030"><vh>High-level code notes</vh>
<v t="ekr.20090526102407.10031"><vh>leoFileCommands.py and leoAtFile.py</vh></v>
<v t="ekr.20090526102407.10032"><vh>Leo's MVC architecture</vh></v>
</v>
</v>
<v t="ekr.20090401113141.1"><vh>How to generate odt/rtf/pdf files</vh>
<v t="ekr.20090620131445.5595"><vh>Post from ville</vh></v>
<v t="ekr.20090401113141.2"><vh>@rst c:\prog\test\test.html</vh>
<v t="ekr.20090401113141.4"><vh>section 1</vh></v>
</v>
</v>
<v t="ekr.20091107093823.6790"><vh>Leo Tech report</vh>
<v t="ekr.20091107093823.6791"><vh>@rst html\techReport.html</vh>
<v t="ekr.20091107093823.6792"><vh>Old</vh>
<v t="ekr.20091107093823.6793"><vh>Leos window, outlines &amp; clones</vh></v>
<v t="ekr.20091107093823.6794"><vh>Relations: organizer nodes, views, tasks and metadata</vh></v>
<v t="ekr.20091107093823.6795"><vh>Plugins</vh></v>
<v t="ekr.20091107093823.6796"><vh>Derived files and special nodes</vh></v>
<v t="ekr.20091107093823.6797"><vh>Markup for scripts</vh></v>
<v t="ekr.20091107093823.6798"><vh>Scripting Leo</vh></v>
<v t="ekr.20091107093823.6799"><vh>Leos modules and classes</vh></v>
<v t="ekr.20091107093823.6800"><vh>Predefined symbols in scripts</vh></v>
<v t="ekr.20091107093823.6801"><vh>Accessing data</vh></v>
<v t="ekr.20091107093823.6802"><vh>Traversing outlines</vh></v>
<v t="ekr.20091107093823.6803"><vh>Executing commands from scripts</vh></v>
<v t="ekr.20091107093823.6804"><vh>Bringing scripts to data</vh></v>
<v t="ekr.20091107093823.6805"><vh>Unit Testing with @test and @suite nodes</vh></v>
<v t="ekr.20091107093823.6806"><vh>Plugins and hooks</vh></v>
<v t="ekr.20091107093823.6807"><vh>Contacts</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20100129054823.11924"></v>
<v t="edream.110203163054.46"><vh>Release Notes</vh>
<v t="edream.110203163054.117"><vh>Previous versions...</vh>
<v t="ekr.20050210102358"><vh>4.0... New read logic eliminates read errors, eliminated child indices</vh>
<v t="edream.110203163054.66"><vh>4.0.1 through 4.0.4</vh></v>
<v t="edream.110203163054.67"><vh>4.0 final</vh>
<v t="edream.110203163054.68"><vh>4.0 beta 4</vh></v>
<v t="edream.110203163054.69"><vh>4.0 beta 3</vh>
<v t="edream.110203163054.70"><vh>Fixed bugs</vh>
<v t="edream.110203163054.71"><vh>Fixed bug that caused some clones not to be marked as clones</vh></v>
<v t="edream.110203163054.72"><vh>Corrected problems with setting icons on Linux</vh></v>
<v t="edream.110203163054.73"><vh>Fixed crasher in sentinelName</vh></v>
<v t="edream.110203163054.74"><vh>Reenabled orphans &amp; ignored test in new write logic</vh></v>
</v>
<v t="edream.110203163054.75"><vh>New features</vh>
<v t="edream.110203163054.76"><vh>Added support for unknown tnode and vnode attributes</vh></v>
<v t="edream.110203163054.77"><vh>Added build number to signon</vh></v>
<v t="edream.110203163054.78"><vh>Added better error message in setDefaultIcon</vh></v>
</v>
</v>
<v t="edream.110203163054.79"><vh>4.0 beta 2</vh>
<v t="edream.110203163054.80"><vh>To-do for 4.0 final</vh></v>
<v t="edream.110203163054.81"><vh>Fixed Bugs</vh>
<v t="edream.110203163054.82"><vh>Added crucial defensive checks in v.headString() and v.bodySting()</vh></v>
<v t="edream.110203163054.83"><vh>Ensured newlines before all sentinels in @rawfile</vh></v>
<v t="edream.110203163054.84"><vh>Fixed bugs involving find params</vh></v>
<v t="edream.110203163054.85"><vh>Fixed Python Import bug</vh></v>
<v t="edream.110203163054.86"><vh>Fixed several more unicode bugs</vh></v>
<v t="edream.110203163054.87"><vh>Fixed crasher in Go To Outline command.</vh></v>
<v t="edream.110203163054.88"><vh>Fixed @rawfile write problem</vh></v>
</v>
<v t="edream.110203163054.89"><vh>Improved commands</vh>
<v t="edream.110203163054.90"><vh>Finished Import External File command and made it undoable</vh></v>
<v t="edream.110203163054.91"><vh>Moved Clear Recent Files menu item into Recent Files menu</vh></v>
<v t="edream.110203163054.92"><vh>Added better log message for Convert All Tabs/Blanks commands</vh></v>
<v t="edream.110203163054.93"><vh>Marked changed nodes &amp; make the @file node and the outline dirty.</vh></v>
<v t="edream.110203163054.94"><vh>Rewrote icon code so it doesn't use PIL or tkIcon in Python 2.3</vh></v>
<v t="edream.110203163054.95"><vh>Created leoGui base class for tkinterGui class</vh></v>
</v>
<v t="edream.110203163054.96"><vh>New and improved settings</vh>
<v t="edream.110203163054.97"><vh>Added support for two new settings affecting drags</vh></v>
<v t="edream.110203163054.98"><vh>changed default for config.write_old_format_derived_files</vh></v>
</v>
</v>
<v t="edream.110203163054.99"><vh>4.0 beta 1</vh>
<v t="edream.110203163054.100"><vh>4.0 Theory of operation</vh></v>
<v t="edream.110203163054.101"><vh>New commands &amp; options</vh>
<v t="edream.110203163054.102"><vh>New write_old_format_derived_files option</vh></v>
<v t="edream.110203163054.103"><vh>New Clear Recent Files command</vh></v>
<v t="edream.110203163054.104"><vh>New Import External File command</vh></v>
<v t="edream.110203163054.105"><vh>New Write 3.x/4.x External Files &amp; autosave</vh></v>
</v>
<v t="edream.110203163054.106"><vh>New plugins</vh></v>
<v t="edream.110203163054.107"><vh>New read logic and greatly inproved error recovery</vh>
<v t="edream.110203163054.108"><vh>Added test for unvisited nodes in read logic</vh></v>
<v t="edream.110203163054.109"><vh>Error recovery is _much_ better than before</vh></v>
</v>
<v t="edream.110203163054.110"><vh>Improvements &amp; bug fixes</vh>
<v t="edream.110203163054.111"><vh>Added horizontal scrollbar in body pane when @nowrap in effect</vh></v>
<v t="edream.110203163054.112"><vh>Added support for Python 2.3</vh></v>
<v t="edream.110203163054.113"><vh>Leo recycles window objects only if more than one window open</vh></v>
<v t="edream.110203163054.114"><vh>Removed "not undoable" message from Read @file Nodes command</vh></v>
<v t="edream.110203163054.115"><vh>Removed Open Python Window command</vh></v>
<v t="edream.110203163054.116"><vh>Simplified read and write code</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050210102150.1"><vh>4.1... gnx's</vh>
<v t="ekr.20040216151748"><vh>4.1 final</vh>
<v t="ekr.20040217085036"><vh>Added several new plugins</vh></v>
<v t="ekr.20040216152948"><vh>Added Toggle Angle Brackets command</vh></v>
<v t="ekr.20040216153725"><vh>Changed Undo/Redo messages</vh></v>
<v t="ekr.20040217075627"><vh>Fixed clone bug when pasting nodes</vh></v>
<v t="ekr.20040217085036.1"><vh>Investigated encoding problem: it's a Python 2.3 bug</vh></v>
</v>
<v t="ekr.20040131040356"><vh>4.1 rc4</vh>
<v t="ekr.20040201114855"><vh>New plugins in 4.1 rc4</vh>
<v t="ekr.20040201114855.42"><vh>mod_http.py plugin: Bernhard Mulder</vh></v>
<v t="ekr.20040201114855.91"><vh>newButtons.py plugin: Paul Paterson</vh></v>
<v t="ekr.20040201114855.29"><vh>nodenavigator.py plugin: Paul Paterson</vh></v>
<v t="ekr.20040201114855.36"><vh>rowcol.py: EKR</vh></v>
<v t="ekr.20040201114855.3"><vh>rst2.py plugin: Steve Zatz</vh></v>
<v t="ekr.20040201114855.13"><vh>searchbox.py plugin: Paul Paterson</vh></v>
<v t="ekr.20040201120903"><vh>status_line.py plugin: EKR</vh></v>
</v>
<v t="ekr.20040131041015"><vh>New features in 4.1 rc4</vh>
<v t="ekr.20040131040544.10"><vh>Leo no longer automatically draws the status area</vh></v>
<v t="ekr.20040131040544.21"><vh>Esc and enter key now work in the find panel</vh></v>
<v t="ekr.20040131040544.55"><vh>Improved message for orphan nodes</vh></v>
<v t="ekr.20040131040544.178"><vh>Eliminated marking nodes dirty unnecessarily</vh></v>
<v t="ekr.20040131040544.222"><vh>Execute Script command now ends all nodes with a newline</vh></v>
<v t="ekr.20040131040544.2"><vh>Added message when plugins are disabled</vh></v>
<v t="ekr.20040201061329"><vh>Created status_line.py plugin</vh></v>
<v t="ekr.20040201114855.105"><vh>Simplified operation of script-find/change &amp; improved documentation</vh>
<v t="edream.110603190322.6"><vh> Script Find and Script Change</vh>
<v t="edream.111803060152.1"><vh>How it works</vh></v>
<v t="ekr.20040201113232"><vh>Using the initScriptFind script</vh></v>
<v t="edream.111803060152.2"><vh>Ideas for using scripts</vh></v>
</v>
</v>
<v t="ekr.20040201114855.106"><vh>Added done message to Mark Changed commands</vh></v>
</v>
<v t="ekr.20040131040356.1"><vh>Bugs fixed in 4.1 rc4</vh>
<v t="ekr.20040131044727"><vh>Fixed several bugs when writing external files</vh></v>
<v t="ekr.20040131040754"><vh>Fixed several crashers</vh></v>
<v t="ekr.20040131040544.5"><vh>Fixed "bad leo file" when reading some 3.x .leo files</vh></v>
<v t="ekr.20040131040544.18"><vh>Fixed huge performance bug in cut/copy node commands</vh></v>
<v t="ekr.20040131040544.32"><vh>Leo now properly re-enables drawing after exceptions</vh></v>
<v t="ekr.20040201114855.107"><vh>Fixed major bug in tkFind.init</vh></v>
<v t="ekr.20040131040544.73"><vh>Fixed bug in Move Up command</vh></v>
<v t="ekr.20040131040544.81"><vh>Fixed bug in Import External File</vh></v>
<v t="ekr.20040131040544.146"><vh>Fixed bugs related to saving read-only files</vh></v>
<v t="ekr.20040131040544.169"><vh>Fixed bug in Import Python Window command when using Python 2.2</vh></v>
<v t="ekr.20040131040544.228"><vh>Fixed bugs in Convert All BlanksTabs commands</vh></v>
<v t="ekr.20040131040544.258"><vh>Fixed crashes in open_shell.py plugin</vh></v>
<v t="ekr.20040131044136"><vh>Fixed several bugs involving cut &amp; paste</vh></v>
<v t="ekr.20040131040544.227"><vh>Fixed whitespace problem in leoTkinterGui.py</vh></v>
<v t="ekr.20040131100557"><vh>Fixed glitches when inserting node in hoisted outline</vh></v>
<v t="ekr.20040203084228"><vh>Fixed bugs in search command</vh></v>
</v>
<v t="ekr.20040131040356.2"><vh>Bug fixed in previous 4.1 releases</vh></v>
<v t="ekr.20040131040356.3"><vh>New code-level features</vh></v>
<v t="ekr.20040131040356.4"><vh>New configuration settings</vh></v>
<v t="ekr.20040131040356.5"><vh>New features</vh></v>
</v>
<v t="edream.121403160546"><vh>4.1 rc3</vh>
<v t="edream.121403165221"><vh>Bugs fixed in this release</vh></v>
<v t="edream.121403161017"><vh>Bug fixed in previous 4.1 releases</vh></v>
<v t="edream.121403161017.1"><vh>New code-level features</vh></v>
<v t="edream.121403161017.2"><vh>New configuration settings</vh></v>
<v t="edream.121403161340"><vh>New features</vh></v>
</v>
<v t="edream.110603185805"><vh>4.1 beta 5</vh>
<v t="edream.120403174147"><vh>Changes made in 4.1 beta 5</vh>
<v t="edream.120403180443"><vh>New and improved features</vh>
<v t="edream.120403174147.105"><vh>Honor outline/body pane ratio when opening files</vh></v>
<v t="edream.120403174147.112"><vh>Leo now adjusts newly opened windows so they fit on the screen</vh></v>
<v t="edream.120403174147.119"><vh>Tested support for Unicode file &amp; directory names</vh></v>
<v t="edream.120403174147.128"><vh>Added code so @url nodes may open .leo files</vh></v>
<v t="edream.120403174147.56"><vh>Fixed problems with @lineending platform</vh></v>
</v>
<v t="edream.120403174241"><vh>Bugs fixed</vh>
<v t="edream.120403174147.30"><vh>Fixed crasher in Apply Settings command</vh></v>
<v t="edream.120403174147.102"><vh>Fixed crasher in Toggle Angle Brackets command</vh></v>
<v t="edream.120403174147.109"><vh>Fixed crasher when setting Icon in Linux)</vh></v>
<v t="edream.120403174147.33"><vh>Fixed Find panel bug on the Mac</vh></v>
<v t="edream.120403174147.36"><vh>Fixed Import backslash-newline bug</vh></v>
<v t="edream.120403174147.61"><vh>Fixed Linux import problem</vh></v>
<v t="edream.120403174147.63"><vh>Fixed Recent files crasher</vh></v>
<v t="edream.120403174147.65"><vh>Fixed Replace Blanks command</vh></v>
<v t="edream.110603190322.8"><vh>Fixed Serious Undo Change All bugs</vh></v>
<v t="edream.120403174147.94"><vh>Fixed several long-standing bugs related to Extract commands</vh></v>
</v>
</v>
<v t="edream.120403180443.1"><vh>Changes made in earlier 4.1 betas</vh>
<v t="edream.110603190234.1"><vh>Code-level features</vh>
<v t="edream.110603190125.3"><vh>Regression tests started</vh></v>
<v t="edream.110603190125.4"><vh>Code reorganized to support other guis</vh></v>
<v t="edream.110303182253.39"><vh>Made app.forceShutdown work in "idle" hook</vh></v>
</v>
<v t="edream.110603190404"><vh>Fixed bugs</vh>
<v t="edream.110603190322.13"><vh>Fixed bug involving 0x1a characters in body text.</vh></v>
<v t="edream.110603190322.11"><vh>Fixed first node-only find bug</vh></v>
<v t="edream.110603190322.3"><vh>Fixed bug in idle_body_key</vh></v>
<v t="edream.111803060643"><vh>Fixed LaTeX syntax coloring bug</vh></v>
</v>
<v t="edream.110603192009"><vh>Improved format of .leo files</vh>
<v t="edream.110603190322.9"><vh>Leo now ignores unknown prefs and find prefs</vh></v>
<v t="edream.110603190322.10"><vh>Leo now writes node_only find prefs</vh></v>
<v t="edream.110603190125.1"><vh>.leo files are now cvs-friendly</vh></v>
</v>
<v t="edream.110603192009.1"><vh>New &amp; improved commands</vh>
<v t="edream.112303173638"><vh>Running Leo in batch mode</vh></v>
<v t="edream.110203163054.833"><vh>Executing Python scripts in body text</vh></v>
<v t="edream.110603190322.14"><vh>Added Check Outline command</vh></v>
<v t="edream.110603190322.15"><vh>Added Hoist/De-Hoist commands</vh></v>
<v t="edream.111803060152"><vh>Added script-based find/change commands</vh>
<v t="edream.110603190322.6"></v>
</v>
<v t="edream.110303182253.3"><vh>Leo now does an auto-save only if files have actually been changed.</vh></v>
<v t="edream.111803062437"><vh>Shift commands now shift single line if no selection</vh></v>
</v>
<v t="edream.110303182719"><vh>New config settings</vh></v>
</v>
</v>
<v t="edream.110203163054.64"><vh>4.1 alpha 1</vh></v>
</v>
<v t="ekr.20050210102150"><vh>4.2... @file-thin, shared tnodes</vh>
<v t="ekr.20040922074200"><vh>4.2 final</vh></v>
<v t="ekr.20040914103359"><vh>4.2 rc1</vh>
<v t="ekr.20040914103743.1"><vh>Added new features</vh>
<v t="ekr.20040914103359.137"><vh>Added c.frame.openDirectory to sys.path when executing scripts</vh></v>
<v t="ekr.20040914103359.37"><vh>Added expanded_click_area option to disable left click logic in outline pane</vh></v>
<v t="ekr.20040914103359.2"><vh>Restored the "iconclick1/2" hooks</vh></v>
<v t="ekr.20040914103359.19"><vh>(Allow longer headlines for to support long url's)</vh>
<v t="ekr.20040914103359.20"><vh>Report</vh></v>
</v>
</v>
<v t="ekr.20040914103743"><vh>Fixed bugs</vh>
<v t="ekr.20040914103359.47"><vh>Disabled perfect import</vh></v>
<v t="ekr.20040914103359.127"><vh>Fixed bugs in Tangle/Untangle</vh></v>
<v t="ekr.20040914103359.12"><vh>Fixed Import External Files command</vh></v>
<v t="ekr.20040914103359.15"><vh>Fixed parsing of minimal &lt;preferences&gt; tag</vh></v>
<v t="ekr.20040914103359.7"><vh>Fixed problem with tabs on MacOs</vh></v>
<v t="ekr.20040914103359.28"><vh>Fixed read errors with @language html</vh></v>
<v t="ekr.20040914103359.4"><vh>Made sure a proper message is given with invalid versions of Python</vh></v>
<v t="ekr.20040914103359.110"><vh>Removed failed assert from colorizer</vh></v>
<v t="ekr.20040914103359.31"><vh>Removed spurious "Warning: updating changed text" messages</vh></v>
<v t="ekr.20040914103359.129"><vh>Shifted all Alt-shortcuts to Ctrl shortcuts on the Mac</vh></v>
</v>
</v>
<v t="ekr.20040713110718"><vh>4.2 beta 3</vh>
<v t="ekr.20040804165258.1"><vh>Bug fixes</vh>
<v t="ekr.20040804164600.16"><vh>Leo gives the user a chance to save read-only files</vh></v>
<v t="ekr.20040804164600.36"><vh>Fixed some unit-test bugs</vh></v>
<v t="ekr.20040804164600.56"><vh>Added 3 .cascading style sheets to the distribution list</vh></v>
<v t="ekr.20040804164600.98"><vh>Fixed some bugs in g.importFromPath</vh></v>
<v t="ekr.20040804164600.102"><vh>Fixed major bug in write logic</vh></v>
<v t="ekr.20040804164600.265"><vh>Fixed bug in p.isAncestorOf</vh></v>
<v t="ekr.20040804164600.275"><vh>Leo now writes only the currently selected tree when pasting to the clipboard</vh></v>
<v t="ekr.20040804164600.377"><vh>Fixed performance bug when reading .leo files</vh></v>
<v t="ekr.20040804170846"><vh>Leo now reports problems with bad directories more clearly</vh></v>
<v t="ekr.20040804164600.394"><vh>Leo reads collapsed xml tags properly in .leo files</vh></v>
<v t="ekr.20040804164600.406"><vh>Leo makes brings the confirm save box to the front</vh></v>
<v t="ekr.20040804164600.419"><vh>Improved how es_exception gets line number of errors</vh></v>
<v t="ekr.20040804164600.421"><vh>Fixed major bug: changing headline now marks subnodes dirty</vh></v>
<v t="ekr.20040804164600.470"><vh>Leo now gives update warning only once per external file</vh></v>
<v t="ekr.20040804164600.471"><vh>Leo updates tnodeLists properly in all situations</vh></v>
<v t="ekr.20040804164600.515"><vh>Fixed several leaks of positions</vh></v>
<v t="ekr.20040804171818"><vh>Fixed all unit tests so they work with both Python 2.2 and Python 2.3</vh></v>
</v>
<v t="ekr.20040804165258.2"><vh>Features</vh>
<v t="ekr.20040804172113"><vh>@test and @suite greatly aid unit testing</vh></v>
<v t="ekr.20040804172113.1"><vh>New scripts in test.leo make it very easy to use the gc, profile and timeit modules</vh></v>
<v t="ekr.20040804165258.3"><vh>Import dialogs allow multiple selections</vh></v>
<v t="ekr.20040804165258.4"><vh>New Check menu and commands</vh></v>
<v t="ekr.20040804170531"><vh>Perfect Import feature automatically corrects imported files</vh></v>
<v t="ekr.20040804170657"><vh>Improved performance of outline pane</vh></v>
<v t="ekr.20040804164600.424"><vh>The Go To Line Number command ignores all @all nodes</vh></v>
</v>
</v>
<v t="EKR.20040628095213"><vh>4.2 beta 1 &amp; beta 2</vh>
<v t="EKR.20040628095213.311"><vh>New coding conventions</vh></v>
<v t="EKR.20040524104904.242"><vh>Extending the format of .leo files</vh></v>
<v t="ekr.20040705111716"><vh>in 4.2 b2</vh>
<v t="ekr.20040705111716.1"><vh>Savedmarks and expantion state in &lt;v&gt; elements for @thin nodes</vh></v>
<v t="ekr.20040705111716.45"><vh>Marked all related @thin nodes dirty when a node changesd</vh></v>
<v t="ekr.20040705111716.126"><vh>Fixed bug when reading  4.1 files with topology errors</vh></v>
<v t="ekr.20040705150130"><vh>Leo passes all important pychecker tests</vh></v>
</v>
<v t="ekr.20040705112148"><vh>in 4.2 b1</vh>
<v t="EKR.20040628095213.513"><vh>Changed *nix install script</vh></v>
<v t="EKR.20040628100535"><vh>Fixed bugs</vh>
<v t="EKR.20040628095213.3"><vh>Made "end1" and "ilde"events work again</vh></v>
<v t="EKR.20040628095213.23"><vh>Put drawing hooks back in</vh></v>
<v t="EKR.20040628095213.56"><vh>Fixed syntax colouring Bug in html mode</vh></v>
<v t="EKR.20040628095213.60"><vh>Colorizing fixes</vh></v>
<v t="EKR.20040628095213.113"><vh>Fixed Select All bug</vh></v>
<v t="EKR.20040628095213.121"><vh>Fixed bugs in @tab_width: support backspace with negative tab width</vh></v>
<v t="EKR.20040628095213.143"><vh>Fixed bugs in Remove Sentinel command</vh></v>
<v t="EKR.20040628095213.160"><vh>Eliminated spurious error messages in Import External File command</vh></v>
<v t="EKR.20040628095213.192"><vh>Removed gnx in headlines when importing thin external files</vh></v>
<v t="EKR.20040628095213.202"><vh>Fixed bugs reading 4.1 files</vh></v>
<v t="EKR.20040628095213.213"><vh>Fixed Open With bug</vh></v>
<v t="EKR.20040628095213.225"><vh>Fixed Go To Line Number command</vh></v>
<v t="EKR.20040628095213.246"><vh>Fixed crash when importing Borland wstring.cpp</vh></v>
<v t="EKR.20040628095213.279"><vh>Fixed bug in insertBodyTime</vh></v>
<v t="EKR.20040628095213.297"><vh>Fixed bug when pasting large text into headlines</vh></v>
<v t="EKR.20040628095213.308"><vh>Fixed bug in delete command</vh></v>
<v t="EKR.20040628095213.312"><vh>Fixed oops: nullGui setIdleTimeHook</vh></v>
<v t="EKR.20040628095213.324"><vh>Fixed problems with trailing newlines and spurious changed bit</vh></v>
<v t="EKR.20040628095213.346"><vh>Fixed headline key handling</vh></v>
<v t="EKR.20040628095213.348"><vh>Fixed Problems executing script</vh></v>
<v t="EKR.20040628095213.354"><vh>Fixed problem with PHP and @last</vh></v>
<v t="EKR.20040628095213.366"><vh>Fixed bug when writing unknownAttributes</vh></v>
<v t="EKR.20040628095213.368"><vh>Fixed bugs opening a second file</vh></v>
<v t="EKR.20040628095213.404"><vh>Fixed bug: @last silently failed when extra lines exist</vh></v>
<v t="EKR.20040628095213.407"><vh>Fixed hang when dragging from one clone copy to another</vh></v>
<v t="EKR.20040628095213.412"><vh>Fixed crash in Write Missing</vh></v>
<v t="EKR.20040628095213.442"><vh>Fixed bug in getScript</vh></v>
<v t="EKR.20040628095213.444"><vh>Fixed problems with @all</vh></v>
<v t="EKR.20040628095213.499"><vh>Fixed double print in Execute Script command</vh></v>
<v t="EKR.20040628095213.512"><vh>Fixed bug reading leo.nsi</vh></v>
</v>
<v t="EKR.20040628100535.1"><vh>Added new features</vh>
<v t="EKR.20040628095213.52"><vh>Allowed &lt;/leo_header&gt; tag</vh></v>
<v t="EKR.20040628095213.109"><vh>Replaced the word "Leo" with Leo icon in Find/Compare/Prefs windows</vh></v>
<v t="EKR.20040628095213.110"><vh>Improved Import command slightly</vh></v>
<v t="EKR.20040628095213.197"><vh>Added 3 files to distribution lists</vh></v>
<v t="EKR.20040628095213.198"><vh>Supported @tabwidth in indent/dedent</vh></v>
<v t="EKR.20040628095213.264"><vh>Import now creates absolute path</vh></v>
<v t="EKR.20040628095213.269"><vh>Created @killcolor directive</vh></v>
<v t="EKR.20040628095213.282"><vh>Added Paste Retaining Clones command</vh></v>
<v t="EKR.20040628095213.314"><vh>Added readLineGenerator &amp; readLineClass to leoGlobals</vh></v>
<v t="EKR.20040628095213.334"><vh>Much better error handling in executeScript</vh></v>
<v t="EKR.20040628095213.377"><vh>Recovered nodes when reading .leo files containing topology errors</vh></v>
<v t="EKR.20040628095213.391"><vh>Generalized write-to-string logic</vh></v>
<v t="EKR.20040628095213.408"><vh>Added case_sensitiveLanguage to colorizer</vh></v>
<v t="EKR.20040628095213.425"><vh>Write entire @thin tree on write errors</vh></v>
<v t="EKR.20040628095213.485"><vh>Handled inner @language and @comment properly</vh></v>
<v t="EKR.20040628095213.490"><vh>Better reporting of body text conflicts</vh></v>
<v t="EKR.20040628095213.493"><vh>Improved error handling for unknownAttributes</vh></v>
<v t="EKR.20040628095213.501"><vh>Read and write all t.unknownAttributes in top vnode of an @thin tree</vh></v>
</v>
</v>
</v>
<v t="EKR.20040601084317"><vh>4.2 a3</vh>
<v t="EKR.20040601084317.2"><vh>Bug fixes</vh>
<v t="EKR.20040601101118"><vh>Fixed copy/paste operations involving @thin trees</vh></v>
<v t="EKR.20040601101430"><vh>Fixed Change Headline command</vh></v>
<v t="EKR.20040601084317.99"><vh>Eliminated spurious "Not written x.tmp" message after write errors</vh></v>
<v t="EKR.20040601084317.142"><vh>Fixed problems saving unknownAttribute field</vh></v>
<v t="EKR.20040601102115"><vh>Fixed unicode problem in the Dump Outline command</vh></v>
</v>
<v t="EKR.20040601101227"><vh>New Features</vh>
<v t="EKR.20040601101227.1"><vh>Leo ignores all directives in @all trees</vh></v>
<v t="EKR.20040601101430.1"><vh>@+-middle sentinels allow sections to be defined in grandchildren</vh></v>
<v t="EKR.20040601101510"><vh>@clone sentinel allows siblings to be cloned</vh></v>
<v t="EKR.20040601101547"><vh>Created @thin, @nosent, @noref and @asis abbreviations</vh>
<v t="EKR.20040524104904.92"><vh>Appendix 1 to Chapter 4: Using @asis, @noref and @nosent trees</vh></v>
</v>
<v t="EKR.20040601084317.102"><vh>Made undo extensible</vh></v>
<v t="EKR.20040601102703"><vh>Started work on simple new undo scheme</vh></v>
<v t="EKR.20040601084317.161"><vh>Created new c, p, v iterators</vh></v>
</v>
<v t="EKR.20040601102808"><vh>Known bugs</vh></v>
</v>
<v t="EKR.20040518070558"><vh>4.2 a2</vh>
<v t="EKR.20040518070940.5"><vh>Implemented @file-thin</vh></v>
<v t="EKR.20040518070824"><vh>Fixed bugs</vh>
<v t="EKR.20040518071415"><vh>Fixed clone bug that caused parts of outlines to disappear</vh></v>
<v t="EKR.20040518070940.156"><vh>Fixed long-standing problem with the outline-only command</vh></v>
<v t="EKR.20040518070824.1"><vh>Made sure file indices are always assigned when writing files.</vh></v>
<v t="EKR.20040518070940"><vh>Fixed problems with missing tnodeList with @file-noref</vh></v>
<v t="EKR.20040518070940.164"><vh>Added t.writeBit</vh></v>
</v>
<v t="EKR.20040518075457"><vh>Dangers of @file-thin</vh></v>
</v>
</v>
<v t="ekr.20060206111600"><vh>4.3...@settings</vh>
<v t="ekr.20050917092557"><vh>4.3.3 final</vh>
<v t="ekr.20050917105646"><vh>Fixes made in 4.3.3</vh></v>
<v t="ekr.20050917092557.1"><vh>Rewrote documentation</vh></v>
<v t="ekr.20050917092557.2"><vh>Bug fixes...</vh>
<v t="ekr.20050917092557.3"><vh>Fixed various unicode bugs</vh></v>
<v t="ekr.20050917092557.4"><vh>Fixed bugs relating to recent files</vh></v>
<v t="ekr.20050917092557.5"><vh>Fixed minor crasher in colorizer</vh></v>
<v t="ekr.20050917092557.6"><vh>Protected several methods used by plugin manager</vh></v>
<v t="ekr.20050917092557.7"><vh>Added test files to distribution list and cvs</vh></v>
</v>
<v t="ekr.20050917092557.8"><vh>New and improved  plugins</vh>
<v t="ekr.20050917092557.9"><vh>New rst3 plugin</vh></v>
<v t="ekr.20050917092557.10"><vh>Improved spellpyx plugin</vh></v>
<v t="ekr.20050917092557.11"><vh>Improved vim and openWith plugins</vh></v>
</v>
<v t="ekr.20050917092557.12"><vh>New &amp; improved features...</vh>
<v t="ekr.20050917092557.13"><vh>Added g.es_print, g.es_trace function</vh></v>
<v t="ekr.20050917092557.14"><vh>Improved PrettyPrinting</vh></v>
</v>
</v>
<v t="ekr.20050913131848"><vh>4.3.2 final</vh>
<v t="ekr.20050906104918.1"><vh>Rewrote documentation</vh></v>
<v t="ekr.20050906104931.1"><vh>Bug fixes...</vh>
<v t="ekr.20050909082711"><vh>Fixed various unicode bugs</vh></v>
<v t="ekr.20050906104931.15"><vh>Fixed bugs relating to recent files</vh></v>
<v t="ekr.20050906104931.38"><vh>Fixed minor crasher in colorizer</vh></v>
<v t="ekr.20050906104931.42"><vh>Protected several methods used by plugin manager</vh></v>
<v t="ekr.20050906104931.43"><vh>Added test files to distribution list and cvs</vh></v>
</v>
<v t="ekr.20050908164150"><vh>New and improved  plugins</vh>
<v t="ekr.20050908164150.1"><vh>New rst3 plugin</vh></v>
<v t="ekr.20050908164150.2"><vh>Improved spellpyx plugin</vh></v>
<v t="ekr.20050910143326"><vh>Improved vim and openWith plugins</vh></v>
</v>
<v t="ekr.20050906104931.48"><vh>New &amp; improved features...</vh>
<v t="ekr.20050906104931.49"><vh>Added g.es_print, g.es_trace function</vh></v>
<v t="ekr.20050906104931.56"><vh>Improved PrettyPrinting</vh></v>
</v>
</v>
<v t="ekr.20050906104918"><vh>4.3.2 beta 1</vh></v>
<v t="ekr.20050620144052"><vh>4.3.1</vh>
<v t="ekr.20050620144052.2"><vh>Bug fixes...</vh>
<v t="ekr.20050620144052.3"><vh>Fixed bug in @ratio setting</vh></v>
<v t="ekr.20050620144052.6"><vh>Fixed crasher footprint plugin</vh></v>
<v t="ekr.20050620144052.8"><vh>Fixed invalid position bug)</vh></v>
<v t="ekr.20050620144052.48"><vh>Fixed undo problems in unit tests</vh></v>
<v t="ekr.20050620144052.112"><vh>Made sure same case is used in all recent files entries</vh></v>
<v t="ekr.20050620144052.114"><vh>Made sure all dialogs gets focus when they are run</vh></v>
<v t="ekr.20050620144052.116"><vh>Improved Resize To Screen command</vh></v>
<v t="ekr.20050620144052.119"><vh>Made sure comments are always visible in setting dialog even for non-@ nodes</vh></v>
<v t="ekr.20050620144052.154"><vh>Fixed problem with leading @ in body text</vh></v>
<v t="ekr.20050620144052.166"><vh>Fixed several  crashers while undoing a move involving clones</vh></v>
<v t="ekr.20050620144052.182"><vh>Fixed Unicode encoding problem</vh></v>
<v t="ekr.20050620144052.185"><vh>Fixed problem with coloring @language plain</vh></v>
<v t="ekr.20050620144602"><vh>Fixed bug: Mark Clones command did not work</vh></v>
</v>
<v t="ekr.20050620144052.207"><vh>New features...</vh>
<v t="ekr.20050620144052.208"><vh>Created separate helpers for idle_body_key</vh></v>
<v t="ekr.20050620144052.210"><vh>Made all Mark commands undoable</vh></v>
<v t="ekr.20050620144052.222"><vh>Removed dependence on profile and pstats modules from leoTest.py</vh></v>
<v t="ekr.20050620144052.231"><vh>Added support for tk resource files</vh></v>
<v t="ekr.20050620144425"><vh>Added support for coloring the PL/SQL language</vh></v>
</v>
</v>
<v t="ekr.20050523092026"><vh>4.3-final</vh>
<v t="ekr.20050523092056.1"><vh>Fixed crasher when pie-menu plugin enabled</vh></v>
<v t="ekr.20050523092056.4"><vh>Fixed crasher in Extract Section Command</vh></v>
</v>
<v t="ekr.20050513141852"><vh>4.3-beta 2</vh>
<v t="ekr.20050513141913.1"><vh>Fixed bugs...</vh>
<v t="ekr.20050513141913.16"><vh>Fixed nodenavagator bug</vh></v>
<v t="ekr.20050513141913.17"><vh>Fixed LaTex Coloring bug</vh></v>
<v t="ekr.20050513141913.22"><vh>Error messages in scripts are now redirected properly.</vh></v>
<v t="ekr.20050513141913.30"><vh>Fixed 2 crashers in nav_buttons plugin</vh></v>
<v t="ekr.20050513141913.57"><vh>Fixed crasher in yoffsetTree</vh></v>
<v t="ekr.20050513141913.60"><vh>Fixed crasher in undo</vh></v>
<v t="ekr.20050513141913.82"><vh>Fixed  several problems with Extract and Extract Section</vh></v>
<v t="ekr.20050513141913.91"><vh>Fixed bug with Delete in headlines</vh></v>
<v t="ekr.20050513141913.127"><vh>Fixed bugs re initial_splitter_orientation &amp; @strings &amp; @ints generally</vh></v>
<v t="ekr.20050513141913.140"><vh>Fixed bug with hoist + insert</vh></v>
<v t="ekr.20050513141913.145"><vh>Fixed problem with settings dialog position when panes split horizontally</vh></v>
<v t="ekr.20050513141913.149"><vh>Fixed problem changing shortcut &amp; redid shortcuts widget</vh></v>
</v>
<v t="ekr.20050513141913.187"><vh>New Features...</vh>
<v t="ekr.20050513141913.97"><vh>Marking any node sets the outline changed</vh></v>
<v t="ekr.20050513141913.188"><vh>Allow quoted urls in  @urls nodes</vh></v>
<v t="ekr.20050513141913.194"><vh>Moved executeFile into core</vh></v>
<v t="ekr.20050513141913.197"><vh>Rewrote g.getScript using at.writeFromString</vh></v>
<v t="ekr.20050513141913.233"><vh>Added define_name arg to c.executeScript</vh></v>
</v>
</v>
<v t="ekr.20050429094215"><vh>4.3-beta 1</vh>
<v t="ekr.20050429094215.2"><vh>Fixed bugs...</vh>
<v t="ekr.20050429094215.3"><vh>Made sure NameErrors are reported with tracebacks in scripts</vh></v>
<v t="ekr.20050429094215.22"><vh>Finally! fixed .leoID problem!</vh></v>
<v t="ekr.20050429094215.31"><vh>Investigated problem with LeoPluginsRef.leo</vh></v>
<v t="ekr.20050429094215.41"><vh>Fixed conflicts in menu shortcuts</vh></v>
<v t="ekr.20050429094215.113"><vh>Fixed bug in p.initStatus caught by pychecker</vh></v>
<v t="ekr.20050429094215.116"><vh>Fixed crasher in import logic (leoAtFile)</vh></v>
<v t="ekr.20050429094215.120"><vh>Put in protections against unbounded recursion in idle_scrollTo</vh></v>
</v>
<v t="ekr.20050429094215.130"><vh>New features...</vh>
<v t="ekr.20050429094215.131"><vh>Created stand-alone leoGlobals.py module</vh></v>
<v t="ekr.20050429094215.139"><vh>Leo now ignores problems opening settings file for chapters plugin</vh></v>
<v t="ekr.20050429094215.145"><vh>Improved write logic</vh></v>
<v t="ekr.20050429094215.173"><vh>Rewrote the undo code</vh></v>
<v t="ekr.20050429094215.286"><vh>Implemented undo/redo for Paste Retaining clones</vh></v>
<v t="ekr.20050429094215.316"><vh>Added support for 'str_' uA's</vh></v>
<v t="ekr.20050429094215.347"><vh>Removed unused params from leoAtFile.py</vh></v>
<v t="ekr.20050429094215.353"><vh>Leo  saves recent files info in .leoRecentFiles.txt files</vh>
<v t="ekr.20050429094215.354"><vh>What I did</vh></v>
<v t="ekr.20050429094215.355"><vh>New plan</vh></v>
</v>
<v t="ekr.20050429095849"><vh>Finished all @settings coding</vh></v>
</v>
</v>
<v t="ekr.20050313101229"><vh>4.3-a4</vh>
<v t="ekr.20050313101229.2"><vh>Fixed bugs...</vh>
<v t="ekr.20050313101229.69"><vh>Fix colorizer bug for initial @nocolor in @root nodes</vh></v>
<v t="ekr.20050313101229.74"><vh>Fixed @wrap bug</vh></v>
<v t="ekr.20050313101229.77"><vh>Fixed change-all bug</vh></v>
</v>
<v t="ekr.20050313103448"><vh>New features...</vh>
<v t="ekr.20050313101229.95"><vh>Created Add Comments and Delete Comments commands</vh></v>
<v t="ekr.20050313101229.94"><vh>Deprecated new_c key in hooks, added c key</vh></v>
<v t="ekr.20050313103448.1"><vh>Added the 'before-create-leo-frame' hook</vh></v>
<v t="ekr.20050313101229.101"><vh>Added support for mod_labels plugin</vh></v>
</v>
<v t="ekr.20050313101229.100"><vh>Revised plugins for the 4.3 code base</vh></v>
</v>
<v t="ekr.20050221104844"><vh>4.3-a3</vh>
<v t="ekr.20050221104844.2"><vh>Bugs</vh>
<v t="ekr.20050221104844.3"><vh>Fixed crasher in Tangle</vh></v>
<v t="ekr.20050221104844.12"><vh>Applied patch to rst2 plugin</vh></v>
<v t="ekr.20050221104844.14"><vh>Revised searchbox plugin so it works with Leo 4.3</vh></v>
<v t="ekr.20050221104844.27"><vh>Fixed bugs in nav_buttons and nodenavigator plugins</vh></v>
<v t="ekr.20050221104844.45"><vh>Made sure Leo asks for leoID at most once</vh></v>
<v t="ekr.20050221104844.54"><vh>Fixed botch in g.pdb</vh></v>
<v t="ekr.20050222100936"><vh>Fixed crasher when executing a script if the script was selected text in a new window</vh></v>
</v>
<v t="ekr.20050221104844.57"><vh>New features</vh>
<v t="ekr.20050221104844.58"><vh>Added sets.py to distribution</vh></v>
<v t="ekr.20050221104844.59"><vh>Added color='suppress' hack to g.es</vh></v>
</v>
</v>
<v t="ekr.20050126100405"><vh>4.3-a2</vh>
<v t="ekr.20050130112336.1"><vh>To do: Improve how Leo handles recent files</vh></v>
<v t="ekr.20050209141626.3"><vh>Bugs fixed...</vh>
<v t="ekr.20050209141626.4"><vh>Fixed very old bug in Undo Insert Node </vh></v>
<v t="ekr.20050209141626.8"><vh>Made sure to remove duplicates from recent files</vh></v>
<v t="ekr.20050209141626.12"><vh>Fixed indentation problems in leoTkinterFind.py</vh></v>
<v t="ekr.20050209141626.13"><vh>Changed leoConfig.txt to leoSettings.leo in Help menu, etc.</vh></v>
<v t="ekr.20050209141626.16"><vh>Investigated recent files problems</vh></v>
<v t="ekr.20050209141626.23"><vh>Improved queuing of log messages</vh></v>
<v t="ekr.20050209141626.42"><vh>Fixed crasher in Change All command</vh></v>
<v t="ekr.20050209141626.43"><vh>Fixed crasher in script button</vh></v>
<v t="ekr.20050209141626.46"><vh>Fixed print problems on the Mac</vh></v>
<v t="ekr.20050209141626.53"><vh>leoTest.runTests now makes copies of all positions</vh></v>
<v t="ekr.20050209141626.54"><vh>Fixed problems with unit test file paths</vh></v>
<v t="ekr.20050209141626.55"><vh>Made local config settings work again</vh></v>
<v t="ekr.20050209141626.91"><vh>Fix problems searching for nothing but whitespace</vh></v>
<v t="ekr.20050210101318"><vh>Fixed problems with typing return in the Find panel</vh></v>
<v t="ekr.20050209141626.101"><vh>Buttons no longer work in toolbars when settings dialog is open</vh></v>
<v t="ekr.20050209141626.102"><vh>Fixed bug in delayed focus logic</vh></v>
<v t="ekr.20050209141626.105"><vh>Made sure Leo asks for leoID at most once</vh></v>
<v t="ekr.20050209141626.113"><vh>Leo now prints unicode characters properly in the log pane</vh></v>
<v t="ekr.20050209141626.114"><vh>Fixed various problems with opening files with Unicode filenames</vh></v>
<v t="ekr.20050211095754"><vh>Fixed bug reading encoding field in external files</vh></v>
<v t="ekr.20050212054743"><vh>Allow indented code blocks to be run using Execute Script command</vh></v>
<v t="ekr.20050212144116"><vh>Fixed problems found by pychecker</vh></v>
</v>
<v t="ekr.20050209141626.150"><vh>New features...</vh>
<v t="ekr.20050126100405.1"><vh>Added undo granularity</vh>
<v t="EKR.20040524104904.48"></v>
</v>
<v t="ekr.20050209141626.185"><vh>Added support for top-level init function in plugins</vh></v>
<v t="ekr.20050209141626.190"><vh>Changed name of Paste Retaining Clones to Paste Node As Clone</vh></v>
<v t="ekr.20050209141626.193"><vh>Added leoPlugins.leo to Help menu</vh></v>
<v t="ekr.20050209141626.194"><vh>Script buttons can request to be removed</vh></v>
<v t="ekr.20050209141626.195"><vh>Improved documentation in several nodes in leoSettings.leo</vh></v>
<v t="ekr.20050209141626.196"><vh>Predefined c,g &amp; p in scripts, unit tests &amp; test routines</vh></v>
<v t="ekr.20050209141626.198"><vh>Changed name of Preferences command to Settings</vh></v>
</v>
</v>
<v t="ekr.20050122090311"><vh>4.3-a1</vh>
<v t="ekr.20050123112834"><vh>Defining features of 4.3</vh>
<v t="ekr.20050123110009"><vh>Using @settings trees and leoSettings.leo</vh>
<v t="ekr.20050122084954"><vh>Using leoSettings.leo and @settings trees</vh></v>
<v t="ekr.20050122091036"><vh>Unfinished configuration features</vh></v>
</v>
<v t="ekr.20050123092834.520"><vh>Rewrote Leo's read/write logic</vh></v>
<v t="ekr.20050123115804"><vh>Added Plugins Manager plugin</vh></v>
<v t="ekr.20050123115804.1"><vh>You can install third-party extensions in Leo's extensions directory</vh></v>
</v>
<v t="ekr.20050123092834.1"><vh>Fixed bugs...</vh>
<v t="ekr.20050123101208"><vh> Major bugs: these bugs corrupted external files!</vh>
<v t="ekr.20050123092834.432"><vh>Fixed double doc part bug</vh></v>
<v t="ekr.20050123092834.497"><vh>Fixed bug in how Leo writes thin external files</vh></v>
</v>
<v t="ekr.20050123092834.2"><vh>Commands</vh>
<v t="ekr.20050123092834.6"><vh>Fixed problems with spawnv option of openWith</vh></v>
<v t="ekr.20050123092834.19"><vh>Fixed bug in  Remove Sentinels command</vh></v>
<v t="ekr.20050123092834.27"><vh>Fixed bug re Paste Node As Clone</vh></v>
<v t="ekr.20050123092834.42"><vh>Fixed Pretty Print commands for Python 2.4</vh></v>
<v t="ekr.20050123092834.71"><vh>Fixed crasher in Import external files command</vh></v>
<v t="ekr.20050123092834.510"><vh>Search commands are now restricted to hoisted area</vh></v>
</v>
<v t="ekr.20050123100706.1"><vh>Distribution</vh>
<v t="ekr.20050123092834.491"><vh>Fixed file association in leoDist.leo</vh></v>
</v>
<v t="ekr.20050123092834.165"><vh>Files</vh>
<v t="ekr.20050123092834.492"><vh>g.import wrappers return module if it is in sys.modules</vh></v>
<v t="ekr.20050123092834.166"><vh>Disabled changes to comment delims in @@language and @@comment sentinels</vh></v>
<v t="ekr.20050123092834.176"><vh>Made sure files that differ only in line ending get written if @lineending is in effect</vh></v>
<v t="ekr.20050123092834.196"><vh>Fixed bug:  @nosent wrote sentinels!</vh></v>
<v t="ekr.20050123092834.422"><vh>Fixed bug in replaceTargetFileIfDifferent</vh></v>
<v t="ekr.20050123092834.424"><vh>Made sure that @ignore forces writing of inner @thin trees</vh></v>
<v t="ekr.20050123092834.431"><vh>Fixed crasher when attempting to write a external file to an invalid path</vh></v>
<v t="ekr.20050123092834.434"><vh>Fixed Python 2.4 deprecation warning when saving .leo files</vh></v>
<v t="ekr.20050123092834.499"><vh>Fixed crasher in getOutputNewline</vh></v>
<v t="ekr.20050123092834.544"><vh>Always use os.rename in utils_rename</vh></v>
<v t="ekr.20050123151338"><vh>Fixed bugs handling @language &amp; @comment in atFile.scanAllDirectives &amp; g.scanDirectives)</vh></v>
</v>
<v t="ekr.20050123103303"><vh>Gui</vh>
<v t="ekr.20050123092834.502"><vh>Put the scrollWheel workaround in createTkTreeCanvas</vh></v>
</v>
<v t="ekr.20050123100706.2"><vh>Menus</vh>
<v t="ekr.20050123092834.81"><vh>Fixed problems with Control-E</vh></v>
<v t="ekr.20050123092834.490"><vh>Better handling of duplicate menu shortcuts</vh></v>
</v>
<v t="ekr.20050123092834.159"><vh>Nodes</vh>
<v t="ekr.20050123092834.160"><vh>Fixed crash after cutting an imported node</vh></v>
<v t="ekr.20050123092834.163"><vh>Removed invalid assert in lastVisible</vh></v>
<v t="ekr.20050123093854.1"><vh>Fixed bugs in tnodes_iter and unique_tnodes_iter</vh></v>
</v>
<v t="ekr.20050123111723"><vh>Plugins</vh>
<v t="ekr.20050123092834.1047"><vh>Fixed two bugs in Plugins Manager plugin</vh></v>
<v t="ekr.20050123092834.1052"><vh>Fixed bug re referencing destroyed ivars</vh></v>
<v t="ekr.20050123092834.1057"><vh>Fixed bug in registerOneHandler</vh></v>
<v t="ekr.20050123092834.506"><vh>Fixed conflict between settings panel and chapters plugin</vh></v>
</v>
<v t="ekr.20050123092834.526"><vh>Pychecker</vh></v>
<v t="ekr.20050123092834.438"><vh>Scripting</vh>
<v t="ekr.20050123092834.439"><vh>Fixed unbounded recursion with --script and redirected output</vh></v>
<v t="ekr.20050123092834.474"><vh>Script buttons now execute the entire script</vh></v>
<v t="ekr.20050123092834.480"><vh>Fixed error reporting in executeScript when the error happens outside the script</vh></v>
</v>
<v t="ekr.20050123092834.486"><vh>Startup</vh>
<v t="ekr.20050123092834.487"><vh>Non-existent command-line file becomes name of new Leo wiindow</vh></v>
<v t="ekr.20050123092834.1011"><vh>computeHomeDir now handles references to other vars</vh></v>
</v>
</v>
<v t="ekr.20050123092834.896"><vh>New or improved features...</vh>
<v t="ekr.20050123110009"></v>
<v t="ekr.20050123103303.1"><vh>Code</vh>
<v t="ekr.20050123092834.520"></v>
<v t="ekr.20050123092834.173"><vh>Added g.cantImport</vh></v>
<v t="ekr.20050123092834.901"><vh>Added g.fileLikeObject.readline</vh></v>
<v t="ekr.20050123092834.928"><vh>Added support for g.app.debugSwitch in es_exception</vh></v>
<v t="ekr.20050123092834.984"><vh>Restored drawing/event hooks</vh></v>
<v t="ekr.20050123092834.1004"><vh>Added p=p param to all hooks containing v=v</vh></v>
<v t="ekr.20050123092834.565"><vh>Implemented delayed focus scheme</vh></v>
</v>
<v t="ekr.20050123103521"><vh>Commands</vh>
<v t="ekr.20050123092834.897"><vh>Added 'Expand Or Go Right' and 'Contract or Go Left' commands</vh></v>
<v t="ekr.20050123092834.908"><vh>Added keyboard shortcuts to find panel</vh></v>
<v t="ekr.20050123092834.1005"><vh>Find panels are now associated with individual Leo windows</vh></v>
<v t="ekr.20050123105026"><vh>Find panels are now inited from @settings nodes</vh></v>
<v t="ekr.20050123092834.961"><vh>Improved Go To Line Number and Execute Script commands</vh></v>
<v t="ekr.20050123092834.1018"><vh>Improved support for relative path names</vh></v>
<v t="ekr.20050123092834.1043"><vh>Implemented 'Undo Clear Recent Files'</vh></v>
<v t="ekr.20050123092834.517"><vh>Removed old-style write commands</vh></v>
</v>
<v t="ekr.20050123092834.1044"><vh>Plugins &amp; extensions</vh>
<v t="ekr.20050123115804"></v>
<v t="ekr.20050123115804.1"></v>
<v t="ekr.20050123112151"><vh>Improved doHandlersForTag</vh></v>
<v t="ekr.20050123092834.1013"><vh>Leo now associates modules with hook handlers</vh></v>
</v>
<v t="ekr.20050123103753"><vh>Syntax Coloring &amp; languages</vh>
<v t="ekr.20050123092834.903"><vh>Added support for Ada</vh></v>
<v t="ekr.20050123092834.929"><vh>Added support for Forth</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060206111717.1"><vh>4.4 minibuffer, keys, autocompletion, multiple log panes</vh>
<v t="ekr.20051219150602"><vh>4.4 alpha 5</vh>
<v t="ekr.20051219150602.2"><vh>Fixed bugs</vh>
<v t="ekr.20051219150602.3"><vh>Made sure focus doesn't go to log during tab completion or after writes to log</vh></v>
<v t="ekr.20051219150602.7"><vh>Fixed problem with getScript in batch mode</vh></v>
<v t="ekr.20051219150602.10"><vh>Text box is now selected in goto-line-number command</vh></v>
<v t="ekr.20051219150602.13"><vh>Restored headkey  &amp; bodykey hooks</vh></v>
<v t="ekr.20051219150602.28"><vh>Fixed ancient bug in read error logic that hung Leo</vh></v>
<v t="ekr.20051219150602.75"><vh>Fixed many headline problems</vh></v>
<v t="ekr.20051219150602.81"><vh>Fixed problem in reformatParagraph</vh></v>
<v t="ekr.20051219150602.85"><vh>Installed LeoUsers patch </vh></v>
<v t="ekr.20060105182648.376"><vh>Improved Import external files command.</vh></v>
<v t="ekr.20060105182648.377"><vh>Fixed crasher in backwardDeleteCharacter</vh></v>
<v t="ekr.20060105182648.378"><vh>Fixed recent bug: dialogs now get focus properly when first opened.</vh></v>
<v t="ekr.20060105182648.379"><vh>Made sure shortcuts are printed clearly by k.registerCommand</vh></v>
<v t="ekr.20060105182648.382"><vh>Suppressed crash undoing a clone followed by a drag</vh></v>
</v>
<v t="ekr.20051219150602.100"><vh>New features</vh>
<v t="ekr.20051219150602.101"><vh>created ut.leo, ut.py and ut.bat</vh></v>
<v t="ekr.20051219150602.102"><vh>Added modes/*.xml to distribution</vh></v>
<v t="ekr.20051219150602.105"><vh>Revised cursor movement commands and added selection-extension commands</vh></v>
<v t="ekr.20051219151926"><vh>Added classic key bindings in leoSettings.leo</vh></v>
<v t="ekr.20060105182648.432"><vh>Allow multiple key bindings to the same command</vh></v>
<v t="ekr.20060105182648.469"><vh>Settings command now opens leoSettings.leo</vh></v>
</v>
</v>
<v t="ekr.20051028051444"><vh>4.4 alpha 4</vh>
<v t="ekr.20051028051444.1"><vh>Quick Start</vh></v>
<v t="ekr.20051028051444.2"><vh>The 'key' features of 4.4</vh>
<v t="ekr.20051101161405"><vh>Leo's minibuffer works like the Emacs mini-buffer</vh></v>
<v t="ekr.20051101161405.1"><vh>@shortcuts nodes in leoSettings.leo allow per-pane bindings</vh></v>
<v t="ekr.20051101161405.2"><vh>The scripting plugin allows key bindings</vh></v>
<v t="ekr.20051101161405.3"><vh>EKR shortcuts</vh></v>
<v t="ekr.20051101162123"><vh>Leo now ignores key bindings in menu tables</vh></v>
</v>
<v t="ekr.20051205091625"><vh>Status of minibuffer commands</vh></v>
<v t="ekr.20051028051616"><vh>New in alpha 1...</vh>
<v t="ekr.20051028051444.4"><vh>New options</vh>
<v t="ekr.20051028051444.5"><vh>The @bool useMinibuffer option</vh></v>
<v t="ekr.20051028051444.6"><vh>The @bool useCmdMenu option</vh></v>
<v t="ekr.20051028051444.7"><vh>Options for selected body text</vh></v>
</v>
<v t="ekr.20051028051444.8"><vh>New mini-buffer commands</vh></v>
<v t="ekr.20051028051444.9"><vh>New code-level features</vh>
<v t="ekr.20051028051444.10"><vh>Dictionaries of keys and commands</vh></v>
<v t="ekr.20051028051444.11"><vh>Functions that return the present key bindings</vh></v>
<v t="ekr.20051028051444.12"><vh>The registerCommand helper</vh></v>
</v>
<v t="ekr.20051028051444.13"><vh>Bugs fixed (in 4.3 code base)</vh>
<v t="ekr.20051028051444.14"><vh>Leo protects c.endUpdate with a 'finally' clause</vh></v>
<v t="ekr.20051028051444.15"><vh>Added kludge to solve infamous control-v problems</vh></v>
<v t="ekr.20051028051444.16"><vh>Fixed bug in Leo's read logic</vh></v>
<v t="ekr.20051028051444.17"><vh>Fixed bug in goto-last-node.</vh></v>
<v t="ekr.20051028051444.18"><vh>Leo now reads @settings trees when opening a .leo file from another outline.</vh></v>
<v t="ekr.20051028051444.19"><vh>Improved g.removeExtraLws</vh></v>
</v>
</v>
<v t="ekr.20051028051616.1"><vh>New in alpha 2</vh>
<v t="ekr.20051101162123.1"><vh>The tabbed log</vh>
<v t="ekr.20051028051616.172"><vh>Programming the tabbed log</vh></v>
</v>
<v t="ekr.20051028061322"><vh>New minibuffer commands</vh></v>
<v t="ekr.20051028051616.299"><vh>Optional generation of closing brackets</vh></v>
<v t="ekr.20051101182739"><vh>New settings in leoSettings.leo</vh></v>
<v t="ekr.20051101161949"><vh>Improved and retired plugins</vh>
<v t="ekr.20051028051616.160"><vh>Improved the scripting plugin</vh></v>
<v t="ekr.20051101162947"><vh>Retired the TabbedLog plugin</vh></v>
</v>
<v t="ekr.20051101163145"><vh>Many code-level improvements</vh></v>
<v t="ekr.20051101163404"><vh>Fixed minor bugs</vh></v>
</v>
<v t="ekr.20051109112610"><vh>New in alpha 3</vh>
<v t="ekr.20051109112826"><vh>The New and Newer World Orders</vh></v>
<v t="ekr.20051109141223"><vh>Bugs fixed...</vh>
<v t="ekr.20051109112826.217"><vh>Fix crasher in Open logic</vh></v>
<v t="ekr.20051109112826.227"><vh>(Undo ends editing</vh></v>
<v t="ekr.20051109112826.257"><vh>Disabled minibuffer when not in use</vh></v>
<v t="ekr.20051109112826.315"><vh>Fixed bug in Find Backward</vh></v>
<v t="ekr.20051109112826.265"><vh>Improved Spell tab</vh></v>
</v>
<v t="ekr.20051109141524"><vh>New features</vh>
<v t="ekr.20051109112826.222"><vh>Created scripts.leo and unitTest.leo</vh></v>
<v t="ekr.20051109112826.254"><vh>c.executeMinibufferCommand executes a minibuffer command by name</vh></v>
<v t="ekr.20051109112826.310"><vh>Improved perl entries in language dicts</vh></v>
</v>
<v t="ekr.20051109141524.1"><vh>Code-level changes</vh>
<v t="ekr.20051109112826.223"><vh>Changed  edit_text to edit_widget everywhere</vh></v>
<v t="ekr.20051109112826.224"><vh>Removed tree ivars</vh></v>
<v t="ekr.20051109142920"><vh>Removed frame.begin/endUpdate</vh></v>
</v>
</v>
<v t="ekr.20051128181229"><vh>New in alpha 4</vh>
<v t="ekr.20051128181351"><vh>Bugs fixed</vh>
<v t="ekr.20051128181302.148"><vh>Changed scripting plugin so files opened with buttons stay in front</vh></v>
<v t="ekr.20051128181302.183"><vh>Fixed undo/redo bugs</vh></v>
<v t="ekr.20051128181302.192"><vh>Fixed focus problem with tab completion</vh></v>
<v t="ekr.20051128181302.193"><vh>Fixed minor Save bug</vh></v>
<v t="ekr.20051128181302.231"><vh>Fixed long-standing problem with Plugins Manager plugin</vh></v>
<v t="ekr.20051128181302.244"><vh>Fixed 2 outline editing bugs</vh></v>
<v t="ekr.20051205090923.13"><vh>Fixed crasher in deleteNextChar</vh></v>
<v t="ekr.20051205090923.16"><vh>Fixed new headline bug</vh></v>
<v t="ekr.20051205090923.22"><vh>Fix problems applying settings</vh></v>
<v t="ekr.20051128181302.204"><vh>Fixed several bugs in rst3 plugin</vh></v>
</v>
<v t="ekr.20051128181651"><vh>Code changes</vh>
<v t="ekr.20051128181302.149"><vh>Removed later arg from c.frame.xWantsFocus</vh></v>
<v t="ekr.20051128181302.196"><vh>Created enableTclTraces</vh></v>
<v t="ekr.20051128181302.208"><vh>Eliminated w.update in g.app.gui.set_focus</vh></v>
</v>
<v t="ekr.20051128181651.1"><vh>New &amp; improved features and files</vh>
<v t="ekr.20051128181302.147"><vh>Moved all scripts into scripts.leo</vh></v>
<v t="ekr.20051128181302.150"><vh>Improved how the New Tab and Rename Tab commands work in the log pane</vh></v>
<v t="ekr.20051128181302.151"><vh>Improved the appearance of the Spell tab</vh></v>
<v t="ekr.20051128181302.156"><vh>Added Clone-find checkbox to the Find tab</vh></v>
<v t="ekr.20051128181302.171"><vh>Improved find tab</vh></v>
<v t="ekr.20051128181302.211"><vh>Improved formatting of shortcuts in print-commands and print-bindings</vh></v>
<v t="ekr.20051128181302.213"><vh>Added settings for vim plugin</vh></v>
<v t="ekr.20051128181302.214"><vh>Put up a dialog if can't import Pmw</vh></v>
<v t="ekr.20051128181302.229"><vh>Bound &lt;Return&gt; to end-edit-headline</vh></v>
</v>
</v>
</v>
<v t="ekr.20060116174906"><vh>4.4 beta 1</vh>
<v t="ekr.20060116174906.2"><vh>Bugs fixed</vh>
<v t="ekr.20060116174906.3"><vh>Fixed minor headline problems</vh></v>
<v t="ekr.20060116174906.63"><vh>Fixed undo problems</vh></v>
<v t="ekr.20060116174906.86"><vh>Improved word-export plugin</vh></v>
<v t="ekr.20060116174906.87"><vh>Removed a bad use of g.app.log in the find panel</vh></v>
<v t="ekr.20060116174906.88"><vh>Fix crash: tab in minibuffer</vh></v>
<v t="ekr.20060116174906.90"><vh>Installed patch for headline width</vh></v>
<v t="ekr.20060116174906.97"><vh>Redraw screen properly after Move To Next Dirty</vh></v>
<v t="ekr.20060116174906.100"><vh>Fixed focus bug</vh></v>
<v t="ekr.20060116174906.103"><vh>Made sure to bring proper window on top in settings.leo button</vh></v>
<v t="ekr.20060116174906.104"><vh>Arrow keys now clear the text selection</vh></v>
<v t="ekr.20060116174906.113"><vh>Fixed several minor bugs</vh></v>
<v t="ekr.20060116174906.118"><vh>Fixed problems with plugins</vh></v>
<v t="ekr.20060116174906.122"><vh>Fixed old file handling bug</vh></v>
<v t="ekr.20060116174906.125"><vh>Use shutil.move in g.utils_rename</vh></v>
<v t="ekr.20060116174906.130"><vh>Simplified k.copyBindingsToWidget and eliminated k.onTextWidgetKey</vh></v>
<v t="ekr.20060116174906.160"><vh>Made sure that focus stays in body during tab completion</vh></v>
<v t="ekr.20060116174906.163"><vh>Leo now puts focus in body pane after deleting a window</vh></v>
<v t="ekr.20060116174906.164"><vh>Fixed many binding problems</vh></v>
<v t="ekr.20060116174906.185"><vh>Fixed extend-selection problems</vh></v>
<v t="ekr.20060116174906.187"><vh>Fixed per-pane bindings!</vh></v>
<v t="ekr.20060116174906.194"><vh>Always redraw the screen after editing a label</vh></v>
</v>
<v t="ekr.20060116174906.195"><vh>Code level changes</vh>
<v t="ekr.20060116174906.198"><vh>Removed g.top from Leo's core and all plugins</vh></v>
<v t="ekr.20060116174906.199"><vh>Created c.exists ivar and related logic</vh></v>
<v t="ekr.20060116174906.213"><vh>Call c.setLog in all entries into code</vh></v>
<v t="ekr.20060116174906.255"><vh>Generalized doCommand</vh></v>
</v>
<v t="ekr.20060116174906.258"><vh>New features</vh>
<v t="ekr.20060116174906.259"><vh>Installed many standard bindings to leoSettings.leo</vh></v>
<v t="ekr.20060116174906.262"><vh>Added Check Bindings script in leoSettings.leo</vh></v>
<v t="ekr.20060116174906.263"><vh>Scripts now maintain original focus</vh></v>
<v t="ekr.20060116174906.267"><vh>Added scroll-up/down-extend-selection commands</vh></v>
<v t="ekr.20060116174906.272"><vh>Improved cursor move/extend commands</vh></v>
<v t="ekr.20060116174906.296"><vh>Added support for @mode nodes</vh></v>
<v t="ekr.20060116174906.306"><vh>keyboard-quit restores default input mode</vh></v>
</v>
<v t="ekr.20060116174906.257"><vh>Added discusion to FAQ about when deleting a node is 'dangerous'</vh>
<v t="ekr.20060111192108"></v>
</v>
</v>
<v t="ekr.20060206111508"><vh>4.4 beta 2</vh>
<v t="ekr.20060206111508.2"><vh>Bugs fixed</vh>
<v t="ekr.20060206111508.3"><vh>Fixed crasher in Save button</vh></v>
<v t="ekr.20060206111508.4"><vh>Fixed minor bugs &amp; made minor improvements</vh>
<v t="ekr.20060206111508.5"><vh>Fixed two annoying headline glitches</vh></v>
<v t="ekr.20060206111508.14"><vh>Insert headline didn't redraw headline properly in vim mode</vh></v>
<v t="ekr.20060206111508.40"><vh>Improved printBindings, printCommands &amp; modeHelp</vh></v>
</v>
<v t="ekr.20060206111508.48"><vh>Fixed crasher re BackSpace in log window</vh></v>
<v t="ekr.20060206111508.49"><vh>Fixed crashers in cut/copy/paste commands</vh></v>
<v t="ekr.20060206111508.54"><vh>Fixed crasher when clicking the close box during a long command</vh></v>
<v t="ekr.20060206111508.58"><vh>cloneFindAll now honor present find settings</vh></v>
<v t="ekr.20060206111508.63"><vh>Double-click didn't work in the body pane.</vh></v>
<v t="ekr.20060206111508.74"><vh>Improved body.makeInsertPointVisible</vh></v>
<v t="ekr.20060206111508.75"><vh>Fixed cut/copy/paste from menu</vh></v>
<v t="ekr.20060206111508.553"><vh>Fixed major blunder: tree.onHeadChanged sets focus only if there was a real change</vh></v>
<v t="ekr.20060206111508.97"><vh>Disabled plain-key bindings in insert/overwrite modes</vh></v>
<v t="ekr.20060206111508.103"><vh>Disabled auto-scrolling in outline pane on clicks</vh></v>
<v t="ekr.20060206111508.136"><vh>move-outline and find commands force a screen scroll</vh></v>
<v t="ekr.20060211104746.2"><vh>Fixed undo problem in headlines</vh></v>
<v t="ekr.20060214085054"><vh>Found the cause of 'sticking focus' problem</vh></v>
<v t="ekr.20060211104746.162"><vh>Fixed tree icon bug</vh></v>
<v t="ekr.20060211104746.177"><vh>Set remembered column properly in prev-line and next-line</vh></v>
<v t="ekr.20060211104746.208"><vh>Fixed focus problems in spell tab</vh></v>
<v t="ekr.20060214074035.9"><vh>Fixed problem with body_gmt_time setting</vh></v>
<v t="ekr.20060214074035.20"><vh>Made sure save updates the open directory</vh></v>
<v t="ekr.20060214074035.41"><vh>Fixed sort-lines problems</vh></v>
<v t="ekr.20060214074035.101"><vh>Fixed bug: paste outline lost headline editing</vh></v>
</v>
<v t="ekr.20060206111508.547"><vh>Code improvements</vh>
<v t="ekr.20060206111508.550"><vh>Removed code in c.begin/EndUpdate and c.endEditLabel that tried to save/restore focus</vh></v>
<v t="ekr.20060206111508.596"><vh>Improved tree allocation</vh></v>
<v t="ekr.20060211104746.12"><vh>Created c.masterFocusHandler</vh></v>
<v t="ekr.20060211104746.168"><vh>Added unit tests for key dicts</vh></v>
<v t="ekr.20060211104746.346"><vh>Special-cased commands for minibuffer</vh></v>
<v t="ekr.20060214074035.6"><vh>Made sure yield works with Python 2.2</vh></v>
<v t="ekr.20060214074035.12"><vh>Use os.getenv('User") if it exists to get initial cvs name</vh></v>
</v>
<v t="ekr.20060206112001"><vh>Improved commands</vh>
<v t="ekr.20060212102459.4"><vh>Minibuffer-oriented find commands</vh></v>
<v t="ekr.20060214074035.67"><vh>Leo remembers the previous open directory</vh></v>
</v>
<v t="ekr.20060214090742"><vh>Improved plugins</vh>
<v t="ekr.20060214074035.65"><vh>Fixed problem with view plugin</vh></v>
<v t="ekr.20060214074035.66"><vh>Installed cleo patch</vh></v>
</v>
<v t="ekr.20060214083808"><vh>New commands</vh>
<v t="ekr.20060212102459.4"></v>
</v>
<v t="ekr.20060214083647"><vh>New settings</vh></v>
<v t="ekr.20060214092741"><vh>User input modes</vh></v>
</v>
<v t="ekr.20060215112429"><vh>4.4 experimental 1</vh>
<v t="ekr.20060215112429.9"><vh>Fixed (maybe) problems with unicode characters &amp; caps lock</vh></v>
<v t="ekr.20060215112429.2"><vh>Restored some legacy bindings</vh></v>
<v t="ekr.20060215112429.3"><vh>Fixed crasher in Go To Line command</vh></v>
<v t="ekr.20060215112429.6"><vh>Fixed menu problem on Linux</vh></v>
</v>
<v t="ekr.20060217071505"><vh>4.4 a6</vh>
<v t="ekr.20060217071505.1"><vh>Fixed urgent compatibility problems</vh></v>
<v t="ekr.20060217072324"><vh>Minor bugs fixed</vh></v>
<v t="ekr.20060217072647"><vh>New debugging options in leoSettings.leo</vh></v>
</v>
<v t="ekr.20060227102028"><vh>4.4 a7</vh>
<v t="ekr.20060227102028.2"><vh>Bugs Fixed</vh>
<v t="ekr.20060227102028.3"><vh>Fixed binding bug</vh></v>
<v t="ekr.20060227102028.14"><vh>Fixed bug in open-find-dialog</vh></v>
<v t="ekr.20060227102028.15"><vh>Ensure dialogs properly get focus</vh></v>
<v t="ekr.20060227102028.16"><vh>Disabled autocompleter in headlines</vh></v>
<v t="ekr.20060227102028.17"><vh>Removed horrible g.app.dialogs hack</vh></v>
<v t="ekr.20060227102028.18"><vh>Fix crasher in plugin</vh></v>
</v>
</v>
<v t="ekr.20060328171518"><vh>4.4 b3</vh>
<v t="ekr.20060328171518.1"><vh>New features</vh>
<v t="ekr.20060328171518.10"><vh>Added scroll outline pane commands</vh></v>
<v t="ekr.20060328171518.11"><vh>Improved registerCommand</vh></v>
<v t="ekr.20060328171518.15"><vh>Suppressed autocompletion after numbers</vh></v>
<v t="ekr.20060328171518.16"><vh>Added colorizing support for Lua language</vh></v>
<v t="ekr.20060328171518.45"><vh>Added run-unit-test command</vh></v>
</v>
<v t="ekr.20060328171518.47"><vh>Bugs</vh>
<v t="ekr.20060328171518.48"><vh>Fixed problem with left &amp; right arrows in outline mode</vh></v>
<v t="ekr.20060328171518.57"><vh>Fixed undo problem with clones</vh></v>
<v t="ekr.20060328171518.83"><vh>Investigated setting descendant @file nodes dirty when changing body text</vh></v>
<v t="ekr.20060328171518.85"><vh>Work around newline problems on the Mac</vh></v>
<v t="ekr.20060328171518.101"><vh>Got rid of settings messages</vh></v>
<v t="ekr.20060328171518.108"><vh>Clicks outside minibuffer no longer rip focus</vh></v>
<v t="ekr.20060328171518.111"><vh>Handled missing leoSettings.leo files more gracefully</vh></v>
<v t="ekr.20060328171518.119"><vh>Converted all shortcuts to unicode</vh></v>
<v t="ekr.20060328171518.135"><vh>Made Open With shortcuts work again</vh></v>
<v t="ekr.20060328171518.151"><vh>Made sure autocompleter and calltip text stick</vh></v>
<v t="ekr.20060328171518.152"><vh>Fixed a bug in c.openWith</vh></v>
<v t="ekr.20060328171518.169"><vh>Import/export commands now set directory for next open</vh></v>
<v t="ekr.20060328171518.190"><vh>Investigated colorizer problems: can not reproduce</vh></v>
<v t="ekr.20060328171518.248"><vh>Removed support @ifgui: it doesn't and can't work</vh></v>
<v t="ekr.20060328171518.249"><vh>Removed autocompletion for self</vh></v>
<v t="ekr.20060414071350.1"><vh>Rewrote g.importExtension to simplify startup logic</vh></v>
<v t="ekr.20060414071350.8"><vh>Removed calls to lstrip and rstrip for compatibility with Python 2.2.1</vh></v>
<v t="ekr.20060414071350.39"><vh>Fixed crash in string.startswith and string.endswith</vh></v>
<v t="ekr.20060414071350.47"><vh>Fixed Crash after undoing clearRecentFiles command</vh></v>
<v t="ekr.20060414071350.58"><vh>Fixed minor problems reported by Pychecker</vh></v>
</v>
<v t="ekr.20060328171518.191"><vh>Plugins</vh>
<v t="ekr.20060328171518.238"><vh>Changed path to stylesheet in the rst3 plugin</vh></v>
<v t="ekr.20060328171518.240"><vh>Fixed problems with chapters plugin</vh></v>
<v t="ekr.20060328171518.244"><vh>Improved groupoperations plugin</vh></v>
<v t="ekr.20060328171518.245"><vh>Fixed crasher in Word (and other) plugins</vh></v>
<v t="ekr.20060328171518.246"><vh>Fixed problem with labels plugin</vh></v>
</v>
</v>
<v t="ekr.20060417092536"><vh>4.4 b4</vh>
<v t="ekr.20060421070409.1"><vh>Bugs</vh>
<v t="ekr.20060421070602"><vh>Fixed rename-buffer command</vh></v>
<v t="ekr.20060421070409.2"><vh>Investigated problems with legacy bindings</vh></v>
<v t="ekr.20060421070409.3"><vh>Fixed bug when cutting text in headline</vh>
<v t="ekr.20060421070409.4"><vh>Report</vh></v>
</v>
<v t="ekr.20060421070409.9"><vh>Fixed crasher in open-find-dialog</vh>
<v t="ekr.20060421070409.10"><vh>Report</vh></v>
<v t="ekr.20060421070409.11"><vh>Traceback</vh></v>
</v>
<v t="ekr.20060421070409.33"><vh>Don't do typing completion for numbers</vh></v>
<v t="ekr.20060421070409.36"><vh>Fixed crash in undo</vh></v>
</v>
<v t="ekr.20060421070409.37"><vh>New features</vh>
<v t="ekr.20060417092825.1"><vh>Added script to update new copies of leoSettting.leo from previous copies</vh></v>
<v t="ekr.20060421070409.41"><vh>Added new commands</vh></v>
<v t="ekr.20060421070409.40"><vh>Made all edit command undoable</vh></v>
</v>
</v>
<v t="ekr.20060428084553"><vh>4.4 rc1</vh>
<v t="ekr.20060428084553.2"><vh>Bugs</vh>
<v t="ekr.20060428084957"><vh>Fixed rename-buffer command</vh></v>
<v t="ekr.20060428084553.4"><vh>Fixed bug when cutting text in headline</vh></v>
<v t="ekr.20060428084553.10"><vh>Fixed crasher in open-find-dialog</vh></v>
<v t="ekr.20060428084553.34"><vh>Suppressed typing completion for numbers</vh></v>
<v t="ekr.20060428084553.37"><vh>Fixed crash in undo</vh></v>
<v t="ekr.20060428084711"><vh>Fixed crash in datenodes plugin</vh></v>
</v>
<v t="ekr.20060428084553.38"><vh>New features</vh>
<v t="ekr.20060428084553.39"><vh>Added clear-selection command</vh></v>
<v t="ekr.20060428084553.41"><vh>Made all edit command undoable</vh></v>
<v t="ekr.20060428084553.42"><vh>Added new commands</vh></v>
<v t="ekr.20060428084553.273"><vh>Added filename completion</vh></v>
</v>
</v>
<v t="ekr.20060511074853"><vh>4.4 final</vh></v>
</v>
<v t="ekr.20080311060457.214"><vh>4.4.x</vh>
<v t="ekr.20060822140418"><vh>4.4.1...new colorizer, slideshow, multiple editors</vh>
<v t="ekr.20060830141224"><vh>4.4.1 final</vh>
<v t="ekr.20060830141224.2"><vh>Removed warning about changed nodes</vh></v>
<v t="ekr.20060830141224.13"><vh>Bugs fixed</vh>
<v t="ekr.20060830141224.14"><vh>Fixed serious bug in Paste Node as Clone</vh>
<v t="ekr.20060830141224.15"><vh>Report</vh></v>
<v t="ekr.20060830141224.16"><vh>What I did</vh></v>
</v>
<v t="ekr.20060830141224.37"><vh>Fixed minor .leoID.txt bug</vh>
<v t="ekr.20060830141224.38"><vh>Report</vh></v>
</v>
<v t="ekr.20060830141224.45"><vh>Improved speed of unmark-all and corresponding undo/redo</vh>
<v t="ekr.20060830141224.46"><vh>Report</vh></v>
</v>
</v>
</v>
<v t="ekr.20060822140418.1"><vh>4.4.1 b4</vh>
<v t="ekr.20060822140418.3"><vh>Bugs fixed</vh>
<v t="ekr.20060822140418.4"><vh>Added bindings to text panes for show-font command</vh></v>
<v t="ekr.20060822140418.26"><vh>Fixed kill-line, kill-word, kill-sentence, etc</vh></v>
<v t="ekr.20060822140418.29"><vh>Fixed minor scrolling problem</vh></v>
<v t="ekr.20060822140418.36"><vh>Fixed bug in backward-kill-word</vh></v>
<v t="ekr.20060822140418.39"><vh>Fixed unicode bug in forward-word and backward-word commands</vh></v>
<v t="ekr.20060822140418.41"><vh>Fixed problem setting body background color</vh></v>
<v t="ekr.20060822140418.49"><vh>Disabled incremental colorizing in new colorizer when there are multiple editors</vh></v>
<v t="ekr.20060822140418.97"><vh>Removed component classes</vh></v>
</v>
<v t="ekr.20060822140418.69"><vh>New features</vh>
<v t="ekr.20060822140418.76"><vh>Added scroll-outline-left/right commands</vh></v>
<v t="ekr.20060822140418.77"><vh>Generalized bracket flasher</vh></v>
<v t="ekr.20060822140418.88"><vh>Leo *already* supports Python decorators</vh></v>
<v t="ekr.20060822140418.92"><vh>Wrote script to convert g.es to g.et where appropriate</vh></v>
<v t="ekr.20060822140418.70"><vh>Created menu font settings</vh></v>
</v>
</v>
<v t="ekr.20060601101643"><vh>4.4.1 b1</vh>
<v t="ekr.20060601101958.1"><vh>Fixed bugs</vh>
<v t="ekr.20060601101958.56"><vh>The Open Python Window command runs Idle in a separate process</vh></v>
<v t="ekr.20060601101958.2"><vh>Fixed crasher in searchbox plugin</vh></v>
<v t="ekr.20060601101958.6"><vh>Fixed binding problems in leoSettings.leo reported by Check bindings script.</vh></v>
<v t="ekr.20060601101958.13"><vh>Fixed crasher in macros plugin</vh></v>
<v t="ekr.20060601101958.14"><vh>Fixed crasher in  UNL plugin</vh></v>
<v t="ekr.20060601101958.16"><vh>Suppressed traceback in g.callers when the call stack isn't deep enough</vh></v>
<v t="ekr.20060603082009"><vh>Fixed long-standing bug involving @comment and @language</vh></v>
</v>
<v t="ekr.20060601102802"><vh>New features, commands &amp; plugins</vh>
<v t="ekr.20060601101958.245"><vh>Support for multiple editors in the body pane</vh></v>
<v t="ekr.20060601101958.70"><vh>Improved searches</vh></v>
<v t="ekr.20060601101958.52"><vh>Added debug command</vh></v>
<v t="ekr.20060601101958.58"><vh>Added Debug button to scripting plugin</vh></v>
<v t="ekr.20060603072938"><vh>Added python-help command</vh></v>
<v t="ekr.20060601101958.277"><vh>Added toggle-invisibles and hide-invisibles commands</vh></v>
<v t="ekr.20060601101958.172"><vh>Added run-unit-test command</vh></v>
<v t="ekr.20060601101958.234"><vh>The help-for-command command now works for almost all commands</vh></v>
<v t="ekr.20060603081537"><vh>Added shortcut_button plugin</vh></v>
</v>
<v t="ekr.20060601102802.2"><vh>New and improved settings</vh>
<v t="ekr.20060601101958.174"><vh>Added @bool idle_redraw setting</vh></v>
<v t="ekr.20060601101958.264"><vh>Added autoindent_in_nocolor_mode setting</vh></v>
<v t="ekr.20060601101958.244"><vh>Added warnings about the expanded_click_area setting</vh></v>
<v t="ekr.20060601101958.276"><vh>Removed support for @shortcut (@shortcuts remains)</vh></v>
</v>
<v t="ekr.20060601101958.28"><vh>Minor improvements</vh>
<v t="ekr.20060601101958.218"><vh>Finished Cmds menu</vh></v>
<v t="ekr.20060601101958.235"><vh>Improved show-fonts command</vh></v>
<v t="ekr.20060601101958.238"><vh>Strip quotes from color, font settings.</vh></v>
<v t="ekr.20060601101958.239"><vh>Warn about invalid Enter and Leave key bindings</vh></v>
</v>
</v>
<v t="ekr.20060620094645"><vh>4.4.1 b2</vh>
<v t="ekr.20060620094645.34"><vh>Bugs fixed</vh>
<v t="ekr.20060620094645.35"><vh>Made sure calltip always adds '('</vh></v>
<v t="ekr.20060620094645.43"><vh>word matches now succeed if first character of the pattern is not in word-chars.</vh></v>
<v t="ekr.20060620094645.44"><vh>Dialogs now bring the Leo window back to the front</vh></v>
<v t="ekr.20060620094645.45"><vh>Fixed unit test: ensure that body gets focus after ending editing</vh></v>
<v t="ekr.20060620094645.46"><vh>Remember scrolling postion, insert point and selection range in multiple editors</vh></v>
<v t="ekr.20060620094645.50"><vh>Fix crasher in kill-region command</vh></v>
<v t="ekr.20060620094645.52"><vh>Fixed bug: cycle-editor hung Leo</vh></v>
<v t="ekr.20060620094645.64"><vh>Fixed crasher in init code</vh></v>
<v t="ekr.20060620094645.68"><vh>use g.stripBrackets instead of lstrip and rstrip</vh></v>
<v t="ekr.20060620094645.76"><vh>Restore cursor when changing focus in editors</vh></v>
<v t="ekr.20060620094645.77"><vh>Undo restores focus again</vh></v>
<v t="ekr.20060622130815"><vh>Updated row/col indicators when using arrow keys</vh></v>
<v t="ekr.20060622130815.3"><vh>Fixed show-invisibles crasher</vh></v>
</v>
<v t="ekr.20060620094645.78"><vh>Code level</vh>
<v t="ekr.20060620094645.79"><vh>Simplified gui bindings</vh></v>
<v t="ekr.20060622130815.9"><vh>Created g.app.gui.makeScriptButton</vh></v>
</v>
<v t="ekr.20060620094645.85"><vh>New &amp; improved features</vh>
<v t="ekr.20060620094645.86"><vh>Improved filename completion</vh></v>
<v t="ekr.20060620094645.96"><vh>Added support for --&gt; command-name in @mode nodes</vh></v>
<v t="ekr.20060620094645.97"><vh>Better listings for print-commands and print-bindings &amp; mode-help commands</vh></v>
<v t="ekr.20060620094645.103"><vh>Fixed find-character &amp; find-word commands</vh></v>
<v t="ekr.20060620094645.106"><vh>Better printing of bindings (period -&gt; .) etc</vh></v>
<v t="ekr.20060620094645.107"><vh>Added support for !command, !insert and !overwrite bindings</vh></v>
<v t="ekr.20060620094645.108"><vh>Improved check bindings script in leoSettings.leo</vh></v>
<v t="ekr.20060620094645.109"><vh>Improved isearch &amp; added isearch-with-present-options command</vh></v>
<v t="ekr.20060620094645.194"><vh>Use last shortcut defined</vh></v>
<v t="ekr.20060620094645.225"><vh>selfInsertCommand sets the column used by up/down arrows</vh></v>
<v t="ekr.20060620094645.231"><vh>Added toggle-autocompleter and toggle-calltips commands</vh></v>
<v t="ekr.20060620094645.232"><vh>Script buttons now create press-xxx-button commands</vh></v>
<v t="ekr.20060620094645.233"><vh>print-bindings command now properly sorts bindings</vh></v>
<v t="ekr.20060620094645.234"><vh>Allow @shortcuts bindings to apply to press-xxx-commands</vh></v>
<v t="ekr.20060620094645.242"><vh>Added support for @abbrev nodes in leoSettings.leo</vh></v>
<v t="ekr.20060620094645.243"><vh>Created open-users-guide command</vh></v>
<v t="ekr.20060620094645.252"><vh>scroll-up/down commands now scroll the outline if focus is in outline pane</vh></v>
<v t="ekr.20060620094645.258"><vh>Cycle-focus command cycles through tabs and editors</vh></v>
<v t="ekr.20060620094645.286"><vh>Allow @mode outside of leoSettings.leo</vh></v>
<v t="ekr.20060622130553"><vh>Added section about upgrading settings</vh></v>
<v t="ekr.20060622130553.2"><vh>Documented how to turn @buttons into plugins</vh></v>
</v>
<v t="ekr.20060620094645.302"><vh>Plugins</vh>
<v t="ekr.20060620094645.303"><vh>Added doc-only option to rst3</vh></v>
<v t="ekr.20060620094645.304"><vh>Fixed bug in rst doc_only_mode</vh></v>
<v t="ekr.20060620094645.305"><vh>Support show_headlines options in doc-only mode in rst3 plugin</vh></v>
<v t="ekr.20060620094645.306"><vh>Fixed bug in UNL plugin</vh></v>
<v t="ekr.20060620094645.307"><vh>Improved image plugin</vh></v>
<v t="ekr.20060620094645.308"><vh>Fixed path problem with rst3 plugin</vh></v>
<v t="ekr.20060620094645.309"><vh>Fixed crashers in scheduler plugin</vh></v>
</v>
<v t="ekr.20060622132524"><vh>Settings</vh>
<v t="ekr.20060620094645.299"><vh>Added editor_orientation setting</vh></v>
</v>
</v>
<v t="ekr.20060629083400.1"><vh>4.4.1 b3</vh>
<v t="ekr.20060629083935.2"><vh>Bugs fixed</vh>
<v t="ekr.20060629083935.3"><vh>Fixed recent bug: Ctrl-g does not work in @mode nodes</vh></v>
<v t="ekr.20060629083935.8"><vh>Update column display when typing</vh></v>
<v t="ekr.20060629083935.15"><vh>Fixed long-standing problem reporting indentation errors</vh></v>
<v t="ekr.20060629083935.25"><vh>Fixed long-standing bug in Remove Sentinels command</vh></v>
<v t="ekr.20060629083935.32"><vh>Fixed long-standing bugs in import code</vh></v>
<v t="ekr.20060629083935.61"><vh>Overwrite mode now works in headllines</vh></v>
<v t="ekr.20060629083935.70"><vh>Fixed crasher in masterCommand</vh></v>
<v t="ekr.20060629083935.71"><vh>Improved view-lossage command</vh></v>
</v>
<v t="ekr.20060629083935.74"><vh>New features</vh>
<v t="ekr.20060629083935.75"><vh>Finished repeat-complex-command</vh></v>
<v t="ekr.20060629083935.76"><vh>Read leoSettings.leo from the directory containing the .leo file</vh></v>
<v t="ekr.20060629083935.93"><vh>Flash matching parens &amp; corresponding settings</vh></v>
</v>
<v t="ekr.20060629083935.96"><vh>New settings</vh>
<v t="ekr.20060629083935.97"><vh>Added standard bindings for Ctrl-y (yank) and Ctrl-k (kill-line)</vh></v>
<v t="ekr.20060629083935.98"><vh>Added @bool warn_about_redefined_shortcuts setting</vh></v>
<v t="ekr.20060629083935.99"><vh>Added @bool trace_bind_key_exceptions setting</vh></v>
<v t="ekr.20060629083935.100"><vh>Added bracket flash settings</vh></v>
</v>
</v>
<v t="ekr.20060903102158"><vh>4.4.1.1 final</vh></v>
</v>
<v t="ekr.20061008190905"><vh>4.4.2... opml, zodb, sax, myLeoSettings, leoPymacs, autocontract, outline nav</vh>
<v t="ekr.20060928172040"><vh>4.4.2 beta 1</vh>
<v t="ekr.20060928172525.81"><vh>The 'big reorg':  vnode, tnode and position classes are independent of the rest of Leo</vh></v>
<v t="ekr.20060928195040"><vh>New features</vh>
<v t="ekr.20060928194633.1"><vh>myLeoSettings.leo</vh></v>
<v t="ekr.20060928172525.195"><vh>Created simple support for ZODB databases</vh>
<v t="ekr.20060928172525.197"><vh>Scripting using zodb</vh></v>
</v>
<v t="ekr.20060928172525.172"><vh>Improved help-for-command</vh></v>
<v t="ekr.20060928172525.180"><vh>Improved  quick-find commands</vh></v>
<v t="ekr.20060928172525.198"><vh>Improved how Leo works w/o the mousre</vh></v>
<v t="ekr.20060928172525.237"><vh>Increased speed of arrow keys</vh></v>
<v t="ekr.20060928172525.240"><vh>Find command now collapses nodes during searches</vh></v>
<v t="ekr.20060928172525.252"><vh>Added support  -- comments in @url nodes</vh></v>
<v t="ekr.20060928172525.167"><vh>Added many new commands to Cmds menu</vh></v>
</v>
<v t="ekr.20060928195040.1"><vh>New plugins</vh></v>
</v>
<v t="ekr.20061008190655"><vh>4.4.2 beta 2</vh>
<v t="ekr.20061008190633.248"><vh>Bugs</vh>
<v t="ekr.20061008190633.249"><vh>Fixed rst3 problem</vh></v>
<v t="ekr.20061008190633.250"><vh>Fixed apparent bug in pmw</vh></v>
<v t="ekr.20061008190633.257"><vh>Fixed various unicode word-select problems</vh></v>
<v t="ekr.20061008190633.261"><vh>Installed installer patch</vh></v>
<v t="ekr.20061008190633.262"><vh>Use letter accellerators for recent files after 9</vh></v>
<v t="ekr.20061008190633.264"><vh>Made yank work in minibuffer</vh></v>
<v t="ekr.20061008190633.265"><vh>Mass change to edit commands: made sure w is a text widget</vh></v>
<v t="ekr.20061008190633.283"><vh>Do full recolor after cut/paste/yank</vh></v>
<v t="ekr.20061008190633.294"><vh>Fixed crash when pasting a node</vh></v>
</v>
<v t="ekr.20061008192040"><vh>Settings</vh>
<v t="ekr.20061008190633.298"><vh>Completed support for myLeoSettings.leo</vh></v>
<v t="ekr.20061008190633.306"><vh>Added settings for all mod_scripting switches</vh></v>
<v t="ekr.20061008190633.307"><vh>Added @bool collapse_nodes_during_finds</vh></v>
<v t="ekr.20061008190633.325"><vh>Added @bool outline_pane_has_initial_focus</vh></v>
<v t="ekr.20061008190633.362"><vh>Added @bool sparse_move_outline_left</vh></v>
<v t="ekr.20061008190633.360"><vh>Added bindings for Alt-Shift-Arrow keys to force an outline move</vh></v>
<v t="ekr.20061009112808"><vh>Added @bool use_sax_based_read </vh></v>
</v>
<v t="ekr.20061008192040.1"><vh>New commands</vh>
<v t="ekr.20061008190633.354"><vh>Added extend-to-line command</vh></v>
<v t="ekr.20061008190633.356"><vh>Improved print-bindings command</vh></v>
<v t="ekr.20061008190633.364"><vh>Created extend-to-sentence and extend-to-paragraph commands</vh></v>
<v t="ekr.20061008190633.371"><vh>Created runEditCommandTest</vh></v>
</v>
<v t="ekr.20061008190633.295"><vh>Features</vh>
<v t="ekr.20070622180342"><vh>Added chapters</vh></v>
<v t="ekr.20061008190633.296"><vh>Improved the mod_scripting plugin</vh></v>
<v t="ekr.20061008190633.297"><vh>rst3 plugin now registers the rst3-process-tree command</vh></v>
<v t="ekr.20061008190633.311"><vh>Made writing .leo files faster</vh></v>
<v t="ekr.20061008190633.347"><vh>Generalized navigation in outline pane to ignore @file, @thin, etc prefixes</vh></v>
<v t="ekr.20061008190633.351"><vh>Made outline navigation cumulative</vh></v>
<v t="ekr.20061008190633.353"><vh>added p.archivedPosition</vh></v>
<v t="ekr.20061008190633.382"><vh>(Integrated sax with read logic)</vh></v>
</v>
<v t="ekr.20061009074305"><vh>Leap 204. "New" positions allow Leo outlines to represent arbitrary directed graphs</vh></v>
</v>
<v t="ekr.20061020155306"><vh>4.4.2 beta 3</vh>
<v t="ekr.20061020155235.1"><vh>Bugs</vh>
<v t="ekr.20061020155235.2"><vh>Fixed crash when searching for headllines containing unicode chars</vh></v>
<v t="ekr.20061020155235.9"><vh>Fixed bugs in cycle-all-focus command</vh></v>
<v t="ekr.20061020155235.27"><vh>Fixed bug with Alt-n keys</vh></v>
<v t="ekr.20061020155235.36"><vh>Fix bug: closing a window after removing a script button can crash</vh></v>
<v t="ekr.20061020155235.37"><vh>The end-of-script message no longer yanks focus from tabs</vh></v>
<v t="ekr.20061020155235.41"><vh>Fixed  warning if minibuffer command does not exist when making menus</vh></v>
<v t="ekr.20061020155235.47"><vh>Fixed new unicode bug</vh></v>
<v t="ekr.20061020155235.123"><vh>Made 'About Plugin' dialog scrollable</vh></v>
<v t="ekr.20061020155235.124"><vh>Removed unwanted key-state message</vh></v>
<v t="ekr.20061020155235.126"><vh>Made sure all kill commands do a full recolor</vh></v>
<v t="ekr.20061020155235.149"><vh>Fixed bug in new colorizer</vh></v>
<v t="ekr.20061020155235.180"><vh>Removed set-mark-command and all calls to removeRKeys</vh></v>
<v t="ekr.20061020155235.185"><vh>Fixed body editor problems</vh></v>
<v t="ekr.20061020155235.254"><vh>Moved @import to top of doc/default.css</vh></v>
<v t="ekr.20061020155235.255"><vh>Fixed focus problem when double-clicking @url nodes</vh></v>
</v>
<v t="ekr.20061020155235.263"><vh>Features</vh>
<v t="ekr.20061020155235.271"><vh>Added minibuffer and Settings menus</vh></v>
<v t="ekr.20061020155235.292"><vh>Toggling autocompleter and calltips now write to log (in red) instead of the statusLine</vh></v>
<v t="ekr.20061020155235.294"><vh>Finished collapse-on-move-left</vh></v>
<v t="ekr.20061020155235.304"><vh>Properly create Help menu on the Mac</vh></v>
<v t="ekr.20061020155235.307"><vh>'*command-name' in headline means convert '-' to blanks</vh></v>
<v t="ekr.20061020155235.308"><vh>Removed all references to commands from menu tables</vh></v>
<v t="ekr.20061020155235.335"><vh>Add Open scripts.leo to help menu</vh></v>
<v t="ekr.20061020155235.337"><vh>The spell tab now uses ctypes for Python 2.5</vh></v>
<v t="ekr.20061020155235.385"><vh>Simulated x-windows middle-button paste</vh></v>
</v>
<v t="ekr.20061020155235.393"><vh>Plugins</vh>
<v t="ekr.20061020155235.394"><vh>Fixed keyBindings plugin</vh></v>
<v t="ekr.20061020155235.395"><vh>The scripting plugin now creates a delete-x-script-button command for each script button</vh></v>
<v t="ekr.20061020155235.396"><vh>Fixed the nodenavigator plugin</vh></v>
<v t="ekr.20061020155235.397"><vh>Rewrote the multifile plugin for the 4.x code base.</vh></v>
<v t="ekr.20061020155235.398"><vh>Replaced __name__ with __plugin_name__ in four plugins</vh></v>
<v t="ekr.20061020155235.399"><vh>Improved the scripting plugin</vh></v>
<v t="ekr.20061020155235.400"><vh>Fixed bugs in multi-file plugin</vh></v>
<v t="ekr.20061020155235.402"><vh>Fix bug in shortcut_button plugin</vh></v>
<v t="ekr.20061020155235.125"><vh>Removed datenodes.ini from cvs</vh></v>
<v t="ekr.20061020155235.34"><vh>Fix bug in ops plugin</vh></v>
<v t="ekr.20061020155235.35"><vh>Fixed crasher on script button balloons</vh></v>
</v>
<v t="ekr.20061020155235.403"><vh>Settings</vh>
<v t="ekr.20061020155235.404"><vh>Made unlimited undo the default</vh></v>
<v t="ekr.20061020155235.405"><vh>Added @bool select_all_text_when_editing_headlines</vh></v>
<v t="ekr.20061020155235.410"><vh>Added bindings to toggle-autocompleter and toggle-calltips</vh></v>
<v t="ekr.20061020155235.411"><vh>Added 'Candidates for myLeoSettings.leo' to leoSettings.leo</vh></v>
<v t="ekr.20061020155235.412"><vh>Recent changes to settings</vh></v>
<v t="ekr.20061020155235.413"><vh>Added @bool insert_new_nodes_at_end</vh></v>
<v t="ekr.20061020155235.264"><vh>Removed .leoRecentFiles.txt from distribution and cvs</vh></v>
</v>
</v>
<v t="ekr.20061026095728"><vh>4.4.2 final and 4.4.2.1 final</vh>
<v t="ekr.20061026095922.1"><vh>Bugs</vh>
<v t="ekr.20061026095922.2"><vh>Changed leo_rst.css to pass the w3 validator</vh></v>
<v t="ekr.20061026095922.3"><vh>Fixed 'Run on string' message when typing</vh></v>
<v t="ekr.20061026095922.15"><vh>Fixed problem with c++ extensions</vh></v>
<v t="ekr.20061026095922.17"><vh>Move on if regexp matches an empty string</vh></v>
<v t="ekr.20061026095922.19"><vh>Fixed several bugs related to multiple body panes</vh></v>
<v t="ekr.20061026095922.25"><vh>Fixed multipath plugin so it works with new colorizier</vh></v>
<v t="ekr.20061026095922.32"><vh>Fixed bug in new colorizer</vh></v>
<v t="ekr.20061026095922.33"><vh>Fixed config bug</vh></v>
</v>
<v t="ekr.20061026095922.35"><vh>New features</vh>
<v t="ekr.20061026095922.51"><vh>Added forward-end-word/-extend-selection commands</vh></v>
<v t="ekr.20061026095922.36"><vh>Created leoPymacs.py for interaction with pymacs</vh></v>
</v>
</v>
</v>
<v t="ekr.20070316182323"><vh>4.4.3... winpdb, leoBridge, gui reorg, chapters</vh>
<v t="ekr.20070122070619"><vh>4.4.3 alpha 1</vh>
<v t="ekr.20070122070634.1"><vh>Bugs</vh>
<v t="ekr.20070122070634.2"><vh>Fixed an escape bug in new colorizer</vh></v>
<v t="ekr.20070122070634.4"><vh>Treat escaped characters in find patterns as a single character</vh></v>
<v t="ekr.20070122070634.13"><vh>Fixed undo problems with yank/kill</vh></v>
<v t="ekr.20070122070634.40"><vh>Fixed clone-drag problem</vh></v>
<v t="ekr.20070122070634.51"><vh>Made sure all ancestors expanded when select a body editor with multiple body editors</vh></v>
<v t="ekr.20070122070634.54"><vh>Fixed bug in CheckVersion</vh>
<v t="ekr.20070122070634.55"><vh>CheckVersion (EKR) &amp; helper</vh>
<v t="ekr.20070122070634.56"><vh>CheckVersionToInt</vh></v>
<v t="ekr.20070122070634.57"><vh>test_CheckVersionToInt</vh></v>
</v>
</v>
</v>
<v t="ekr.20070122070634.305"><vh>Code reorg for wxGui plugin</vh></v>
<v t="ekr.20070122070634.58"><vh>Features</vh>
<v t="ekr.20070122070634.59"><vh>Added handleUrlInUrlNode helper for OnIconDoubleClick</vh></v>
<v t="ekr.20070122070634.66"><vh>Only do one message re writing recent files</vh></v>
<v t="ekr.20070122070634.69"><vh>Made escape in the minibuffer work like ctrl-g</vh></v>
<v t="ekr.20070122070634.81"><vh>Clear status line in repeat-complex-command</vh></v>
<v t="ekr.20070122070634.82"><vh>Added shortcuts for goto-first/last-sibling</vh></v>
<v t="ekr.20070122070634.83"><vh>Made copied nodes valid Leo files</vh></v>
<v t="ekr.20070122070634.89"><vh>Added support for chdir_to_relative_path setting</vh></v>
<v t="ekr.20070122070634.91"><vh>changeAll now works like findAll</vh></v>
<v t="ekr.20070122070634.209"><vh>Added Find &amp; Spell tabs to log pane on startup</vh></v>
<v t="ekr.20070122070634.220"><vh>Created standard pluginsManager.txt only if it does not exist</vh></v>
<v t="ekr.20070122070634.223"><vh>Improved support for the winpdb debugger</vh></v>
<v t="ekr.20070122104240"><vh>Added \runAskOkCancelStringDialog</vh></v>
</v>
<v t="ekr.20070122070634.298"><vh>Plugins</vh>
<v t="ekr.20070122072110"><vh>The wxGui plugin is now functional</vh></v>
<v t="ekr.20070122070634.299"><vh>Changed bindings in UniversalScrolling pluing</vh></v>
<v t="ekr.20070122070634.300"><vh>Registered write-restructured-text command in rst3 plugin</vh></v>
</v>
<v t="ekr.20070122070634.301"><vh>Settings</vh>
<v t="ekr.20070122070634.302"><vh>Added @bool center_selected_tree_node</vh></v>
<v t="ekr.20070122070634.303"><vh>Added @bool invisible_outline_navigation = False</vh></v>
<v t="ekr.20070122070634.304"><vh>Added @bool show_full_tracebacks_in_scripts</vh></v>
</v>
</v>
<v t="ekr.20070316182323.1"><vh>4.4.3 alpha 2</vh>
<v t="ekr.20070316182341.1"><vh>Fixed Bugs</vh>
<v t="ekr.20070316182341.2"><vh>Fixed bugs in undo/redoNodeContents</vh></v>
<v t="ekr.20070316182341.6"><vh>Fixed minor xml problem</vh></v>
<v t="ekr.20070316182341.10"><vh>Fixed C++ import bug</vh></v>
<v t="ekr.20070316182341.39"><vh>Fixed recent bug in next-line command</vh></v>
<v t="ekr.20070316182341.41"><vh>Made standalone plugins manager work again</vh></v>
<v t="ekr.20070316182341.42"><vh>Fixed wiki markup bug</vh></v>
<v t="ekr.20070316182341.43"><vh>Fixed bugs in regular expressions</vh></v>
<v t="ekr.20070316182341.54"><vh>Fixed memory error in leoBridge</vh></v>
<v t="ekr.20070316182341.56"><vh>Fixed backspace in headline bug</vh></v>
<v t="ekr.20070316182341.66"><vh>Made sure alt-arrow keys honor focus settings</vh></v>
<v t="ekr.20070316182341.112"><vh>Fixed bug in nav button plugin</vh></v>
<v t="ekr.20070316182341.113"><vh>Fixed yet another cursor down bug</vh></v>
<v t="ekr.20070316182341.137"><vh>Improved special case in moveOutlineUp</vh></v>
<v t="ekr.20070316182341.138"><vh>Fixed crasher in rclicker plugin</vh></v>
<v t="ekr.20070316182341.139"><vh>Fixed recent problem with settings report</vh></v>
</v>
<v t="ekr.20070316182341.437"><vh>New Features</vh>
<v t="ekr.20070316182341.440"><vh>Added leoBridge module</vh></v>
<v t="ekr.20070316182341.723"><vh>Added support for @enabled-plugins in settings files</vh></v>
<v t="ekr.20070316182341.718"><vh>Added new search path for pluginsManager.txt</vh></v>
<v t="ekr.20070316182341.155"><vh>Made Leo's core gui-indenpendent</vh></v>
<v t="ekr.20070316182341.438"><vh>Warn on dubious section brackets</vh></v>
</v>
<v t="ekr.20070317044545"><vh>Plugins</vh></v>
</v>
<v t="ekr.20070513111132"><vh>4.4.3 beta 1</vh>
<v t="ekr.20070513111526.1"><vh>New features</vh>
<v t="ekr.20070513112414"><vh>Added support for chapters to Leo's core</vh></v>
<v t="ekr.20070513111526.2"><vh>Added @bool force_newlines_in_at_nosent_bodies setting</vh></v>
<v t="ekr.20070513111526.7"><vh>Added apropos-debugging-commands command</vh></v>
<v t="ekr.20070513111526.8"><vh>Added print-plugins &amp; print-plugin-handlers commands</vh></v>
<v t="ekr.20070513111526.10"><vh>Added print-settings command</vh></v>
<v t="ekr.20070513111526.14"><vh>Added support for @openwith nodes in leoSettings.leo</vh></v>
<v t="ekr.20070513111526.39"><vh>Created clean-all-lines command</vh></v>
<v t="ekr.20070513111526.42"><vh>Support for compressed .leo files</vh></v>
</v>
<v t="ekr.20070513111526.77"><vh>Fixed bugs</vh>
<v t="ekr.20070513111526.78"><vh>Fixed bug: new-file doesn't allow edit of initial headline</vh></v>
<v t="ekr.20070513111526.80"><vh>Removed all returns from finally clauses</vh></v>
<v t="ekr.20070513111526.99"><vh>Fixed crashes when trying to import aspell</vh></v>
<v t="ekr.20070513111526.105"><vh>Fixed repeatComplexCommand weirdness</vh></v>
<v t="ekr.20070513111526.198"><vh>Fixed minor chapter hoist bug</vh></v>
<v t="ekr.20070513111526.200"><vh>Fixed crasher in plugins_menu.py</vh></v>
</v>
</v>
<v t="ekr.20070610063456"><vh>4.4.3 beta 2</vh>
<v t="ekr.20070610063538.1"><vh>Fixed bugs</vh>
<v t="ekr.20070610063538.2"><vh>Fixed noweb hangs</vh></v>
<v t="ekr.20070610063538.151"><vh>Alt-4 did not work in tree pane in unitTest.leo</vh></v>
<v t="ekr.20070610063538.163"><vh>Investigated problem with subprocess (works for me)</vh></v>
<v t="ekr.20070610063538.164"><vh>Fixed crashers in leoupate plugin</vh></v>
<v t="ekr.20070610063538.165"><vh>Fixed automatic directory creation</vh></v>
<v t="ekr.20070610063538.168"><vh>Fixed bug: shift-arrow keys not bound properly when node is clicked</vh></v>
<v t="ekr.20070610063538.171"><vh>Made sure the new outlines aren't marked dirty</vh></v>
<v t="ekr.20070610063538.175"><vh>Fix crasher in maximizeNewWindows</vh></v>
<v t="ekr.20070610063538.209"><vh>Don't change focus in the save command</vh></v>
<v t="ekr.20070610063538.212"><vh>downcase-region and upcase-region didn't color body text.</vh></v>
<v t="ekr.20070611161859"><vh>Fixed *major* demote bug</vh></v>
</v>
<v t="ekr.20070610063538.280"><vh>Features</vh>
<v t="ekr.20070610063538.281"><vh>Supported write_strips_blank_lines option</vh></v>
<v t="ekr.20070610063538.334"><vh>Completed chapters</vh></v>
<v t="ekr.20070610063538.336"><vh>Aspell now works on Linux, but only using Python 2.5</vh></v>
<v t="ekr.20070610063538.366"><vh>Improved dynamic abbreviations</vh></v>
<v t="ekr.20070610063538.377"><vh>Created the hoist-changed hook</vh></v>
<v t="ekr.20070610173300"><vh>Enabled more plugins by default</vh></v>
</v>
</v>
<v t="ekr.20070622090350"><vh>4.4.3 beta 3</vh>
<v t="ekr.20070622090350.1"><vh>Fixed bugs</vh>
<v t="ekr.20070622090350.2"><vh>Allow aspell on Linux provided that ctypes exists</vh></v>
<v t="ekr.20070622090350.8"><vh>Fixed a bug that disabled icon button colors on Linux</vh></v>
<v t="ekr.20070622090350.22"><vh>Switch chapters if new position isn't in current chapter</vh></v>
<v t="ekr.20070622090350.42"><vh>Improved goto-next/prev-node commands</vh></v>
<v t="ekr.20070622090350.57"><vh>Fixed failing bridge unit test</vh></v>
</v>
<v t="ekr.20070622090350.59"><vh>New features &amp; settings</vh>
<v t="ekr.20070622090350.60"><vh>Added @bool contractVisitedNodes setting</vh></v>
<v t="ekr.20070622090350.61"><vh>Added goto-first-visible-node command</vh></v>
<v t="ekr.20070622090350.62"><vh>Changed binding of Alt-Home</vh></v>
<v t="ekr.20070622090350.65"><vh>Added @button dynamic-tests.</vh></v>
<v t="ekr.20070622090350.66"><vh>created g.unitTesting and g.getTestVars</vh></v>
<v t="ekr.20070622090350.9"><vh>Made alt menu keys work</vh></v>
</v>
</v>
<v t="ekr.20070626082732"><vh>4.4.3 final</vh></v>
<v t="ekr.20070702162421"><vh>4.4.3.1</vh>
<v t="ekr.20070703095207.1"><vh>Bugs</vh>
<v t="ekr.20070703095207.2"><vh>Fixed improper can not open myLeoSettings message</vh></v>
<v t="ekr.20070703095207.5"><vh>Fixed import problem in leoDynamicTest.py</vh></v>
<v t="ekr.20070703095207.34"><vh>Fixed cleo crasher</vh></v>
<v t="ekr.20070703095207.35"><vh>Fixed spell-check bug</vh></v>
<v t="ekr.20070703095207.40"><vh>Fixed several crashers in the group operations plugin</vh></v>
<v t="ekr.20070703095207.41"><vh>Fixed chapters bug</vh></v>
<v t="ekr.20070703095207.43"><vh>Fixed problems in groupOperations plugin</vh></v>
<v t="ekr.20070703095207.50"><vh>Fixed pychecker complaints</vh></v>
<v t="ekr.20070703095207.51"><vh>Fixed editor bug: deleting an editor did not always select the proper body pane</vh></v>
</v>
<v t="ekr.20070703095207.55"><vh>Features</vh>
<v t="ekr.20070703095207.56"><vh>g.es and g.es_print print only to console during unit tests</vh>
<v t="ekr.20070703095207.57"><vh>es_print &amp; test</vh>
<v t="ekr.20070703095207.58"><vh>@test g.es_print</vh></v>
</v>
<v t="ekr.20070703095207.59"><vh>es</vh></v>
</v>
<v t="ekr.20070703095207.61"><vh>Run unit tests in a separate process</vh></v>
<v t="ekr.20070703095207.72"><vh>Move most unit tests into external files</vh></v>
<v t="ekr.20070703095207.73"><vh>Send can not import aspell message only to the log</vh></v>
</v>
</v>
</v>
<v t="ekr.20070806090235"><vh>4.4.4 @auto, @menus, threading syntax colorer, the Great Graph Aha</vh>
<v t="ekr.20070806090235.1"><vh>4.4.4 b1</vh>
<v t="ekr.20070806090226.1"><vh>Added support for @mark-for-unit-tests node</vh></v>
<v t="ekr.20070806090226.14"><vh>Created threading_colorizer</vh></v>
<v t="ekr.20070806090226.15"></v>
</v>
<v t="ekr.20070915101216"><vh>4.4.4 b2</vh>
<v t="ekr.20070915101157.1"><vh>Bug fixes</vh>
<v t="ekr.20070915101157.3"><vh>Fixed UNL bug1</vh></v>
<v t="ekr.20070915101157.5"><vh>Fixed how @auto handles paths</vh></v>
<v t="ekr.20070915101157.14"><vh>Fixed another path bug</vh></v>
<v t="ekr.20070915101157.16"><vh>fixed c parser so it handles non-ascii declaratsions</vh></v>
<v t="ekr.20070915101157.17"><vh>Fixed colorizing bug and moved calls to w.toGuiIndex out of some loops</vh></v>
<v t="ekr.20070915101157.18"><vh>Fixed unicode bug in http plugin</vh></v>
<v t="ekr.20070915101157.19"><vh>Fixed new @path problem</vh></v>
<v t="ekr.20070915101157.40"><vh>Fixed @auto path bug</vh></v>
<v t="ekr.20070915101157.45"><vh>Improved messages on @import failure</vh></v>
<v t="ekr.20070915101157.48"><vh>Fixed problem with space in path names in runLeoDynamicTest</vh></v>
<v t="ekr.20070915101157.50"><vh>Fixed bad drag &amp; drop bug</vh></v>
<v t="ekr.20070915101157.70"><vh>Fixed bug 'node note selected' bug</vh></v>
<v t="ekr.20070915101157.81"><vh>Retain dirty bit after write @auto fails</vh></v>
</v>
<v t="ekr.20070915101157.82"><vh>Features</vh>
<v t="ekr.20070915101157.168"><vh>Read @auto nodes during saves if the node has not been read previously</vh></v>
<v t="ekr.20070920092716"></v>
</v>
</v>
<v t="ekr.20071004101349"><vh>4.4.4 b3</vh>
<v t="ekr.20071004101443.1"><vh>Bugs fixed</vh>
<v t="ekr.20071004101443.18"><vh>Greatly improved speed of unmark-all</vh></v>
<v t="ekr.20071004101443.26"><vh>Made sure dirty bits get updated in xemacs plugin</vh></v>
<v t="ekr.20071021111856.20"><vh>Fixed backward find bug</vh></v>
<v t="ekr.20071021111856.83"><vh>Fixed cursor up/down problem</vh></v>
<v t="ekr.20071021111856.124"><vh>Fixed unicode bug in trace</vh></v>
<v t="ekr.20071021111856.127"><vh>Fixed chapter crasher</vh></v>
<v t="ekr.20071021111856.252"><vh>Installed patch to fix Fedora Tk.Text bug</vh></v>
<v t="ekr.20071021111856.437"><vh>Fixed bug in rst3 plugin</vh></v>
<v t="ekr.20071021111856.461"><vh>Allow unicode characters in Leo file names</vh></v>
<v t="ekr.20071023080957"><vh>Fixed bugs when running unit tests externally</vh></v>
</v>
<v t="ekr.20071004101443.29"><vh>New Features</vh>
<v t="ekr.20071004103659"></v>
<v t="ekr.20071021111856.441"><vh>Rewrote threading colorizer</vh></v>
<v t="ekr.20070806090226.15"></v>
<v t="ekr.20071004101443.52"><vh>Added @buttons trees in @settings trees</vh></v>
<v t="ekr.20071004101443.105"><vh>Added @menus trees in @settings trees</vh></v>
<v t="ekr.20070920092716"></v>
<v t="ekr.20071004105000"><vh>Added the graphed plugin</vh></v>
<v t="ekr.20071004101443.178"></v>
<v t="ekr.20071004101443.30"><vh>Added button font settings</vh></v>
<v t="ekr.20071005095907"><vh>Leo's core is now compatible with jython</vh></v>
<v t="ekr.20071006093614"><vh>Added the insert-child command</vh></v>
<v t="ekr.20071006155647"><vh>@bool add_ws_to_kill_ring setting</vh></v>
<v t="ekr.20071021111856.412"><vh>Improved yank and yank-pop commands</vh></v>
<v t="ekr.20071021111856.458"><vh>Improved debug command</vh></v>
<v t="ekr.20071021111856.459"><vh>Added the @bool rst3 strip_at_file_prefixes setting</vh></v>
<v t="ekr.20071021111856.476"><vh>Added g.app.inBridge ivar</vh></v>
<v t="ekr.20071021111856.477"><vh>Improved the scripting and plugins chapters of Leo's Users Guide</vh></v>
</v>
</v>
<v t="ekr.20071026053825"><vh>4.4.4 b4</vh>
<v t="ekr.20071026053931.1"><vh>Fixed bugs</vh>
<v t="ekr.20071026053931.2"><vh>Fixed aspell problem</vh></v>
<v t="ekr.20071026053931.13"><vh>Fixed bug: utf-8 files now get imported properly</vh></v>
<v t="ekr.20071026053931.156"><vh>Replaced c.frame.body with c.frame.body.bodyCtrl</vh></v>
<v t="ekr.20071026053931.157"><vh>Fixed (maybe) multi-editor bug</vh></v>
<v t="ekr.20071026053931.219"><vh>Made sure proper node is visible when deleting a body editor</vh></v>
<v t="ekr.20071026053931.220"><vh>Fixed colorizer end-of-text bug</vh></v>
<v t="ekr.20071026075016"><vh>Added support for fastGotoNode plugin to leoKeyEvent classes</vh></v>
<v t="ekr.20071026092552"><vh>Fixed bug that disabled multiple occurances of the same user icon</vh></v>
</v>
<v t="ekr.20071026182824"><vh>Added features</vh>
<v t="ekr.20071026053931.221"><vh>Added @bool big_outline_pane setting</vh></v>
<v t="ekr.20071026053931.234"><vh>Can print *can* handle unicode</vh></v>
<v t="ekr.20071026180804.1"><vh>Improved the prototype of icon handling</vh></v>
</v>
</v>
<v t="ekr.20071101162646"><vh>4.4.4 Final</vh>
<v t="ekr.20071101162751"><vh>Fixed bugs</vh>
<v t="ekr.20071101162751.2"><vh>Fixed bug that caused rClick plugin to crash</vh></v>
<v t="ekr.20071101162751.4"><vh>Fixed scrolling problem with chapters</vh></v>
<v t="ekr.20071101162751.19"><vh>Fixed bug: select a chapter containing the initially selected node</vh></v>
<v t="ekr.20071101162751.28"><vh>Fixed Apple help menu reversion</vh></v>
<v t="ekr.20071101162751.32"><vh>Disabled the plugins manage plugin</vh></v>
<v t="ekr.20071101162751.33"><vh>Made sure plugins work if frame.iconFrame is None</vh></v>
<v t="ekr.20071101162751.34"><vh>Fixed @auto java bug</vh></v>
<v t="ekr.20071101162751.97"><vh>Fixed spell-check problem on Linux</vh></v>
<v t="ekr.20071101162751.149"><vh>Use the default spell tab</vh></v>
<v t="ekr.20071101162751.150"><vh>Fixed long-standing and important body editor bug</vh></v>
<v t="ekr.20071101162751.178"><vh>Non-ignored @auto trees do not get saved to the .leo file</vh></v>
<v t="ekr.20071101162751.184"><vh>Fixed bug that cause the import of PyParse.py to fail</vh></v>
<v t="ekr.20071101163257"><vh>Improved error reporting in rst3 plugins for code_block directive</vh></v>
</v>
</v>
</v>
<v t="ekr.20071115102421"><vh>4.4.5 bug fixes</vh>
<v t="ekr.20071115102156"><vh>Leo 4.4.5 b1</vh>
<v t="ekr.20071115102156.5"><vh>Fixed bugs</vh>
<v t="ekr.20071115102156.2"><vh>Removed all references to pluginsManager.txt</vh></v>
<v t="ekr.20071115102156.6"><vh>Fixed hung windows</vh></v>
<v t="ekr.20071115102156.11"><vh>Warn on resurrected (vampire) nodes</vh></v>
<v t="ekr.20071115102156.21"><vh>Fixed new @auto bug (python)</vh></v>
<v t="ekr.20071115102156.78"><vh>Fixed new @auto bug: c++</vh></v>
<v t="ekr.20071115102156.79"><vh>Fixed various @auto comparison problems</vh></v>
<v t="ekr.20071115102156.81"><vh>Retain relative paths in recent files menu</vh></v>
<v t="ekr.20071115102156.123"><vh>Fixed windows registry problem</vh></v>
<v t="ekr.20071115102156.124"><vh>Fixed paste node as clone crasher</vh></v>
<v t="ekr.20071115102156.141"><vh>Fixed hoist crasher</vh></v>
<v t="ekr.20071115102156.146"><vh>Ignore unpickling problems in getUa</vh></v>
</v>
<v t="ekr.20071116081521"><vh>New commaneds</vh>
<v t="ekr.20071115102156.238"><vh>toggle-collapse_nodes_during_finds</vh></v>
<v t="ekr.20071115102156.256"><vh>3 new sort-lines commands</vh></v>
<v t="ekr.20071115102156.303"><vh>Added Cmd:Icons menu and commands</vh></v>
</v>
<v t="ekr.20071115102156.148"><vh>New features</vh>
<v t="ekr.20071115102156.149"><vh>Leo now recognizes directives in headlines</vh></v>
<v t="ekr.20071115102156.301"><vh>Moved all unit tests to unitTest.leo</vh></v>
<v t="ekr.20071115102156.320"><vh>Added @rst-preformat</vh></v>
<v t="ekr.20071115102156.321"><vh>Installed small icon set from Tango library</vh></v>
</v>
<v t="ekr.20071116081521.1"><vh>New settings</vh>
<v t="ekr.20071115102156.237"><vh>@bool at_auto_warns_about_leading_whitespace</vh></v>
<v t="ekr.20071115102156.258"><vh>@bool diagnose-aspell-installation</vh></v>
<v t="ekr.20071115102156.302"><vh>@bool vim_plugin_opens_url_nodes</vh></v>
<v t="ekr.20071115102156.289"><vh>@bool warn_when_plugins_fail_to_load </vh></v>
</v>
</v>
<v t="ekr.20071206093346"><vh>Leo 4.4.5 b2</vh>
<v t="ekr.20071206093323.1"><vh>Fixed bugs</vh>
<v t="ekr.20071206093323.112"><vh>Improved error reporting for aspell on Linux</vh></v>
<v t="ekr.20071206093323.2"><vh>Fixed two crashers in the @noref logic</vh></v>
<v t="ekr.20071206093323.3"><vh>Fixed crasher in regularizeWhitespace</vh></v>
<v t="ekr.20071206093323.4"><vh>Fixed paste-node-as-clone</vh></v>
<v t="ekr.20071206093323.29"><vh>Fixed threading colorizer hang with perl</vh></v>
<v t="ekr.20071206093323.30"><vh>Fixed C++ importer crash</vh></v>
<v t="ekr.20071206093323.31"><vh>Reorganized leoImport.py</vh></v>
<v t="ekr.20071206093323.32"><vh>Fixed crasher when tangling @root</vh></v>
<v t="ekr.20071206093323.59"><vh>Fixed command lockout problem</vh></v>
<v t="ekr.20071206093323.72"><vh>Improved @auto code</vh></v>
<v t="ekr.20071206093323.76"><vh>Simplified perl colorizer and added progress checks</vh></v>
<v t="ekr.20071206093323.77"><vh>Fixed crasher in aspell logic</vh></v>
<v t="ekr.20071206093323.80"><vh>Fixed problem with decorators</vh></v>
<v t="ekr.20071206093323.87"><vh>Fixed @auto bug</vh></v>
<v t="ekr.20071206093323.96"><vh>Fixed  focus problem with goto-next clone command</vh></v>
</v>
</v>
<v t="ekr.20071211083251"><vh>Leo 4.4.5 final</vh></v>
</v>
<v t="ekr.20080106114331"><vh>4.4.6 bug fixes</vh>
<v t="ekr.20071217092250"><vh>leo 4.4.6 b1</vh>
<v t="ekr.20071217092203.1"><vh>Bugs fixed</vh>
<v t="ekr.20071217092203.2"><vh>Fixed undo (dirty bit) problem)</vh></v>
<v t="ekr.20071217092203.30"><vh>Fixed cursesGui  plugin</vh></v>
<v t="ekr.20071217092203.31"><vh>Fixed script_io_to_body plugin</vh></v>
<v t="ekr.20071217092203.45"><vh>Make Import to @file create @file nodes</vh></v>
<v t="ekr.20071217092203.51"><vh>Fixed bug: rst3 plugin now finds default.css file correctly</vh></v>
<v t="ekr.20071217092203.52"><vh>Fixed bug with clear-recent-files</vh></v>
<v t="ekr.20071217092203.64"><vh>Fixed bug: replace didn't always start in the correct place</vh></v>
<v t="ekr.20071217092203.127"><vh>fixed colorizer bug</vh></v>
<v t="ekr.20071217092203.128"><vh>Fixed clone focus bug</vh></v>
<v t="ekr.20071217092203.130"><vh>Removed call to printLine in change-all logic</vh></v>
<v t="ekr.20071217092203.131"><vh>Fixed crash when copying or cloning to non-exisitent chapter</vh></v>
<v t="ekr.20071217092203.161"><vh>Added text bindings to status area</vh></v>
<v t="ekr.20071217092203.136"><vh>Repaired damaged minusnode.gif icon</vh></v>
</v>
<v t="ekr.20071217092203.137"><vh>New features</vh>
<v t="ekr.20071217092203.138"><vh>Applied Terry Brown's config patch</vh></v>
<v t="ekr.20071217092203.145"><vh>Applied plumloco's patch to plugins_menu.py</vh></v>
<v t="ekr.20071217092203.146"><vh>Upgraded to Pmw 1.3</vh></v>
<v t="ekr.20071217092203.147"><vh>Added find-next-clone command</vh></v>
<v t="ekr.20071217092203.149"><vh>Added toggle-sparse-move command</vh></v>
<v t="ekr.20071217092203.152"><vh>Added support for @data nodes in @settings trees</vh></v>
<v t="ekr.20071217092203.154"><vh>Added @auto xml script</vh></v>
<v t="ekr.20071217092203.163"><vh>Added @import scanners for javascript and xml files</vh></v>
</v>
</v>
<v t="ekr.20080106114225"><vh>leo 4.4.6 b2</vh>
<v t="ekr.20080106114648"><vh>Fixed bugs</vh>
<v t="ekr.20080106114203.1"><vh>Fixed bug in nav_buttons plugin</vh></v>
<v t="ekr.20080106114203.2"><vh>Fixed problems with modes/rest.py</vh></v>
<v t="ekr.20080106114203.3"><vh>Replaced delete-all-icons command with a script in script.leo</vh></v>
<v t="ekr.20080106114203.4"><vh>Leo issues better messages if Image can not be imported</vh></v>
<v t="ekr.20080115093848.18"><vh>Added convenience methods for icons</vh></v>
<v t="ekr.20080115093848.19"><vh>Fixed undo bug</vh></v>
<v t="ekr.20080115093848.23"><vh>Don't mark nodes dirty if insert-icon is cancelled</vh></v>
</v>
</v>
<v t="ekr.20080126090039"><vh>leo 4.4.6 final</vh></v>
</v>
<v t="ekr.20080218154129"><vh>4.4.7 ipython plugin</vh>
<v t="ekr.20080212221734"><vh>leo 4.4.7 b1 </vh>
<v t="ekr.20080212221711.1"><vh>Fixed bugs</vh>
<v t="ekr.20080212221711.2"><vh>Fixed perl syntax coloring bug</vh></v>
<v t="ekr.20080212221711.4"><vh>Removed warnings while typing @language directives</vh></v>
<v t="ekr.20080212221711.15"><vh>Fixed pascal import bug</vh></v>
<v t="ekr.20080212221711.35"><vh>write-outline-only command now prints a 'done' message</vh></v>
<v t="ekr.20080213094948.1"><vh>Worked around problems with winpdb</vh></v>
<v t="ekr.20080213094948.4"><vh>Fixed new problem with image.py</vh></v>
</v>
<v t="ekr.20080212221711.32"><vh>New features</vh>
<v t="ekr.20080212221711.33"><vh>All import commands now honor @path</vh></v>
<v t="ekr.20080212221711.34"><vh>Added ipython plugin</vh></v>
<v t="ekr.20080212221711.47"><vh>Added support for @bool open_with_save_on_update setting</vh></v>
<v t="ekr.20080212221711.26"><vh>Improved handling of unicode for @auto files</vh></v>
</v>
</v>
<v t="ekr.20080218153931"><vh>leo 4.4.7 final</vh>
<v t="ekr.20080218153931.1"><vh>Fixed bugs</vh>
<v t="ekr.20080218153931.2"><vh>Fixed perl syntax coloring bug</vh></v>
<v t="ekr.20080218153931.3"><vh>Removed warnings while typing @language directives</vh></v>
<v t="ekr.20080218153931.4"><vh>Fixed pascal import bug</vh></v>
<v t="ekr.20080218153931.5"><vh>write-outline-only command now prints a 'done' message</vh></v>
<v t="ekr.20080218153931.6"><vh>Worked around problems with winpdb</vh></v>
<v t="ekr.20080218153931.7"><vh>Fixed new problem with image.py</vh></v>
<v t="ekr.20080218154129.1"><vh>Leo's old colorizer now colorizes Leo directives properly</vh></v>
</v>
<v t="ekr.20080218153931.8"><vh>New features</vh>
<v t="ekr.20080218153931.9"><vh>All import commands now honor @path</vh></v>
<v t="ekr.20080218153931.10"><vh>Added ipython plugin</vh></v>
<v t="ekr.20080218153931.11"><vh>Added support for @bool open_with_save_on_update setting</vh></v>
<v t="ekr.20080218153931.12"><vh>Improved handling of unicode for @auto files</vh></v>
</v>
</v>
</v>
<v t="ekr.20080311060457.215"><vh>4.4.8 translating args to g.es and g.es_print</vh>
<v t="ekr.20080304112808"><vh>4.4.8 b1</vh>
<v t="ekr.20080304112802.1"><vh>Allow arguments to minibuffer commands</vh></v>
<v t="ekr.20080304112802.25"><vh>Added translation services</vh>
<v t="ekr.20080310093038.4"></v>
</v>
</v>
<v t="ekr.20080311060457.1"><vh>4.4.8 b2</vh>
<v t="ekr.20080311060457.210"><vh>b1</vh>
<v t="ekr.20080311060457.211"><vh>Allow arguments to minibuffer commands</vh></v>
<v t="ekr.20080311060457.212"><vh>Added translation services</vh>
<v t="ekr.20080311060457.213"><vh>Translating Leo's menus and messages</vh></v>
</v>
</v>
<v t="ekr.20080311060457.216"><vh>b2</vh>
<v t="ekr.20080311060457.2"><vh>Bug fixes</vh>
<v t="ekr.20080311060457.3"><vh>Assigned g.fileIndex on the fly</vh></v>
<v t="ekr.20080311060457.28"><vh>Allow tkFrame to complete before killing it</vh></v>
<v t="ekr.20080311060457.38"><vh>Renamed self.fileIndex to  readBufferIndex in file read logic</vh></v>
<v t="ekr.20080311060457.125"><vh>Made sure that all fileIndex fields get converted on read</vh></v>
</v>
<v t="ekr.20080311060457.128"><vh>Features</vh>
<v t="ekr.20080311060457.188"><vh>Compile regexp's once in findNextMatch</vh></v>
<v t="ekr.20080311060457.198"><vh>Created menus very late in the creation process</vh></v>
<v t="ekr.20080314081157.1"><vh>Improved marks/recent buttons plugin</vh></v>
<v t="ekr.20080314081157.2"><vh>Added support for @commands trees in settings files</vh></v>
</v>
</v>
</v>
<v t="ekr.20080328074117.340"><vh>4.4.8 b3</vh>
<v t="ekr.20080328074117.2"><vh>Fixed bugs</vh>
<v t="ekr.20080328074117.3"><vh>Corrected docs: unit tests are in test/unitTest.leo</vh></v>
<v t="ekr.20080328074117.4"><vh>Removed '.' from leoID</vh></v>
<v t="ekr.20080328074117.12"><vh>Fixed Open With menu</vh></v>
<v t="ekr.20080328074117.30"><vh>Fixed @lineending botch</vh></v>
<v t="ekr.20080328074117.76"><vh>Fixed undo problem with mutliple editors</vh></v>
<v t="ekr.20080328074117.77"><vh>Write dirty bit if write fails</vh></v>
<v t="ekr.20080328074117.135"><vh>Fixed bug involving default_target_language</vh></v>
<v t="ekr.20080328074117.215"><vh>Fixed plugins that create new menu items</vh></v>
</v>
<v t="ekr.20080328074117.216"><vh>Features</vh>
<v t="ekr.20080328074117.217"><vh>Added @bool collapse_nodes_while_spelling setting</vh></v>
<v t="ekr.20080328074117.220"><vh>Errors reading external files give line numbers</vh></v>
<v t="ekr.20080328074117.262"><vh>Added @bool allow_middle_button_paste</vh></v>
<v t="ekr.20080328074117.297"><vh>Added support for @popup settings</vh></v>
</v>
</v>
<v t="ekr.20080403065258.10"><vh>4.4.8 rc1</vh>
<v t="ekr.20080403065258.6"><vh>Fixed delete-editor problem</vh></v>
</v>
</v>
<v t="ekr.20080405074410.4"><vh>4.4.8 final</vh>
<v t="ekr.20080405074410.7"><vh>Open leoPluginsRef.leo in help menu if leoPlugins.leo does not exist</vh></v>
<v t="ekr.20080405074410.9"><vh>Fixed big performance bug in find/spell commands.</vh></v>
<v t="ekr.20080405074410.38"><vh>Fixed several unit testing bugs relating to doTests(all=True)</vh></v>
</v>
</v>
<v t="ekr.20080730095710.1"><vh>4.5 code reorgs, vim bindings, @shadow</vh>
<v t="ekr.20080624093059.1"><vh>4.5 b1</vh>
<v t="ekr.20080624093059.2"><vh>Bug fixes</vh>
<v t="ekr.20080624093059.3"><vh>Fixed bug in appendToRecentFiles</vh></v>
<v t="ekr.20080624093059.4"><vh>Fixed bug in install script</vh></v>
<v t="ekr.20080624093059.5"><vh>Fixed bug: no focus after save-as and save-to commands</vh></v>
<v t="ekr.20080624093059.6"><vh>Fixed find bug</vh></v>
<v t="ekr.20080624093059.7"><vh>Fixed find completion bug</vh></v>
<v t="ekr.20080624093059.8"><vh>Fixed how-many, find-word and goto-character commands</vh></v>
<v t="ekr.20080624093059.9"><vh>Fixed import PHP bug</vh></v>
<v t="ekr.20080624093059.10"><vh>Fixed keyword handling in g.es and g.es_print</vh></v>
<v t="ekr.20080624093059.11"><vh>Fixed new @auto bug</vh></v>
<v t="ekr.20080624093059.12"><vh>Fixed recent files bug</vh></v>
<v t="ekr.20080624093059.13"><vh>Fixed Tangle bugs</vh></v>
<v t="ekr.20080624093059.14"><vh>Greatly increased speed of undo clone-find-all</vh></v>
<v t="ekr.20080624093059.15"><vh>Temporary fix for php import bug</vh></v>
<v t="ekr.20080624093059.16"><vh>Fixed unbounded loop in autocompleter.findAnchor</vh></v>
<v t="ekr.20080624093059.17"><vh>Fixed insert-newline bug</vh></v>
<v t="ekr.20080624093059.18"><vh>Single click did not color body correctly</vh></v>
<v t="ekr.20080624093059.19"><vh>Body not colored correctly after find</vh></v>
<v t="ekr.20080624093059.20"><vh>Fixed big performance bug in contract-all command</vh></v>
<v t="ekr.20080624093059.21"><vh>Changed bindings so Home and end keys work as expected when editing a headline</vh></v>
<v t="ekr.20080624093059.22"><vh>Fixed bug: myLeoSettings.leo sometimes read twice</vh></v>
<v t="ekr.20080624093059.23"><vh>Compute menus list for each c</vh></v>
<v t="ekr.20080624093059.24"><vh>Fixed minor spelling bug</vh></v>
<v t="ekr.20080624093059.25"><vh>Fixed spell bug: words containing unicode characters aren't saved properly</vh></v>
<v t="ekr.20080624093059.26"><vh>Fixed coloring bugs in reformatParagraph and c.redraw</vh></v>
<v t="ekr.20080624093059.27"><vh>Fixed missing redraw problem</vh></v>
<v t="ekr.20080624093059.28"><vh>Fixed new-headline problem</vh></v>
<v t="ekr.20080624093059.29"><vh>Fixed recent crasher</vh></v>
<v t="ekr.20080624093059.30"><vh>Fixed encoding problems with paste from clipboard</vh></v>
<v t="ekr.20080624093059.31"><vh>Changed installer to support leo-as-a-package</vh></v>
<v t="ekr.20080628062747.69"><vh>Fixed undo problem</vh></v>
<v t="ekr.20080628062747.70"><vh>Fixed insert-file bug</vh></v>
<v t="ekr.20080628062747.71"><vh>Fixed script button bug</vh></v>
<v t="ekr.20080628062747.72"><vh>Fixed dragging bug</vh></v>
</v>
<v t="ekr.20080624093059.32"><vh>Features</vh>
<v t="ekr.20080624093059.33"><vh>Remove useTextWidget option from leoKeys.py</vh></v>
<v t="ekr.20080624093059.34"><vh>Set use_sax = True always</vh></v>
<v t="ekr.20080624093059.35"><vh>Added g.unified_nodes</vh></v>
<v t="ekr.20080624093059.36"><vh>Added install nodes re Leo's home directory</vh></v>
<v t="ekr.20080624093059.37"><vh>Added support for @bool fixedWindow option</vh></v>
<v t="ekr.20080624093059.38"><vh>Added new key-handling</vh></v>
<v t="ekr.20080624093059.39"><vh>New drawing/focus code</vh></v>
<v t="ekr.20080624093059.40"><vh>Improved end of calltips</vh></v>
<v t="ekr.20080624093059.41"><vh>Find character crosses lines</vh></v>
<v t="ekr.20080624093059.42"><vh>Added os.curdir to sys.path if possible</vh></v>
<v t="ekr.20080624093059.43"><vh>Added support for single-config option</vh></v>
<v t="ekr.20080624093059.44"><vh>Finished Tracer class</vh></v>
<v t="ekr.20080624093059.45"><vh>Rewrote option-parsing code using optparse</vh></v>
<v t="ekr.20080624093059.46"><vh>Added @bool cleo_color_ignore = True</vh></v>
<v t="ekr.20080624093059.47"><vh>Set cwd in read/write commands</vh></v>
<v t="ekr.20080624093059.48"><vh>Added  vim patches</vh>
<v t="ekr.20080624093059.49"><vh>Realization</vh></v>
<v t="ekr.20080624093059.50"><vh>Problems</vh></v>
<v t="ekr.20080624093059.51"><vh>Notes</vh></v>
</v>
<v t="ekr.20080624093059.52"><vh>Added 'kill' bindings</vh></v>
<v t="ekr.20080624093059.53"><vh>Added check for empty @nosent nodes</vh></v>
</v>
</v>
<v t="ekr.20080730095710.2"><vh>4.5 b2</vh>
<v t="ekr.20080806211440.188"></v>
<v t="ekr.20080806211440.253"></v>
<v t="ekr.20080806211440.256"></v>
<v t="ekr.20080806211440.189"></v>
</v>
<v t="ekr.20080815093141.89"><vh>4.5 b3</vh>
<v t="ekr.20080815093141.90"><vh>Major new features</vh></v>
<v t="ekr.20080815093141.91"><vh>Major code reorganizations</vh></v>
<v t="ekr.20080815093141.92"><vh>Minor new features</vh></v>
<v t="ekr.20080815093141.93"><vh>New settings</vh></v>
</v>
<v t="ekr.20080827175609.55"><vh>4.5 rc1</vh>
<v t="ekr.20080827175609.56"><vh>Major new features</vh></v>
<v t="ekr.20080827175609.57"><vh>Major code reorganizations</vh></v>
<v t="ekr.20080827175609.58"><vh>Minor new features</vh></v>
<v t="ekr.20080827175609.59"><vh>New settings</vh></v>
</v>
<v t="ekr.20080830082008.1"><vh>4.5 rc2</vh>
<v t="ekr.20080830082008.2"><vh>Major new features</vh></v>
<v t="ekr.20080830082008.3"><vh>Major code reorganizations</vh></v>
<v t="ekr.20080830082008.4"><vh>Minor new features</vh></v>
<v t="ekr.20080830082008.5"><vh>New settings</vh></v>
</v>
<v t="ekr.20080902080930.2"><vh>4.5 final</vh>
<v t="ekr.20080902080930.3"><vh>Major new features</vh></v>
<v t="ekr.20080902080930.4"><vh>Major code reorganizations</vh></v>
<v t="ekr.20080902080930.5"><vh>Minor new features</vh></v>
<v t="ekr.20080902080930.6"><vh>New settings</vh></v>
</v>
<v t="ekr.20080912143702.137"><vh>4.5.1 final</vh>
<v t="ekr.20080912143702.138"><vh>Fixed line number problems</vh></v>
<v t="ekr.20080912143702.139"><vh>Fixed problems with @shadow files with unknown file extensions</vh></v>
<v t="ekr.20080912143702.140"><vh>Fixed bug in Leo's pre-install script</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10704"><vh>4.6 file caching, qt gui, @edit, @auto-rst</vh>
<v t="ekr.20090324085713.2"><vh>4.6 b1</vh>
<v t="ekr.20090324085713.285"><vh>Bugs fixed</vh>
<v t="ekr.20090324085713.292"><vh>Fixed goto-global-line crasher</vh></v>
<v t="ekr.20090324085713.326"><vh>Fixed bug that prevented Leo from opening files on the XP desktop</vh></v>
<v t="ekr.20090324085713.350"><vh>Save/restore tnodeList in atFile.write</vh></v>
<v t="ekr.20090324085713.358"><vh>Paste outline problem</vh></v>
<v t="ekr.20090324085713.395"><vh>Made sure $Home works for @nosent</vh></v>
<v t="ekr.20090324085713.404"><vh>Fixed atFile unicode bug</vh></v>
<v t="ekr.20090324085713.513"><vh>Fixed Mark Edgington's @shadow bug</vh></v>
<v t="ekr.20090324085713.605"><vh>Fixed whitespace problems with @auto/@shadow</vh></v>
<v t="ekr.20090324085713.327"><vh>Fixed nested @path problem</vh></v>
<v t="ekr.20090324085713.289"><vh>Fixed encoding problems with rst3 plugin</vh></v>
<v t="ekr.20090324085713.318"><vh>Fixed new rst3 crash</vh></v>
<v t="ekr.20090324085713.320"><vh>Fixed two c syntax-coloring bugs</vh></v>
</v>
<v t="ekr.20090324085713.690"><vh>Improved file handling</vh>
<v t="ekr.20090324085713.726"><vh>Open a default .leo file if no other is specified</vh></v>
<v t="ekr.20090324085713.748"><vh>Added escapes for underindented lines</vh></v>
<v t="ekr.20090324085713.792"><vh>Warn when writing an externally changed file</vh></v>
</v>
<v t="ekr.20090324085713.661"><vh>New code features</vh>
<v t="ekr.20090324085713.662"><vh>Added autoCompleter.getExternalCompletions</vh></v>
<v t="ekr.20090324085713.663"><vh>Added g.posList</vh></v>
<v t="ekr.20090324085713.666"><vh>Better plugin info</vh></v>
<v t="ekr.20090324085713.672"><vh>Added properties to leoNodes.py</vh></v>
<v t="ekr.20090324085713.688"><vh>Added script to leoSettings.leo to ensure all menu items are valid</vh></v>
<v t="ekr.20090324085713.689"><vh>Added c.config.getSettingSource</vh></v>
<v t="ekr.20090324085713.272"><vh>Predefined 'self' in @test/@suite nodes</vh></v>
<v t="ekr.20090324085713.745"><vh>Added c.getNodePath and c.getNodeFileName</vh></v>
</v>
<v t="ekr.20090324105223.15"><vh>New command-line options</vh>
<v t="ekr.20090324085713.849"><vh>Added -c option to specify config files</vh></v>
<v t="ekr.20090324085713.835"><vh>Added support for --file=fileName command-line option</vh></v>
<v t="ekr.20090324085713.867"><vh>Added support for --gui option</vh></v>
</v>
<v t="ekr.20090324105223.9"><vh>New commands</vh>
<v t="ekr.20090324085713.747"><vh>Added smart home (back-to-home) command</vh></v>
<v t="ekr.20090324085713.817"><vh>The open command creates @edit nodes when opening non-.leo files</vh></v>
<v t="ekr.20090324085713.836"><vh>added pdb minibuffer command</vh></v>
<v t="ekr.20090324085713.837"><vh>Added support for smart_tab setting</vh></v>
<v t="ekr.20090324085713.847"><vh>Improved isearch commands</vh></v>
</v>
<v t="ekr.20090324105223.10"><vh>New and improved directives</vh>
<v t="ekr.20090324085713.740"><vh>Added @nocolor-node directive</vh></v>
<v t="ekr.20090324085713.691"><vh>Improved @path handling</vh></v>
</v>
<v t="ekr.20090324085713.848"><vh>New settings</vh>
<v t="ekr.20090324085713.732"><vh>Added better default fonts for Leo on Linux</vh></v>
<v t="ekr.20090324085713.850"><vh>Added support for @int icon_bar_widgets_per_row setting</vh></v>
<v t="ekr.20090324085713.746"><vh>Added support for meta keys</vh></v>
<v t="ekr.20090324085713.814"><vh>Use myLeoSettings when opening leoSettings.leo</vh></v>
</v>
<v t="ekr.20090324085713.868"><vh>Plugins</vh>
<v t="ekr.20090324085713.869"><vh>Improved nav_buttons plugin and corresponding nodeHistory class</vh></v>
<v t="ekr.20090324085713.881"><vh>Created qtGui and tkGui plugins</vh></v>
<v t="ekr.20090324085713.890"><vh>Created leoGuiPluginsRef.leo</vh></v>
</v>
</v>
<v t="ekr.20090620073906.11072"><vh>4.6 b2</vh>
<v t="ekr.20090620073906.11073"><vh>Bugs</vh>
<v t="ekr.20090620073906.11083"><vh>Added patch for startup logic</vh></v>
<v t="ekr.20090620073906.11087"><vh>Allocate gnx's when nodes are created</vh></v>
<v t="ekr.20090620073906.11960"><vh>Allow block comments in private shadow files</vh></v>
<v t="ekr.20090620073906.11590"><vh>Compute delims from private shadow file as needed</vh></v>
<v t="ekr.20090620073906.11376"><vh>Don't copy @edit trees to outline</vh></v>
<v t="ekr.20090620073906.11981"><vh>Don't expand ancestors of @chapter node when selecting chapter</vh></v>
<v t="ekr.20090620073906.12044"><vh>Entries in recent files menu now have absolute paths</vh></v>
<v t="ekr.20090620073906.11865"><vh>Fixed (worked around) tk chapters bug</vh></v>
<v t="ekr.20090620073906.11850"><vh>Fixed @edit bug</vh></v>
<v t="ekr.20090620073906.11564"><vh>Fixed @shadow crasher</vh></v>
<v t="ekr.20090620073906.11296"><vh>Fixed @thin bug</vh></v>
<v t="ekr.20090620073906.11081"><vh>Fixed back-to-home so it works as expected</vh></v>
<v t="ekr.20090620103431.5601"><vh>Fixed bad @verbatim bug</vh></v>
<v t="ekr.20090620073906.11833"><vh>Fixed binding problem with notebook</vh></v>
<v t="ekr.20090620073906.11374"><vh>Fixed bug: sorting could revert headline changes</vh></v>
<v t="ekr.20090620073906.11521"><vh>Fixed crash when reading .zip files</vh></v>
<v t="ekr.20090620073906.11091"><vh>Fixed crasher when creating .leoID.txt</vh></v>
<v t="ekr.20090620073906.11380"><vh>Fixed dabbrev-expands bug</vh></v>
<v t="ekr.20090620073906.11074"><vh>Fixed elisp importer problem</vh></v>
<v t="ekr.20090620073906.11137"><vh>Fixed F10/11/12 key bug</vh></v>
<v t="ekr.20090620073906.11387"><vh>Fixed file bug re unicode characters</vh></v>
<v t="ekr.20090620073906.11776"><vh>Fixed hoist problems</vh></v>
<v t="ekr.20090620073906.11707"><vh>Fixed lost anchor bug page up/down</vh></v>
<v t="ekr.20090620073906.11377"><vh>Fixed minor @auto bug</vh></v>
<v t="ekr.20090620073906.11864"><vh>Fixed multiple-editor focus problems</vh></v>
<v t="ekr.20090620073906.11352"><vh>Fixed new command</vh></v>
<v t="ekr.20090620073906.11740"><vh>Fixed problems with change-all command</vh></v>
<v t="ekr.20090620073906.11818"><vh>Fixed read clone bug</vh></v>
<v t="ekr.20090620073906.11390"><vh>Fixed rst import bug</vh></v>
<v t="ekr.20090620073906.11086"><vh>Fixed rst3 problem</vh></v>
<v t="ekr.20090620073906.11760"><vh>Fixed seg-fault bug</vh></v>
<v t="ekr.20090620073906.11666"><vh>Fixed Shift-Arrow in headlines</vh></v>
<v t="ekr.20090620073906.11866"><vh>Fixed startup problem</vh></v>
<v t="ekr.20090620073906.11349"><vh>Fixed stubConfig problems</vh></v>
<v t="ekr.20090620073906.11107"><vh>Fixed undo bug</vh></v>
<v t="ekr.20090620073906.11378"><vh>Fixed vim bindings (dd) bug</vh></v>
<v t="ekr.20090620073906.11759"><vh>Investigated bug: File-&gt;Export-&gt;write failed due to incorrect path</vh></v>
<v t="ekr.20090620073906.11094"><vh>Investigated speed of external unit tests</vh></v>
<v t="ekr.20090620073906.11612"><vh>Made @url nodes work with qt gui</vh></v>
<v t="ekr.20090620073906.11620"><vh>Mark @&lt;file&gt; nodes dirty when @path nodes change</vh></v>
<v t="ekr.20090620073906.11824"><vh>Removed duplicate messages when opening non-existent .leo file</vh></v>
<v t="ekr.20090620073906.11771"><vh>Reversed messages about redefined keys</vh></v>
<v t="ekr.20090620073906.11973"><vh>Scroll commands now affect only scrollbars</vh></v>
</v>
<v t="ekr.20090620073906.11870"><vh>New features</vh>
<v t="ekr.20090620073906.11923"><vh>Allow Leo to open any file</vh></v>
<v t="ekr.20090620073906.11873"><vh>Improved unit testing</vh></v>
<v t="ekr.20090620073906.11898"><vh>Leo tests syntax of .py files when saving them</vh></v>
<v t="ekr.20090620073906.12061"><vh>Made qt gui the default</vh></v>
<v t="ekr.20090620073906.11935"><vh>Support @auto-rst</vh></v>
</v>
</v>
<v t="ekr.20090709084001.5944"><vh>4.6 rc1</vh>
<v t="ekr.20090709084001.5945"><vh>Bugs</vh>
<v t="ekr.20090709084001.5946"><vh>Fixed Tangle bugs</vh></v>
<v t="ekr.20090709084001.5968"><vh>Fixed unicode problem with spell checker</vh></v>
<v t="ekr.20090709084001.6086"><vh>Ensure newline at end of each @auto node</vh></v>
<v t="ekr.20090709084001.6096"><vh>Fixed bugs with goto-global-line and @auto</vh></v>
<v t="ekr.20090709084001.6119"><vh>Added key bindings in log pane</vh></v>
<v t="ekr.20090709084001.6138"><vh>Honor split ratios</vh></v>
<v t="ekr.20090709084001.6140"><vh>Click in body after editing activates body</vh></v>
<v t="ekr.20090709084001.6144"><vh>Rewrote string-rectangle command for speed</vh></v>
<v t="ekr.20090709084001.6149"><vh>Fixed read-at-auto-nodes bug</vh></v>
<v t="ekr.20090709084001.6153"><vh>Fixed major focus problems</vh></v>
<v t="ekr.20090709084001.6156"><vh>Fixed problem with read-at-file/shadow-nodes</vh></v>
<v t="ekr.20090709084001.6164"><vh>Fixed major icon/t.uA bug</vh></v>
<v t="ekr.20090709084001.6192"><vh>Fixed rst bug</vh></v>
<v t="ekr.20090709084001.6204"><vh>Made alt-6 run all unit tests</vh></v>
<v t="ekr.20090709084001.6238"><vh>Fixed crasher in dynamicExpanderHelper</vh></v>
<v t="ekr.20090709084001.6241"><vh>Don't collapse initial node automatically</vh></v>
<v t="ekr.20090709084001.6254"><vh>Fixed bug: don't duplicate standard buttons</vh></v>
<v t="ekr.20090709084001.6283"><vh>Fixed critical @file data-loss problem</vh></v>
<v t="ekr.20090709084001.6291"><vh>Added hasSelection to leoQtBody</vh></v>
</v>
<v t="ekr.20090709084001.6296"><vh>Features</vh>
<v t="ekr.20090709084001.6297"><vh>Added open-quickstart-leo command</vh></v>
<v t="ekr.20090709084001.6300"><vh>Added tree bindings for page-up/down commands</vh></v>
<v t="ekr.20090709084001.6301"><vh>Issue error message re non-existent plugins</vh></v>
<v t="ekr.20090709084001.6304"><vh>Expanded Alt-lt/rt arrows</vh></v>
<v t="ekr.20090709084001.6307"><vh>Added important @auto warning</vh>
<v t="ekr.20090709084001.6308"><vh>c.checkFileTimeStamp</vh></v>
<v t="ekr.20090709084001.6309"><vh>readOneAtAutoNode (atFile)</vh></v>
<v t="ekr.20090709084001.6310"><vh>writeOneAtAutoNode &amp; helpers (atFile)</vh>
<v t="ekr.20090709084001.6311"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20090709084001.6312"><vh>promptForAtAutoRead</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20090717084250.10808"><vh>4.6 final</vh>
<v t="ekr.20090717084250.10809"><vh>Bug fixes</vh>
<v t="ekr.20090717084250.10810"><vh>Bugs fixed in 4.6 b2</vh>
<v t="ekr.20090717084250.10811"><vh>Added patch for startup logic</vh></v>
<v t="ekr.20090717084250.10812"><vh>Allocate gnx's when nodes are created</vh></v>
<v t="ekr.20090717084250.10813"><vh>Allow block comments in private shadow files</vh></v>
<v t="ekr.20090717084250.10814"><vh>Compute delims from private shadow file as needed</vh></v>
<v t="ekr.20090717084250.10815"><vh>Don't copy @edit trees to outline</vh></v>
<v t="ekr.20090717084250.10816"><vh>Don't expand ancestors of @chapter node when selecting chapter</vh></v>
<v t="ekr.20090717084250.10817"><vh>Entries in recent files menu now have absolute paths</vh></v>
<v t="ekr.20090717084250.10818"><vh>Fixed (worked around) tk chapters bug</vh></v>
<v t="ekr.20090717084250.10819"><vh>Fixed @edit bug</vh></v>
<v t="ekr.20090717084250.10820"><vh>Fixed @shadow crasher</vh></v>
<v t="ekr.20090717084250.10821"><vh>Fixed @thin bug</vh></v>
<v t="ekr.20090717084250.10822"><vh>Fixed back-to-home so it works as expected</vh></v>
<v t="ekr.20090717084250.10823"><vh>Fixed bad @verbatim bug</vh></v>
<v t="ekr.20090717084250.10824"><vh>Fixed binding problem with notebook</vh></v>
<v t="ekr.20090717084250.10825"><vh>Fixed bug: sorting could revert headline changes</vh></v>
<v t="ekr.20090717084250.10826"><vh>Fixed crash when reading .zip files</vh></v>
<v t="ekr.20090717084250.10827"><vh>Fixed crasher when creating .leoID.txt</vh></v>
<v t="ekr.20090717084250.10828"><vh>Fixed dabbrev-expands bug</vh></v>
<v t="ekr.20090717084250.10829"><vh>Fixed elisp importer problem</vh></v>
<v t="ekr.20090717084250.10830"><vh>Fixed F10/11/12 key bug</vh></v>
<v t="ekr.20090717084250.10831"><vh>Fixed file bug re unicode characters</vh></v>
<v t="ekr.20090717084250.10832"><vh>Fixed hoist problems</vh></v>
<v t="ekr.20090717084250.10833"><vh>Fixed lost anchor bug page up/down</vh></v>
<v t="ekr.20090717084250.10834"><vh>Fixed minor @auto bug</vh></v>
<v t="ekr.20090717084250.10835"><vh>Fixed multiple-editor focus problems</vh></v>
<v t="ekr.20090717084250.10836"><vh>Fixed new command</vh></v>
<v t="ekr.20090717084250.10837"><vh>Fixed problems with change-all command</vh></v>
<v t="ekr.20090717084250.10838"><vh>Fixed read clone bug</vh></v>
<v t="ekr.20090717084250.10839"><vh>Fixed rst import bug</vh></v>
<v t="ekr.20090717084250.10840"><vh>Fixed rst3 problem</vh></v>
<v t="ekr.20090717084250.10841"><vh>Fixed seg-fault bug</vh></v>
<v t="ekr.20090717084250.10842"><vh>Fixed Shift-Arrow in headlines</vh></v>
<v t="ekr.20090717084250.10843"><vh>Fixed startup problem</vh></v>
<v t="ekr.20090717084250.10844"><vh>Fixed stubConfig problems</vh></v>
<v t="ekr.20090717084250.10845"><vh>Fixed undo bug</vh></v>
<v t="ekr.20090717084250.10846"><vh>Fixed vim bindings (dd) bug</vh></v>
<v t="ekr.20090717084250.10847"><vh>Investigated bug: File-&gt;Export-&gt;write failed due to incorrect path</vh></v>
<v t="ekr.20090717084250.10848"><vh>Investigated speed of external unit tests</vh></v>
<v t="ekr.20090717084250.10849"><vh>Made @url nodes work with qt gui</vh></v>
<v t="ekr.20090717084250.10850"><vh>Mark @&lt;file&gt; nodes dirty when @path nodes change</vh></v>
<v t="ekr.20090717084250.10851"><vh>Removed duplicate messages when opening non-existent .leo file</vh></v>
<v t="ekr.20090717084250.10852"><vh>Reversed messages about redefined keys</vh></v>
<v t="ekr.20090717084250.10853"><vh>Scroll commands now affect only scrollbars</vh></v>
</v>
<v t="ekr.20090717084250.10854"><vh>Bugs fixed in 4.6 b1</vh>
<v t="ekr.20090717084250.10855"><vh>Fixed goto-global-line crasher</vh></v>
<v t="ekr.20090717084250.10856"><vh>Fixed bug that prevented Leo from opening files on the XP desktop</vh></v>
<v t="ekr.20090717084250.10857"><vh>Save/restore tnodeList in atFile.write</vh></v>
<v t="ekr.20090717084250.10858"><vh>Paste outline problem</vh></v>
<v t="ekr.20090717084250.10859"><vh>Made sure $Home works for @nosent</vh></v>
<v t="ekr.20090717084250.10860"><vh>Fixed atFile unicode bug</vh></v>
<v t="ekr.20090717084250.10861"><vh>Fixed Mark Edgington's @shadow bug</vh></v>
<v t="ekr.20090717084250.10862"><vh>Fixed whitespace problems with @auto/@shadow</vh></v>
<v t="ekr.20090717084250.10863"><vh>Fixed nested @path problem</vh></v>
<v t="ekr.20090717084250.10864"><vh>Fixed encoding problems with rst3 plugin</vh></v>
<v t="ekr.20090717084250.10865"><vh>Fixed new rst3 crash</vh></v>
<v t="ekr.20090717084250.10866"><vh>Fixed two c syntax-coloring bugs</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10867"><vh>New features</vh>
<v t="ekr.20090717084250.10868"><vh>New features in 4.6 b1</vh>
<v t="ekr.20090717084250.10869"><vh>Improved file handling</vh>
<v t="ekr.20090717084250.10870"><vh>Open a default .leo file if no other is specified</vh></v>
<v t="ekr.20090717084250.10871"><vh>Added escapes for underindented lines</vh></v>
<v t="ekr.20090717084250.10872"><vh>Warn when writing an externally changed file</vh></v>
</v>
<v t="ekr.20090717084250.10873"><vh>New code features</vh>
<v t="ekr.20090717084250.10874"><vh>Added autoCompleter.getExternalCompletions</vh></v>
<v t="ekr.20090717084250.10875"><vh>Added g.posList</vh></v>
<v t="ekr.20090717084250.10876"><vh>Better plugin info</vh></v>
<v t="ekr.20090717084250.10877"><vh>Added properties to leoNodes.py</vh></v>
<v t="ekr.20090717084250.10878"><vh>Added script to leoSettings.leo to ensure all menu items are valid</vh></v>
<v t="ekr.20090717084250.10879"><vh>Added c.config.getSettingSource</vh></v>
<v t="ekr.20090717084250.10880"><vh>Predefined 'self' in @test/@suite nodes</vh></v>
<v t="ekr.20090717084250.10881"><vh>Added c.getNodePath and c.getNodeFileName</vh></v>
</v>
<v t="ekr.20090717084250.10882"><vh>New command-line options</vh>
<v t="ekr.20090717084250.10883"><vh>Added -c option to specify config files</vh></v>
<v t="ekr.20090717084250.10884"><vh>Added support for --file=fileName command-line option</vh></v>
<v t="ekr.20090717084250.10885"><vh>Added support for --gui option</vh></v>
</v>
<v t="ekr.20090717084250.10886"><vh>New commands</vh>
<v t="ekr.20090717084250.10887"><vh>Added smart home (back-to-home) command</vh></v>
<v t="ekr.20090717084250.10888"><vh>The open command creates @edit nodes when opening non-.leo files</vh></v>
<v t="ekr.20090717084250.10889"><vh>added pdb minibuffer command</vh></v>
<v t="ekr.20090717084250.10890"><vh>Added support for smart_tab setting</vh></v>
<v t="ekr.20090717084250.10891"><vh>Improved isearch commands</vh></v>
</v>
<v t="ekr.20090717084250.10892"><vh>New and improved directives</vh>
<v t="ekr.20090717084250.10893"><vh>Added @nocolor-node directive</vh></v>
<v t="ekr.20090717084250.10894"><vh>Improved @path handling</vh></v>
</v>
<v t="ekr.20090717084250.10895"><vh>New settings</vh>
<v t="ekr.20090717084250.10896"><vh>Added better default fonts for Leo on Linux</vh></v>
<v t="ekr.20090717084250.10897"><vh>Added support for @int icon_bar_widgets_per_row setting</vh></v>
<v t="ekr.20090717084250.10898"><vh>Added support for meta keys</vh></v>
<v t="ekr.20090717084250.10899"><vh>Use myLeoSettings when opening leoSettings.leo</vh></v>
</v>
<v t="ekr.20090717084250.10900"><vh>Plugins</vh>
<v t="ekr.20090717084250.10901"><vh>Improved nav_buttons plugin and corresponding nodeHistory class</vh></v>
<v t="ekr.20090717084250.10902"><vh>Created qtGui and tkGui plugins</vh></v>
<v t="ekr.20090717084250.10903"><vh>Created leoGuiPluginsRef.leo</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10904"><vh>New features in 4.6 b2</vh>
<v t="ekr.20090717084250.10905"><vh>Allow Leo to open any file</vh></v>
<v t="ekr.20090717084250.10906"><vh>Improved unit testing</vh></v>
<v t="ekr.20090717084250.10907"><vh>Leo tests syntax of .py files when saving them</vh></v>
<v t="ekr.20090717084250.10908"><vh>Made qt gui the default</vh></v>
<v t="ekr.20090717084250.10909"><vh>Support @auto-rst</vh></v>
</v>
<v t="ekr.20090717084250.10910"><vh>New features in 4.6 final</vh></v>
</v>
</v>
<v t="ekr.20090718092032.10405"><vh>4.6.1 final</vh>
<v t="ekr.20090718092032.10406"><vh>Bug fixes</vh>
<v t="ekr.20090718092032.10407"><vh>Bugs fixed in 4.6 b2</vh>
<v t="ekr.20090718092032.10408"><vh>Added patch for startup logic</vh></v>
<v t="ekr.20090718092032.10409"><vh>Allocate gnx's when nodes are created</vh></v>
<v t="ekr.20090718092032.10410"><vh>Allow block comments in private shadow files</vh></v>
<v t="ekr.20090718092032.10411"><vh>Compute delims from private shadow file as needed</vh></v>
<v t="ekr.20090718092032.10412"><vh>Don't copy @edit trees to outline</vh></v>
<v t="ekr.20090718092032.10413"><vh>Don't expand ancestors of @chapter node when selecting chapter</vh></v>
<v t="ekr.20090718092032.10414"><vh>Entries in recent files menu now have absolute paths</vh></v>
<v t="ekr.20090718092032.10415"><vh>Fixed (worked around) tk chapters bug</vh></v>
<v t="ekr.20090718092032.10416"><vh>Fixed @edit bug</vh></v>
<v t="ekr.20090718092032.10417"><vh>Fixed @shadow crasher</vh></v>
<v t="ekr.20090718092032.10418"><vh>Fixed @thin bug</vh></v>
<v t="ekr.20090718092032.10419"><vh>Fixed back-to-home so it works as expected</vh></v>
<v t="ekr.20090718092032.10420"><vh>Fixed bad @verbatim bug</vh></v>
<v t="ekr.20090718092032.10421"><vh>Fixed binding problem with notebook</vh></v>
<v t="ekr.20090718092032.10422"><vh>Fixed bug: sorting could revert headline changes</vh></v>
<v t="ekr.20090718092032.10423"><vh>Fixed crash when reading .zip files</vh></v>
<v t="ekr.20090718092032.10424"><vh>Fixed crasher when creating .leoID.txt</vh></v>
<v t="ekr.20090718092032.10425"><vh>Fixed dabbrev-expands bug</vh></v>
<v t="ekr.20090718092032.10426"><vh>Fixed elisp importer problem</vh></v>
<v t="ekr.20090718092032.10427"><vh>Fixed F10/11/12 key bug</vh></v>
<v t="ekr.20090718092032.10428"><vh>Fixed file bug re unicode characters</vh></v>
<v t="ekr.20090718092032.10429"><vh>Fixed hoist problems</vh></v>
<v t="ekr.20090718092032.10430"><vh>Fixed lost anchor bug page up/down</vh></v>
<v t="ekr.20090718092032.10431"><vh>Fixed minor @auto bug</vh></v>
<v t="ekr.20090718092032.10432"><vh>Fixed multiple-editor focus problems</vh></v>
<v t="ekr.20090718092032.10433"><vh>Fixed new command</vh></v>
<v t="ekr.20090718092032.10434"><vh>Fixed problems with change-all command</vh></v>
<v t="ekr.20090718092032.10435"><vh>Fixed read clone bug</vh></v>
<v t="ekr.20090718092032.10436"><vh>Fixed rst import bug</vh></v>
<v t="ekr.20090718092032.10437"><vh>Fixed rst3 problem</vh></v>
<v t="ekr.20090718092032.10438"><vh>Fixed seg-fault bug</vh></v>
<v t="ekr.20090718092032.10439"><vh>Fixed Shift-Arrow in headlines</vh></v>
<v t="ekr.20090718092032.10440"><vh>Fixed startup problem</vh></v>
<v t="ekr.20090718092032.10441"><vh>Fixed stubConfig problems</vh></v>
<v t="ekr.20090718092032.10442"><vh>Fixed undo bug</vh></v>
<v t="ekr.20090718092032.10443"><vh>Fixed vim bindings (dd) bug</vh></v>
<v t="ekr.20090718092032.10444"><vh>Investigated bug: File-&gt;Export-&gt;write failed due to incorrect path</vh></v>
<v t="ekr.20090718092032.10445"><vh>Investigated speed of external unit tests</vh></v>
<v t="ekr.20090718092032.10446"><vh>Made @url nodes work with qt gui</vh></v>
<v t="ekr.20090718092032.10447"><vh>Mark @&lt;file&gt; nodes dirty when @path nodes change</vh></v>
<v t="ekr.20090718092032.10448"><vh>Removed duplicate messages when opening non-existent .leo file</vh></v>
<v t="ekr.20090718092032.10449"><vh>Reversed messages about redefined keys</vh></v>
<v t="ekr.20090718092032.10450"><vh>Scroll commands now affect only scrollbars</vh></v>
</v>
<v t="ekr.20090718092032.10451"><vh>Bugs fixed in 4.6 b1</vh>
<v t="ekr.20090718092032.10452"><vh>Fixed goto-global-line crasher</vh></v>
<v t="ekr.20090718092032.10453"><vh>Fixed bug that prevented Leo from opening files on the XP desktop</vh></v>
<v t="ekr.20090718092032.10454"><vh>Save/restore tnodeList in atFile.write</vh></v>
<v t="ekr.20090718092032.10455"><vh>Paste outline problem</vh></v>
<v t="ekr.20090718092032.10456"><vh>Made sure $Home works for @nosent</vh></v>
<v t="ekr.20090718092032.10457"><vh>Fixed atFile unicode bug</vh></v>
<v t="ekr.20090718092032.10458"><vh>Fixed Mark Edgington's @shadow bug</vh></v>
<v t="ekr.20090718092032.10459"><vh>Fixed whitespace problems with @auto/@shadow</vh></v>
<v t="ekr.20090718092032.10460"><vh>Fixed nested @path problem</vh></v>
<v t="ekr.20090718092032.10461"><vh>Fixed encoding problems with rst3 plugin</vh></v>
<v t="ekr.20090718092032.10462"><vh>Fixed new rst3 crash</vh></v>
<v t="ekr.20090718092032.10463"><vh>Fixed two c syntax-coloring bugs</vh></v>
</v>
</v>
<v t="ekr.20090718092032.10464"><vh>New features</vh>
<v t="ekr.20090718092032.10465"><vh>New features in 4.6 b1</vh>
<v t="ekr.20090718092032.10466"><vh>Improved file handling</vh>
<v t="ekr.20090718092032.10467"><vh>Open a default .leo file if no other is specified</vh></v>
<v t="ekr.20090718092032.10468"><vh>Added escapes for underindented lines</vh></v>
<v t="ekr.20090718092032.10469"><vh>Warn when writing an externally changed file</vh></v>
</v>
<v t="ekr.20090718092032.10470"><vh>New code features</vh>
<v t="ekr.20090718092032.10471"><vh>Added autoCompleter.getExternalCompletions</vh></v>
<v t="ekr.20090718092032.10472"><vh>Added g.posList</vh></v>
<v t="ekr.20090718092032.10473"><vh>Better plugin info</vh></v>
<v t="ekr.20090718092032.10474"><vh>Added properties to leoNodes.py</vh></v>
<v t="ekr.20090718092032.10475"><vh>Added script to leoSettings.leo to ensure all menu items are valid</vh></v>
<v t="ekr.20090718092032.10476"><vh>Added c.config.getSettingSource</vh></v>
<v t="ekr.20090718092032.10477"><vh>Predefined 'self' in @test/@suite nodes</vh></v>
<v t="ekr.20090718092032.10478"><vh>Added c.getNodePath and c.getNodeFileName</vh></v>
</v>
<v t="ekr.20090718092032.10479"><vh>New command-line options</vh>
<v t="ekr.20090718092032.10480"><vh>Added -c option to specify config files</vh></v>
<v t="ekr.20090718092032.10481"><vh>Added support for --file=fileName command-line option</vh></v>
<v t="ekr.20090718092032.10482"><vh>Added support for --gui option</vh></v>
</v>
<v t="ekr.20090718092032.10483"><vh>New commands</vh>
<v t="ekr.20090718092032.10484"><vh>Added smart home (back-to-home) command</vh></v>
<v t="ekr.20090718092032.10485"><vh>The open command creates @edit nodes when opening non-.leo files</vh></v>
<v t="ekr.20090718092032.10486"><vh>added pdb minibuffer command</vh></v>
<v t="ekr.20090718092032.10487"><vh>Added support for smart_tab setting</vh></v>
<v t="ekr.20090718092032.10488"><vh>Improved isearch commands</vh></v>
</v>
<v t="ekr.20090718092032.10489"><vh>New and improved directives</vh>
<v t="ekr.20090718092032.10490"><vh>Added @nocolor-node directive</vh></v>
<v t="ekr.20090718092032.10491"><vh>Improved @path handling</vh></v>
</v>
<v t="ekr.20090718092032.10492"><vh>New settings</vh>
<v t="ekr.20090718092032.10493"><vh>Added better default fonts for Leo on Linux</vh></v>
<v t="ekr.20090718092032.10494"><vh>Added support for @int icon_bar_widgets_per_row setting</vh></v>
<v t="ekr.20090718092032.10495"><vh>Added support for meta keys</vh></v>
<v t="ekr.20090718092032.10496"><vh>Use myLeoSettings when opening leoSettings.leo</vh></v>
</v>
<v t="ekr.20090718092032.10497"><vh>Plugins</vh>
<v t="ekr.20090718092032.10498"><vh>Improved nav_buttons plugin and corresponding nodeHistory class</vh></v>
<v t="ekr.20090718092032.10499"><vh>Created qtGui and tkGui plugins</vh></v>
<v t="ekr.20090718092032.10500"><vh>Created leoGuiPluginsRef.leo</vh></v>
</v>
</v>
<v t="ekr.20090718092032.10501"><vh>New features in 4.6 b2</vh>
<v t="ekr.20090718092032.10502"><vh>Allow Leo to open any file</vh></v>
<v t="ekr.20090718092032.10503"><vh>Improved unit testing</vh></v>
<v t="ekr.20090718092032.10504"><vh>Leo tests syntax of .py files when saving them</vh></v>
<v t="ekr.20090718092032.10505"><vh>Made qt gui the default</vh></v>
<v t="ekr.20090718092032.10506"><vh>Support @auto-rst</vh></v>
</v>
<v t="ekr.20090718092032.10507"><vh>New features in 4.6 final</vh></v>
</v>
</v>
<v t="ekr.20090802162204.5798"><vh>4.6.2 final</vh>
<v t="ekr.20090803084828.5800"><vh>Bugs fixed</vh></v>
</v>
<v t="ekr.20091006093902.6558"><vh>4.6.3 final</vh>
<v t="ekr.20091006093902.6559"><vh>Bugs fixed</vh></v>
<v t="ekr.20091006093902.6560"><vh>New features</vh></v>
</v>
</v>
<v t="ekr.20100118181428.8827"><vh>4.7 One-node world, Leo-3k, @auto-rst, convert @file</vh>
<v t="ekr.20090909083000.6547"><vh>4.7 beta 1</vh>
<v t="ekr.20090909083000.6556"><vh>Added new Windows installer</vh></v>
<v t="ekr.20090909083000.6555"><vh>Added new plugins</vh></v>
<v t="ekr.20090909083000.6552"><vh>Added options to vim plugin</vh></v>
<v t="ekr.20090909083000.6553"><vh>Leo no longer adds directories to sys.path</vh></v>
</v>
<v t="ekr.20100118181428.8813"><vh>4.7 beta 2</vh>
<v t="ekr.20100118181428.7557"><vh>Bugs</vh>
<v t="ekr.20100118181428.7559"><vh>Fixed calltips on leo3k</vh></v>
<v t="ekr.20100118181428.7570"><vh>Fixed headline scrolling</vh></v>
<v t="ekr.20100118181428.7571"><vh>Fixed bug 498692: Undo renames headline</vh></v>
<v t="ekr.20100118181428.7614"><vh>Fixed bug 498688: Undo back to last saved content...</vh></v>
<v t="ekr.20100118181428.7712"><vh>Fixed bug: no log when notebook does not exist</vh></v>
<v t="ekr.20100118181428.7715"><vh>Fixed bug 362950: during body text undo selection goes nuts...</vh></v>
<v t="ekr.20100118181428.7830"><vh>Removed unsettling @auto warning</vh></v>
<v t="ekr.20100118181428.7831"><vh>Fixed at-auto-rst problems</vh></v>
<v t="ekr.20100118181428.8070"><vh>Fixed bug: at-nosent nodes were not being dirty when headline changes</vh></v>
<v t="ekr.20100118181428.8077"><vh>Allow hyphens in xml tags</vh></v>
<v t="ekr.20100118181428.8086"><vh>Color sections references in @root trees</vh></v>
<v t="ekr.20100118181428.8090"><vh>Fixed Alt-u bug and refactored k.masterKeyHandler</vh></v>
<v t="ekr.20100118181428.8109"><vh>Fixed at-shadow error</vh></v>
<v t="ekr.20100118181428.8236"><vh>Fixed bug 408886: qttabs gui doesn't mark commanders dirty properly</vh></v>
<v t="ekr.20100118181428.8239"><vh>Fixed bug 476653: @nowrap isn't working for qt / @edit nodes</vh></v>
<v t="ekr.20100118181428.8240"><vh>Fixed bug 480422: string-rectangle kills syntax highlighting</vh></v>
<v t="ekr.20100118181428.8242"><vh>Fixed bug in g.adjustTripleString</vh></v>
<v t="ekr.20100118181428.8248"><vh>Fixed bug in writeNodeToString</vh></v>
<v t="ekr.20100118181428.8252"><vh>Fixed bug: @nosent should warn about orphan nodes</vh></v>
<v t="ekr.20100118181428.8257"><vh>Fixed bug: Sometimes 'redefining shortcut' message is backwards</vh></v>
<v t="ekr.20100118181428.8262"><vh>Fixed contract-or-go-right</vh></v>
<v t="ekr.20100118181428.8275"><vh>Fixed crasher when writing to a newly-deleted file</vh></v>
<v t="ekr.20100118181428.8278"><vh>Fixed double prompt in c.close()</vh></v>
<v t="ekr.20100118181428.8281"><vh>Fixed elisp parsing bug</vh></v>
<v t="ekr.20100118181428.8294"><vh>Fixed publish-argv-for-missing-stylesheets</vh></v>
<v t="ekr.20100118181428.8297"><vh>Fixed registerHandler bug</vh></v>
<v t="ekr.20100118181428.8298"><vh>Fixed scrolling problem with multiple editors</vh></v>
<v t="ekr.20100118181428.8299"><vh>Fixed startup reversion when .leoID.txt does not exist</vh></v>
<v t="ekr.20100118181428.8302"><vh>Handle Insert key properly</vh></v>
<v t="ekr.20100118181428.8306"><vh>Improved the install docs</vh></v>
<v t="ekr.20100118181428.8307"><vh>Made add-comments and delete-comments commands work with shortcuts</vh></v>
<v t="ekr.20100118181428.8334"><vh>Marked @&lt;file&gt; nodes dirty if nodes change during read.</vh></v>
<v t="ekr.20100118181428.8358"><vh>Recover from bad chars in .leo files</vh></v>
<v t="ekr.20100118181428.8362"><vh>Select main chapter initially</vh></v>
<v t="ekr.20100118181428.8363"><vh>Suppressed dangerous write prompt for clones</vh></v>
<v t="ekr.20100118181428.8365"><vh>Use w.leoMoveCursorHelper if it exists</vh></v>
<v t="ekr.20100118181428.8413"><vh>Fixed bug 452303 @auto-rst can be dangerous</vh></v>
<v t="ekr.20100118181428.8447"><vh>Fixed underlining problem in rst</vh></v>
<v t="ekr.20100118181428.8449"><vh>Fixed qt key problems</vh></v>
<v t="ekr.20100118181428.8473"><vh>Fixed bug: 381895 qtGui Split ratio is not saved in .leo file</vh></v>
<v t="ekr.20100118181428.8481"><vh>Applied patches to fix bug: 451377 Make Leo frienly to mac apps</vh></v>
<v t="ekr.20100118181428.8485"><vh>Fixed bug: 394445 Chapters selection button: in qt, missing, in Tk, only one option</vh></v>
<v t="ekr.20100118181428.8486"><vh>Fixed bug: overwrite modified file message</vh></v>
<v t="ekr.20100118181428.8497"><vh>Fixed auto-save problem</vh></v>
<v t="ekr.20100118181428.8502"><vh>Fixed old at-shadow problem</vh></v>
<v t="ekr.20100118181428.8514"><vh>Fixed ctrl-tab bug</vh></v>
<v t="ekr.20100118181428.8517"><vh>Fixed 349027: body doesn't get focus after headline edit</vh></v>
<v t="ekr.20100118181428.8518"><vh>Fixed bug 507559: Can't use End key while editing node headline</vh></v>
<v t="ekr.20100118181428.8522"><vh>Finished bug 486433: non-breaking space etc. are invisible</vh></v>
<v t="ekr.20100118181428.8523"><vh>Fixed bug: 420988 @tabwith 8 not honored</vh></v>
<v t="ekr.20100118181428.8524"><vh>Don't colorize @others and @all unless they start a line</vh></v>
<v t="ekr.20100119145003.7319"><vh>Gui bugs</vh>
<v t="ekr.20100119145003.7320"><vh>Fixed file-open focus problem</vh></v>
<v t="ekr.20100119145003.7322"><vh>Eliminate double close prompt</vh></v>
<v t="ekr.20100119145003.7324"><vh>Fixed scrolling problem with multiple editors</vh></v>
<v t="ekr.20100119145003.7325"><vh>Fixed crash in quicksearch plugin</vh></v>
<v t="ekr.20100119145003.7327"><vh>Fixed @nosent dirty bug</vh></v>
<v t="ekr.20100119145003.7358"><vh>Allow horizontal scrolling in QtTree</vh></v>
<v t="ekr.20100119145003.7531"><vh>Correct binding of insert key</vh></v>
<v t="ekr.20100119145003.7546"><vh>Update tab names when the commander is dirty</vh></v>
<v t="ekr.20100119145003.7612"><vh>Made @nowrap work</vh></v>
<v t="ekr.20100119145003.7618"><vh>Added leoMoveCursorHelper</vh></v>
<v t="ekr.20100119145003.7625"><vh>Remember the ratios when the user moves splitters by hand.</vh></v>
<v t="ekr.20100119145003.7629"><vh>Chapter tabs require both_chapters and use_chapters_tabs</vh></v>
<v t="ekr.20100119145003.7632"><vh>Don't colorize directives unless they start a line</vh></v>
<v t="ekr.20100119145003.7643"><vh>Config coloring tags whenever the language changes</vh></v>
<v t="ekr.20100119145003.7718"><vh>Update qttabs when saving a new file</vh></v>
</v>
<v t="ekr.20100124164700.11919"><vh>Fixed colorizer bug affecting per-language @font settings</vh></v>
<v t="ekr.20100124164700.11920"><vh>support extend-mode for several commands</vh></v>
<v t="ekr.20100124164700.11921"><vh>Fixed qttab problem</vh></v>
<v t="ekr.20100124164700.11922"><vh>&lt;alt-x&gt; select-all crashes python when focus is in headline</vh></v>
<v t="ekr.20100124164700.11923"><vh>Allow saving .leo files with undefined-sections</vh></v>
<v t="ekr.20100124164700.11924"><vh>Refactored write_Leo_file</vh></v>
<v t="ekr.20100124164700.11925"><vh>Fixed print-bindings crasher w/ leo3k</vh></v>
<v t="ekr.20100124164700.11926"><vh>Fixed problem with already-existing .leo.bak files</vh></v>
<v t="ekr.20100124164700.11927"><vh>Fixed sort children bug</vh></v>
<v t="ekr.20100124164700.11928"><vh>Fixed unicode problems</vh>
<v t="ekr.20100124164700.11929"><vh>g.pr</vh></v>
<v t="ekr.20100124164700.11930"><vh>qtGui diff</vh></v>
<v t="ekr.20100124164700.11931"><vh>parse_leo_file</vh></v>
<v t="ekr.20100124164700.11932"><vh>toUnicode &amp; toEncodedString (and tests)</vh>
<v t="ekr.20100124164700.11933"><vh>g.toEncodedString</vh></v>
<v t="ekr.20100124164700.11934"><vh>toEncodedStringWithErrorCode (for unit testing)</vh></v>
<v t="ekr.20100124164700.11935"><vh>g.toUnicode</vh></v>
<v t="ekr.20100124164700.11936"><vh>g.u &amp; g.ue</vh></v>
<v t="ekr.20100124164700.11937"><vh>toUnicodeWithErrorCode (for unit testing)</vh></v>
</v>
</v>
<v t="ekr.20100124164700.11938"><vh>Fixed crash in writeToFileHelper</vh>
<v t="ekr.20100124164700.11939"><vh>put</vh></v>
<v t="ekr.20100124164700.11947"><vh>writeToFileHelper &amp; helpers</vh>
<v t="ekr.20100124164700.11948"><vh>createActualFile</vh></v>
<v t="ekr.20100124164700.11949"><vh>createBackupFile</vh></v>
<v t="ekr.20100124164700.11950"><vh>handleWriteLeoFileException</vh></v>
</v>
</v>
<v t="ekr.20100124164700.11944"><vh>Add warnings when @file logic happens</vh>
<v t="ekr.20100124164700.12071"><vh>findChild4</vh></v>
</v>
<v t="ekr.20100124164700.11946"><vh>Fixed mkstemp bug</vh>
<v t="ekr.20100124164700.11947"></v>
</v>
<v t="ekr.20100124164700.11951"><vh>Removed most usage of _bodyString &amp; _headString</vh>
<v t="ekr.20100124164700.11952"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20100124164700.11953"><vh>p.Properties</vh>
<v t="ekr.20100124164700.11954"><vh>p.b property</vh></v>
<v t="ekr.20100124164700.11955"><vh>p.h property</vh></v>
<v t="ekr.20100124164700.11956"><vh>p.gnx property</vh></v>
</v>
<v t="ekr.20100124164700.11957"><vh>v.Properties</vh>
<v t="ekr.20100124164700.11958"><vh>v.b Property</vh></v>
<v t="ekr.20100124164700.11959"><vh>v.h property</vh></v>
<v t="ekr.20100124164700.11960"><vh>v.u Property</vh></v>
<v t="ekr.20100124164700.11961"><vh>v.gnx Property</vh></v>
</v>
<v t="ekr.20100124164700.11962"><vh>v .setBodyString &amp; v.setHeadString</vh></v>
<v t="ekr.20100124164700.11963"><vh>c.setBodyString</vh></v>
<v t="ekr.20100124164700.11964"><vh>afterInsertNode</vh></v>
</v>
<v t="ekr.20100124164700.11965"><vh>Don't use tnodeList to separate old/new @file nodes</vh>
<v t="ekr.20100124164700.12046"><vh>read (atFile) &amp; helpers</vh>
<v t="ekr.20100124164700.12047"><vh>deleteAllTempBodyStrings</vh></v>
<v t="ekr.20100124164700.12072"><vh>deleteTnodeList</vh></v>
<v t="ekr.20100124164700.12049"><vh>initFileName</vh></v>
<v t="ekr.20100124164700.12128"><vh>at.readFromCache</vh></v>
<v t="ekr.20100124164700.12051"><vh>warnAboutUnvisitedNodes</vh></v>
</v>
<v t="ekr.20100124164700.11972"><vh>readOpenFile</vh>
<v t="ekr.20100124164700.11973"><vh>&lt;&lt; handle first and last lines &gt;&gt;</vh></v>
<v t="ekr.20100124164700.11974"><vh>shouldDeleteChildren</vh></v>
</v>
<v t="ekr.20100124164700.11975"><vh>initReadIvars</vh>
<v t="ekr.20100124164700.12070"><vh>&lt;&lt; init ivars for reading &gt;&gt;</vh></v>
</v>
<v t="ekr.20100124164700.11977"><vh>at.scanHeader</vh>
<v t="ekr.20100124164700.11978"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20100124164700.11979"><vh>at.parseLeoSentinel</vh>
<v t="ekr.20100124164700.11980"><vh>&lt;&lt; set the opening comment delim &gt;&gt;</vh></v>
<v t="ekr.20100124164700.11981"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="ekr.20100124164700.11982"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="ekr.20100124164700.11983"><vh>&lt;&lt; read optional thin param &gt;&gt;</vh></v>
<v t="ekr.20100124164700.11984"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="ekr.20100124164700.11985"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
</v>
<v t="ekr.20100124164700.11986"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20100124164700.11987"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20100124164700.11988"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20100124164700.11989"><vh>readNormalLine</vh>
<v t="ekr.20100124164700.11990"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20100124164700.11991"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20100124164700.11992"><vh>start sentinels</vh>
<v t="ekr.20100124164700.12143"><vh>at.readStartAll</vh></v>
<v t="ekr.20100124164700.11994"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20100124164700.11995"><vh>readStartLeo</vh></v>
<v t="ekr.20100124164700.11996"><vh>readStartMiddle</vh></v>
<v t="ekr.20100124164700.12129"><vh>at.readStartNode</vh>
<v t="ekr.20100124164700.12130"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20100124164700.12131"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
</v>
<v t="ekr.20100124164700.12000"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20100124164700.12001"><vh>end sentinels</vh>
<v t="ekr.20100124164700.12002"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20100124164700.12003"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20100124164700.12004"><vh>readEndLeo</vh></v>
<v t="ekr.20100124164700.12005"><vh>readEndMiddle</vh></v>
<v t="ekr.20100124164700.12140"><vh>at.readEndNode</vh>
<v t="ekr.20100124164700.12141"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh>
<v t="ekr.20100124164700.12142"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20100124164700.12009"><vh>readEndOthers</vh></v>
<v t="ekr.20100124164700.12010"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20100124164700.12011"><vh>Unpaired sentinels</vh>
<v t="ekr.20100124164700.12012"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20100124164700.12013"><vh>readAfterRef</vh></v>
<v t="ekr.20100124164700.12014"><vh>readClone</vh></v>
<v t="ekr.20100124164700.12015"><vh>readComment</vh></v>
<v t="ekr.20100124164700.12016"><vh>readDelims</vh></v>
<v t="ekr.20100124164700.12017"><vh>readDirective (@@)</vh>
<v t="ekr.20100124164700.12018"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20100124164700.12019"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20100124164700.12020"><vh>readNl</vh></v>
<v t="ekr.20100124164700.12021"><vh>readNonl</vh></v>
<v t="ekr.20100124164700.12022"><vh>readRef</vh></v>
<v t="ekr.20100124164700.12023"><vh>readVerbatim</vh>
<v t="ekr.20100124164700.12024"><vh>@test verbatim sentinel</vh></v>
</v>
</v>
<v t="ekr.20100124164700.12025"><vh>badEndSentinel, popSentinelStack</vh></v>
</v>
<v t="ekr.20100124164700.12026"><vh>scanHeaderForThin (used by import code)</vh></v>
</v>
<v t="ekr.20100124164700.12027"><vh>Eliminated warning re orphan nodes</vh>
<v t="ekr.20100124164700.12028"><vh>warnAboutOrpanAndIgnoredNodes</vh></v>
<v t="ekr.20100124164700.12029"><vh>putAtAllChild</vh></v>
</v>
<v t="ekr.20100128094926.12524"><vh>Eliminated node-changed marks</vh></v>
<v t="ekr.20100128094926.12739"><vh>Suppress path changed message in save-as and save-to</vh></v>
<v t="ekr.20100128094926.12747"><vh>Fixed Tangle problem with latext files</vh></v>
<v t="ekr.20100128094926.12756"><vh>Fixed Terry's unicode problem</vh></v>
</v>
<v t="ekr.20100118181428.8525"><vh>Features</vh>
<v t="ekr.20100118181428.8815"><vh>Leo supports Python 3.x</vh></v>
<v t="ekr.20100129054823.11928"></v>
<v t="ekr.20100129054823.17683"><vh>New command-line options</vh></v>
<v t="ekr.20100129054823.11935"></v>
<v t="ekr.20100129054823.17685"><vh>New settings</vh></v>
</v>
</v>
<v t="ekr.20100201192329.7018"><vh>4.7 beta 3</vh>
<v t="ekr.20100201192329.7095"><vh>Bugs fixed in Leo 4.7 b3</vh>
<v t="ekr.20100201192329.7141"><vh>Fixed unicode problems</vh></v>
<v t="ekr.20100201192329.7101"><vh>paste-node-as-clone now sets dirty bits properly</vh></v>
<v t="ekr.20100201192329.7106"><vh>Fixed crasher in sort-siblings</vh></v>
<v t="ekr.20100201192329.7108"><vh>Fixed bug 515164: a crasher in p.positionExists</vh></v>
<v t="ekr.20100201192329.7112"><vh>Fix crasher in scrolledMessage.py</vh></v>
<v t="ekr.20100201192329.7113"><vh>Fixed problem with colon following @path</vh></v>
<v t="ekr.20100201192329.7116"><vh>Code cleanup</vh></v>
</v>
</v>
<v t="ekr.20100205152016.14053"><vh>4.7 rc 1</vh>
<v t="ekr.20100205152016.14054"><vh>Recovering from clone conflicts</vh></v>
<v t="ekr.20100209160132.11690"><vh>Bugs fixed</vh>
<v t="ekr.20100209160132.11691"><vh>Fixed unicode bug in setSelectionRangeHelper</vh></v>
<v t="ekr.20100209160132.11692"><vh>Home key no longer clears the minibuffer</vh></v>
<v t="ekr.20100209160132.11694"><vh>Fixed bug in c.pasteOutline when run from unit tests</vh></v>
<v t="ekr.20100209160132.11700"><vh>Removed all references to isAtNorefFileNode</vh></v>
<v t="ekr.20100209160132.11701"><vh>Fixed inconsistency in how @path works</vh></v>
<v t="ekr.20100209160132.11711"><vh>Fixed crasher in path.py</vh></v>
<v t="ekr.20100209160132.11712"><vh>Fixed at-auto write bug</vh></v>
<v t="ekr.20100209160132.11718"><vh>Fixed the critical 'file used by another process' bug</vh></v>
<v t="ekr.20100209160132.11736"><vh>Alt-right should *not* go down</vh></v>
<v t="ekr.20100209160132.11742"><vh>Big change: simplified g.utils_rename</vh></v>
<v t="ekr.20100209160132.11751"><vh>Fixed cursor hangnail</vh></v>
<v t="ekr.20100209160132.11755"><vh>Do a full redraw when contracting a cloned node</vh></v>
<v t="ekr.20100209160132.11756"><vh>Bug 399720: (fixed) goto-global-line doesn't work with @edit nodes</vh></v>
<v t="ekr.20100209160132.11765"><vh>Fixed unit test for leo_interface.py</vh></v>
<v t="ekr.20100209160132.11767"><vh>Fixed g.getLastTracebackFileAndLineNubmer</vh></v>
<v t="ekr.20100209160132.11770"><vh>Fixed open-with crash</vh>
<v t="ekr.20100209160132.11771"><vh>Report</vh></v>
</v>
<v t="ekr.20100209160132.11773"><vh>Fixed bug 518823: clone headline updates</vh></v>
<v t="ekr.20100211125418.11596"><vh>Removed duplicate can not open message for @auto file</vh></v>
<v t="ekr.20100211125418.11599"><vh>Fixed minor bug involving insertion point</vh></v>
<v t="ekr.20100211125418.11602"><vh>Fixed unicode crasher in write-recent-files logic</vh></v>
</v>
<v t="ekr.20100211125418.11611"><vh>New commands</vh>
<v t="ekr.20100209160132.11888"><vh>Created clear-cache and clear-all-caches commands</vh></v>
</v>
</v>
<v t="ekr.20100223063657.7262"><vh>4.7 final</vh>
<v t="ekr.20100223063657.7264"><vh>Bug fixed</vh>
<v t="ekr.20100223063657.7182"><vh>Fixed calls to sort in 6 places</vh>
<v t="ekr.20100223063657.7183"><vh>changed...</vh>
<v t="ekr.20100223063657.7184"><vh>c.sortSiblings</vh></v>
<v t="ekr.20100223063657.7253"><vh>helpForCommand</vh></v>
<v t="ekr.20100223063657.7186"><vh>printBindings &amp; helper</vh>
<v t="ekr.20100223063657.7187"><vh>printBindingsHelper</vh></v>
</v>
<v t="ekr.20100223063657.7188"><vh>printGcAll</vh></v>
<v t="ekr.20100223063657.7189"><vh>sortLines commands</vh></v>
<v t="ekr.20100223063657.7190"><vh>sortRecentFiles</vh></v>
</v>
</v>
<v t="ekr.20100223063657.7192"><vh>Fix bug 363406: goto-global-line works with @auto files</vh></v>
<v t="ekr.20100223063657.7212"><vh>Put focus in a standard place after save commands</vh></v>
<v t="ekr.20100223063657.7232"><vh>Fixed internal Leo error in atFile.read method</vh></v>
<v t="ekr.20100223063657.7238"><vh>Fixed wish-list bug 508108: No methods sub-nodes in PHP class import</vh></v>
<v t="ekr.20100223063657.7245"><vh>Fixed qt colorizer bug</vh></v>
<v t="ekr.20100223063657.7246"><vh>Fixed ancient minibuffer bug</vh></v>
<v t="ekr.20100223063657.7249"><vh>Improved support for wrapping in the log pane</vh></v>
<v t="ekr.20100223063657.7263"><vh>Reformatted the output of the apropos commands</vh></v>
</v>
</v>
</v>
</v>
<v t="edream.110203163054.63"><vh>Latest version</vh>
<v t="ekr.20100225102026.7139"><vh>4.7.1 final</vh>
<v t="ekr.20100225102026.7140"><vh>Changes made to Leo 4.7.1</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040518070558">Leo 4.2 alpha 2           May 18, 2004

This is an important milestone in Leo's history; the two defining features of
the 4.2 code base are complete:

1. This is the first stable version using the "shared nodes" code base.

Shared nodes dramatically improve the time needed to insert, delete, and move
nodes. Moreover, the new code base is code compatible with the old. Indeed, much
of Leo still uses the old code base. See Chapter 7 for full details of how to
script Leo with the 4.2 code base.

2. This is the first version to use @file-thin for most external files.

@file-thin makes it possible to use Leo effectively in a cvs environment.  Indeed, cvs now contains only a "dummy" version of LeoPy.leo.  The idea is that:

- LeoPyRef.leo hardly ever changes. Developers will download LeoPyRef.leo once
from cvs, then rename LeoPyRef.leo to be LeoPy.leo. LeoPy.leo is private to each
developer.

- Developers will commit and update to cvs only thin external files. There is no
longer any need to keep .leo files and the files derived from them "in synch".

- Similar remarks apply to LeoPlugins.leo. Cvs contains only LeoPluginsRef.leo,
and contributors will need only to submit thin external files.

I have been using the new code base without incident for weeks now, and I am
fairly confident that it is safe to use. Nevertheless, I would suggest routine
caution when dealing with this version until more people have tested it.

Known bugs

- Cutting and pasting an @file-thin node does not work properly. This will be
easy to fix, I think.

- The present algorithm for reading thin external files probably does not handle
properly the situation in which a named node is some kind of grand child of the
referencing node rather than being an immediate child of the referencing node.
This is a rare situation, easily avoided, and it doesn't happen at all in
LeoPy.leo. Nevertheless, something must be done.

Other improvements:

- Fixed a number of problems with using Leo on MacOS X. In particular, Leo now
uses the clover key as is usual on the Mac. More Mac and *nix specific
improvements are coming.

Still to do:

- Perfect import and @import. - Make the Go To Line Number command work with
@file-thin files. - Fix minor bugs and add new features See the "To Do: 4.2"
node in the leoToDo.txt node in LeoPy.leo.</t>
<t tx="EKR.20040518070824"></t>
<t tx="EKR.20040518070824.1">- Moved call to assignFileIndices into write_Leo_file.
- Called assignFileIndices in writeAtFileNodes, writeDirtyAtFileNodes, writeMissingAtFileNodes</t>
<t tx="EKR.20040518070940"></t>
<t tx="EKR.20040518070940.156">After a match, the find-next command searched only in the suboutline where the first match occurred.
To fix this, we call g.app.findFrame.handleUserClick in various Tk event handlers.</t>
<t tx="EKR.20040518070940.164">@nocolor


p.v.t.visitedBit was used for two purposes:

- To mark the nodes to be written.
- To mark nodes that are not orphan.

What I did:

- Added t.is/set/clearWriteBit.
- Call t.setWriteBit in putVnode unless we are in a thin node.
- putTnodes tests for t.writeBit rather than t.visitedBit.</t>
<t tx="EKR.20040518070940.5">What I did:

File format

Added -thin field to @+leo sentinel

Recognizers

- Added vnode recognizers for @file-thin option.
- Added position proxies for vnode recognizers.

Directives &amp; sentinels
- Added support for @all.

Writing

- Added top-level atFile code to write @file-thin tree.
- DO write @file-thin vnodes if there was an error writing the external file.
	- No autosave for @file-thin.
 	- Leo writes @file nodes first, so this is not a problem.
	- putVnode checks orphan bit, which gets set if there was an error.
- Don't write vnodes (or related tnodes) for @file-thin trees. (fileCommands).
- Do write empty nodes in @thin trees.
- Don't generate close node sentinels until all children have been generated.

Reading

- Set at.thinFile when reading thin files.
- Suppressed changed message and related items for thin files.
- Modified scanText4 and allies to read thin external files.
	- Don't look for tnodeList for thin files.
	- Initially, at.lastThinNode is at.root.v
	- readStartNode calls createThinChild
	- createThinChild makes a child of at.lastThinNode if needed and sets at.lastThinNode.
- Updated fc.tnodesDict in at.createThinChild.
	Otherwise clones existing only in two thin files won't be linked properly.</t>
<t tx="EKR.20040518071415">Leo did not handle moving a node to the root position of the outline correctly.</t>
<t tx="EKR.20040518075457">Using @ignore with @file-thin is asking for trouble.
If you remove the @ignore and then save, you will lose data.

How to recover the data:
	- Read Outline.
	- Remove @ignore
	- Import External File... </t>
<t tx="EKR.20040524104904.100"></t>
<t tx="EKR.20040524104904.101">-   The New command creates a new Leo main window.

-   The Open command opens an existing Leo file and shows it in a main window.

-   The Close command closes the topmost Leo window,
    giving you an opportunity to save your work if you haven't yet done so.

-   The Save, Save As and Save To commands save the Leo window to a file.
    The Save As command changes the name of the outline being edited;
    the Save To command does not.

    The Save File As Zipped command is the same as the
    Save As command except that the resulting .leo file is compressed with Python's zipfile module.
    Similarly, the Save File As Unzipped command is the same as the Save As command
    except that the resulting .leo file is not compressed.
    The Save, Save As and Save To commands compress the file if it was originally compressed.
    **Note**: Leo writes files with .leo extension, regardless of whether the file is zipped or not.
    Zipped .leo files contain a single archive, whose name is the same as the .leo file itself.
    Outside of Leo you can change the extension to .leo.zip and use stuffit or other program to expand the .leo file
    contained within.

-   The Revert command reloads a file, discarding any changes made to the file since it was last saved.

-   The Recent Files command brings up a submenu containing a list of recently
    opened files. Choosing an item in this submenu opens the selected file or brings
    it to the front.

-   The Clear Recent Files command deletes all entries in the Recent
    Files submenu except the most recent file. The files themselves are not
    affected, just the menu entries.

The following commands are located in the Read/Write menu, part of the File
menu.

-   The Read Outline Only command reads an outline using only the .leo file, not any files derived
    from @file nodes. This command is useful for reverting a project to a
    previously saved state.

-   The Read @file Nodes command updates all @file nodes in an outline.
    This ensures that the state of an outline matches all files derived
    from @file nodes. 

-   The Write Outline Only command saves an outline without writing any @file
    trees. Useful for inserting an @file node into an outline without modifying a
    external file with the same name.

-   The Write @file Nodes command forces an update of all @file trees.

-   The Write Dirty @file Nodes command writes all @file trees that have been changed.</t>
<t tx="EKR.20040524104904.102">The Open With command allows you to communicate with external editor. When
you select this command Leo creates a temporary file and invokes an external
program. Leo periodically checks whether this temporary file has changed; Leo
changes the corresponding node in the outline if so. You must create the entries
in the Open With submenu. This would typically be done in a hook routine, using
the createOpenWithMenuFromTable routine described in the child of this node. The
@file mod_open_with.py node in LeoPlugins.leo gives a complete example
of handling the Open With menu.</t>
<t tx="EKR.20040524104904.105">The Tangle, Tangle All and Tangle Marked commands create derived
files from portions of an outline. These commands indent and format the derived
files so that they are easy to read and so that it is clear what sections
produced the code. The .c file in the Examples folder shows the code produced by
the Tangle commands. The Tangle command tangles only the selected portion of
the outline, the Tangle All command tangles the entire outline, and the
Tangle Marked command tangles only marked headlines.

The Tangle commands create a external file, call it F, from each @root
node. This process is like macro expansion. The contents of F are simply the
body text of the @root node, with each section reference replaced by its
definition. Substitution continues until all references to sections are replaced
with their definitions. By default, Tangle commands look for section
definitions only in the suboutline containing the @root directive being
tangled. That is, all sections are assumed to be defined either in the body text
of the headline, say h, containing the
@root directive, or in the body texts of the descendants of h.
The @unit directive changes the default scope of the tangle command, while
the @ignore directive causes the tangle commands to ignore a subtree. For
more details, see: `Tangling @root trees with the Tangle commands`_</t>
<t tx="EKR.20040524104904.106">The Untangle, Untangle All and Untangle Marked commands are the
reverse of the corresponding Tangle commands. They update an outline based
on changes made to one or more external files. These are exceptionally useful
commands. For example, suppose you create a new part of the outline and
Tangle it for the first time. When you compile the resulting external files
for the first time, you are likely to get many syntax errors. You could fix
those errors in the outline and Tangle the outline again, but there is a much
easier way: you fix the errors in the external files using the compiler's editor,
then run the untangle command on the part of the outline that created the
external file. The Untangle command updates the selected outline to match the
changes in the external files. It's as simple as that. The Untangle command
marks all the nodes in the outline that it updates; you can examine all such
nodes with the Go To Next Marked command in the Outline menu. You cannot use
Untangle to update doc parts, or leading comments in code parts or "trivial"
whitespace in code parts. This is a limitation of the Untangle command that
cannot be fixed; Untangle has no way of knowing whether leading comments
came from doc parts or are just leading comments.

Untangle never changes the structure of an outline; it never inserts,
deletes or moves nodes. Don't attempt to change the structure of an outline by
modifying external files; it won't work. Also, never delete, move or alter the
sentinel lines in external files written by the Tangle command. Such lines start
with /// followed by a section name. If you change the section name in a
sentinel line Untangle will not update the code in the outline (with the old
name) that generated the renamed section. Untangle now warns about sections that
appear in a external file but not in the outline. Untangle has no trouble with
changed section references in external files; it is only changed sentinel lines
that cause problems. Cloned nodes that generate code in several files may cause
problems for Untangle if not all the code is changed the same way in derived
files. If Untangle is run separately on these external files, Untangle will
update all cloned nodes each time it is run, so only the code in the last
Untangle run will take effect. Therefore, the only reliable way to update
text in cloned nodes is to make the change in the .leo file rather than the
external files.</t>
<t tx="EKR.20040524104904.108">The Import commands do not attempt to do perfect translations; they merely automate the bulk of the drudgery:

-   The Import to @file command creates an @file node from a file.

-   The Import to @root command creates an @root node from a file.

-   The Import CWEB Files command creates an @file node from a `CWEB`_ file.

-   The Import noweb Files command creates an @file node from a `noweb`_ file.

-   The Import External File command imports all the nodes in a external file into the outline.
    Unlike the read commands, the command preserves no outline structure.

-   The Import Flattened Outline command converts plain text written in MORE format to an outline.

The Import Flattened Outline command brings up a dialog which will accept at
most one file. If that file contains MORE-format text it creates an outline
corresponding to that text. MORE is a now-defunct outliner program. MORE
represents outlines as follows. Headlines are denoted by a leading + or
- character, preceding by zero or more tabs that denote the level of the
headline. Body text follows its headline, with no indentation. The original
MORE format did not escape lines in the body text that started with + or -.
Leo escapes such characters by preceding +, - or backslash with a
backslash.</t>
<t tx="EKR.20040524104904.109">-   The Outline To CWEB command creates a `CWEB`_ file from the selected outline.

-   The Outline TO noweb command creates a `noweb`_ file from the selected outline.

-   The Flatten Outline command creates a text file in MORE format from the selected outline.
    See the previous section for a discussion of MORE format.

-   The Remove Sentinels command removes all sentinel lines from a file derived from an @file node.

-   The Weave Command formats the selected text and writes it to a file.</t>
<t tx="EKR.20040524104904.110">The Quit command causes Leo to exit. You may also exit Leo by closing the
main window. You will be prompted to save any file that has been altered but not
saved.</t>
<t tx="EKR.20040524104904.111"></t>
<t tx="EKR.20040524104904.112">Leo supports unlimited undo and redo. Think of actions that may be undone or
redone as a string of beads. A "bead pointer" points to the present bead.
Performing an operation creates a new bead after the present bead and removes
all following beads. Undoing an operation moves the bead pointer backwards;
redoing an operation moves the bead pointer forwards. The Undo command is
disabled when the bead pointer moves in front of the first bead; the Redo
command is disabled when the bead pointer points to the last bead.
</t>
<t tx="EKR.20040524104904.113">Leo supports the standard editing commands: Cut, Copy, Paste,
Clear and Select All. These commands work with either headline or body
text.
</t>
<t tx="EKR.20040524104904.114">The Shift Left and Shift Right commands shift selected lines in the body
text left or right one tab position. These commands shift the entire line if any
characters in that line are selected.</t>
<t tx="EKR.20040524104904.115">The Extract, Extract Section and Extract Section Names commands create child nodes whose headline is the first line of the selected body text.

-   The Extract command creates a new node whose headline is the first line of selected body text and
    whose body is all other lines of selected text.
    Previously selected text is deleted from the original body text. 

-   The Extract Section command creates a new node whose headline is the first line of selected text and
    whose body is @code followed by all the other lines of selected text.
    All selected text lines except the first line are deleted from the original body text.
    This command is enabled only if the first line contains nothing but section name.

-   The Extract Section Names command creates one or more child nodes,
    one for each section name in the selected body text.
    The headline of each created node is the section name; the body text is @code followed by a newline.</t>
<t tx="EKR.20040524104904.116">-   The Convert Tabs command converts leading tabs to blanks in a single node.
-   The Convert Blanks command converts blanks to tabs in a single node.
-   The Convert All Tabs converts leading tabs to blanks throughout the selected tree.
-   The Convert All Blanks command converts leading blanks to tabs throughout the selected tree.

All these commands convert between tabs and blanks using the tab width presently in effect.</t>
<t tx="EKR.20040524104904.117">The Execute Script command executes body text as a Python script. Leo
execute the selected text, or the entire body text if no text is selected. The
Execute Script command pre-defines the values c, g and p as
follows:

- c is the commander of the outline containing the script.
- g is the leoGlobals modules.
- p is c.p, that is, c.currentPosition().

**Important**: Body text may contain Leo directives and section references. You
can now use all of Leo's features to organize scripts that you execute
interactively. Section definitions must appear in the node containing the script
or in descendant nodes.

Leo preprocesses all scripts by simulating the writing of a external file to a
string. The Execute Script command sets app.scriptDict["script1"] to the
value of the script before preprocessing, and sets app.scriptDict["script2"]
to the value of the script after preprocessing. Scripts may examine and change
app.scriptDict as they please.</t>
<t tx="EKR.20040524104904.118">The following check boxes options appear in the search dialog and control the operations of the find and change commands.

Clone Find All
    When checked, the the Find All command creates a new root node called Found: *&lt;your search pattern&gt;*.
    This node contains clones of the nodes found by the Find All command.
    It is your responsibility to navigate to this new node and to clean it up when it's no longer needed.

Ignore Case
    When checked, the Find and Change commands ignore the case of alphabetic characters when determining matches.

Mark Changes
    When checked, the Change command marks all headlines whose headline or body text are changed by the command.

Mark Matches
    When checked, the Find and Change commands mark all headlines in which a match is found with the pattern.

Pattern Match
    When checked, the Find and Change commands treat several characters specially in the find pattern.

    - '*'  matches any sequence of zero or more characters.
    - '.'  matches any single character.
    - '^'  matches a newline at the start of a pattern.
    - '$'  matches a newline at the end of a pattern.

Examples::

    "^abc$" matches lines that only contain "abc".
    "^a" matches any line starting with "A".
    "a$" matches any line ending with "a".
    "^*$" matches any line at all.

Reverse
    When checked, the Find and Change commands search backward through the file.

Search Body Text
    When checked, the Find and Change commands search body text.

Search Headline Text
    When checked, the Find and Change commands search headline text.

Show Context
    When checked, the Find All command shows additional context information when printing matches.

Suboutline Only
    When checked, the Find and Change commands search only the currently selected headline and its offspring.

Whole Word
    When checked, the find pattern must match an entire word.
    Words consist of an alphabetic character or underscore, followed by zero or more
    alphabetic characters, numbers or underscores.

Wrap Around
    When checked, the Find and Change commands continues at the top of the file when
    the command reaches the bottom of the file.
    For reverse searches, the find or change command continues at the bottom of the file when
    the command reaches the top of the file.</t>
<t tx="EKR.20040524104904.134">The Go To Line Number command selects the locations in your outlines corresponding to a line in a external file.
</t>
<t tx="EKR.20040524104904.136">The Insert Body Time/Date and Insert Headline Time/Date commands insert
formatted time and date into body or headline text. You must be editing a
headline to be able to insert the time/date into the headline.
The  body_time_format_string and headline_time_format_string settings
specify the format of the inserted text. These settings are the format string
passed to time.strftime. For a complete list of the format options see
http://www.python.org/doc/current/lib/module-time.html
If the format specified by either of these two settings is erroneous the
"%m/%d/%Y %H:%M:%S" format is used by default, resulting in a time/date
format like::

    1/30/2003 8:31:55</t>
<t tx="EKR.20040524104904.137">The Reformat Paragraph command rearranges the words in a text paragraph to fill
each line as full as possible, up to the @pagewidth setting. A paragraph is
delimited by blank lines, Leo directives, and (of course) start and end of text
in a node. The width of the line used by the reformatting operation is governed
by @pagewidth and the indentation that would be applied to the node when
tangled (as part of a @root) or written (as part of a @file).

The command operates on the paragraph containing the insert cursor. If the
insert cursor is on a blank line or directive, nothing happens. If the cursor is
on a line containing text, then the paragraph containing that text line is
reformatted and the insert cursor is moved to the next paragraph.

**Note**: Hanging indentation is preserved. This is most useful for bulleted or
numbered lists, such as::

  1. This is the first paragraph,
     and it has a hanging indentation.

  2. This is the second paragraph,
     and it too has a hanging indentation.</t>
<t tx="EKR.20040524104904.139">The Match Brackets command is enabled if the cursor is next to one of the
following characters in the body pane:

    ( ) [ ] { } &lt; &gt;

This command looks for the matching character, searching backwards through the
body text if the cursor is next to `)` `]` `}` or `&gt;` and searching forward through the
text otherwise. If the cursor is between two brackets the search is made for the
bracket matching the leftmost bracket. If a match is found, the entire range of
characters delimited by the brackets is highlighted and the cursor is placed
just to the left of the matching characters. Thus, executing this command twice
highlights the range of matched characters without changing the cursor.</t>
<t tx="EKR.20040524104904.140">Leo stores options in **@settings trees**, outlines whose headline is
@settings. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.
This scheme allows for the following kinds of settings:

- Per-installation or per-machine settings.
- Per-user settings.
- Per-folder settings.
- Per-file settings.

There are four kinds of settings files:

1. **Default settings files**, named **leoSettings.leo**.
   Although they can be used in other ways, they typically contain default settings.

2. **Personal settings files**, named **myLeoSettings.leo**. They provide a way
   of ensuring that your customized settings are not altered when updating Leo
   from bzr or while installing a new version of Leo. The myLeoSettings.leo acts
   much like Python's site-customize.py file. myLeoSettings.leo will never be
   part of any Leo distribution, and it will never exist in Leo's cvs
   repository. This solution is *much* better than trying to update
   leoSettings.leo with scripts.

3. **Machine settings files**, named **LeoSettings.leo** (note the capital 'L'),
   and appearing in a unique directory.

4. **Command-line settings files**, specified using Leo's -c command-line
   option. Any .leo file may be used, provided it has an @settings tree. These
   files typically provide a common set of settings for files scattered in
   various places on the file system.

The following sections describe the kinds of nodes in @settings trees.
</t>
<t tx="EKR.20040524104904.143"></t>
<t tx="EKR.20040524104904.144">-   The Check Outline command checks the outline for consistency.

-   The Check All Python Code and Check Python Code commands report any syntax errors or tabnanny errors.
    These commands mark erroneous nodes and ignore any nodes for which:

        - @ignore is in effect or
        - @language python is in not effect.

-   The Check Python Code and Pretty Print Python Code pretty print body text.
    You can customize this code by overriding the following methods of class prettyPrinter in leoCommands.py::

        putOperator:      puts whitespace around operators.
        putNormalToken:   puts whitespace around everything else.</t>
<t tx="EKR.20040524104904.145">-   The Insert Headline command inserts a new headline after the presently selected headline,
    either as the next sibling or the first child of the presently selected headline
    if the presently selected headline has children and is expanded.

-   The Clone Node creates a clone of the selected node.
    See `Clones and views`_ for full details about clones.</t>
<t tx="EKR.20040524104904.146">-   The Cut Outline and Copy Outline commands copy a text
    representation of the outline to the clipboard. This representation is the same
    as the file format with some information deleted.

-   The Paste command (in the Edit menu) copies this representation into the *body* pane.

-   The Paste Node As Clone command pastes the node from the clipboard, retaining the
    identity of nodes.  Thus, if the pasted node already exists in the outline the newly
    pasted node will become of a clone of the already-existing node.

-   The Paste Outline command creates nodes with new identities (new gnx's).</t>
<t tx="EKR.20040524104904.147">-   The Expand command expands the currently selected node so that all its children are visible.
-   The Expand All Subheads command expands the currently selected node so that all its offspring are visible.
-   The Expand All command expands all the nodes of the entire tree.
-   The Contract Parent contracts the selected node's parent and selects the parent node.</t>
<t tx="EKR.20040524104904.148">-   The Hoist command redraws the screen so presently selected tree becomes the only visible part of the outline.
    Hoist commands may be nested.  

-   The De-hoist command restores the outline.</t>
<t tx="EKR.20040524104904.149">-   The Mark Headline command marks a headline with a red marker  near the leader characters.
-   The Unmark Headline command removes such a mark.
-   The Mark Subheads command marks all offspring of the currently selected node.
-   The Unmark All command removes the marks from the entire tree.
-   The Mark Changed Items command marks all headlines whose headline or
    body text has been changed since the file was last saved.
-   The Mark Changed Roots command marks all changed headlines whose body text contains the @root directive.
    This command is especially useful with the Tangle Marked command.</t>
<t tx="EKR.20040524104904.150">-   The Move Up, Move Down, Move Left and Move Right commands move the currently selected node.

-   The Promote command makes all the children of a node siblings of the node.

-   The Demote command makes all the siblings that follow a node children of the node.

-   The Sort Children command sorts all children of the present node in alphabetical order of their headlines.

-   The Sort Siblings command sorts all siblings of the present node in alphabetical order.</t>
<t tx="EKR.20040524104904.151">-   The Equal Sized Panes command adjusts the sizes of the outline and body
    panes so that they are the same height.
-   The Cascade command cleans up the screen by cascading all Leo windows.
-   The Minimize All command minimizes all Leo windows.
-   The Toggle Active Pane command toggles keyboard focus between the outline and body panes.
-   The Toggle Split Direction command switches between vertical and horizontal
    orientations of the Leo window. In the vertical orientation, the body pane
    appears below the pane containing the outline and log panes. In the horizontal
    orientation, the body pane appears to the left the pane containing the outline
    and log panes. By default, the ratio of pane outline pane to the body pane is
    0.5 in the vertical orientation and 0.3 in the horizontal orientation. These two
    ratios may be changed using settings.
-   The Open Compare Window command opens a dialog that allows you to compare
    two files, one containing sentinels and one not.
</t>
<t tx="EKR.20040524104904.157">-   The About Leo command puts up a dialog box showing the version of Leo.
-   The Online Home Page command opens Leo's home page at http://webpages.charter.net/edreamleo/front.html.
-   The Open Online Tutorial command opens Joe Orr's excellent ScreenBook tutorial at
    http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm.
-   The Open Offline Tutorial command opens the file sbooks.chm if it exists.
    Otherwise, you will be asked whether you want to download it from Leo's SourceForge web site.
    If you say yes, the page http://sourceforge.net/project/showfiles.php?group_id=3458 will open.
    You may then download sbooks.sbm to the folder containing leo.py.
-   The Open LeoDocs.leo command opens LeoDocs.leo.
-   The Open LeoPlugins.leo command opens LeoPlugins.leo.
-   The Open LeoSettings.leo command opens LeoSettings.leo.

</t>
<t tx="EKR.20040524104904.161">@language rest</t>
<t tx="EKR.20040524104904.162">The following paragraphs discuss the main benefits of traditional `literate programming`_.
**Note**: none of these benefits depends on printed output.

**Design and coding happen at the highest possible level**.
The names of sections_ are constrained only by one's design skill, not by any
rules of language. You say what you mean, and that becomes both the design and
the code. You never have to simulate a concept because concepts become `section
names`_.

**The visual weight of code is separate from its actual length**.
The visual weight of a section_ is simply the length and complexity of the
section name, regardless of how complex the actual definition of the section
is. The results of this separation are spectacular. No longer is one reluctant
to do extensive error handling (or any other kind of minutia) for fear that it
would obscure the essence of the program. Donald Knuth stresses this aspect of
literate programming and I fully agree.

**Sections show relations between snippets of code**.
Sections_ can show and enforce relationships between apparently unrelated pieces
of code. Comments, macros or functions are other ways to indicate such
relationships, but often sections are ideal. Indeed, a natural progression is to
create sections as a matter of course. I typically convert a section to a
function only when it becomes apparent that a function's greater generality
outweighs the inconvenience of having to declare and define the function.

**Complex section names invite improvements**.
A section name is complex when it implies unwholesome dependencies between the
caller (user) of the section and the section_ itself. Such section names tend to
be conspicuous, so that the programmer is lead to revise both the section name
and its purpose. Many times my attention has been drawn to a poorly conceived
section because I didn't like what its name implied. I have always been able to
revise the code to improve the design, either by splitting a section into parts
or be simplifying its relation to colleagues.

**Sections create a place for extensive comments**.
One of the most surprising thing about literate programming is how severely
traditional programming tends to limit comments. In a conventional program the
formatting of code must indicate structure, and comments obscure that
formatting. Sections_ in literate programming provide a place for lengthy
comments that do not clutter the code at the place the section is
referenced_.

**Section names eliminate mundane comments**.
The section name often says it all. The reference_ to the section says everything
that the user needs to know, and the section name at the point of definition
also eliminates the need for many comments.

**Sections create comments automatically**.
A typical @root node starts out with something like::

	&lt;&lt; includes for class x &gt;&gt;
	&lt;&lt; private data for class x &gt;&gt;
	&lt;&lt; private prototypes for class x &gt;&gt;
	&lt;&lt; functions of class x &gt;&gt;

In the external file there is a comment that looks like this::

	/// &lt;&lt; includes for class x &gt;&gt;

It would be silly to write this comment by hand, though often programmers do
just that in order to have a place holder for a mark in the source file. With
literate programming the situation is different: the comment indicates that the
code came from a particular section_; that is, the comment servers a real
purpose.

**Literate programming clarifies the shape of code**.
These last several paragraphs have discussed comments in detail because the net
effect of "putting comments where they belong" is that comments don't clutter
the code. Section references hide irrelevant detail, so larger-scale patterns
within functions (or declarations) become more apparent. Often just recasting
code into web format has created Aha's about my own code, with no special
attention to recoding or redesign! Recasting a function as a web raises the real
and apparent level of abstraction.

**I spend less time formatting code**.
Formatting no longer has to indicate overall design; sections do that. I am less
obsessive about formatting code; it simply doesn't matter much whether different
sections are formatted consistently because the format of one section has no
effect on the look of other sections. Also, I don't worry about most line breaks
within `documentation parts`, or about adding comment delimiters.

**Literate programming creates a new design dimension**.
Sections_ add a new dimension to the design and coding process. Choices about
what sections do, what they are named, what order they appear in, are choices in
a design space different from "normal" programming. This an abstract concept, to
be sure. However, the previous paragraphs are really a manifestation of
working in this new design space.</t>
<t tx="EKR.20040524104904.173">Outlines_ add something brand new to traditional literate programming, namely an
explicit mechanism for expressing structure at any level of detail, from largest
overall view to smallest detail. The following paragraphs elaborate on this theme.

**Outlines add context**.
There are too many sections_ in conventional `literate programming`. It becomes
difficult to understand the relationships between sections. Using an outline_ to
express a literate programming instantly solves this problem. The programmer is
always aware of how sections are related.

**Outlines provide scope for commands**.
Outlines_ provide a convenient way of expressing the intended scope of commands.
For example, the Tangle command operates only on the presently selected tree_.
The Extract Section command creates a new section_ as the last child_ of the
present node_.

**Clones create different views and focus attention**.
Clones_ can create different views of the outline. An outline_ can contain many such views.
`Clones &amp; views`_ discusses the implications of clones in detail.

**Outlines increase flexibility**.
Organizer nodes do not affect external files in any way, but organizer nodes
often convey the most information about the structure and design of a large
system. Decoupling structure from content in this way is precisely what is
needed for flexibility: one can reorganize at will without worrying about
changing the meaning of the code.

**Outlines express hierarchy directly**.
Hierarchy is often implicit in programming: for example, the grouping of
functions into files, or the organization of a single file as a set of
functions, etc. An outline_ directly expresses hierarchy. Many of Leo's commands_
operate on the presently selected node. It is natural to apply operations on
selected node_ of the outline.

**reStructuredText is much easier to use than CWEB markup.**
Leo makes it easy to use reStructuredText_ (rST) instead of CWEB markup. For
most purposes, rST suffices, and rST is much easier to use and less intrusive
than CWEB.

**Outlines create new design dimensions**.
There are many ways to express a program as a Leo outline. Such choices are
important. They add clarity to the entire program. These are different *kind* of
choices. They simply can not be expressed at all in other editors. In other
words, such choices exist in a new design space. 

**Leo improves tangling and adds untangling**.
Tangling_ and untangling_ are fundamental operations of `literate programming`_.
Leo tangles and untangles files derived from @file trees automatically. This
is an important convenience.</t>
<t tx="EKR.20040524104904.181">Leo changes the theory and practice of literate programming as follows:

**Leo reduces the need for comments**.
In particular, bridge or transition phrases are almost always unnecessary in a
Leo outline_. One never needs to say something like, "having just finished
with topic x, we turn now to topic y." Leo's outlines tend to be far less
chatty than flat literate programs.

**Leo reduces the need for printed listings**.
Experience with the Weave command shows that an outline can easily become
unintelligible when printed, no matter how "beautiful" the typeset printout is.
No printed listing can be as clear as Leo's outline view.

**Leo reduces the need for indices and tables of contents**.
You could say the entire outline is a table of contents. Moreover, sections_
must always be defined in a descendant of the node_ containing the `section
reference`_, so there is very little need for an index. 

**Leo shows that outline structure is more powerful than narrative.**
Indeed, narrative style creates severe maintenance problems. The narrative is
soon forgotten, and when that happens it becomes difficult to find anything. The
few times I have tried narrative organization I soon regretted it: things just
weren't where I expected them to be.

**Leo shows that traditional literate programming encourages a too creative approach to programming.**
A dictionary is a better model for programs than a novel. Leo's outlines provide
a more regular organization, while providing space for the most lengthy
discussions when those discussions are required.</t>
<t tx="EKR.20040524104904.211">@language rest</t>
<t tx="EKR.20040524104904.224">Naively using plugins can expose you and your .leo files to malicious attacks.
The fundamental principles are::

    Scripts and plugins must never blindly execute code from untrusted sources.

and::

    .leo files obtained from other people may potentially contain hostile code.

Stephen Schaefer summarizes the danger this way::

    I foresee a future in which the majority of leo projects come from
    marginally trusted sources...a world of leo documents sent hither and yon -
    resumes, project proposals, textbooks, magazines, contracts - and as a race
    of Pandora's, we cannot resist wanting to see "What's in the box?" And are
    we going to fire up a text editor to make a detailed examination of the
    ASCII XML? Never! We're going to double click on the cute leo file icon, and
    leo will fire up in all its raging glory. Just like Word (and its macros) or
    Excel (and its macros).

In other words::

    When we share "our" .leo files we can NOT assume that
    we know what is in our "own" documents!

Not all environments are untrustworthy. Code in a commercial cvs repository is
probably trustworthy: employees might be terminated for posting malicious code.
Still, the potential for abuse exists anywhere.

In Python it is very easy to write a script that will blindly execute other scripts::

    # Warning: extremely dangerous code

    # Execute the body text of all nodes that start with `@script`.
    def onLoadFile():
        for p in c.all_positions():
            h = p.h.lower()
            if g.match_word(h,0,"@script"):
                s = p.b
                if s and len(s) &gt; 0:
                    try: # SECURITY BREACH: s may be malicious!
                        exec(s + '\n')
                    except:
                        es_exception()

Executing this kind of code is typically an intolerable security risk.
**Important**: rexec provides *no protection whatever*.
Leo is a repository of source code, so any text operation is potentially malicious.
For example, consider the following script, which is valid in rexec mode::

    badNode = c.p
    for p in c.all_positions():
        &lt;&lt; change `rexec` to `exec` in p's body &gt;&gt;
    &lt;&lt; delete badNode &gt;&gt;
    &lt;&lt; clear the undo stack &gt;&gt;

This script will introduce a security hole the .leo file without doing anything
prohibited by rexec, and without leaving any traces of the perpetrating script
behind. The damage will become permanent *outside* this script when the user
saves the .leo file.</t>
<t tx="EKR.20040524104904.240">The plugins test suite creates a new convention: if a plugin has a function at
the outer (module) level called unitTest, Leo will call that function when
doing unit testing for plugins. So it would be good if writers of plugins would
create such a unitTest function. To indicate a failure the unitTest just
throws an exception. Leo's plugins test suite takes care of the rest.</t>
<t tx="EKR.20040524104904.242">Leo reads and writes "foreign" attributes in &lt;v&gt; and &lt;t&gt; elements in .leo files as follows:

- When reading a .leo file, Leo will create t.unknownAttributes or v.unknownAttributes ivars for
  any tnode or vnode whose corresponding &lt;v&gt; or &lt;t&gt; element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are dictionaries whose keys are the attribute names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if a vnode or tnode contains an unknownAttributes ivar.

- The only native attribute of &lt;t&gt; elements is tx.

- The native attributes of &lt;v&gt; elements are a, t, vtag and tnodeList.

- The native attributes of &lt;v&gt; elements are marks, expanded and descendentTnodeUnknownAttributes.

- Non-native attributes are called **foreign** attributes.

- Leo performs the usual xml escapes on these strings when reading or writing the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching unknownAttributes ivars to a vnode or tnode.
Like this::

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes ["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

See the section called "Recommended conventions for plugins" for advice about
how to avoid potential conflicts in naming new attributes.

All members of these dictionaries should be "pickleable". That is, Leo uses
Python's Pickle module to encode all values in these dictionaries. Leo will
discard any attributes that can not be pickled. This should not be a major
problem to plugins. For example, instead of putting a tnode into these
dictionaries, a plugin could put the tnode's gnx (a string) in the dictionary.

Leo writes only t.unknownAttributes when writing @thin trees to the .leo
file. Leo puts (the encoding of) these elements into an attribute called
descendentTnodeUnknownAttributes. This attribute is part of the &lt;v&gt;
element representing the @thin node. Leo does _not_ write
v.unknownAttributes in @thin trees because *only tnodes have gnx's in
thin external files*. In effect, vnodes are anonymous. We could attempt to get
around this by identifying vnodes by their corresponding tnodes, but that's not
a general solution and it is, in effect, equivalent to writing only
t.unknownAttributes. So it seems pointless to "pretend" to be writing
v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using
unknownAttributes is concerned. This won't work in all cases. For example, a
plugin that creates an arbitrary directed graph between vnodes must distinguish
between joined vnodes. In that case, the plugin should confine itself to @file
trees, or just vnodes in .leo files, for that matter.</t>
<t tx="EKR.20040524104904.245">@language rest</t>
<t tx="EKR.20040524104904.247">In May of 1999 I began work on the Borland version of Leo for Windows.  The Borland Delphi classes were a pleasure to use and free of bugs.  I redesigned Leo's file format for the Windows version of Leo;  the Yellow Box file format is a binary format that requires the Yellow Box runtime.  Fortunately, I choose to use XML for Leo's file format. I have Marc-Antoine Parent to thank for this decision; he urged me to use XML and patiently explained how to use XML properly.  However, there are two significant problems with the Borland version of Leo.  First, it works only on Windows.  Second, it can never be Open software, because it uses Borland's Delphi classes and a commercial syntax coloring component.

In October of 2001 I began work on the leo.py, an Open Software version of leo.py, a version of Leo written in Python and Tk.  At last I have found the proper platform for Leo.  leo.py naturally supports scripting in Python.  The combination of Python and Tk is incredibly powerful, very easy to use, and truly cross platform.  I rewrote Leo in Python in about two months!  For the first time in my career I no longer am anxious while programming; it simply isn't possible to create bad bugs in Python.</t>
<t tx="EKR.20040524104904.248">The following sections give a pseudo-chronological list of the major Aha's
involved in creating Leo2. These Aha's form the real design and theory of
operation of Leo. See the "Diary", "Notes" and "Letters to Speed Ream" sections
in LeoDocs.leo for a more accurate and less tidy history of Leo2.

I am writing these notes for several reasons. First, the initial design and
coding of Leo2, spanning a period of about 8 weeks, was some of the most
creative and rewarding work I have ever done. The result is elegant and simple.
I'm proud of it. Second, much of the design work is not reflected in the code,
because improved design often eliminated code entirely. The final code is so
elegant that it obscures the hard work that created it. Third, you must
understand this design in order to understand the implementation of @file trees
and their external files. Someday someone else may take charge of Leo. That
person should know what really makes Leo2 work.</t>
<t tx="EKR.20040524104904.249">In the summer of 2001 I began work on a project that for a long time I had
considered impossible. I had long considered that "private" file formats such as
.leo files were the only way to represent an outline properly and safely. I'm
not sure exactly what changed my mind, but I finally was willing to consider
that information embedded in external files might be useful. This meant accepting
the possibility that sentinel lines might be corrupted. This was a crucial first
step. If we can trust the user not to corrupt sentinel lines than we can embed
almost any kind of information into a external file.

There were several motivations for this work. I wanted to eliminate the need for
explicit Tangle and Untangle commands. I thought of this as "Untangle on
Read/Tangle on Write." If tangling and untangling could be made automatic it
would save the user a lot of work. I also wanted to make external files the
primary sources files. .leo files might be made much smaller external files
contained the primary source information. This hope turned out to be false.

The result of this design work was something I originally called Leo2, though I
now usually prefer to talk about @file trees. Initially most design issues were
unresolved or unknown. I resolved to attempt a robust error-recovery scheme, not
knowing in advance what that might involve. I also wanted to solve what I
thought of as the "cross-file clone" problem: clones that point from a .leo
outline into a external file. With Leo1 cross-file clones do not exist;
everything is in the same .leo file. It was clear that Leo2 would have to change
some aspects of clones, but all details were fuzzy.
</t>
<t tx="EKR.20040524104904.250">The next step was also crucial. I started to use Leo1 as a prototype to design
what the new body pane would look like to the user. In retrospect, using Leo1 as
a prototype for Leo2 was just as inspired as using MORE as a prototype for Leo1.
Both prototypes marked the true beginning of their respective projects. The Leo2
prototype was a mockup in Python of the code for reading and writing derived
files. The file LeoDocs.leo contain these first prototype nodes.

Writing the prototype got me thinking about improving noweb. With my experience
with Leo1, I was able to create a new markup language that took advantage of
outline structure. I called the new language "simplified noweb", though that
terminology is obsolete. I created @file nodes to distinguish between the old
and new ways of creating external files. In Leo1, the @code directive is simply
an abbreviation for a section definition line. Simplified noweb used @c as an
abbreviation for @code. More importantly, simplified noweb used @c to separate
doc parts from code parts without necessarily specifying a section name. It
quickly became apparent that most nodes could be unnamed. All I needed was the
@others directive to specify the location for all such unnamed nodes.

From the start, simplified noweb was a joy to use. Indeed, the @others directive
could replace all section definition lines. Furthermore, I could make @doc
directive optional if the body pane started in "code mode". But this meant that
plain body text could become a "literate" program! This was an amazing
discovery. These Aha's got me excited about Leo2. This was important, as it
motivated me to do a lot of difficult design work.</t>
<t tx="EKR.20040524104904.251">In spite of this excitement, I was uneasy. After much "daydreaming" I realized
that I was afraid that reading and writing external files would be interrupted by
a long series of alerts. I saw that designing the "user interaction" during
reading and writing would be very important. The next Aha was that I could
replace a long series of alerts with messages to the log window, followed by a
single "summary" alert. Much later I saw how to eliminate alerts entirely.

At this time I thought there would be two kinds of "errors" while reading
external files. Warnings would alert the user that something non-serious had
happened. True errors would alert the user that data might have been lost.
Indeed, if Leo2 saves orphan and ignored nodes in a .leo file under an @file
node, then read errors could endanger such nodes. Much later I saw that a robust
error recovery scheme demands that @file nodes not contain orphan and @ignored
nodes. (More on this subject later.) But if orphan and @ignored nodes are moved
out of @file trees, there are no read errors that can cause data loss! So the
distinction between warnings and errors finally went away.</t>
<t tx="EKR.20040524104904.252">I next turned my attention to writing @file nodes. A huge Aha: I realized that
sentinel lines must contain both a leading and a trailing newline. The general
principle is this: the write code must contain absolutely no "conditional"
logic, because otherwise the read code could not figure out whether the
condition should be true or false. So external files contain blank lines between
sentinel lines. These "extra" newlines are very useful, because the read
(untangle) code can now easily determine exactly where every blank, tab and
newline of the external file came from. It would be hard to overstate how
important this simplifying principle was in practice.

Much later, with urging from a customer, I realized that the write code could
safely remove "extra" newlines between sentinels with a caching scheme in the
low level atFile::os() routine. This scheme does not alter the body of the write
code in any way: in effect, sentinels still contain leading and trailing
"logical" newlines. The read code had to be modified to handle "missing" leading
newlines, but this can always be done assuming that sentinels still contain
logical leading and trailing newlines!

At about this time I designed a clever way of having the write code tell the
read code which newlines were inserted in doc parts. (The whole point of doc
parts is to have the write code format long comments by splitting long lines.)
To quote from my diary:

"We can use the following convention to determine where putDocPart has inserted
line breaks: A line in a doc part is followed by an inserted newline if and only
if the newline is preceded by whitespace. This is a really elegant convention,
and is essentially invisible to the user. Tangle outputs words until the line
would become too long, and then it inserts a newline. To preserve all
whitespace, tangle always includes the whitespace that terminates a word on the
same line as the word itself. Therefore, split lines always end in whitespace.
To make this convention work, tangle only has to delete the trailing whitespace
of all lines that are followed by a 'real' newline."</t>
<t tx="EKR.20040524104904.253">After the write code was working I turned my attention to the read (untangle)
code. Leo's Untangle command is the most complex and difficult code I have ever
written. Imagine my surprise when I realized that the Leo2 read code is
essentially trivial! Indeed, the Leo2 untangle code is like an assembler. The
read code scans lines of a external files looking for "opcodes", that is,
sentinel lines, and executes some simple code for each separate opcode. The
heart of this code is the scanText routine in atFile.cpp.

The read code was written and debugged in less than two days! It is the most
elegant code I have ever written. While perfecting the read code I realized that
sentinel lines should show the complete nesting structure found in the outline,
even if this information seems redundant. For example, I was tempted to use a
single sentinel to represent an @other directive, but finally abandoned this
plan in favor of the @+other and @-other sentinels.

This redundancy greatly simplified the read code and made the structure of
external files absolutely clear. Moreover, it turned out that we need, in
general, all the information created by the present sentinel lines. In short,
sentinels are as simple as they can be, and no simpler.

The atFile::createNthChild method is a very important: it ensures that nodes
will be correctly inserted into the outline. createNthChild must be bullet-proof
if the Read code is to be robust. Note that the write code outputs @node
sentinels, that is, section definitions, in the order in which sections are
referenced in the outline, not the order in which sections appear in the
outline. So createNthChild must insert the n'th node of parent p properly even
if p contains fewer than n-1 children! The write code ensures that section
references are properly nested: @node sentinels are enclosed in @node sentinels
for all their ancestors in the @file tree. createNthChild creates dummy siblings
as needed, then replaces the dummy siblings later when their actual definitions,
that is, @node sentinels, are encountered.

At this point the fundamental read/write code was complete. I found three minor
bugs in the code over the next week or so, but it was clear that the read/write
code formed a rock-solid base from which to continue design and implementation.
This was an entirely unexpected surprise.</t>
<t tx="EKR.20040524104904.254">At this point I could read and write external files "by hand", using temporary
Read and Write commands. The next step was to integrate the reading and writing
of external files with the loading and saving of .leo files. From time to time I
made minor changes to the drivers for the read/write code to accommodate the
Load and Save code, but at no time did I significantly alter the read or write
code itself.

The user interaction of the Load and Save commands drove the design and
implementation of the load/store code. The most important questions were: "what
do we tell the user?", and "what does the user do with the information?" It
turns out that the user can't make any complex decision during error recovery
because the user doesn't have nearly enough information to make an informed
choice. In turn, this means that certain kinds of error recovery schemes are out
of the question...</t>
<t tx="EKR.20040524104904.255">I now turned my attention to "attributes" of nodes. Most attributes, like user
marks, are non-essential. However, clone information is essential; we must never
lose clone links. At this time I had a preliminary design for cross-file clones
that involved a two part "pointer" consisting of a full path name and an
immutable clone index within the external file. Eventually such pointers
completely disappeared, but the immutable clone indices remain.

My first thought was that it would be good to store all attributes in @node
sentinels in the external file, but experience showed that would be irritating.
Indeed, one wants Leo2 to rewrite external files only if something essential has
changed. For example, one doesn't want to rewrite the external file just because
a different node as been selected.

At this point I had another Aha: we can use the .leo file to store all
non-essential attributes. For example, this means that the .leo file, not the
external files, will change if we select a new node. In effect, the .leo file
mirrors the external file. The only reason to store nodes in the .leo file under
an @file node is to carry these attributes, so Leo2 wrote dummy nodes that do
not reference body text. Much later I saw that dummy nodes were dangerous and
that .leo files should contain all information found in external files.</t>
<t tx="EKR.20040524104904.256">The concept of mirroring created a huge breakthrough with cross-file clones:
Here is an excerpt of an email i sent to my brother Speed:

"I realized this morning that since a .leo file contains dummy vnodes for all
nodes in a external file, those dummy nodes can carry clone info! I changed one
line to make sure that the write code always writes clone info in dummy vnodes
and voila! Cross-file clones worked!"

All of Leo1's clone code could be used completely unchanged. Everything "just
works".</t>
<t tx="EKR.20040524104904.257">At first I thought we could make sure that the .leo file always correctly
mirrors all external file, but disastrous experience showed that is a completely
false hope. Indeed, backup .leo files will almost never mirror external file
correctly. So it became urgent to find a completely fool-proof error recovery
scheme.

I had known for quite a while that error recovery should work "as if" the
mirroring nodes were deleted, then recreated afresh. Several failed attempts at
an error recovery scheme convinced me that error recovery would actually have to
delete all dummy nodes and then do a complete reread. This is what Leo2 does.

But erasing dummy nodes would destroy any orphan and ignored nodes--by
definition such nodes appear nowhere in the external file. Therefore, I had to
enforce the rule that @file nodes should contain no such nodes. Here is an email
I wrote to my brother, Speed Ream discussing what turned out to be the
penultimate error recovery scheme:

"The error recovery saga continues. After much pondering and some trial coding I
have changed my mind about orphans and @ignored nodes. They simply should never
appear as descendants of @file nodes. Fortunately, this simplifies all aspects
of Leo2. Leo2 will issue a warning (not an error) if an orphan or @ignored node
appears as the descendant of an @file node when a .leo file is being saved. If
any warnings occur while writing the external file, Leo2 will write the
"offending" @file tree to the .leo file instead of the external file. This has
several advantages:

1. The user gets warned about orphan nodes. These are useful warnings! Orphan
nodes arise from missing @others directives or missing section references.

2. The user doesn't have to change anything immediately in order to save an
outline. This is very important. Besides warnings about orphans, Leo2 will also
warn about undefined or unreferenced sections. User's shouldn't have to fix
these warnings to do a Save!

3. No errors or alerts will occur during Reading or Writing, so the user's
anxiety level goes way down. At worst, some informational message will be sent
to the log. The user will never have to make important decisions during Loads or
Saves. [At last the dubious distinction between errors and warnings disappears.]

4. Error recovery can be bullet-proof. Simple code will guarantee that after any
read operation the structure of an @file node will match the structure of the
external file. Also, sentinels in external files will now account for all children
of an @file node. There are no more "missing nodes" that must be filled in using
the .leo file. Finally, error recovery will never change the @file tree in any
way: no more "recovered nodes" nodes.

5. The present read code can be used almost unchanged. The only addition is the
posting of a warning if the structure of the .leo file does not match the
structure of the external file. We need a warning because non-essential attribute
of nodes (like user marks) may be altered."

This ends the original history of Leo2. In fact, it took quite a while before
Leo recovered properly from all errors. I finally saw that .leo files should
duplicate all information in external files. This allows a .leo file to be used a
single backup file and allows maximal error recovery in all situations. It took
several months to stamp out several subtle bugs involving clones that caused
spurious read errors. Such errors undermine confidence in Leo and can cause
disastrous reversions. See my diary entries for January 2002 in leo.py for
details.</t>
<t tx="EKR.20040524104904.259">The more I look at Tk, the more convinced I am that Python + Tk (aka Tkinter)
is, by far, the best way to go with Leo. I now have Open Source code for tree
widgets and splitter windows, and have intensely studied how to modify that code
for use in Leo. It is clear, even at this early date, that this code will
provide a very pleasant base on which to build Leo.

The tree code is based on code in IDLE, the Python IDE. This code is simple,
good and plenty fast enough. The tree code draws directly to a Tk canvas object.
The look and feel matches Windows exactly. It would be trivial to use Mac
triangle icons instead of the Windows plus and minus icons. It would also be
trivial to modify the look and feel for Linux.

The tree widget code solves several intractable problems with wxTreeCtrl.
Moving nodes becomes trivial. Bugs in wxTreeCtrl involving editing and
redrawing disappear. Using Python/Tk code simplifies the vnode class, and having
access to the vnode class simplifies and speeds up the tree widget code. It will
now be possible to bind keystrokes properly; this simply can not be done in
wxWindows. The tree widget code shows just how trivial the Windows native
tree control is. The Tk canvas is a splendid example of higher-level code being
superior, in every way, to lower level code.

Another big win comes from using the Tk text widget. This widget is
extraordinarily powerful. The only text control that rivals it is the
MacOS/Yellow Box text control. Indeed, the Tk text widget does everything that
Leo could possibly want. One can even embed images in text.

In short, using Tk for Leo will be fast enough and will greatly increase what is
possible in Leo while at the same time greatly simplifying Leo's code. I am
about to convert Leo from wxPython to Python + Tk.
Edward K. Ream, November 4, 2001</t>
<t tx="EKR.20040524104904.26">@language rest</t>
<t tx="EKR.20040524104904.260">I've known for a while that Python was interesting; I attended a Python
conference last year and added Python support to Leo. But last week I got that
Python is something truly remarkable. I wanted to convert Leo from wxWindows to
wxPython, so I began work on c2py, a Python script that would help convert from
C++ syntax to Python. While doing so, I had an Aha experience. Python is more
than an incremental improvement over Smalltalk or C++ or objective-C; it is
"something completely different". The rest of this post tries to explain this
difference.
</t>
<t tx="EKR.20040524104904.261">@language rest</t>
<t tx="EKR.20040524104904.262">All versions of Leo are organized as a collection of classes. The general
organization of Leo has remained remarkably stable throughout all versions of
Leo, although the names of classes are different in different versions.
Smalltalk's Model/View/Controller terminology is a good way think about Leo's
classes. **Model classes** represent the fundamental data. The vnode and tnode
classes are Leo's primary model classes.

**View classes** draw the screen. The main view classes are leoFrame.py and
leoTree.py. The colorizer class in leoColor.py handles syntax coloring in the
body pane. Leo's view classes know about data stored in the vnode class. Most
events (keystrokes and mouse actions) in the outline and body pane are handled
in the leoTree class. The leoFrame class also creates the Leo window, including
menus, and dispatches the appropriate members of the controller classes in
response to menu commands.

**Controller classes** (aka commanders) control the application. In Leo,
controllers mostly handle menu commands. Commanders create subcommanders to
handle complex commands. The atFile class reads and writes files derived from
\@file trees. The LeoFind class handles the Find and Change commands. The
leoImportCommands class handles the Import and Export commands, the
tangleCommands class handles the Tangle and Untangle commands and the undoer
class handles the Undo command. Other classes could be considered controller
classes.

Each Leo window has its own commander and subcommanders. Subcommanders are not
subclasses of their commander. Instead, subcommanders know the commander that
created them, and call that commander as needed. Commanders and subcommanders
call the model and view classes as needed. For example, the Commands class
handles outline commands. To move a headline, the commander for the window calls
a vnode move routine to alter the data, then calls the view class to redraw the
screen based on the new data.

A singleton instance of the **LeoApp** class represents the application itself.
All code uses the app() global function to gain access to this singleton member.
The ivars of the LeoApp object are the equivalent of Leo's global variables.
leo.py uses no global Python variables, except the gApp variable returned by
app(). leoGlobals.py defines all application constants. Naturally, most
constants are local to the class that uses them.

Several classes combine aspects of model, view and controller. For example, the
**LeoPrefs** class represents user preferences (model), the Preference Panel
(view) and the Preferences menu command (controller). Similarly, the **LeoFind**
class represents find settings, the Find/Change dialog, and the Find/Change
commands.

We use the following convention throughout this documentation. Any variable
named c is a commander, i.e., an instance of the Commands class in
leoCommands.py. Variables named v and t are vnodes and tnodes respectively.
These classes are defined in leoNodes.py.</t>
<t tx="EKR.20040524104904.263">The vnode and tnode classes represent most of the data contained in the outline.
These classes are Leo's fundamental Model classes. A **vnode** (visual node)
represents a headline at a particular location on the screen. When a headline is
cloned, vnodes must be copied. vnodes persist even if they are not drawn on the
screen. Commanders call vnode routines to insert, delete and move headlines.

The vnode contains data associated with a headline, except the body text data
which is contained in tnodes. A vnode contains headline text, a link to its
tnode and other information. Vnodes contain structure links: parent, firstChild,
next and back ivars. To insert, delete, move or clone a vnode the vnode class
just alters those links. The Commands class calls the **leoTree** class to redraw
the outline pane whenever it changes. The leoTree class knows about these
structure links; in effect, the leoTree and vnode classes work together.

A **tnode**, (text node) represents body text. All vnodes that are clones of
each other share the same tnode. In other words, tnodes are the unit of sharing
of body text. The tnode class is more private than the vnode class. Most
commanders deal only with vnodes, though there are exceptions.

Because Leo has unlimited Undo commands, Leo deletes vnodes and tnodes only when
a window closes. Leo deletes nodes indirectly using destroy methods. Several
classes, including the vnode, tnode, leoFrame and leoTree classes, have
destroy methods. destroy methods merely clear links so that Python's and
Tkinter's reference counting mechanisms will eventually delete vnodes, tnodes
and other data when a window closes.

Leo's XML file format uses **tnode indices** to indicate which tnodes (t
elements) belong to which vnodes (v elements). Such indices are required. Even
if we duplicated the body text of shared tnodes within the file, the file format
would still need an unambiguous way to denote that tnodes are shared. Present
versions of Leo use **gnx's** (global node indices) as node indices. These indices
do not change once a node has created. This reduces cvs conflicts.</t>
<t tx="EKR.20040524104904.264">Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.
The main challenges are eliminating flicker and handling events properly.
These topics are interrelated.

**Eliminating flicker**. Leo must update the outline pane with minimum flicker.
Various versions of Leo have approached this problem in different ways. The
drawing code in leo.py is robust, flexible, relatively simple and should work in
almost any conceivable environment. Leo assumes that all code that changes the
outline pane will be enclosed in matching calls to the c.beginUpdate and
c.endUpdate methods of the Commands class. c.beginUpdate() inhibits drawing
until the matching c.endUpdate(). These calls may be nested; only the outermost
call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.

Code may call c.endUpdate(flag) instead of c.endUpdate(). Leo redraws
the screen only if flag is true. This allows code to suppress redrawing entirely
when needed. For example, here is how the idle_body_key event handler in
leoTree.py conditionally redraws the outline pane::

	redraw_flag = false
  	c.beginUpdate()
	val = v.computeIcon()
	if val != v.iconVal:
		v.iconVal = val
		redraw_flag = true
	c.endUpdate(redraw_flag) # redraw only if necessary

The leoTree class redraws all icons automatically when c.redraw() is called.
This is a major simplification compared to previous versions of Leo. The entire
machinery of drawing icons in the vnode class has been eliminated. The
v.computeIcon method tells what the icon should be. The v.iconVal ivar
tells what the present icon is. The event handler simply compares these two
values and sets redraw_flag if they don't match.

**Handling events.** Besides redrawing the screen, Leo must handle events or
commands that change the text in the outline or body panes. It is surprisingly
difficult to ensure that headline and body text corresponds to the vnode and
tnode corresponding to presently selected outline, and vice versa. For example,
when the user selects a new headline in the outline pane, we must ensure that 1)
the vnode and tnode of the previously selected node have up-to-date information
and 2) the body pane is loaded from the correct data in the corresponding tnode.
Early versions of Leo attempted to satisfy these conditions when the user
switched outline nodes. Such attempts never worked well; there were too many
special cases. Later versions of Leo, including leo.py, use a much more direct
approach. The event handlers make sure that the vnode and tnode corresponding to
the presently selected node are always kept up-to-date. In particular, every
keystroke in the body pane causes the presently selected tnode to be updated
immediately. There is no longer any need for the c.synchVnode method, though
that method still exists for compatibility with old scripts.

The leoTree class contains all the event handlers for the body and outline
panes. The actual work is done in the idle_head_key and idle_body_key methods.
These routines are surprisingly complex; they must handle all the tasks
mentioned above, as well as others. The idle_head_key and idle_body_key methods
should not be called outside the leoTree class. However, it often happens that
code that handles user commands must simulate an event. That is, the code needs
to indicate that headline or body text has changed so that the screen may be
redrawn properly. The leoTree class defines the following simplified event
handlers: onBodyChanged, onBodyWillChange, onBodyKey, onHeadChanged and
onHeadlineKey. Commanders and subcommanders call these event handlers to
indicate that a command has changed, or will change, the headline or body text.
Calling event handlers rather than c.beginUpdate and c.endUpdate ensures that
the outline pane is redrawn only when needed.</t>
<t tx="EKR.20040524104904.265">New in Leo 4.7. All clones of a node **are the same node**. This is the
so-called **one-node** world. In this world, vnodes represent data, generators
and positions represent the location of the data in an outline.  This is a much
simpler world than all previous data representations.

In Leo versions 4.2 to 4.6 clones were represented by sharing **tnodes**. Cloned
vnodes shared the same tnode. This shared tnode represented the entire shared
subtree of both clones. Thus, the _firstChild link had to reside in
*tnodes*, not *vnodes*.

Prior to Leo version 4.2, Leo duplicated all the descendants of vnode v when
cloning v. This created many complications that were removed in the shared tnode
world. In particular, in the shared tnode scheme a vnode v is cloned if and only
if len(v.vnodeList) &gt; 1.</t>
<t tx="EKR.20040524104904.266">The find and change commands are tricky; there are many details that must be
handled properly. The following principles govern the LeoFind class:

1.  Find and Change commands initialize themselves using only the state of the
    present Leo window. In particular, the Find class must not save internal
    state information from one invocation to the next. This means that when the
    user changes the nodes, or selects new text in headline or body text, those
    changes will affect the next invocation of any Find or Change command.
    Failure to follow this principle caused all kinds of problems in the Borland
    and Macintosh codes. There is one exception to this rule: we must remember
    where interactive wrapped searches start. This principle simplifies the code
    because most ivars do not persist. However, each command must ensure that
    the Leo window is left in a state suitable for restarting the incremental
    (interactive) Find and Change commands. Details of initialization are
    discussed below.

2.  The Find and Change commands must not change the state of the outline or body
    pane during execution. That would cause severe flashing and slow down the
    commands a great deal. In particular, the c.selectPosition and c.editPosition
    methods must not be called while looking for matches.

3.  When incremental Find or Change commands succeed they must leave the Leo
    window in the proper state to execute another incremental command. We
    restore the Leo window as it was on entry whenever an incremental search
    fails and after any Find All and Change All command. Initialization involves
    setting the self.c, self.v, self.in_headline, self.wrapping and
    self.s_text ivars.

Setting self.in_headline is tricky; we must be sure to retain the state of
the outline pane until initialization is complete. Initializing the Find All and
Change All commands is much easier because such initialization does not depend
on the state of the Leo window. Using Tk.Text widgets for both headlines and
body text results in a huge simplification of the code.

Indeed, the searching code does not know whether it is searching headline or
body text. The search code knows only that self.s_text is a Tk.Text widget that
contains the text to be searched or changed and the insert and sel Tk attributes
of self.search_text indicate the range of text to be searched. Searching
headline and body text simultaneously is complicated. The selectNextVnode()
method handles the many details involved by setting self.s_text and its insert
and sel attributes.</t>
<t tx="EKR.20040524104904.267">This section describes Leo's explicit Tangle and Untangle commands. Such
commands operate only on @root and @unit trees. The previous chapter discusses
the implicit Tangle on Write/Untangle on Read processes used to read and write
@file trees.

The Tangle command translates the selected @root tree into one or more
well-formatted C source files. The outline should contain directives, sections
references and section definitions, as described in Chapter 4. The Untangle
command is essentially the reverse of the Tangle command. The Tangle command
creates a external file from an @root tree; the Untangle command incorporates
changes made to external files back into the @root tree.

The Tangle command operates in two passes. The first pass discovers the complete
definitions of all sections and places these definitions in a symbol table. The
first pass also makes a list of root sections. Definitions can appear in any
order, so we must scan the entire input file to know whether any particular
definition has been completed.

This second pass creates one file for each @root node. Tangle rescans each
section in the list of roots, copying the root text to the output and replacing
each section reference by the section's definition. This is a recursive process
because any definition may contain other references. We can not allow a section
to be defined in terms of itself, either directly or indirectly. We check for
such illegally recursive definitions in pass 2 using the section stack class.
Tangle indicates where sections begin and end using comment lines called
sentinel lines. The this part of the appendix discusses the format of the
sentinels output by the Tangle command.

The key design principle of the Tangle command is this::

    Tangle must output newlines in a context-free manner.

That is, Tangle must never output conditional newlines, either directly or
indirectly. Without this rule Untangle could not determine whether to skip or
copy newlines.

The Tangle command increases the indentation level of a section expansion the
minimum necessary to align the section expansion with the surrounding code. In
essence, this scheme aligns all section expansions with the line of code in
which the reference to the section occurs. In some cases, several nested
sections expansions will have the same indentation level. This can occur, for
example, when a section reference in an outline occurs at the left margin of the
outline.

This scheme is probably better than more obvious schemes that indent more
"consistently." Such schemes would produce too much indentation for deeply
nested outlines. The present scheme is clear enough and avoids indentation
wherever possible, yet indents sections adequately. End sentinel lines make this
scheme work by making clear where the expansion of one section ends and the
expansion of a containing section resumes.

Tangle increases indentation if the section reference does not start a line.
Untangle is aware of this hack and adjusts accordingly. This extra indentation
handles several common code idioms, which otherwise would create under-indented
code. In short, Tangle produces highly readable output, given the necessity
of preserving newlines for Untangle.

Untangle is inherently complex. It must do a perfect job of updating the
outline, especially whitespace, from expansions of section definitions created
by the Tangle command. Such expansions need not be identical because they may
have been generated at different levels of indentation. The Untangle command
can not assume that all expansions of a section will be identical in the derived
file; within the external file, the programmer may have made incompatible changes
to two different expansions of the same section. Untangle must check to see
that all expansions of a section are "equivalent". As an added complication,
external files do not contain all the information found in @root trees.
@root trees may contain headlines that generate no code at all. Also, an
outline may define a section in several ways: with an @c or @code
directive or with a section definition line. To be useful, Untangle must handle
all these complications flawlessly. The this part of the appendix discusses the
various conventions used in the sentinels output by the Tangle command.
These conventions allow the Untangle command to recreate whitespace
correctly.

Untangle operates in two passes. The first pass finds definitions in the
external file and enters them into the **Untangle Symbol Table**, or UST.
Definitions often include references to other sections, so definitions often
include nested definitions of referenced sections. The first pass uses a
definition stack to keep track of nested definitions. The top of the stack
represents the definition following the latest reference, except for the very
first entry pushed on the stack, which represents the code in the outline that
contains the @root directive. The stack never becomes empty because of the
entry for the @root section. All definitions of a section should
match--otherwise there is an inconsistent definition. This pass uses a forgiving
compare routine that ignores differences that do not affect the meaning of a
program.

The second pass of Untangle enters definitions from the outline into the
**Tangle Symbol Table**, or TST. The second pass simultaneously updates all
sections in the outline whose definition in the TST does not match the
definition in the UST. The central coding insight of the Untangle command is
this:  **the second pass of Untangle is almost identical to the first pass of
Tangle**. That is, Tangle and Untangle share key parts of code, namely the
skip_body method and its allies. Just when skip_body enters a definition
into the symbol table, all the information is present that Untangle needs to
update that definition.</t>
<t tx="EKR.20040524104904.268">Leo uses unicode objects in vnodes and tnodes to denote headline and body text.
Note that unicode strings have no encoding; only plain strings have encodings.
This means that once an (encoded) plain string has been converted to a unicode
string it doesn't matter how the unicode string was created. This is the key
that makes Leo's new code robust: internally Leo never has to worry about
encodings. Encoding matter only when encoded strings are converted to and from
Unicode. This happens when Leo reads or writes files.

Python expressions that mix unicode strings u and plain strings s, like one of these::

	u + s
	u == s
	u[5] == s[2:]

are promoted to unicode objects using the "system encoding". This encoding
should never be changed, but we can't assume that we know what it is, so for
safety we should assume the most restrictive encoding, namely "ascii". With this
assumption, Leo's code can't throw an exception during these promotions provided
that: 

- All strings are converted to unicode when Leo reads files or gets text from Tk.Text widgets.

- All string literals in Leo's code have only ascii characters.</t>
<t tx="EKR.20040524104904.269">Unlimited undo is straightforward; it merely requires that all commands that
affect the outline or body text must be undoable. In other words, everything
that affects the outline or body text must be remembered. We may think of all
the actions that may be Undone or Redone as a string of beads (undo nodes).

Undoing an operation moves backwards to the next bead; redoing an operation moves
forwards to the next bead. A bead pointer points to the present bead. The bead
pointer points in front of the first bead when Undo is disabled. The bead
pointer points at the last bead when Redo is disabled. An undo node is a Python
dictionary containing all information needed to undo or redo the operation. The
Undo command uses the present bead to undo the action, then moves the bead
pointer backwards.

The Redo command uses the bead after the present bead to redo the action, then
moves the bead pointer forwards. All undoable operations call setUndoParams() to
create a new bead. The list of beads does not branch; all undoable operations
(except the Undo and Redo commands themselves) delete any beads following the
newly created bead. I did not invent this model of unlimited undo.
I first came across it in the documentation for Apple's Yellow Box classes.</t>
<t tx="EKR.20040524104904.27">A cloned node is a copy of a node that changes when the original
changes. One may also think of it as a single node that is hooked into
the outline at multiple positions.  Because that single node brings
along all its descendants, changes are maintained across all the the
clones of a node, along with changes to its offspring (children,
grandchildren, etc.), i.e., any changes are simultaneously made to the
corresponding offspring of all of those clones.  A small red arrow in
the icon box marks cloned nodes.  You can think of the arrow as
pointing out that there are other paths to get to this same node.
There is no real distinction between the "original" node and any of
its clones.  Any headline or body update of a clone headed subtree
affects all of its clones simultaneously.  A cloned node becomes a
regular node whenever deletion of its other clones makes it the only
one left. Clones are useful for making alternate views of a program.
See `Clones and views`_ for full details.

The command ``clone-node``, (Clone Node in the Outline menu, bound to Control-`) creates a clone as the immediate sibling of a selected node.
You have to place it where you want it by either using move
commands, or cutting and paste the clone.
</t>
<t tx="EKR.20040524104904.274">@language rest</t>
<t tx="EKR.20040524104904.282">To convert an \@root tree to an @file tree, choose the root of the tree to be
converted, then do the following in the Python window::

	import c2py
	c2py.leo1to2()

This script makes numerous changes throughout the tree. It does not, however,
change @root to @file, or insert the needed @others directives. You must do that
by hand.

To convert @root trees to @file trees by hand:

1. Change the @root node to an @file node. That is, delete the @root &lt;filename&gt;
    from the body text and insert @file &lt;filename&gt; in the headline. Typically,
    the root node contains a reference like &lt;&lt;methods of class x&gt;&gt; as the last
    body text. Replace this reference with the @others directive. The expansion
    of @others is all text that is not part of a section definition.

2. Add @ to the start of all doc parts. Leo starts syntax coloring in code mode
   rather than doc mode, so if a doc part starts body text it should start with
   an '@' sign.
   
3. Replace all section definition lines (like &lt;&lt;name&gt;&gt;=) by @c. This results in
   the node being added to the expansion of @others.

4. Remove all unused code from the @file tree. Leo does not write external files
   whose @file trees contain orphan or @ignore nodes.

5. Make sure that all nodes defining a section have a headline that starts with
   &lt;&lt;section&gt;&gt;. This will typically be true when converting @root trees that use
   the @code directive.

6. If a section is referenced in more than one node (a rare occurrence in my
    code), clone the defining node and move one clone under each referencing
    node.

7. If a node contains the definitions of several sections, place each different
   definition in a different node.
</t>
<t tx="EKR.20040524104904.307">The following error messages may be generated by the Tangle commands.

Can not re-open temp file
    A file error occurred while trying to reopen the temporary file used during tangling.

Can not rename temporary file name
    A file error occurred while trying to change the name of the temporary file used during tangling.

@code expects the header: [text of header] to contain a section name
    An @code directive appeared in body text whose header does not contain a section name.

@directive not valid here
    An @directive was seen somewhere other than the start of a line.

Halting Tangle: too many errors
    Tangle detected more than 20 errors.

Invalid recursive reference of &lt;&lt; section name &gt;&gt;
    A section was defined in terms of itself, either directly or indirectly.
    The trace shows the chain of section definitions that resulted in the illegal definition.

This message is followed by a walkback of the section names that recursively reference the section.
    The walkback looks like this::

        called from &lt;&lt; section name &gt;&gt;
        called from &lt;&lt; section name &gt;&gt;
        ...

Multiple parts not allowed for &lt;&lt; section name &gt;&gt;
    Sections can be defined in several parts in two ways:

    1.  Using &lt;&lt; section name &gt;&gt;= in several places with the same section name.

    2.  Using several @code directives within the same body text.

    As a precaution against mistakenly defining a section in more than one place,
    it is invalid to use @code in different nodes to define multiple parts for the same section.
    In particular, this error may arise when using cloned nodes.
    This error may always be eliminated by using &lt;&lt; section name &gt;&gt;= instead of @code.

No file written because of errors
    Tangle did not write a file because errors were found.

Run on comment
    A C-language comment was not properly terminated.

Run on file name in @root directive
    The file name in an @root directive was not terminated with the proper delimiter.

Run on section name
    A section name was not properly terminated before the end of the line in which it started.

Run on string
    A C-language string or character constant was not properly terminated.

Section definition not valid here.
    Something that looks like a section definition was seen in the middle of a line.

Sections nested too deeply
    A section was defined using more than 100 levels of section definitions (!)
    You could easily create an outline containing every computer program ever written in less than 50 levels.

The outline contains no roots
    The selected outline contained no @root directive.

Undefined section:  &lt;&lt;&lt; section name &gt;&gt;&gt;
    A reference to an undefined section was encountered.

Unexpected @directive while putting code
    Tangle outputs 2-character WEB control code in a comment.
    This message is given if we find such comments in a code definition.

Warning: possible duplicate definition of: &lt;&lt;&lt; section name &gt;&gt;&gt;
    (The text of the duplicate definition follows.)
    The section may have been defined in more than one place.

Warning: &lt;&lt;&lt; section name &gt;&gt;&gt; has been defined but not used
    The indicated section appears in the outline but is never referenced.</t>
<t tx="EKR.20040524104904.327">The following error messages may be generated by the Untangle commands.

Incompatible definitions of &lt;&lt;&lt; section name &gt;&gt;&gt;
    Two expansions of &lt;&lt; section name &gt;&gt; were different in the external file.
    This typically arises when the programmer changes one of the expansions but not the other.

Missing root part
    No end sentinel line was found for a part of the expansion of the code in the @root node.
    This is likely the result of adding, deleting or altering a sentinel line.

Missing root section
    No end sentinel line was found for the expansion of the code in the @root node.
    This is likely the result of adding, deleting or altering a sentinel line.

Missing sentinel line for &lt;&lt;&lt; section name &gt;&gt;&gt;
    The end sentinel name for &lt;&lt; section name &gt;&gt; was expected but not found.
    This is likely the result of adding, deleting or altering a sentinel line.

Unterminated section: &lt;&lt;&lt; section name &gt;&gt;&gt;
    The end of the file was reached before encountering the end sentinel line for &lt;&lt; section name &gt;&gt;.
    This is likely the result of adding, deleting or altering a sentinel line.
</t>
<t tx="EKR.20040524104904.333">The following are all serious errors, meaning that the data in a external file has been corrupted::

    Bad @+leosentinel in &lt;filename&gt;
    Bad @delims
    Bad attribute field in @+node
    Bad child index in @+node
    File may have damaged sentinels!
    Ignoring &lt;sentinel kind&gt; sentinel.  Expecting &lt;sentinel kind&gt;
    Ignoring unexpected @+leo sentinel
    Missing &lt;sentinel kind&gt; sentinel
    Missing @file in root @node sentinel
    Outline corrupted: different nodes have same clone index!
    Replacing body text of orphan &lt;node name&gt;
    Unexpected end of file. Expecting &lt;sentinel kind&gt; sentinel
    Unknown sentinel: &lt;sentinel line&gt;

You should restore the information from a backup .leo file using the Read Outline Only commands,
followed by a Write @file Nodes command</t>
<t tx="EKR.20040524104904.336">Errors while writing @file nodes are harmless.
No information is lost because all information is written to the .leo file rather than the external file.

bad @delims directive
    A node contains an ill-formed @delims directive.

@ignore node &lt;headline&gt;
    The body text of *headline* contains an @ignore directive.

orphan node: &lt;headline&gt;
    The node is referenced by no ancestor node, and no @others directive applies to it.

@others already expanded in: &lt;headline&gt;
    The node contains more than one @others directive.

Rename failed: no file created! (file may be read-only)
    Leo's Save command writes external files to a temporary file,
    and replaces the external file by the temporary files only if the two files are different.
    A problem with the file system prevented the temporary file from being renamed.

Path does not exist: &lt;filename&gt;

undefined section: &lt;section name&gt; referenced from: &lt;headline&gt;
    The node given by *headline* contains a reference to *section name*
    but no section definition node for *section name* exists in the descendants of *headline*.</t>
<t tx="EKR.20040524104904.351">The following bugs can not be fixed:

1.  The Untangle command has no way of updating a section whose name has been changed in the external file.

    Because of the @unit directive, there is not even a way to issue a meaningful warning.

2.  The Tangle command treats @c like @code in CWEB mode.

    I recommend changing @c to @&lt; c @&gt;= throughout your CWEB sources
    and adding a reference to @&lt; c @&gt; in all roots of CWEB files.</t>
<t tx="EKR.20040524104904.354">Leo uses unicode internally for all strings.

1.  Leo converts headline and body text to unicode when reading .leo files and external files.
    Both .leo files and external files may specify their encoding.  The default is utf-8.
    If the encoding used in a external file is not "utf-8" it is represented in the @+leo sentinel line.
    For example::

        #@+leo-encoding=iso-8859-1.

    The utf-8 encoding is a "lossless" encoding (it can represent all unicode code points),
    so converting to and from utf-8 plain strings will never cause a problem.
    When reading or writing a character not in a "lossy" encoding,
    Leo converts such characters to '?' and issues a warning. 

2.  When writing .leo files and external files Leo uses the same encoding used to read the file,
    again with utf-8 used as a default.

3.  leoSettings.leo contains the following Unicode settings, with the defaults as shown::

        default_derived_file_encoding = UTF-8 
        new_leo_file_encoding = UTF-8 

    These control the default encodings used when writing external files and .leo files.
    Changing the new_leo_file_encoding setting is not recommended.
    See the comments in leoSettings.leo.
    You may set default_derived_file_encoding to anything that makes sense for you.

4.  The @encoding directive specifies the encoding used in a external file.
    You can't mix encodings in a single external file.</t>
<t tx="EKR.20040524104904.357">This technical information may be of use to those wanting to process Leo files with special-purpose filters.
Leo's uses XML for its file format.
The following sections describe this format in detail.
**Important**:
The actual read/write code in leoFileCommands.py is the authoritative guide.
When in doubt about what Leo actually writes, look at an actual .leo file in another editor.

Here are the elements that may appear in Leo files.
These elements must appear in this order.

&lt;?xml&gt;
    Leo files start with the following line::

        &lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;?xml-stylesheet&gt;
    An xml-stylesheet line is option.  For example::

        &lt;?xml-stylesheet ekr_stylesheet?&gt;

&lt;leo_file&gt;
    The &lt;leo_file&gt; element opens an element that contains the entire file.
    &lt;/leo_file&gt; ends the file.

&lt;leo_header&gt; 
    The &lt;leo_header&gt; element specifies version information and other information
    that affects how Leo parses the file.  For example::

        &lt;leo_header file_format="2" tnodes="0" max_tnode_index="5725" clone_windows="0"/&gt;

    The file_format attribute gives the 'major' format number.
    It is '2' for all 4.x versions of Leo.
    The tnodes and clone_windows attributes are no longer used.
    The max_tnode_index	attribute is the largest tnode index.

&lt;globals&gt;
    The globals element specifies information relating to the entire file.
    For example::

        &lt;globals body_outline_ratio="0.50"&gt;
            &lt;global_window_position top="27" left="27" height="472" width="571"/&gt;
            &lt;global_log_window_position top="183" left="446" height="397" width="534"/&gt;
        &lt;/globals&gt;

    -   The body_outline_ratio attribute specifies the ratio of the height of the body pane to
        the total height of the Leo window.
        It initializes the position of the splitter separating the outline pane from the body pane.

    -   The global_window_position and global_log_window_position elements
        specify the position of the Leo window and Log window in global coordinates:

&lt;preferences&gt;
    This element is vestigial.
    Leo ignores the &lt;preferences&gt; element when reading.
    Leo writes an empty &lt;preferences&gt; element.

&lt;find_panel_settings&gt;
    This element is vestigial.
    Leo ignores the &lt;find_panel_settings&gt; element when reading.
    Leo writes an empty &lt;find_panel_settings&gt; element.

&lt;clone_windows&gt;
    This element is vestigial.
    Leo ignores the &lt;clone_windows&gt; element when reading.
    Leo no longer writes &lt;clone_windows&gt; elements.

&lt;vnodes&gt;
    A single &lt;vnodes&gt; element contains nested &lt;v&gt; elements.
    &lt;v&gt; elements correspond to vnodes.
    The nesting of &lt;v&gt; elements indicates outline structure in the obvious way.

&lt;v&gt;
    The &lt;v&gt; element represents a single vnode and has the following form::

        &lt;v...&gt;&lt;vh&gt;sss&lt;/vh&gt; (zero or more nested v elements) &lt;/v&gt;

    The &lt;vh&gt; element specifies the headline text.
    sss is the headline text encoded with the usual XML escapes.
    As shown above, a &lt;v&gt; element may contain nested &lt;v&gt; elements.
    This nesting indicates outline structure in the obvious way.
    Zero or more of the following attributes may appear in &lt;v&gt; elements::

        t=name.timestamp.n
        a="xxx"

    The t="Tnnn" attribute specifies the tnode associated with this vnode.
    The a="xxx" attribute specifies vnode attributes.
    The xxx denotes one or more upper-case letters whose meanings are as follows::

        C	The vnode is a clone. (Not used in 4.x)
        E	The vnode is expanded so its children are visible.
        M	The vnode is marked.
        T	The vnode is the top visible node.
        V	The vnode is the current vnode.

    For example, a="EM"  specifies that the vnode is expanded and is marked.

    **New in 4.0**:

    -   &lt;v&gt; elements corresponding to @file nodes now contain tnodeList attributes.
        The tnodeList attribute allows Leo to recreate the order in which nodes should appear in the outline.
        The tnodeList attribute is a list of gnx's: global node indices.
        See Format of external files (4.x) for the format of gnx's.

    -   Plugins and scripts may add attributes to &lt;v&gt; and &lt;t&gt; elements.
        See `Chapter 13: Writing plugins`_ for details.

&lt;tnodes&gt;
    A single &lt;tnodes&gt; element contains a non-nested list of &lt;t&gt; elements.

&lt;t&gt;
    The &lt;t&gt; element represents a single tnode and has this form::

        &lt;t tx="Tnnn"&gt;&lt;tb&gt;sss&lt;/tb&gt;&lt;/t&gt;

    The tx attribute is required.
    The t attribute of &lt;v&gt; elements refer to this tx attribute.
    The &lt;tb&gt; element specifies the body text.
    sss is the headline text encoded with the usual XML escapes.

    **New in 4.0**:
    Plugins and scripts may add attributes to &lt;v&gt; and &lt;t&gt; elements.
    See `Chapter 13: Writing plugins`_ for details.
</t>
<t tx="EKR.20040524104904.36">The ``insert-node`` command inserts a new node into the outline; it is bound to Control-I and the Insert key. When invoked, (from any pane),
it inserts a new node below the presently selected node, and at the
same level as that node, or at the child level if it has a child
vissible.  The
``delete-node`` command deletes a node and all its children; it is initially unbound.
 If you want to retain the children you must
promote all the children before you do the delete. </t>
<t tx="EKR.20040524104904.37">The ``cut-node``, ``paste-node``, ``copy-node`` and ``delete-node`` commands work on
nodes rather than text. For example, to delete a node, select the node and
choose the Cut Outline or Delete Outline command in the menu, use Alt-X to invoke the command in the mini-buffer, or use Control-Shift-X (which cuts the node; delete node is not bound). The ``cut-node`` and ``copy-node`` commands copy a text representation of the outline to the clipboard.
This representation is the same as Leo's .leo file format with some information
deleted. You may copy this text representation into a body pane (or into any
other text editor) using Edit-&gt;Paste in the menus, Ctrl-V, or Alt-X paste-text.

**Warning**: If you want to preserve the "cloned" attribute of a node, or want to paste the node as a clone of the node you cut or copied, use the ``past-retaining-clones`` command, which in the Outline menu is called "Paste Node as Clone".  The ``paste-node`` command instead creates a new, distinct version of the node you previously cut or copied, though if there were descendant nodes which were clones of each other, the new version will have parallel, distinct nodes that are also clones of each other (just not of the originals).  You may paste a node between .leo files, but there can be no clone relationship across files.

There are places to which you are prevented from ``paste-retaining-clones``, because it would cause a node to become a parent of itself, and thus cause outline traversals like ``@thin`` expansion to loop until they consumed all memory and crashed the program.  The Leo outline is thus mathematically a *directed acyclic graph*: clones make it more flexible than a tree, but not a generalized graph.
</t>
<t tx="EKR.20040524104904.38">In the Tk GUI, you may drag a node (including all its descendants) from one place to another
in an outline. To start a drag, press the main (left) mouse button while the
cursor is over the icon for a node. The cursor will change to a hand icon. If
you release the mouse button while the hand cursor is above the icon for another
node, Leo will move the dragged node after that node. If you release the mouse
button when the hand cursor is not over an icon, Leo will leave the outline pane
as it is. Leo scrolls the outline pane as the result of mouse-moved events, so
to continue scrolling you must keep moving the mouse.

This is not yet implemented in the (default) Qt GUI.
</t>
<t tx="EKR.20040524104904.380">@language rest</t>
<t tx="EKR.20040524104904.39">The default features of Leo's body text derive from the Tk.Text widget,
described at: http://www.tcl.tk/man/tcl8.3/TkCmd/text.htm Not all these features
are found on all platforms.
The following features are derived from the Tk Text widget. Some default
behaviors have been changed because they conflict with other Leo features.

-   Clicking mouse button 1 positions the insertion cursor just before the character
    underneath the mouse cursor, sets the input focus to this widget, and clears any
    selection in the widget. Dragging with mouse button 1 strokes out a selection
    between the insertion cursor and the character under the mouse. 

-   Double-clicking mouse button 1 selects the word under the mouse and
    positions the insertion cursor at the end of the word.

-   The ends of the selection can be adjusted by dragging with mouse button 1 while
    the Shift key is down; this will adjust the end of the selection that was
    nearest to the mouse cursor when button 1 was pressed. 

-   Tk GUI only: clicking mouse button 1 with the Control key down will reposition the insertion
    cursor without affecting the selection. 

-   If there is no selection, normal printing characters are inserted at the point of the insertion cursor. 

-   If there is a selection, normal printing characters replace the selection.

-   If the mouse is dragged out of the body pane while button 1 is pressed, the
    entry will automatically scroll to make more text visible.

-   Left Arrow and Right Arrow move the cursor one character to the left or right
    and clear any selection in the text.

-   Shift Left or Shift Right move the cursor and modify the selection.

-   Control-Left and Control-Right move the insertion cursor by words,
    and Control-Shift-Left and Control-Shift-Right move the insertion
    cursor by words and also extend the selection.

-   Up Arrow and Down Arrow move the insertion cursor one line up or down and
    clear any selection in the text. 

-   Shift Up and Shift Right move the cursor and extend the selection.

-   Control-Up and Control-Down move the insertion cursor by paragraphs.

-   Control-Shift-Up and Control-Shift-Down move the insertion cursor by
    paragraphs and extend the selection.
    
-   Next (Page Down) and Prior (Page Up) keys move the
    insertion cursor one screen and clear any text selection.

-   Shift Next and Shift Prior move the cursor one screen and extend the selection.

-   Line movement is by text lines terminated by hard returns (newlines), not by
    displayed lines; if a text line is long and wraps across more than one display
    line, then the Up and Down movement will skip the extra wrapped display lines.

-   Home moves the insertion cursor to the beginning of its line and clears any
    selection in the widget.

-   Shift-Home moves the insertion cursor to the beginning of the line and extends the selection. 

-   End moves the insertion cursor to the end of the line and clears any selection in
    the widget.

-   Shift-End moves the cursor to the end of the line and extends the selection. 

-   Control-Home moves the insertion cursor to the beginning of the text and clears
    any selection in the widget.

-   Control-Shift-Home moves the insertion cursor to the beginning of the text and extends the selection. 

-   Control-End moves the insertion cursor to the end of the text and clears any
    selection.

-   Control-Shift-End moves the cursor to the end of the text and extends the selection. 

-   Select and Control-Space set the selection anchor to the position of the
    insertion cursor. They don't affect the current selection.

-   Shift-Select and Control-Shift-Space adjust the selection to the current position of the
    insertion cursor, selecting from the anchor to the insertion cursor if there was
    no previous selection. 

-   F16  (Copy on many Sun workstations) or Control-c copies the
    selection in the widget to the clipboard, if there is a selection.

-   F20 (Cut on many Sun workstations) or Control-x copies the
    selection in the widget to the clipboard and deletes the selection.
    These keys have no effect if no text is selected.

-   F18 (Paste on many Sun workstations) or Control-v inserts the
    contents of the clipboard at the position of the insertion cursor.

-   Delete deletes the text selection, or the character to the right of the cursor
    if there is no text selection.

-   Backspace deletes the selection, or the character to the left of the cursor
    if there is no text selection.</t>
<t tx="EKR.20040524104904.40">You can expand or contract a node by clicking in the tree
view icon to the left of the headline.  The icon in the Qt gui matches the native
OS's tree view icon, i.e. for Mac's, a triangle pointing right or
down; on Windows (also when using the Tk gui), a square containing a
plus or minus.  Expanding a node shows its immediate
children; contracting a node hides all its children.  The corresponding commands are ``expand-node`` and ``contract-node``.  For more convenient navigation, there are ``expand-and-go-right`` and ``contract-or-go-up`` which are bound to Alt-Right and Alt-Left.

The ``expand-all`` command expands every node in the outline.  ``contract-all`` contracts every node in the outline.  Both commands are availble in the Outline-&gt;Expand/Contract... submenu.  ``contract-all`` is bound to Atl-- (Alt modifying a single hyphen).  In all but the smallest outlines, ``expand-all`` is rarely used, and is does not have a key binding.



</t>
<t tx="EKR.20040524104904.41">Leo auto indents unless @nocolor is in effect.  Typing a newline
automatically inserts the same leading whitespace present on the previous line.

If Python is the present language, Leo inserts an additional tab if the previous
line ends with a colon.  When the smart_auto_indent setting is True, Leo uses Emacs-style
auto-indentation instead.  This style of auto-indent aligns newly created lines
with unmatched ( [ or { brackets in the previous line.
</t>
<t tx="EKR.20040524104904.43">You can mark nodes in several ways:

- With the Mark commands: ``mark``, ``mark-changed-items``, ``mark-changed-roots``, ``mark-subheads``.  These are found in the Outline-&gt;Mark... submenu; ``mark`` is bound to Control-M .

- With the Find or Change commands.  The "mark changes" and "mark finds" options are intially cleared; you can change them with the ``toggle-find-mark-changes-option`` and ``toggle-find-mark-finds-option`` commands.  Using those commands will put focus in the Find tab of the log pane.  When the Find tab is visible, Alt in combination with the underlined option character will put focus on that option, and then the space bar will toggle the option.  You can also change the options by clicking on them in the Find tab.

- With the ``untangle``, ``untangle-all`` and ``untangle-marked`` commands: nodes altered because of changes to external files get marked.  These commands are available in the File-&gt;Untangle... submenu.

The ``goto-next-marked`` command selects the next marked node, if any; it is available in the Outline-&gt;Go to... submenu.

The ``mark`` command unmarks the selected headline if it is already marked.</t>
<t tx="EKR.20040524104904.44">The ``move-outline-up``, ``move-outline-down``, ``move-outline-left``, and  ``move-outline-right`` commands move the currently
selected node. In the Outline-&gt;Move... menu, they're called Move Up, Move Down, Move Left and Move Right; they're bound to Control-U, Control-D, Control-L and Control R.  The ``promote`` command makes all the children of a node
siblings of the node. The ``demote`` command makes all following siblings of a
node children of the node.  These are also found in the Outline-&gt;Move... menu, and are bound to Control-Shift-[ and Control-Shift-] .

Nodes moved in the above manner retain any clone characteristics.  Moves are limited to retain the directed acyclic graph property.
</t>
<t tx="EKR.20040524104904.45">Double-clicking the icon box of a node whose headline has the form::

    @url &lt;any url&gt;

executes the URL in your default web browser.

Leo checks that the URL is valid before doing so. A valid URL is:

-   3 or more lowercase alphas
-   followed by one :
-   followed by one or more of:
-   ``$%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~``
-   followed by one of: ``$%&amp;'()*+/0-9:=?@A-Z_a-z}~`` (i.e., comma, hyphen and open curly brace may not be the last character)

URL's should contain no spaces: use %20 to indicate spaces. You may use any
type of URL that your browser supports: http, mailto, ftp, file, etc.
</t>
<t tx="EKR.20040524104904.47">You can change the relative sizes of the outline and body panes by dragging the
splitter bar. The ``equal-sized-panes`` (Window-&gt;Equal Sized Panes) command resizes the panes so that each
fills half of the main window.
</t>
<t tx="EKR.20040524104904.48">Leo supports unlimited undo for all typing and all commands. The
'undo_granularity' setting controls the granularity of undo. There are four
possible values:

node
    Starts a new undo unit when typing moves to a new node.

line (default)
    Starts a new undo unit when typing moves to new line.

word
    Starts a new undo unit when typing starts a new word.

char (not recommended)
    Starts a new undo unit for each character typed.
    This wastes lots of computer memory.

Internally, setUndoTypingParams() calls recognizeStartOfTypingWord() to recognize the
start of words. Plugins can modify recognizeStartOfTypingWord(). It should
return True if the typing indicated by the params starts a new 'word' for the
purposes of undo with 'word' granularity. setUndoTypingParams() calls this
method only when the typing could possibly continue a previous word. In other
words, undo will work safely regardless of the value returned. See the actual
code for recognizeStartOfTypingWord() for more details.</t>
<t tx="EKR.20040524104904.92">An @asis tree is a tree whose root headline starts with @asis &lt;filename&gt;.  Similarly, for @noref and @nosent trees.

New in 4.2:  The following terms are equivalent.  The first form is preferred in each case.

@asis, @file-asis, @silent
@nosent, @file-nosent and @nosentinelsfile
@noref, @file-noref and @rawfile

You can get any combination of sentinels/no sentinels and references/no references using @file, @nosent, @noref and @asis trees:

                External files        Sections and 
Type of tree   contain sentinels?   @others expanded?
------------   ------------------   -----------------
       @asis   no                   no
       @file   yes                  yes
      @noref   yes                  no
     @nosent   no                   yes
     
       

Leo can not update the outline from changes made from external files unless those
files contain sentinels. The primary source for @nosent and @asis trees are the
outlines from which those files were derived.

Leo creates files derived from @noref and @asis trees by writing the body text
of all nodes of the tree in outline order. Leo writes the body text _as is_,
without recognizing section definitions, without expanding section references,
and without treating directives specially in any way. In particular, Leo copies
all directives, including @space or @c directives, to the external file as text.
However, Leo recognizes the @ignore directive in the _ancestors_ of @noref or
@asis nodes, so you may use the @ignore directive as usual to prevent Leo from
writing @rawfile and @silentfile trees.

Notes:

1. When writing @noref trees, Leo writes only the @+leo, @-leo, @+node, @-node,
@+body and @-body sentinels.

2. Within @asis trees only, if a headline starts with @@, Leo writes everything
in the headline following the @@ just before the corresponding body text.

3. Files derived from @asis trees contain _nothing_ not contained in body text
(or @@ headlines). In particular, if body text does not end in a newline, the
first line from the next node will concatenated to the last line of the
preceding node.</t>
<t tx="EKR.20040524104904.99">@language rest</t>
<t tx="EKR.20040601084317">Leo 4.2 alpha 3           June 1, 2004

This version fixes completes the essential features of version 4.2. All known
incompletions and bugs involving shared nodes and Leo's new file format have
been fixed. BTW, this version of Leo completes Leaps 201 and 202.

It should be safe to use this version for collaboration between Leo's
developers. I hereby encourage people to start using cvs for collaboration. Only
by doing so will we discover any possible problems.

The only item that must be completed before releasing 4.2 beta is fixing the Go
To Line Number command so it supports thin external files.

There are many known bugs in this version: most are minor bugs that have been
around for a long time. All known bugs will be fixed by the first release
candidate. See the to-do list in LeoPy.leo for the complete list.

The highlights of this version:

- All features of @file-thin are now complete and appear to be stable. - All
	.leo files in the distribution use @thin files where possible. - Leo ignores
	all directives within the range of the @all directive. - The @+middle and
	@-middle sentinels allow sections to be defined in any descendant node. -
	The @clone sentinel marks duplicate cloned siblings. - The beginnings of a
	new undo scheme are in place. - @thin, @nosent, @noref and @asis are
	abbreviations for @file-thin, @file-nosent, @file-noref and @file-asis. -
	Created new iterators that return lists of vnodes and tnodes, including
	iterators that remove all duplicates from those lists.</t>
<t tx="EKR.20040601084317.102">Added u.registerUndoHandlers.

This will become largely unnecessary in the new undo scheme.  It's good to have though.</t>
<t tx="EKR.20040601084317.142">When writing .leo files Leo now pickle's and hexlify's all data in the
v.unknownAttribute and t.unknownAttribute dictionaries. When reading .leo files
Leo does the reverse.

Leo ignores all elements in these dictionaries if some element can not be pickled.</t>
<t tx="EKR.20040601084317.161">I have fallen madly in love with generators.
The following new iterators are defined with generators.

c.all_positions_iter
c.all_tnodes_iter
c.all_vnodes_iter
c.all_unique_tnodes_iter
c.all_unique_vnodes_iter

p.tnodes_iter
p.vnodes_iter
p.unique_tnodes_iter
p.unique_vnodes_iter

v.self_and__subtree_iter
v.self_and_unique_subtree_iter</t>
<t tx="EKR.20040601084317.2"></t>
<t tx="EKR.20040601084317.99">This happened after write errors such as orphan nodes.</t>
<t tx="EKR.20040601101118">If the copied node was an @thin or @file-thin node node only the root node was copied.</t>
<t tx="EKR.20040601101227"></t>
<t tx="EKR.20040601101227.1"></t>
<t tx="EKR.20040601101430">This bug exists in 4.1 final. Leo did not properly show the found text in
headlines. The fix was in the code that redraws the screen, not in the
find/change code itself.</t>
<t tx="EKR.20040601101430.1"></t>
<t tx="EKR.20040601101510"></t>
<t tx="EKR.20040601101547"></t>
<t tx="EKR.20040601102115"></t>
<t tx="EKR.20040601102703">The new scheme simply saves all information in one or more vnodes and their
associated tnodes. This is a general scheme that can be used by almost any
command.

At present only the u.saveTree method exists. Coming soon, u.saveNode,
u.saveNodeAndChildren and u.saveListOfNodes.</t>
<t tx="EKR.20040601102808">See the to-do list in LeoPy.leo for a list of known bugs in this version.

None of these bugs is serious:  I consider this version to be suitable for day-to-day work.</t>
<t tx="EKR.20040628095213">Leo 4.2 beta 2           July 5, 2004
Leo 4.2 beta 1           June 30, 2004

The highlights of 4.2 beta 2:

- Leo now writes the entire contents of @ignore'd @thin trees to the .leo file.
This change ensures that users can create and remove @ignore directives without
any chance of losing data inadvertently.

- Leo now saves and restores marks and the expansion state of nodes in @thin trees.

- Leo marks @thin nodes as dirty whenever they become "newly unignored", i.e.,
when an @thin node no longer falls in the range of an @ignore directive.

Beta 1 completes all fundamental work in the 4.2 code base. All essential code
is complete. Dozens of bugs have been fixed since the Alpha 3 release about a
month ago.

Known bugs in 4.2 beta 2:

- Not all plugins work correctly.
- Some plugins leak memory very slightly.

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
external files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

Other features of 4.2:

- Leo is now much more friendly to using spaces instead of tabs.
- The Execute Script command reports erroneous lines more clearly.
- The usual assortment of bug features and minor features.

Coming soon in 4.2:

- Perfect Import will guarantee that Leo imports file perfectly.
- @import will allow you to study files using Leo without changing those files.</t>
<t tx="EKR.20040628095213.109">http://sourceforge.net/forum/message.php?msg_id=2429098
By: nobody

The Leo icon can eliminate the need for the word Leo.

What I did:

- Eliminate Leo in name of Find panel.
- Derived leoTkinterPrefs from leoTkinterDialog: creates icon.
- Derived leoComparePanel from leoTkinterDialog: creates icon.
- Eliminated the -t option when opening Idle: the idle window is now called "Python Shell"</t>
<t tx="EKR.20040628095213.110">- Added @language html when importing ".htm" and ".html" files.
- Added @nocolor when importing ".txt" and ".text" files
</t>
<t tx="EKR.20040628095213.113">When in headline, the Select All command selected the body text.</t>
<t tx="EKR.20040628095213.121">- idle_body_key must call g.scanDirectives in order to support @tab_width.
	- This must be done for tabs and newlines.

- Fixed bug in g.scanDirectives that was rejecting negative tabwidth values.
	- This bug did not exist in the other versions of scanDirectives.

- With a negative tabwidth, a backspace now computes what spaces are equivalent
to a tab and delete all of those. This is easy to do!
</t>
<t tx="EKR.20040628095213.143"></t>
<t tx="EKR.20040628095213.160"></t>
<t tx="EKR.20040628095213.192"></t>
<t tx="EKR.20040628095213.197">doc\leoUsersGuide.txt
doc\leoFAQ.txt
doc\leoLeaps.txt</t>
<t tx="EKR.20040628095213.198">The old code used at c.tab_width.  It should also look for @tabwidth directives.

This was not good when @tabwidth -4 was in effect.</t>
<t tx="EKR.20040628095213.202">atFile.scanHeader was not handling -encoding fields properly.</t>
<t tx="EKR.20040628095213.213"></t>
<t tx="EKR.20040628095213.225"></t>
<t tx="EKR.20040628095213.23">@color

Added the following hooks:

tag argument                                               keys in keywords
(hook name)           overrides    when called           dictionary argument
---------             ---------    -----------           -------------------

"draw-outline-box"       yes   start of drawBox          tree,p,v,x,y (note 6)
"draw-outline-icon"      yes   start of tree.drawIcon    tree,p,v,x,y (note 6)
"draw-outline-node"      yes   start of tree.drawNode    tree,p,v,x,y (note 6)
"draw-outline-text-box"  yes   start of tree.drawText    tree,p,v,x,y (note 6)
"draw-sub-outline"       yes   start of tree.drawTree    tree,p,v,x,y,h,level,hoistFlag (note 6)</t>
<t tx="EKR.20040628095213.246">Namespace not handled very well.</t>
<t tx="EKR.20040628095213.264"></t>
<t tx="EKR.20040628095213.269"></t>
<t tx="EKR.20040628095213.279">I inserted "import time", and while I was at it I improved the error checking.</t>
<t tx="EKR.20040628095213.282">- By default, finishPaste command reassigns all indices in copied nodes.
- Created pasteOutlineRetainingClones.
- Added reassignIndices arg to pasteOutline, getLeoOutline and finishPaste.
- Added &lt;&lt; recreate tnodesDict &gt;&gt; in getLeoOutline.
- Simplified getTnode slightly: the "if t" code is the same for both kinds of reads.</t>
<t tx="EKR.20040628095213.297">The code now limits what can be pasted to a maximum of one line or a about 250 characters.</t>
<t tx="EKR.20040628095213.3">@nocolor

- Leo calls g.enableIdleTimeHook at end of startup code.
	- This means that g.idleTimeHookHandler gets called periodically, even if no hooks have been defined.
	- g.enableIdleTime hook now calls g.app.gui.setIdleTimeHook at most once.

- app.forceShutdown now calls "end1" hook before calling app.finishQuit.
	- This ensures that the "end1" hook always gets called once.
	- app.finishQuit calls doHook("end1",...) only if it hasn't been called before.
		- This isn't necessary, but it makes traces in doHook less confusing.

- idleTimeHookHandler now calls the idle-time hook for all open windows.
	- So having multiple windows open should not affect idle-time hooks.

** Warning: new convention required to workaround apparent Tk problems.
	- "idle" hooks should return if g.app.killed is True.</t>
<t tx="EKR.20040628095213.308"></t>
<t tx="EKR.20040628095213.311">@nocolor

- Leo now uses True and False everywhere instead of true and false.

- All of Leo's code uses spaces instead of tabs for indentation.</t>
<t tx="EKR.20040628095213.312"></t>
<t tx="EKR.20040628095213.314"></t>
<t tx="EKR.20040628095213.324">- Set removeTrailing to True unless ch is a newline.

This allows Alt-f to work properly.

- Return "break" after the "final" text has been computed if nothing has changed.

This suppresses spurious newlines.

A new idea:  Make sure the text _does_ have a newline at all times.  I'm not sure this will work...

- ALWAYS set the text in select.  This prevents some weird problems with trailing newlines.</t>
<t tx="EKR.20040628095213.334">- The string passed to exec now includes sentinels.

goToLineNumber needs sentinels to work properly.

- es_exception now gets the error line number from the traceback.

- Added new keyword arguments to goToLineNumber.

- Created goToScriptLineNumber, which just calls goToLineNumber.</t>
<t tx="EKR.20040628095213.346">Hitting return in middle of a headline didn't work.</t>
<t tx="EKR.20040628095213.348"></t>
<t tx="EKR.20040628095213.354"></t>
<t tx="EKR.20040628095213.366"></t>
<t tx="EKR.20040628095213.368"></t>
<t tx="EKR.20040628095213.377">Changed getVnode so it checks for v = None after calling getExistingVnode.  Creating the node seems to work in this case: I wouldn't bet my life that it works in all cases.</t>
<t tx="EKR.20040628095213.391">- Added toString to most write methods.
- Retained scriptFile option for compatibility with plugins.</t>
<t tx="EKR.20040628095213.404"></t>
<t tx="EKR.20040628095213.407"></t>
<t tx="EKR.20040628095213.408"></t>
<t tx="EKR.20040628095213.412"></t>
<t tx="EKR.20040628095213.425"></t>
<t tx="EKR.20040628095213.442">This only happened after previous write error.

The fix was to init self.errors in openWriteFile.

The whole atFile logic is pretty gruesome.  It's got to be cleaned up.</t>
<t tx="EKR.20040628095213.444">- Allow indented @all.
    - Changed to g.is_special
    - Changed leoColor.doAtKeyword
    
- Fixed bug in is_special that broke p.isAtAllNode.</t>
<t tx="EKR.20040628095213.485">There was a small hole in the format of external files. Leo assumed that comment
delimiters do not change within any particular external file. This assumption is
not necessarily true in files like leoProjects.txt.

What I did:

- putDirective and readDirective now check for @langauge and @comment, and
change comment delims appropriately.

This is slightly dubious: after all, an @langauge directive in the middle of
most external files will cause havoc. However, one could say that this is the
users problem :-)

BTW, this doesn't really solve all problems in @all trees: Leo can still get
mightily confused about comment delims if the user doesn't put proper @language
directives in @all trees.
</t>
<t tx="EKR.20040628095213.490">readEndNode uses the existing tempBodyString attribute to determine if the body text has changed.  If so, we mark the tnode dirty.  The code in 

top_df.read.&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;

propagates the dirty marks to all ancestor @file nodes.  This can't be done in readEndNode because no positions are available at that time.</t>
<t tx="EKR.20040628095213.493"></t>
<t tx="EKR.20040628095213.499"></t>
<t tx="EKR.20040628095213.501">Leo now writes t.unknownAttributes to the .leo file when writing the &lt;v&gt; element
corresponding to the root of an @thin tree. Leo will do this by writing a new
xml attribute, descendentTnodeUnknownAttributes, in &lt;v&gt; element.

Leo will only write t.unknownAttributes, not v.unknownAttributes. This is
because only tnodes have gnx's in thin external files. In effect, vnodes are
anonymous. We could attempt to get around this by identifying vnodes by their
corresponding tnodes, but that's not a general solution and it is, in effect,
equivalent to writing only t.unknownAttributes. This being so, it seems
pointless to "pretend" to be writing v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using
unknownAttributes is concerned. As I've stated in the past, this won't do if,
for example, a plugin is trying create an arbitrary directed graph between
vnodes. In that case, the plugin should confine itself to @file trees, or just
vnodes in .leo files, for that matter.</t>
<t tx="EKR.20040628095213.512">The problem was setting endSentinelComment to None instead of "" in readDirective.

The code is pretty fragile; it should handle either None or "", but in fact it requires "".</t>
<t tx="EKR.20040628095213.513"></t>
<t tx="EKR.20040628095213.52"></t>
<t tx="EKR.20040628095213.56"></t>
<t tx="EKR.20040628095213.60">Added support for RapidQ, css, shell scripts and PHP.</t>
<t tx="EKR.20040628100535">@killcolor</t>
<t tx="EKR.20040628100535.1"></t>
<t tx="TL.20080804095315.1">@language rest
</t>
<t tx="TL.20080804095315.11"></t>
<t tx="TL.20080804095315.2">############################################################
Chapter 22: Using Vim Bindings with Leo
############################################################

This chapter describes Leo's vim-like bindings, including how to install them.

.. .. contents::
</t>
<t tx="TL.20080804095315.3">.. Links
</t>
<t tx="TL.20080804095315.4">Place a copy of the "@keys Vim bindings" node and its sub-nodes,
located in the leoSettings.leo file, under the "@settings" node
in the myLeoSettings.leo file

The same procedure is performed to update to a new version.

Note: Place any local customized key bindings in a separate
"@keys My Vi" node in the myLeoSettings.leo file to prevent
them from being overwritten when updating to a new version.
</t>
<t tx="TL.20080804095315.5">The following commands are always available.

State change commands::

    i           Change state to insert from command state
    Esc         Change state to command from insert state
    Ctrl-[      Same as ESC

Save/Exit/Quite commands::

    :e          Revert
    :w&lt;return&gt;  Save '.leo' file
    :wq&lt;return&gt; Save '.leo' file and quit Leo
    :q&lt;return&gt;  Quit Leo   (Leo will prompt if file not saved)
    ZZ          Save leo file and exit

Undo/Redo commands::

    u           Undo previous command
    Ctrl-r      Redo previous command


Search options::

    Ctrl-/      Prompt for option to change
                Options:
                    a   Search all nodes (also &lt;cr&gt; key)
                    h   Toggle headline search
                    b   Toggle body search
                    m   Toggle marking of nodes (specify sub-option)
                        f   Toggle marking of nodes with found text
                        c   Toggle marking of nodes with changed text
                            (only supported with 'Alt-/', 'Alt-p')
                    r   Toggle regex matches
                        ('/' key turns off regex. 'n' key uses regex if turned on)

    Note: Whether a search is limited to node's body or the node's sub-outline
          is determined by which pane has focus when search text specified.
          (See "Find text commands:" sub-sections in Outline/Body Pane sections)

Miscellaneous commands::

    Tab         Toggle focus between Outline and Body pane
    =           Simulate double-click on current node's icon box
    Alt-G       Go to specified line number (relative to external file)
    Ctrl-:      Enter Leo's command line
</t>
<t tx="TL.20080804095315.6">Move cursor commands::

    h           Go back 1 character
       LtArrow  Mapped to "h" for convenience
    j           Go down 1 line
       DnArrow  Mapped to "j" for convenience
    k           Go up 1 line
       UpArrow  Mapped to "k" for convenience
    l           Go forward 1 character
       RtArrow  Mapped to "l" for convenience

    w           Go to beginning of next word
       W        Mapped to "w" until "stop after blank characters" supported
    b           Go to beginning of current/previous word
       B        Mapped to "b" until "stop at blank character" supported
    e           Go to end of current/next word
       E        Mapped to "e" until "stop at blank character" supported

    Note: Move by word commands stop at non-alpha characters

    |           Goto beginning of current line
    ^           Go to 1st non-blank character on current line
    $           Goto end of current line

    %           Go to matching bracket

    (           Go to beginning of current sentence
    )           Go to beginning of next sentence
    {           Go to beginning of current paragraph
    }           Go to beginning of next paragraph

    gg          Go to the first line (Cursor at column 1)
    G           Go to the last line  (Cursor at column 1)

Mark commands::

    m&lt;label&gt;    Assign cursor location to a single character label
    `&lt;label&gt;    Go to location associated with label

      Note: Only character count is tracked. Any inserts or deletes will change mark.
          Mark's are not node specific; `&lt;label&gt; will go to location in current node.

Select commands::

    Ctrl-v      Toggle text select mode (Vim's "visual" mode)
       V        Mapped to 'Ctrl-v' for convenience (Should toggle line select)

Insert/substitute commands::

    a           Insert at cursor
    i           Mapped to "a" until "cursor on a character" supported
    A           Insert at end of line
    I           Insert at first non-space
    o           Open new line below current line
    O           Open new line above current line
    R           Overwrite text
    s           Substitute character (Delete character, enter insert state)
    S           Substitute line (Delete line, enter insert state)

Change commands::

    C           Change to end of line
    cc          Change all of current line
    cw          Change to end of word
    cb          Change to beginning of word
    c)          Delete to end of sentence
    c(          Delete to beginning of sentence
    c}          Delete to end of paragraph
    c{          Delete to beginning of paragraph
    c%          Change from current bracket type its matching bracket type
    ct&lt;char&gt;    Selects forward to &lt;char&gt; (follow with 'i' to change selection)
    cT&lt;char&gt;    Selects backward to &lt;char&gt; (follow with 'i' to change selection)
    c&lt;cr&gt;       Change selected text

Delete commands::

    x           Delete next character
    delete      Delete next character
    D           Delete to the end of the current line
    dd          Delete current line
    dw          Delete to end of word
    db          Delete to beginning of word
    d)          Delete to end of sentence
    d(          Delete to beginning of sentence
    d}          Delete to end of paragraph
    d{          Delete to start of paragraph
    d%          Delete from current bracket type to its apposing bracket
    dt&lt;ch&gt;      Delete to character (not limited to current line)
    d&lt;cr&gt;       Delete selected text

    J           Join next line to end of current line (deletes carriage return)

Yank text commands::

    Y           Yank to end of line
    yy          Yank line
    yw          Yank to beginning of next word
    yb          Yank to beginning of current word
    y)          Yank to end of sentence
    y(          Yank to beginning of sentence
    y}          Yank to end of paragraph
    y{          Yank to beginning of paragraph
    y%          Yank from current bracket type to its opposing bracket
    yt&lt;char&gt;    Select forward to &lt;char&gt;  (use 'y&lt;cr&gt;' to yank selection)
    yT&lt;char&gt;    Select backward to &lt;char&gt; (use 'y&lt;cr&gt;' to yank selection)
    y&lt;cr&gt;       Yank selected text (Vim uses 'y' in visual mode)

Find character commands::

    f           Find next occurrence of user specified character
    F           Find previous occurrence of user specified character

Find text commands::

    /           Search forward within current node's body text
    ?           Search backward within current node's body text
    n           Find next (same scope, same direction)
    N           Find next (same scope, other direction)

    Note: See "Search options" in General Commands section to change options.

Replace [and find next] commands::

    Commands using Paste buffer (clipboard)
    P           Paste text before cursor.
    p           Mapped to "P" until character based cursor supported.
    Ctrl-p      Paste then find next match
                Note: Use 'pn' instead of 'Ctrl-p' in headlines (Leo limitation)
                      Command will continue to paste when match no longer found.

    Commands prompting for replace string
    Note: Scope and direction taken from last use of '/','?' or 'Ctrl-/'(scope only)
    Alt-/       Prompt for search &amp; replace string
    Alt-p       Replace then search (use after Alt-/)
                Note: Works in headlines and body panes.
                      Doesn't paste unless last search found a match.

Indent/Unindent line commands::

    &gt;&gt;          Indent the current line
    &gt;)          Indent to the end of sentence
    &gt;(          Indent to the beginning of sentence
    &gt;}          Indent to the end of paragraph
    &gt;{          Indent to the beginning of paragraph
    &gt;g          Indent to the start of buffer
    &gt;G          Indent to the end of buffer

    &lt;&gt;          Unindent the current line
    &lt;)          Unindent to the end of sentence
    &lt;(          Unindent to the beginning of sentence
    &lt;}          Unindent to the end of paragraph
    &lt;{          Unindent to the beginning of paragraph
    &lt;g          Unindent to the start of buffer
    &lt;G          Unindent to the end of buffer

Format commands::

    gqap        Split long line into separate lines
    gwap        Split long line into separate lines
    gqq         Split long line into separate lines
    gww         Split long line into separate lines
    
    Note: 'gwap' and 'gww' should not move cursor but do.

Scroll commands::

    Ctrl-b      Scroll text up by pane's height
    Ctrl-f      Scroll text down by pane's height
       Ctrl-y   Mapped to Ctrl-b until scroll up one line is supported
       Ctrl-e   Mapped to Ctrl-f until scroll down one line is supported
       Ctrl-u   Mapped to Ctrl-b until scroll up half a pane height is supported
       Ctrl-d   Mapped to Ctrl-f until scroll down half a pane height is supported

Window commands::

    Ctrl-w s    Open another view into current node's body (Vim: Split window)
       Ctrl-w n Mapped to "Ctrl-w s" (Vim: New buffer in split window)
    Ctrl-w w    Switch to next view (Vim: Go to up/left window w/wrapping)
       Ctrl-w p Mapped to "Ctrl-w w" (Vim: Cycle through windows)
       Ctrl-w k Mapped to "Ctrl-w w" (Vim: Go to window above current window)
       Ctrl-w j Mapped to "Ctrl-w w" (Vim: Go to window below current window)
    Ctrl-w c    Close current view in body pane (Vim: Close current window)
       Ctrl-w q Mapped to "Ctrl-w c" (Vim: Quit current window)

Node commands::

    Go to another node while focus remains in the body pane.
    Ctrl-j      Go to next visible node
    Ctrl-k      Go to previous visible node
    Ctrl-h      Hide sub-nodes or, if hidden, go up 1 level
    Ctrl-l      Display sub-nodes or, if displayed, go down 1 level
       Ctrl-DnArrow    Mapped to "Ctrl-j" for convenience
       Ctrl-UpArrow    Mapped to "Ctrl-k" for convenience
       Ctrl-LtArrow    Mapped to "Ctrl-h" for convenience
       Ctrl-RtArrow    Mapped to "Ctrl-l" for convenience
</t>
<t tx="TL.20080804095315.7">The following commands are supported when in a headline's command mode.

State change commands::

    Ctrl-i      Change state to command from grayed state
    return      Change state to command from insert state
    Ctrl-]      Change state to grayed from command state

Cursor movement commands::

    h           Go to previous character
       LtArrow  Mapped to 'h' for convenience
    l           Go to next character
       RtArrow  Mapped to "l" for convenience

    Note: 'j' and 'k' will scroll the buffer contents up and down;
          leaving the focus in the outline pane.

    w           Go to beginning of next word
       W        Mapped to "w" until "stop after blank characters" supported
    b           Go to beginning of current/previous word
       B        Mapped to "b" until "stop at blank character" supported
    e           Go to end of current/next word
       E        Mapped to "e" until "stop at blank character" supported

    Note: Move by word commands stop at non-alpha characters

    |           Go to beginning of line
    ^           Go to beginning of line
    $           Go to end of line

    %           Go to matching bracket

Edit commands::

    x           Delete next character
    delete      Delete next character
    dd          kill-line

    s           Select current character

    v           Toggle text select mode (issue cursor movement commands)
    y&lt;return&gt;   Yank selected text

    C           Select to end of line (follow with 'i' to change text)
    cc          Delete line (follow with 'i' to change text)

    D           Select to end of line (follow with 'x' to delete text)
    dd          Delete line

    Y           Select to end of line (follow with 'y&lt;return&gt;' to yank text)
    yy          Select line (follow with 'y&lt;return&gt;' to yank text)

Find character commands::

    f           Find next occurrence of user specified character
    F           Find previous occurrence of user specified character

Find text commands::

    /           Search forward within current node and its subnodes
    n           Find next (same scope, same direction)
    N           Find next (same scope, other direction)

    Note: See "Search options" section above to change options using 'Ctrl-/'

Replace [and find next] commands::

    Commands that use Paste buffer (clipboard)
    Note: Paste-then-search command not possible in headlines (Use 'pn')
    P           Paste text before cursor.
    p           Mapped to "P" until character based cursor supported.

    Commands that prompt for the replace string
    Alt-/       Prompt for search &amp; replace string
    Alt-p       Replace then search (use after Alt-/)
                Note: Works in headlines and body panes.
                      Doesn't paste unless last search found a match.

Node edit commands::

    o           Insert node after current node

    Ctrl-x      Delete current node
    Ctrl-c      Yank current node
    Ctrl-v      Paste current node

Node goto commands::

    G           Go to the outline's last node
    gg          Go to the outline's first node

    Ctrl-j      Go to next visible node
    Ctrl-k      Go to previous visible node
    Ctrl-h      Hide sub-nodes or, if hidden, go up 1 level
    Ctrl-l      Display sub-nodes or, if displayed, go down 1 level

       DnArrow  Mapped to "Ctrl-j" for convenience
       UpArrow  Mapped to "Ctrl-k" for convenience

       Ctrl-DnArrow Mapped to "Ctrl-j" for convenience
       Ctrl-UpArrow Mapped to "Ctrl-k" for convenience
       Ctrl-LtArrow Mapped to "Ctrl-h" for convenience
       Ctrl-RtArrow Mapped to "Ctrl-l" for convenience

Node move commands::

    Ctrl-Shift-k    Move node down
    Ctrl-Shift-h    Move node left
    Ctrl-Shift-l    Move node right
    Ctrl-Shift-j    Move node up

       Ctrl-Shift-DnArrow    Mapped to "Ctrl-Shift-k" for convenience
       Ctrl-Shift-LtArrow    Mapped to "Ctrl-Shift-h" for convenience
       Ctrl-Shift-RtArrow    Mapped to "Ctrl-Shift-l" for convenience
       Ctrl-Shift-UpArrow    Mapped to "Ctrl-Shift-j" for convenience

Node mark commands::

    m           Toggle node mark
    Ctrl-m      Go to next marked node
    Alt-m       Clear all marked nodes

Node clone commands::

    t           Clone the current node (transclude)
    Ctrl-t      Go to next clone of current node

Outline scroll commands::

   Ctrl-y       Scroll outline up one line
   Ctrl-e       scroll outline down one line
   Ctrl-u       Scroll outline up one half page
   Ctrl-d       scroll outline down one half page
   Ctrl-b       Scroll outline up one page
   Ctrl-f       scroll outline down one page

</t>
<t tx="TL.20080804095315.8">Notable missing editing commands::

    t&lt;char&gt;     Move cursor to character before specified character
    r           Replace a single character with a single character
    0           Go to 1st column in current line (Use '|' instead)
    bksp        Move one character to the left
    ~           Toggle character's case
    .           Repeat last editing command
    ;           Repeat last cursor movement command
    &lt;n&gt;&lt;cmd&gt;    Perform command 'n' number of times
    &lt;cmd&gt;&lt;n&gt;&lt;object&gt;    Perform the command on the n'th or up to the n'th object

Notable missing body pane commands::

    &lt;num&gt;G      Go to specified line number
    z&lt;movement&gt; Slide buffer to put current line at top/middle/bottom of pane
    '&lt;command&gt;  Go to line of last edit, jump, ...
    `&lt;command&gt;  Go to character of last edit, jump, ...
</t>
<t tx="TL.20080804095315.9">If you use the open-with plugin to open node text in Vim and your Vim's "tag"
file refers to external files then there is a risk that a external file that is
initially displayed via the "tag" command" in Vim is accidentally edited and
saved from the external Vim editor while your Leo session still contains the
external file's original text that may later recreate the original external file
during a Leo save operation (overwriting the changes saved from the Vim editor).

To prevent this problem, modifications to external files can be avoided by using
Vim's "modeline" feature to disable editing of external files.

Vim's "modeline" feature scans each loaded buffer for text at the top or bottom
of the file containing " vim:" followed by a series of Vim options. The text is
usually embedded within a comment. The following example prevents modifications
to a buffer in a Python file::

    # vim:noma (A space is required between the '#' and "vim:noma")

If this line is placed in a separate Leo node at the top or bottom of the list
of nodes under a external file node (ex: @thin) then any external file saved and
then later loaded into Vim will, by default, not be modifiable. If a derived
file does need to be edited then modifications can be re-enabled on a
file-by-file basis by issuing Vim's ":ma" command while viewing the derived
file.

The number of lines that Vim checks at the top and bottom of the buffer is
configurable. The following Vim command must be placed in the vimrc file to
allow for Leo's trailing sentinel lines::

    set modelines=8

Issue the ":help modeline" command within Vim for the more information about
modelines.</t>
<t tx="TL.20090225194539.1">A Leo plugin that permits the "easy" assignment of scripts to be performed on
double-clicked nodes based on pattern matching.

When a node is double-clicked, the nodeActions plugin checks for a match of the
double-clicked node's headline text with a list of patterns and, if a match
occurs, the script associated with the pattern is executed.

Each pattern and their associated script is defined within a 'pattern'
sub-node under a single "nodeActions" node.  The "nodeActions" node can
be located anywhere within the Leo file.
The headline of each patteren sub-node contains the pattern to be matched.
The body of the sub-node contains the script to be executed if the pattern
matches the double-clicked node.

For example, the "nodeActions" node containing a "launch URL" pattern node
and a "pre-process python code" node could be placed under an "@settings"
node::

   @settings
   |
   +- nodeActions
      |
      +- http:\\*
      |
      +- @thin *.py

Configuration:
   The nodeActions plugin supports the following global configurations using
   Leo's support for setting global variables within an @settings node's
   sub-nodes in the leoSettings.leo, myLeoSettings.leo, and the project Leo
   file:

   @bool nodeActions_save_atFile_nodes = False

      :True:
         Double-click on an @file type node will save the file to disk
         before executing the script.

      :False:
         Double-click on an @file type node will **not** save the file to disk
         before executing the script. (default)

   @int nodeActions_message_level = 1

      Specifies the type of messages to be sent to the log pane.  Specifying a
      higher message level will display that level and all lower levels.
      The following integer values are supported:

      :0: no messages
      :1: Plugin triggered and the patterns that were matched (default)
      :2: Double-click event passed or not to next plugin
      :3: Patterns that did not match
      :4: Code debugging messages

.. _nA_Patterns:

__ nA_Directives_

Patterns:
   Pattern matching is performed using python's support for Unix
   shell-style patterns unless overwritten by the "X" `pattern directive`__.
   The following pattern elements are supported::

              * - matches everything
              ? - matches any single character
        [&lt;seq&gt;] - matches any character in &lt;seq&gt;
       [!&lt;seq&gt;] - matches any character **not** in &lt;seq&gt;

   Unix shell-style pattern matching is case insensitive and always starts from
   the beginning of the headline.  For example:

      .. table::

         ======= =========== ==============
         Pattern   Matches   Does not match
         ======= =========== ==============
         \*.py   Abc_Test.py
         .py     .py - Test  Abc_Test.py
         test*   Test_Abc.py Abc_Test.py
         ======= =========== ==============

   To enable a script to run on any type of @file node (@thin, @shadow, ...),
   the pattern can start with "@files" to match on any
   external file type.  For example, the pattern "@files \*.py" will
   match a node with the headline "@thin abcd.py".

   The headline of the double-clicked node is matched against the patterns
   starting from the first sub-node under the "nodeActions" node to the last
   sub-node.
   
   Only the script associated with the first matching pattern is
   invoked unless overwritten by the "V" `pattern directive`__.

   __ nA_Directives_

   Using the "V" pattern directive allows a broad pattern such
   as "@files \*.py" to be invoked, and then, by placing a more restrictive
   pattern above it, such as "@files \*_test.py", a different script can be
   executed for those files requiring pre-processing::

      +- nodeActions
         |
         +- @files *_test.py
         |
         +- @files *.py

   :Note:
      To prevent Leo from trying to save patterns that begin with a derived
      file directive (@thin, @auto, ...) to disk, such as "@thin \*.py",
      place the "@ignore" directive in the body of the "nodeActions" node.

   Pattern nodes can be placed at any level under the "nodeActions" node.
   Only nodes with no child nodes are considered pattern nodes.
   This allows patterns that are to be used in multiple Leo files to be read
   from a file.  For example, the following structure reads the pattern
   definition from the "C:\\Leo\\nodeActions_Patterns.txt" file::

      +- nodeActions
         |
         +- @files C:\Leo\nodeActions_Patterns.txt
            |
            +- http:\\*
            |
            +- @thin *.py


.. _nA_Directives:

Pattern directives:
   The following pattern specific directives can be appended to the end of a
   pattern (do not include the ':'):

   :[X]:
      Use python's regular expression type patterns instead of the Unix
      shell-style pattern syntax.

      For example, the following patterns will match the same headline string::

         Unix shell-style pattern:
            @files *.py

         Regular Expression patern:
            ^@files .*\.py$ [X]

   :[V]:
      Matching the pattern will not block the double-click event from
      being passed to the remaining patterns.
      The "V" represents a down arrow that symbolizes the passing of the event
      to the next pattern below it.

      __ nA_Patterns_

      For example, adding the "[V]" directive to the "@files \*_test.py" in
      the `Patterns`__ section above, changes its script from being 'an
      alternate to' to being 'a pre-processor for' the "@files \*.py" script::

         +- nodeActions
            |
            +- @files *_test.py [V]
            |
            +- @files *.py

   :[&gt;]:
      Matching the pattern will not block the double-click event from being
      passed to other plugins.
      The "&gt;" represents a right arrow that
      symbolizes the passing of the event to the next plugin.

      If the headline matched more than one headline,
      the double-click event will be passed to the next plugin if the
      directive is associated with any of the matched patterns.

   The directive(s) for a pattern must be contained within a single set of
   brackets, separated from the pattern by a space, with or without a comma
   separator.  For example, the following specifies all three directives::

      ^@files .*\.py$ [X,V&gt;]

Scripts:
   The script for a pattern is located in the body of the pattern's node.
   The following global variables are available to the script::

      c
      g
      pClicked - node position of the double-clicked node
      pScript - node position of the invoked script

Script examples:
   Displaying URLs (tested with WinXP):

      Double-clicking on a node with a "http:\\\\www.google.com" headline
      will invoke the script associated with the
      "http:\\\\\*" pattern.  The following script in the body of the pattern's
      node displays the URL in a browser::

         import webbrowser
         hClicked = pClicked.h     #Clicked node's Headline text
         webbrowser.open(hClicked) #Invoke browser

   Executing commands (tested with WinXP):

      The following script can be placed in the body of a pattern's node to
      execute a command in the first line of the body of a double-clicked node::

         g.os.system('"Start /b ' + pClicked.bodyString() + '"')

</t>
<t tx="bob.20080110214217"></t>
<t tx="bob.20080110214217.1">gtkDialogs replaces Tk's file dialogs with Gtk file chooser dialogs.

The plugin is aimed mainly at Linux users with pyGtk installed on their systems,
but it should work on on any system that support Gtk2 and pyGtk.

</t>
<t tx="bob.20080110221203"></t>
<t tx="bob.20080110221203.1">This plugin allows wxPython to be used as leo's gui instead of TK.

It is a prototype under development and so does not have all the features of Tk
leo nor are there many plugins compatible with it yet.

It is mainly being developed for Linux at the moment, but attempts are being
made to keep it working on Windows as well.

Work on this project has now halted in favor of a gtkLeo plugin.

</t>
<t tx="bobjack.20080613141524.2">A plugin that enhances Leo's iconBar and script buttons.


This plugin provides:

    multiple iconBars each of which automatically collapse and
    expand so that all the buttons are always visible.

    drag and drop of buttons within and between iconBars.

    enhancements to Leo's buttons and @button settings to allow
    icons, menus, tooltips and text and background colors to be set
    in @button settings and scripts. 


see test/testToolbar.leo for demo's and howto's
see test/testAtPopup.leo for examples of enhanced buttons
</t>
<t tx="edream.110203163054.100">The Synchronization Principle simplifies everything and at long last puts Leo on
a firm theoretical foundation. This principle states that the "smallest unit of
meaning" of any Leo outline is the entire outline itself. In particular,
individual external files have meaning only in the context of a particular
outline.

The Synchronization Principle has the following happy consequences:

1. We may assume that all external files are in synch with the outline that wrote
them. This assumption allows Leo to use "hidden machinery" in the outline to
associate nodes in the external file with nodes in the outline. This "hidden"
machinery consists of a list of tnodes associated with @file vnodes in the
outline. When writing a external file Leo creates a list of tnodes in the order
they were written to the external file. When reading the external file, Leo uses
this list to associate nodes in the external file with nodes in the outline.

2. external files must get their structure from the .leo file that wrote them. As
we have seen, this is done using the hidden machinery in the .leo file.
Consequently, there is no further need to represent outline structure in derived
files. There is no need any longer either for child indices or for sentinels to
represent outline structure. As a result, we can eliminate @+body and @-body
nodes entirely because all @+node sentinels are followed by body text.

3. All .leo files must contain full outline structure. Even "thin" outline will
contain the full representation of the outline as vnodes.

4. Reading _never_ alters outline structure in the outline. No vnodes are ever
created or destroyed and reading never alters clone links. This is true whether
or not read errors occur. The read code sets a temporary attribute of tnodes
while reading. These attributes are copied to the permanent t.bodyString
attribute only if no read errors were encountered.

4. Error recovery is now trivial: Read errors indicate that the .leo files and
one or more external files are out-of-synch. No error recovery is attempted: the
@file tree in which the error occurred reverts back to its original state.

5. The new Import External File command is the _only_ way to recover data from
mismatched external file.</t>
<t tx="edream.110203163054.101"></t>
<t tx="edream.110203163054.102">The write_old_format_derived_files option in leoConfig.leo and leoConfig.txt
determines which format of external file Leo's Write and Save commands write by
default. If this option is 0 (recommended) Leo writes 4.x format external files.
Otherwise Leo writes 3.x external files.

Note that you can use the Write 3.x/4.x external files commands in the
File:Read/Write menu to write external files in an explicitly specified format.</t>
<t tx="edream.110203163054.103">This command deletes all entries in the Recent Files submenu except the most
recent file. The files themselves are not affected, just the menu entries.</t>
<t tx="edream.110203163054.104">The Import External File command imports all the nodes in a external file into the
outline. Unlike the read commands, no outline structure is preserved. This
command can import either 3.x or 4.x external files.

This command is necessary in version 4.0 because there is no other way to read
external files that are out-of-synch with a .leo file.</t>
<t tx="edream.110203163054.105">The Write 4.x External Files command and Write 3.x External Files command work
just like the Write @file Nodes command, except that they write the indicated
format off external file. In contrast, the Write @file Nodes command writes 3.x
format external files if and only if the write_old_format_derived_files = 1 in
leoConfig.txt.

All three of these commands automatically save the outline (the .leo file) if
any external file was actually written. This is necessary so that information in
the .leo file always remains in synch with all external files.</t>
<t tx="edream.110203163054.106">Paul Paterson contributed the following new plugins:

mod_autosave.py

Autosaves the Leo document every so often.

mod_timestamp.py

Timestamps all save operations to show when they occur.

word_export.py

Exports an outline to a word document. Clicking "plugins ... word export ...
export" exports the selected outline to Word. Word should be running with an
open (empty) document before executing this command.</t>
<t tx="edream.110203163054.107"></t>
<t tx="edream.110203163054.108">Leo's read code now warns if any non-empty node is unvisited. This check, and
the check that headlines match pretty much guarantees that out-of-synch outlines
will generate errors. Thus, there is no need a gnx timestamp in @+leo sentinels!</t>
<t tx="edream.110203163054.109">Version 4.0 is a major advance in Leo's error handling. Using 4.0 is much safer
than all previous versions. This new error handling applies to all derived
files, both 3.x and 4.x format.

Leo's read code never alters the structure of an outline, regardless of whether
read errors are encountered. This means that clone links, marks, and all other
information in the outline except body text remains completely unchanged during
reads. Broken clone links (the dreaded read errors) are gone forever. Also, the
new read code makes no changes to any body text until it is known that no read
errors have occurred. This ensures that absolutely no changes at all are made to
the outline if there are read errors.

Leo's read code now writes a message to the log pane whenever it sees that the
body text in the external file does not match the body text in the outline. These
messages do not indicate errors, only that the body text has been changed
outside of Leo, say in an external editor or by cvs.</t>
<t tx="edream.110203163054.110"></t>
<t tx="edream.110203163054.111"></t>
<t tx="edream.110203163054.112">Added encoding comments to leoGlobals.py and French plugins

This removes a warning new in Python 2.3.
</t>
<t tx="edream.110203163054.113">There is no need to recycle Python objects when the last outline window is being closed.</t>
<t tx="edream.110203163054.114">This is too annoying during testing.  The Read @file Nodes command will in fact be made undoable for the 4.0 final release.</t>
<t tx="edream.110203163054.115">This has been changed in Python 2.3 and it probably wasn't ever a good idea...</t>
<t tx="edream.110203163054.116">The read code has much simplified using look-behind rather than look-ahead.  Both the read and write code write the file line-by-line without recursion.</t>
<t tx="edream.110203163054.117"></t>
<t tx="edream.110203163054.46">@nocolor
@language plain</t>
<t tx="edream.110203163054.48">##########################################
Chapter 1: Installing Leo
##########################################

This chapter tells how to install and run_ Leo.

**Important**:

If you have *any* problems installing Leo,
please ask for help on `Leo's help forum`_.
</t>
<t tx="edream.110203163054.49">Leo will work on any platform that supports Python 2.5 or later and Tk 8.4 or later. For
Qt ui, Qt 4.4 or newer (and compatible PyQt) is required.

-   Download the latest version of Leo from `Leo's download page`_.

-   Download Python from: http://python.org/

-   Most installations of Python have Tk pre-installed.
    If your doesn't, you may download it from: http://tcl.activestate.com/software/tcltk/

    **Warning**: When building Tcl on Linux, do **not** specify
    "--enable-threads".
    Only use Tcl with the default "threads not enabled" case.

-   Leo uses `Pmw`_ (Python Mega Widgets). Leo's extensions folder contains a copy
    of Pmw for use if needed. Leo first tries to import Pmw normally. If that
    fails, Leo will use the version of Pmw in the extensions folder.</t>
<t tx="edream.110203163054.50">If you are using Debian/Ubuntu, find and install the debian package. This
provides the best integration with your desktop (file associations, icons, launcher
item). Failing that, follow the instructions below.

Download the latest version of Leo (a .zip file) from `Leo's download page`_.

Unzip the downloaded .zip file into the **unpacked folder** in your home directory.
The unpacked folder will be called something like leo-4-5.

You now have two choices:

1. You can run Leo from your home directory.
   Just add  ~/leo-4-5 to your path.

2. You can install leo into /usr/local/lib and /usr/local/bin by running Leo's install script as follows::

    cd ~/leo-4-4-3-final
    chmod u+x install
    sudo ./install


The install script will instruct you to add /usr/local/bin to your path.
You can, instead, add the following link::

    sudo ln -s /usr/local/lib/leo/ /usr/local/lib/python2.5/site-packages/

Now you are ready to `run Leo`_.
</t>
<t tx="edream.110203163054.61">For versions of Leo before 4.0 and for versions of Python before 2.3,
Leo will draw a Leo icon in Leo windows only if you have installed Fredrik Lundh's PIL and tkIcon packages.

-   Download PIL from http://www.pythonware.com/downloads/index.htm#pil

-   Download tkIcon from http://www.effbot.org/downloads/#tkIcon
</t>
<t tx="edream.110203163054.63"></t>
<t tx="edream.110203163054.64">Leo 4.1 alpha 1                   November 3, 2003

*** Alpha quality code:  Please make full backups before playing with this code!

This release marks another significant milestone in Leo's history:

- Leo's 4.x file code is complete. At present I have no plans to change the
format of .leo files or external files. I am eating my own dog food: I do all my
editing with the 4.1 code base.

- Leo uses immutable gnx's (id:timestamp:n) by default to associate tnodes with
vnodes in .leo files. This makes Leo as cvs friendly as possible. From now on
.leo files will be checked in to cvs with the -ko (text/keywords off) option.

- The use_gnx setting in leoConfig.txt determines whether uses gnx's (cvs
friendly) or ints. No version of Leo before 4.1 can read .leo files containing
gnx. Only gnx's are immutable. Leo recomputes all non-gnx indices from scratch
whenever writing a .leo file. It is possible to convert between 3.x and 4.1 file
formats by changing the use_gnx setting.

- The 4.1 code base has been reorganized to support gui's other than tkinter.
Leo's src directory contains several new source files.

- The file test.leo in the test directory contains real regression tests for
syntax coloring. Regression testing scripts create regression tests dynamically
from data in Leo's outline. Very cool, very easy, very general. In particular,
regression tests may use temporary nodes in test.leo rather than creating
separate Tk windows for testing.

Known bugs:

- The Extract commands eat one character too much.

- The __wx_gui.py plugin is only partly functional.</t>
<t tx="edream.110203163054.66">Leo 4.0.4                         October 29, 2003

- Fixed a problem with the titles in Font and Color panels.
- Worked around a Unicode assert failure in the colorizer.
- Fixed crasher in OnEndEditHeadline.
- Fixed import problems in leoPlugins.leo.
- @first and @last sentinels no longer contain corresponding text.
  This fixes a problem that affected PHP comment delimiters.

Leo 4.0.3                         October 25, 2003

- Fixes several problems with the auto_save and plugin menu plugins.
- Fixes a problem with the Go To Line Number command.

Note: This version does _not_ support Unicode file names or directory names.

Leo 4.0.2                         October 23, 2003

- Fixes a crasher in reportBadChars when a .leo file contains a character that
  can not be represented in the encoding specified in the first line of the
  .leo file.
- Leo now sends full tracebacks to the log window when Leo takes an unexpected
 exception.
- Leo now issues a more informative message when the @comment directive
  inhibits the Untangle command.

Leo 4.0.1                         October 22, 2003

- Fixes several crashers, one of which may prevent Leo from starting.
- Fixes indentation for section references that are preceded by something
  other than whitespace.
- Removes debugging traces when reading and writing unknown attributes.
- Removes some improperly cloned nodes from LeoDocs.leo.
- Adds the checkTopologyOfAllClones script.
- Fixes some problems with plugins.</t>
<t tx="edream.110203163054.67">Leo 4.0 final                     October 17, 2003

More than a year in the making, Leo 4.0 is finally here.

Highlights of 4.0 final:
-----------------------

** Improved and simplified format of external files.
	- Eliminated child indices, extraneous blank lines and @body sentinels.
	- Eliminated @node sentinels that indicate outline structure.
	- New @nl and @nonl sentinels indicate where newlines are and aren't.
	- These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
	- Reading external files _never_ alter outline structure or links.
	- Read errors leave the outline completely unchanged.
	- Broken clone links are gone forever.
	- As a result, 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
	- Leo 4.0 reads all external files properly, regardless of version.
	- Leo writes new-format external files by default, and this default may be changed.
	- New commands in the read/write menu allow you to explicitly specify the format of external files.

* New commands:
	- Write 3.x external file and Write 4.x external file.
	- Import External File.
	- Clear Recent Files.

* Dozens of other improvements, including:
	- Better Unicode support.
	- New configuration settings.
	- Several new plugins.

See the notes for the various beta releases for full details.</t>
<t tx="edream.110203163054.68">Leo 4.0 beta 4                      October 13, 2003

This is the third public release of Leo 4.0. There are no known serious bugs in
this version of Leo.  This will be the last beta release before 4.0 final.

Changes made in 4.0 beta 4
--------------------------

- Changed all instances of string.letters to string.ascii_letters.
  string.letters can cause crashes in some locales (Unicode environments).
- Fixed several bugs that caused clone marks not to be set properly.</t>
<t tx="edream.110203163054.69">Leo 4.0 beta 3                      October 9, 2003

This is the third public release of Leo 4.0. There are no known serious bugs in
this version of Leo.

Highlights of 4.0 beta 3
------------------------

- Fixed problems with setting Leo's window icons.
- Plugins may now save their own information in &lt;v&gt; and &lt;t&gt; elements in .leo files.
- The usual assortment of bug fixes and minor improvements.

See the children of this node for full details.</t>
<t tx="edream.110203163054.70"></t>
<t tx="edream.110203163054.71">This was a long-standing bug.  It's effect was cosmetic, and it was important to fix.</t>
<t tx="edream.110203163054.72"></t>
<t tx="edream.110203163054.73">This could happen when the external file was corrupted.</t>
<t tx="edream.110203163054.74"></t>
<t tx="edream.110203163054.75"></t>
<t tx="edream.110203163054.76">Leo can now read and write "foreign" attributes in &lt;v&gt; and &lt;t&gt; elements in .leo
files:

- When reading a .leo file, Leo will create t.unknownAttributes or
v.unknownAttributes ivars for any tnode and vnode object whose corresponding &lt;v&gt;
or &lt;t&gt; element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are a dictionary whose keys are the attribute
names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if a vnode or tnode
contains an unknownAttributes ivar.

- The only "native" attributes that Leo expects to find are the "tx" attribute
in &lt;t&gt; elements and the "a", "t", "vtag" and "tnodeList" attributes of &lt;v&gt;
elements. Everything else is a foreign attribute.

- Leo performs the usual xml escapes on these strings when reading or writing
the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching
unknownAttributes ivars to a vnode or tnode. For example:

	v.unknownAttributes = {"vnodeIcon" : pathToIcon}

It would be best not to delete other foreign attributes, so the following would
be preferred:

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

Another way:

	try:
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	except AttributeError:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}</t>
<t tx="edream.110203163054.77"></t>
<t tx="edream.110203163054.78">Leo now warns if it can't find either the Icons directory or the LeoApp16.ico icon in that directory.</t>
<t tx="edream.110203163054.79">Leo 4.0 beta 2                      October 3, 2003

This is the second public release of Leo 4.0. There are no known serious bugs
in this version of Leo. Version 4.0 is the culmination of over a year of
collaborative design work and several months of actual implementation.

Highlights of 4.0 beta 2
------------------------
* Fixed several bugs:
  - Fixed several problems with reading and writing 4.0 external files.
  - Fixed several Unicode-related bugs.
  - Fixed a crasher in the Go To Line Number command.
  - Fixed a problem with Importing Python files.
* Important improvements:
  - Added allow_clone_drags setting.  N.B. Allows Leo to be used with Aqua.
  - When running Python 2.3 Leo can now create window icons without third-party packages.
- The usual minor improvements and bug fixes.

See the children of this node for full details.

Highlights of 4.0 beta 1
------------------------
* Improved and simplified format of external files.
* Greatly improved error handling.
* Full compatibility will previous versions of Leo.</t>
<t tx="edream.110203163054.80">- Fix undo/redo bug for all commands that change body text in multiple nodes without changing outline structure.
	- This is a long-standing bug that came to light when trying to make Read @file Nodes undoable.

- Make Read @file Nodes command undoable.

- Fix small bugs in the Go To Line Number command.</t>
<t tx="edream.110203163054.81"></t>
<t tx="edream.110203163054.82">The new code prints a warning if Leo's key internal strings are not Unicode.</t>
<t tx="edream.110203163054.83"></t>
<t tx="edream.110203163054.833">The Execute Script command executes body text as a Python script. Leo execute
the selected text, or the entire body text if no text is selected.

Scripts are executed in a "pristine" environment, that is, with __builtins__ as
both the local and global environments.

New in version 4.1: Body text may now contain @directives and section
references. This is a major step forward: you can now use all of Leo's features
to organize scripts that you execute interactively.

Section definitions must appear in the node containing the script or in
descendant nodes. Leo "preprocesses" all scripts by simulating the writing of a
external file to a string.

The Execute Script command sets app.scriptDict["script1"] to the value of the
script before preprocessing, and sets app.scriptDict["script2"] to the value of
the script after preprocessing. Scripts may examine and change app.scriptDict as
they please.</t>
<t tx="edream.110203163054.84">There were bugs involving saving the "Pattern Match" and "Subroutine Only" find settings.</t>
<t tx="edream.110203163054.85">@nocolor

Class level-code after the method definitions was dropped.  For example:

@color

class someclass:
	def __init__(self):
		pass

	# this code is dropped
	class_var = None

def some_proc():
	pass</t>
<t tx="edream.110203163054.86">The new code ensures that Leo creates and uses only Unicode strings internally.</t>
<t tx="edream.110203163054.87">Fixed Go To Outline command so it doesn't crash on 4.0 files.  More work is needed.</t>
<t tx="edream.110203163054.88">Under certain conditions the no sentinels at all were written when writing @rawfile trees.</t>
<t tx="edream.110203163054.89"></t>
<t tx="edream.110203163054.90"></t>
<t tx="edream.110203163054.91">This is much more natural and less cluttered.</t>
<t tx="edream.110203163054.92"></t>
<t tx="edream.110203163054.93"></t>
<t tx="edream.110203163054.94">Leo will create the Leo icon in Leo windows automatically when using Python 2.3.
The Python Imaging Library and the tkIcon package are only used when using
previous versions of Python.</t>
<t tx="edream.110203163054.95">This is the foundation for "foreign" guis.</t>
<t tx="edream.110203163054.96"></t>
<t tx="edream.110203163054.97">allow_clone_drags

This is a workaround so that Leo may be used on Aqua. When this setting is zero
Leo always moves nodes when dragging. The default is to enable clone-drags.

enable_drag_messages

Allows the user to suppress the message telling whether dragging nodes will move
them or clone them. The default is to enable those messages.</t>
<t tx="edream.110203163054.98">After the 4.0 beta 1 release I changed the default so that _new_ format derived
files are written if leoConfig.txt does not exist.</t>
<t tx="edream.110203163054.99">leo.py 4.0 beta 1                      September 26, 2003

This is the first public release of Leo 4.0.  Version 4.0 is the culmination of over a year of collaborative design work and several months of actual implementation.

Please use caution when using this beta version of Leo.  It appears very solid and it has been tested by only a few people.

Highlights of 4.0:

** Improved and simplified format of external files.
	- Eliminated child indices, extraneous blank lines and @body sentinels.
	- Eliminated @node sentinels that indicate outline structure.
	- New @nl and @nonl sentinels indicate where newlines are and aren't.
	- These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
	- Reading external files _never_ alter outline structure or links.
	- Read errors leave the outline completely unchanged.
	- Broken clone links are gone forever.
	- As a result, using 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
	- Leo reads all external files properly, regardless of version.
	- Leo writes new-format external files by default, and this default may be changed.
	- New commands in the read/write menu allow you to explicitly specify the format of external files.

* New commands:
	- Write 3.x external file.
	- Write 4.x external file.
	- Import external file.
	- Clear Recent Files.

- Several new plugins.
- Several minor bug fixes.

See the children of this node for full details.</t>
<t tx="edream.110303182253.3">Leo does an auto-save only if something has actually been changed.</t>
<t tx="edream.110303182253.39"></t>
<t tx="edream.110303182719">The config_encoding setting controls the encoding of non-ascii characters in leoConfig.txt.

The use_gnx setting in leoConfig.txt determines whether uses gnx's (cvs friendly) or ints.  No version of Leo before 4.1 can read .leo files containing gnx.   Only gnx's are immutable.  Leo recomputes all non-gnx indices from scratch whenever writing a .leo file. It is possible to convert between 3.x and 4.1 file formats by changing the use_gnx setting.
</t>
<t tx="edream.110603185805">Leo 4.1 beta 5                   December 5, 2003

This is the fifth release of the reorganized 4.1 code base.

For the first time in months there are no serious bugs outstanding.

Warning: By default Leo 4.1 creates .leo files that can not be read by older versions of Leo.

Warning: Use the __wx_gui.py plugin with extreme caution until further notice:
bugs in this plugin could cause body text to be cleared improperly when changing nodes.

Beta 5:
  * Leo runs in batch mode when invoked with --script aScriptFile.py
    - Created "null gui" classes that do not use any gui code.
  * Leo supports Unicode characters (e.g. Chinese) in path and file names.
  * Fixed several long-standing bugs:
    - Fixed several minor problems with the Extract Section and Import commands.
    - Fixed problem that prevent the Find panel from working on the Mac.
    - Improved @url handling so that @url file:\\path\x.leo works properly.
    - Improved support for @lineending platform.
    - Leo honors outline/body pane ratio when opening .leo files.
    - Leo now ensures that newly-opened windows fit entirely on the screen.
    - Fixed a crasher when Undoing a Change All command when searching headlines.
  - Fixed other bugs resulting from the 4.1 reorg:
    - Fixed problem loading plugins on Linux.
    - Fixed crashers in the Extract Section and Extract commands.
    - Fixed a crasher when writing a file containing an undefined section.
    - Removed duplicate bindings in popup menus.
    - Made sure to show Leo's windows in wx gui plugin.

Beta 4:
  - Fixed several "reorg" bugs, some of which affected plugins.
  - Allow @directives and section references when executing scripts!
  - More than one section reference may now appear on the same line.
  - Use "utf-8" encoding for filenames under MacOS (Darwin)
  - Allow command or cmnd prefix for menu shortcuts under Darwin.
	  
Beta 3:
  - Completed the reorg, making many changes to the code base.
  - Fixed a LaTeX coloring bug

Beta 2:
  - Fixed a startup problem on Linux: the "mbcs" text encoding is not valid on Linux.

Beta 1:
  * Script-based find/change commands.
  - Hoist &amp; DeHoist commands for viewing parts of an outline.
  - Check Outline command finds user clone mistakes.
  * New configuration settings:
    - use_gnx specifies whether .leo files use integers as indices:
      use_gnx = 0 makes .leo files compatible with previous versions of Leo.
      use_gnx = 1 makes .leo files cvs-friendly
    - config_encoding specifies the encoding of leoConfig.txt.
  * Several significant code-level changes:
    - The 4.1 code base has been reorganized to support gui plugins.
    - An example wx_gui plugin is partly functional.
    - Created a flexible framework for creating &amp; running regression tests.
    - app.forceShutdown now works when called from plugins.</t>
<t tx="edream.110603190125.1">Leo 4.1 uses immutable gnx's (id:timestamp:n) by default to associate tnodes with vnodes in .leo files.  This makes Leo as cvs friendly as possible.  From now on .leo files will be checked in to cvs with the -ko (text/keywords off) option.</t>
<t tx="edream.110603190125.3">The file test.leo in the test directory contains real regression tests for syntax coloring.   Regression testing scripts create regression tests dynamically from data in Leo's outline.  Very cool, very easy, very general.  In particular, regression tests may use temporary nodes in test.leo rather than creating separate Tk windows for testing.</t>
<t tx="edream.110603190125.4">The 4.1 code base has been reorganized to support gui's other than tkinter.  Leo's src directory contains several new source files.

This reorg affects almost all plugins.  Considerably more work and testing will be done before 4.1 final.

The __wx_gui.py plugin is uses the newly reorganized code.  It is functional except for gui-dependent commands like Toggle-Split Direction.  WARNING: treat the this plugin with extreme caution until further notice.  The possibility exists that bugs in the code could cause body text to be cleared improperly when changing nodes.</t>
<t tx="edream.110603190234.1"></t>
<t tx="edream.110603190322.10"></t>
<t tx="edream.110603190322.11">The node-only option wasn't working due to a bug in createFrame.

There still may be a problem with the interaction between Node-only,Change All and Undo.</t>
<t tx="edream.110603190322.13">The fix was to open files with 'rb' instead of 'r'.  This probably should be done in more places.</t>
<t tx="edream.110603190322.14">This command checks for unused tnodeLists and checks the topology of all clones.</t>
<t tx="edream.110603190322.15">The Hoist command redraws the screen so presently selected tree becomes the only visible part of the outline.  Leo prevents the you from moving nodes outside the hoisted outline.  The De-hoist command restores the outline.  Hoist commands may be nested.</t>
<t tx="edream.110603190322.3">This involved fixing a bug in idle_body_key so that the oldText param is honored if present.</t>
<t tx="edream.110603190322.6">@nocolor

New in 4.1: Leo now supports scripts in Leo's Find/Change dialog.

Leo's find panel now contains the Script Search radio button and the Script
Change checkbox. When the Script Search radio button is selected Leo treats the
contents of the Search Text as a script to execute whenever any kind of Find
command is executed. Similarly, when the Script Change checkbox is selected Leo
treats the context of the Change Text as a script to execute whenever any kind
of Change command is executed. See below for just how this works.

Script-based find-change is extremely powerful. In effect, Leo's Find/Change
panel becomes a new platform for running scripts interactively. Leo now has all
the find/change capability of pattern matching languages like Snobol and Icon,
just by using the capabilities of the plain Python language. Moreover, Leo can
deliver these capabilities interactively or not depending which buttons you push
in Leo's Find/Change panel.

Script-based find/change frees the user from having to control script-based
searches interactively. Rather than forcing find/change scripts to implement
their own interactive controls, it is much easier to use what Leo already has.</t>
<t tx="edream.110603190322.8">Undoing Change All cleared the body pane or the headline pane.

The fix was simple: call setUndoParams instead of setUndoTypingParams in batchChange.</t>
<t tx="edream.110603190322.9"></t>
<t tx="edream.110603190404"></t>
<t tx="edream.110603192009"></t>
<t tx="edream.110603192009.1"></t>
<t tx="edream.111803060152"></t>
<t tx="edream.111803060152.1">Leo dedicates a Python dictionary called app.searchDict for communication
between Leo and the search and change scripts. The search and change scripts may
also use app.searchDict for communication between themselves. Leo sets
app.searchDict["type"] to "find", "change", "findAll" or "changeAll" to indicate
the kind of command being executed. Scripts may use all other entries in
app.searchDict as they please.

Leo executes the find script once when you press the Find button (or the Change
then Find button) in Leo's Find/Change dialog. Typically, the find script would
traversing the tree and highlight the found text or otherwise indicate to the
user that the find operation has succeeded. However, the script can do anything
it pleases.

Leo executes the the find script repeatedly when you press the Find All button.
Leo keeps executing the find script until app.searchDict["continue"] evaluates
to false. Initially there is no entry for app.searchDict["continue"], so the
find script must set app.searchDict["continue"] = true if it wants Leo to keep
executing it.

Leo executes the change script once when you press the Change button. Typically,
the change script would change the selected text. Usually the change script will
compute the new value of body text and call c.setBodyString(p,newText) to
make that change permanent. 

The change script also may handle undo, typically by calling
c.frame.onBodyChanged(v,"Change",oldText=oldText). Leo does not handle undo
automatically. Indeed, Leo makes no assumptions whatever about what the change
script really does.

Leo executes the the change script repeatedly when you press the Change All
button. Just as with the Find All command, Leo keeps executing the change script
until app.searchDict["continue"] evaluates to false.

Most find and change scripts will ignore settings in the Find Panel like "whole
word", "pattern match", and "reverse". However, these settings are available to
the scripts via ivars such as c.whole_word_flag, etc. if desired.</t>
<t tx="edream.111803060152.2">@nocolor

Some ideas for using scripts:
	
Either the find and change scripts may use Python's re module.  For
example, the find script could set app.searchDict["m"] to the match object
returned by re's match method.  The change script would then compute the
result, change the text and set the undo info as usual.

There is no reason to confine find/change scripts to operate on data only
within a Leo outline. These scripts could as easily traverse your file system
as the Leo outline. But notice: scripts could pull data from the file system
into the outline so that you can see the effects of changes as the scripts
operate. Again, this can all happen interactively if you like.</t>
<t tx="edream.111803060643"></t>
<t tx="edream.111803062437"></t>
<t tx="edream.112303173638">@color
@  New in version 4.1: On startup, Leo looks for two arguments of the form --script scriptFile.  If found, Leo enters batch mode.

In batch mode Leo does not show any windows.  Leo assumes the scriptFile contains a Python script and executes the contents of that file using Leo's Execute Script command.  By default, Leo sends all output to Leo's log pane to the console window.  Scripts in the scriptFile may disable or enable this output by calling app.log.disable() or app.log.enable()

Scripts in the scriptFile may execute any of Leo's commands except the Edit Body and Edit Headline commands.  Those commands require interaction with the user.

For example, the following batch script reads a Leo file and prints all the headlines in that file.
@c

import leoGlobals as g

path = r"c:\prog\leoCVS\leo\test\test.leo"

g.app.log.disable() # disable reading messages while opening the file
flag,newFrame = g.openWithFileName(path,None)
g.app.log.enable() # re-enable the log.

for p in newFrame.c.all_positions():
	g.es(g.toEncodedString(p.headString(),"utf-8"))</t>
<t tx="edream.120403174147"></t>
<t tx="edream.120403174147.102">Another 4.1 reorg bug.</t>
<t tx="edream.120403174147.105">This bug has been around for a long time.</t>
<t tx="edream.120403174147.109">The new code attempts to use bitmap files only on Windows.</t>
<t tx="edream.120403174147.112">Leo makes sure that opened files or newly-created outlines fit entirely on the screen.  The Cascade commands leaves the sizes of windows unchanged: it merely ensures that the top left corner of a window is visible on the screen.</t>
<t tx="edream.120403174147.119"></t>
<t tx="edream.120403174147.128">@ A problem: the new window gets put behind the old.  This is probably because Tk thinks that the mouse-down event should select then new window...</t>
<t tx="edream.120403174147.30">Another 4.1 reorg bug.</t>
<t tx="edream.120403174147.33">This was due to a missing activate event.</t>
<t tx="edream.120403174147.36">Continuation lines caused the import command to terminate functions, methods and classes prematurely.</t>
<t tx="edream.120403174147.56"></t>
<t tx="edream.120403174147.61">This was causing Leo not to load plugins properly on Linux.  The problem was that the imp module does not handle Unicode file names properly.</t>
<t tx="edream.120403174147.63">This was a reorg bug.</t>
<t tx="edream.120403174147.65">Another bug caused by the 4.1 reorg.</t>
<t tx="edream.120403174147.94">- Leo now properly enables and disables the Extract Section menu item.
- Leo no longer removes leading forward slashes in section names in headlines.
- Corrected the documentation for the Extract Section command.</t>
<t tx="edream.120403174241"></t>
<t tx="edream.120403180443"></t>
<t tx="edream.120403180443.1"></t>
<t tx="edream.121403160546">Leo 4.1 Release Candidate 3              December 19, 2003

This release fixes a serious bug in the logic that reads old-style external files.

There are no known bugs in this version of Leo.

The highlights of this release:

- Leo runs in batch mode when invoked with --script aScriptFile.py
- Leo supports Unicode characters (e.g. Chinese) in path and file names.
- @directives and section references are now valid when executing scripts.
- @ignored and orphan nodes now valid in @file-nosent trees.
- Script-based find/change commands.
- Check Outline command.
- Hoist &amp; DeHoist commands.
- A new gui-agnostic architecture: useful for batch mode and unit tests.
- Several new configuration settings.
- Many new unit tests.
- A host of bug fixes.</t>
<t tx="edream.121403161017">See previous release notes for more details:

- Fixed several minor problems with the Extract Section and Import commands.
- Fixed problem that prevent the Find panel from working on the Mac.
- Improved @url handling so that @url file:\\path\x.leo works properly.
- Improved support for @lineending platform.
- Leo honors outline/body pane ratio when opening .leo files.
- Leo now ensures that newly-opened windows fit entirely on the screen.
- Fixed a crasher when Undoing a Change All command when searching headlines.
- Fixed other bugs resulting from the 4.1 reorg:
- Fixed problem loading plugins on Linux.
- Fixed crashers in the Extract Section and Extract commands.
- Fixed a crasher when writing a file containing an undefined section.
- Removed duplicate bindings in popup menus.
- Made sure to show Leo's windows in wx gui plugin.
- More than one section reference may now appear on the same line.
- Use "utf-8" encoding for filenames under MacOS (Darwin)
- Allow command or cmnd prefix for menu shortcuts under Darwin.
- Fixed a LaTeX coloring bug
</t>
<t tx="edream.121403161017.1">- The 4.1 code base has been reorganized to support gui plugins.
- Created a flexible framework for creating &amp; running regression tests.
- app.forceShutdown now works when called from plugins.
- Created app.unitTestDict for communication between tests and between tests and code.

- An example wx_gui plugin is partly functional.

	Warning: Use the __wx_gui.py plugin with extreme caution until further notice:
	bugs in this plugin could cause body text to be cleared improperly when changing nodes.
</t>
<t tx="edream.121403161017.2">- use_gnx specifies whether .leo files use integers as indices:
  
	use_gnx = 0 makes .leo files compatible with previous versions of Leo.
	use_gnx = 1 makes .leo files cvs-friendly

- config_encoding specifies the encoding of leoConfig.txt.</t>
<t tx="edream.121403161340">- Import External File command now uses a file dialog.

	This is much more natural than using @file nodes.
</t>
<t tx="edream.121403165221">- Corrected counts when replacing tabs/blanks.
- Don't write tnodeList when executing scripts.
- Fixed long-standing clone-drag bug.
- Fixed inconsistency between how 4.x and 3.x handle @others.
  The code now works as it did in all 3.x versions, namely
  @others does not terminate doc parts.
- Leo now properly sets clone marks when when cutting and pasting nodes.
- Only double-quotes delimit strings in html files.
  This bug prevented Leo from untangling some valid html/xml files.
- Leo now puts class docstrings in class nodes when importing .py files.
- Fixed several reorg bugs.</t>
<t tx="ekr.20040131040356">Leo 4.1 Release Candidate 4              February 3, 2004

This release fixes numerous bugs reported since 4.1 rc3 and makes several other
minor improvements, including several nifty new plugins.

The highlights of Leo 4.1:

- Leo runs in batch mode when invoked with --script aScriptFile.py
- Leo supports Unicode characters (e.g. Chinese) in path and file names.
- @directives and section references are now valid when executing scripts.
- @ignored and orphan nodes now valid in @file-nosent trees.
- Script-based find/change commands.
- Check Outline command.
- Hoist &amp; DeHoist commands.
- A new gui-agnostic architecture: useful for batch mode and unit tests.
- Several new configuration settings.
- Many new unit tests.
- Excellent new plugins.
- A host of bug fixes.</t>
<t tx="ekr.20040131040356.1"></t>
<t tx="ekr.20040131040356.2">See previous release notes for more details:

4.1 rc3:

- Corrected counts when replacing tabs/blanks.
- Don't write tnodeList when executing scripts.
- Fixed long-standing clone-drag bug.
- Fixed inconsistency between how 4.x and 3.x handle @others.
  The code now works as it did in all 3.x versions, namely
  @others does not terminate doc parts.
- Leo now properly sets clone marks when when cutting and pasting nodes.
- Only double-quotes delimit strings in html files.
  This bug prevented Leo from untangling some valid html/xml files.
- Leo now puts class docstrings in class nodes when importing .py files.
- Fixed several reorg bugs.

4.1 rc2, rc1, betas, alphas:

- Fixed several minor problems with the Extract Section and Import commands.
- Fixed problem that prevent the Find panel from working on the Mac.
- Improved @url handling so that @url file:\\path\x.leo works properly.
- Improved support for @lineending platform.
- Leo honors outline/body pane ratio when opening .leo files.
- Leo now ensures that newly-opened windows fit entirely on the screen.
- Fixed a crasher when Undoing a Change All command when searching headlines.
- Fixed other bugs resulting from the 4.1 reorg:
- Fixed problem loading plugins on Linux.
- Fixed crashers in the Extract Section and Extract commands.
- Fixed a crasher when writing a file containing an undefined section.
- Removed duplicate bindings in popup menus.
- Made sure to show Leo's windows in wx gui plugin.
- More than one section reference may now appear on the same line.
- Use "utf-8" encoding for filenames under MacOS (Darwin)
- Allow command or cmnd prefix for menu shortcuts under Darwin.
- Fixed a LaTeX coloring bug
</t>
<t tx="ekr.20040131040356.3">- The 4.1 code base has been reorganized to support gui plugins.
- Created a flexible framework for creating &amp; running regression tests.
- app.forceShutdown now works when called from plugins.
- Created app.unitTestDict for communication between tests and between tests and code.

- An example wx_gui plugin is partly functional.

	Warning: Use the __wx_gui.py plugin with extreme caution until further notice:
	bugs in this plugin could cause body text to be cleared improperly when changing nodes.
</t>
<t tx="ekr.20040131040356.4">- use_gnx specifies whether .leo files use integers as indices:
  
	use_gnx = 0 makes .leo files compatible with previous versions of Leo.
	use_gnx = 1 makes .leo files cvs-friendly

- config_encoding specifies the encoding of leoConfig.txt.</t>
<t tx="ekr.20040131040356.5">- Import External File command now uses a file dialog.

	This is much more natural than using @file nodes.</t>
<t tx="ekr.20040131040544.10">This allows plugins to draw the status area in the icon area.</t>
<t tx="ekr.20040131040544.146">- Leo now does a better job of checking and reporting read-only violations.

- Leo now clears the file-dirty mark only if the file was successfully saved.

</t>
<t tx="ekr.20040131040544.169"></t>
<t tx="ekr.20040131040544.178">Leo sets only ancestor @file nodes dirty (not nodes themselves) when altering
outline structure, i.e., when moving, inserting, deleting, cloning and sorting
nodes.</t>
<t tx="ekr.20040131040544.18">The old code was concatenating strings; the new code uses list.append.</t>
<t tx="ekr.20040131040544.2"></t>
<t tx="ekr.20040131040544.21">- ESC closes the Find panel.

- Hitting the Return key is now equivalent to hitting the Find button.</t>
<t tx="ekr.20040131040544.222">That is, when preprocessing the script (expanding section references, etc.) Leo
now ensures that child nodes effectively end in a newline. This prevents
unintended concatenation of lines.</t>
<t tx="ekr.20040131040544.227">A contained a space before a tab in the leading whitespace of the line.</t>
<t tx="ekr.20040131040544.228">- These commands did not properly count the number of changed nodes.
- These commands now mark only changed nodes as dirty.</t>
<t tx="ekr.20040131040544.258"></t>
<t tx="ekr.20040131040544.32"></t>
<t tx="ekr.20040131040544.5"></t>
<t tx="ekr.20040131040544.55">Leo now reports the parent of the orphan node.</t>
<t tx="ekr.20040131040544.73">This bug happened when a move up command would cause a node to become the
sibling of (a clone of) itself. In such cases, Leo simply selects the other
cloned copy of the moved node.</t>
<t tx="ekr.20040131040544.81">The bug was causing Leo not to remember the comment delimiters in the @+leo
sentinel. As a result, Leo was recognizing no sentinels and the command
complained about missing @-leo sentinels.</t>
<t tx="ekr.20040131040754">Fixed crashers in:

- Insert Headline Time/Date commands.
- Change headline command.
- Write Dirty/Missing @file Nodes commands.
- Batch mode.</t>
<t tx="ekr.20040131041015"></t>
<t tx="ekr.20040131044136">- Fixed a bug that caused cut and paste operations in headlines to revert when those commands were chosen from the Edit menu.

- Extended control-v bug fix to "darwin","freebsd4","freebsd5"

- Cut and paste are now always enabled when not editing the body pane.  This isn't perfect, and is an improvement.</t>
<t tx="ekr.20040131044727">1. Fixed a bug that caused improper indentation of sections.

The bug happened in some cases when a section reference occurred following non-whitespace.

2. Leo ensures that leading whitespace is not added when writing empty lines.

This might fix the "Zope Sprint" bug: "blank" lines in the expansion of @others got leading whitespace.</t>
<t tx="ekr.20040131100557">Previously, if you hoist a node with no children and then insert a node (CTRL-I)
then the child is created as a sibling of the hoisted node and consequently is
not displayed.

Leo now creates the new node as the first child of the hoisted node. 

Also, Leo disables the Clone command when the presently selected node is the root of a hoist.</t>
<t tx="ekr.20040201061329">This creates a status area at the bottom of the Leo Window. Plugins may write to
this area using the status area convenience routines in leoTkinterFrame.py.</t>
<t tx="ekr.20040201113232">@nocolor

The Scripts node in LeoPy.leo contains a script called initScriptFind.  This script makes it easy to set up script based searches as follows:

1. Put the following code in the root of a tree that will contain your script search:

@color
# Initialize Leo's find panel using the named children of this node.
from leoGlobals import *
initScriptFind("Find script","Change script") # Second argument is optional.
# Start searching at the top.
top().selectVnode(c.rootVnode())
@nocolor

2. Put the search script in a child node called "Find script" (no quotes).

3. (Optional) Put the change script in a child node called "Change script"

4.  Execute the code above.  Leo does the following:

- Puts the body of the "Find script" into the find text of Leo's Find/Change dialog.
- Puts the body of the "Change script" into the change text of Leo's Find/Change dialog.
- Selects the Script Find radio button.
- Selects the Script Change checkbox if the change script exists.
- Selects the root of the entire outline.

Presto!  Leo is ready for a script search.</t>
<t tx="ekr.20040201114855"></t>
<t tx="ekr.20040201114855.105"></t>
<t tx="ekr.20040201114855.106"></t>
<t tx="ekr.20040201114855.107">This bug happened when executing the initScriptFind script.  This bug could cause Leo not to be able to save files.</t>
<t tx="ekr.20040201114855.13">Adds a quick search to the toolbar in Leo.

A search box which behaves like a web site search is added, along with a "GO"
button to do quick searches right from the main Leo window. All the current
search options are retained except that "search body text" is explicitly set -
mainly because this is by far the most common use case.

Pressing &lt;CR&gt; while editing the text automatically does a search. Repeated
searches can be done by clicking the "GO" button.

The combo box also stores a list of previous searches, which can be selected to
quickly repeat a search. When activating a previous search the original search
mode is used.

Still to do:

- incremental search
- reverse search
- persist recent searches across Leo sessions
- use INI file to set options for list size, etc.</t>
<t tx="ekr.20040201114855.29">Adds a node navigator to the toolbar. The navigator allows quick access to
marked nodes. You can either go to the marked node or hoist the marked node.</t>
<t tx="ekr.20040201114855.3">This plugin uses Leo and docutils to mix program code and reST documentation.

The Python docutils package must be installed.http://docutils.sourceforge.net

If SilverCity is installed (http://silvercity.sourceforge.net) the plugin
produces HTML output that is syntax colored.

The basic approach is that any Leo node that contains program code that needs
documentation (in an ideal world it would be every node) has an associated child
node whose headline is simply '@rst', that contains reST-style documentation.
While this means that a typical program may have dozens (if not hundreds) of
these @rst nodes, it produces documentation that I think is as close as I have
ever seen to useful, easy-to-read documentation that is easy to create at the
same time as an application is being coded.

There are several interrelated aspects to this work:

- The reST plugin (renamed rst2) was hacked to manage Leo outlines that were a
combination of normal code nodes and reSt nodes.

- The plugin now recognizes a @rst directive (that has no associated file name)
in the headline of a node.

- When it encounters such a @rst Headline node, it writes the contents of the
body of the @rst node's *parent* (which generally contains program code) to the
reST output file (HTML) and then adds the reST content that is contained in the
body of the @rst documentation node to the output HTML file,

- These @rst nodes are used in @file-nosent trees and the @rst nodes have an 
@ignore directive (plus @nocolor directive and @wrap directives) so that 
when the @file is updated the application code does not contain the reST-style
documentation contained in the body of the @rst nodes. (This was the reason I
had asked you in the Leo Forum to allow @file-nosent trees to work appropriately
with @ignore nodes - Thank you for doing this right away.) There is no reason
that the reST content couldn't be written to the 
@file as documentation other than I personally believe in a volume of 
documentation (including musings, failed ideas, questions, etc.) that is 
probably best kept separate from the actual *.py files.

- When you double-click on a plain rst node (no associated filename) Leo opens
both the @rst documentation node and the parent node containing code in an
external editor *simultaneously*. I happen to use Textpad and so the code is
opened with python syntax coloring in one Textpad window and right next to it is
the reST documentation. This makes it much much easier to code and do
documentation at the same time. (Note that the plugin assumes that the python
extension is '.tp' since that is what I use with TextPad.)

So why is this a big deal?

For the first time in my experience the documentation process:

1) is completely in sync with the process of code development.

2) allows the programmer to write as much documentation as he/she wants without
the programming code becoming unreadable because of what would be considered
excessive or intrusive documentation. (This applies whether documentation is
intended for external consumption or just so a solo programmer can remember what
he/she was thinking...)

My conclusion is that Leo + reST/docutils provides the perfect platform for
optimal documentation. I have never completely understood what is meant by
Literate Programming but in my mind this is practical Literate Programming.

Frankly, I think this is all a minor miracle but maybe I've lost perspective.

Steve Zatz</t>
<t tx="ekr.20040201114855.36">Adds row/column indicators to the toolbar at the top of Leo Windows.</t>
<t tx="ekr.20040201114855.42">A minimal http plugin for LEO, based on AsyncHttpServer.py.

Use this plugin is as follows:

1. Start Leo with the plugin enabled. You will see a purple message that says
something like: "http serving enabled on port 8080, version 0.9"

2. Start a web browser, and enter the following url: http://localhost:8080/
You will see a a "top" level page containing one link for every open .leo file.
Start clicking :-)

You can use the browser's refresh button to update the top-level view in the
browser after you have opened or closed files.</t>
<t tx="ekr.20040201114855.91">Automatically add nodes for common tasks. This can be used to generate boiler
plate code to quickly build an outline.</t>
<t tx="ekr.20040201120903">Adds a status line to the bottom of Leo windows.</t>
<t tx="ekr.20040203084228">The Change All command was looping when the find pattern was '\n'.</t>
<t tx="ekr.20040216151748">Leo 4.1 Final              February 20, 2004

Leo 4.1 Final is the culmination of four months of work. No significant bugs
have been reported since 4.1 rc4. Several people have contributed nifty plugins
recently. See leoPlugins.leo for full details.

The highlights of Leo 4.1:

- Leo runs in batch mode when invoked with --script aScriptFile.py
- Leo supports Unicode characters (e.g. Chinese) in path and file names.
- @directives and section references are now valid when executing scripts.
- @ignored and orphan nodes now valid in @file-nosent trees.
- Script-based find/change commands.
- Check Outline command.
- Hoist &amp; DeHoist commands.
- A new gui-agnostic architecture: useful for batch mode and unit tests.
- Several new configuration settings.
- Many new unit tests.
- Excellent new plugins.
- A host of bug fixes.</t>
<t tx="ekr.20040216152948"></t>
<t tx="ekr.20040216153725">Changed Undo/Redo messages:

- Insert Outline to Insert Node.
- Delete Outline to Delete Node.
- Clone to Clone Node.

This is a real code change: it affects the undo/redo logic.</t>
<t tx="ekr.20040217075627">Clone bits could be improperly set in some cases.  This bug would not have caused serious long-term problems.

Steps to reproduce:

1. Create a parent node (named 'cloned').
2. Create two children nodes (one named 'dummy' and another named 'bottom') under the parent node 'cloned'.
3. Move the 'bottom' node below the 'dummy' node.
4. Clone node 'cloned'.
5. Copy node 'dummy'.
6. Paste node 'dummy' in between 'dummy' and 'bottom'.
7. After pasting you'll see that 'bottom' is now marked as a cloned node.</t>
<t tx="ekr.20040217085036">See leoPlugins.leo for full details.</t>
<t tx="ekr.20040217085036.1">Here is the bug report I submitted to Python:

The documentation for encoding lines at

C:\Python23\Doc\Python-Docs-2.3.1\whatsnew\section-encodings.html

states:

"Encodings are declared by including a specially formatted comment in the
first or second line of the source file."

In fact, contrary to the implication, the Python 2.3 parser does not look
for lines of the form:

# -*- coding: &lt;encoding&gt; -*-

For example, Python improperly scans the following line for an encoding

#@+leo-ver=4-encoding=iso-8859-1.

and reports that iso-8859-1. (note trailing dot) is an invalid encoding!

The workaround for my app is to precede this line with the following line:

# -*- coding: iso-8859-1 -*-

This makes Python 2.3 happy.

To make myself perfectly clear: Python has absolutely no right to complain
about comment lines that do not have the form:

# -*- coding: &lt;encoding&gt; -*-</t>
<t tx="ekr.20040403171740">@ @rst-options
.. A very cool option: doc parts will be rendered properly,
.. but will be ignored by the Execute script command.
..
show_doc_parts_as_paragraphs = True
@c

####################################
Chapter 7: Scripting Leo with Python
####################################

This chapter describes how to write Python scripts that control Leo and access
the data in Leo outlines. To write such scripts, you must understand the basics
of Leo's internal data structures. As we shall see, these basics are quite simple.

Although this chapter discussses everything you will need to write most scripts,
please keep in mind that your scripts have complete access to all of Leo's
source code, that is, all the code in LeoPy.leo.

**Note**: If you are reading this documentation in leoDocs.leo you can execute
all code examples in this chapter by running the Execute Script command
(Ctrl-B). You may have to select the actual code to execute if a node contains
comments interspersed with the code.

.. .. contents::</t>
<t tx="ekr.20040403173920.10" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313322206e616d653d22687474702d6e6f64652d6d61726b65722d3133223e710158040000003c2f613e71025d710328582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e65656565582b0000003c64697620636c6173733d2273656374696f6e222069643d22632d616c6c6e6f6465732d69746572223e0a710f58570000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643722206e616d653d22632d616c6c6e6f6465732d69746572223e632e616c6c4e6f6465735f697465723c2f613e3c2f68323e0a7110652e">The c.all_positions generator returns a list of all positions in the outline.
This script makes a list of all the nodes in an outline::

    nodes = list(c.all_positions())
    print("This outline contains %d nodes" % len(nodes))
    
The c.all_unique_positions generator returns a list of all unique positions in the outline.
For each vnode v in the outline, exactly one position p is returned such that p.v == v.

This script prints the *distinct* vnodes of an outline::

    for p in c.all_unique_positions():
        sep = g.choose(p.hasChildren(),'+','-')
        print('%s%s %s' % (' '*p.level(),sep,p.h))
</t>
<t tx="ekr.20040403173920.13" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313522206e616d653d22687474702d6e6f64652d6d61726b65722d3135223e710158040000003c2f613e71025d710328582a0000003c64697620636c6173733d2273656374696f6e222069643d22632d616c6c6e6f6465732d69746572223e710458060000003c2f6469763e71055d710628582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a7112582b0000003c64697620636c6173733d2273656374696f6e222069643d22702d6368696c6472656e2d69746572223e0a711358570000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643822206e616d653d22702d6368696c6472656e2d69746572223e702e6368696c6472656e5f697465723c2f613e3c2f68323e0a7114652e">The p.children generator returns a list of all children of position p::

    parent = p.parent()
    print("children of %s" % parent.h)
    for p in parent.children():
        print(p.h)</t>
<t tx="ekr.20040403173920.14" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313722206e616d653d22687474702d6e6f64652d6d61726b65722d3137223e710158040000003c2f613e71025d710328582a0000003c64697620636c6173733d2273656374696f6e222069643d22702d6368696c6472656e2d69746572223e710458060000003c2f6469763e71055d710628582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a711258460000003c64697620636c6173733d2273656374696f6e222069643d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e0a7113588d0000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643922206e616d653d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e702e706172656e74735f6974657220616e6420702e73656c665f616e645f706172656e74735f697465723c2f613e3c2f68323e0a7114652e">The p.parents generator returns a list of all parents of position p,
excluding p::

    current = p.copy()
    print("exclusive of %s" % (current.h),color="purple")
    for p in current.parents():
        print(p.h)

The p.self_and_parents generator returns a list of all parents of position
p, including p::

    current = p.copy()
    print("inclusive parents of %s" % (current.h),color="purple")
    for p in current.self_and_parents():
        print(p.h)    </t>
<t tx="ekr.20040403173920.15" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313922206e616d653d22687474702d6e6f64652d6d61726b65722d3139223e710158040000003c2f613e71025d71032858450000003c64697620636c6173733d2273656374696f6e222069643d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e710458060000003c2f6469763e71055d710628582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a711258490000003c64697620636c6173733d2273656374696f6e222069643d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e0a711358940000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313022206e616d653d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e702e7369626c696e67735f6974657220616e6420702e666f6c6c6f77696e675f7369626c696e67735f697465723c2f613e3c2f68323e0a7114652e">The p.siblings generator returns a list of all siblings of position p::

    current = c.p
    print("all siblings of %s" % (current.h),color="purple")
    for p in current.self_and_siblings():
        print(p.h)

The p.following_siblings generator returns a list of all siblings that
follow position p::

    current = c.p
    print("following siblings of %s" % (current.h),color="purple")
    for p in current.following_siblings():
        print(p.h)</t>
<t tx="ekr.20040403173920.16" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323122206e616d653d22687474702d6e6f64652d6d61726b65722d3231223e710158040000003c2f613e71025d71032858480000003c64697620636c6173733d2273656374696f6e222069643d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e710458060000003c2f6469763e71055d710628582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a711258460000003c64697620636c6173733d2273656374696f6e222069643d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e0a7113588e0000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313122206e616d653d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e702e737562747265655f6974657220616e6420702e73656c665f616e645f737562747265655f697465723c2f613e3c2f68323e0a7114652e">The p.subtree generator returns a list of all positions in p's subtree, excluding p::

    parent = p.parent()
    print("exclusive subtree of %s" % (parent.h),color="purple")
    for p in parent.subtree():
        print(p.h)

The p.self_and_subtree generator returns a list of all positions in p's subtree, including p::

    parent = p.parent()
    print("inclusive subtree of %s" % (parent.h),color="purple")
    for p in parent.self_and_subtree():
        print(p.h)</t>
<t tx="ekr.20040403173920.17" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323522206e616d653d22687474702d6e6f64652d6d61726b65722d3235223e710158040000003c2f613e71025d710328583e0000003c64697620636c6173733d2273656374696f6e222069643d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e710458060000003c2f6469763e71055d710628582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a711258070000003c2f6469763e0a7113582f0000003c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e0a711458600000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313322206e616d653d227570646174696e672d7468652d73637265656e223e5570646174696e67207468652073637265656e3c2f613e3c2f68313e0a7115652e">You can use c.redraw_now to redraw the entire screen immediately::

    c.redraw_now()

However, it is usually better to *request* a redraw to be done later as follows::

    c.redraw()

Leo actually redraws the screen in c.outerUpdate, provided that a redraw has been requested.
Leo will call c.outerUpdate at the end of each script, event handler and Leo command.</t>
<t tx="ekr.20040403173920.18" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323722206e616d653d22687474702d6e6f64652d6d61726b65722d3237223e710158040000003c2f613e71025d710328582e0000003c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f583a0000003c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e0a711058760000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313422206e616d653d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e496e766f6b696e6720636f6d6d616e64732066726f6d20736372697074733c2f613e3c2f68313e0a7111652e">Leo dispatches commands using c.doCommand,
which calls the "command1" and "command2" hook routines for the given label.
c.doCommand catches all exceptions thrown by the command::

    c.doCommand(c.markHeadline,label="markheadline")

You can also call command handlers directly so that hooks will not be called::

    c.markHeadline()

You can invoke minibuffer commands by name.  For example::

    c.executeMinibufferCommand('open-outline')

c.keyHandler.funcReturn contains the value returned from the command.
In many cases, as above, this value is simply 'break'.</t>
<t tx="ekr.20040403173920.19" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323922206e616d653d22687474702d6e6f64652d6d61726b65722d3239223e710158040000003c2f613e71025d71032858390000003c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f583b0000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e0a711058780000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313522206e616d653d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e47657474696e6720616e642073657474696e6720707265666572656e6365733c2f613e3c2f68313e0a7111652e">Each commander maintains its own preferences.
Your scripts can get the following ivars::

    ivars = (
        'output_doc_flag',
        'page_width',
        'page_width',
        'tab_width',
        'tangle_batch_flag',
        'tangle_directory',
        'target_language',
        'untangle_batch_flag',
        'use_header_flag',
    )

    print("Prefs ivars...\n",color="purple")
    for ivar in ivars:
        print(getattr(c,ivar))

If your script sets c.tab_width your script may call f.setTabWidth to redraw the screen::

    c.tab_width = -4    # Change this and see what happens.
    c.frame.setTabWidth(c.tab_width)</t>
<t tx="ekr.20040403173920.21" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333122206e616d653d22687474702d6e6f64652d6d61726b65722d3331223e710158040000003c2f613e71025d710328583a0000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f58500000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e0a711058a20000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313622206e616d653d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e46756e6374696f6e7320666f722066696e64696e6720616e64206368616e67696e6720746578742066726f6d20736372697074733c2f613e3c2f68313e0a7111652e">The file leoFindScript.py contains functions for finding and changing text
from within scripts.  See leoFindScript.py in LeoPy.leo for full details.

The findall function returns a list of tuples (v,pos) describing matches in
c's entire tree::

    import leo.scripts.leoFindScript as leoFindScript

    pattern="import leo.core.leoGlobals as g"
    result = leoFindScript.findAll(c,pattern,bodyFlag=1)

    print("%-3d instances of: '%s'...\n" % (len(result),pattern),color="purple")

    for v,pos in result:
        body = v.b
        print('\n%-4d %s' % (pos,v.h))
        print(g.get_line_after(body,pos))

The reFindall function returns a list of tuples (v,mo,pos), where mo
is a MatchObject. The reFlags argument are flags to re.search::

    import leo.scripts.leoFindScript as leoFindScript

    pattern="from .* import"
    result = leoFindScript.reFindAll(c,pattern,bodyFlag=1,reFlags=None)

    print("%-3d instances of: '%s'...\n" % (len(result),pattern),color="purple")
    for v,mo,pos in result:
        body = v.b
        print('\n%-4d %s' % (pos,v.h))
        print(g.get_line_after(body,pos))</t>
<t tx="ekr.20040403173920.24" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333722206e616d653d22687474702d6e6f64652d6d61726b65722d3337223e710158040000003c2f613e71025d71032858260000003c64697620636c6173733d2273656374696f6e222069643d22672d726566696e64616c6c223e710458060000003c2f6469763e71055d710628584f0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a711258070000003c2f6469763e0a711358350000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e0a7114586c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313922206e616d653d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e52756e6e696e67204c656f20696e206261746368206d6f64653c2f613e3c2f68313e0a7115652e">On startup, Leo looks for two arguments of the form::

    --script scriptFile

If found, Leo enters batch mode. In batch mode Leo does not show any windows.
Leo assumes the scriptFile contains a Python script and executes the contents of
that file using Leo's Execute Script command. By default, Leo sends all
output to the console window. Scripts in the scriptFile may disable or enable
this output by calling app.log.disable or app.log.enable

Scripts in the scriptFile may execute any of Leo's commands except the Edit Body
and Edit Headline commands. Those commands require interaction with the user.
For example, the following batch script reads a Leo file and prints all the
headlines in that file::

    path = r"c:\prog\leoCVS\leo\test\test.leo"

    g.app.log.disable() # disable reading messages while opening the file
    flag,newFrame = g.openWithFileName(path,None)
    g.app.log.enable() # re-enable the log.

    for p in newFrame.c.all_positions():
        g.es(g.toEncodedString(p.h,"utf-8"))
</t>
<t tx="ekr.20040403173920.25" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333922206e616d653d22687474702d6e6f64652d6d61726b65722d3339223e710158040000003c2f613e71025d71032858340000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f583e0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e0a7110587e0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323022206e616d653d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e46756e6374696f6e7320646566696e656420696e206c656f476c6f62616c732e70793c2f613e3c2f68313e0a7111652e">leoGlobals.py contains many utility functions and constants.
The following script prints all the names defined in leoGlobals.py::

    print("Names defined in leoGlobals.py",color="purple")
    names = g.__dict__.keys()
    names.sort()
    for name in names:
        print(name)</t>
<t tx="ekr.20040403173920.26" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343322206e616d653d22687474702d6e6f64652d6d61726b65722d3433223e710158040000003c2f613e71025d710328583a0000003c64697620636c6173733d2273656374696f6e222069643d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f58450000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e0a7110588c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323222206e616d653d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e53756d6d617279206f662074686520766e6f646520616e6420706f736974696f6e20636c61737365733c2f613e3c2f68313e0a7111652e">Most scripts will use methods of the position class to access information in an
outline. The following sections summarizes the most useful methods that your
scripts can use. For a complete list, see the leoNodes.py in of LeoPy.leo.
</t>
<t tx="ekr.20040403173920.27" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343722206e616d653d22687474702d6e6f64652d6d61726b65722d3437223e710158040000003c2f613e71025d71032858240000003c64697620636c6173733d2273656374696f6e222069643d226974657261746f7273223e710458060000003c2f6469763e71055d71062858440000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a711258230000003c64697620636c6173733d2273656374696f6e222069643d2267657474657273223e0a711358480000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323422206e616d653d2267657474657273223e476574746572733c2f613e3c2f68323e0a7114652e">Here are the most useful getters of the vnode and position classes.

Returning strings::

    p.b # the body string of p.
    p.h # the headline string of p. A property.

Returning ints::

    p.childIndex()
    p.numberOfChildren()
    p.level()

Returning bools representing property bits::

    p.hasChildren()
    p.isAncestorOf(v2) # True if v2 is a child, grandchild, etc. of p.
    p.isCloned()
    p.isDirty()
    p.isExpanded()
    p.isMarked()
    p.isVisible()
    p.isVisited()</t>
<t tx="ekr.20040403173920.28" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343922206e616d653d22687474702d6e6f64652d6d61726b65722d3439223e710158040000003c2f613e71025d71032858220000003c64697620636c6173733d2273656374696f6e222069643d2267657474657273223e710458060000003c2f6469763e71055d71062858440000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a711258230000003c64697620636c6173733d2273656374696f6e222069643d2273657474657273223e0a711358480000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323522206e616d653d2273657474657273223e536574746572733c2f613e3c2f68323e0a7114652e">Here are the most useful setters of the Commands and position classes.
The following setters of the position class regardless of whether
p is the presently selected position::

    c.setBodyString(p,s)  # Sets the body text of p.
    c.setHeadString(p,s)  # Sets the headline text of p.

Moving nodes::

    p.moveAfter(v2)           # move p after v2
    p.moveToNthChildOf(v2,n)  # move p to the n'th child of v2
    p.moveToRoot(oldRoot)     # make p the root position.
                              # oldRoot must be the old root position if it exists.

The "visited" bit may be used by commands or scripts for any purpose.
Many commands use this bits for tree traversal, so these bits do not persist::

    c.clearAllVisited() # Clears all visited bits in c's tree.
    p.clearVisited()
    p.setVisited()</t>
<t tx="ekr.20040403173920.3" rst_http_attribute="5d71002858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3522206e616d653d22687474702d6e6f64652d6d61726b65722d35223e710158040000003c2f613e71025d71032858400000003c64697620636c6173733d2273656374696f6e222069643d22672d746f702d7468652d636f6d6d616e6465722d6f662d7468652d746f702d77696e646f77223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f58360000003c64697620636c6173733d2273656374696f6e222069643d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e0a711058700000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643322206e616d653d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e672e657328293a20777269746520746f20746865206c6f672070616e653c2f613e3c2f68313e0a7111652e">The g.es method prints its arguments to the Log tab of the log pane::

    g.es("Hello world")

g.es converts non-string arguments using repr::

    g.es(c)

g.es prints multiple arguments separated by commas::

    g.es("Hello","world")

To create a tab named 'Test' or make it visible if it already exists::

    c.frame.log.selectTab('Test')

When first created, a tab contains a Tk.Text widget.
To write to this widget, add the tabName argument to g.es::

    g.es('Test',color='blue',tabName='Test')</t>
<t tx="ekr.20040403173920.5" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343122206e616d653d22687474702d6e6f64652d6d61726b65722d3431223e710158040000003c2f613e71025d710328583d0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f583b0000003c64697620636c6173733d2273656374696f6e222069643d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e0a711058780000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323122206e616d653d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e5265646972656374696e67206f75747075742066726f6d20736372697074733c2f613e3c2f68313e0a7111652e">leoGlobals.py defines 6 convenience methods for redirecting stdout and stderr::

    g.redirectStderr() # Redirect stderr to the current log pane.
    g.redirectStdout() # Redirect stdout to the current log pane.
    g.restoreStderr()  # Restores stderr so it prints to the console window.
    g.restoreStdout()  # Restores stdout so it prints to the console window.
    g.stdErrIsRedirected() # Returns True if the stderr stream is redirected to the log pane.
    g.stdOutIsRedirected() # Returns True if the stdout stream is redirected to the log pane.

Calls need *not* be paired. Redundant calls are ignored and the last call made
controls where output for each stream goes.
**Note**: you must execute Leo in a console window to see non-redirected output from the print statement::

    print("stdout isRedirected: %s" % g.stdOutIsRedirected())
    print("stderr isRedirected: %s" % g.stdErrIsRedirected())

    g.redirectStderr()
    print("stdout isRedirected: %s" % g.stdOutIsRedirected())
    print("stderr isRedirected: %s" % g.stdErrIsRedirected())

    g.redirectStdout()
    print("stdout isRedirected: %s" % g.stdOutIsRedirected())
    print("stderr isRedirected: %s" % g.stdErrIsRedirected())

    g.restoreStderr()
    print("stdout isRedirected: %s" % g.stdOutIsRedirected())
    print("stderr isRedirected: %s" % g.stdErrIsRedirected())

    g.restoreStdout()
    print("stdout isRedirected: %s" % g.stdOutIsRedirected())
    print("stderr isRedirected: %s" % g.stdErrIsRedirected())</t>
<t tx="ekr.20040403173920.6" rst_http_attribute="5d71002858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3922206e616d653d22687474702d6e6f64652d6d61726b65722d39223e710158040000003c2f613e71025d71032858450000003c64697620636c6173733d2273656374696f6e222069643d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f58460000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e0a7110588d0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643522206e616d653d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e47657474696e6720616e642073657474696e6720686561646c696e6520616e6420626f647920746578743c2f613e3c2f68313e0a7111652e">Here is how to access the data of a Leo window::

    g.es(p) # p is already defined.
    p = c.p # get the current position.
    g.es(p)
    g.es("head:",p.h)
    g.es("body:",p.b)

Here is how to access data at position p.
**Note**: these methods work whether or not p is the current position::

    body = p.b # get the body text.
    head = p.h # get the headline text.
    p.b = body # set body text of p to body.
    p.h = head # set headline text of p to head.

**Note**: Sometimes you want to use text that *looks* like a section reference, but isn't.
In such cases, you can use g.angleBrackets.  For example::

    g.es(g.angleBrackets('abc'))</t>
<t tx="ekr.20040403173920.9" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313122206e616d653d22687474702d6e6f64652d6d61726b65722d3131223e710158040000003c2f613e71025d71032858450000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f582f0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e0a7110585f0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643622206e616d653d2274726176657273696e672d6f75746c696e6573223e54726176657273696e67206f75746c696e65733c2f613e3c2f68313e0a7111652e">Leo scripts can easily access any node of an outline with generators. Leo's
generators return positions or nodes, one after another. Generators do not
return lists, but you can make lists from generators easily. For example, the
c.all_positions() generator returns every position in c's tree, one after
another. You can use the generator directly, like this::

    for p  in c.all_positions():
        print(p.h)
        
You can create actual lists from generators in several ways::

    aList = list(c.all_positions()] # Use the list built-in function.
    print(aList)
    
or::

    aList = [p.copy() for p in c.all_positions()] # Use list comprehension.
    print(aList)

    
Using the list is simpler, but list comprehensions can be more flexible.  For example::

    aList = [p.copy().h for p in c.all_positions() if p.h.startswith('@thin')]
    print(aList)</t>
<t tx="ekr.20040403175157.1" rst_http_attribute="5d71002858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3722206e616d653d22687474702d6e6f64652d6d61726b65722d37223e710158040000003c2f613e71025d71032858350000003c64697620636c6173733d2273656374696f6e222069643d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f58460000003c64697620636c6173733d2273656374696f6e222069643d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e0a7110588e0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643422206e616d653d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e6170702e77696e646f774c6973743a20746865206c697374206f6620616c6c206f70656e206672616d65733c2f613e3c2f68313e0a7111652e">The windowlist attribute of the application instance contains the list of the
frames of all open windows. The commands ivar of the frame gives the commander
for that frame::

    windows = g.app.windowList # get the list of all open frames.
    g.es("windows...")
    for f in windows:
        c = f.c # c is f's commander
        g.es(f)
        g.es(f.shortFileName())
        g.es(c)
        g.es(c.rootPosition())

There is also g.app.commandrs() method, that gives the list of all active
commanders directly.</t>
<t tx="ekr.20040403183229" rst_http_attribute="5d71002858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3122206e616d653d22687474702d6e6f64652d6d61726b65722d31223e710158040000003c2f613e71025d710328583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710458060000003c2f6469763e71055d71062858060000003c626f64793e710758070000003c2f626f64793e71085d71092858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710a58070000003c2f68746d6c3e710b4e65656558240000003c64697620636c6173733d2273656374696f6e222069643d226f76657276696577223e0a710c58490000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643122206e616d653d226f76657276696577223e4f766572766965773c2f613e3c2f68313e0a710d652e">Leo scripts typically use the following objects:

**g**
    The predefined constant g is the leo.core.leoGlobals module. This
    module contains several dozen utilty functions and classes.

**g.app**
    g.app is the **application object** representing the entire Leo application.
    The instance variables (ivars) of g.app represent Leo's global variables.

**commander**
    The predefined constant c is the commander of the window containing the
    script. Commanders represent all aspects of a single Leo window. For any
    commander c, c.p is the presently selected position (see below), and
    c.rootPosition() is the root (first) position in the outline. Given
    c, Leo scripts can gain access to all data present while Leo is running,
    including all of Leo's classes, functions and data.

**position**
    The predefined constant p is the position of the presently selected
    node. Positions represent locations in Leo outlines. For any position p,
    p.v is the vnode at that position.

**vnode**
    A vnode represents a single outline node. Because of clones, a vnode may
    appear in several places on the screen. Vnodes hold most of the data in Leo
    outlines. For any vnode v, v.h is the node's headline, and v.b
    is the node's body text. As a convenience, for any position p, p.h
    and p.b are synonyms for p.v.h and p.v.b.
    
Later sections will discuss other classes, objects and utility functions, but
most scripts will need only the objects and classes described above.</t>
<t tx="ekr.20040411151245" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343522206e616d653d22687474702d6e6f64652d6d61726b65722d3435223e710158040000003c2f613e71025d71032858440000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558250000003c64697620636c6173733d2273656374696f6e222069643d226974657261746f7273223e0a710f584c0000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323322206e616d653d226974657261746f7273223e4974657261746f72733c2f613e3c2f68323e0a7110652e">Here is the list of Leo's generators::

    c.all_nodes             # all vnodes in c.
    c.all_unique_nodes      # all unique vnodes in c.
    c.all_positions         # all positions in c.
    c.all_unique_positions  # all unique positions in c.
    
    p.children              # all children of p.
    p.following_siblings    # all siblings of p that follow p.
    p.nodes                 # all vnodes in p's subtree.
    p.parents               # all parents of p.
    p.self_and_parents      # p and all parents of p.
    p.siblings              # all siblings of p, including p.
    p.subtree               # all positions in p's subtree, excluding p.
    p.self_and_subtree      # all positions in p's subtree, including p.
    p.unique_nodes          # all unique vnodes in p's subtree.
    p.unique_subtree        # all unique positions in p's subtree.
    
**Note**: A generator that returns **unique positions** is a generator that returns
a list of positions such that p.v == v at most once for any vnode v.
Similarly, a generator that returns **unique nodes** is a generator that returns
a list that contains any vnode at most once.

**Note**: The names given above are the recommended names for Leo's generators.
Leo continues to support the names of iterators used before Leo 4.7.
These names typically end with the _iter suffix.</t>
<t tx="ekr.20040414161647">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

@language rest
@tabwidth -4

These are the sources for the html version of Leo's users guide,
as well as the documentation for the rst3 plugin used to create the actual html files.

These sources contain reStructuredText_ (rST) markup that is easy to read.
See http://docutils.sourceforge.net/docs/user/rst/quickstart.html for an introduction to rST.

See the node "How to generate Leo's Sphinx docs" for details about making these docs.</t>
<t tx="ekr.20040414172212">############
Front Matter
############

.. .. contents::
</t>
<t tx="ekr.20040414172218.2">Leo_ has thousands of users_. Like me, many of them would never willingly be without Leo again.
Here are Leo's essential features:

1.  Leo outlines_ show you the big picture at all times,
    while providing unlimited space for details.

2.  Leo outlines_ can organize any kind of data:
    computer programs, web sites, documentation, pictures, whatever.

3.  Clones_ allow multiple views of the data within a *single* outline_.
    You don't have to choose the 'correct' view; you can see data in many ways.

4.  Plugins_ allow Leo's users to add new features to Leo.
    Many of Leo's most successful features started life this way.

5.  Leo is a superb scripting_ environment for Python.
    Scripts contained in a Leo outline_ have easy access to all the outline's data.
    It is natural to organize Leo outlines to make life easier for scripts.

6.  Leo is `Open Software`_, written in 100% pure Python_.
    Leo runs wherever Python does.

Leo has a strong and active community of users on `SourceForge`_.
Working with this community has been a constant source of joy and inspiration.
Suggestions and plugins from users continue to drive Leo in excellent new directions.
Who knows what the next plugin will bring? -- Edward K. Ream, September, 2005</t>
<t tx="ekr.20040414172218.4">Leo owes much of its visual design to MORE, possibly the most elegant
computer program ever written. Leo's clone nodes are inspired by MORE.

The following people have made generous donations to the Leo project:
Robert Low, Nic Cave-Lynch.

The following people reported bugs, answered questions, and made suggestions for
improving Leo:
Alex Abacus, Shakeeb Alireze, Steve Allen, Bruce Arnold,
Chris Barker, Dennis Benzinger, David Boddie, Jason Breti, Eric Brown, Terry Brown,
Darius Clarke, Martin Clifford, Jason Cunliffe,
Josef Dalcolmo, Gil Dev, Bill Drissel, Wenshan Du,
Allen Edwards, Chris Elliot, Dethe Elza, Mark Engleberg, Roger Erens, 
Stephen Ferg, Tom Fetherston, Tomaz Ficko, Niklas Frykholm,
Fred Gansevles, Jonathan M. Gilligan, Zak Greant, Thomas Guettler, Romain Guy,
Dave Hein, Tiago Castro Henriques, Gary Herron, Steve Holden, Klass Holwerda, Matthias Huening, Robert Hustead,
John Jacob, Paul Jaros, Christopher P. Jobling, Eric S. Johansson, Garold Johnson, 
James Kerwin,
Nicola Larosa, David LeBlanc, Chris Liechti, Steve Litt, Martin v. Loewis, Robert Low, Fredrik Lundh,
Michael Manti, Alex Martelli, Marcus A. Martin, Gidion May, David McNab, Frank Merenda, Martin Montcrieffe, Will Munslow,
Chad Netzer, Derick van Niekerk, Jeff Nowland,
Naud Olivier, Joe Orr,
Marc-Antoine Parent, Paul Paterson, Sean Shaleh Perry, Tim Peters, David Priest, Gary Poster, Scott Powell,
Bruce Rafnel, Walter H. Rauser, Olivier Ravard, David Speed Ream, Rich Ries, Aharon Robbins, Guido van Rossum, David Rowe,
Davide Salomoni, Steven Schaefer,Johannes Schn, Wolfram Schwenzer, Casey Wong Kam Shun,
Gil Shwartz, Jim Sizelove, Paul Snively, Jurjen Stellingwerff, Phil Straus, David Szent-Gyrgyi,
Kent Tenney, Jeffrey Thompson,
Gabriel Valiente, Jim Vickroy, Tony Vignaux, Tom van Vleck,
Kevin Walzer, Ying-Chao Wang, Cliff Wells, Dan Wharton, John Wiegley, Wim Wijnders, Dan Winkler, 
Vadim Zeitlin.

The following have contributed plugins to Leo:

Rodrigo Benenson, Pierre Bidon, Felix Breuer, Terry Brown,
Mike Crowe,
Josef Dalcolmo, Michael Dawson,
e, Roger Erens, 
Andrea Galimberti, Engelbert Gruber,
Timo Honkasalo,
Jaakko Kourula, Maxim Krikun,
Zhang Le, LeoUser,
Frdric Mommja, Bernhard Mulder, 
Mark Ng,
Alexis Gendron Paquette, Paul Paterson,
Dan Rahmel,
Davide Salomoni,
Ed Taekema, Kent Tenney, Brian Theado,
Ville M. Vainio,
Steve Zatz.
</t>
<t tx="ekr.20040414172218.5">All parts of Leo are distributed under the following copyright. This is intended
to be the same as the Python license, namely that Leo is absolutely free, even
for commercial use, including resale. There is no GNU-like "copyleft"
restriction. This license is compatible with the GPL.

Copyright 1997-2009 by Edward K. Ream. All Rights Reserved. Permission to use,
copy, modify, and distribute this software and its documentation for any purpose
and without fee is hereby granted, provided that the above copyright notice
appears in all copies and that both that copyright notice and this permission
notice appear in supporting documentation, and that the names of Edward K. Ream
or Leo may not be used in advertising or publicity pertaining to distribution of
the software without specific, prior written permission from Edward K. Ream.</t>
<t tx="ekr.20040414174439">**EDWARD K. REAM (REAM) SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESSED OR
IMPLIED, WITH RESPECT TO THIS COMPUTER SOFTWARE, INCLUDING BUT NOT LIMITED TO
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN
NO EVENT SHALL REAM BE LIABLE FOR ANY LOSS OF PROFIT OR ANY COMMERCIAL DAMAGE,
INCLUDING BUT NOT LIMITED TO SPECIAL, INCIDENTAL, CONSEQUENTIAL OR OTHER
DAMAGES.**
</t>
<t tx="ekr.20040416080538">The following deserve special mention:
David Brock wrote TSyntaxMemo.
The late Bob Fitzwater kept me focused on design. Donald Knuth invented literate programming and the CWEB language.
Jonathan M. Gilligan showed how to put the Leo icon in Leo's windows.
Joe Orr created XSLT stylesheets for Leo; see http://www.jserv.com/jk_orr/xml/leo.htm.
Joe Orr also created an outstanding set of tutorials for Leo; see http://www.evisa.com/e/sb.htm.
LeoUser (B.H.) contributed numerous plugins and was the inspiration for Leo's minibuffer.
LeoUser also wrote jyLeo: Leo for Jython.
Bernhard Mulder proposed a new way of untangling external files.
John K. Ousterhout created tcl/Tk. Neal Norwitz wrote PyChecker.
Marc-Antoine Parent urged me to use XML for Leo's file format and helped improve it.
Paul Paterson suggested the plugin architecture,
suggested an approach to spell checking and has contributed many excellent plugins.
Franois Pinard wrote pymacs.
Norman Ramsey created noweb and gave permission to quote from the noweb web documentation.
Rich Ries has contributed a huge number of suggestions.
Steven P. Schaefer pointed out major security problems lurking in hooks.
Gil Shwartz helped with unicode support.
Phil Straus has been a great friend and constant support.
Guido van Rossum created Python, Tkinter and the Python License.
Dave Winer created MORE.
Ville M. Vainio created ILeo.
Dan Winkler helped support Leo on the Mac.

Special thanks to my family.
My brother, David Speed Ream, tested Leo and made many useful suggestions.
Rebecca, James and Linda make it all worthwhile.
It was during a conversation with Rebecca that I realized that MORE could be used as a prototype for Leo.
That was a crucial first step.</t>
<t tx="ekr.20040705111716"></t>
<t tx="ekr.20040705111716.1">Leo will write only t.unknownAttributes to the .leo file when writing the &lt;v&gt;
element corresponding to the root of an @thin tree. Leo will do this by writing
a new xml attribute, say descendentTnodeUnknownAttributes, in &lt;v&gt; element.

The reason that Leo will only write t.unknownAttributes and not
v.unknownAttributes is that only tnodes have gnx's in thin external files. In
effect, vnodes are anonymous. We could attempt to get around this by identifying
vnodes by their corresponding tnodes, but that's not a general solution and it
is, in effect, equivalent to writing only t.unknownAttributes. This being so, it
seems pointless to "pretend" to be writing v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using
unknownAttributes is concerned. As I've stated in the past, this won't do if,
for example, a plugin is trying create an arbitrary directed graph between
vnodes. In that case, the plugin should confine itself to @file trees, or just
vnodes in .leo files, for that matter.

7/1/04:

- Leo now writes "marks" and "expanded" attributes in the root &lt;v&gt; element for @thin trees.

- VERY IMPORTANT.  Leo now writes entire tree of @ignored @thin nodes.  This fixes a major bug.</t>
<t tx="ekr.20040705111716.126"></t>
<t tx="ekr.20040705111716.45">Leo marks as dirty all @file nodes when they become "newly unignored".</t>
<t tx="ekr.20040705112148"></t>
<t tx="ekr.20040705150130">Leo now generates no warnings with all significant tests enabled.  Some tests have been disabled in bases classes, and in a few cases pychecker gives erroneous warnings that have been suppressed directly in the source code using the __pychecker__ = arg syntax.</t>
<t tx="ekr.20040713110718">Leo 4.2 beta 3           August 10, 2004

This version of Leo is feature complete.  Leo's core code has been stable for several months.

To do: most plugins work with the new code base, but other plugins need some more work.

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
external files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

- A new mod_scripting plugin is a big advance in scripting and testing.
test.leo now uses @test and @script nodes to define unit tests without
explicitly creating subclasses of unittest.TestCase. Converting scripts to unit
tests now takes a few seconds!

- A much faster and more robust spell checker plugin. (requires Python 2.3)

- Leo is now much more friendly to using spaces instead of tabs.

- The Execute Script command reports erroneous lines more clearly.

- The Perfect Import feature guarantee that Leo imports file exactly.</t>
<t tx="ekr.20040804164600.102">Spurious entries in a tnodeList for @thin trees wiped out all the headlines in the @thin tree.</t>
<t tx="ekr.20040804164600.16">Leo now vetoes the shutdown logic if saving a dirty file fails.

Leo prints in red the warning about not being able save the read-only file. The
user can use the Save To command to save the file. The Save To command does not
clear the file's dirty bit, so Leo will prompt again to save the file. The user
will have to ignore this prompt in order to exit. This is correct: the
_original_ file has not been saved.</t>
<t tx="ekr.20040804164600.265"></t>
<t tx="ekr.20040804164600.275"># The new code only writes tnodes for the current tree when pasting to the clipboard.</t>
<t tx="ekr.20040804164600.36">- g.getScript implicitly assumed that p == c.currentPosition.
  I removed that assumption.

- The scriptButton callback in the scripting.py plugin no longer calls c.executeScript.
  It's simpler and easier to call exec directly.

- Improved c.checkOutline:
    - Added full keyword arg.
    - Print more if verbose is on.</t>
<t tx="ekr.20040804164600.377">There was a big performance bug in the nodenavigator plugin.</t>
<t tx="ekr.20040804164600.394">@nocolor

As a result, the minimal .leo file is:

@color
@language html

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;

@nocolor

The empty_leo_file plugin now uses this code. The minimal .leo file that Leo
might actually write is more like this:

@color

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings&gt;
    &lt;find_string/&gt;
    &lt;change_string/&gt;
&lt;/find_panel_settings&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;</t>
<t tx="ekr.20040804164600.406"></t>
<t tx="ekr.20040804164600.419"></t>
<t tx="ekr.20040804164600.421">This is required to make @thin work properly.</t>
<t tx="ekr.20040804164600.424">This makes the command more useful.</t>
<t tx="ekr.20040804164600.470"></t>
<t tx="ekr.20040804164600.471">A major change: putVnode doesn't put tnodeLists for @thin nodes.

Instead it issues an informational message and deletes the tnodeList.</t>
<t tx="ekr.20040804164600.515">Leo used to allocate more positions than necessary.  This unnecessarily stressed the garbage collector.</t>
<t tx="ekr.20040804164600.56"></t>
<t tx="ekr.20040804164600.98"></t>
<t tx="ekr.20040804165258.1"></t>
<t tx="ekr.20040804165258.2"></t>
<t tx="ekr.20040804165258.3">Leo now allows you to select multiple files in the dialogs for all Import
commands. This fixes a major annoyance. However, you must be running Python 2.3
or above to get this feature.
</t>
<t tx="ekr.20040804165258.4">Added the Check submenu of the Outline menu. This contains the Check Outline and
Dump Outline commands, as well as four new commands:

The Check All Python Code and Check Python Code commands report any syntax
errors or tabnanny errors. These commands mark erroneous nodes. These commands
work on the selected Node and its descendants. These commands ignore any nodes
for which a) @ignore is in effect or b) @language python is in not effect.

The Check Python Code and Pretty Print Python Code commands replace nodes with
their pretty-printed alternative. No doubt everyone will have their own favorite
style. You could implement alternate pretty printers in a plugin merely by
overriding the following methods of class prettyPrinter in leoCommands.py:
    
---- putOperator:      puts whitespace around operators.
---- putNormalToken:   puts whitespace around everything else.</t>
<t tx="ekr.20040804170531"></t>
<t tx="ekr.20040804170657">Leo now reuses all widgets used to draw the outline pane. This improves
performance and ends leaks of bindings and widgets.</t>
<t tx="ekr.20040804170846">@thin bad-directory caused excessive and confusing tracebacks.</t>
<t tx="ekr.20040804171818"></t>
<t tx="ekr.20040804172113"></t>
<t tx="ekr.20040804172113.1"></t>
<t tx="ekr.20040903100514" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323322206e616d653d22687474702d6e6f64652d6d61726b65722d3233223e710158040000003c2f613e71025d71032858450000003c64697620636c6173733d2273656374696f6e222069643d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e710458060000003c2f6469763e71055d710628582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a7112583f0000003c64697620636c6173733d2273656374696f6e222069643d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e0a711358800000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313222206e616d653d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e54657374696e672077686574686572206120706f736974696f6e2069732076616c69643c2f613e3c2f68323e0a7114652e">The tests::

    if p:       # Right
    if not p:   # Right

are the **only** correct ways to test whether a position p is valid.
In particular, the following **will not work**::

    if p is None:       # Wrong
    if p is not None:   # Wrong</t>
<t tx="ekr.20040914103359">Leo 4.2 release candidate 1        September 14, 2004

This version fixes a number of minor bugs reported since the last release. See
the children of this node for details.

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
external files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

- A new mod_scripting plugin is a big advance in scripting and testing.
test.leo now uses @test and @script nodes to define unit tests without
explicitly creating subclasses of unittest.TestCase. Converting scripts to unit
tests now takes a few seconds!

- A much faster and more robust spell checker plugin. (requires Python 2.3)

- Leo is now much more friendly to using spaces instead of tabs.

- The Execute Script command reports erroneous lines more clearly.

- The Perfect Import feature guarantee that Leo imports file exactly.</t>
<t tx="ekr.20040914103359.110"></t>
<t tx="ekr.20040914103359.12">If only one file was specified Leo gave an error for every character of the file name!
</t>
<t tx="ekr.20040914103359.127">Leo wasn't always traversing the outline correctly when looking for @root nodes.</t>
<t tx="ekr.20040914103359.129">http://sourceforge.net/forum/message.php?msg_id=2742238
By: hinsen

The shortcut definitions in Leo are quite inconvenient on the Mac, as those
using the Alt key don't work. Alt is used for entry of additional characters.
On the other hand, ctrl is available for shortcuts but not used in Leo, since
the ctrl-based shortcuts are shifted to the command key (following standard
Mac practice).

The patch at the end of this message simply shifts all Alt-shortcuts to Ctrl
on the Mac.

That leaves one minor clash: Command-` is used for CloneNode in Leo, although
it canonical MacOS function (switching between the windows of an application)
would be very useful in Leo as well. Removing the CloneNode binding is easy
enough, but it seems that I must implement a window switching function myself.
Not today :-)

Konrad.
</t>
<t tx="ekr.20040914103359.137"></t>
<t tx="ekr.20040914103359.15"></t>
<t tx="ekr.20040914103359.19"></t>
<t tx="ekr.20040914103359.2"></t>
<t tx="ekr.20040914103359.20">@killcolor

From Dan Winkler:

On a couple of occasions, I tried to paste in a long @url node and got 
this message:

	Truncating headline to 250 characters

I wonder if the 250 character limit on headline length should be 
rethought in light of the @url directive and long web addresses.</t>
<t tx="ekr.20040914103359.28"></t>
<t tx="ekr.20040914103359.31"></t>
<t tx="ekr.20040914103359.37"></t>
<t tx="ekr.20040914103359.4"></t>
<t tx="ekr.20040914103359.47">There were too many problems with this feature.  In the future Leo will have a Check Import command.</t>
<t tx="ekr.20040914103359.7">With TclTkAqua on the Mac (but *not* with tcltk installed via Fink), the tab
problem doesn't exist there), the tab, return, and backspace keys did not generate
ASCII codes, i.e. event.char is an empty string. So when I press the tab key,
Tk inserts a tab character and Leo isn't even aware of it.</t>
<t tx="ekr.20040914103743"></t>
<t tx="ekr.20040914103743.1"></t>
<t tx="ekr.20040922074200">Leo 4.2 Final       September 20, 2004

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
external files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

- A new mod_scripting plugin is a big advance in scripting and testing.
test.leo now uses @test and @script nodes to define unit tests without
explicitly creating subclasses of unittest.TestCase. Converting scripts to unit
tests now takes a few seconds!

- A much faster and more robust spell checker plugin. (requires Python 2.3)

- Leo is now much more friendly to using spaces instead of tabs.

- The Execute Script command reports erroneous lines more clearly.</t>
<t tx="ekr.20041226081019">c.spellCommands.openSpellTab()</t>
<t tx="ekr.20050122084954">Leo stores options in @settings trees, that is, parts of Leo outlines whose root node has the headline @settings.  When opening a .leo file, Leo looks for @settings trees in the following places:

- The file called leoSettings.leo in the leo/config directory.
- The file called leoSettings.leo in the users home directory.
- The file being loaded.

Settings that later in the above list override settings found earlier. For
example, any setting specified in an @settings tree in the file being loaded
overrides any setting seen in any leoSettings.leo file.

The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings dialog" pane. This settings dialog pane allows
you to change the settings selected in the outline pane using standard gui
widgets.

The format of nodes in @settings trees are as follows:

1. "Simple settings nodes" have headlines of the form:

@&lt;type&gt; name = val

set the value of name to val, with the indicated type.

&lt;type&gt; may be one of the following, with valid values shown:

&lt;type&gt;          Valid values
-----           ------------
\@bool           True, False, 0, 1
\@color          A Tk color name or value, such as 'red' or 'xf2fddff' (without the quotes)

For a list of Tk color specifiers see:

- http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm
- http://www.tcl.tk/man/tcl8.4/TkLib/GetColor.htm

\@directory      A path to a directory
\@float          A floating point number of the form nn.ff.
\@int            An integer
\@ints[list]     An integer (must be one of the ints in the list).
                 Example: @ints meaningOfLife[0,42,666]=42
\@path           A path to a directory or file
\@ratio          A floating point number between 0.0 and 1.0, inclusive.
\@string         A string
\@strings[list]  A string (must be one of the strings in the list).
                 Example: @strings tk_relief['flat','groove','raised']='groove'

2. "Complex settings nodes" have headlines of the form:

\@&lt;type&gt; description

The actual settings are specified in the body text.  At present, there are two such kinds of complex settings nodes:

- @font

The body text contains a list of settings for a font.  For example:

body_text_font_family = Courier New
body_text_font_size = None
body_text_font_slant = None
body_text_font_weight = None

- @recentFiles

The body text contains a list of paths of recently opened files, one path per line.

Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.

3.  All other nodes are "Organizer" nodes.  Such nodes have no effect on the settings shown in the dialog.  You may use them as you please to organize settings.

Notes:

A.  At present, you can not change @settings trees while executing the Settings command.  You can, however, change any @settings tree normally when not executing the Settings command.

B. Other kinds of settings nodes are planned for future releases.</t>
<t tx="ekr.20050122090311">Leo 4.3 alpha 1                 January 24, 2005

Leo 4.3 is the culmination of more than four months of work. 

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail.</t>
<t tx="ekr.20050122091036">The essential features of @settings trees and the settings dialog appear to be stable.  However, many improvements can be imagined, including the following:

- Allow searching for nodes while in the settings dialog.

- Allow adding, deleting, rearranging nodes while in the settings dialog.

- Allow adding, deleting, rearranging recent files while in the settings dialog.

These will be added as time permits and people request.</t>
<t tx="ekr.20050123092834.1"></t>
<t tx="ekr.20050123092834.1004">Changed these hooks:

"bodyclick1", "bodyclick2",
"bodydclick1", "bodydclick2",
"bodyrclick1", "bodyrclick2",
"bodykey1", "bodykey2",
"command1", "command2",
"headclick1", "headclick2",
"headrclick1", "headrclick2",
"headkey1", "headkey2", 
"hyperclick1", "hyperclick2",
"hyperenter1", "hyperenter2",
"hyperleave1", "hyperleave2", 
"openwith1", "openwith2",
"menu1", "menu2", 
"recentfiles1", "recentfiles2",
"save1", "save2",
"select1", "select2", "select3",
"start2",
"unselect1", "unselect2",
"url1", "url2", 

"clear-mark", "set-mark", 
"color-optional-markup",
"create-popup-menu", 
"draw-outline-icon",
"draw-outline-node",
"draw-outline-text-box",
"draw-sub-outline", 
"init-color-markup",
"scan-directives", 
"draw-outline-box",
"enable-popup-menu-items",
"show-popup-menu",</t>
<t tx="ekr.20050123092834.1005">Leo no loner has any global windows!

- Each commander has its own find window.
    - It's title tells to what commander it applies.
</t>
<t tx="ekr.20050123092834.1011">computeHomeDir() now test the first retrieval of the %HOME% var and grab it's
results if it is in fact another environment variable.</t>
<t tx="ekr.20050123092834.1013"></t>
<t tx="ekr.20050123092834.1018">Actually, support already existed for them in getBaseDirectly!

What I did.

- Added a c keyword to getBaseDirectory.
- Added similar logic to os_path_join.

- Changed some stupid code in g.openWithFileName (called by @url logic):
    changed: fileName = g.os_path_join(os.getcwd(),fileName)
    to:      fileName = g.os_path_abspath(fileName)

MAYBE g.os_path_abspath should force '.' to mean c.openDir, but I kinda doubt
it. This could be asking for trouble.

OTOH, the various flavors of scanAllDirectives already do this.  Hmmmmmm.</t>
<t tx="ekr.20050123092834.1043"></t>
<t tx="ekr.20050123092834.1044"></t>
<t tx="ekr.20050123092834.1047">- This plugin now handles both kinds of triple-quotes correctly so that both
kinds of docstrings are recognized.
</t>
<t tx="ekr.20050123092834.1052">Created callTagHandler. This checks 'idle' hooks to make sure that any commander
referenced by the 'c','new_c' or 'old_c' keywords still exists.</t>
<t tx="ekr.20050123092834.1057">leoPlugins.registerOneHandler wasn't working properly at all. In effect, only
the last registered hook was ever being remembered!</t>
<t tx="ekr.20050123092834.159"></t>
<t tx="ekr.20050123092834.160">p.moveToParent now just returns if p is a null position.</t>
<t tx="ekr.20050123092834.163"># Leo looped after this assert failed.</t>
<t tx="ekr.20050123092834.165"></t>
<t tx="ekr.20050123092834.166">he readDirective method was changing the comment delimiters as the result of
seeing the sentinels corresponding to @language or @comment directives. But in
general this makes no sense! Comment delimiters should be set once and for all
in the @+leo sentinel: there is no compiler in the world that tolerates mixed
comment delimiters.

BTW, the way to set javascript "inner" comments is to use @delims, not @comment.
N.B. The @language and @comment delimiters _will_ have an effect, and that
effect is in the _write_ logic, not the read logic. The effect is to set the
comment delims in the @+leo sentinel.

The quick fix is to comment out code in readDirective.</t>
<t tx="ekr.20050123092834.173"></t>
<t tx="ekr.20050123092834.176">The old code did not honor the @lineending directive if the two files would otherwise be identical.

What I did:

- Added self.explicitLineEnding to remember whether an explicit @lineending directive is in effect.

- Make sure the user knows why an otherwise identical file was written.

- Changed name of compareFilesIgnoringNewlines to compareFiles.

- Added ignoreLineEndings arg to compareFiles.</t>
<t tx="ekr.20050123092834.19">The old code wasn't handling single file selections properly. The new code works
around an apparent bug in Tk.askopenfilename.</t>
<t tx="ekr.20050123092834.196">The fix was to add nosentinels=nosentinels in the call to initWriteIvars in atFile.write.</t>
<t tx="ekr.20050123092834.2"></t>
<t tx="ekr.20050123092834.27">The new code forbids Paste Node As Clone if the paste would result in a node being a clone of itself.</t>
<t tx="ekr.20050123092834.42">The '@' sign is an operator in Python 2.4, not an error token.</t>
<t tx="ekr.20050123092834.422">This method now does nothing if at.toString is True.</t>
<t tx="ekr.20050123092834.424"></t>
<t tx="ekr.20050123092834.431"></t>
<t tx="ekr.20050123092834.432">Leo did not correctly write adjacent @doc parts in @file trees.  Leo could not read the resulting external files!

The bug happened if any node in an @file tree contains adjacent @doc parts, like this:

@  first doc part
...
@ second doc part
...

Leo failed to write the closing #@-at sentinel that would finish the first @doc part.</t>
<t tx="ekr.20050123092834.434">The new code uses protocol=1 instead of the deprecated bin argument to Pickler.</t>
<t tx="ekr.20050123092834.438"></t>
<t tx="ekr.20050123092834.439">The problem was that nullLog.write calls print, and if print is redirected the
code ends up calling nullLog.write again.

What I did:

- g.redirectClass.redirect does nothing if g.app.batchMode is True.
- added g.rawPrint.
- Changed self.old.write(s) to self.old.write(s+'\n') throughout.</t>
<t tx="ekr.20050123092834.474">It makes no sense to use only the selected text.</t>
<t tx="ekr.20050123092834.480">The old code assumed that the error is always in the script itself. Not true!
The error could happen in methods called by the script.

This code works with Python 2.3.4 and Python 2.4.  It may be version dependent.</t>
<t tx="ekr.20050123092834.486"></t>
<t tx="ekr.20050123092834.487">Leo now sets the name of the frame to the requested file name on the command line even if the file name does not exist.</t>
<t tx="ekr.20050123092834.490">The code now clears previous shortcut, and tells what the previous entry was.</t>
<t tx="ekr.20050123092834.491">Changed the open command associated with .leo files on Windows from:

pythonw.exe "&lt;leodir&gt;\src\leo.py" %1

to:

"pythonw.exe" "&lt;leodir&gt;\src\leo.py" "%1"

The difference is in quotes.  Especially quotes around "%1" seem to matter.</t>
<t tx="ekr.20050123092834.492">This is an important difference. imp.load_module is equivalent to a reload, so
we must not call this if the module already exists!</t>
<t tx="ekr.20050123092834.497">Leo did not properly write external files that contained section references to grand-children.

For example:

&lt;&lt; current level&gt;&gt;
  reference to &lt;&lt; 3. level&gt;&gt;
    &lt;&lt; 1.level&gt;&gt;
        &lt;&lt; 2.level &gt;&gt;
            &lt;&lt; 3.level&gt;&gt;

The fix was simply to reverse the order in which putRefAt puts +middle and -middle sentinels.</t>
<t tx="ekr.20050123092834.499">In some cases g.app.config.output_newline was None.  The new code sets the default to '', and then assigns a valid default to ''.</t>
<t tx="ekr.20050123092834.502">This binds scroll-wheel events to Button-4 and Button-5
</t>
<t tx="ekr.20050123092834.506">chapters.py requires that the canvas have a name ivar.

Added treeCanvas.name = '1' in:
    
&lt;&lt; replace tree pane with settings tree &gt;&gt;</t>
<t tx="ekr.20050123092834.510"></t>
<t tx="ekr.20050123092834.517">Leo can still read such files, but old-style file formats are now deprecated</t>
<t tx="ekr.20050123092834.520">The new code greatly simplifies the class structure. The intention is to allow plugins to override methods of this file more easily.

The highlights:

- Plugins may now override methods in this file much more easily.
    - All code is now in a single class.
    - Resolved the few name conflicts by renaming x to x3 or x4.
    - The new code generally uses methods instead of sections.
    - Initialization is now simple and sane, and is done in dedicated methods.
    - All constants are class constants: no more module-level constants.

- All top-level methods support toString or fromString arguments.</t>
<t tx="ekr.20050123092834.526">Fixed shadow warnings.  The following are all Python global functions:

cmp -&gt; compare
dict -&gt; theDict
dir -&gt; theDir
file -&gt; theFile
id -&gt; theId
type -&gt; theType
input  (suppressed the warning)
iter -&gt; theIter</t>
<t tx="ekr.20050123092834.544">Apparently distutils.file_util is not present in all Python distributions!

New approaches:
    - Fall back on code in distutils.file_util if import fails.
    - Make sure the src and dst volumes are the same (so Linux os.rename will always work)
    - Simplify replaceTargetFileIfDifferent by creating new routines.

What I did:
    - Rewrote replaceTargetFileIfDifferent in terms of atFile.rename, atFile.remove, etc.
    - Rewrote update_file_if_changed in terms of g.utils_rename, g.utils_remove, etc.</t>
<t tx="ekr.20050123092834.565">Leo's code now contains an important simplification to Leo's gui code. This
arose because of a problem in the UNL plugin. The window that opened when double
clicking an @url UNL node wasn't staying on top.

It turns out that this was essentially impossible to fix with the old code. The
proximate cause of the original problem button-1 was bound to OnActivateTree,
which called g.app.gui.set_focus after the new window was visible, thereby
bringing the old tree to the front.

Further investigation revealed other problems. For example, the idle-time code
in the status line logic was also messing with the focus. It turns out that
repeatedly calling g.app.gui.set_focus is a very bad idea, for lots of reasons
which I won't go into in detail here.

The old code called g.app.gui.set_focus explicitly whenever it wanted focus to
change. But there is a much better way, namely to have routines that _indicate_
where they want the focus to be "after the dust settles", that is, when all gui
calls have been completed. I call this a "delayed focus" scheme.

So I rewrote all the code that sets the focus. The new code replaces direct
calls to g.app.gui.set_focus with calls to the following methods in
leoTkinterFrame class: bodyWantsFocus, statusLineWantsFocus, treeWantsFocus and
logWantsFocus. Actually, these xWantsFocus methods all do the same thing, but
using different methods improves traces.

This is an excellent pattern. Again, rather than setting the focus directly,
these xWantsFocus methods merely signal their intension to set the focus. This
allows very complex logic to be hidden in leoTkinterFrame.set_focus.

leoTkinterFrame.set_focus is indeed complex. It took me several hours this
morning to get it just right. It queues up a 'one-shot' callback. That is, at
most one copy of the callback is ever waiting to be executed. Furthermore, the
callback is only queued for execution at the result of a call to xWantsFocus; it
is never run automatically at idle time. Finally, even when executed, the
callback does nothing if the last requested commander (in the new ivar,
g.app.wantedFocus) does not match the commander to which the callback was bound.

These checks allow the UNL plugin to open a window properly and keep it topmost.

This is a big step forward for Leo, for the following reasons:

- Delayed focus ensures that the body pane always has focus unless the code has
a specific, positive reason for the focus to be elsewhere. This was difficult
(or rather impossible) to do with the old code: there are _many_ Tk calls that
can affect the focus.

- Delayed focus minimizes calls to g.app.gui.set_focus. Unlike the old code,
many seconds may elapse between calls. The stress on Tk is much less, and I
believe this may cure some flakiness in how focus changes, especially in
headlines.

- There are some cases where focus must change immediately. The xWantsFocus
methods all support a 'later' keyword argument. By default it is True, but when
it is False leoTkinterFrame.set_focus calls g.app.gui.set_focus immediately.

- The xWantsFocus methods all support a 'tag' keyword argument that tells what
routine the method is called from. It is a big help in making sense of traces.
BTW, extensive traces are the _only_ possible way of tracking down
focus/selection problems.</t>
<t tx="ekr.20050123092834.6">The Open With logic in createOpenWithMenuFromTable for the 'spawnv' case now
actually calls os.spawnv (rather than spawnl) and it allows a variable length
list of parameters.</t>
<t tx="ekr.20050123092834.71">What I did:
    
- Created a new top-level method: scanHeaderForThin.

This sets self.encoding temporarily. The actual value of self.encoding does not
really matter: no errors will be given by readLine and its helpers even if there
are unicode encoding errors.

- We must _not_ set self.encoding in scanHeader: that would interfere with
normal initialization.</t>
<t tx="ekr.20050123092834.81">- Restored non Pmw code in resizePanesToRatio. This code got deleted by mistake.
The Equal Sized Panes works again.

- Added many do-nothing methods to nullMenu class.

This should prevent the startup logic from messing with shortcuts in any way.
It's also the right thing to do.

- Added an entry for EqualSizedPanes to leoSettings.leo. This overrides the
default (Ctrl-E) and thereby prevents the default from overriding the entry for
ExecuteScript!

- Re-enabled code in createMenuEntries that warns when shortcuts have been
redefined. Not sure if this is a wise idea, or indeed if it actually does
anything :-)

I am tempted to remove all the default entries entirely. This would simplify
error reporting, but then Leo would hardly work at all if leoSettings.leo were
not present.</t>
<t tx="ekr.20050123092834.896"></t>
<t tx="ekr.20050123092834.897">These commands work as do the similar commands in Windows Explorer. How did we
ever live without them?</t>
<t tx="ekr.20050123092834.901">This supports the fromString option in read commands.</t>
<t tx="ekr.20050123092834.903">Thanks to Bernhard Mulder for the new code.</t>
<t tx="ekr.20050123092834.908">- Tab toggles between the Search to the Replace areas.

- Control-Tab inserts a tab.

- Added hot keys for all settings.  Use Alt-x to activate hot key x.
  The Enter key activates the Find button.

- As usual, Alt-F4 dismisses the Find panel.</t>
<t tx="ekr.20050123092834.928">It's not clear that this support is so useful for debugging scripts.

If g.app.debugSwitch is True es_exception gives a full traceback.</t>
<t tx="ekr.20050123092834.929">Thanks to David McNab &lt;david@freenet.org.nz&gt; for this work.</t>
<t tx="ekr.20050123092834.961">- Go To Line Number command now assumes the presently selected node is a script if there is no ancestor @file node.

- Execute Script command uses this new logic to select the proper node and line in a script if there is an error.

How did we ever live without these features?</t>
<t tx="ekr.20050123092834.984">Restored the following hooks:
    
"boxclick1"     before click in +- box            c,p,v,event
"boxclick2"     after  click in +- box            c,p,v,event
"drag1"         before start of drag              c,p,v,event
"drag2"         after  start of drag              c,p,v,event
"dragging1"     before continuing to drag         c,p,v,event
"dragging2"     after  continuing to drag         c,p,v,event
"enddrag1"      before end of drag                c,p,v,event
"enddrag2"      after  end of drag                c,p,v,event

The following already existed.  I added v=p keyword params:

"iconclick1"    before single click in icon box   c,p,v,event
"iconclick2"    after  single click in icon box   c,p,v,event
"iconrclick1"   before right click in icon box    c,p,v,event
"iconrclick2"   after  right click in icon box    c,p,v,event
"icondclick1"   before double click in icon box   c,p,v,event
"icondclick2"   after  double click in icon box   c,p,v,event</t>
<t tx="ekr.20050123093854.1">tnodes_iter and unique_tnodes_iter were returning vnodes, not tnodes!</t>
<t tx="ekr.20050123100706.1"></t>
<t tx="ekr.20050123100706.2"></t>
<t tx="ekr.20050123101208"></t>
<t tx="ekr.20050123103303"></t>
<t tx="ekr.20050123103303.1"></t>
<t tx="ekr.20050123103521"></t>
<t tx="ekr.20050123103753"></t>
<t tx="ekr.20050123105026">- Leo now ignores all find settings in .leo files.  Instead, Leo inits find settings from @settings entries.

- Removed all c ivars corresponding to leoFind ivars.
    - This eliminates the ugliest code in Leo.
    - Inits all leoFind ivars from @settings in init, a helper of the ctor.
    - Updates all the leoFind ivars in update_ivars, called just before doing any find.

- Removed the _flag suffix from leoFind ivars.
    - Another major mess cleaned up.

- Renamed find/change_text to find/change_ctrl to avoid name conflict.</t>
<t tx="ekr.20050123110009">Leo now stores options in @settings trees, that is, outlines whose headline is
'@settings'. When opening a .leo file, Leo looks for @settings trees not only in
the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.

The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

For full details, see the children of this node.</t>
<t tx="ekr.20050123111723"></t>
<t tx="ekr.20050123112151">- leoPlugins.doHandlersForTag now executes the list of hook handlers for a
particular tag (hook name) until one of the handlers returns a non-None result.
doHandersForTag no longer tries to "sort" handlers, so the order that the
handlers are executed is the order in which they were registered.

I finally understand the concerns people have raised several times about hooks
interfering with each other. If two handlers try to return a non-None result
only one of them will ever execute. doHandlersForTag can't do much about this: a
better solution would require more conceptual framework. Not now...</t>
<t tx="ekr.20050123112834"></t>
<t tx="ekr.20050123115804">Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables and
disables plugins automatically.This plugin also tells you everything you need to
know about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

Note. The Plugins Manager plugin requires Pmw. You can install Pmw in Leo's
extensions directory if you like.</t>
<t tx="ekr.20050123115804.1">You can can import any extension to Leo by putting the extension in the 'extensions' directory and using g.importExtension to import it.

- created the 'extensions' directory and g.app.extensionsDir

- created g.importModule and g.importExtension</t>
<t tx="ekr.20050123151338">Changed scanDirectives and atFile.scanDirectives so they work like tangle.scanAllDirectives.  Also added a few clarifying words in LeoDocs.leo.

This should have worked, but didn't:

+ Code 
  @language python 
  + @file sql_create.sql 
    @comment -- 
 
So I rearranged the outline (probably more logical anyway) to  
+Code 
  + Python 
  ... 
+ SQL 
  ... </t>
<t tx="ekr.20050126100405">Leo 4.3 alpha 2                 February 14, 2005

Leo 4.3 is the culmination of more than four months of work. This alpha 2
release corrects various bugs and distribution problems.

a2 also adds several new features:

- Adds 'word', 'line' and 'node' undo granularities.
- Predefines 'c','g', and 'p' in scripts and unit tests.
- Added support for top-level init functions in plugins.
- Buttons can remove themselves when their scripts fail.

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. 
This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail.  Leo is distributed with Pmw (Python Mega Widgets) in this directory.</t>
<t tx="ekr.20050126100405.1"></t>
<t tx="ekr.20050130112336.1">Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.</t>
<t tx="ekr.20050209141626.101"></t>
<t tx="ekr.20050209141626.102">http://sourceforge.net/forum/message.php?msg_id=2958470

I opened a new .leo file, and the cursor was flashing in the text box. I started
typing "@language", and found that the first character is in the text box, and
the rest is in the headline!

What I did:

This was the result of a race condition in the new scheme for setting focus. I
rewrote set_focus so the delayed callback always sets the last requested focus.
The new code also takes care to clear the last request after fulfilling it.</t>
<t tx="ekr.20050209141626.105">http://sourceforge.net/forum/message.php?msg_id=2958470

All changes were to g.app.leoID():

- Fixed bug:  set g.app.leoID in &lt;&lt; put up a dialog requiring a valid id &gt;&gt;.
- Improved signon message.
- Better error handling and reporting. </t>
<t tx="ekr.20050209141626.113">This now works: g.es('',color='red')

g.es must send the original unicode string to the log pane widget, NOT an encoded string.</t>
<t tx="ekr.20050209141626.114">http://sourceforge.net/forum/message.php?msg_id=2983923

- Replaced string.+ with string.% in numerous places.
- Simplified g.openWithFileName and corrected problems in error-reporting logic.</t>
<t tx="ekr.20050209141626.12"></t>
<t tx="ekr.20050209141626.13"></t>
<t tx="ekr.20050209141626.150"></t>
<t tx="ekr.20050209141626.16">http://sourceforge.net/forum/message.php?msg_id=2966541

---- Report:

"Recent Files"  is not remembering files after one closes all open leo sessions.

But it does update the "Recent Files" list while leo is open in the same session.
If one opens more files it adds them to the list. But close all files and Leo
forgets them all.

---- Added to @recentfile documentation: 

Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.</t>
<t tx="ekr.20050209141626.185">When loading plugins, the Leo checks to see if the plugin has an init function
at the top level (the module level). If so, Leo calls the init function. This
function should return True (or equivalent) if the module loaded correctly.

If the top-level init function does not exist, Leo assumes the module loaded
correctly.</t>
<t tx="ekr.20050209141626.190"></t>
<t tx="ekr.20050209141626.193"></t>
<t tx="ekr.20050209141626.194">A script in an @button node or script node can now request to be removed by
setting g.app.scriptDict['removeMe'] = True. Leo checks this value after
executing the script in the button.</t>
<t tx="ekr.20050209141626.195"></t>
<t tx="ekr.20050209141626.196">@nocolor

Added define_p keyword arg in executeScript. When True (the default), the script
or unit test is run in an environment in which c, p and g are all defined.
c is the commander for the outline in which the script appears.
p is the same as c.currentPosition and g is the leoGlobals module.

Therefore, the following lines need never appear in scripts or unit tests!

@color

import leoGlobals as g
p = c.currentPosition()</t>
<t tx="ekr.20050209141626.198"></t>
<t tx="ekr.20050209141626.23">http://sourceforge.net/forum/message.php?msg_id=2960328

Symptom

Can not import messages were not being sent to the console, even though there is a call to es in g.cantImport.

What I did

- The code in g.es now checks for nullLog as well as log == None when deciding when to queue messages.

- g.openWithFileName now calls g.app.writeWaitingLog immediately after enabling the new log.

This writes the queued log messages in the proper order: a major advance in clarity.

- Added silent param to two methods.

This allows the 'reading settings from' message to be sent to the log instead of the default 'reading' message.</t>
<t tx="ekr.20050209141626.3"></t>
<t tx="ekr.20050209141626.4">http://sourceforge.net/forum/message.php?msg_id=2795653

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. There is no longer a node selected in the tree so keyboard tree navigation etc 
commands don't work until you click on something with the mouse

-----

http://sourceforge.net/forum/message.php?msg_id=2795656

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. Hit Hoist before clicking on anything

Now you are hoisted on the recently removed node! The node is dead but his memory lives on ...</t>
<t tx="ekr.20050209141626.42"></t>
<t tx="ekr.20050209141626.43">The new code no longer requires that the present node have a tnodeList.

File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3830, in putOpenNodeSentinel
    at.root.v.t.tnodeList.append(p.v.t)
    
AttributeError: 'tnode' object has no attribute 'tnodeList'</t>
<t tx="ekr.20050209141626.46">The message 'command for widget 5' was a message from Tk saying in effect that no command was bound to the button.

Indeed, this was so: a recent botch in a change in mod_scripting.py prevented the binding.

Moreover, there were some extra print statements in the g.es logic for the Mac.</t>
<t tx="ekr.20050209141626.53">This makes the test more robust in case of failure.</t>
<t tx="ekr.20050209141626.54">Changed the setup code for the import/export test cases so that it uses os.path.sep when it sees \\ in the test nodes.

With this change all unit tests pass on the Mac as well as on XP.</t>
<t tx="ekr.20050209141626.55">*None* of the local settings were working(!!)

The old init code in the configSettings class had no chance of working. We must
use the full g.app.config.get logic.

Added some very simple unit tests to make sure the basics will never break
again so easily.</t>
<t tx="ekr.20050209141626.8"></t>
<t tx="ekr.20050209141626.91">There were problems searching for whitespace.

Note: it just ran slowly &amp; silently.</t>
<t tx="ekr.20050210101318">Typing return now correctly invokes the Find button, without adding a newline in the find string.</t>
<t tx="ekr.20050210102150"></t>
<t tx="ekr.20050210102150.1"></t>
<t tx="ekr.20050210102358"></t>
<t tx="ekr.20050211095754">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2990951
Milan Melena

I think, I found two bugs:

1) leoAtFile.py:
&lt;&lt; read optional encoding param &gt;&gt;
changed first instance of i = j + 1 to i = j + 2

2) leoGlobals.py
g.getScript now returns with

if at.output_newline == 'crlf':
    return script.replace("\r\n","\n")
else:
    return script</t>
<t tx="ekr.20050212054743">At present, such indented blocks may not contain Leo directives or section references.  This will be fixed in 4.3a3.</t>
<t tx="ekr.20050212144116">1. (fixed) C:\prog\leoCVS\leo\src\leoCommands.py:4539: No global (loadDir) found
    # Would cause leoSettings.leo in Window menu to crash.
    
2. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:3426: No global (local) found
    
    # Local --&gt; locale
    # Might cause getpreferredencoding to fail on *nix.
    
3. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:4152: No global (testing) found
    # Should be self.testing.
    
4. (fixed) mu problems:
    - Changed x to self.x:
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3795: No global (removeSentinelsFromLines) found
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3838: No global (getSentinelsFromLines) found
    - Changed self.x to g.x:
        C:\prog\leoCVS\leo\src\leoGlobals.py:3854: No class attribute (comment_delims_from_extension) found
    - pull_source has been renamed, I don not know to what.
        C:\prog\leoCVS\leo\src\leoGlobals.py:4170: Object (mu) has no attribute (pull_source)
        (commented out the code that contains this)
        
5. (removed code) from &lt;&lt; create a node p for  kind &amp; root2 &gt;&gt;
    - last_p is None at first, so last_p.insertAfter does not make sense.</t>
<t tx="ekr.20050221104844">Leo 4.3 alpha 3                 February 24, 2005

Leo 4.3 is the culmination of more than five months of work. This alpha 3
release corrects various bugs in Leo's core and in plugins. This is the first
release that include an installer for MacOSX.

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically.
This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.</t>
<t tx="ekr.20050221104844.12">http://sourceforge.net/forum/message.php?msg_id=2999651

I was pleasantly surprised to discover the reST2 plug-in working under 4.3a2
(this is one the first thing I try as I'd like to use Leo as an editor
for that).

As mentioned in early threads, it still needs @rst for each node to be included
in the reST rendering process. So I put @rst test.html and then a child with
@rst and some reST code and it worked !!

Then I tried to to get a simple rst file using @rst test but the plugin complained:

[snip]

  File "C:\dn_apps\Leo\plugins\rst2.py", line 164, in onIconDoubleClick
    writeTreeAsRst(rstFile,fname,p,c)
TypeError: writeTreeAsRst() takes exactly 5 arguments (4 given)

So I looked at the rst2.py and found a way to get it working but I would need
someone to verify it :

line 164, replaced   writeTreeAsRst(rstFile,fname,p,c)  by

syntax = False
writeTreeAsRst(rstFile,fname,p,c,syntax)

And it worked!
</t>
<t tx="ekr.20050221104844.14"></t>
<t tx="ekr.20050221104844.2"></t>
<t tx="ekr.20050221104844.27">http://sourceforge.net/forum/message.php?msg_id=3005140
By: ktenney

- perform a search which marks a number of nodes
- select "Outline -&gt; Mark/Unmark -&gt; Unmark All"
- Several marks are still listed in in the nodenavigator "Marks" list.
  (They are not marked in the outline.)

What I did:

- The p.set/clearMark methods now call the hook _after_ changing the marked status.
  This fixes the apparent bug in nodenavigator.py.
- Rewrote nav_buttons.py.  The old code was a mess; the new code is clean.
- Changed the vnodeList ivar in leoTkinterDialog to positionList.
- Rewrote c.unmarkAll to make clear that it is using positions.
    - Added test_c_unmark_all test routine.</t>
<t tx="ekr.20050221104844.3">http://sourceforge.net/forum/message.php?msg_id=2998446
By: djsg

g.create_temp_name() calls tempfile.mktemp or mkstemp(), but these return different values!

mktemp returns the filename(a string); mkstemp returns a tuple (handle,filename)

What I did:

- Changed g.create_temp_name to g.create_temp_file.
- Removed the file open logic in tangle.put_all_roots (now done in g.create_temp_file)
- Rewrote g.create_temp_file so it works in both cases.
- Create test routine for g.create_temp_file
- Created very simple unit tests in test.leo for tangle and untangle.</t>
<t tx="ekr.20050221104844.45">http://sourceforge.net/forum/message.php?msg_id=2958470
From: Rich

Leo 4.3 alpha 1, build  1.208 , January 24, 2005
Python 2.3.4, Tk 8.4.3, win32

Opened a new .leo file. It asked for an ID, and said it saved it. Closed the
new leo file &amp; tried opening "Leo\config\leoSettings.leo". _It_ is asking for
a leoID!

What I did

All changes were to g.app.leoID():
    - Fixed bug:  set g.app.leoID in &lt;&lt; put up a dialog requiring a valid id &gt;&gt;.
    - Improved signon message.
    - Better error handling and reporting. </t>
<t tx="ekr.20050221104844.54">g.pdb wasn't working because pdb wasn't imported inside the function.</t>
<t tx="ekr.20050221104844.57"></t>
<t tx="ekr.20050221104844.58">This allows plugins such as plugin_manager.py to work on Python 2.2.x.</t>
<t tx="ekr.20050221104844.59">g.es does nothing if color=='suppress'.  This can be useful in unit tests.</t>
<t tx="ekr.20050222100936">http://sourceforge.net/forum/message.php?msg_id=3008045

Leo crashed when executing a script if the script was selected text in a new window.

What I did:

- g.getScript now calls g.getOutputNewline(c=c) rather than look at atFile.output_newline.

atFile.output_newline may not exist if a) the file is new and b) g.getScript
doesn't call atfile.write.

- Set scripting=scriptWrite in call to atFile.scanAllDirectives in atFile.write.

This suppresses the following irrelevant message when executing scripts:

    "No absolute directory specified anywhere."</t>
<t tx="ekr.20050306090601">Leo's .leo file format is extensible.
The basis for extending .leo files are the v.unknownAttributes ivars of vnodes,
uA's for short.
Leo translates between uA's and xml attributes in the corresponding
&lt;v&gt; elements in .leo files.
Plugins may also use v.tempAttributes ivars to hold temporary information
that will *not* be written to the .leo file.
These two ivars are called **attribute ivars**.

Attribute ivars must be Python dictionaries, whose keys are names of plugins and
whose values are *other* dictionaries, called **inner dictionaries**, for
exclusive use of each plugin.

The v.u Python property allows plugins to get and set v.unknownAttributes easily::

    d = v.u # gets uA (the outer dict) for v
    v.u = d # sets uA (the outer dict) for v
    
For example:

    plugin_name = 'xyzzy'
    d = v.u # Get the outer dict.
    inner_d = d.get(plugin_name,{}) # Get the inner dict.
    inner_d ['duration']= 5
    inner_d ['notes'] "This is a note."
    d [plugin_name] = inner_d
    v.u = d
    
No corresponding Python properties exist for v.tempAttributes,
so the corresponding example would be::

    plugin_name = 'xyzzy'
    # Get the outer dict.
    if hasattr(p.v,'tempAttributes'): d = p.v.tempAttributes
    else: d = {}
    inner_d = d.get(plugin_name,{}) # Get the inner dict.
    inner_d ['duration'] = 5
    inner_d ['notes'] = "This is a note."
    d [plugin_name] = inner_d
    p.v.tempAttributes = d

**Important**: All members of inner dictionaries should be picklable: Leo
uses Python's Pickle module to encode all values in these dictionaries. Leo will
discard any attributes that can not be pickled. This should not be a major
problem to plugins. For example, instead of putting a tnode into these
dictionaries, a plugin could put the tnode's gnx (a string) in the dictionary.

**Note**: Leo does *not* pickle members of inner dictionaries whose name (key) starts with str\_.
The values of such members should be a Python string.
This convention allows strings to appear in .leo files in a more readable format.

Here is how Leo associates uA's with &lt;v&gt; elements in .leo files:

- **Native xml attributes** are the attributes of &lt;v&gt; elements that are
  known (treated specially) by Leo's read/write code. The native attributes of
  &lt;v&gt; elements are a, t, vtag, tnodeList, marks,
  expanded and descendentTnodeUnknownAttributes. All other attributes of
  &lt;v&gt; and &lt;t&gt; elements are **foreign xml attributes**.

- When reading a .leo file, Leo will create v.unknownAttributes ivars for
  any vnode whose corresponding &lt;v&gt; or &lt;t&gt; element contains a
  foreign xml attribute.

- When writing a file, Leo will write foreign xml attributes in &lt;v&gt; elements
  if the corresponding vnode contains an unknownAttributes ivar.

- Leo performs the usual xml escapes on these strings when reading or writing
  the unknownAttributes ivars.</t>
<t tx="ekr.20050313101229">Leo 4.3 alpha 4                 March 15, 2005

Leo 4.3 is the culmination of more than five months of work. This alpha 4
focuses on plugins: all known plugins are now in leoPlugins.leo. Most plugins
now work with the 4.3 code base. Warning: not all plugins have been tested
thoroughly.

This alpha 4 release also adds the frequently-requested Add Comments and Delete
Comments commands to Leo's Edit Body menu.

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. 
This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.</t>
<t tx="ekr.20050313101229.100">Fixed problems in the following plugins. See the &lt;&lt; version history &gt;&gt; section
in each plugin for details.

autocompleter.py
cleo.py
mod_scripting.py
mod_tempfname.py
templates.py
vim.py
xemacs.py

Replaced the 'new_c' key by the 'c' key in the following plugins:

ConceptualSort.py
URLloader.py
UASearch.py
arrows.py
autocompleter.py
base64Packager.py
cleo.py
dyna_menu.py
macros.py
mod_read_dir_outline.py
mod_scripting.py
multifile.py
nodebar.py
nodenavigator.py
open_with.py
scheduler.py
read_only_nodes.py
templates.py

Replaced the 'start2' hook by the 'new' hook in the following plugins: (This was
made possible now that 'new' is called when opening a new window if the
'open1/2' hooks are not called.

URLloader.py
UASearch.py
at_produce.py
autocompleter.py
color_markup.py
fastGotoNode.py
groupOperations.py
import_cisco_config.py
multifile.py
nodebar.py
open_with.py
read_only_nodes.py
scheduler.py
table.py
usetemacs.py
xsltWithNodes.py</t>
<t tx="ekr.20050313101229.101">atFile.copyAllTempBodyStringsToTnodes calls:

    c.mod_label_controller.add_label(p,"before change:",old_body)</t>
<t tx="ekr.20050313101229.2"></t>
<t tx="ekr.20050313101229.69">Nodes containing the @root directive did not honor @nocolor directives.</t>
<t tx="ekr.20050313101229.74">http://sourceforge.net/forum/message.php?msg_id=3035471

Leo was not inserting a visible horizontal scrollbar when @nowrap was in effect.</t>
<t tx="ekr.20050313101229.77">http://sourceforge.net/forum/message.php?msg_id=3042593

Leo now properly redraws the screen after a Change All command.</t>
<t tx="ekr.20050313101229.94">Several hooks use the 'new_c' key in the keywords dictionary. Plugin writers had
to remember whether to get the commander using keywords.get('c') or
keywords.get('new_c') or both. This was needlessly confusing.

All hooks that use the 'new_c' key now use also include the 'c' key. The 'new_c'
key is deprecated; plugins should use the 'c' key instead. 

None of the plugins presently in leoPlugins.leo use the 'new_c' key, but the
'new_c' key still exists for compatibility.

The following plugins were affected by this change:

ConceptualSort.py
URLloader.py
UASearch.py
arrows.py
autocompleter.py
base64Packager.py
cleo.py
dyna_menu.py
macros.py
mod_read_dir_outline.py
mod_scripting.py
multifile.py
nodebar.py
nodenavigator.py
open_with.py
scheduler.py
read_only_nodes.py
templates.py</t>
<t tx="ekr.20050313101229.95">The Add Comments command puts comments around a block of code. This command uses
single-line comments if the language in effect for the node supports single-line
comments.

The Delete Comments command deletes the comments specified by the Add Comments command.</t>
<t tx="ekr.20050313102319">-   The Add Comments command puts comments around a block of code.
    This command uses single-line comments if possible.

-   The Delete Comments command deletes the comments specified by the Add Comments command.</t>
<t tx="ekr.20050313103448"></t>
<t tx="ekr.20050313103448.1">Leo calls the 'before-create-leo-frame' hook just before calling frame.onCreate.
Similarly, Leo calls the 'after-create-leo-frame' just after calling
frame.onCreate.</t>
<t tx="ekr.20050404094627"></t>
<t tx="ekr.20050407144342"> 
        
        
        </t>
<t tx="ekr.20050407144342.1"></t>
<t tx="ekr.20050407144342.2"></t>
<t tx="ekr.20050407144342.3"></t>
<t tx="ekr.20050407144417"></t>
<t tx="ekr.20050417072710.1">Plugins and scripts should call u.beforeX and u.afterX methods ato
describe the operation that is being performed. **Note**: u is shorthand for
c.undoer. Most u.beforeX methods return undoData that the client
code merely passes to the corresponding u.afterX method. This data contains
the 'before' snapshot. The u.afterX methods then create a bead containing
both the 'before' and 'after' snapshots.

u.beforeChangeGroup and u.afterChangeGroup allow multiple calls to
u.beforeX and u.afterX methods to be treated as a single undoable entry.
See the code for the Change All, Sort, Promote and Demote
commands for examples. The u.beforeChangeGroup and u.afterChangeGroup
methods substantially reduce the number of u.beforeX and afterX methods
needed.

Plugins and scripts may define their own u.beforeX and afterX methods. Indeed,
u.afterX merely needs to set the bunch.undoHelper and
bunch.redoHelper ivars to the methods used to undo and redo the operation.
See the code for the various u.beforeX and afterX methods for guidance.

p.setDirty and p.setAllAncestorAtFileNodesDirty now return a
dirtyVnodeList that all vnodes that became dirty as the result of an
operation. More than one list may be generated: client code is responsible for
merging lists using the pattern dirtyVnodeList.extend(dirtyVnodeList2)

See the section &lt;&lt; How Leo implements unlimited undo &gt;&gt; in leoUndo.py
for more details. In general, the best way to see how to implement undo is to
see how Leo's core calls the u.beforeX and afterX methods.</t>
<t tx="ekr.20050429094215">Leo 4.3 beta 1                 April 30, 2005

Leo 4.3 beta 1 completes all major features of Leo 4.3. There are no known
significant bugs remaining.

The defining features of Leo 4.3:
---------------------------------
1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo now stores recent files information in .leoRecentFiles.txt files.

4. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

5. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. 
This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

6. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.</t>
<t tx="ekr.20050429094215.113">The status bits weren't being passed to v.initStatus!</t>
<t tx="ekr.20050429094215.116">Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 174, in doCommand
    command()
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 863, in importDerivedFile
    c.importCommands.importDerivedFiles(v,names)
  File "C:\prog\leoCVS\leo\src\leoImport.py", line 137, in importDerivedFiles
    isThin = at.scanHeaderForThin(theFile,fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 570, in scanHeaderForThin
    junk,junk,isThin = at.scanHeader(theFile,fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2616, in scanHeader
    at.error("Bad @+leo sentinel in: %s" % fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4500, in error
    self.printError(message)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4509, in printError
    if self.errors == 0:
AttributeError: atFile instance has no attribute 'errors'
</t>
<t tx="ekr.20050429094215.120">Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1409, in idle_scrollTo
    h1 = self.yoffset(p)
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1488, in yoffset
    h, flag = self.yoffsetTree(root,v1)
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1506, in yoffsetTree
    h2, flag = self.yoffsetTree(child,p1)
  
# Maximum recursion depth exceeded.

It is still not completely clear why this happened.</t>
<t tx="ekr.20050429094215.130"></t>
<t tx="ekr.20050429094215.131">- Moved computeGlobalConfigDir, computeHomeDir, computeLoadDir and
startupEncoding from leo.py to leoGlobals.py.

- Created g.computeStandardDirectories and used it in leo.py.

- Created g.createStandAloneApp using the above functions. This function was
based on the 'Standalone Operation' classed in the plugin_manager plugin.
g.createStandAloneApp doesn't actually use any of these classes because the
nullGui class is basically a clumsier version of the BlackHole class.

- Added a do-nothing attachLeoIcon method to nullGui class to suppress a
warning. As I said, the nullGui class is not as elegant as Paul's BlackHole
class.

- Added &lt;&lt;importLeoGlobals&gt;&gt; button to newButtons plugin. This creates a node
  named &lt;&lt; define importLeoGlobals &gt;&gt; whose body text defines an
  importLeoGlobals function.

The idea is that importing leoGlobals from a stand-alone plugin is a bit tricky.
The importLeoGlobals handles these details. Note that we don't want to define
importLeoGlobals in a node included by @others, because this function must be
available to the code in the &lt;&lt; imports &gt;&gt; section. So we use a named section
and reference it in before referencing the &lt;&lt; imports &gt;&gt; section. See the
plugin_manager plugin for an example.

- Changed the plugin_manager plugin as follows: - Used the newButtons plugin to
    add an &lt;&lt; define importLeoGlobals &gt;&gt; section. - Simplified the import logic
    using importLeoGlobals function. - Commented out the Standalone Operation
    classes. - Called g.createStandAloneApp in the '__name__ == "__main__"'
    code.</t>
<t tx="ekr.20050429094215.139">- config.openSettingsFile returns None if there is a read error.

- leoFileCommand.open gives no BadLeoFile message if silent is True.</t>
<t tx="ekr.20050429094215.145">- Simplified write_Leo_file using new leoFileCommand.deleteFileWithMessage and g.utils_rename.

- Eliminated outputList var.
    - The code that writes to a clipboard sets self.outputFile to g.fileLikeObject.

- Sped up put routine: it always writes to self.outputFile.

- self.outputFile is now a cStringIo object.  However, the heart of the put routine is:

    s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
    self.outputFile.write(s)

and it appears that the call to g.toEncodedString is the limiting factor.</t>
<t tx="ekr.20050429094215.173">- Use g.Bunch to simplify code.
- Added 'before' &amp; 'after' methods
- Added entries to optionalIvars dynamically in bead methods.
- Eliminated 'case-itis' by making it unnecessary ever to add more cases.
- Removed 'v' key in undoer:  replaced it with 'p'.
- Replaced u.v by u.p and v by p in find code (It's too confusing).
- p.setDirty and p.setAllAncestorAtFileNodesDirty  return list of nodes that were marked dirty.
- Create new top-level before/after methods &amp; helpers:
- Changed setUndoTypingParams to use new dispatch method.
- Removed makeBeadDict.
- Removed updateSetChangedFlag.
- Added new methods to nullUndoer class.
- Moved undo methods from leoNodes.py to leoUndo.py
- Added dirtyVnodeList param to afterChangeNodeContents.</t>
<t tx="ekr.20050429094215.2"></t>
<t tx="ekr.20050429094215.22">Initial bug report:

http://sourceforge.net/forum/message.php?msg_id=3053699

There were three similar bugs, all arising from the fact that g.os_path_abs and
g.os_path_join return the _working_ directory if the initial path is None!

I removed my HOME directory for testing. This was essential.

- Compute home directory must return None, rather than the working directory if
the HOME variable is None.

- app.setLeoId must be careful (in two sections) to do nothing if any of
(homeDir,globalConfigDir,loadDir) is None.</t>
<t tx="ekr.20050429094215.286"></t>
<t tx="ekr.20050429094215.3">The initial bug report:

http://sourceforge.net/forum/message.php?msg_id=3048149

The problem arose from a misguided attempt to eliminate non-useful information
from traces. Alas, the baby got thrown out with the bath water.

Here are the changes I made:

 - c.executeScript now calls g.es_exception(full=True) to ensure that a full
 stack trace always gets produced. This is especially important when the
 exception happens in a module (file) called by the script.

- c.executeScript now always executes the section &lt; &lt; dump the lines near the
error &gt; &gt;, regardless of context. The lines are printed (in black) in the log.
This is useful information in almost all cases.

- After much experimentation, g.es_exception is basically unchanged. Note: If
the error occurs in your script itself (as contrasted with an exception thrown
from a file called by your script) Leo always has properly put the cursor on the
offending line. I made no changes in this logic.

BTW, calling pdb.set_trace() in your scripts may cause more problems than it is
worth. Indeed.pdb.set_trace() uses only the information on the stack, and that
may not be enough information to be useful. I usually use g.trace to find out
what is happening. This works well.</t>
<t tx="ekr.20050429094215.31">The problem is that newButtons must use @nosent, so any changes to newButtons
must be accompanied by a change to LeoPluginsRef.py. There is nothing more that
needs to be done.</t>
<t tx="ekr.20050429094215.316">The only changes concern how Leo encodes and decodes items in
t.unknownAttributes and v.unknownAttributes.

Without changing the file format, the only way to tell Leo how to write
attributes is to use naming conventions. When writing attributes, Leo now does
the following:

- Do nothing except apply xml escapes if the attribute name (in
t.unknownAttributes or v.unknownAttributes) starts with str_ and the attribute
is, in fact, a string. If the string is a Unicode string Leo converts the
Unicode string to an encoded string.

- Use the present pickling/hexlifying scheming otherwise. In particular, issue a
warning and ignore the attribute if the attribute can not be pickled. BTW, there
is no need for separate base64 support: hexlifying guarantees that the result is
valid in any xml environment.

Leo now does the reverse when reading.

BTW, plugins could add their own naming conventions in an emergency. Indeed, the
conventions will be confined to code in atFile.putUa and atFile.getUa, so a
plugin would only need to override these two methods.</t>
<t tx="ekr.20050429094215.347">Removed inAtOthers  param from putOpen/CloseNodeSentinel.
Removed inAtAll param from putCloseNodeSentinel.
Removed putCloseSentinel param from putAtAllBody
Removed putCloseSentinel param from putBody

Removed toString param from openFileForWritingHelper
Removed toString param from v.putUnknownAttributes

Note: most(all?) top-level atFile.write methods pass toString to initWriteIvars.</t>
<t tx="ekr.20050429094215.353">Leo stores recent files information as follows.

1. Leo stores recent files info in files called .leoRecentFiles.txt. These will
be a plain text files with one line per recent files entry. An Easter egg: if
the file starts with read-only, read_only, readonly, etc. Leo will never update
the file and will not remember changes to the Recent Files menu.

2. On startup, Leo searches for the .leoRecentFiles.txt files in the user's home
directory, if it exists. Leo looks in Leo's config directory next, but only if
the home directory does not exist, or does not contain a .leoRecentFiles.txt
file. In other words, Leo will use at most one .leoRecentFiles.txt file on
startup.

3. When opening a .leo file, Leo looks for .leoRecentFiles.txt in the directory
containing the file.

4. At no time after installation does Leo create any .leoRecentFiles.txt file.
This will allow users (or their managers) to set policy regarding where to store
this information (if anywhere).

5. Leo writes at most one .leoRecentFiles.txt file when saving a .leo file,
namely the file read in item 3 if it exists, or the file read in item 2
otherwise.

This is a flexible scheme that should meet most needs without having to resolve
thorny questions about exactly where recent files info belongs.</t>
<t tx="ekr.20050429094215.354">@killcolor

- Properly implemented undo/redo Clear Recent Files.

- readSettingsFiles now reads @recentfiles nodes from all settings files.

- Created @settings nodes and @recent-files nodes if they do not exist.</t>
<t tx="ekr.20050429094215.355">You all have convinced me that storing recent files data in .leo files is a
dubious idea. My new plan is as follows:

1. Leo will store recent files info in files called .leoRecentFiles.txt. These
will be a plain text files with one line per recent files entry. These will be
local files, so problems concerning directory structure and path specifications
should go away.

2. On startup, Leo will search for the .leoRecentFiles.txt files in the user's
home directory, if it exists. Leo will look in Leo's config directory next, but
only if the home directory does not exist, or does not contain a
.leoRecentFiles.txt file. In other words, Leo will use at most one
.leoRecentFiles.txt file on startup.

3. When opening a .leo file, Leo will look for .leoRecentFiles.txt in the
directory containing the file.

4. At no time after installation will Leo create any .leoRecentFiles.txt file.
This will allow users (or their managers) to set policy regarding where to store
this information (if anywhere).

5. Leo will write at most one .leoRecentFiles.txt file when saving a .leo file,
namely the file read in item 3 if it exists, or the file read in item 2
otherwise.

6. Leo will have settings to tell which .leoRecentFiles.txt files may be
written.

7. Leo will never create @settings nodes or @recent-files nodes automatically.
Moreover, I shall remove the @recent-files panel from the settings dialog and
the corresponding @recent-files code from the config classes.

I believe this will address everyone's concerns without the need for resolving
thorny questions about exactly where recent files info belongs.</t>
<t tx="ekr.20050429094215.41">The De-hoist command conflicted with the Expand/Contract submenu.

The Paste Node As Clone conflicted with the Mark submenu.</t>
<t tx="ekr.20050429095849">- Saved expansion state of @settings trees when the user hits the OK button.

- Added support for UNL's in the status line when the settings dialog is active.

- Debugged @if-platform, @if-gui, @ints &amp; @strings.

- Reloaded settings files when opening the settings dialog.

- Removed support for @recent-files nodes.  This is now handled by .leoRecentFiles.txt files.</t>
<t tx="ekr.20050513141852">Leo 4.3 beta 2                 May 15, 2005

Leo 4.3 beta 2 completes all major features of Leo 4.3 and fixes all bugs
reported since the beta 1 release.

The defining features of Leo 4.3:
---------------------------------
1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo now stores recent files information in .leoRecentFiles.txt files.

4. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

5. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

6. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.</t>
<t tx="ekr.20050513141913.1"></t>
<t tx="ekr.20050513141913.127">http://sourceforge.net/forum/forum.php?thread_id=1281868&amp;forum_id=10226

doStrings now accepts either:

@strings[values]name=value
@strings name[values]=value

Similarly, doInts accepts:

@ints[values]name=value
@ints name[values]=value</t>
<t tx="ekr.20050513141913.140">http://sourceforge.net/forum/message.php?msg_id=3149604

Changed c.hoistStack[-1].current to c.hoistStack[-1].p in c.insertHeadline.</t>
<t tx="ekr.20050513141913.145">http://sourceforge.net/forum/forum.php?thread_id=1281868&amp;forum_id=10226

The code now calls frame.resizePanesToRatio in createFrame in Leo.

Not only does this fix this bug, it honors the following settings:

- initial_horizontal_ratio
- initial_horizontal_secondary_ratio
- initial_vertical_ratio
- initial_vertical_secondary_ratio</t>
<t tx="ekr.20050513141913.149">http://sourceforge.net/forum/message.php?msg_id=3138608

Replaced individual shortcuts widget with a single text widget. This allows the
user to add or delete shortcuts.</t>
<t tx="ekr.20050513141913.16">http://sourceforge.net/forum/message.php?msg_id=3133917

'Recent' and 'Marked' button now appear in new windows.</t>
<t tx="ekr.20050513141913.17">http://sourceforge.net/forum/message.php?msg_id=3133915

The colorizer now correctly handles the following:
    
\@, \(, \), \{, \}

And also constructs like \documentclass{report}.</t>
<t tx="ekr.20050513141913.187"></t>
<t tx="ekr.20050513141913.188">http://sourceforge.net/forum/message.php?msg_id=3135170</t>
<t tx="ekr.20050513141913.194">For a test of this, see the script in test.leo at:
    
Scripts--&gt;Script to execute @test, @suite or file

Read the documentation in that node before running the script.</t>
<t tx="ekr.20050513141913.197">g.getScript now fully processes all scripts, regardless of where they came from.

- Changed g.getScript:
    - p arg is now required.
    - Removed unused script arg.
    - Added forcePythonSentinels arg (default is True).
    - g.getScript no longer temporarily alters any body text.
        - atFile.writeFromString gets the initial text using the fromString arg.
    - g.getScript now always calls atFile.writeFromString to handle all Leo directives.

- Added forcePythonSentinels to atFile.initWriteIvars and atFile.scanAllDirectives.
    - Default is None, in which case the code sets forcePythonSentinels to the scriptWrite arg.

- Added forcePythonSentinels to atFile.scanAllDirectives.
    - Default is False.

- Created atFile.putAtFirstLines and atFile.putAtLastLines.
    - These replace the corresponding sections in writeOpenFile.
    - It was not actually necessary to define these, but it cleans up the code.

- Created atFile.writeFromString.
    - This handles all the details of simulating a write _from_ a string _to_ a string.

- atFile.initWriteIvars and atFile.openFileForWriting now allow root to be None.
    - This is not used at present: root is always defined.

- Added fromString arg to atFile.writeOpenFile and atFile.putBody.</t>
<t tx="ekr.20050513141913.22">http://sourceforge.net/forum/message.php?msg_id=3051870</t>
<t tx="ekr.20050513141913.233">http://sourceforge.net/forum/forum.php?thread_id=1281640&amp;forum_id=10228

The default is ''.  It define_name exists c.executeScript executes the script in an environment containing
__name__ = define_name.</t>
<t tx="ekr.20050513141913.30">http://sourceforge.net/forum/message.php?msg_id=3138608

The nav_buttons plugin was using self.c rather than keywords.get('c') in a hook
handler. The general rule is that hook handlers should do nothing if self.c !-
keywords.get('c').  This was an old bug, arising from the rewrite of the plugin.

I added a warning to that effect in the plugin template.

It would perhaps be better to specify an optional commander in registerHandler
and only call the handler if the commander matches. However, this isn't so easy
or clean to do.I

http://sourceforge.net/forum/forum.php?thread_id=1282631&amp;forum_id=10226
 
The plugin was failing to set the positionList ivar (in the base
tkinterListBoxDialog class). This was a fairly recent blunder: I saw that
positionList wasn't used in the plugin directly, so I 'improved' the code by
using a local var instead of self.positionList. This illustrates a hazard of
using subclassing.</t>
<t tx="ekr.20050513141913.57">This happened when creating a new chapter with chapters.py enabled.</t>
<t tx="ekr.20050513141913.60">http://sourceforge.net/forum/forum.php?thread_id=1281868&amp;forum_id=10226

The fix was to recompute newSel in &lt;&lt; handle backspace with negative tab_width &gt;&gt; in idle_body_key.</t>
<t tx="ekr.20050513141913.82">- The section name lost its indentation.
- The created section had extra indentation.
- Undoing did not remove the inserted section node.

The unit tests now properly test indentation.</t>
<t tx="ekr.20050513141913.91">http://sourceforge.net/forum/message.php?msg_id=3143895

The Edit-&gt;Delete command did nothing when the selected text was in a headline.</t>
<t tx="ekr.20050513141913.97">The following methods changed:

- markAllAtFileNodesDirty
- markAtFileNodesDirty
- markClones
- markHeadline
- markSubheads

I also rewrote the code using explicit positions.</t>
<t tx="ekr.20050523092026">Leo 4.3 final                 May 23, 2005

Leo 4.3 is here after almost five months of work.

The defining features of Leo 4.3:
---------------------------------
1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo now stores recent files information in .leoRecentFiles.txt files.

4. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

5. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

6. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.</t>
<t tx="ekr.20050523092056.1">http://sourceforge.net/forum/message.php?msg_id=3155657

Enabling the Pie Menu plug-in caused Leo to quit when opening .leo files.</t>
<t tx="ekr.20050523092056.4">This fixed a recent bug.
The crash happened if not section text was specified.
Added new checks and new error messages.</t>
<t tx="ekr.20050620144052">Leo 4.3.1                    June 20, 2005

- Added support for Tk resource files.
- Added support for coloring the PL/SQL language.
- All Mark commands are now undoable.
- Improved Resize To Screen command.
- The usual assortment of minor bug fixes.</t>
<t tx="ekr.20050620144052.112">The problem was that leo.__file__ returns a randomly upper or lower cased drive letter.</t>
<t tx="ekr.20050620144052.114"># The About Leo dialog was not getting focus.</t>
<t tx="ekr.20050620144052.116"></t>
<t tx="ekr.20050620144052.119">http://sourceforge.net/forum/message.php?msg_id=3176499

5) am I missing text in the Settings panels?  the outline shows that certain
nodes have text (e.g., "About keyboard shortcuts" has the blue rectangle), yet
the body pane is empty; heck, even the title suggests that something should
be there...
</t>
<t tx="ekr.20050620144052.154">http://sourceforge.net/forum/message.php?msg_id=3190593

As luck would have it, I need to put an @ character at the beginning of a line
in source code (windows registry file format) and can't figure out how to do
it. 
</t>
<t tx="ekr.20050620144052.166"></t>
<t tx="ekr.20050620144052.182">http://sourceforge.net/forum/message.php?msg_id=3186385

I just tried 4.3-final, and it seems it does not work with Chinese LC_CTYPE:</t>
<t tx="ekr.20050620144052.185">http://sourceforge.net/forum/message.php?msg_id=3175553

When I set default_target_language to plain in 4.2., no words in any body text
is colored. This behavior seems to have changed in 4.3. Is it right, that I
now have to write @nocolor on top of *every* body text to get rid of randomly
colored words?
 
What I did:

- Added entries for target_language to ivarsDic and defaultsDict in leoConfig.py.
- Added @language target_language = Python to leoSettings.leo.
- Convert c.target_language to lowercase in several places.</t>
<t tx="ekr.20050620144052.2"></t>
<t tx="ekr.20050620144052.207"></t>
<t tx="ekr.20050620144052.208">idle_body_key now calls doAutoIndent and convertBlanksToTabs. The idea is that
plugins could override these methods if desired.</t>
<t tx="ekr.20050620144052.210"># I also fixed a bug: the Mark Clones command did not work!</t>
<t tx="ekr.20050620144052.222">Some non-standard distributions don't include the profile and pstats modules.</t>
<t tx="ekr.20050620144052.231">Leo will now look for a file called .leo_xresources in the users home directory.
If found, Leo will pass that file to Tk's option_readfile method for the top
widget. This allows users to set Tk options.</t>
<t tx="ekr.20050620144052.3">http://sourceforge.net/forum/message.php?msg_id=3166883
By: rogererens

I swear I didn't wait for the release to be the first to report a bug! I just
didn't try this in the alpha/beta versions:

Leo 4.3 final, build  1.262 , May 23, 2005
Python 2.4.1, Tk 8.4.7, win32

Changing
Global settings: C:\Leo\config\leoSettings.leo--&gt;Window options--&gt;@page Options
for new windows--&gt;@ratio initial_horizontal_ratio = 0.3
or any of the other ratios, does not save them to leoSettings.leo. So after
restarting I still have the old settings in use.
</t>
<t tx="ekr.20050620144052.48">- Fixed bugs in convertAllBlanks and convertAllTabs.

These must always call afterChangeGroup to match beforeChangeGroup, even if
nothing has changed.

- Added u.getMark and u.rollbackToMark.

These allow unit tests to cut the undo stack back to an initial position in the
tearDown method. This should be done for all tests that use u.undo and u.redo
methods. The bug was probably the result of changing the outline in the tearDown
method.

Both the Reformat Paragraph and Edit Body unit tests now roll back the undo stack.

- Added traces for unexpected conditions in u.undo, u.redo and tree.select.

- Call u.setUndoTypes() in u.setUndoTypingParams when returning early.

- Corrected Edit Body unit tests.

These tests should not call undo/redo when nothing is expected to change. Doing
so may trigger the new 'cant undo' traces in u.undo.

- doTest in leoTest.py now makes copies of both p and p1.

It's not clear that this is needed, it can't hurt, and it may have been important.</t>
<t tx="ekr.20050620144052.6">http://sourceforge.net/forum/message.php?msg_id=3167166

The fix was to add the following line to the init function:

    global click_registry, coloured_nodes</t>
<t tx="ekr.20050620144052.8">Modifying outlines can invalidate existing positions! This rarely happens. At
present it affects the atFile.read logic when reading an outline whose initial
current position is a clone outside an @thin tree with another clone inside the
@thin tree. So the read logic computes the expected current position before
reading all external files, and this expected current position becomes invalid.

What I did:

1. Moved &lt;&lt; set current and top positions &gt;&gt; from getVnodes to end of
getLeoFile. This ensures that the outline won't change after computing the
position.

2. Unit tests will have to be revised to make sure that only valid positions get
used.</t>
<t tx="ekr.20050620144425"></t>
<t tx="ekr.20050620144602"></t>
<t tx="ekr.20050620150517">Leo looks for a file called .leo_xresources in the users home directory. If
found, Leo will pass that file to Tk's option_readfile method for the top
widget. This allows users to set Tk options.</t>
<t tx="ekr.20050812090111">import leo.core.leoPlugins as leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        controller.processTopTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20050812123002"></t>
<t tx="ekr.20050812123002.1"></t>
<t tx="ekr.20050812123002.2">Deletes p.v.rst2_http_attributename from all nodes after writing.

Deletes p.v.unknownAttributes if it then becomes empty.</t>
<t tx="ekr.20050812123002.3"></t>
<t tx="ekr.20050812123002.4">@nocolor

If False, add_node_marker and http_support_main  do nothing.  Otherwise add_node_marker does the following:
    
1. add_node_marker writes a string using generate_node_marker.

Generates 'http-node-marker-'+str(number), where number is config.node_counter
(incremented each time add_node_marker is called.

2. Enables the following code in :
@color

    if config.tag == 'open2':
        http_map = self.http_map
    else:
        http_map = {}
        config.anchormap = {}
        # maps v nodes to markers.
        config.node_counter = 0
    # [snip] code to write the tree
    if config.rst2_http_server_support:
        self.http_map = http_map</t>
<t tx="ekr.20050812123002.5"></t>
<t tx="ekr.20050812123002.6">True: call body_filter to massage text.

Removes @ignore, @nocolor, @wrap directives.
</t>
<t tx="ekr.20050812123002.7">Used differently.  See rst2_pure_document.</t>
<t tx="ekr.20050812123002.8"></t>
<t tx="ekr.20050812134441">.. External links...
.. _`Open Software`:    http://www.opensource.org/
.. _Python:             http://www.python.org/
.. _`SourceForge`:      http://sourceforge.net/projects/leo/

.. Relative links...
.. _clones:             intro.html#clones-views
.. _leo:                front.html
.. _outline:            intro.html#introduction
.. _outlines:           intro.html#introduction
.. _plugins:            intro.html#plugins-settings
.. _scripting:          intro.html#scripting-leo
.. _users:              http://sourceforge.net/projects/leo/
</t>
<t tx="ekr.20050812134441.1">.. Links used in this document.
.. _front:          front.html
.. _chapter6:       design.html
.. _chapter8:       customizing.html
.. _`rst3 plugin`:  rstplugin3.html
</t>
<t tx="ekr.20050818163826">.. publish_argv_for_missing_stylesheets = --language=de,--documentclass=report,--use-latex-toc

######################################
Chapter 14: Leo and ReStructuredText
######################################

.. .. contents::
</t>
<t tx="ekr.20050818163826.1">.. rST links used in this document...

.. External links...
.. _docutils:           http://docutils.sourceforge.net
.. _LaTeX:              http://www.latex-project.org/
.. _reStructuredText:   http://docutils.sourceforge.net/rst.html
.. _SilverCity:         http://silvercity.sourceforge.net
.. _Sphinx:             http://sphinx.pocoo.org/

.. Hard links to Leo's web site...
.. _ListManagerDocs.html: http://webpages.charter.net/edreamleo/ListManagerDocs.html
.. _wxListManager.leo:    http://webpages.charter.net/edreamleo/wxListManager.leo
</t>
<t tx="ekr.20050818163826.10">The rst3 command defines a code-block rST directive. The primary purpose of this
directive is to show formatted source code.

In rst mode you can insert the code-block directive like any other rST markup.
The rst3 command generates code-block directives when handling nodes in code
mode.

This directive takes one argument, a language name.  Like this::

    .. code-block:: Python

        import leo.core.leoPlugins as leoPlugins
        import leo.core.leoGlobals as g

This directive syntax colors the code in the indented code block that follows the directive.
The result looks like this if the SilverCity syntax coloring module has been installed.

.. .. code-block:: Python

    .. import leo.core.leoPlugins as leoPlugins
    .. import leo.core.leoGlobals as g

.. Otherwise, the output looks like this::

    .. import leo.core.leoPlugins as leoPlugins
    .. import leo.core.leoGlobals as g

See the Scripting chapter in LeoDocs.leo for many examples of how to use
code-blocks.</t>
<t tx="ekr.20050818163826.11">HTML files generated by the rst3 command assume that three .css (cascading style
sheet) files exist in the same directory. For the HTML output to look good the
following .css files should exist:

- default.css is the default style sheet that docutils expects to exist.

- leo_rst.css contains some style improvements based on Gunnar Schwant's DocFactory.

- silver_city.css is the style sheet that controls the syntax highlighting generated by SilverCity.

The latter two style sheets are imported at the end of the default.css.

**Important:** You can use cascading style sheets to do things that otherwise
wouldn't be possible with "plain" rST. For instance, the background color of
this page was specified in a body style.</t>
<t tx="ekr.20050818163826.12">Leo reserves the '#' character for your own use so that you can
specify an rST headline explicitly. For example,::

    #####
    Title
    #####

You would typically put such a title in the rst root node. Otherwise, you should
let the rst3 command automatically generate rST sections from headlines.

To create a table of contents (TOC) put::

    .. contents:: Table of Contents

on its own line wherever you want the TOC to appear.  This line can appear in body text in rst mode,
or in an @ @rst-markup doc part in code mode.</t>
<t tx="ekr.20050818163826.13">The file ListManagerDocs.html_ is an impressive example of the kind of output
that can be generated relatively easily using the rst3 command.

The source for ListManagerDocs.html is wxListManager.leo_. **Important**:
wxListManager.leo was written for the old rst2 plugin; it could be greatly
simplified if adapted for the rst3 command.

The files in LeoDocs.leo under the node 'Leo's HTML Users Guide' contain
examples of using the rst3 command.

This documentation was created using the rst3 command. The source code for this
documentation is in LeoDocs.leo. The source code for all the rst3 command is in
leoRst.py in leoPy.leo.</t>
<t tx="ekr.20050818163826.14">The code for the rst3 command is more complex than usual. Fortunately, the
overall organization is straightforward.

defaultOptionsDict
    This dictionary represents each rst3 option.
    To add another option, just add another entry to this dictionary.
    Keys are the option name, including the `rst3_` prefix.
    Values are the default value of the option.
    The hard values in the dictionary may be changed as the result of @settings entries.

processTree
    processTree is the top-level code that handles one rst root node.
    It calls preprocessTree to create the **tnodeOptionDict** ivar.
    processTree then calls either writeNormalTree or writeSpecialTree
    depending on whether text will be sent to docutils for further processing.
    These two methods handle mundane details of opening an closing files.
    Both writeNormalTree and writeSpecialTree call **writeTree** to do the actual work.

tnodeOptionDict
    The entries in this dictionary represents the options that are set in one particular node.
    The keys of tnodeOptionDict are tnodes, the values are anonymous dictionaries.
    These anonymous inner dictionaries contain the options that are explicitly set at each tnode
    (and thus each position).
    Preprocessing the tree this way ensures that each node (headline and body text) is parsed exactly once.

writeTree
    writeTree first calls **scanAllOptions**, which has the effect of
    initializing all options. writeTree then calls **writeNode** for each node
    that will be processed by the rst3 command. Options may cause the rst3 command to
    skip a node or an entire subtree.

writeNode
    writeNode first calls **scanAllOptions** to compute the options that are in
    effect for that *single* node. Once options have computed, processing the
    node is straightforward. writeNode calls writeBody and writeHeadline
    to do the real work. These methods generate or skip text based on various
    options.

scanAllOptions
    scanAllOptions recreates the optionsDict ivar to represent *all* the options
    in effect for *for the particular node being processed by writeNode*. Client
    code gets these options by calling the getOption method.

    scanAllOptions first inits all options from settings,
    then updates those options using the anonymous
    dictionaries contained in the tnodeOptionsDict.
    scanAllOptions works like g.scanAllDirectives, but the code is much simpler.</t>
<t tx="ekr.20050818163826.16">Josef Dalcolmo wrote the initial rst plugin.
Timo Honkasalo, Bernhard Mulder, Paul Paterson, Kent Tenney and
Steve Zatz made contributions to the rst and rst2 plugins.</t>
<t tx="ekr.20050818163826.2">reStructuredText_ (rST) is a popular markup language for writing documents. rST
is simple, yet powerful. All of Leo's documentation is written in rST, and then
processed via the docutils_ and Sphinx_ processors to produce Leo's web pages.

Leo makes writing rST documents easier. A *lot* easier. There are several
reasons for this:

1. Leo outlines help organize rST source code in all the usual ways. You always
clearly see the structure of even book-length documents. You can rearrange and
reorganize chapters, sections and paragraphs effortlessly. You can use clones to
create multiple views of your writing for yourself and your readers. These
capabilities, all by themselves, would make Leo an excellent choice for editing
rST documents.

2. Leo fixes the clumsiest part of rST markup, namely the markup for headings.
Without Leo, you must underline heading lines manually. The underlining
character indicates the level of a heading. Changing the level of a heading is
clumsy and error prone: you must change the underlining character properly.
Changing the level of several headings is a headache.

Leo gets rid of all this bother. Within an outline that gets written to an
external rST file, Leo's headlines become section headings. When writing
external rST files, **Leo generates underlining for headers automatically**
based on the outline level of the outline nodes. When you rearrange your outline
Leo will recompute the rST markup needed to recreate the outline structure in
the external rST file. In most cases, you won't even see the rST markup for
headings!

3. @auto-rst nodes allow you to edit exising rST files in Leo. The outline
structure of such nodes mirrors the level of the rST section headings. Note:
there may be minor variations the first time you import an existing rST file,
but these differences will not affect the meaning of the rST file. After the
first import, the only changes when writing the imported rST file will be
changes *you* make.

The three features just discussed (Leo's organizational capabilities, automatic
generation of markup for rST headings, and @auto-rst trees) are useful for
anyone using reStructuredText. In addition Leo provides additional capabilities
for power users:

4. @rst trees can contain settings that affect how Leo writes individual nodes.

@rst trees allows the ultimate in flexible formating.
We'll discuss these options in detail later, but here are a few examples.

- Headlines that starts with @rst-no-head do not create an rST heading.

- Body text that starts with::

    @rst-option code_mode = True

causes the body text of the node to be displayed as an rST code block.

Leo's rst3 command generates .htm, .html or .tex output files from @rst tree,
provided that you have installed Python's docutils_ module.  The rst3 command
will use the SilverCity_ syntax coloring package if it installed.

The rst3 command sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.
See `Required cascading style sheets`_ for more details.

5. The rST options just discussed will suffice to create just about any kind of
rST output. But for those desiring the ultimate in flexibility, it is relatively
straightforward to create Leo outlines or external files using scripts. For
example, you might want to write a script to format source code to rST markup. A
script can give you complete control over such formatting. This chapter
concludes by telling how to write such scripts.</t>
<t tx="ekr.20050818163826.3">1. The rst3 command allows much more flexible control over its operations using
**rst options**. You can set options in @settings trees, in headlines and in
body text. Nodes inherit most rst3 options from ancestor nodes much like nodes
inherit Leo directives. See `Options`_.

The most important option is the code_mode option. This option specifies whether
to process the body text of a node as rst markup (rst mode) or source code that
is to be converted to rST markup (code mode). Any node can be processed in any mode.

2. Headlines can set any option. This turns out to be very convenient. See
`Headline commands`_ for details. Nodes whose headlines start with @rst-options
are treated specially. The body text of such **rst options nodes** should
contain nothing but lines of the form::

    &lt;option&gt;=&lt;value&gt;

3. You can set any rst options in the *body text* of any node using doc parts
of the form::

    @ @rst-options
    list of rst options, one per line
    @c

Such **option doc parts** allows you to specify rst options even with source code files.

4. You can embed rST markup in the body text of any node using doc parts of the
form::

    @ @rst-markup
    any rST markup
    @c

Such **markup doc parts** allow you to fine-tune the formatting of your source files.
See `Using doc parts`_ for full details.</t>
<t tx="ekr.20050818163826.4">You can set any option in any node, so you have complete control over how the
rst3 command processes each node. The following is a list of options that
control how the rst3 command formats each particular node.

code_mode (default: False)
    True: process nodes in code mode.  False: process nodes in rst mode.
    In code mode, the rst3 command automatically creates rST markup to display the body text as an
    rst code-block. In rst mode the rst3 simply copies the body text of the node to the output. That
    is, the rst3 command assumes that body text is already valid rST markup.

doc_only_mode (default: False)
    True: process nodes in doc_only mode.
    False: process nodes in rst mode or code_mode, depending on options.
    In doc_only mode, the rst3 command outputs only regular doc parts and @ @rst-markup doc parts.
    Headlines create section in doc_only mode only if
    a\) the node contains a doc part or b\) the show_organizer_nodes option is in effect.
    As always can use @ @rst-options for per-node control of the process,
    especially node-by-node control of the show_organizer_nodes option.

default_path (default: '')
    The path to be prepended to filenames given in root nodes.

default_encoding (default: utf-8)
    The default encoding to be used for non-ascii (unicode characters).

encoding (default: the default_encoding setting)
    The encoding to be used for non-ascii (unicode) characters.
    **Important**: this option has effect only in @rst-options doc parts
    in root @rst nodes.

generate_rst (default: True)
    A master switch.
    True: generate rST markup for rST sections and rST code-blocks.
    False: don't generate rST markup and ignore @ @rst-markup doc parts.

generate_rst_header_comment (default: True)

    This option has effect only if the generate_rst and write_intermediate_file
    options are both True. When this option is in effect, Leo writes a comment
    line of the form::

        .. rst3: filename: &lt;filename&gt;

    at the start of intermediate files.

number_code_lines (default: True)
    Controls whether to number code lines in code mode.
    This option has no effect in rst mode.

publish-argv-for-missing-stylesheets (Default: '')
    The arguments to be passed to docutils.core.Publisher().publish()
    when no stylesheet is in effect.
    This is a string that represents a comma-separated list of strings:
    For example, the option::

        publish-argv-for-missing-stylesheets=--language=de,--documentclass=report,--use-latex-toc

    results in the call::

        publish(['--language=de','--documentclass=report','--use-latex-toc'])

show_doc_parts_as_paragraphs (default: False)
    True: Move doc parts outside of the code-block directive in code mode.
    This option has no effect in rst mode.
    **Cool**: Any rST markup in doc parts included as the result of this option will be rendered properly.

show_doc_parts_in_rst_mode (default: True)
    This option is most useful for rst documents which are not computer code.
    It allows you to use doc parts to make comments on the draft document
    which are either excluded from the output or formatted in a way that highlights
    their nature as comments rather than contet.  For example, you're writing a book, and
    you want to use a doc part at the top of a section to remind yourself "need
    to explain how Ted got to Sally's".    Note: you may need to add
    CSS to have them formatted differently.  The option can be `True`, `False`,
    or one or more class names.

    True: doc parts have no special significance in rst mode.
    That is, the entire doc part from the opening '@' to the closing '@c
    and everything in between are treated as normal rST markup.

    False: doc parts are removed from the output in rst mode

    class name(s):

      The contents of the doc part is processed as it if was in an rst `container`
      directive.  For example::

         @ @rst-options
         show_doc_parts_in_rst_mode = notes literal
         @c

      would wrap the doc part contents in the output in a div with classes
      "container notes literal".  Furthermore, if one of the class names is
      `literal`, then the doc part content will be output as a literal block
      wrapped in a container as described above.  This allows you to use text
      which is not valid rst as rough notes for annotating a draft document.

show_headlines (default: True)
    True: automatically generate rST sections from headlines.
    Applies to both code mode and rst mode.
    The level of the node in the outline determines the level of the section
    underling in the rST markup. Higher-level headlines in the outline
    correspond to higher-level section headings; lower-level headlines in the
    outline correspond to lower-level section headings.

show_leo_directives (default: True)
    True: include Leo directives in code mode.
    This option has no effect in rst mode.

show_markup_doc_parts (default: False)
    True: include markup doc parts in code mode.
    This option has no effect in rst mode.

show_options_doc_parts (default: False)
    True: include options doc parts in code mode.
    This option has no effect in rst mode.

show_options_nodes (default: False)
    True: show @rst-options nodes.

show_organizer_nodes (default: True)
    True: generate rST sections for nodes that do not contain body text.
    This option has no effect unless the rST section would otherwise be written.

show_sections (default: True)
    True: generate rST sections corresponding to headlines.
    False: don't generate sections.  Instead, generate lines of the form::

        **headline**

strip_at_file_prefixes (default: True)
    True: remove @auto, @file, @nosent and @thin from the start of headlines.

stylesheet_name (default: 'default.css')
    The name of the stylesheet passed to docutils.

stylesheet_path (default: '')
    The directory containing the stylesheet passed to docutils.

    :Note:
        If the stylesheet_embed option is True, specify a path relative
        to the location of the Leo file.  If the stylesheet_embed option is
        False, specify a path relative to the location of the HTML file.

stylesheet_embed (default: True)
    | True: The content of the stylesheet file will be embedded in the HTML file.
    | False: The HTML file will link to an external stylesheet file.

underline_characters (default: \'\'\'#=+*^~"'\`-:&gt;&lt;\_\'\'\')
    The underlining characters to be used to specify rST sections.
    The first character is reserved so you can specify the top-level section explicitly.

verbose (default: True)
    True: write informational messages.

write_intermediate_file (default: False)
    True: writes intermediate files before sending them to docutils.
    This option only applies to .htm, .html and .tex files.
    The name of the intermediate file has the name of the output file with .txt appended.
    This option has effect only if the generate_rst option is True.</t>
<t tx="ekr.20050818163826.5">The following options are for the use of Bernhard Mulder's http plugin. The http
plugin creates an http server running on a local port, typically 8080. When the
http plugin is running you will see a purple message in the log window that
looks something like this::

    http serving enabled on port 8080, version 0.91

To use the http plugin, start a web browser and enter this url::

    http://localhost:8080/

You will see a a top level page containing one link for every open .leo file.  Clicking on link will cause the http server to pass a new page to the browser.  You can use the browser's refresh button to update the top-level view in the browser after you have opened or closed files.

**Important**: See the docstring for the http plugin for information on
configuring the plugin. Some of the following rst3 settings must match values of
settings for the http plugin. Here are the rst3 options that support the http
plugin:

http_server_support (default: False)
    A master switch: none of the following options have any effect unless this option is True.
    If True, the rst3 command does the following:

    - Writes **node markers** in the rst output for use by the http plugin. Node markers are rst named hyperlink targets.  By default they look like::

            .. _http-node-marker-N

      where N is a unique node number.

    - Adds additional information to all nodes of the tree being formatted using Leo's
      unknownAttributes mechanism.

http_attributename (default: 'rst_http_attribute')
    The name of the attribute name written to the unknownAttributes attribute of
    each each outline node in the rst root tree.
    The default is 'rst_http_attribute';
    it should match the following setting of the *http* plugin::

        @string rst_http_attributename = 'rst_http_attribute'

    This option has no effect unless the http_server_support option is True.

clear_http_attributes (default: False)
    If True the rst3 command initially clears the fields specified by `http_attributename`.  
    This option has no effect unless the http_server_support option is True.

node_begin_marker (default: 'http-node-marker-')
    The string used for node markers.
    This option has no effect unless the http_server_support option is True.</t>
<t tx="ekr.20050818163826.6">The following options specify the 'spelling' of headline commands. The
option_prefix and option_prefixes command also define the spelling of special
doc parts.

You can change these to make them shorter or to avoid conflicts with headlines
in your Leo files. The list below merely gives the default value for each
setting.

`code_prefix`: '\@rst-code'

`ignore_headline_prefix`: '\@rst-no-head'

`ignore_headlines_prefix`: '\@rst-no-headlines'

`ignore_prefix_tree`: '\@rst-ignore'

`ignore_node_prefix`: '\@rst-ignore-node'

`ignore_tree_prefix`: '\@rst-ignore-tree'

`option_prefix`: '\@rst-option'

`options_prefix`: '\@rst-options'

`preformat_prefix`: '\@rst-preformat'

`rst_prefix`: '\@rst'

`show_headline_prefix`: '\@rst-head'</t>
<t tx="ekr.20050818163826.7">It is often convenient to set options in headlines.  This is done with the following **headline commands**:

@rst TEXT
    Enter rst mode.  Create a section called TEXT provided the show_headlines option is set.

@rst-code TEXT
    Enter code mode.  Create a section called TEXT provided the show_headlines option is set.

@rst-ignore-node TEXT
    Suppress all output from a single node. TEXT is ignored.
    Has *no* effect on descendant nodes and does **not** change any rst3 option. 

@rst-ignore-tree TEXT and @rst-ignore TEXT
    Suppress all output from the node and its descendants.  TEXT is ignored.
    Does **not** change any rst3 formatting option.

@rst-no-head TEXT
    Suppress the generation of an rST section for this node only.  Does not affect descendant nodes.
    Has *no* effect on descendant nodes and does **not** change any rst3 option. 

@rst-no-headlines TEXT
    Set the show_headlines option to False.  As a result, TEXT is ignored.

@rst-option &lt;option&gt; = &lt;value&gt;
    Set a single option to the given value.  The default value is True.

@rst-options TEXT
    Set zero or more options from the body text of the node.  TEXT is ignored.
    The entire body text is treated as if it were in an @ @rst-options doc part.

@rst-preformat TEXT
    Format the entire body text of the node as if the entire text preformatted.
    TEXT is ignored. In effect, a line containing '::' is added to the start of
    the text, and all following lines of the text are indented. This option has
    no effect on descendant nodes.

**Notes**:

- Several of these commands affect only the node in which they appear.  Such commands set internal settings variables only: they have no effect on the visible rst3 options.

- If a headline generates an rST section, the section name does not include the headline command.  Furthermore, no rST section is generated if the TEXT is empty.</t>
<t tx="ekr.20050818163826.8">Recall that in Leo a doc part starts with the '@' directive and continues until the end of body text or until the '@c' directive is seen.  For example::

    @ This is a comment in a doc part.
    Doc parts can span multiple lines.
    The next line ends the doc part
    @c

Leo converts doc parts into comments using whatever comment delimiters are in effect.

**Option doc parts** are doc parts that start with @ @rst-options. All other
lines of such doc parts should be of the form name=value. (rST comments lines
starting with '..' are allowed). For example::

    @ @rst-options
    .. This comment line is ignored.
    show_headlines=False
    show_leo_directives=False
    verbose=True
    @c

The rst3 command sets options from option doc parts, even in code mode.

**Markup doc parts** are doc parts that start with @ @rst-markup.  For example::

    @ @rst-markup
    .. contents::

The rst3 command replaces markup doc parts by the markup they contain, even in
code mode.

Option and markup doc parts are especially useful in code mode. They allow you
to specify options or insert rST markup directly from with external files. This
makes your source files self contained: there is no need to add other nodes to
make the rst3 command happy.

A cool feature: In code mode, rST markup in *ordinary* doc parts will be
rendered properly when the show_doc_parts_as_paragraphs option is in effect.
*Important*: Regardless of the show_doc_parts_as_paragraphs option, doc parts
have no special significance in rst mode. That is, the entire `doc part` from
the opening '@' to the closing '@c and everything in between are treated as normal
rST markup.  *Update:* you can now use the `show_doc_parts_in_rst_mode` option
to change this behavior and control the processing of doc parts in rst mode.</t>
<t tx="ekr.20050818163826.9">You can set the defaults for any rst3 option in several ways:

\1.  By setting options in the root node using @ @rst-options doc parts.
For example, the root of the file that generated this documentation contains::

    @ @rst-options
    code_mode=False
    doc_mode_only=False
    generate_rst=True
    show_organizer_nodes=True
    show_headlines=True
    show_leo_directives=True
    verbose=True
    @c

\2. By setting options in @settings trees.  To do this, you must prefix the option name shown in this documentation with the prefix 'rst3\_'.  For example::

    @settings
        @bool rst3_write_intermediate_file = True
</t>
<t tx="ekr.20050828061213">#####################################
Chapter 4: Writing Programs in Leo
#####################################
</t>
<t tx="ekr.20050828061501.1">This chapter is a guide to computer programming with Leo, specifically, to interacting with external files intended for use with other programs, such as C or python source code, the CVS data for a spreadsheet, or a markup language such as nroff, TeX or XML.  For reStructuredText, there are special facilities detailed in the chapter `Leo and reStructuredText`_.  This chapter does *not* teach you how to use Leo:
for that you should read `Leo's tutorial`_.
You should be thoroughly familiar with the terminology introduced in that tutorial.

.. .. contents::</t>
<t tx="ekr.20050828061501.43">See `CWEB`_ for a discussion of the CWEB language. CWEB mode refers to how Leo
tangles an outline when @language cweb is in effect or the cweb setting is in
effect. Leo treats *all* cweb code in cweb mode as unevaluated text. That is,
Leo treats cweb control codes, including ``@&lt;...@&gt;``, ``@&lt;..@&gt;=``, ``@c``, ``@``, ``@*`` and ``@**`` as
"raw" text within cweb mode. Leo does *not* expand *cweb* section references
when writing external files in cweb mode. However, Leo *does* expand *noweb*
section references, so you may use noweb sections to organize cweb files! You
can create *noweb* code and doc sections using the @code and @doc directives in
place of @c and @ directives.

By default, cweb colors ``@``, ``@*`` and ``@**`` sections using the same syntax coloring as
for LaTeX. In addition, cweb colors C ``//`` and ``/*..*/`` comments using LaTeX
coloring by default. You may change these defaults using the
color_cweb_doc_parts_with_latex and color_cweb_comments_with_latex settings.
</t>
<t tx="ekr.20050828160132">.. External links...
.. _`CWEB`:     http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`noweb`:    http://www.eecs.harvard.edu/~nr/noweb/

.. Links to other chapters
.. _front:                  front.html
.. _`Leo's tutorial`:       intro.html
.. _`Leo and reStructuredText`: rstplugin3.html
.. _`History of Leo`:       history.html

.. Relative links...
.. _`@auto reference`:      `auto reference`_
.. _`@delims`:              `delims reference`_
.. _`@file reference`:      `file reference`_
.. _`@root Directive Family`:      `root reference`_


.. For reasons unknown, images must appear in the _images folder on the web site.
.. |leoAtFileMainNode| image:: screen-shots/leo-qt-at-file-main-node.JPG
.. |leoAtFileFirstChild| image:: screen-shots/leo-qt-at-file-first-child.JPG
.. |leoAtFileNamedChild| image:: screen-shots/leo-qt-at-file-named-child.JPG
</t>
<t tx="ekr.20050830074716">###################################
What People Are Saying About Leo
###################################

.. .. contents::
</t>
<t tx="ekr.20050830074815.1">"I am using Leo since a few weeks and I brim over with enthusiasm for it. I
think it is the most amazing software since the invention of the spreadsheet."

"We who use Leo know that it is a breakthrough tool and a whole new way of
writing code." -- Joe Orr

"I am a huge fan of Leo. I think it's quite possibly the most revolutionary
programming tool I have ever used and it (along with the Python language) has
utterly changed my view of programming (indeed of writing) forever." -- Shakeeb
Alireza

"Thank you very much for Leo. I think my way of working with data will change
forever... I am certain [Leo] will be a revolution. The revolution is as
important as the change from sequential linear organization of a book into a
web-like hyperlinked pages. The main concept that impress me is that the source
listing isn't the main focus any more. You focus on the non-linear,
hierarchical, collapsible outline of the source code." -- Korakot Chaovavanich

"Leo is a quantum leap for me in terms of how many projects I can manage and how
much information I can find and organize and store in a useful way." -- Dan
Winkler

"Wow, wow, and wow...I finally understand how to use clones and I realized that
this is exactly how I want to organize my information. Multiple views on my
data, fully interlinkable just like my thoughts." -- Anon

"Edward... you've come up with perhaps the most powerful new concept in code
manipulation since VI and Emacs. -- David McNab

"Leo is...a revolutionary step in the right direction for programming." -- Brian
Takita</t>
<t tx="ekr.20050830074815.10">"I am extremely impressed at how stable and useful Leo appears to be." -- Marcus
A. Martin

"Leo is amazingly stable. Docs are often weak with Open Source Software. Not so
Leo: Leo is unusually well documented." -- F. Geiger

"Leo is unimaginably useful and I always find new things it already knows(!) how
to do. Indeed I am amazed by the never-ending resources and patience Edward is
putting into it and its users community. Excellent." -- Gil Shwartz

I feel strongly that Ed Ream, our ever-patient, ever-productive Leo architect
deserves a nomination [for the ActiveState OpenSource Award.] Among other
reasons, for:

- Delivering the first usable visual literate programming tool.
- Adding a vast abundance of new features.
- Making possible a previously unimaginable amount of leverage in code editing.
- Eliminating vast amounts of menial programming labour.
- Tirelessly and patiently supporting users, and catering to a wide range of
  feature requests. -- David McNab

</t>
<t tx="ekr.20050830074815.11"></t>
<t tx="ekr.20050830074815.12">September 3, 2002

Hello, my full name is David Speed Ream. I am known as Speed to friends and
enemies alike, but I gladly answer to David or most any other handle. I am an
unabashed and biased fan of Leo, the fact that it was written by my brother
Edward only slightly coloring my already colored glasses. I have been testing
and using Leo in software production for over 4 years. My company currently has
over 50,000 lines of code in over 100 source files that are written using Leo.

My comments are from two points of view, the first being software project
manager for a complicated, multi-module software product, and the second being
as a production line coder. For me, Leos greatest and only real drawback is the
learning curve. This learning curve can be shallow is if all that is required is
that someone code using Leo. However, in our company we allocate 40 to 80 hours
*on top* of the normal coding load for someone to come up to speed on Leo. The
ROI (return on investment) is calculated by me to be on the order of 3 months.
So if I hire a consultant for less than 3 months, I dont teach him Leo, even
though all source code in our company must reside in Leo files for the reasons I
wont go into now.

I consider that my coders are 15 to 30 percent more efficient in their daily
operations than my competitions people. This indefensible claim of mine is
based on the changes in my productivity as Leo grew from a test document
production tool to the primary production method for all our assembly, c and cpp
source code.

Personally, I hate to deal with documentation when I write code, except:

1) When I am first sitting down to solve a new problem.
   Then the documentation becomes quite long-winded and pontificatory,
   as if I were the only one on earth smart enough to solve the problem - or
2) When I come back to code I or someone else has written and find the documentation insufficient to
   understand the code without study (seems to be most of the time).

So I do not require my engineers or myself to do a great job of documentation,
nor do I use Leo for that purpose. Rather, it is Leos outlining and organizing
ability, and Leos ability to create source files from within the outline that
give me what I think is a tremendous competitive advantage. Each of my companys
products run on all versions of windows from Win 3.1 to XP. In our flagship
software piece, there are ten main modules, and each module is maintained by one
single Leo file. In the CODEC module, one Leo file named compress.leo organizes
and creates seven .asm files, forty-four .c files, twenty .h files, two .def
files, four .mak files, etc. etc. etc. This one file can be checked out from
source code control and given to an engineer for the addition of a new feature.

In it are contained all the known issues for the CODEC, each issue arranged in
its own clone section. One clone section groups together every routine, variable
or type definition that must change between different versions of Windows. These
sections could be from six different c source files, two assembly files, and
eight .h files. Another clone section groups together those sections relating to
memory problems, which change according to the memory configuration and TSR
configuration (or lack thereof) on the target machine. Another clone section
groups sections that fail (or dont fail) if the routine in question was
accidentally run during the dreaded interrupt time. Another clone section is a
section containing clones, each of which is named after the major bug that was
fixed when the engineer who fixed the bug grouped a bunch of routines,
definitions, etc. together to fix the bug.

None of the above clone sections was designed into the document. Just the
opposite happens. When the codec was first written, there was just a single Leo
file with a bunch of sections for each c routine or assembly module. As the
product grew and was tested on various platforms, each failure of the module was
organized into clones each time a failure was fixed. This is what I call SELF
DOCUMENTING CODE. This has nothing to do with me sitting and documenting
anything. Its just that the STRUCTURE of a bug fix (or product enhancement)
lives on long after the coding is done, as long as no one is foolish enough to
delete the cloned sections that DOCUMENT what happened.

In actual practice, this organizational history is so powerful that I cant
begin to describe it. A REVERSE LEARNING CURVE happens when an engineer gets a
Leo file that already has the interrupt time sensitive routines grouped
together by the last unfortunate soul who had to work on them. There may not be
any more written documentation, but the knowledge contained in the structure can
be breathtaking. It is certainly time saving. I find this particularly true in
my own case. Often Ill look at some code that seems totally unfamiliar and
think what idiot wrote this crap. Then Ill look at the version control
comments and realize that I wrote the crap. Then for sure I know the
documentation is non-existent, but the clones I used to develop it are still
there, and they always serve to refresh my memory in an indescribable way.

Enough of this commentary, I just looked at the clock. Best wishes to anyone
willing to try Leo for a week. I hope you will be glad you did.</t>
<t tx="ekr.20050830074815.13">The Word outlines are very useful. But Leo makes Word look like a clunky toy.

#1 Reason would probably be clone nodes. One node can point to another. Another
way of putting this is is that a leaf can be on more than one tree. For
example, suppose you have a list of recipes. You simultaneously put a single
recipe under multiple categories or even multiple hierarchies. You could put "3
bean enchilada" simultaneously under Recipes-Mexican and Food-Gas. Another
example would be, if you are a biologist trying to decide under which genus to
put a new species, you could put the species under two simultaneously. In
effect, you can build a 3-D tree. For a further illustration see
http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm

#2 Reason would probably be that Leo outlines can be embedded in external text
files. So, a Leo outline is more than an outline, it is a meta-structure that
can be added to another text without changing that text, but rather providing
an external road map to the text. Microsoft Word has a text (xml) version with a
commenting convention, so Leo can even be used to add outlines into Word docs,
although it isn't set up to do that now. For example, see
http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm In this case, the upper
window of Leo is the meta-structure, and the bottom window is the file to which
the meta-structure is being applied, viewed one node at a time.

I may not have made #2 very clear, but it is actually a very useful feature. It
takes some getting used to before one sees all of the possibilities tho. One
way to think of it is that Leo allows you to throw external documents into your
outline, and yet the external document remains independent and can still be
edited separately.

Some other cool things about Leo which Word doesn't feature:
1. Pure xml output that is easy to transform into other formats (next
version of Word will have true XML format, but not as easy to work with).
One consequence of this is that Leo files can be transformed pretty easily
to web pages with their outlining capability intact.
2. Easy to add features since is programmed in Tk and open source. Maybe
your average user can't start hacking on it, but a surprising amount can be
tacked on by flipping through the Tk manual.
3. Free, opensource, multi-platform
4. Leo is scriptable with Python. It should be possible to build a Tickler
into Leo using Python scripting, for example.</t>
<t tx="ekr.20050830074815.14">First of all, kudos to you for the excellent progress you've been making with
Leo. I upgraded today after about three months of using and older version and I
was thrilled to see all the great improvements that have happened so fast. I
especially love the ability to go to next clone. I think you're really showing
what open source can do and your current trajectory puts you on track to kick
Emacs into the dustbin of computing history.

So today I copied all my data (personal information manager and project
management stuff) out of my old outliner (ThoughtManager, which syncs with and
runs on the Palm) and put it into Leo. It took me hours to do it and then to
rearrange it the way I really wanted it. But having the ability to make clones
and have different ways to view my data is, as you know, fabulous. In my case,
for personal information and project management things, I used the flexibility
of clones to allow me to see my data in several different views: 1) by project,
the logical hierarchical breakdown by topic, 2) by person, so whenever I'm
talking to someone I can easily see all the pending items related to them which
may be spread over multiple projects, 3) by priority, so I can see what needs to
get done sooner and what can wait for later and, 4) a special case of priority
called "Today" for the things I'm going to focus on in the coming hours.

Now here's why I don't miss the ability of my old outliner to synch the entire
outline with the Palm. It turns out the main thing I really want in the Palm is
the top category "Today" so all I have to do is have Leo flatten that one
heading into a text file (and it kindly remembers the name and directory of the
file I used last time) and then I'm done because I've told the Palm Hotsync
manager that that file should be sent to Palm memo pad every time I synch. The
Palm Hotsync manager does a nice job of sending a text file to the Palm memo pad
and even breaks the file up into multiple memo records if it's too big to fit in
just one. So that gives me enough to be able to browse (or full text search) the
small amount of data that I really want right inside my Palm (which is also my
cell phone). Quick and dirty but it works.

For times when I want my whole outline with me, Leo wins again because thanks to
its cross platform nature I can take my whole outline with me on my Mac iBook,
even though I usually edit it on a Windows PC (which is the only kind of machine
my old outliner would run on). Quite frankly, although my old outliner was able
to shoehorn the whole thing into my palm/cellphone, it was a pain to access it
on the small screen and slow processor. Now when I anticipate I'll need the
whole thing, for example when I'm going to a meeting, I can put it on my Mac
iBook (under X and Fink for now until Python can do it native under Aqua) and
have real, full access to it all.

I think now in addition to being great for programming Leo is also a great PIM.
Being able to flatten a strategically chosen portion of the outline into a known
file name that the Palm synch manager has been told to send to the Palm on every
synch does the trick for me. I wonder if you would consider something like an
@flatten directive so I can have that done automatically for me every time I
save my outline? For now it's up to me to flatten the node I want manually,
although once I've done that the transfer to the Palm is automatic.

You're my hero! Thank you so much.</t>
<t tx="ekr.20050830074815.15">Another day, another breakthrough using Leo -- now I realize Leo is the 
best URL bookmark manager there is.  No more bookmarks menus or 
favorites lists inside the browser for me.  With the @url directive I 
can just double click on the URL to open it in my browser.  Leo lets me 
arrange the URLs in a hierarchy (or multiple hierarchies), attach notes 
to them, save clippings of things I read on the sites.  It's sooo much 
better than anything the browsers have built in and it lets me easily 
use different browsers on different platforms and different machines 
(try that with the browsers' built-in bookmark managers).  

When using Leo as a project manager and personal information manager as 
I do I can heavily annotate every task and project with helpful and 
relevant URLs.  And since URLs can be of the file:// form, they're not 
just for web pages or HTML documents;  I can link to any file on my disk 
of any type to be opened by any program.

Leo is a quantum leap for me in terms of how many projects I can manage 
and how much information I can find and organize and store in a useful 
way.  I'm a data-mining army of one now and the web is my playground. 
Every time I find a web page that has interesting links to others, 
those links get stored in my Leo outline too, right where I can find 
them and make practical use of them.  I can easily accept dozens of 
valuable links every day and integrate them into what I'm doing in a way 
that I'm confidant they won't get lost or forgotten.  Before I always 
used to get bogged down by the difficulty of managing bookmarks inside 
the browser.  But now I'm no longer the victim of information overload 
buried in the knowledge landslide of the Internet;  instead I'm the 
professional strip miner with the world's biggest bulldozer.  I eagerly 
plunge into mountains of data and emerge with all the valuable 
information nuggets neatly stored and organized.  And my storehouse of 
knowledge is a flexible thing where I can reorganize and prioritize and 
massage the data to my heart's content as I learn more about it and 
decide to use it in different ways for different purposes.  It's the 
difference between the pick axe and the steam shovel for me.
</t>
<t tx="ekr.20050830074815.16">This year my accountant is getting a beautiful printout generated by LaTeX and
Leo. I have a complicated tax situation this year, but I got it all laid out and
organized in Leo. Then I had each of the nodes that had something my accountant
needs to see write the data out to a file in the form a LaTeX table.

Sometimes a row of a table would have a result that was calculated by adding up
a list of numbers. For that I used the modern day equivalent of an adding
machine paper tape -- I stored a lisp s-expression in a Leo comment. I like
s-expressions for this because once I put the opening "(+" on one line and the
closing ")" on another line, I can fill in additional numbers just by typing
them and can even annotate them with comments. So in the middle of generating a
LaTeX file I might have something like this::

    @
    (+
    1165.26 1823.70 ; May 2002
    123.38 ; June 2002
    13.50 ; July 2002
    13.21 ; October 2002
    55.25 ; November 2002
    )
    @c

That's an annotated record of how I arrived at the number the accountant will
actually see. I can just paste it into any lisp or scheme interpreter and get
the total. Adding additional numbers is easy.

For next year, I think I might take this a step further. What I did this year is
good for adding up numbers to get a total for one row of a LaTeX table. But it
turns out I'd also like some more processing done on those tables (which I had
to do by hand this time) -- I'd like the rows sorted in reverse order by
magnitude (so that the big numbers jump out at you from the start of the tables)
and I'd like a total of all the rows in the table. So I think next year, instead
of having an s-expression that computes the total of one row for me, I think
I'll use s-expressions that generate whole tables, formatted for LaTex, from the
underlying data. So I'm thinking next year my s-expressions might look more like
this::

    @
    (table "Widget Related Expenses"
        ("widget insurance" (+
                        1165.26 1823.70 ; May 2002
                        123.38 ; June 2002
                        13.50 ; July 2002
                        13.21 ; October 2002
                        55.25 ; November 2002
                      ))
         ("widget shipping" (+
                        472.15 651.94 ; May 2002
                        54 ; June 2002
                       ))
         ("widget cleaning" (+
                        165.26 183.70 ; May 2002
                        123.38 ; June 2002
                        13.50 ; July 2002
                        13.21 ; October 2002
                        55.25 ; November 2002
                       ))
    )
    @c

The job of that "table" function would be to return the LaTeX code needed to
display a table with the category names and values, sorted descending by
magnitude, with the total displayed. It's sort of a poor man's way of doing a
spreadsheet inside Leo and then making it look great using LaTeX. The idea would
be as I wanted to add more data, I'd add it to the s-expression and then
reevaluate the whole thing by pasting it into a lisp interpreter and then
copying the result back into the same Leo node for LaTeX to process.

-- Dan</t>
<t tx="ekr.20050830074815.2">"Thanks for a wonderful program  everybody should be using it! It blows the
socks off that Java Mind mapping software that won project of the month a while
back on sourceforge!" -- Derick van Niekerk.

"A few years back I would have said Zope was #1 Python showcase, but I agree
100% that Leo is tops now." -- Jason Cunliffe

"Leo is the most interesting Python project I know of...I see lots of stuff
posted on the Daily Python page, but I usually yawn and come over to this forum
to see what's cooking." -- Anon

"Leo is the best Tkinter application ever written. It convinces me that Tkinter
can really *do something*, and do [it] well." - Anon

"What an original synthesis of different ideas, why can't other Open Source
projects change the way I think?" -- Anon</t>
<t tx="ekr.20050830074815.3">"When first I opened Leo, it was out of curiosity. But having used it...I'll
never go back. They'll have to pry Leo out of my cold, dead fingers! Seriously,
it should be renamed 'Crack Cocaine' because it's that addictive. I'm ready to
start a 12-Step group." -- Travers A. Hough

"I feel addicted to programming again...in fact [Leo] has resurrected a dead
project of mine :) The Outline has proven most liberating in terms of testing
ideas out." -- Anon

"I have been absolutely seduced by Leo over the past few days. I tell you, I can
not put it down. I feel like a kid with a shiny new bike...I'm already bursting
with new ways I'd like to use the tool in the future." -- Lyn Adams Headley

Thanks for the great work--I love Leo!!! -- Josef Dalcolmo

Leo has simplified updating and creating new scripts and .bats keeping similar
information in the same place. there is almost an addictive withdrawal effect
when I can complete an operation in so much less time with Leo &amp; python than I
had become used to. -- Anon</t>
<t tx="ekr.20050830074815.4">"[Leo] should either replace or greatly augment the development tools that I
use." -- Zak Greant

"Leo is a marriage of outlining and literate programming. Pure genius. The main
reason I am impressed with this tool is that it doesn't affect your choice of
tools. You can use whatever IDE for whatever language and switch back and forth
between Leo and it." -- Austin King

"Leo is the best IDE that I have had the pleasure to use. I have been using it
now for about 2--3 months. It has totally changed not only the way that I
program, but also the way that I store and organize all of the information that
I need for the job that I do." -- Ian Mulvany

"I only have one week of Leo experience but I already know it will be my default
IDE/project manager...people complain about the lack of a project manager for
the free/standard Python IDE's like Idle. Leo clearly solves that problem and in
a way that commercial tools can't touch." -- Marshall Parsons

"I have been using Leo for about 3 weeks and I hardly use my other programming
editor anymore...I find it easy and enjoyable to use. I plan to adopt it as my
presentation tool for code reviews." -- Jim Vickroy

"I'm absolutely astounded by the power of such a simple idea! It works great and
I can immediately see the benefits of using Leo in place of the standard flat
file editor." -- Tom Lee

I think you're really showing what open source can do and your current
trajectory puts you on track to kick Emacs into the dustbin of computing
history. -- Dan Winkler
</t>
<t tx="ekr.20050830074815.5">"Word outlines are very useful. But Leo makes Word look like a clunky toy."
--Joe Orr

"Leo is an interactive editor for organizing text fragments hierarchically and
sequentially into one or more files and hierarchical folders, without arbitrary
limits on the number and size of text fragments and the depth of the
hierarchy...Tangle is a tool for combining hierarchically and sequentially
organized text fragments into text files, hierarchically grouped into folders,
with hierarchical or sequential organization of text within the files, and
without arbitrary limits on the size and number of files and the depth of the
hierarchy of folders and text nesting within the files." -- Alex Abacus

"Leo reminds me a great deal of things I loved when I used Userland's Frontier
(an outlining cms with a native oodb) - but Frontier wasn't hackable enough for
me, and it wasn't oriented towards coding and literate programming, and you
couldn't round-trip rendered pages (big Leo win). This is really a super tool -
in a matter of days I've started to use it on all my projects and I still
haven't figured out how I lived without it." -- John Sequeira

"Leo is EXACTLY the kind of outliner I was looking for--fantastic job!"
-- Steve Allen

"If you are like me, you have a kind of knowledge base with infos gathered over
time. And you have projects, where you use some of those infos. Now, with
conventional outliners you begin to double these infos, because you want to have
the infos needed for the project with your project. With Leo you can do this
too, but if you change text in one place IT IS UPDATED IN THE OTHER PLACE TOO!
This is a feature I did not see with any other outliner (and I tried a few).
Amazing! Leo directly supports the way I work!" -- F. Geiger
</t>
<t tx="ekr.20050830074815.6">"Another day, another breakthrough using Leo--now I realize Leo is the best URL
bookmark manager there is. No more bookmarks menus or favorites lists inside the
browser for me. With the @url directive I can just double click on the URL to
open it in my browser. Leo lets me arrange the URLs in a hierarchy (or multiple
hierarchies), attach notes to them, save clippings of things I read on the
sites. It's sooo much better than anything the browsers have built in and it
lets me easily use different browsers on different platforms and different
machines (try that with the browsers' built-in bookmark managers)." -- Dan
Winkler

"I am an amateur photographer. I use plain old 35mm. film for my pictures. Over
the weekend, I used Leo to organize my lists of pictures. It is quite helpful--I
can have separate nodes for pictures I have enlarged, as well as pictures I have
submitted to our local camera club. Thanks!" -- Rich Reis

"Cloning is pure genius!... Leo's cloning facility, allows me to create several
views on the CFA course material. My main view follows the prescribed study
guide. Another view is organized like the textbooks. Yet another gives me a
glossary of terms. And when I'm done, I'll have some nice libraries...I can
re-use later in other projects." -- Michael Manti</t>
<t tx="ekr.20050830074815.7">"I've tried Literate Programming tools off and on for more than 10 years, mainly
because the promise was so great. I've abandoned them every time because working
with the various Cweb-like tools was so awkward. Leo changes all that. The most
important benefits promised by Literate Programming are realized by using Leo,
without the awkwardness of the other tools." -- Dave Hein

"[Leo] has enabled me to use Literate Programming in production for the first
time. When I figured out I could do it in plain text and export to DocBook for
automated typesetting, I was on my way. Because I only do business and utility
software, I don't need the sophistication of LaTeX markup. Writing the
documentation and the code in the same outline at the same time improves the
whole product. Being able to automatically export both with just two key presses
(tangle and export-to-DocBook) is a real luxury." -- Michael Dawson

I wanted to thank you for the effort you've put into Leo. It looks fantastic.
I've always though that Literate Programming was a good idea, but the tools were
completely un-workable. -- Bob Hustead</t>
<t tx="ekr.20050830074815.8">"I've written documentation in WordPerfert, Ventura, Word, PageMaker, and
FrameMaker and even though they create wonderfully looking and useful documents,
they've never been able to do what I've been looking for. HTML, compiled help
files, and later PDF came closer, but still not there...I think I've found it in
LEO, a way to make a "living" document. A document built out of discrete parts
that can be re-organized on the fly to meet the needs of a varying
audience...I've already started converting the IT Procedures manual from Open
Office to LEO because I know it's going to be much more useful to me and anyone
else...just the possibility of keeping system maintenance scripts in the IT
manual is mind boggling." -- David Nichols

"With the help of the rst2 plugin, [Leo is] the best outliner I have yet
encountered for writing the early stages of academic papers."

"A Leo file is an ideal documentation tool, collecting the assorted readme.txt
files, the comments from the source files...as well as the config files
themselves." -- Kent Tenney</t>
<t tx="ekr.20050830074815.9">"Just as structured programming reveals and disciplines the flow control of a
program, [Leo] allows the designer to reveal and discipline structure at many
layers simultaneously: data structures, object structure, entity-relationship
structure, client-server structure, design pattern structure, temporal
structure, project management structure, and any other structure relevant to the
system." -- Steven P. Schaefer

"A funny observation with Leo is that when I 'Leo-ise' other people's code, Leo
makes the code's structure so transparent that design faults become very quickly
apparent. For example, maintenance pain caused by lack of factorization." --
David McNab

"Leo is a powerful tool for organizing text into tree structures, and for just
generally attacking a number of problems from a tree-based perspective." -- Joe
Orr

"I found this blog entry by someone (a talented former coworker of mine
actually) complaining about some poorly written code she had to maintain:
http://snippy.ceejbot.com/wiki/show/start/2003/01/29/001 She said: 'You'd need a
bulldozer to start refactoring it.' That was my cue to write a long message
explaining that there is indeed such a bulldozer and it's called Leo. (You can
see my message there as a reply to her original posting.) I gave her my recipe
for how to get someone else's messy, scary code into Leo and how to break it
down into manageable chunks." -- Dan Winkler

"Ed, you continue to push the envelope. The amazing thing is that the footprint
isn't doubling every few months like it would be in another designer's hands.
Adding features by removing constraints, hot refactoring while adding unit
tests. Forget the book. I would pay to see the movie."</t>
<t tx="ekr.20050830075229">.. Relative links...

.. _quotes:         testimonials.html
.. _toc:            leo_TOC.html
</t>
<t tx="ekr.20050830115714">####
FAQ
####

This is Leo's Frequently Asked Questions document.

.. .. contents::
..    :depth: 2

</t>
<t tx="ekr.20050830115714.1"></t>
<t tx="ekr.20050830115714.10">The encoding used in the file being imported doesn't match the encoding in effect for Leo.
You have two options:

- Use the @encoding directive_ in an ancestor of the node_ selected when
  doing the Import command_ to specify the encoding of file to be imported.

- Set the tk_encoding setting_ (see the previous answer) to the encoding you normally use.</t>
<t tx="ekr.20050830115714.113">**Question**:
It would be nice if Leo could open empty files. I tend to be "document oriented"
rather than "application oriented" in my thinking and prefer "create empty file
at location -&gt; open it with program" to "start program -&gt; create new file -&gt;
save it at location".

**Answer** by Paul Paterson:
If you are on Windows 98/2000/XP then the procedure is as follows...

1. Start Leo
2. Click New
3. Click Save as...
4. Save the file as "c:\\windows\\shellnew\\leofile.leo" (or c:\\winnt for 2000/XP)
5. Open regedit "start...run...regedit"
6. Open HKEY_CLASSES_ROOT and find the ".leo" extension type
7. Go New ... Key from the context menu 
8. Call the new key ShellNew 
9. Select the new key, right-click, choose New...String Value from the context menu
10. Call it FileName 
11. Double-click on the string, and modify it to be the filename of the leofile.leo file you created,
    including the extension
12. Exit the registry editor and restart Windows Explorer (you may need to reboot on Windows 98)

Now you should have a New:Leo File option in Explorer. This creates a duplicate
of the file you saved. This can be useful because you could make a template Leo
file containing some standard nodes_ that you always have and then save this.</t>
<t tx="ekr.20050830115714.114">By Dave Hein: The cause of the keymapping problem is a issue with the X11
keyboard mapping, not with Tk. If you have this problem on your system, issue
the command::

    xmodmap -pke 

and look in the results for the line for keycode 22. I'll bet it shows something like::

    keycode 22 = BackSpace Terminate_Server

That second token ("Terminate_Server") is what is supposed to be mapped to
Shift-Backspace. You want this second token to be either not present or to be
BackSpace. To fix this, create a file (e.g. .Xmodmap) and give it the content::

    keycode 22 = BackSpace

then run the command::

    xmodmap .Xmodmap

This fixes the problem. On my system this also disables the ability to terminate
the X server using Ctrl-Alt-BackSpace. This is because of some conflict with xdb
(xdb is the newer keyboard mapping facility in XFree86; xmodmap is the old
original X11 keyboard mapping facility). I'm still working on that. I'm also not
able to get xmodmap to make this change during X11 startup (again because of
conflicts with xdb). But I'm working on that as well.</t>
<t tx="ekr.20050830115714.115">For the most part, docutils_ does a good job of reporting errors. docutils_ prints
a message to the console and inserts an unmistakable error message in the
generated .html file.
**Important**: On Windows it is helpful to `run Leo in a console window`_.

However, in some cases, docutils_ crashes instead of properly reporting the
problem. There are several workarounds:

1.  The crashes I have seen arise from the following bug in docutils.
    **Hyperlinks in image:: markup must be lower case**.  This will work::

        .. .. |back| image:: arrow_lt.gif
            :target: faq_

    This will **crash**::

        .. .. |back| image:: arrow_lt.gif
            :target: FAQ_

    So avoid this crash by making sure to use lower case targets in ':target:' markup.

2.  You can change the docutils_ source slightly so that it prints a traceback when it
    crashes. (The rst3 plugin should be able to do this, but I haven't figured
    out how yet.) It's easy enough to do this:

    - Find the file core.py in top-level docutils folder.
      Typically this folder will be in Python's site-packages folder.

    - Open core.py in some editor other than Leo.

    - Find the method called report_Exceptions.

    - Insert the following lines at the very start of this method::

        print 'EKR: added traceback'
        import traceback ; traceback.print_exc()

    This will cause a traceback whenever docutils_ crashes. I have found that
    such tracebacks are generally enough to locate the general area of the
    problem. **Note**: These tracebacks go to the console window, so you should
    `run Leo in a console window`_.

3.  As a last resort, you can isolate syntax errors by reducing your input files
    until they work again, then adding sections until you get a crash. This is
    easy enough to do (when using the rst3 plugin) by change a headline 'x' to
    @rst-ignore-tree x.</t>
<t tx="ekr.20050830115714.116">From: http://sourceforge.net/forum/message.php?msg_id=3240374
Using Leo's File-Export-Flatten Outline commands creates a MORE style outline which places
all Leo body sections on the left margin.
The headlines_ are indented with tabs which Excel will read as a tab delimited format.
Once inside Excel there are benefits.

1.  The most obvious benefit inside Excel is that the body sections (Excel first
    column) can be selected easily and highlighted with a different font color.
    This makes the MORE format very readable. Save a copy of your sheet as HTML
    and now you have a web page with the body sections highlighted.

2.  It is possible to hide columns in Excel.
    Hiding the first column leaves just the headlines showing.

3.  Formulas based on searching for a string can do calculations in Excel.
    For example if a heading "Current Assets" appears on level 4 then the body formula::

        =INDEX(A:A,MATCH("Current Assets",D:D,0)+1)

    will retrieve it. The +1 after match looks down one row below the matched
    headline. The trick is to place all your headlines in quotes because Excel
    will see + "Current Assets" from the MORE outline. When Excel tries
    without the quotes it thinks it is a range name and displays a #N/A
    error instead of the headline. Also you must place a child node_ below to
    get the + sign instead of a - sign which would give a MORE headline of
    -"Current assets" , also is an error.

I think there is some interesting possibility here because of the enforcement of
Leo body text being always in the first column. The Leo outline provides
additional reference to organizing the problem not typical of spreadsheet
models. Beyond scripting in Python, Excel is good at doing interrelated
calculations and detecting problems like circular references. In Excel
Tools-Options-General is a setting for r1c1 format which then shows numbers
instead of letters for column references. Using this would allow entries like
this in the leo body::

    1000
    3500
    =R[-1]C+R[-2]C

In Excel you would see 4500 below those two numbers. This is completely
independent of where the block of three cells exists on the sheet.</t>
<t tx="ekr.20050830115714.117">Python's decorator_ syntax is ill-conceived.
This syntax file hack works well enough anyway to work with Leo '@' markup::

    syn region leoComment start="^@\\s*" end="^@c\\s*$"
    syn match   pythonDecorator	"@\\S\\S+" display nextgroup=pythonFunction skipwhite</t>
<t tx="ekr.20050830115714.118"></t>
<t tx="ekr.20050830115714.119">By Rich Ries.
I often rework C code that's already been "Leo-ized"--the first pass was quick
and dirty to get it going. When I do subsequent passes, I wind up with subnodes
that are out of order with the sequence found in the main node_. It's not a big
deal, but I like 'em ordered. With just one editor pane, clicking on the node_ to
move would switch focus to that node_. I'd then need to re-focus on the main
node_. A minor nuisance, but it does slow you down.

My solution is to open a second editor with its focus on the main node_. Switch
to the other editor, and, referring to the first editor pane, move the nodes as
you like. The second editor's pane will change focus to the node_ you're moving,
but the first editor will stay focused on the main node_. It's a lot easier to
do than to describe!
</t>
<t tx="ekr.20050830115714.12">Using @thin trees can eliminate most problems with using Leo in cooperative
(SCCS) environments:

- Developers should use @thin trees to create external files in any kind of
  cooperative environment.

- If sentinels are frowned upon in your development community, use @auto or
  @shadow instead of @thin.

- The repository contains **reference** .leo files. These reference files should
  contain nothing but @thin nodes. Reference files should change only when
  new external files get added to the project. Leo's `bzr repository`_ and Leo
  distributions contain the following reference files: LeoPyRef.leo,
  LeoPluginsRef.leo and leoGuiPluginsRef.leo. Developers should use
  local copies of reference files for their own work. For example, instead of
  using LeoPyRef.leo directly, I use a copy called LeoPy.leo.</t>
<t tx="ekr.20050830115714.120">One way is to link directly to the media file from a Leo node_ (with @url)
and write a scriptbutton to wrap all URL-nodes under the current node_ in a
single HTML page (using the HTML browser trick at
http://sourceforge.net/forum/forum.php?thread_id=1201579&amp;forum_id=10226).

Then, you can view your media in two ways:

-   Individually. You can directly click on the @url link to display the media
    in the browser (assuming you have your MIME/filetype associations set up
    correctly for your browser).

-   In a group. You can click on a script button (you have to code this yourself,
    very simple) which should collect all @url nodes_ under the current node_
    and dynamically generate a HTML page displaying either links to or embedded
    versions of the media (using the HTML trick described above to invoke the
    browser). This way, you can create collections of @url nodes under a
    single node_ (like a bookmark folder), and press a single button to view the
    @url collection as a single entity in the browser (with all browser
    capabilities like displaying the media).

You could probably generalize this idea of "collect all @url nodes under current
node_ and display as HTML in browser" into a general-purpose plugin. However,
the plugin would have to be somewhat smart in mapping a link to its corresponding
HTML code (e.g. an image link gets mapped to an &lt;img&gt; HTML tag, a link to a
Flash file gets mapped to an &lt;embed&gt; tag, etc).</t>
<t tx="ekr.20050830115714.13"></t>
<t tx="ekr.20050830115714.14">You have two options, depending on whether you want to be able to use sections
or not.

-   Use @nosent trees.
    Files derived from @nosent trees contain no sentinels_.
    However, Leo create the external file just as in @thin trees.
    In particular, Leo expands section references and understands the @others directive.

-   Use @asis trees.
    Files derived from @asis trees contain no sentinels_.
    Moreover, Leo does not expand section references in asis trees.
    In other words, Leo creates the `external file` simply by writing all body text in outline order.
    Leo can't update the outline unless the external file contains sentinels,
    so Leo does not update @nosent trees or @asis trees automatically when
    you change the external file in an external editor.</t>
<t tx="ekr.20050830115714.16">Use @asis trees. Files derived from @asis trees contain no sentinels. Leo
creates the external file simply by writing all body text in outline order. Leo
can't update the outline unless the external file contains sentinels, so Leo
does not update @asis trees automatically when you change the external file in
an external editor.</t>
<t tx="ekr.20050830115714.17">The import commands insert @ignore directives_ in the top-level node_.
Leo does this so that you won't accidentally overwrite your files after importing them.
Change the filename following @thin or @root as desired,
then remove the @ignore directive_.
Saving the outline will then create the external file.</t>
<t tx="ekr.20050830115714.18">**Question**: I'm writing a Windows Script Component, which is an XML file with
a CData section containing javascript. I can get the XML as I want it by using
\@language html, but how can I get the tangling comments inside the CData
section to be java-style comments rather than html ones?

**Answer**: In @thin trees you use the @delims directive to change comment delimiters.
For example::

    @delims /* */ 
    Javascript stuff 
    @delims &lt;-- --&gt; 
    HTML stuff

**Important**: Leo can not revert to previous delimiters automatically;
you must change back to previous delimiters using another @delims directive_.

In @root trees you can work around this problem using the @silent directive_.</t>
<t tx="ekr.20050830115714.19">By Zvi Boshernitzan: I was having trouble disabling '&lt;?php' with comments (and
couldn't override the comment character for the start of the page). Finally, I
found a solution that worked, using php's heredoc string syntax::

    @first &lt;?php
    @first $comment = &lt;&lt;&lt;EOD
    EOD;

    // php code goes here.
    echo "boogie";

    $comment2 = &lt;&lt;&lt;EOD
    @last EOD;
    @last ?&gt;

or::

    @first &lt;?php
    @first /*
    */

    echo "hi";

    @delims /* */
    @last ?&gt;</t>
<t tx="ekr.20050830115714.2">First, read the tutorial_. This will be enough to get you started if you just
want to use Leo as an outliner_. If you intend to use Leo for programming, read
the `Quick start for programmers`_, then look at Leo's source code in the file LeoPy.leo.
Spend 5 or 10 minutes browsing through the outline. Don't worry about details;
just look for the following common usage patterns:

-   The (Projects) tree shows how to use clones to represent tasks.

-   Study @thin leoNodes.py.
    It shows how to define more than one class in single file.

-   Most other files show how to use a single @others directive to define one class.

-   Most methods are defined using @others, *not* section definition nodes.</t>
<t tx="ekr.20050830115714.20">Here is a posting which might be helpful:
http://sourceforge.net/forum/message.php?msg_id=2300457 The @first
directive_ is the key to output usable code in unsupported languages. For
example, to use Leo with the Basic language, use the following::

    @first $IFDEF LEOHEADER
    @delims '
    @c
    $ENDIF

So this would enable a basic compiler to "jump" over the "true" LEO-header-lines.
Like this::

    $IFDEF LEOHEADER &lt;-conditional compilation directive 
    #@+leo-ver=4 &lt;-these lines not compiled
    #@+node:@file QParser005.INC
    #@@first
    #@delims ' 
    '@@c
    $ENDIF &lt;-... Until here!
    &lt;rest of derived code file ... &gt;

This changes the comment symbol the apostrophe,
making comments parseable by a BASIC (or other language.)</t>
<t tx="ekr.20050830115714.21">Use the @first directive_ in @thin trees or @nosent trees.
Use the @silent directive in @root trees.

The @first directive puts lines at the very start of files derived from @thin.
For example, the body text of @thin spam.py might be::

    @first #! /usr/bin/env python

The body text of @thin foo.pl might be::

    @first #/usr/bin/perl

Leo recognizes the @first directive_ only at the start of the body text of @thin nodes.
No text may precede @first directives_.
More than one @first directive may exist, like this::

    @first #! /usr/bin/env python
    @first # more comments.</t>
<t tx="ekr.20050830115714.22">Leo has good support for `CWEB`_.
@thin trees can organize any part of CWEB code using *noweb* sections.
You can also use @asis or @nosent trees to create cweb files.
See `CWEB mode`_ for full details.
</t>
<t tx="ekr.20050830115714.24">No. Everything in an @thin trees must be part of the external file: orphan and
\@ignore nodes are invalid in @thin trees. This restriction should not be
troublesome. For example, you can organize your outline like this::

    + myClass
    ..+ ignored stuff
    ..+ @file myClass

(As usual, + denotes a headline.) So you simply create a new node_, called
myClass, that holds your @thin trees and stuff you don't want in the @thin
trees.</t>
<t tx="ekr.20050830115714.25">By Rich Ries.
Some older C compilers don't understand the "//" comment symbol, so using @language C won't work.
Moreover, the following does not always work either::

    @comment /* */

This generates the following sentinel line::

    /*@@comment /* */*/

in the output file, and not all C compilers allow nested comments, so the last \*\/ generates an error.
The solution is to use::

    #if 0
    @comment /* */
    #endif

Leo is happy: it recognizes the @comment directive_.
The C compiler is happy: the C preprocessor strips out the offending line before the C
compiler gets it.</t>
<t tx="ekr.20050830115714.26"></t>
<t tx="ekr.20050830115714.29">See the instructions are in LeoPy.leo in::

    Notes:How To:How to add support for a new language section.

This section contains clones of all relevant parts of Leo that you will change.
Coming in Leo 4.4: Leo will use JEdit's language description files to drive the
syntax colorer. To add support for a new language, just add another such
description file.</t>
<t tx="ekr.20050830115714.30">You have two options: 

-   Get cvs write access, and add the @thin file to the plugins directory.

-   Just send the @thin file to me at edreamleo@gmail.com.
    That's all you need to do.  In particular that there is no need to change leoPlugins.leo.</t>
<t tx="ekr.20050830115714.4">.. _`Clones &amp; views`:   intro.html#clones-views

You will lose much of Leo's power if you don't use clones.
See `Clones &amp; views`_ for full details.</t>
<t tx="ekr.20050830115714.5">Use @thin trees unless you are *sure* you must have the extra flexibility of @root trees.
Indeed, @thin trees are much easier to use than @root trees:

- @thin trees use less markup than @root trees.
  In particular, the @others directive is valid only within @thin trees.

- You must explicitly tangle_ and untangle_ @root trees using the `Tangle and Untangle`_ commands.

However, @root trees are more flexible than @thin trees:

- Sections_ may be defined anywhere within @root trees.
  Moreover, the @unit directive_ expands the scope of section definitions in @root trees
  so that a section may be referenced in several @root trees.

- The meaning of section definitions in @root trees are independent of their position within the tree.</t>
<t tx="ekr.20050830115714.7">Use methods for any code that is used (called or referenced) more than once.

Sections_ are convenient in the following circumstances:

-   When you want to refer to snippets of code the can not be turned into methods.
    For example, many plugins start with the code like this::

    &lt;&lt; docstring &gt;&gt;
    &lt;&lt; imports &gt;&gt;
    &lt;&lt; version history &gt;&gt;
    &lt;&lt; globals &gt;&gt;

    None of these sections could be replaced by methods.

-   When you want to refer to a snippet of code that shares local variables with the enclosing code.
    This is surprisingly easy and safe to do, *provided* the section is used only in one place.
    `Section names`_ in such contexts can be clearer than method names.  For example::

    &lt;&lt; init ivars for writing &gt;&gt;

In short, I create sections when convenient,
and convert them to functions or methods if they need to be used in several places.</t>
<t tx="ekr.20050830115714.74">The Import Files dialog allows you to select multiple files provided you are running Python 2.3 or above.
There is also an importFiles script in LeoPy.leo.  You can use that script as follows::

    import leo.core.leoImport as leoImport
    leoImport.importFiles(aDirectory, ".py")

This will import all .py files from aDirectory, which should be a full path to a particular directory.
You could use ".c" to import all .c files, etc.</t>
<t tx="ekr.20050830115714.75">From: http://sourceforge.net/forum/message.php?msg_id=1685399

When building Tcl on Linux, do not specify "--enable-threads"
Only use Tcl with the default "threads not enabled" case.

Here is how to build Tk without thread support:

- Go to www.tcl.tk, and download the sources for Tcl and Tk.
- Build those two pack's as is told in the "How to Compile Tcl Source Releases"
- Go to www.python.org and download your favorite Python (2.3.5 for me).
- Build it as is told on the download page.
- Enjoy using Leo on Linux.
</t>
<t tx="ekr.20050830115714.76"></t>
<t tx="ekr.20050830115714.77">Just `run Leo in a console window`_. At the point you want to drop into the
debugger, execute this line::

    g.pdb()

All output from pdb goes to stdout, which is the console window. It would be
good to create a subclass of pdb.Pdb that uses Leo's log pane rather than a
console window, but I haven't done that. It could be done easily enough in a
plugin...

**Important**: I recommend using g.trace instead of pdb.  For example::

    g.trace(x)

prints the name of the function or method containing the trace, and the value of
x. g.callers is often useful in combination with g.trace. g.callers(5)
returns the last 5 entries of the call stack. For example::

    g.trace(x,g.callers(5))

Used this way, g.trace shows you patterns that will be invisible using pdb.</t>
<t tx="ekr.20050830115714.9">Internally, Leo represents all strings as unicode. Leo translates from a
particular encoding to Unicode_ when reading .leo files or external files. Leo
translates from Unicode_ to a particular encoding when writing external files.
You may see strange looking characters if your text editor is expecting a
different encoding. The encoding used in any external file is shown in the
#@+leo sentinel line like this::

    #@+leo-encoding=iso-8859-1.

**Exception**: the encoding is UTF-8 if no -encoding= field exists.
You can also use the @encoding directive_ to set the encoding for individual external files.
If no @encoding directive_ is in effect,
Leo uses the following settings_ to translate to and from unicode:

default_derived_file_encoding
    The encoding used for external files if no @encoding directive_ is in effect.
    This setting also controls the encoding of files created by the Tangle commands.
    The default is UTF-8 (case not important).

new_leo_file_encoding
    The encoding specified in the following line of new .leo files::

        &lt;?xml version="1.0" encoding="UTF-8"&gt;

    The default is UTF-8 (upper case for compatibility for old versions of Leo).

tk_encoding
    The encoding that Leo uses to communicate with Tk text widgets.
    You would typically use this setting only in an emergency.
    The section called::

        &lt;&lt; set app.tkEncoding &gt;&gt;

    in app.finishCreate sets this encoding as follows:

    a) using the tk_encoding setting if it exists,
    b) using locale.getpreferredencoding if it exists,
       or the equivalent code in pre-python 2.3 versions,
    c) using sys.getdefaultencoding
    d) defaulting to "utf-8"

    Neither b nor c are guaranteed to give a valid encoding in all systems,
    and Leo will ignore invalid encodings returned from b or c.
    Therefore, setting the tk_encoding setting may be needed.</t>
<t tx="ekr.20050830120007">.. Links used in this document...

.. ----- External links.

.. _`cvs repository`:   http://sourceforge.net/cvs/?group_id=3458
.. _decorator:          http://www.python.org/peps/pep-0318.html
.. _docutils:           http://docutils.sourceforge.net/
.. _unicode:            http://www.unicode.org/
.. _`bzr repository`:   https//code.launchpad.net/leo-editor/

.. ----- Relative links into Leo's documentation.

.. _`Associating Leo with .leo Files`:  install.html#how-to-associate-leo-with-leo-files-on-windows
.. _`How to install Leo on Windows`:    install.html#how-to-install-leo-on-windows

.. _`CWEB mode`:                                directives.html#cweb-mode
.. _command:                                    commands.html
.. _commands:                                   commands.html
.. _`quick start for programmers`:              intro.html#quick-start-for-programmers
.. _`rst3 plugin`:                              rstplugin3.html

.. _`Tangle and Untangle`:                      commands.html#tangling-an-outline-producing-derived-files
.. _tutorial:                                   intro.html
.. _`Leo 4.0: Eliminating error 'recovery'`:    history.html#leo-4-0-eliminating-error-recovery
.. _`Chapter 9: History of Leo`:                history.html
.. .. _`Run Leo in a console window`:            `How can I run Leo from a console window?`_
.. _`Run Leo in a console window`:              install.html#running-leo-from-a-console-window
.. _`run Leo in a console window`:              install.html#running-leo-from-a-console-window
.. _`console window`:                           install.html#running-leo-from-a-console-window

.. ----- References to the glossary: the glossary now contains references to the tutorial.
.. _`@asis`:                glossary.html#asis-trees
.. _`@auto`:                glossary.html#auto-trees
.. _`@file`:                glossary.html#file-trees
.. _`@others directive`:    glossary.html#others
.. _`@nosent`:              glossary.html#nosent
.. _`@root`:                glossary.html#root
.. _`@shadow`:              glossary.html#shadow-trees
.. _`@thin`:                glossary.html#thin-trees
.. _`@unit`:                glossary.html#unit
.. _`body text`:            glossary.html#body-text
.. _cweb:                   glossary.html#cweb
.. _directive:              glossary.html#directive
.. _directives:             glossary.html#directives
.. _`external file`:        glossary.html#external-file
.. _`external files`:       glossary.html#external-files
.. _headline:               glossary.html#headline
.. _headlines:              glossary.html#headlines
.. _node:                   glossary.html#node
.. _nodes:                  glossary.html#nodes
.. _outliner:               glossary.html#outliner
.. _sections:               glossary.html#sections
.. _`section name`:         glossary.html#section-name
.. _`section names`:        glossary.html#section-names
.. _sentinels:              glossary.html#sentinels
.. _`sentinel line`:        glossary.html#sentinel
.. _`sentinel lines`:       glossary.html#sentinel
.. _setting:                glossary.html#setting
.. _settings:               glossary.html#settings
.. _tangle:                 glossary.html#tangle
.. _untangle:               glossary.html#untangle
</t>
<t tx="ekr.20050830120844">c.frame.menu.createMenuItemsFromTable will append items to the end of an existing menu.
For example, the following script will add a new item at the end of the 'File' menu::

    def callback(*args,**keys):
        g.trace()

    table = (("Test1",None,callback),)

    c.frame.menu.createMenuItemsFromTable('File',table)

Plugins can do anything that can be done with Tk using the menu returned by
c.frame.menu.getMenu. For example, here is a script that adds a Test menu item
after the 'Open With' menu item in the File menu::

    def callback(*args,**keys):
        g.trace()

    fileMenu = c.frame.menu.getMenu('File')

    # 3 is the position in the menu.  Other kinds of indices are possible.
    fileMenu.insert(3,'command',label='Test2',command=callback)</t>
<t tx="ekr.20050830120857">The trick is to create a workflow that separates editing from testing. Putting
test code in LeoPy.leo would waste a lot of time. To run tests you would
have to exit Leo and reload LeoPy.leo. A much quicker way is to put all test
code in a test.leo file. So to change and test code, do the following:

1. Save LeoPy.leo but do **not** exit Leo. 

2. Quit the copy of Leo running test.leo, then reload test.leo.

3. Run test scripts from test.leo.

That's all. Python will recompile any changed .py files in the new copy of Leo.
**Note**: I create a batch file called t.bat that runs test.leo, so to the
"edit-reload-test" cycle is just:

1. Control-S (in LeoPy.leo: saves the .leo file)
2. t         (in a console window: runs test.leo, compiling all changed .py files as a side effect)
3. Control-E (in test.leo: runs the test script)

The benefits of the new workflow:

- test.leo loads  _much_ more quickly than LeoPy.leo does.
  This new approach can increase the speed of the edit-reload-test cycle by more than a factor of 10.
  Hitting Control-S, t, Control-E takes about 5 seconds.

- LeoPy.leo runs with the *old* code,
  so it is much easier to fix syntax errors or exceptions in the *new* code:
  just fix the problem and save LeoPy.leo *without* closing LeoPy.leo,
  then restart test.leo.
  You run your tests on the new code, but you edit the new code with the old, stable code.

- test.leo is the perfect place to develop test.
  I can create and organize those tests and when I am done, ''test.leo'' is a log of my work.</t>
<t tx="ekr.20050831184021.1">@language rest</t>
<t tx="ekr.20050831184021.3">@language rest</t>
<t tx="ekr.20050831184021.4">@language rest</t>
<t tx="ekr.20050831184021.5">@language rest</t>
<t tx="ekr.20050831195331.1">@language rest</t>
<t tx="ekr.20050831195331.2">@language rest</t>
<t tx="ekr.20050831195331.4">@language rest</t>
<t tx="ekr.20050831195449">@nocolor

For instruction about installing Leo see:
http://webpages.charter.net/edreamleo/install.html

For everything a beginner needs to know about Leo see:
http://webpages.charter.net/edreamleo/intro.html

For help, please ask questions at:
http://groups.google.com/group/leo-editor</t>
<t tx="ekr.20050831231852">############
Appendices
############

.. .. contents::
</t>
<t tx="ekr.20050831232205">.. Relative links.
.. _`Chapter 13: Writing plugins`:   writingPlugins.html

.. References to the glossary.
.. _`sentinel lines`:             glossary.html#sentinel-lines
</t>
<t tx="ekr.20050901054622">c.save()</t>
<t tx="ekr.20050901055150">@color
# Script to promote headlines and body text

root = p.copy()
body = [root.bodyString()+'\n']
for p in root.subtree_iter():
    body.append(p.headString())
    body.append(p.bodyString().rstrip()+'\n')

body = '\n'.join(body)
root.setBodyString(body)
</t>
<t tx="ekr.20050901060119">@color

# Converts text selection to def list.

@others

createDefList(c,p)</t>
<t tx="ekr.20050901061220">def createDefList(c,p):
    
    undoType = 'Create Def List'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not lines: return
    
    result = ['``%s``\n' % lines[0].strip()]
    
    for line in lines[1:]:
        result.append('    %s' % line.lstrip()+'\n')
    lines = ''.join(result).rstrip()

    c.updateBodyPane(head,lines,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20050901071041">############
Glossary
############
</t>
<t tx="ekr.20050901071300">.. Links used in this document.

.. ----- External links.

.. _`CWEB language`:                    http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`literate programming web page`:    http://www.literateprogramming.com/
.. _`noweb language`:                   http://www.eecs.harvard.edu/~nr/noweb/
.. _`rST primer`:                       http://docutils.sourceforge.net/docs/user/rst/quickstart.html

.. ----- Relative links.

.. _`Chapter 8: Customizing Leo`:   customizing.html
.. _`Writing plugins and hooks`:    writingPlugins.html

.. _`programming reference`:    directives.html
.. _`@asis`:                    directives.html#asis-and-noref
.. _`@auto`:                    directives.html#auto
.. _`@file`:                    directives.html#file-and-thin
.. _`@noref`:                   directives.html#asis-and-noref
.. _`@nosent`:                  directives.html#nosent
.. _`@root`:                    directives.html#root
.. _`@thin`:                    directives.html#file-and-thin
.. _`@unit documentation`:      directives.html#root
.. _`tangling @root trees`:     directives.html#tangling-root-trees-with-the-tangle-commands
.. _`untangling @root trees`:   directives.html#untangling-root-trees-with-the-untangle-commands

.. ----- References to the tutorial.
.. _`clones &amp; views`:               intro.html#clones-views
.. _`leo's tutorial`:               intro.html
.. _`external files section`:        intro.html#derived-files
.. _`directives for programming`:   intro.html#directives-for-programming
.. _`leo directives`:               intro.html#leo-directives
.. _`quick start for programmers`:  intro.html#quick-start-for-programmers
.. _`sentinels lines`:              intro.html#sentinel-lines
</t>
<t tx="ekr.20050901073048">**Important**: We often refer to outline_ nodes_ by the directives_ they contain.
For example, an `@root node`_ is a node containing an @root directive_, etc.
**Exception**: An `@file node`_ is a node whose *headline* starts with @file.

.. _`@auto node`:
.. _`@file node`:
.. _`@thin node`:
.. _`@root node`:
.. _`@file nodes`:
.. _`@thin nodes`:
.. _`@root nodes`:

@file node
    An @file node_ is a node whose *headline* starts with @file.
    **Important**: Headlines_ that start with @file-asis, @file-noref, @file-nosent
    (and their abbreviations @asis, @noref, @nosent) are collectively called @file nodes.

.. _`@auto tree`:
.. _`@file tree`:
.. _`@thin tree`:
.. _`@root tree`:
.. _`@file trees`:
.. _`@shadow trees`:
.. _`@thin trees`:
.. _`@root trees`:

@file tree, @others tree, @root tree, etc.
    An @file tree_ is a tree whose root_ is an @file node, etc.

@asis, @auto, @file, @noref, @nosent, @thin
    Headlines_ that start with one of these create (correspond to) `external files`_.
    The following synonyms exist::

        @asis, @file-asis
        @noref, @file-noref
        @nosent, @file-nosent

    For more information, see the documentation for `@asis`_, `@auto`_, `@file`_, `@noref`_, `@nosent`_ and `@thin`_
    in Leo's `programming reference`_ chapter.

    \@auto trees allow you to edit external files that contain no sentinels.
    Leo will import the @auto files when reading .leo files.  Be careful when first creating the @auto node.
    *Before* saving the .leo file containing the new @auto node,
    use the read-at-auto-nodes command to do the initial import.

.. _`@all`:
.. _`@all directive`:

@all
    A directive_ that copies the `body text`_ of all nodes_ in an `@thin` tree to the corresponding `external file`_.
    For more information, see `directives for programming`_ in `Leo's tutorial`_.

.. _`@others`:
.. _`@others directive`:

@others
    A directive_ that copies the `body text`_ of all nodes_ *except* `section definition nodes`_
    in an `@thin` tree to the corresponding `external file`_.
    For more information, see `directives for programming`_ in `Leo's tutorial`_.

.. _`@unit`:
.. _`@unit directive`:

@unit
    A directive_ that expands the scope_ of definitions in `@root` trees.
    For more information, see the `@unit documentation` in Leo's `programming reference`_.

.. _`body pane`:

Body pane
    The pane containing the `body text`_ of the currently selected headline_ in the `outline pane`_.

.. _`body text`:

Body text
    The text in the `body pane`_.  Body text is always associated with a particular node_.

.. _`body text box`:

Body text box
    A small blue box in the `icon box`_ indicating that the node_ contains `body text`_.

.. _`child`:
.. _`children`:

Child
    A node_ directly contained by a node.

.. _`chunk`:
.. _`chunks`:

Chunk
    A section_ (noweb_ terminology).

.. _`clone`:
.. _`clones`:
.. _`cloned`:

Clone
    A copy of a tree_ that changes whenever the original changes.
    The original and all clones are treated equally:
    no special status is given to the "original" node_.

.. _`clone arrow`:
.. _`clone arrows`:

Clone Arrow
    A small red arrow in the `icon box`_ indicating that the node_ is a clone_.

.. _`code part`:
.. _`code parts`:

Code part
    A part of a `section definition`_ that contains code. 
    Code parts start with @c or @code directives_ and continue until the next `doc part`_

.. _contract:
.. _contracts:
.. _contracted:

Contract:
    To hide all descendants_ of a node_.

.. _`cweb`:

CWEB
    A `literate programming`_ language invented by Donald Knuth and Silvio Levy.
    The `CWEB language`_ produces external files for the C language.

.. _`demote`:

Demote
    To move all siblings_ that follow a node_ so that they become children_ of the node.

.. _`external file`:
.. _`external files`:

external file
    The file created as the result of tangling_ a node containing an @root directive_.
    The file consists of the expansion of the text following the @root directive_.
    For more information, see the `external files section`_ of `Leo's tutorial`_.

.. _`descendant`:
.. _`descendants`:

Descendant
    An offspring_ of a node_.  That is, a child_, grandchild_, etc. of a node.

.. _`directive`:
.. _`directives`:

Directive
    A keyword, preceded by an '@' sign, in `body text`_ that controls Leo's operation.
    The keyword is empty for the @ directive.
    For more information, set the `Leo directives`_ section of `Leo's tutorial`_.

.. _`doc part`:
.. _`doc parts`:

Doc part, @doc part, document part, etc.
    A part_ of a `section definition`_ that contains comments.
    Doc parts start with @ and continue until the @c directive_ or the end of the `body text`_.
    In `@root trees`_, doc parts are associated with the immediately following `code part`_, if any.

.. _`escape convention`:
.. _`escape conventions`:

Escape convention
    A convention for representing sequences of characters that would otherwise have special meaning.
    Leo has only one such convention:
    in `@root trees`_, @@ in the leftmost column of a `code part`_ stands for a single @ character.
    **Important**:
    Leo does not support `noweb's`_ @&lt;&lt; and @&gt;&gt; escape conventions.
    Any line containing matched &lt;&lt; and &gt;&gt; is a `section reference`_, regardless of context.
    To use &lt;&lt; and &gt;&gt; as ordinary characters, place them on separate lines.

.. _expand:
.. _expands:
.. _expanded:

expand
    To make the children_ of a node_ visible.

.. _`grandchild`:
.. _`grandchildren`:

Grandchild
    The child_ of a child of a node_.

.. _`headline`:
.. _`headlines`:
.. _`headline text`:

Headline
    The headline text of a node_.  The part of the node visible in the `outline pane`_

.. _`hoist`:
.. _`hoisted`:
.. _`dehoist`:

Hoist &amp; dehoist
    Hoisting a node_ redraws the screen that node and its descendants_ becomes the only visible part of the outline_.
    Leo prevents the you from moving nodes outside the hoisted outline.  Dehoisting a node restores the outline.
    Multiple hoists may be in effect: each dehoist undoes the effect of the immediately preceding hoist.

.. _`icon box`:
.. _`icon boxes`:

.. _`LaTex`:

LaTex
    A markup language often used in `literate programming` environments.
    See: http://www.latex-project.org/

Icon box
    An icon just to the left of `headline text`_ of a node_ indicating whether the node is cloned, marked or dirty,
    and indicating whether the node contains `body text`_.

.. _`Leo1`:
.. _`Leo2`:

Leo1 and Leo2
    **Leo1** denotes all versions of Leo that write version 1 .leo files, that is,
    all Windows version of Leo prior to version 2.0.
    The last version of Leo1, version 1.15, understands enough about Leo2 to issue a warning when opening version 2 files.

    **Leo2** denotes all versions of Leo that write version 2 .leo files, that is,
    all versions of leo.py and all Windows versions with version number 2.0 and above.
    Only Leo2 can generate `external files`_ from `@file trees`_.

.. _`literate programming`:

Literate programming
    A style of programming that aims at producing the highest quality program listings.
    Literate programming languages apply two fundamental operations to text: weaving_ and tangling_.
    Leo supports two literate programming languages, `CWEB`_ and `noweb`_.
    For more links see the `literate programming web page`_.

.. _`mark`:
.. _`marks`:

Mark
    A red vertical line in the `icon box`_ of a node_.

.. _node:
.. _nodes:

Node
    The organizational unit of an outline_. The combination of `headline text`_ and `body text`_.
    Sometimes used as a synonym for tree_.

.. _`noweb`:
.. _`noweb's`:

noweb
    A literate programming language invented by Norman Ramsey.
    The `noweb language`_ can produce `external files`_ for any text-based programming language.

.. _`offspring`:

Offspring
    The children_, grandchildren_, etc. of a node_.

.. _`organizing node`:
.. _`organizing nodes`:
.. _`organizer node`:
.. _`organizer nodes`:

Organizing node, organizer node
    A node_ containing no `body text`_.
    Organizing nodes may appear anywhere in an `@file tree`_; they do not affect the external file in any way.
    In particular, organizing nodes do not affect indentation in `external files`_.

.. _`orphan`:
.. _`orphan node`:
.. _`orphan nodes`:

Orphan node
    A node_ that would not be copied to a `external file`_.
    Orphan nodes can arise because an `@thin tree`_ has no @others or @all directives_.
    Sections_ that are defined but not used also create orphan nodes.

    Leo issues a warning when attempting to write an `@thin tree`_ containing orphan nodes,
    and does not save the `external file`_.
    No information is lost; Leo saves the information in the `@thin tree`_ in the .leo file.
    Leo will load the `@thin tree`_ from the .leo file the next time Leo opens the .leo file.

.. _`outline`:
.. _`outliner`:
.. _`outlines`:

Outline
    - A node_ and its descendants_.
    - A tree_
    - All the nodes_ of a .leo file.

.. _`outline order`:

Outline Order
    The order that nodes_ appear on the screen when all nodes_ are expanded.

.. _`outline pane`:

Outline pane
    The pane containing a visual representation of the entire outline_, or a part of the outline_ if the outline is hoisted_.

.. _parent:
.. _parents:

Parent
    The node_ that directly contains a node.

.. _`part`:
.. _`parts`:

Part
    A synonym for section_.  See also `code part`_ and `doc part`_.

.. _`pdf file`:
.. _`.pdf file`:

pdf file
    A file that can be read by Adobe Acrobat.

.. _`plugin`:
.. _`plugins`:

Plugin
    - A Python file in Leo's plugins folder.
    - A way to modify and extend Leo without changing Leo's core code.
      leoPlugins.leo contains all of Leo's official plugins.

    See `Writing plugins and hooks`.

.. _`promote`:

Promote
    To move all children_ of a node_ in an outline so that they become siblings_ of the node.

.. _reStructuredText:
.. _rST:

reStructuredText (rST)
    A simple, yet powerful markup language for creating .html, or LaTeX output files.
    See the `rST primer`_.

.. _`root`:
.. _`root node`:

Root
    - The first node_ of a .leo file.
    - The first node of an `@root`_ tree or `@file`_ tree.

.. _`rst3 plugin`:

rST plugin
    A plugin_ that supports reStructuredText_.
    Unlike previous rst plugins, the rst3 plugin supports per-node options.

.. _`scope`:

Scope
    The portion of the outline_ in which a `section definition`_ is known.

.. _`section`:
.. _`sections`:

Section
    A fragment of text that can be incorporated into `external files`_.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section definition`:
.. _`section definitions`:

Section definition:
    The `body text`_ of a `section definition node`_.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section definition node`:
.. _`section definition nodes`:

Section definition node
    A node_ whose headline_ starts with a `section name`_ and whose body text defines a section_.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section name`:
.. _`section names`:

Section name
    A name enclosed in &lt;&lt; and &gt;&gt;.
    Section names may contain any characters except newlines and "&gt;&gt;".
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section reference`:
.. _`section references`:
.. _`reference`:
.. _`references`:
.. _`referenced`:

Section reference
    A `section name`_ appearing in a `code part`_.
    Tangling_ replaces all references by their definitions.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`sentinel`:
.. _`sentinels`:
.. _`sentinel lines`:

Sentinels, sentinel lines
    Comment lines in files derived from `@file nodes`_.
    Such lines start with an @ following the opening comment delimiter.
    Sentinels embed outline structure into `external files`_.
    **Do not alter sentinel lines**.  Doing so can corrupt the outline structure.
    For more information see `Sentinel lines`_ in `Leo's tutorial`_.

.. _`@settings`:
.. _`setting`:
.. _`settings`:

Setting:
    Plugins_ and other parts of Leo can get options from @settings trees,
    outlines_ whose headline_ is @settings. When opening a .leo file, Leo looks
    for @settings trees in the outline being opened and also in various
    leoSettings.leo files. @settings trees allow plugins_ to get options without
    any further support from Leo's core code. For a full discussion of
    @settings trees, see `Chapter 8: Customizing Leo`_.

.. _`sibling`:
.. _`siblings`:

Sibling
    Two nodes_ are siblings if they have the same parent_.  Siblings of the root_ have no parent.

.. _`tangle`:
.. _`tangles`:
.. _`tangling`:

Tangling
    The process of creating `external files`_ from `@root trees`_ or `@file trees`_.
    Leo tangles `@file trees`_ automatically when writing a .leo file.
    You must explicitly tangle_ `@root trees`_ using the Tangle command.
    Tangling expands all `section references` in an `@root node`_ or `@file node`_.
    For more information, see `Tangling @root trees`_ in Leo's `programming reference`_.

.. _`target language`:

Target language
    The language used to syntax color text.
    This determines the default comment delimiters used during tangling_ and untangling_.

.. _`tree`:
.. _`trees`:

Tree
    An outline_.
    A node_ and its descendants_.

.. _`untangle`:
.. _`untangles`:
.. _`untangling`:

Untangling
    Updating an outline_ based on changes to `external files`_.
    Untangling allows changes to be propagated from external files back to the outline.
    Especially useful when fixing syntax errors outside Leo.
    For more information, see `Untangling @root trees`_ in Leo's `programming reference`_.

.. _`weave`:
.. _`weaves`:
.. _`weaving`:

.. _`view node`:
.. _`view nodes`:

View node
    A `node`_ that represents a view of an `outline`_.
    View nodes are typically ordinary, non-`cloned`_ nodes that contain cloned `descendant`_ nodes.
    The cloned descendant nodes comprise most of the data of the view.
    Other non-cloned nodes may add additional information to the view.
    See `clones &amp; views`_ in the `Leo's tutorial`_ for more information.

Weaving
    The process of creating typeset documentation from a noweb_ or CWEB_ source file.
    Weaving creates documentation. Tangling_ creates `external files`_.
    Leo does not support weaving directly.
    To weave a file you can create noweb_ or CWEB_ files using Leo's Export commands,
    then use the noweb_ or CWEB_ systems to weave those files.</t>
<t tx="ekr.20050901084134">@language rest</t>
<t tx="ekr.20050901092232">##########################
Chapter 11: White Papers
##########################

..  I wrote the first two white papers soon after discovering Python.
..  The conclusions in these papers have remained largely unchanged.
..  I wrote the third in November 2004, and rewrote it in February 2006.

I wrote this white paper soon after discovering Python in 2001.
The conclusions are still valid today.

.. .. contents::
</t>
<t tx="ekr.20050901092232.1">.. External links...
.. _pychecker:              http://pychecker.sourceforge.net/
.. _`region inference`:     http://en.wikipedia.org/wiki/Region_inference

.. Relative links...
.. _chapter10:              theory.html
.. _appendices:             appendices.html
.. _`Rst3 plugin`:          rstplugin3.html
.. _`Scripting plugin`:     plugins.html#mod-scripting
.. _`test buttons`:         scripting.html#test-and-suite-nodes
</t>
<t tx="ekr.20050901092232.2">What struck me first as I converted C++ code to Python is how much less blah,
blah, blah there is in Python. No braces, no stupid semicolons and most
importantly, *no declarations*. No more pointless distinctions between
const, char \*, char const \*, char \* and wxString.
No more wondering whether a variable should be signed, unsigned, short or long.

Declarations add clutter, declarations are never obviously right and
declarations don't prevent memory allocation tragedies. Declarations also hinder
prototyping. In C++, if I change the type of something I must change all related
declarations; this can be a huge and dangerous task. With Python, I can change
the type of an object without changing the code at all! It's no accident that
Leo's new log pane was created first in Python.

Functions returning tuples are a "minor" feature with a huge impact on code
clarity. No more passing pointers to data, no more defining (and allocating and
deallocating) temporary structs to hold multiple values.

Python can't check declarations because there aren't any. However, there is a
really nifty tool called Pychecker that does many of the checks typically done
by compilers. See `pychecker`_ for details.</t>
<t tx="ekr.20050901092232.3">Python is much more powerful than C++, not because Python has more features, but
because Python needs *less* features. Some examples:

-   Python does everything that the C++ Standard Template Library (STL) does,
    without any of the blah, blah, blah needed by STL.
    No fuss, no muss, no code bloat.

-   Python's slicing mechanism is very powerful and applies to any sequence (string, list or tuple).
    Python's string library does more with far less functions because slices replace many functions
    typically found in other string libraries.

-   Writing dict = {} creates a dictionary (hash table).
    Hash tables can contain anything, including lists and other hash tables.

-   Python's special functions,  __init__, __del__, __repr__, __cmp__, etc.
    are an elegant way to handle any special need that might arise.</t>
<t tx="ekr.20050901092232.4">Before using Python I never fully realized how difficult and dangerous memory allocation is in C++.
Try doing::

        aList[i:j] = list(aString)

in C.  You will write about 20 lines of C code.
Any error in this code will create a memory allocation crash or leak.

Python is fundamentally safe. C++ is fundamentally unsafe. When I am using
Python I am free from worry and anxiety. When I am using C++ I must be
constantly "on guard." A momentary lapse can create a hard-to-find pointer bug.
With Python, almost nothing serious can ever go wrong, so I can work late at
night, or after a beer. The Python debugger is always available. If an exception
occurs, the debugger/interpreter tells me just what went wrong. I don't have to
plan a debugging strategy! Finally, Python recovers from exceptions, so Leo can
keep right on going even after a crash!</t>
<t tx="ekr.20050901092232.5">Python has almost all the speed of C. Other interpretive environments such as
icon and Smalltalk have clarity, power and safety similar to Python. What makes
Python unique is its seamless way of making C code look like Python code.
Python executes at essentially the speed of C code because most Python modules
are written in C. The overhead in calling such modules is negligible. Moreover,
if code is too slow, one can always create a C module to do the job.

In fact, Python encourages optimization by moving to higher levels of
expression. For example, Leo's Open command reads an XML file. If this command
is too slow I can use Python's XML parser module. This will speed up Leo while
at the same time raising the level of the code.</t>
<t tx="ekr.20050901092232.6">Little of Python is completely new. What stands out is the superb engineering
judgment evident in Python's design. Python is extremely powerful, yet small,
simple and elegant. Python allows me to express my intentions clearly and at the
highest possible level.

The only hope of making Leo all it can be is to use the best possible tools. I
believe Python (possibly with Tkinter) will allow me to add, at long last, the
new features that Leo should have.

Edward K. Ream, October 25, 2001.  P.S., September, 2005:

Four years of experience have only added to my admiration for Python. Leo could
not possibly be what it is today without Python.</t>
<t tx="ekr.20050901101608">##########################################
Chapter 3: Using Outlines
##########################################

This chapter tells how to use Leo's outlines.  Most of the commands can be invoked by clicking with the pointer in the outline pane or by using the pointer to select the command from the ``Outline`` menu.  The key bindings mentioned here are those of the default EKR bindings.

.. .. contents::</t>
<t tx="ekr.20050901101608.1">.. _`Chapter 2\: A Tutorial Introduction to Leo`:   intro.html
.. _`Chapter 4\: Writing Programs in Leo`:          directives.html
.. _`Clones and views`:                             intro.html#clones-views
</t>
<t tx="ekr.20050901101608.2">##########################################
Chapter 5: Using Leo's Commands
##########################################

This chapter discusses all of Leo's menu commands.
It starts with a discussion of the Emacs-like minibuffer,
then continues with a discussion of commands in each of Leo's menus.

.. .. contents::</t>
<t tx="ekr.20050901101608.3">##########################################
Chapter 6: Leo and Literate Programming
##########################################

This chapter discusses Leo's relationship with traditional `literate programming`_.

.. .. contents::</t>
<t tx="ekr.20050901101608.4">#############################################
Chapter 8: Customizing Leo
#############################################

This chapter discusses how to customize Leo using the plugins and other means.
See `Specifying settings`_ for a description of how to change Leo's settings.

.. .. contents::</t>
<t tx="ekr.20050901101608.5">##########################################
Chapter 9: History of Leo
##########################################

This chapter discusses the history of Leo and tells the essential features of each version.
Here are the most important dates in Leo's history:

.. .. contents::</t>
<t tx="ekr.20050901101608.6">##########################################
Chapter 10: Theory of Operation
##########################################

This chapter discusses how Leo's code works,
paying particular attention to topics that have caused difficulties in design or implementation.
This chapter will be of use primarily to those wanting to change Leo's code.

.. .. contents::</t>
<t tx="ekr.20050901101852">.. External links...
.. _CWEB:       http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _noweb:      http://www.eecs.harvard.edu/~nr/noweb/

.. Relative links...
.. _`Chapter 4\: Writing Programs in Leo`:              directives.html
.. _`Chapter 6\: Leo and Literate Programming`:         design.html
.. _`Chapter 8: Customizing Leo`:                       customizing.html
.. _`Clones and views`:                                 intro.html#clones-views
.. _`Creating script buttons`:                          scripting.html#creating-script-buttons
.. _`Tangling @root trees with the Tangle commands`:    directives.html#tangling-root-trees-with-the-tangle-commands
</t>
<t tx="ekr.20050901101949">.. Relative links...
.. _`Chapter 5\: Using Leo's Commands`:             commands.html
.. _`Chapter 7\: Scripting Leo with Python`:        scripting.html
.. _`Clones &amp; views`:                               intro.html#clones-views
.. _`Organizer nodes`:                              intro.html#good-style-and-bad-sections-vs-others

.. _`@file trees`:          glossary.html#file-trees
.. _`@root node`:           glossary.html#root-node
.. _child:                  glossary.html#child
.. _clones:                 glossary.html#clones
.. _commands:               `Chapter 5\: Using Leo's Commands`_
.. _cweb:                   glossary.html#cweb
.. _`literate programming`: glossary.html#literate-programming
.. _node:                   glossary.html#node
.. _outline:                glossary.html#outline
.. _outlines:               glossary.html#outlines
.. _`reference`:            glossary.html#reference
.. _`referenced`:           glossary.html#referenced
.. _reStructuredText:       glossary.html#restructuredtext
.. _`rst3 plugin`:          glossary.html#rst3-plugin
.. _section:                glossary.html#section
.. _sections:               glossary.html#sections
.. _`section name`:         glossary.html#section-name
.. _`section names`:        glossary.html#section-names
.. _`section reference`:    glossary.html#section-reference
.. _`section references`:   glossary.html#section-references
.. _tangling:               glossary.html#tangling
.. _tree:                   glossary.html#tree
.. _untangling:             glossary.html#untangling
</t>
<t tx="ekr.20050901102055">.. _`Chapter 7\: Scripting Leo with Python`:    scripting.html
.. _`Chapter 9\: History of Leo`:               history.html
.. _`rst3 plugin`:                              glossary.html#rst3-plugin
.. _`Specifying settings`:                      commands.html#specifying-settings
</t>
<t tx="ekr.20050901102147">.. Relative links...
.. _`Chapter 7\: Scripting Leo with Python`:    scripting.html
.. _`Chapter 8\: Customizing Leo`:              customizing.html
.. _`Chapter 10\: Theory of Operation`:         theory.html
.. _`Chapter 15\: Controlling Syntax Coloring`:     coloring.html
.. _`Chapter 16\: Debugging with Leo`:              debuggers.html
.. _`Chapter 17\: Using ZODB with Leo`:             zodb.html
.. _`Chapter 18\: Leo and Emacs`:                   emacs.html
.. _`Chapter 19\: Embedding Leo with the leoBridge Module`: leoBridge.html
.. _`Chapter 20\: Unit testing with Leo`:           unitTesting.html
.. _`Chapter 21\: ILeo - the IPython bridge`:       IPythonBridge.html

.. Absolute links..
.. _OPML:   http://en.wikipedia.org/wiki/OPML
</t>
<t tx="ekr.20050901102300">.. _`Chapter 9\: History of Leo`:   history.html
.. _`Chapter 11\: White Papers`:    whitepapers.html
</t>
<t tx="ekr.20050901110110">.. Links used in this document...
.. _`Pmw`:                  http://pmw.sourceforge.net/
.. _run:                    `Running Leo`_
.. _`run Leo`:              `Running Leo`_
.. _`Leo's download page`:  http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106
.. _`Leo's help forum`:         http://groups.google.com/group/leo-editor-users

.. .. _`associating leo with .leo files`:   `How to associate Leo with .leo files on Windows`_
.. .. _`associated .leo files with Leo`:   `How to associate Leo with .leo files on Windows`_
</t>
<t tx="ekr.20050901121617">@color

# Puts each sentence on a separate line
# Not as useful as I had hoped.  The Reformat Paragraph command is better.

@others

splitSentences(c,p)</t>
<t tx="ekr.20050901121617.1">def splitSentences(c,p):
    
    undoType = 'Split Sentences'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    s = p.bodyString()
    if not s.strip(): return
    
    i = 0 ; line = [] ; result = [] ; nl = False
    while i &lt; len(s):
        ch = s[i] ; i += 1 ; ch2 = '.'
        if i &lt; len(s): ch2 = s[i]
        if ch in ('.',';') and ch2 in (' ','\t','\n'):
            line.append(ch)
            r = ''.join(line)+'\n'
            if nl and ch == '.': r = r + '\n'
            result.append(r)
            line = [] ; nl = False
            while i &lt; len(s):
                ch2 = s[i]
                if ch2 == '\n' and ch == '.':
                    nl = True
                if ch2 in (' ','\t','\n'):
                    i += 1
                else:
                    break
        else: line.append(ch)

    result.append(''.join(line)+'\n') # Add the last line.
    result = ''.join(result)
    c.updateBodyPane('',result,'',undoType,oldSel,oldYview)</t>
<t tx="ekr.20050901174937">You can run Leo from a Python interpreter as follows::

    import leo
    leo.run() # runs Leo, opening a new outline or,
    leo.run(fileName=aFileName) # runs Leo, opening the given file name.

Another way to run Leo is as follows::

    cd &lt;path-to-launchLeo.py&gt;
    python launchLeo.py %1

Here are some tips that may make running Leo easier:

**Linux**
    The following shell script will allow you to open foo.leo files by typing leo foo::

        #!/bin/sh 
        python &lt;leopath&gt;launchLeo.py $1

    where &lt;leopath&gt; is the path to the directory containing the leo directory. 

**Windows**
    If you have associated .leo files with Leo you may run Leo by double-clicking any .leo file.
    You can also use a batch file.
    Put the following .bat file in c:\\Windows::

        cd &lt;path-to-leo&gt;
        c:\\Python26\\python &lt;path-to-leo&gt;launchLeo.py %1

    where &lt;path-to-leo&gt; is the path to the directory *containing* the leo directory.

    This opens the file specified by the first argument (%1).

The first time you start Leo, a dialog will ask you for a unique identifier. If
you are using cvs, use your cvs login name. Otherwise your initials will do. Leo
stores this identifier in the file .leoID.txt. Leo attempts to create
leoID.txt in the .leo sub-directory of your home directory, then in Leo's config directory, and
finally in Leo's core directory. You can change this identifier at any time by
editing .leoID.txt.</t>
<t tx="ekr.20050902073404">Scripts must wary of saving positions because positions become invalid
whenever the user moves, inserts or deletes nodes.  It is valid to store
positions **only** when a script knows that the stored position will be used
before the outline's stucture changes.

To store a postion, the script must use the p.copy() method::

    p2 = p.copy()   # Correct: p2 will not change when p changes later.

The following **will not work**::

    p2 = p  # Wrong.  p2 will change if p changes later.

For example, the following creates a dictionary of saved positions::

    d = {}
    for p in c.all_positions():
        d[p.v] = p.copy()
        
</t>
<t tx="ekr.20050902080416"># Start at the top.
b = c.frame.body.bodyCtrl
b.mark_set('insert','1.0')
b.tag_remove('sel','1.0','end')
b.tag_add('sel','1.0','1.0')
b.update_idletasks()

# Format until the end.
count = 0 # Guard against loops.
while count &lt; 100:
    count += 1
    s = p.bodyString()
    if not s.strip():
        break
    c.reformatParagraph()
    s2 = p.bodyString()
    
    index = b.index('insert')
    if b.compare(index,'&gt;=','end-1c'):
        break</t>
<t tx="ekr.20050902100834">This following information may be of interest to historians. It is not of
general enough interest to put in Leo's Users Guide on the web. I am including
this mass of detail here to indicate the complexities that were involved in
designing Leo's simple-looking mechanisms.</t>
<t tx="ekr.20050902105852">Leo grew out of my efforts to use Donald Knuth's "CWEB system of Structured
documentation." I had known of literate programming since the mid 1980's, but I
never understood how to make it work for me. In November 1995 I started thinking
about literate programming in earnest. Over the holidays I mused about making
literate programs more understandable. In January 1996 the fog of confusion
suddenly cleared. I summarized my thinking with the phrase, **web are outlines
in disguise**. I suspected that outline views were the key to literate
programming, but many details remained obscure.
</t>
<t tx="ekr.20050902105852.1">March 5, 1996, is the most important date in Leo's history. While returning from
a day of skiing, I discussed my thoughts with Rebecca. During that conversation
I realized that I could use the MORE outliner as a prototype for a "literate
outliner." I immediately started work on my first literate outline. It quickly
became apparent that outlines work: all my old problems with literate
programming vanished. The @others directive dates from this day. I realized
that MORE's outlines could form the basis for Leo's screen design. Rather
than opening body text within the outline, as MORE does, I decided to use a
separate body pane.

I hacked a translator called M2C which allowed me to use MORE to write
real code. I would write code in MORE, copy the text to the clipboard in
MORE format, then run M2C, which would tangle the outline into C code.
This process was useful, if clumsy. I called the language used in the outline
SWEB, for simplified CWEB. Much later Leo started supporting the noweb
language.</t>
<t tx="ekr.20050902105852.10">Leo first used gnx's (global node indices) as a foolproof way of associating
nodes in .leo files with nodes in external files. At the time, there was
still intense discussions about protecting the logical consistency of
outlines. @thin was later to solve all those problems, but nobody knew
that then.
</t>
<t tx="ekr.20050902105852.11">Leo 4.2 Final went out the door September 20, 2004.
This surely is one of the most significant dates in Leo's history:

-   This marked the end worries about consistency of outlines and external files:
    Leo recreates all essential information from thin external files,
    so *there is nothing left in the .leo file to get out of synch*.

- Thin external files use gnx's extensively. This simplifies the file format and
    makes thin external files more cvs friendly.

-   A sensational scripting plugin showed how to create script buttons.
    This has lead to improvements in the Execute Script command and
    other significant improvements in Unit testing.

-   As if this were not enough, 4.2 marked the 'great divide' in Leo's internal
    data structures. Before 4.2, Leo every node in the outline had its own
    vnode. This was a big performance problem: clone operations had to
    traverse the entire outline! 4.2 represents clones by sharing subtrees.
    Changing Leo's fundamental data structures while retaining compatibility
    with old scripts was engineering work of which the entire Leo community can
    be proud. `Chapter 7: Scripting Leo with Python`_ tells how the position
    class makes this happen.
    This was a cooperative effort. Kent Tenney and Bernhard Mulder made
    absolutely crucial contributions. Kent pointed out that it is a tnode,
    not a vnode that must form the root of the shared data. Bernhard showed
    that iterators are the way to avoid creating huge numbers of positions.

Leo 4.2 marked so many significant changes. I often find it hard to remember
what life with Leo was like before it.</t>
<t tx="ekr.20050902105852.12">Leo 4.3 corrected many problems with leoConfig.txt. Instead, Leo gets
settings from one or more leoSettings.leo files. This version also
introduced a way to changed settings using a settings dialog.  However,
the settings dialog proved not to be useful (worse, it inhibited design) and
the settings dialog was retired in Leo 4.4.</t>
<t tx="ekr.20050902105852.2">Throughout 1996 I created a version of Leo on the Macintosh in plain C and the
native Mac Toolbox. This was a poor choice; I wasted a huge amount of time
programming with these primitive tools. However, this effort convinced me that
Leo was a great way to program.

Late in 1997 I wrote a Print command to typeset an outline. Printing (Weaving)
is supposedly a key feature of literate programming. Imagine my surprise when I
realized that such a "beautiful" program listing was almost unintelligible; all
the structure inherent in the outline was lost! I saw clearly that typesetting,
no matter how well done, is no substitute for explicit structure.

In 1998 I created a version of Leo using Apple's YellowBox environment. Alas,
Apple broke its promises to Apple developers. I had to start again.</t>
<t tx="ekr.20050902105852.3">I rewrote Leo for Borland C++ starting in May 1999. Borland C++ was much better
than CodeWarrior C, but it was still C++. This version of Leo was the first
version to use xml as the format of .leo files. The last version of Borland Leo,
3.12 Final went out the door July 17, 2003.</t>
<t tx="ekr.20050902105852.4">I attended the Python conference in early 2001. In May of 2000 I began work on
an wxWindows version of Leo. This did not work out, but something good did come
from this effort. I spent a lot of time adding Python scripting to the wxWindows
code and I became familiar with Python and its internals.

I really started to 'get' Python in September 2001. I wrote the white papers at
about this time. Python solved *all* my programming problems. I rewrote Leo in
Python in about two months! For the first time in my career I was no longer
anxious while programming; it simply isn't possible to create bad bugs in
Python. The Python version of Leo was the first officially OpenSoftware version of
Leo. The first functional version of Leo in Python was 0.05 alpha, December 17,
2001.</t>
<t tx="ekr.20050902105852.5">I registered the Leo project on SourceForge on March 10, 2003. It is certainly
no accident that Leo started a new life shortly thereafter. Prior to SourceForge
my interest in Leo had been waning.</t>
<t tx="ekr.20050902105852.6">In the summer of 2001 I began to consider using sentinel lines in external files.
Previously I had thought that outline structure must be 'protected' by remaining
inside .leo files. Accepting the possibility that sentinels might be corrupted
opened vast new design possibilities. In retrospect, problems with sentinel
almost never happen, but that wasn't obvious at the time! The result of this
design was known at first as Leo2. That terminology is extinct. I think of
this version as the first version to support @file and automatic tangling
and untangling.</t>
<t tx="ekr.20050902105852.7">The biggest surprise in Leo's history was the realization it is **much** easier
to untangle files derived from @file. Indeed, @root creates all sorts of
problems that just disappear when using @file. The new Python version of Leo
became fully operational in early 2002. It was probably about this time that I chose
noweb as Leo's preferred markup language. My decision not to support noweb's
escape sequences made Leo's read code much more robust.
</t>
<t tx="ekr.20050902105852.8">I spent 2002 taking advantages of Python's tremendous power and safety.
Many improvements were at last easy enough to do:

- Nested @others directives appeared in 3.2.
- Unicode support started in 3.3.
- @first and @last appeared in 3.7
- @asis and @nosent appeared in 3.8.
- Incremental syntax coloring and incremental undo appeared in 3.9.
- Paul Paterson created Leo's plugin architecture sometime during this period.
  Plugins have been a driving force in Leo's development because people can
  change how Leo works without altering Leo's core.
- 3.12 fixed a huge memory leak.
- 3.12 Final, the last 3.x version, appeared July 17, 2003.
</t>
<t tx="ekr.20050902105852.9">In late 2002 and throughout 2003 I worked on an entirely new file format.
4.0 final went out the door October 17, 2003 after almost a year intense
design work trying to improve error recovery scheme used while reading
external files. In the summer of 2003 I realized that orphan and @ignore'd
nodes must be prohibited in @file trees. With this restriction, Leo
could finally recreate @file trees in outlines using **only** the
information in external files. This made the read code much more robust, and
eliminated all the previous unworkable error recovery schemes. At last Leo
was on a completely firm foundation.
</t>
<t tx="ekr.20050902160924">**Important**: Script buttons are easier to use than the script-oriented
find/change commands described next. I recommend using script buttons whenever
possible. See `Creating script buttons`_.
You are not likely to need all the firepower that script-orient find/change commands,
but it could save you lots of time for complex jobs.

Leo's find panel contains the Script Search radio button and the Script
Change checkbox. When the Script Search radio button is selected Leo treats the
contents of the Search Text as a script to execute whenever any kind of Find
command is executed. Similarly, when the Script Change checkbox is selected Leo
treats the context of the Change Text as a script to execute whenever any kind
of Change command is executed.

Script-based find-change turns Leo's Find/Change panel into a platform for
running scripts interactively. The script writer need not write code to control
interactive searches.

Here's how it works. Leo dedicates g.app.searchDict for
communication between Leo and the search and change scripts. The search and
change scripts may also use g.app.searchDict for communication between themselves.
Leo sets g.app.searchDict["type"] to "find", "change", "findAll" or "changeAll" to
indicate the kind of command being executed. Scripts may use all other entries
in g.app.searchDict as they please.

Here is what Leo does when the user presses buttons with Script Search enable:

Find and Change, then Find buttons
    Leo executes the find script once. Typically, the find script would traverse
    the tree and highlight the found text or otherwise indicate to the user that
    the find operation has succeeded. However, the script can do anything it
    pleases.

Find All button
    Leo executes the find script repeatedly until g.app.searchDict["continue"] evaluates
    to False. Initially there is no entry for g.app.searchDict["continue"], so the
    find script must set g.app.searchDict["continue"] = True if it wants Leo call it again.

Change button
    Leo executes the change script once. Typically, the change script would change
    the selected text. Usually the change script will compute the new value of body
    text and call c.setBodyString(p,newText) to make that change permanent. 
    To handle undo, the change script can call
    c.frame.onBodyChanged(v,"Change",oldText=oldText).

Change All button
    Leo executes the change script repeatedly
    until g.app.searchDict["continue"] evaluates to false.

Most find and change scripts will ignore settings in the Find Panel like "whole
word", "pattern match", and "reverse". However, these settings are available to
the scripts via ivars such as c.whole_word_flag, etc. if desired.

The initScriptFind script in LeoPy.leo makes it easy to set up script based searches:

1. Put the following code in the root of a tree that will contain your script search::

    # Initialize Leo's find panel using the named children of this node.
    import leo.core.leoGlobals as g.
    g.initScriptFind("Find script","Change script") # Second argument is optional.
    # Start searching at the top.
    c.selectPosition(c.rootPosition())

2. Put the search script in a child node called "Find script" (no quotes).

3. (Optional) Put the change script in a child node called "Change script"

4.  Execute the code above.  Leo does the following:

- Puts the body of the "Find script" into the find text of Leo's Find/Change dialog.
- Puts the body of the "Change script" into the change text of Leo's Find/Change dialog.
- Selects the Script Find radio button.
- Selects the Script Change checkbox if the change script exists.
- Selects the root of the entire outline.

Presto! Leo is ready for a script search. **Note**: you could also consider creating a
script button to set up complex find/change scripts.

Here are some ideas for using script find/change.

-   Find and change scripts may use Python's re module.  For
    example, the find script could set g.app.searchDict["m"] to the match object
    returned by re's match method.  The change script would then compute the
    result, change the text and set the undo info as usual.

-   Find and change scripts may operate on data outside any Leo outline.
    For example, script-find scripts could traverse your file system.
    Scripts could even pull data from the file system
    into the outline so that you can see the effects of changes as the scripts
    operate.</t>
<t tx="ekr.20050903074833">Plugins and other scripts can register event handlers (also known as hooks) with code such as::

    leoPlugins.registerHandler("after-create-leo-frame",onCreate)
    leoPlugins.registerHandler("idle", on_idle) 
    leoPlugins.registerHandler(("start2","open2","command2"), create_open_with_menu) 

As shown above, a plugin may register one or more event handlers with a single call to
leoPlugins.registerHandler. Once a hook is registered, Leo will call the
registered function' at the named **hook time**. For example::

    leoPlugins.registerHandler("idle", on_idle)

causes Leo to call on_idle at "idle" time.

Event handlers must have the following signature::

    def myHook (tag, keywords):
        whatever

-   tag is the name of the hook (a string).
-   keywords is a Python dictionary containing additional information.
    The following section describes the contents of the keywords dictionary in detail.

**Important**: hooks should get the proper commander this way::

    c = keywords.get('c')</t>
<t tx="ekr.20050903074833.1">The following table tells about each event handler: its name, when it is called,
and the additional arguments passed to the hook in the keywords dictionary.
For some kind of hooks, Leo will skip its own normal processing if the hook
returns anything *other* than None. The table indicates such hooks with 'yes' in
the 'Stop?' column.

**Important**: Ever since Leo 4.2, the v, old_v and new_v keys in
the keyword dictionary contain *positions*, not vnodes. These keys are
deprecated. The new_c key is also deprecated. Plugins should use the c key instead.

============================= ======== =================================== =============================
Event name (tag argument)     Stop?    When called                         Keys in keywords dict
============================= ======== =================================== =============================
'after-auto'                           after each @auto file loaded        c,p (note 14)
'after-create-leo-frame'               after creating any frame            c
'after-redraw-outline'                 end of tree.redraw                  c (note 6)
'before-create-leo-frame'              before frame.finishCreate           c
'bodyclick1'                   yes     before normal click in body         c,p,v,event
'bodyclick2'                           after normal click in body          c,p,v,event
'bodydclick1'                  yes     before double click in body         c,p,v,event
'bodydclick2'                          after  double click in body         c,p,v,event
'bodykey1'                     yes     before body keystrokes              c,p,v,ch,oldSel,undoType
'bodykey2'                             after  body keystrokes              c,p,v,ch,oldSel,undoType
'bodyrclick1'                  yes     before right click in body          c,p,v,event
'bodyrclick2'                          after  right click in body          c,p,v,event
'boxclick1'                    yes     before click in +- box              c,p,v,event
'boxclick2'                            after  click in +- box              c,p,v,event
'clear-all-marks'                      after clear-all-marks command       c,p,v
'clear-mark'                           when mark is set                    c,p,v
'close-frame'                          in app.closeLeoWindow               c
'color-optional-markup'        yes *   (note 7)                            colorer,p,v,s,i,j,colortag (note 7)
'command1'                     yes     before each command                 c,p,v,label (note 2)
'command2'                             after  each command                 c,p,v,label (note 2)
'create-optional-menus'                (note 8)                            c (note 8)
'create-popup-menu-items'              in tree.OnPopup                     c,p,v,event (new)
'destroy-all-global-windows'           (note 12)                           None
'draw-outline-box'             yes     when drawing +- box                 tree,p,v,x,y
'draw-outline-icon'            yes     when drawing icon                   tree,p,v,x,y
'draw-outline-node'            yes     when drawing node                   tree,p,v,x,y
'draw-outline-text-box'        yes     when drawing headline               tree,p,v,x,y
'drag1'                        yes     before start of drag                c,p,v,event
'drag2'                                after  start of drag                c,p,v,event
'dragging1'                    yes     before continuing to drag           c,p,v,event
'dragging2'                            after  continuing to drag           c,p,v,event
'enable-popup-menu-items'              in tree.OnPopup                     c,p,v,event
'end1'                                 start of app.quit()                 None
'enddrag1'                     yes     before end of drag                  c,p,v,event
'enddrag2'                             after  end of drag                  c,p,v,event
'headclick1'                   yes     before normal click in headline     c,p,v,event
'headclick2'                           after  normal click in headline     c,p,v,event
'headrclick1'                  yes     before right click in headline      c,p,v,event
'headrclick2'                          after  right click in headline      c,p,v,event
'headkey1'                     yes     before headline keystrokes          c,p,v,ch (note 13)
'headkey2'                             after  headline keystrokes          c,p,v,ch (note 13)
'hoist-changed'                        whenever the hoist stack changes    c
'hypercclick1'                 yes     before control click in hyperlink   c,p,v,event
'hypercclick2'                         after  control click in hyperlink   c,p,v,event
'hyperenter1'                  yes     before entering hyperlink           c,p,v,event
'hyperenter2'                          after  entering hyperlink           c,p,v,event
'hyperleave1'                  yes     before leaving  hyperlink           c,p,v,event
'hyperleave2'                          after  leaving  hyperlink           c,p,v,event
'iconclick1'                   yes     before single click in icon box     c,p,v,event
'iconclick2'                           after  single click in icon box     c,p,v,event
'iconrclick1'                  yes     before right click in icon box      c,p,v,event
'iconrclick2'                          after  right click in icon box      c,p,v,event
'icondclick1'                  yes     before double click in icon box     c,p,v,event
'icondclick2'                          after  double click in icon box     c,p,v,event
'idle'                                 periodically (at idle time)         c
'init-color-markup'                    (note 7)                            colorer,p,v (note 7)
'menu1'                        yes     before creating menus               c,p,v (note 3)
'menu2'                        yes     during creating menus               c,p,v (note 3)
'menu-update'                  yes     before updating menus               c,p,v
'new'                                  start of New command                c,old_c,new_c (note 9)
'open1'                        yes     before opening any file             c,old_c,new_c,fileName (note 4)
'open2'                                after  opening any file             c,old_c,new_c,fileName (note 4)
'openwith1'                    yes     before Open With command            c,p,v,openType,arg,ext
'openwith2'                            after  Open With command            c,p,v,openType,arg,ext
'recentfiles1'                 yes     before Recent Files command         c,p,v,fileName,closeFlag
'recentfiles2'                         after  Recent Files command         c,p,v,fileName,closeFlag
'redraw-entire-outline'        yes     start of tree.redraw                c (note 6)
'save1'                        yes     before any Save command             c,p,v,fileName
'save2'                                after  any Save command             c,p,v,fileName
'scan-directives'                      in scanDirectives                   c,p,v,s,old_dict,dict,pluginsList (note 10)
'select1'                      yes     before selecting a position         c,new_p,old_p,new_v,new_v
'select2'                              after  selecting a position         c,new_p,old_p,new_v,old_v
'select3'                              after  selecting a position         c,new_p,old_p,new_v,old_v
'set-mark'                             when a mark is set                  c,p,v
'show-popup-menu'                      in tree.OnPopup                     c,p,v,event
'start1'                               after app.finishCreate()            None
'start2'                               after opening first Leo window      c,p,v,fileName
'unselect1'                    yes     before unselecting a vnode          c,new_p,old_p,new_v,old_v
'unselect2'                            after  unselecting a vnode          c,new_p,old_p,old_v,old_v
'\@url1'                        yes     before double-click @url node       c,p,v,url (note 5)
'\@url2'                                after  double-click @url node       c,p,v(note 5)
============================= ======== =================================== =============================

**Notes**:

1.  'activate' and 'deactivate' hooks have been removed because they do not work as expected.

2.  'commands' hooks: The label entry in the keywords dict contains the
    'canonicalized' form of the command, that is, the lowercase name of the command
    with all non-alphabetic characters removed.
    Commands hooks now set the label for undo and redo commands 'undo' and 'redo'
    rather than 'cantundo' and 'cantredo'.

3.  'menu1' hook: Setting g.app.realMenuNameDict in this hook is an easy way of
    translating menu names to other languages. **Note**: the 'new' names created this
    way affect only the actual spelling of the menu items, they do *not* affect how
    you specify shortcuts settings, nor do they affect the 'official'
    command names passed in g.app.commandName. For example::

        app().realMenuNameDict['Open...'] = 'Ouvre'.

4.  'open1' and 'open2' hooks: These are called with a keywords dict containing the following entries:

    - c:          The commander of the newly opened window.
    - old_c:      The commander of the previously open window.
    - new_c:      (deprecated: use 'c' instead) The commander of the newly opened window.
    - fileName:   The name of the file being opened.

    You can use old_c.p and c.p to get the current position in the old and new windows.
    Leo calls the 'open1' and 'open2' hooks only if the file is not already open. Leo
    will also call the 'open1' and 'open2' hooks if: a) a file is opened using the
    Recent Files menu and b) the file is not already open.

5.  '\@url1' and '\@url2' hooks are only executed if the 'icondclick1' hook returns None.

6.  These hooks are useful for testing.

7.  These hooks allow plugins to parse and handle markup within doc parts,
    comments and Python ''' strings. Note that these hooks are *not* called in
    Python ''' strings. See the color_markup plugin for a complete example of how to
    use these hooks.

8.  Leo calls the 'create-optional-menus' hook when creating menus. This hook need
    only create new menus in the correct order, without worrying about the placement
    of the menus in the menu bar. See the plugins_menu and scripts_menu plugins for
    examples of how to use this hook.

9.  The New command calls 'new'.
    The 'new_c' key is deprecated.  Use the 'c' key instead.

10. g.scanDirectives calls 'scan-directives' hook.
    g.scanDirectives returns a dictionary, say d.
    d.get('pluginsList') is an a list of tuples (d,v,s,k) where:

    - d is the spelling of the @directive, without the leading @.
    - v is the vnode containing the directive, _not_ the original vnode.
    - s[k:] is a string containing whatever follows the @directive.
      k has already been moved past any whitespace that follows the @directive.

    See the add_directives plugins directive for a complete example of how to use
    the 'scan-directives' hook.

11. g.app.closeLeoWindow calls the 'close-frame' hook just before
    removing the window from g.app.windowList. The hook code may remove the window
    from app.windowList to prevent g.app.closeLeoWindow from destroying the window.

12. g.app.destroyAllGlobalWindows calls the 'destroy-all-global-windows' hook.
    This hook gives plugins the chance to clean up after themselves when Leo shuts down.

13. Leo calls the 'headkey1' and 'headkey2' when the headline *might* have changed.

14. p is the new node (position) containing '@auto filename.ext'</t>
<t tx="ekr.20050903075144">A **plugin** is a Python file that appears in Leo's plugin directory. Plugins
modify how Leo works. With plugins you can give Leo new commands, modify how
existing commands work, or change any other aspect of Leo's look and feel.
leoPlugins.leo contains all of Leo's official plugins. Studying this file is
a good way to learn how to write plugins.

You **enable** plugins using @enabled-plugins nodes in leoSettings.leo or
myLeoSettings.leo. For more details, see the @enabled-plugins node in
leoSettings.leo. Leo imports all enabled plugins at startup time. Plugins become
**active** if importing the plugin was successful.

Writing plugins is quite similar to writing any other Leo script.  See
`Chapter 7\: Scripting Leo with Python`_. In particular:

1. Plugins can use any of Leo's source code simply by importing any module
   defined in leoPy.leo.

2. Plugins can register event handlers just like any other Leo script. For full
   details, see the section called `event handlers`_ in Leo's scripting chapter.

The rest of this chapters discusses topics related specifically to plugins.
</t>
<t tx="ekr.20050903161843">Creating a script button should be your first thought whenever you want to
automate any task. The scripting plugin, mod_scripting.py, puts two buttons
in the icon menu, a pink Run Script button and a yellow Script Button
button. The Run Script button does the same thing as the Execute Script
command. The Script Button button is the interesting one. It creates a
button, confusingly called a **script button** in the icon area. A script button
executes a script when you push it.

Suppose node N is selected. When you press the Script Button button a new
(pink) script button is created. The name of the new button is N's headline
text. The script associated with the new button is N's body text. Now whenever
you press the new button, N's script is executed on the **presently** selected
node. Script buttons are extraordinarily useful. In effect, each script button
defines an instant command! For example, sometimes my fingers get tired of
saving a file. I simply put Save in a node's headline and c.save() in
the body text. I hit the Script Button button and I get a new button called
Save that will save the outline when I press it.

Here's a more interesting example. The following script searches the present
node and its ancestors looking for an @rst node. When such a node is found the
script uses Leo's core c.rstCommands.processTree method to format it. I don't have
to select the actual \@rst node; I can select any of its children::

    for p in p.self_and_parents():
        if p.h.startswith('@rst '):
            c.rstCommands.processTree(p)
            break

**Notes**:

- The scripting plugin pre-defines the c, g and p symbols just as the Execute
  Script command does.

- By default a script button executes the **present** body text of the node that
  original created the script button. This is very handy: you can modify a
  script button's script at any time without having to recreate the script
  button.

- You can delete any script button by right-clicking on it.

- On startup, the scripting plugin scans the entire .leo file and creates a
  script button for every node whose headline starts with @button scriptName.
  **Warning**: this is indeed a security risk of the kind discussed later. This
  feature can be disabled by setting atButtonNodes = True at the start of
  mod_scripting.py.</t>
<t tx="ekr.20050906090012">Leo (and other programs) often send more detailed error messages to stderr,
the output stream that goes to the console window. In Linux and MacOS
environments, python programs normally execute with the console window visible.
On Windows, can run Leo with the console window visible by associating .leo
files with python.exe *not* pythonw.exe.
</t>
<t tx="ekr.20050906104918">Leo 4.3.2 beta 1                  September 10, 2005

To learn about Leo, see: http://webpages.charter.net/edreamleo/intro.html

The highlights of 4.3.2:
-----------------------

- Improved Leo's documentation:
    - A tutorial introduction to Leo:
      http://webpages.charter.net/edreamleo/intro.html
    - A 5-minute guide to programming with Leo:
      http://webpages.charter.net/edreamleo/intro.html#quick-start-for-programmers

- The new rst3 plugin creates .html and .tex files from reStructuredText
  embedded in Leo files. Any node of the source outline may contain options for
  the rst3 plugin, which makes this plugin much more useful and flexible than
  the previous rst plugins. All of Leo's documentation was created using this
  plugin from sources in LeoDocs.leo. For full documentation for rst3 see:
  http://webpages.charter.net/edreamleo/rstplugin3.html.

- The spellpyx (spell checking) plugin is now much easier to use.

- The vim and openWith plugins now use Python's subprocess module if it is present.
 
- Improved the Pretty Printing command.

- The usual assortment of bug fixes.</t>
<t tx="ekr.20050906104918.1">Here is a summary of the changes:

- General: All chapters created with rst3 plugin. This ensures a uniform look.
The source is in LeoDocs.leo. Removed all references to older versions of Leo,
except when discussing old file formats in the Appendices. Corrected all text so
it discusses present version.

- rst3 plugin itself: Correct bug that caused chapters to be formatted
differently when processing multiple @rst trees.

- rst3 button in LeoDocs.leo: The script first looks *up* the tree, looking for
an @rst node. If found, it processes just that tree. If not found, it processes
all @rst nodes *below* the originally selected node. The button is now much more
convenient to use.

- Preface: Shorter, no history. No longer a dead end.

- What People are Saying About Leo: No longer a dead end.

- FAQ: Reorganized, simplified, revised. Added entries for running Leo in a
console window and debugging docutils. Improved entry for using cvs.

- Chapter 1: Installation: Now the first chapter. Revised.

- Chapter 2: Tutorial: Completely rewritten. Like Python's tutorial, this
chapter contains everything a beginner needs to understand and use Leo. The
`Quickstart for programmers` section is the heart of this chapter. All terms
used have links either to their definition in the tutorial or in the Glossary.
Newbies should be able to digest this chapter easily. This chapter should make
Leo comprehensible to many more people.

- Chapter 3: Using Outlines: Revised per general remarks above.

- Chapter 4: Writing Programs in Leo. Completely rewritten. The old chapter was
an embarrassment. The new chapter is a reference guide, properly organized as
such. The introduction warns newbies away.

- Chapter 5: Using Leo's Commands. 'Minor' revisions and corrections create a
substantially better result.

- Chapter 6: Leo and literate programming: Reformatting helps. New words about
rST markup and other improvements over traditional LP.

- Chapter 7: Scripting Leo with Python: Rewritten, simplified, updated and
corrected. The sources in LeoDocs.leo are directly executable. rST sources use
literal blocks instead of code-blocks so that the sources are simplified.
(Important when executing examples). Properly discusses positions, including
'supremely important' section on copying positions.

- Chapter 8: Customizing Leo. Heavily revised. Discusses leoSettings.leo, not
leoConfig.txt. Security warnings are more reasonable. Section on script buttons.
Rewrote section on uA's (Adding extensible attributes to nodes and .leo files).

- Chapter 9: History of Leo. Rewritten. Much shorter and more useful. Discusses
the major milestones, concentrating on explaining the major differences between
versions. Gone are details of how discoveries came to be. They are in
LeoPostings.leo, which will be included in the distribution.

- Chapter 10: Theory of Operation. Largely rewritten. Discusses positions
properly. Omits discussion of how clones were implemented before 4.2.

- Chapter 11: White Papers. A new chapter. This is a slightly-edited version of
writing that had been buried in the appendices.

- Appendices. Heavily revised and reformatted. Rewrote sections on file formats.

- Glossary: A separate chapter. All terms have links to their definition. All
definitions are rST targets so other chapters may refer to them. Added several
new entries.</t>
<t tx="ekr.20050906104931.1"></t>
<t tx="ekr.20050906104931.15">http://sourceforge.net/forum/message.php?msg_id=3218558</t>
<t tx="ekr.20050906104931.38">The fix was to add an entry of 'unknown' state to state_dict. This fixes the
crash by brute force, but may not be strictly correct. However, this is pretty
much moot: we shall soon be moving to the new colorizer.</t>
<t tx="ekr.20050906104931.42">The code gets c = keywords.get('c') in several places.
The protection is to return if c is None.
This affects the following files: plugins_menu.py, pluginsTest.py, plugin_manager.py</t>
<t tx="ekr.20050906104931.43">http://sourceforge.net/forum/message.php?msg_id=3231597

test.leo had some non-@ignore'd @thin nodes for files not in the distribution.

- Only files used by unit tests should be on cvs and the distribution.
    - test\unittest\batchTest.py and test\unittest\errorTest.py were already on cvs.
    - Added these files to the distribution.

- Other test files should be distributed in @ignore nodes.

- Leo's distribution checklist now has an item to check that the distributed test.leo can be opened without errors.</t>
<t tx="ekr.20050906104931.48"></t>
<t tx="ekr.20050906104931.49">Calling print directly is dangerous: it will fail for unicode characters.</t>
<t tx="ekr.20050906104931.56">The new Pretty Print code has the following improvements:

- Strip trailing blanks in get.
- Many improvement to doOp.
- Improved DoMultiline:
    - Added special case logic to ensure '#' is preceded by space except at start of line.
    - Added blank after multi-line string if needed.
- Added lastName token for special-case handling depending on previous token.
- No change to put, putArray or doName.</t>
<t tx="ekr.20050907094633">Any .leo file may contain an @settings tree, so settings may be different for each commander.
Plugins and other scripts can get the value of settings as follows::

    format_headlines = c.config.getBool('rst3_format_headlines')
    print('format_headlines',format_headlines)

The c.config class has the following getters.
See the configSettings in leoCommands.py for details::

    c.config.getBool(settingName,default=None)
    c.config.getColor(settingName)
    c.config.getDirectory(settingName)
    c.config.getFloat(settingName)
    c.config.getInt(settingName)
    c.config.getLanguage(settingName)
    c.config.getRatio(settingName)
    c.config.getShortcut(settingName)
    c.config.getString(settingName)

These methods return None if no setting exists.
The getBool 'default' argument to getBool gives the value to be returned if the setting does not exist.

You can set any *existing* item in an @settings tree with c.config.set(p,setting,val).
For example::

    for val in (False,True):
        c.config.set(p,'rst3_format_headlines',val)
        format_headlines = c.config.getBool('rst3_format_headlines')
        print('format_headlines',format_headlines)

c.config.set does not change the @settings tree; it simply changes the values returned by the getters.</t>
<t tx="ekr.20050908113904">This is a known bug in Tk that prevents this on Windows. The obvious Tk code
causes a hard crash in the Python dll: it's the only time Leo has taken such a
hard crash. The UniversalScrolling plugin is an attempt at a workaround.

Scrolling with the mouse wheel may be possible on Linux. See the code in
createTkTreeCanvas in leoTkinterFrame.py
</t>
<t tx="ekr.20050908164150"></t>
<t tx="ekr.20050908164150.1">See http://webpages.charter.net/edreamleo/rstplugin3.html for full documentation
of this plugin.

The rst3 plugin creates output files from Leo outlines containing
reStructuredText (rST) ReStructuredText is a simple and powerful text formatting
markup language. Outlines are a natural way to organize rST (or any text).

This plugin adds the Write Restructured Text command to Leo's Edit menu. The
Write Restructured Text command searches the selected outline looking for rst
root nodes whose headline have the form @rst &lt;filename&gt;. The plugin then creates
the named file in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically relieves you from one of the most
tedious chores in creating rST markup.

To use this plugin effectively, Python's docutils module must be installed. The
rst3 plugin will use the SilverCity syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.</t>
<t tx="ekr.20050908164150.2">This plugin now allows quotes within words, but strips quotes and other cruft
from the beginning and end of words. As a result, using the spellpyx spell
checker is much easier than before.

Leo's extensions folder now contains aspell23.pyd and aspell24.pyd. These are
Python dll's compiled for Python 2.3 and 2.4 respectively. You must rename one
of these files to be aspell.pyd and move aspell.pyd to the aspell folder. For
more details, see the installation nodes in the docstring for the spellpyx
plugin.</t>
<t tx="ekr.20050909082711">- Fixed bug with non-unicode characters in file name

    http://sourceforge.net/forum/message.php?msg_id=3224635
    
    Leo crashed try to read .leo files whose name contained non-ascii characters.

- Fixed bug with non-unicode characters in settings value

    http://sourceforge.net/forum/message.php?msg_id=3222750
    
    Leo crashed try to write settings whose values contained non-ascii characters.

- Fixed bug tangling sections with non-unicode characters.

    http://sourceforge.net/forum/message.php?msg_id=3307318</t>
<t tx="ekr.20050910143326">These plugins now use Python's subprocess module if it is present. The
subprocess module comes standard with Python 2.4. For Linux systems, Leo will
use subprocess.py in Leo's extensions folder if necessary.

For Windows systems you can install Python's subprocess module in Python 2.2 or
2.3 as follows:
    
    - Go to http://www.effbot.org/downloads/#subprocess

    - Download and execute one of the following installers, depending on your version of Python:
        subprocess-0.1-20041012.win32-py2.3.exe 
        subprocess-0.1-20041012.win32-py2.2.exe
        
This installer installs the subprocess sources and also _subprocess.pyd in Python's site-packages folder.
</t>
<t tx="ekr.20050912125144">@language rest</t>
<t tx="ekr.20050912125144.1">##########################
Chapter 12: Plugins
##########################

This chapter discusses the plugins contained in leoPlugins.leo.
These plugins are part of Leo's official distribution.
`Chapter 13: Writing Plugins`_ tells how to write plugins.

The scripting plugin (mod_scripting.py) deserves special mention. This
plugin lets you create **script buttons** in a matter of seconds. See `Creating
script buttons`_. Script buttons are extraordinarily useful. Try them, you'll be
instantly hooked.

.. .. contents::
</t>
<t tx="ekr.20050912125735">.. External links...
.. _docutils:             http://docutils.sourceforge.net
.. _LaTeX:                http://www.latex-project.org/
.. _reStructuredText:     http://docutils.sourceforge.net/rst.html
.. _SilverCity:           http://silvercity.sourceforge.net

.. Relative links...
.. _`Specifying settings`:              customizing.html#specifying-settings
.. _`Chapter 8\: Customizing Leo`:      customizing.html
.. _`Chapter 13\: Writing Plugins`:     writingPlugins.html
.. _`Creating script buttons`:          scripting.html#creating-script-buttons
</t>
<t tx="ekr.20050912125735.1008">Automatically add nodes for common tasks.</t>
<t tx="ekr.20050912125735.1041">Add Hoist/De-Hoist buttons to the toolbar.
</t>
<t tx="ekr.20050912125735.1050">Adds "Recent" and "Marks" pulldown buttons to the toolbar.</t>
<t tx="ekr.20050912125735.1072">Adds a quick search to Leo's toolbar, along with a "GO" button to do quick
searches right from the main Leo window. All the current search options are
retained except that "search body text" is explicitly set - mainly because this
is by far the most common use case. Pressing &lt;CR&gt; while editing the text
automatically does a search. Repeated searches can be done by clicking the "GO"
button. The combo box also stores a list of previous searches, which can be
selected to quickly repeat a search. When activating a previous search the
original search mode is used.
</t>
<t tx="ekr.20050912125735.1092">This plugin supports Uniform Node Locators (UNL's). UNL's specify nodes within
Leo files. UNL's are not limited to nodes within the present Leo file; you can
use them to create cross-Leo-file links. This plugin consists of two parts:

1) Selecting a node shows the UNL in the status line at the bottom of the Leo
   window. You can copy from the status line and paste it into headlines, emails,
   whatever. 

2) Double-clicking @url nodes containing UNL's select the node specified in the
   UNL. If the UNL species in another Leo file, the other file will be opened.

UNL's referring to nodes within the present outline have the form::

    headline1--&gt;headline2--&gt;...--&gt;headlineN

where headline1 is the headline of a top-level node, and each successive headline is
the headline of a child node.  UNL's of the form::

    file:&lt;path&gt;#headline1--&gt;...--&gt;headlineN

refer to a node specified in &lt;path&gt; For example, double clicking the following
headline will take you to Chapter 8 of Leo's Users Guide::

    @url file:c:/prog/leoCvs/leo/doc/leoDocs.leo#Users Guide--&gt;Chapter 8: Customizing Leo

For example, suppose you want to email someone with comments about a Leo file.
Create a comments.leo file containing @url UNL nodes. That is, headlines are
@url followed by a UNL. The body text contains your comments about the nodes in
the _other_ Leo file! Send the comments.leo to your friend, who can use the
comments.leo file to quickly navigate to the various nodes you are talking
about. As another example, you can copy UNL's into emails. The recipient can
navigate to the nodes 'by hand' by following the arrows in the UNL.

**Notes**:

- At present, UNL's refer to nodes by their position in the outline. Moving a
  node will break the link.

- Don't refer to nodes that contain UNL's in the headline. Instead, refer to the
  parent or child of such nodes.

- You don't have to replace spaces in URL's or UNL's by '%20'.</t>
<t tx="ekr.20050912125735.1105"></t>
<t tx="ekr.20050912125735.113">Leo plugin that permits the definition of actions for double-clicking on file
nodes. Double-clicking in a @file node writes out the file if changes have
been made since the last save, and then runs a script on it, which is retrieved
from the outline. Scripts are located in a node whose headline is FileActions.
This node can be anywhere in the outline. If there is more than one such node,
the first one in outline order is used. The children of that node are expected
to contain a file pattern in the headline and the script to be executed in the
body. The file name is matched against the patterns (which are Unix-style shell
patterns), and the first matching node is selected. If the filename is a path,
only the last item is matched. Execution of the scripts is similar to the
Execute Script command in Leo. The main difference is that the namespace in
which the scripts are run contains two elements:

-   filename, which contains the filename from the @file directive.

-   shellScriptInWindow, a utility function that runs
    a shell script in an external windows, thus permitting
    programs to be called that require user interaction

File actions are implemented for @file nodes and all its variants
(@file-nosent, @thin, etc.). There is also a new node type
@file-ref for referring to files purely for the purpose of
file actions, Leo does not do anything with or to such files.</t>
<t tx="ekr.20050912125735.1135" annotate="580c0100003764373130303238353530383730373236393666373236393734373937313031323836333631366536653666373436313734363530613534366235303639363336623663363535363631373230613731303236663731303334643066323736323535303436653666363436353731303532383638303236663731303635353034363636393663363537313037363235353032363236373731303832383638303236663731303935353030373130613632353530393631373236333638363537343739373036353731306232383638303236663731306335353035346637343638363537323731306436323535303236363637373130653238363830323666373130663638306136323735326571002e">Cleo allows you to annotate or colour leo outlines based on priority, code
archetype, node types or some arbitrary criteria. The annotations and colour
coding can play a similar role like that of syntax highlighting. Right-click on
the icon area to popup its menu to play with it.</t>
<t tx="ekr.20050912125735.1187">A plugin to leave footprints! This colors the Leo nodes so that the ones you
have visited most and most recently will stand out.</t>
<t tx="ekr.20050912125735.1285">A plugin that lets the user to associate text with a specific node.
Summon it by pressing button-2 or button-3 on an icon Box in the outline. This
will create an attribute editor where the user can add, remove and edit
attributes. Since attributes use the underlying tnode, clones will share the
attributes of one another.</t>
<t tx="ekr.20050912125735.129">A Leo Plugin that adds Group commands functionality.  Restrictions currently apply to using Leo with a Tk front end.
There are several commands in this plugin:

-   Mark Node: marks a node for further operations such as copying, cloning and moving.

-   Mark Spot: marks a node as the place where group operations are to target.

-   Operate On Marked: moves lassoed nodes to the spot where the roundup node is
    placed. Clones are maintained.

-   Clear Marked: unmarks all marked nodes and removes the roundup node.

-   Transfer Lassoed Nodes: this is a menu for inter-window communication.
    The windows must all be spawned from the same Leo instance. 
    It allows the user to move all node marked for copying and moving from another window to this one.</t>
<t tx="ekr.20050912125735.1299">Maximizes all new windows.</t>
<t tx="ekr.20050912125735.1301">The nodebar plugin adds buttons at the bottom of the tree canvas. The buttons
correspond to commands found in the Outline commands. It is intended to speed up
a new users ability to use the outline. Experienced users may find value in
being able to quickly execute commands they do not use very often.</t>
<t tx="ekr.20050912125735.1316">Send all output to the log pane.</t>
<t tx="ekr.20050912125735.1317">Turns the log into a tabbed component.  Other plugins may add tabs.
To get a new tab in TabbedLog::

    import TabbedLog
    pane = TabbedLog.getPane(name,c)

- pane is the pane returned for you to work with.
- name is the name of the tab you want for the pane.
- c is the commander for the leoFrame.</t>
<t tx="ekr.20050912125735.1323">A plugin for searching unknownAttributes (uA's).</t>
<t tx="ekr.20050912125735.1333">A plugin that enables the user to scroll down with a left mouse click and hold,
and to scroll up with a right mouse click and hold. Scrolling continues until
the user releases the mouse. Originally designed as a workaround for various
bugs in Tkinter scrolling, this may actually be superior to wheel scrolling, in
that there is little work a user has to do to scroll except to press a button.</t>
<t tx="ekr.20050912125735.1342">This plugin uses Python's urllib module to download files and import them into Leo.
It requires the TabbedLog plugin.
</t>
<t tx="ekr.20050912125735.164">Creates new nodes containing parameterized section references.
</t>
<t tx="ekr.20050912125735.172">This plugin allows Leo to read a complete directory's outline into a Leo's
Outline. Directories are converted into headlines and files names are listed
into the bodies.</t>
<t tx="ekr.20050912125735.184">Timestamp all save operations to show when they occur.</t>
<t tx="ekr.20050912125735.186">Modify the way exported outlines are displayed.</t>
<t tx="ekr.20050912125735.188">A plugin that helps customize pretty printing. It creates a do-nothing subclass
of the default pretty printer. To customize, simply override in this file the
methods of the base prettyPrinter class in leoCommands.py. You would typically
want to override putNormalToken or its allies. Templates for these methods have
been provided. You may, however, override any methods you like. You could even
define your own class entirely, provided you implement the prettyPrintNode
method.
</t>
<t tx="ekr.20050912125735.204">A plugin to schedule commands for later execution. It's provides the ability to
issue commands at a future time and to write messages that will be displayed at
a later time. To record commands You goto Schedule and choose begin recording.
Then you jump to the nodes and select the commands you want issued on them. This
process is ended with the end recording option. A dialog pops up. You can then
click on the individual commands and set the time for execution. To set the
execution time for all, enter a value and hit set_all. All times must be in the
form hh:mm. For example I want to issue a save command for 5:00 PM. I would do
so by using the value 17:00. The Schedule Message is simple. There is a Text box
to enter the message and a Entry to place the time. View Queue will summon a
view of The Queue. This dialog will show the commands that have been enqueued.
There is also the option to Cancel out any scheduled commands/messages.</t>
<t tx="ekr.20050912125735.225">This plugin lets you add customizable templates to an outline. Templates are
like any other node except that the plugin replaces %s in the body text by
values that you specify when using template. Templates may have section
references; this plugin uses Leo's @nosent write machinery to create one
string out of possibly many nodes. This plugin requires the simplified atFile
write code that is new in 4.2.1.

This plugin creates two buttons in Leo's icon area:

- The '%s' button marks or unmarks a node as a template. A %s symbol will appear to
  the left of the node when it is marked as a template.

- The '----&gt; %s' button brings up a dialog that shows you the template text and
  asks you to specify the value for all %s instances. Dismissing this dialog
  inserts the template as the first child of the node, and creates a section
  reference in the node that references the template.

If a template does not have a '%s' in it, then the templates plugin just adds
the text as a node. Templates once marked are stored across sessions. Do not put
a template in a thin file, as your template mark will be erased between
sessions.

</t>
<t tx="ekr.20050912125735.245">This plugin adds **date nodes** (nodes with dates as their headlines) to the
current outline. Date nodes may be added one at a time, a month's-worth at a
time, or a year's-worth at a time. The format of the headlines is
configurable in the ini file.</t>
<t tx="ekr.20050912125735.26"></t>
<t tx="ekr.20050912125735.2712"></t>
<t tx="ekr.20050912125735.2713">Replaces Commands.openWithTempFilePath so Leo opens temporary
files with a filename that begins with the headline text, and
located in a username_Leo subdirectory of the temporary
directory. The LeoTemp prefix is omitted.  This makes it easier to
see which temporary file is related to which outline node.</t>
<t tx="ekr.20050912125735.2716">Creates an 'extensions' menu with commands to open either an xterm on Linux
or a cmd windows/explorer window on win32 in the directory of the current @file node.
This allows quick navigation to facilitate testing and navigating large systems
with complex directories.</t>
<t tx="ekr.20050912125735.2726">This plugin creates menu items in the File:Open With menu.

@openwith nodes in @settings trees create menu items. The openWith
plugin must be active for these settings to have any effect.

The headline of an @openwith node has the form::

    @openwith name = shortcut

name is name of the menu item. shortcut specifies the shortcut used to invoke
the menu item. shortcut may be None.

The body text @openwith nodes should contain a single line contain a tuple of the form::

    command,arg,ext

For example::

    'subprocess.Popen',['pythonw','C:/Python24/Lib/idlelib/idle.pyw'],'.py'

When the user selects this menu item Leo executes command(arg+path) where path
is the full path to the temp file. The ext argument specifies the extension of
the temp file.

Notes:

- command is a string.  Valid values are::

  'subprocess.Popen'
  'os.system'
  'os.startfile'
  'os.spawnl'
  'os.spawnv'
  'exec'

- arg is either a single string or a list of strings.

- ext is a string or None. If None, Leo computes a file extension base on what
  @language directive is in effect.

- If the .leo file being loaded contains @openwith nodes, the File:Open With
  menu contains only the items created by those nodes. Similarly, @openwith
  nodes in myLeoSettings.leo override entries in leoSettings.leo.

- If no @openwith nodes are found anywhere the openWith plugin uses hard-coded
  tables in the plugin itself.</t>
<t tx="ekr.20050912125735.273">A plugin to store Leo trees in anydbm files. Note: there isn't such a thing as an
anydbm file: it's whatever the anydbm module uses.
Under Outline, there is an option called Library. This will open a
dialog with a list of the trees that you have saved. You can insert trees stored
in the library, remove them and add trees to the library. Be aware of unicode,
any characters outside of the ascii set gets turned into a ?. I found this
problem in storing some trees from Edward's Leo outline. Id like it to be able to
store unicode, but that may require a more specific db background, than anydbm.
Also note, that your library files may not be OS independent. If your python
distribution does not have the backing db on another machine, it will not be
able to open your library.
This should help people develop templates that they want to reuse between Leo
projects.  For example, Id like a template of many Java interfaces to be easily
accessible.</t>
<t tx="ekr.20050912125735.2736">A plugin that communicates with VIM:

When properly installed, this plugin does the following:

- Double clicking on a node's icon opens that node in VIM.

- Leo will put the Vim cursor at same location as the Leo cursor in node's body if the Leo 'vim_plugin_positions_cursor' variable is set to True.

- Leo will put node in a Vim tab card if the Leo 'vim_plugin_uses_tab_feature' is set to True.

- Leo will update the node in the outline when you save the file in VIM.</t>
<t tx="ekr.20050912125735.2743">This plugin allows you to edit nodes in emacs/xemacs.
Depending on your preference, selecting or double-clicking a node will pass the
body text of that node to emacs. You may edit the node in the emacs buffer and
changes will appear in Leo.</t>
<t tx="ekr.20050912125735.2749">Use commands in the Plugins:Word Export:Export menu to formats and export
the selected outline to a Word document, starting Word if necessary.</t>
<t tx="ekr.20050912125735.2759"></t>
<t tx="ekr.20050912125735.2760">Opens any empty file as a minimal .leo file.</t>
<t tx="ekr.20050912125735.2763">Adds #line directives in perl and perlpod programs.
Currently supports only perl and perlpod.</t>
<t tx="ekr.20050912125735.2768">Multipath enables the ability to write a file to multiple locations. It acts as
a post-write mechanism, a file must be written to the file system for it to work.
At this point it is not a replacement for @path or an absolute path, it works in
tandem with them. To use, place @multipath at the start of a line in the root
node or an ancestor of the node. The format is (On Unix systems)::

    @multipath /machine/unit/:/machine/robot/:/machine/

It will place a copy of the written file in each of these directories.

There is an additional directive that simplifies common paths, it is called
@multiprefix. By typing @multiprefix with a path following it, before a
@multipath directive you set the beginning of the paths in the
@multipath directive. For example::

    @multiprefix /leo #@multipath /plugins 

or::

    @multiprefix /leo/
    @multipath plugins: fungus : drain

copies a file to /leo/plugins /leo/fungus /leo/drain.

The @multiprefix stays in effect for the entire tree until reset with
another @multiprefix directive. @multipath is cumulative, in that for
each @multipath in an ancestor a copy of the file is created. These
directives must at the beginning of the line and by themselves.</t>
<t tx="ekr.20050912125735.2779">Preprocess @file-nosent nodes: make sure each subnode ends
with exactly one newline, replace all tabs with spaces, and
add a newline before class and functions in the external file.
</t>
<t tx="ekr.20050912125735.2786">LeoN is Leo over the Network. LeoN is Collaborative Leo. This is an important
project for Leo's long-term development. See leo/doc/LeoN for important research
papers that form the basis of this project.</t>
<t tx="ekr.20050912125735.28">This plugin adds a menu item under the File-&gt;Import menu to import
Cisco configuration files.
The plugin will:

1)  Create a new node, under the current node, where the configuration will be
    written. This node will typically have references to several sections (see below).

2)  Create sections (child nodes) for the indented blocks present in the original
    config file. These child nodes will have sub-nodes grouping similar blocks (e.g.
    there will be an 'interface' child node, with as many sub-nodes as there are real
    interfaces in the configuration file).

3)  Create sections for the custom keywords specified in the customBlocks[] list in
    importCiscoConfig(). You can modify this list to specify different keywords. DO
    NOT put keywords that are followed by indented blocks (these are taken care of by
    point 2 above). The negated form of the keywords (for example, if the keyword is
    'service', the negated form is 'no service') is also included in the sections.


4)  Not display consecutive empty comment lines (lines with only a '!').

All created sections are alphabetically ordered.</t>
<t tx="ekr.20050912125735.2826"></t>
<t tx="ekr.20050912125735.2828">Translate a few menu items into Simplified Chinese

By Zhang Le &lt;ejoy@xinhuanet.com&gt;</t>
<t tx="ekr.20050912125735.2836">Translate menus to French</t>
<t tx="ekr.20050912125735.2844">Adds pie menus.  See http://www.piemenus.com/</t>
<t tx="ekr.20050912125735.2867"></t>
<t tx="ekr.20050912125735.2869">Create a Plugins menu and adds an item to the plugin menu for each active
plugin. Selecting this menu item will bring up a short About dialog with the
details of the plugin. Plugins can create additional menu items by defining
functions named cmd_XZY. These will appear in a submenu. If the plugin
requires an INI file then a configure menu item will be created which will show
an INI file editor. The plugin can define an applyConfiguration function,
which will be called when the configuration changes. Plugins can also define a
top level function to be called instead of the default "About" dialog by
defining a "topLevelMenu" function in the plugin. This function will be called
when the user clicks on the plugin name in the plugins menu, but only if the
plugin was loaded properly and registered with g.plugin_signon.

Plugins can define their name by setting the __plugin_name__ property.
Plugins can also attempt to select the order they will appear in the menu by
defining a __plugin_prioriy__. The menu will be created with the highest
priority items first. This behavior is not guaranteed since other plugins can
define any priority. This priority does not affect the order of calling
handlers. To change the order select a number outside the range 0-200 since this
range is used internally for sorting alphabetically.</t>
<t tx="ekr.20050912125735.2918">A plugin to manage Leo's Plugins:

- Enables and disables plugins.
- Shows plugin details.
- Checks for conflicting hook handlers.
- Checks for and updates plugins from the web.
</t>
<t tx="ekr.20050912125735.3040">A plugin to automatically update Leo from the current CVS version
of the code stored on the SourceForge site. You can view individual
files and update your entire Leo installation directly without needing
a CVS client.</t>
<t tx="ekr.20050912125735.3056"></t>
<t tx="ekr.20050912125735.3057">A plugin to create script buttons and @button, @plugin and @script nodes.
This plugin puts two buttons in the icon area: a button called run Script and
a button called script Button. The run Script button is simply another way
of doing the Execute Script command: it executes the selected text of the
presently selected node, or the entire text if no text is selected. The 'script
Button' button creates another button in the icon area every time you push it.
The name of the button is the headline of the presently selected node. Hitting
this _new_ button executes the button's script.

For example, to run a script on any part of an outline do the following:

1.  Select the node containing the script.
2.  Press the scriptButton button.  This will create a new button, call it X.
3.  Select the node on which you want to run the script.
4.  Push button X.

That's all.  You can delete a script button by right-clicking on it.
This plugin optionally scans for @button nodes, @plugin nodes and @script nodes
whenever a .leo file is opened.

- @button nodes create script buttons.
- @plugin nodes cause plugins to be loaded.
- @script nodes cause a script to be executed when opening a .leo file.

Such nodes may be security risks. This plugin scans for such nodes only if the
corresponding atButtonNodes, atPluginNodes, and atScriptNodes constants are set
to True in this plugin.</t>
<t tx="ekr.20050912125735.3077"></t>
<t tx="ekr.20050912125735.3078">A minimal http plugin for LEO, based on AsyncHttpServer.py.
Use this plugin is as follows:

1. Start Leo with the plugin enabled.  You will see a purple message that says something like::

    http serving enabled on port 8080, version 0.91

2. Start a web browser, and enter the following url: http://localhost:8080/ You
   will see a a "top" level page containing one link for every open .leo
   file.  Start clicking :-)

You can use the browser's refresh button to update the top-level view in the browser after you have opened or closed files.

To enable this plugin put this into your file::

    @settings
        @bool http_active = True
        @int  port = 8080
        @string rst_http_attributename = 'rst_http_attribute'</t>
<t tx="ekr.20050912125735.3136"></t>
<t tx="ekr.20050912125735.3138">aspell.pyx: Leo's new spell checking plugin that uses aspell.exe. It is much
faster than the old mod_spelling plugin, but requires Python 2.3 or above and a
recent version of Aspell. When properly installed and enabled, this plugin adds
a Check Spelling command to Leo's Edit menu. This command brings up a spell
checking dialog. You can set options by changing entries in spellpyx.ini in
Leo's plugins menu. One of these settings is the name of the dictionary,
spellpyx.txt by default. **Warning**: do not create spellpyx.txt with an @asis
tree in leoPlugins.leo: only the plugin code should typically change
spellpyx.txt. You **can** edit spellpyx.txt yourself in an external editor: just
make sure that Leo isn't running when you do this. You can bring up the spell
checker without enabling the spellpyx plugin by using an @button Check
Spelling... script button. LeoDocs.leo contains such a script button.</t>
<t tx="ekr.20050912125735.314">Autosave the Leo document every so often. The time between saves is given in
seconds in autosave.ini.</t>
<t tx="ekr.20050912125735.318">This plugin puts the View Table command in the Outline menu. This command checks
the current node using the csv (comma separated values) mods Sniffer. It tries
to determine the format that is in the nodes data. If you had excel data in it,
it should be able to determine its excel data. It then creates a dialog with the
data presented as in a table for the user to see it. Requires Pmw and the
tktable widget at http://sourceforge.net/projects/tktable.
</t>
<t tx="ekr.20050912125735.3209">temacs is a binding module for the Tkinter Text widget.
usetemacs is a Leo plugin that patches the temacs modules Emacs emulation
into the standard Leo Tkinter Text editor.</t>
<t tx="ekr.20050912125735.334"></t>
<t tx="ekr.20050912125735.335">A plugin to test import problems.</t>
<t tx="ekr.20050912125735.336">Dump Python globals at startup.</t>
<t tx="ekr.20050912125735.338">Enable debugging and tracing for Python's garbage collector.</t>
<t tx="ekr.20050912125735.341">Trace changes to Leo's objects at idle time.</t>
<t tx="ekr.20050912125735.344">Trace keystrokes in the outline and body panes.</t>
<t tx="ekr.20050912125735.346">Trace the most common hooks, but not key, drag or idle hooks.</t>
<t tx="ekr.20050912125735.3559"></t>
<t tx="ekr.20050912125735.3621">Adds XSLT-Node Command submenu item to the Outline menu.
This menu contains the following items:

Set StyleSheet Node
    Selects the current node as the xsl stylesheet the plugin will use.

Process Node with Stylesheet Node
    Processes the current node as an xml document,
    resolving section references and Leo directives,
    and creates a sibling containing the results.

Requires 4Suite 1.0a3 or better, downloadable from http://4Suite.org.</t>
<t tx="ekr.20050912125735.363">The dyna_menu plugin is a remarkable body of work by 'e'.
This plugin creates a dyna_menu menu from which you can execute commands.
You may download the latest version at: http://rclick.netfirms.com/dyna_menu.py.html</t>
<t tx="ekr.20050912125735.3642">Leo2AsciiDoc is a small Python program which has been built to be used as a
plugin module for the Leo outlining editor.
For more information see:  http://www.marshallresearch.com/michael-dawson/os/leo.html
I am still using Leo version 4.1 (rc3, build 1.62), as I've been unable to keep
up with the speed of Edward's Leo development. He has made such significant
changes to Leo since 4.1 that I doubt that Leo2AsciiDoc will work with any
version later than 4.1. I do intend to rewrite Leo2AsciiDoc for the new Leo, but
there is no schedule set. 

Leo2AscDoc enables the contents of plain text Leo outlines to be published to HTML
or PDF via the AsciiDoc program and the DocBook set of publishing tools. Plain
text from the Leo outline can be transformed into a final result that has
typeset body text, in which bulleted and numbered lists, variable lists, page
numbers, URLs, index terms,and bold and italic text are automatically
recognized. typeset Headings a Table of Contents an Index containing any items
marked by the user, and any Python classes or functions. To produce HTML and
PDF, you'll need to have the AsciiDoc program installed (a trivial task) and a
DocBook tool chain installed, which is not a trivial task. And, of course,
Python and Leo. In sum, this little program is an easy install for people who
are already using Leo and DocBook. As noted later, Leo2AsciiDoc has only been
tested on Linux</t>
<t tx="ekr.20050912125735.3832">The rst3 plugin creates output files from Leo outlines containing rST
(reStructuredText_) markup. rst3 options control most aspects of this plugin's
operations. You can set options in @settings trees, in headlines and in body
text. There are too many options to describe here. See:
http://webpages.charter.net/edreamleo/rstplugin3.html for full documentation. To
use this plugin effectively, Python's docutils_ module must be installed. The
rst3 plugin will use the SilverCity_ syntax coloring package if it installed.

The rst3 plugin adds the Write Restructured Text command to Leo's Edit menu.
This command searches the selected outline looking for **rst root nodes** whose
headline have the form::

    @rst &lt;filename&gt;

The plugin then creates the named file in various ways depending which rst3
options are in effect. By default, the rst3 plugin creates rST headings
automatically from outlines, so the higher-level nodes in the outline correspond
to higher-level sections in the output. Creating rST headings automatically
eliminates one of the most tedious chores associated with rST markup.
This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.

For full details on this plugin, see http://webpages.charter.net/edreamleo/rstplugin3.html

A new method has been added to the rst3 plugin to make it more easily to drive
the plugin from scripts::

    def writeNodeToString (self,p=None,ext=None)

writeNodeToString scans p's tree (p defaults to presently selected node) looking for @rst nodes.
When the first @rst node is found, writeNodeToString processes the node as usual, with the following changes:

- @rst need not be followed by a filename; any filename and its extension are *ignored*.

- Only the ext argument to writeNodeToString determines the type of output produced.
  The valid values for the ext argument are None (for rst output), '.html', '.pdf', and '.tex'.

- Instead of writing the result to a file, writeNodeToString returns the tuple (p,s),
  where p is the node whose tree produced the output, and s is the output itself.

- writeNodeToString returns after processing at most one @rst node.

Scripts can easily use writeNodeToString to convert @rst trees into various kinds of output.
For example, here is the body of @button rst-&gt;html in LeoDocs.leo::

    import leo.core.leoPlugins as leoPlugins
    rst3 = leoPlugins.getPluginModule('rst3')
    if rst3:
        controller = rst3.controllers.get(c)
        if controller:
            p,s = controller.writeNodeToString(ext='.html')
            print '*' * 40,p
            print s

Notes:

- This script scans the presently selected tree for @rst nodes, just like the @button rst script does.
  In particular, if the presently selected tree does not contain an @rst node the search continues in parent trees.
  When an @rst node is found, it converts the node (and descendants) to html and returns p,
  the found @rst node and s, the html itself.

- The script shown above merely prints the output, but many other actions could be taken.
  In particular, because writeNodeToString returns p it would be possible to write a script that
  would scan multiple @rst nodes.

- None and '.tex' are also valid values for the ext argument to writeNodeToString.
  None converts the @rst tree to a single reStructuredText string, as shown in @button rst-&gt;rst.

- There is some support for ext='.pdf', but this is experimental code.  Expect crashes.</t>
<t tx="ekr.20050912125735.525"></t>
<t tx="ekr.20050912125735.526">Synchronizes @folder nodes with folders. If a node is named @folder
path_to_folder, the content (filenames) of the folder and the children of that
node will be sync. Whenever a new file is put there, a new node will appear on
top of the children list (with mark). So that I can put my description (i.e.,
annotation) as the content of that node. In this way, I can find any files much
easier from leo. Moreover, I add another feature to allow you to group files(in
leo) into children of another group. This will help when there are many files in
that folder. You can logically group it in leo (or even clone it to many
groups), while keep every files in a flat/single directory on your computer.
</t>
<t tx="ekr.20050912125735.529">Executes commands in nodes whose body text starts with @produce.
To use, put in the body text of a node::

    @produce javac -verbose Test.java

To execute, you goto Outline and look at Produce. Choose Execute All Produce or
Execute Tree Produce. The Tree does the current Tree, All does the whole
Outline. Executing will fire javac, or whatever your using. @produce functions
as a directive. After executing, a log file/node is created at the top of the
Outline. Any output, even error messages, should be there. It executes in a
hierarchal manner. Nodes that come before that contain @produce go first. I'm
hoping that this orthogonal to @run nodes and anything like that. Its not
intended as a replacement for make or Ant, but as a simple substitute when that
machinery is overkill. **Warning**: trying to execute a non-existent command
will hang Leo.</t>
<t tx="ekr.20050912125735.540">A plugin that supports @clip, @view and @strip nodes.

-   Selecting a headline containing @clip appends the contents of the clipboard to
    the end of the body pane.

-   Double clicking the icon box of a node whose headline contains @view &lt;path-to-file&gt;
    places the contents of the file in the body pane.

-   Double clicking the icon box of a node whose headline contains @strip &lt;path-to-file&gt;
    places the contents of the file in the body pane, with all sentinels removed.

This plugin also accumulates the effect of all @path nodes.</t>
<t tx="ekr.20050912125735.556">This plugin allows the user to import binary data and store it in Leo as a
base64 string. This plugin adds Import base64 and Export base64 commands
to the Import menu and adds the 'View base64' command to the outline menu. The
Import base64 command creates a new node with the headline::

    @base64 &lt;filename&gt;

The body of this node will kill the colorizer, add some info on the original
file and create a section reference to the payload node, which contains the
data. The Export base64 command asks for a location to place the file. The
plugin checks that the structure of the base64 node is what it expected,
basically what an import operation creates. If Ok, it will write the file to the
selected directory. The View base64 command brings up a Pmw Dialog that displays
the data as a PhotoImage. This currently only supports formats recognized by the
PhotoImage class. This would be the .gif format. This functionality may be
enhanced in the future by PIL to support more image types. Depending on the size
of the image, you may have to scroll around to see it. For example, a leo clone
icon will require scrolling to find. Id like to change this in the future.</t>
<t tx="ekr.20050912125735.565">A Leo plugin that adds quick utility commands through a pop-up menu.
To summon Menu, type control-space.
To unsummon, Right Click.

1. Movement. If a node has ancestors,siblings or children a menu option will
appear offering the user the ability to jump to the node from the current node.
This is an improvement over moving one node at a time with the keyboard
commands.

2. Inserting text. These menus offer the current language keywords, the
directives the body recognizes and any @file type headline directives. It offers
the new user easy access to the different directives and ways to write a file.

3. Moving Nodes(experimental). You can quickly move a node to its
parent's parent or after a sibling, if they exist.</t>
<t tx="ekr.20050912125735.597">This plugin allows you to associate information with nodes. This information is
organized around "labels", which is are just strings and freely chosen by the
user. The plugin allows you to create such a label quickly for each marked node,
and to mark all nodes which have a certain label. Labels can be converted to
subnodes, and vice versa. This facility allows you to add additional information
for each label. You can create clones for each node which has a label. These
clones are created as children of the current node. This last facility can be
used to create clones for each node which has been found or changed by the
standard search/replace dialog:

- Delete all marks.
- Do a "find all" / "change all".
- Convert the marks to a label.
- Run the "Clone label subnodes" command.

Finally, if you read a external file, and the content of a node changes, the
previous content is available under the label "before change:"</t>
<t tx="ekr.20050912125735.647">A plugin to create and update @read-only nodes. I wanted to have the ability to
import files in "read-only" mode, that is, in a mode where files could only be
read by leo (not tangled), and also kept in sync with the content on the drive.
The reason for this is for example that I have external programs that generate
resource files. I want these files to be part of a leo outline, but I don't want
leo to tangle or in any way modify them. At the same time, I want them to be
up-to-date in the leo outline. This plugin has the following characteristics:

- It reads the specified file and puts it into the node content.

- If the @read-only directive was in the leo outline already, and the file content
  on disk has changed from what is stored in the outline, it marks the node as
  changed and prints a "changed" message to the log window; if, on the other hand,
  the file content has *not* changed, the file is simply read and the node is
  not marked as changed.

- When you write a @read-only directive, the file content is added to the node
  immediately, i.e. as soon as you press Enter (no need to call a menu
  entry to import the content).

- If you want to refresh/update the content of the file, just edit the headline
  and press Enter. The file is reloaded, and if in the meantime it has changed,
  a "change" message is sent to the log window.

- The body text of a @read-only file cannot be modified in leo.

The syntax to access files in @read-only via ftp/http is the following::

    @read-only http://www.ietf.org/rfc/rfc0791.txt
    @read-only ftp://ftp.someserver.org/filepath

If FTP authentication (username/password) is required, it can be specified as follows::

    @read-only ftp://username:password@ftp.someserver.org/filepath</t>
<t tx="ekr.20050912125735.674">Runs a program and interface Leo through its input/output/error streams.
Double clicking the icon box whose headlines are @run 'cmd args' will execute
the command. There are several other features, including @arg and @input nodes.

The run_nodes.py plugin introduce two new nodes that transform leo into a
terminal. It was mostly intended to run compilers and debuggers while having the
possibility to send messages to the program.

- Double clicking on the icon of an node whose headline is::

    @run &lt;command&gt; &lt;args&gt;

will launch &lt;command&gt; with the given arguments. It will also mark the node. #
Terminates the argument list. @run # &lt;comment&gt; is also valid.

- @in nodes are used to send input to the running process. Double clicking
  on the icon of an @in &lt;message&gt; node will append a "\n" to &lt;message&gt; and
  write it to the program, no matter where the node is placed. If no @run node is
  active, nothing happens.

- The body text of every child, in which the headlines do not begin with @run
  or @in, will be appended to &lt;command&gt;, allowing you to add an infinite number
  of arguments to &lt;command&gt;.

- The output of the program is written in the log pane (Error outputted in red).
  When the program exit the node is set unmarked and the return value is
  displayed...When the enter key is pressed in the body pane of an active @run
  node the content of it body pane is written to the program and then emptied
  ready for another line of input. If the node have @run nodes in its descendants,
  they will be launched successively (unless one returned an exit code other
  than 0, then it will stop there).</t>
<t tx="ekr.20050912125735.694">Launches (starts) a file given by a headline when double-clicking the icon.
Ignores headlines starting with an '@'. Uses the @folder path if the headline
is under an @folder headline. Otherwise the path is relative to the Leo file.
</t>
<t tx="ekr.20050912125735.699">The AutoTrees plugin is a helper plugin designed to make it very easy to write
"handler" plugins to manage dynamic content in Leo outlines. AutoTrees provides:

- Convenient handler base classes which can be specialized for particular uses.
- A manager to turn handlers on and off.
- A set of example handlers to show the kinds of things that are possible.

AutoTrees doesn't do anything that you cannot do in other ways, but it does
provide a consistent way of adding dynamic content. This means that individual
plugin writers don't have to rewrite all the same kinds of code each time and
also makes it easier to maintain Leo, since it standardizes the way that certain
classes of plugin interact with the Leo core. Why use this? I'm a plugin writer
and I want to write a plugin to display dynamic content, i.e., content not
directly contained in the .leo or external files, e.g.,

- email messages 
- news feeds
- news groups
- documentation
- remote files
- statistics
- file system data
- data base records

You can do this as a standard plugin, but as an AutoTrees handler you,

- don't need to write code that interacts with the tree (this is done for you)
- get centralized management
- can still do everything else you could as a normal plugin
</t>
<t tx="ekr.20050912125735.82">Supports new Leo directives.</t>
<t tx="ekr.20050912125735.85">This plugin manages BibTeX files with Leo. Create a bibliographic database by
putting @bibtex filename in a headline. Entries are added as nodes, with
@entrytype key as the headline, and the contents of the entry in body text.
The plugin will automatically insert a template for the entry in the body pane
when a new entry is created (hooked to pressing enter when typing the headline
text). The templates are defined in dictionary templates in the \&lt;\&lt;globals\&gt;\&gt;
section, by default containing all required fields for every entry.

The file is written by double-clicking the node. Thus the following outline::

    -@bibtex biblio.bib
     +@book key
      author = {A. Uthor},
      year = 1999

will be written in the file 'biblio.bib' as::

    @book{key,
    author = {A. Uthor},
    year= 1999}

Strings are defined in @string nodes and they can contain multiple entries.
All @string nodes are written at the start of the file. Thus the following
outline::

    -@bibtext biblio.bib
     +@string
      j1 = {Journal}
     +@article AUj1
      author = {A. Uthor},
      journal = j1
     +@string
      j2 = {Journal2}
      j3 = {Journal3}

Will be written as::

    @string{j1 = {Journal1}}
    @string{j2 = {Journal2}}
    @string{j3 = {Journal3}}

    @article{AUj1,
    author = {A. Uthor},
    journal = j1}

No error checking is made on the syntax. The entries can be organized under
nodes--if the headline doesn't start with '@', the headline and body text are
ignored, but the child nodes are parsed as usual. BibTeX files can be imported
by creating an empty node with @bibtex filename in the headline.
Double-clicking it will read the file filename and parse it into a
@bibtex tree. No syntax checking is made, filename is expected to be a
valid BibTeX file.</t>
<t tx="ekr.20050912125735.868"></t>
<t tx="ekr.20050912125735.869">Rebinds up/down arrow keys.</t>
<t tx="ekr.20050912125735.874">Handles images in body text. Based on work by Gil Shwartz. Brent Burley provided
many important insights. See:
http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52264</t>
<t tx="ekr.20050912125735.880">This plugin provides a simple but powerful and flexible system of managing
scriptable context menus.

Named menus defined in scripts or @popup &lt;name&gt; settings can be associated with any widget.

Menu items may have icons and the foreground/background colors can be set in @popup settings.

Full details can be found in the plugins docstring.

Many executable howto's, demos and examples can be found in::

    test/testAtPopup.leo
</t>
<t tx="ekr.20050912125735.904">Autocompletion and calltips plugin.

- . summons the autocompletion.
- ( summons the calltips
- Escape closes either box.
- Ctrl selects an item.
- alt-up_arrow, alt-down_arrow move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocompleter.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesn't find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleter's runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.</t>
<t tx="ekr.20050912125735.942">Handle coloring for markup in doc parts and Python triple-double-quoted strings.

**Important**:

- This plugin requires that the add_directives plugin is enabled.

- To color a text with wiki markup the text must be in the range of an @markup wiki directive.

The currently supported markups are::

    ''text''                    # write text in italics
    __text__                    # write text in bold
    ~~&lt;color&gt;:text~~            # write text in the color specified by &lt;color&gt; (e.g. blue, grey, etc)
    {picture file=&lt;filename&gt;}   # load the picture indicated by &lt;filename&gt;
    http://url                  # URL support: double clicking on the url will open it in the default browser.
    https://url                 # URL support: double clicking on the url will open it in the default browser.

-   Note 1: italics and bold markups can be nested, e.g.,::

        ''__text__''            # write text in italics and bold

    Just remember to terminate the tags in the order they were opened.

- Note 2: URLs must be terminated by a space.

By default, once the text has been markup up, the actual tags (e.g. '__' for
bold) are not displayed anymore. You can choose to display them selecting "Show
Invisibles" from the Edit menu.</t>
<t tx="ekr.20050912125735.974">Send output from the Execute Script command to the end of the body pane.</t>
<t tx="ekr.20050912125735.98">This plugin is enhances the EditAttributes.py plugin. It puts a command in
Outline called ConceptualSort. This will prompt you for a concept to sort by.
This gives the user some more flexibility in how they want to arrange their
nodes. Nodes without the attribute in question go to the bottom of the sort.
The user can:

- Select which attribute he wants to sort on by clicking on the Attribute box.

- Select the type of sort he wants by clicking on the radio buttons:

    -   Normal.
    -   Reversed. Like normal but the results are reversed.
    -   Used defined. For advanced users. The text box is where a user can type in
        their own python code to sort the nodes-attributes. There is no need for a
        def. That gets appended to the beginning of the code. It prototype looks
        like::

            def( a, b, att ):

where a and b are nodes and att is dictionary of the nodes and the respective
value of the selected attribute. There is no need to indent on the first level
since indentation is added at compile time.</t>
<t tx="ekr.20050912125735.980"></t>
<t tx="ekr.20050912125735.981">Adds navigation buttons to icon bar. Tk only.</t>
<t tx="ekr.20050913131848">Leo 4.3.2 final                 September 16, 2005

To learn about Leo, see: http://webpages.charter.net/edreamleo/intro.html

The highlights of 4.3.2:
-----------------------

- Improved Leo's documentation:
    - A tutorial introduction to Leo:
      http://webpages.charter.net/edreamleo/intro.html
    - A 5-minute guide to programming with Leo:
      http://webpages.charter.net/edreamleo/intro.html#quick-start-for-programmers

- The new rst3 plugin creates .html and .tex files from reStructuredText
  embedded in Leo files. Any node of the source outline may contain options for
  the rst3 plugin, which makes this plugin much more useful and flexible than
  the previous rst plugins. All of Leo's documentation was created using this
  plugin from sources in LeoDocs.leo. For full documentation for rst3 see:
  http://webpages.charter.net/edreamleo/rstplugin3.html.

- The spellpyx (spell checking) plugin is now much easier to use.

- The vim and openWith plugins now use Python's subprocess module if it is present.
 
- Improved the Pretty Printing command.

- The usual assortment of bug fixes.</t>
<t tx="ekr.20050917092557">Leo 4.3.3 final                 September 17, 2005

Leo 4.3.3 fixes several bugs reported in Leo 4.3.2 final in the last several days.

To learn about Leo, see: http://webpages.charter.net/edreamleo/intro.html

The highlights of 4.3.3 (and 4.3.2)
-----------------------------------

- Improved Leo's documentation:
    - A tutorial introduction to Leo:
      http://webpages.charter.net/edreamleo/intro.html
    - A 5-minute guide to programming with Leo:
      http://webpages.charter.net/edreamleo/intro.html#quick-start-for-programmers

- The new rst3 plugin creates .html and .tex files from reStructuredText
  embedded in Leo files. Any node of the source outline may contain options for
  the rst3 plugin, which makes this plugin much more useful and flexible than
  the previous rst plugins. All of Leo's documentation was created using this
  plugin from sources in LeoDocs.leo. For full documentation for rst3 see:
  http://webpages.charter.net/edreamleo/rstplugin3.html.

- The spellpyx (spell checking) plugin is now much easier to use.

- The vim and openWith plugins now use Python's subprocess module if it is present.
 
- Improved the Pretty Printing command.

- The usual assortment of bug fixes.</t>
<t tx="ekr.20050917092557.1">Here is a summary of the changes:

- General: All chapters created with rst3 plugin. This ensures a uniform look.
The source is in LeoDocs.leo. Removed all references to older versions of Leo,
except when discussing old file formats in the Appendices. Corrected all text so
it discusses present version.

- rst3 plugin itself: Correct bug that caused chapters to be formatted
differently when processing multiple @rst trees.

- rst3 button in LeoDocs.leo: The script first looks *up* the tree, looking for
an @rst node. If found, it processes just that tree. If not found, it processes
all @rst nodes *below* the originally selected node. The button is now much more
convenient to use.

- Preface: Shorter, no history. No longer a dead end.

- What People are Saying About Leo: No longer a dead end.

- FAQ: Reorganized, simplified, revised. Added entries for running Leo in a
console window and debugging docutils. Improved entry for using cvs.

- Chapter 1: Installation: Now the first chapter. Revised.

- Chapter 2: Tutorial: Completely rewritten. Like Python's tutorial, this
chapter contains everything a beginner needs to understand and use Leo. The
`Quickstart for programmers` section is the heart of this chapter. All terms
used have links either to their definition in the tutorial or in the Glossary.
Newbies should be able to digest this chapter easily. This chapter should make
Leo comprehensible to many more people.

- Chapter 3: Using Outlines: Revised per general remarks above.

- Chapter 4: Writing Programs in Leo. Completely rewritten. The old chapter was
an embarrassment. The new chapter is a reference guide, properly organized as
such. The introduction warns newbies away.

- Chapter 5: Using Leo's Commands. 'Minor' revisions and corrections create a
substantially better result.

- Chapter 6: Leo and literate programming: Reformatting helps. New words about
rST markup and other improvements over traditional LP.

- Chapter 7: Scripting Leo with Python: Rewritten, simplified, updated and
corrected. The sources in LeoDocs.leo are directly executable. rST sources use
literal blocks instead of code-blocks so that the sources are simplified.
(Important when executing examples). Properly discusses positions, including
'supremely important' section on copying positions.

- Chapter 8: Customizing Leo. Heavily revised. Discusses leoSettings.leo, not
leoConfig.txt. Security warnings are more reasonable. Section on script buttons.
Rewrote section on uA's (Adding extensible attributes to nodes and .leo files).

- Chapter 9: History of Leo. Rewritten. Much shorter and more useful. Discusses
the major milestones, concentrating on explaining the major differences between
versions. Gone are details of how discoveries came to be. They are in
LeoPostings.leo, which will be included in the distribution.

- Chapter 10: Theory of Operation. Largely rewritten. Discusses positions
properly. Omits discussion of how clones were implemented before 4.2.

- Chapter 11: White Papers. A new chapter. This is a slightly-edited version of
writing that had been buried in the appendices.

- Appendices. Heavily revised and reformatted. Rewrote sections on file formats.

- Glossary: A separate chapter. All terms have links to their definition. All
definitions are rST targets so other chapters may refer to them. Added several
new entries.</t>
<t tx="ekr.20050917092557.10">This plugin now allows quotes within words, but strips quotes and other cruft
from the beginning and end of words. As a result, using the spellpyx spell
checker is much easier than before.

Leo's extensions folder now contains aspell23.pyd and aspell24.pyd. These are
Python dll's compiled for Python 2.3 and 2.4 respectively. You must rename one
of these files to be aspell.pyd and move aspell.pyd to the aspell folder. For
more details, see the installation nodes in the docstring for the spellpyx
plugin.</t>
<t tx="ekr.20050917092557.11">These plugins now use Python's subprocess module if it is present. The
subprocess module comes standard with Python 2.4. For Linux systems, Leo will
use subprocess.py in Leo's extensions folder if necessary.

For Windows systems you can install Python's subprocess module in Python 2.2 or
2.3 as follows:
    
    - Go to http://www.effbot.org/downloads/#subprocess

    - Download and execute one of the following installers, depending on your version of Python:
        subprocess-0.1-20041012.win32-py2.3.exe 
        subprocess-0.1-20041012.win32-py2.2.exe
        
This installer installs the subprocess sources and also _subprocess.pyd in Python's site-packages folder.
</t>
<t tx="ekr.20050917092557.12"></t>
<t tx="ekr.20050917092557.13">Calling print directly is dangerous: it will fail for unicode characters.</t>
<t tx="ekr.20050917092557.14">The new Pretty Print code has the following improvements:

- Strip trailing blanks in get.
- Many improvement to doOp.
- Improved DoMultiline:
    - Added special case logic to ensure '#' is preceded by space except at start of line.
    - Added blank after multi-line string if needed.
- Added lastName token for special-case handling depending on previous token.
- No change to put, putArray or doName.</t>
<t tx="ekr.20050917092557.2"></t>
<t tx="ekr.20050917092557.3">- Fixed bug with non-unicode characters in file name

    http://sourceforge.net/forum/message.php?msg_id=3224635
    
    Leo crashed try to read .leo files whose name contained non-ascii characters.

- Fixed bug with non-unicode characters in settings value

    http://sourceforge.net/forum/message.php?msg_id=3222750
    
    Leo crashed try to write settings whose values contained non-ascii characters.

- Fixed bug tangling sections with non-unicode characters.

    http://sourceforge.net/forum/message.php?msg_id=3307318</t>
<t tx="ekr.20050917092557.4">http://sourceforge.net/forum/message.php?msg_id=3218558</t>
<t tx="ekr.20050917092557.5">The fix was to add an entry of 'unknown' state to state_dict. This fixes the
crash by brute force, but may not be strictly correct. However, this is pretty
much moot: we shall soon be moving to the new colorizer.</t>
<t tx="ekr.20050917092557.6">The code gets c = keywords.get('c') in several places.
The protection is to return if c is None.
This affects the following files: plugins_menu.py, pluginsTest.py, plugin_manager.py</t>
<t tx="ekr.20050917092557.7">http://sourceforge.net/forum/message.php?msg_id=3231597

test.leo had some non-@ignore'd @thin nodes for files not in the distribution.

- Only files used by unit tests should be on cvs and the distribution.
    - test\unittest\batchTest.py and test\unittest\errorTest.py were already on cvs.
    - Added these files to the distribution.

- Other test files should be distributed in @ignore nodes.

- Leo's distribution checklist now has an item to check that the distributed test.leo can be opened without errors.</t>
<t tx="ekr.20050917092557.8"></t>
<t tx="ekr.20050917092557.9">See http://webpages.charter.net/edreamleo/rstplugin3.html for full documentation
of this plugin.

The rst3 plugin creates output files from Leo outlines containing
reStructuredText (rST) ReStructuredText is a simple and powerful text formatting
markup language. Outlines are a natural way to organize rST (or any text).

This plugin adds the Write Restructured Text command to Leo's Edit menu. The
Write Restructured Text command searches the selected outline looking for rst
root nodes whose headline have the form @rst &lt;filename&gt;. The plugin then creates
the named file in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically relieves you from one of the most
tedious chores in creating rST markup.

To use this plugin effectively, Python's docutils module must be installed. The
rst3 plugin will use the SilverCity syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.</t>
<t tx="ekr.20050917105646">- Fixed bug that caused the Open With command to crash if the subprocess module was not installed.

- Fixed problems in the niceNocent and fastGotoNode plugins.</t>
<t tx="ekr.20051028051444">Leo 4.4 alpha 4                                         December 5, 2005

Leo 4.4 a4 introduces the 'Newer World Order' for redrawing the screen,
corrects numerous bugs in the 4.4 code base, and introduces several new features.

You should be able to use this version safely. There are no known serious bugs,
but several minibuffer commands are not ready for prime time. All the major
features of 4.4 are in place.

To learn about Leo, see: http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
----------------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name. Support for tab completion.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Support for almost all commands in the Emacs Cmds menu, including cursor
and screen movement, basic character, word and paragraph manipulation, and
commands to manipulate buffers, the kill ring, regions and rectangles.

- Per-pane key bindings. You can bind shortcuts to multiple commands depending
on which of Leo's panes presently has focus. For example, you can use arrow keys
to move nodes in the outline pane, while retaining their defaults in Leo's body
pane. Per-pane key bindings are essential for mouseless Leo.

- @command nodes create minibuffer commands. You can bind key shortcuts to
@button and @command nodes.

- A rewrite of Leo's keystroke handling. In particular, Leo handles key events
immediately rather than queuing them for idle time.

- Leo recovers from crashes much more reliably than in any previous version.

- Leo updates the screen immediately rather than waiting for idle time.
This 'Newer World Order' simplifies the code and improves performance.

Known bugs in Leo 4.4a4
-----------------------
- Several minibuffer commands do not work.  See the release notes for details.

Coming in later releases of Leo 4.4:
------------------------------------
- An auto-complete command that shows class members in the Completion tab.

- More support for mouseless Leo. There will be commands to manipulate all
aspects of Leo using commands, so your fingers will never have to leave the
keyboard.

- Support for Vim and other 'plain-key' input modes.</t>
<t tx="ekr.20051028051444.1">Here are the default bindings relating to the minibuffer. Any of
these may be changed by changing @shortcuts nodes in leoSettings.leo.

Alt-x: Just like Emacs: starts minibuffer. The prompt is 'full-command' Type a
full command name, then hit &lt;Return&gt; to execute the command. Tab completion
works, but not for file names.

Alt-c: Like Emacs Control-C: (Ctrl-C conflicts with XP cut). starts minibuffer.
The prompt is 'quick-command'. This mode is not completed, but stuff like
`Ctrl-C r` and `Ctrl r r` do work.

Alt-u: Like Emacs Ctrl-u: (Ctrl-u conflicts with move-outline-up). Add a repeat
count for later command. Ctrl-u 999 a adds 999 a's, but many features remain
unfinished.

Ctrl-g: Just like Emacs Ctrl-g: Closes the mini-buffer.

The @bool useMinibuffer setting in leoSettings.leo just controls whether the
minibuffer is visible. The minibuffer exists (and you can type into it) even if
it isn't visible! You can use the show-mini-buffer, hide-mini-buffer and
toggle-mini-buffer commands to show or hide the minibuffer.</t>
<t tx="ekr.20051028051444.10">Leo maintains the following dictionaries.  As usual, k refers to c.keyHandler:

- c.keyHandler.registerCommand can be called from scripts to register new alt-x
  commands. It probably won't work from plugins yet.

New dictionaries and methods make it easier to customize and extend Leo:

- c.commandsDict describes all commands. Keys are full Emacs command names;
values are functions f.

- k.inverseCommandsDict: keys are f.__name__, values are emacs command names.

- k.leoCallbackDict: keys are leoCallback functions, values are called
functions.

- k.bindingsDict: keys are shortcuts, values are g.bunches with the following
    members: func, name, warningGiven, fromMenu.</t>
<t tx="ekr.20051028051444.11">The following helper functions make it easy to discover the binding presently in
effect for a command:

- k.getShortcutForCommandName(self,commandName) returns the shortcut given
  f.__name__.

- k.getShortcutForCommand(self,f) returns the shortcut for f.</t>
<t tx="ekr.20051028051444.12">@nocolor

c.keyHandlerregisterCommand (self,commandName,shortcut,func)

This function make the func available as a minibuffer command, and optionally
binds a shortcut to func. You can wrap any method in a function, so the
restriction to functions is not significant.

Here is an example take from an @button node::

@color

k = c.keyHandler

def f (event):
    g.es_print('Hello',color='purple')

k.registerCommand('print-hello','Alt-Ctrl-Shift-p',f)
k.registerCommand('print-hello2',None,f)</t>
<t tx="ekr.20051028051444.13">The following bugs exist in 4.3 final.</t>
<t tx="ekr.20051028051444.14">This makes it much harder to hang Leo after taking an exception. Leo 4.4a1 is
*much* more robust than Leo 4.3 final in this regard.</t>
<t tx="ekr.20051028051444.15">Added big kludge to menu.createMenuEntries so that f.OnCut/Copy/PasteFromMenu get called
**only** when explicitly selected from the menu (rather than from a shortcut).
This allows the code in cut/copy/paste-text to be different as needed.

Users can override the shortcut by assigning shortcuts to cut/copy/paste-text commands.
The shortcut will appear in the menu, but does **not** get bound to c.frame.menu.

This is an essential step in solving the infamous Control-V problem.
The code appears to work properly on XP.  Not tested other places.

This is the last best hope to solve this problem: the code interacts as little as possible with Tk.</t>
<t tx="ekr.20051028051444.16">http://sourceforge.net/forum/message.php?msg_id=3351985

Leo did not read empty tnodes like &lt;t/&gt; properly.</t>
<t tx="ekr.20051028051444.17"></t>
<t tx="ekr.20051028051444.18">http://sourceforge.net/forum/message.php?msg_id=3376527</t>
<t tx="ekr.20051028051444.19">It now computes the minimum leading whitespace of all non-blank lines. The old
code computed the leading whitespace of the *first* non-blank line. This would
give the wrong results if the first line were indented.</t>
<t tx="ekr.20051028051444.2">The most important new features of Leo 4.4 have to do with key bindings.

See the children of this node for details.


</t>
<t tx="ekr.20051028051444.4"></t>
<t tx="ekr.20051028051444.5">1. The minibuffer exists regardless of this setting, but will not be shown
   initially if it is False.

2. Hiding the minibuffer does not change any bindings or the operation of Leo in
   any other way. Therefore, if you do hide the minibuffer initially, and never
   want to use it, you should not bind shortcuts to any commands that use the
   minibuffer.

3. You can execute the show-mini-buffer, hide-mini-buffer and toggle-mini-buffer
   commands (or any other minibuffer command!) if the minibuffer is hidden.
   Indeed, the following will work even if the minibuffer is hidden.

       &lt;alt-x&gt;show-mini-buffer&lt;return&gt;</t>
<t tx="ekr.20051028051444.6">This options controls whether Leo creates a Cmds menu.

This menu is not ready yet, though nothing bad happens if this option is True.</t>
<t tx="ekr.20051028051444.7">http://sourceforge.net/forum/message.php?msg_id=3355954

'body_text_selection_background_color'  Default is 'Gray80'
'body_text_selection_foreground_color'  Default is 'white'</t>
<t tx="ekr.20051028051444.8">- The contract-and-go-right command moves to the parent node and collapses the
parent node.

- The goto-first-sibling and goto-last-sibling commands allow rapid movement
through an ouline without collapsing nodes.

- The print-bindings and print-commands show what commands exist and what keys
are bound to them.

- The help command gives a brief quick start introduction to Leo's Emacs-like
features.</t>
<t tx="ekr.20051028051444.9"></t>
<t tx="ekr.20051028051616"></t>
<t tx="ekr.20051028051616.1"></t>
<t tx="ekr.20051028051616.160">@nocolor

The scripting plugin has been improved as follows:

1. You can bind shortcuts in @button nodes.  Like this:

@button name @key=shortcut

This binds the shortcut to the script in the script button. The button's name is
'name', but you can see the full headline in the status line when you move the
mouse over the button. This is a clean and simple way of discovering the
shortcut.

2. You can create your own minibuffer commands with @command nodes.

A node whose headline has the form:

@command command-name

a new minibuffer command whose name is 'command-name'.

A node whose headline has the form:

@command command-name @key=shortcut

creates new minibuffer command and binds shortcut to it.

3. The scripting plugin no longer contains the 'bindLate' code-level option. The
scripts for all @button or @command nodes are computed 'dynamically', that is,
when the button is pushed or the command is executed from the minibuffer. This
is the most useful way, and the most intuitive.

Previously, scripts for @button nodes were never dynamic, while scripts in
@button nodes created by the 'Script button' button were dynamic only if
bindLate was True. You could call this a bug: it was unhelpful, annoying and
confusing.

4. The scripting plugin no longer prints an 'end of script' message. This allows
scripts to select tabs in the log pane</t>
<t tx="ekr.20051028051616.172">@color

# Plugins and scripts can easily create new tabs in the log panel.
# Important: you can run any of these examples using the 'Run Script' button.

# To create a tab named "Test" or make it visible if it already exists:
 
c.frame.log.selectTab('Test')

# When first created, a tab contains a text widget.
# To write to this widget, add the tabName argument to g.es:

g.es('Test',color='blue',tabName='Test')

# Plugins and scripts can easily replace the default Text widget with other Tk widgets.
# c.frame.log.tabFrame contains the Tk.Frame that contains all the other widgets of the frame.
# c.frame.log.logCtrl contains the Tk.Text widget that is initially the only widget in this frame.
# So to remove this text widget just do:
    
c.frame.log.logCtrl.pack_forget()

# Now you can pack any other widgets into c.frame.log.tabFrame.

import Tkinter as Tk ; log = c.frame.log
log.selectTab('Test')
log.logCtrl.pack_forget()
f = Tk.Frame(log.tabFrame,bg='red',height='1inch',width='2inch')
f.pack(side='left',expand=0,fill='none')</t>
<t tx="ekr.20051028051616.299">Leo can optionally generate matching brackets depending on the setting:

@bool autocomplete-brackets = TrueOrFalse

If True, Leo will immediately type the corresponding closing bracket whenever
you type a '(', '[' or '{' character. You can use the forward-char command to
move past the closing bracket, and Leo will move past any closing bracket if you
type the closing bracket with the cursor just to the left of a closing bracket.</t>
<t tx="ekr.20051028061322">**Important**: The print-bindings and print-commands commands (new in a1) show
what commands exist and what keys are bound to them.

- The help command tells how to use the minibuffer.

- The show-minibuffer, hide-minibuffer and toggle-mini-buffer commands show and hide the minibuffer.

It *is* possible to execute these command even if the minibuffer isn't presently
visible. For example, typing 

&lt;alt-x&gt;toggle-mini-buffer&lt;return&gt;

should always work.

- The open-find-tab command opens the Find tab. The Find tab replaces the old
Find panel. The Find panel is deprecated.

- The open-spell-tab command opens the Spell-checking tab.

- The show-colors command creates the 'Colors' tab in the log pane. This tab allows you to
experiment with picking fonts.

- The show-fonts command creates the 'Fonts' tab in the log pane. This tab allows you to
experiment with picking colors.</t>
<t tx="ekr.20051101161405">At the bottom of Leo's window you will now see an area labeled the mini-buffer.
You can't type in it directly, you activate the buffer by typing Alt-x or Alt-c.
Typing Alt-x takes you to 'full-command' mode. Type the full name of a command,
followed by a 'return'. 

- To get help, type Alt-x help.
- For a list of commands, type Alt-x print-commands.
- For a list of present key bindings, type Alt-x print-bindings.
- To leave the mini-buffer at any time type Ctrl-g.

Note: you can redefine any of these keys as you wish.

Important: you can execute any of Leo's 'legacy' commands from the mini-buffer.
For example, Alt-x about-leo or Alt-x open-find-dialog. Note: Leo's Find
*dialog* is deprecated. You will find it much more convenient to use Leo's new
Find *tab*. Use the open-find-tab command.

You can use tab-completion in the minibuffer to cycle through the list of
commands that start with what is in the buffer. Typing backspace takes you back
to the what you previously typed (less on character.) The 'Completion' tab shows
all possible completions. This tab appears automatically when you type a tab in
the minibuffer.

The mini-buffer reduces the need for shortcuts dramatically. For example, none
of Leo's import commands need a shortcut because it is easy enough to execute
them from the minibuffer. In particular, executing commands from the minibuffer
is much easier than executing commands by hand from a menu. </t>
<t tx="ekr.20051101161405.1">leoSettings.leo contains one functional @shortcuts node and one disabled
@@shortcuts node. These node contain entries for every command.

You can assign key shortcuts to any command, as discussed in the comments in
that file. You can leave the nodes as they are, use them as base for
modifications, or roll your own. You should define a binding for every function,
even if that binding is 'None'. If you don't, Leo will issue a warning.

Leo now supports per-pane bindings.  Bindings of the form:

command-name ! pane = shortcut

bind the shortcut to the command only withing a single pane. The possible values
for 'pane' are:

pane    affected panes
----    --------------
all     body,log,tree
body    body
log     log
mini    minibuffer
text    body,log
tree    tree</t>
<t tx="ekr.20051101161405.2">The scripting plugin has been improved in two ways:

1. You can specify key bindings in @button nodes as follows:

@button name @key=shortcut

This binds the shortcut to the script in the script button. The button's name is
'name', but you can see the full headline in the status line when you move the
mouse over the button.

2. You can create new minibuffer commands with @command nodes:

@command name @key=shortcut

This creates a new minibuffer command and binds shortcut to it.</t>
<t tx="ekr.20051101161405.3">Abbreviations may not work at present. A new kind of abbreviation is presently
hard coded in add_ekr_altx_commands in leoKeys.py. For example, one ekr-shortcut
is: 'f', which is bound to leo-find-panel. Typing Alt-x f Return executes
leo-find-panel. These may be quicker than Emacs abbreviations, or not.</t>
<t tx="ekr.20051101161949"></t>
<t tx="ekr.20051101162123">These 'hard-coded' bindings are no longer needed and interfere with per-pane bindings.</t>
<t tx="ekr.20051101162123.1">- The open-find-tab command opens the Find tab.

- The open-spell-tab command opens the Spell-checking tab.

The Find and Spell *tabs* replace the corresponding legacy *dialogs*. Using tabs
eliminates previous problems with dialogs obscuring Leo's main window.

Two essential components of the settings dialog now are implemented in the tabbed log:

- The show-colors command creates the 'Colors' tab in the log pane.

- The show-fonts command creates the 'Fonts' tab in the log pane.

These two tabs allow you to pick color or font names without using the @settings dialog.

Important: scripts and plugins can easily create new tabs in the Log pane. See
Chapter 7 of the Users Guide for details.</t>
<t tx="ekr.20051101162947">Leo's core now supports tabs in the log pane.</t>
<t tx="ekr.20051101163145">Leo 4.4a2 contains a large number of code-level improvements--some very
significant. For full details, see the (Projects) section of LeoPy.leo.</t>
<t tx="ekr.20051101163404">The following bugs existed in the 4.4a1 code base and have now been fixed:

- Removed warnings from compare dialog.</t>
<t tx="ekr.20051101171734">Tk/Tkinter make it easy to customize the contents of any of Leo's panes. The
following sections will discuss the 'official' ivars that make it possible for
scripts to access and alter the contents of panes. The next three sections will
give examples of modifying each pane.</t>
<t tx="ekr.20051101182739">- The node::

    @shortcuts traditional Leo shortcuts with important emacs bindings

contains Leo key bindings.

- The spelling settings in leoSettings.leo replace the settings in spellpyx.ini.

- You can specify the background of tabs using the following pattern::

    @color log_pane_XXX_tab_background_color = aColor

For example::

    @color log_pane_Find_tab_background_color = #d6c7d3

- The @bool autocomplete-brackets setting controls whether Leo types a matching
closing bracket immediately when you type '(', '[' or '{'.</t>
<t tx="ekr.20051109112610"></t>
<t tx="ekr.20051109112826">@nocolor

The New World Order means that drawing happens immediately, not at idle time.

The Newer World Order means that c.endUpdate is equivalent to c.redraw_now.</t>
<t tx="ekr.20051109112826.217">http://sourceforge.net/forum/message.php?msg_id=3411030

The fix was to add guards so the code does not assume w._name exists for all widgets w.</t>
<t tx="ekr.20051109112826.222">Scripts.leo contains general-purpose scripts.

unitTest.leo contains all of Leo's unit tests.

test.leo is now for recent tests.  Its small size speeds up my workflow.</t>
<t tx="ekr.20051109112826.223">Changed the following plugins:

cleo.py, footprints.py,__wx_gui.py, zodb.py</t>
<t tx="ekr.20051109112826.224">Removed tree.redrawScheduled, tree.updateCount and tree.disableRedraw

Three major complications are gone.</t>
<t tx="ekr.20051109112826.227"></t>
<t tx="ekr.20051109112826.254">http://sourceforge.net/forum/message.php?msg_id=3412644

You can invoke minibuffer commands by name.  For example:

c.executeMinibufferCommand('open-outline')

Note: c.keyHandler.funcReturn contains the value returned from the command. In
many cases, as above, this value is simply 'break'.</t>
<t tx="ekr.20051109112826.257">For now, I just set c.useTextMinibuffer = False,
so Leo uses a Tk.Label rather than a Tk.Text widget.

This will cause less confusion than always having the minibuffer enabled.</t>
<t tx="ekr.20051109112826.265">http://sourceforge.net/forum/message.php?msg_id=3415021

The code now uses the settings in leoSettings.leo.</t>
<t tx="ekr.20051109112826.310">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3414639

The entries for Perl and Perlpod are now as follows:

@color

self.language_extension_dict = {
    "perl" : "pl",
    "perlpod" : "pod",
}

self.extension_dict = {
    "pl"    : "perl",
    "pod"   : "perlpod",
}</t>
<t tx="ekr.20051109112826.315">http://sourceforge.net/forum/message.php?msg_id=3418304

Fixed an edge effect when backward searching for a match that occurs at the very
end of body text. In the process I removed an ancient hack.</t>
<t tx="ekr.20051109141223"></t>
<t tx="ekr.20051109141524"></t>
<t tx="ekr.20051109141524.1"></t>
<t tx="ekr.20051109142920">This code should never have existed.  It was used only in the macro plugin.</t>
<t tx="ekr.20051128181229"></t>
<t tx="ekr.20051128181302.147"></t>
<t tx="ekr.20051128181302.148">The plugin can not call bodyWantsFocus.</t>
<t tx="ekr.20051128181302.149">Later may never come in the Newer World Order, so everything must happen immediately.</t>
<t tx="ekr.20051128181302.150">This ensures that the widget is always visible.</t>
<t tx="ekr.20051128181302.151"></t>
<t tx="ekr.20051128181302.156">http://sourceforge.net/forum/message.php?msg_id=3425070

This code was contributed by Roger Erens.

When the Clone Find All checkbox is checked, the Find All command creates a new
root node called Found: &lt;your search pattern&gt;

This node contains clones of the nodes found by the Find All command. It is your
own responsibility to navigate to this new node and to clean it up when it's no
longer needed.</t>
<t tx="ekr.20051128181302.171">The tab now scrolls properly.</t>
<t tx="ekr.20051128181302.183">http://sourceforge.net/forum/message.php?msg_id=3434727

- Added calls to c.frame.body.onBodyChanged in cut/paste handlers.

- Added call to c.selectPosition(c.currentPosition()) in undo/redo.
    This is essential because previous calls to c.selectPosition may have had redraw_flag = False.</t>
<t tx="ekr.20051128181302.192"></t>
<t tx="ekr.20051128181302.193">http://sourceforge.net/forum/message.php?msg_id=3425967

When creating a new Leo outline (no leo file created yet), the Save As command
created the file Test4.leo instead of the expected Test4.3.leo</t>
<t tx="ekr.20051128181302.196"></t>
<t tx="ekr.20051128181302.204">http://sourceforge.net/forum/message.php?msg_id=3427809

Allowed relative path to stylesheets.

http://sourceforge.net/forum/message.php?msg_id=3433717

The rst3 plugin now traverses the tree as was done previously in the @button rst3 nodes.

http://sourceforge.net/forum/message.php?msg_id=3456419

The rst3 plugin now looks up and down the tree for settings doc parts.

The rst3 plugin now supports the default_path option.</t>
<t tx="ekr.20051128181302.208">@nocolor

- The focusIn/Out trace is a great tool.

- doTabCompletion now calls w.update before calling bodyWantsFocus.

- Eliminated w.update from g.app.gui.set_focus.  It is now called only in
those places where it is truly essential, such as in k.doTabCompletion and
wherever else it might be required.

- Pmw.Notebook does a *lot* when it switches panes (e.g., the _layout method)
and potentially any of the things it does could result in focus shifting to
widget. Rather than trying to make sense of it all, Leo will simply call
w.update as necessary to force completion of the Pmw.Notebook work before trying
to set focus.</t>
<t tx="ekr.20051128181302.211"></t>
<t tx="ekr.20051128181302.213">http://sourceforge.net/forum/message.php?msg_id=3440420

Added @string vim_cmd and @string vim_exe settings. The defaults now correspond
to default installations of vim.</t>
<t tx="ekr.20051128181302.214">http://sourceforge.net/forum/message.php?msg_id=3436726

The dialog warns about the extensions folder not containing Pmw. This can happen
when getting files from cvs.</t>
<t tx="ekr.20051128181302.229">http://sourceforge.net/forum/message.php?msg_id=3437089

The new default binding causes focus to move to the body pane when the user hits
&lt;Return&gt; to end editing in a headline.</t>
<t tx="ekr.20051128181302.231">http://sourceforge.net/forum/message.php?msg_id=3442064

This was not, in fact, a problem with the plugins manager plugin.

The bug was in &lt;&lt; put up a dialog requiring a valid id &gt;&gt; in app.setLeoID.
The code set g.app.gui to None after calling g.app.gui.runAskLeoIDDialog the code set!

While I was at it, Leo's core now always inits Pmw when creating Tk.Tk. This
removes the necessity for Plugins to do this.</t>
<t tx="ekr.20051128181302.244">1: Outline not marked dirty during editing

https://sourceforge.net/forum/message.php?msg_id=3447570

2: Inserting a headline didn't save previous edits of headlines</t>
<t tx="ekr.20051128181351"></t>
<t tx="ekr.20051128181651">Leo 4.4a4 completes the transition to the 'Newer World Order'.</t>
<t tx="ekr.20051128181651.1"></t>
<t tx="ekr.20051202072010"></t>
<t tx="ekr.20051205090923.13"></t>
<t tx="ekr.20051205090923.16">http://sourceforge.net/forum/message.php?msg_id=3450435</t>
<t tx="ekr.20051205090923.22">http://sourceforge.net/forum/message.php?msg_id=3389810</t>
<t tx="ekr.20051205091625">- The abbreviation and buffer commands are not ready yet.

- repeat-complex-command does not work.

- Moving the cursor when the 'mark' has been defined does not expand the visibly
selected text.

- Yanking and killing have not been well tested.

- C-u 5 &lt;return&gt; works but is not undone properly. Also, the kill-line command
does not work as in Emacs.

- Many new commands must be generalized to handle the more complex environment
Leo offers. For example, search commands must be told whether to limit the
search a single node, or a node or and its descendants, or the entire outline.
We need a set-variable command that sets a (Python) variable using an
emacs-style variable name.

- The notion of the 'point' must be expanded so it indicates a node as well as
text location.
    
- New commands are needed to support 'mouseless-Leo'. The user must be able to
drive all dialogs from the keyboard, or to get the same effect without using a
dialog at all. Examples: dismiss-top-dialog, scroll-outline-up/down. We also
need commands to change focus and to manage menus. Examples: focus-in-body,
focus-in-tree, etc, activate-edit-menu, etc.</t>
<t tx="ekr.20051219150602">Leo 4.4 alpha 5                                             January 6, 2006

This release completes the last major features of Leo 4.4:

- User-specified key-binding modes.
- Support for multiple key-bindings for individual minibuffer commands.

This will be the last alpha version of Leo 4.4. Beta 1 is coming in about a
week. You should be able to use this version safely; there are no known serious
bugs.

To learn about Leo, see: http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
----------------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name. Support for tab completion.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Support for most commands in the Emacs Cmds menu, including cursor and screen
movement, basic character, word and paragraph manipulation, and commands to
manipulate buffers, the kill ring, regions and rectangles.

- Per-pane key bindings. You can bind shortcuts to multiple commands depending
on which of Leo's panes presently has focus. For example, you can use arrow keys
to move nodes in the outline pane, while retaining their defaults in Leo's body
pane.

- User-specified key-binding modes. This feature makes it possible to emulate all
aspects of Emacs and Vim as far as key bindings are concerned.

- @command nodes create minibuffer commands. You can bind key shortcuts to
@button and @command nodes.

- Leo recovers from crashes much more reliably than in any previous version.

- Leo handles keystrokes and updates the screen immediately rather than waiting
for idle time.</t>
<t tx="ekr.20051219150602.10">http://sourceforge.net/forum/message.php?msg_id=3464874</t>
<t tx="ekr.20051219150602.100"></t>
<t tx="ekr.20051219150602.101">The provide batch-mode unit testing.</t>
<t tx="ekr.20051219150602.102"></t>
<t tx="ekr.20051219150602.105">Leo now supports the following commands, shown below with their present bindings:

back-char ! text = LtArrow
back-char-extend-selection ! text = Shift-LtArrow
back-paragraph ! text = Alt-braceleft 
back-paragraph-extend-selection ! text = Alt-Shift-braceleft
back-sentence ! text = Alt-a 
back-sentence-extend-selection  = None
back-word ! text = Alt-b  # No conflict   
back-word-extend-selection  ! text = Alt-Shift-b
beginning-of-buffer ! text = Alt-less # Note: same as Alt-Shift-less
beginning-of-buffer-extend-selection  = None
beginning-of-line ! text = Ctrl-a
beginning-of-line-extend-selection = None
exchange-point-mark = None
forward-char ! text = RtArrow
forward-char-extend-selection ! text = Shift-RtArrow
forward-paragraph ! text = Alt-braceright
forward-paragraph-extend-selection ! text = Alt-Shift-braceright
forward-sentence ! text = Alt-e
forward-sentence-extend-selection ! text = Alt-Shift-e
forward-word ! text = Alt-f
forward-word-extend-selection ! text = Alt-Shift-f
next-line ! text = DnArrow
next-line-extend-selection  ! text = Shift-DnArrow
previous-line ! text = Uparrow
previous-line-extend-selection ! text = Shift-UpArrow

The -extend-selection variants move the cursor and also extend the selection
from the insert point in the indicated direction. As usual exchange-point-mark
switches the insert point from one side of the selection to the other: which
side of the selection the insert point is on does make a difference.

I also added three commands that implement so-called 'extend mode':

clear-extend-mode = None
set-extend-mode = None
toggle-extend-mode = None

When extend mode is on (it is off at first), all cursor movement commands listed
above extend the selection. Very handy. Thanks to Brian for this suggestion.

This is the start of mouseless Leo. For the first time all the common Emacs
cursor-movement commands exist. These commands should work in any text widget.</t>
<t tx="ekr.20051219150602.13">http://sourceforge.net/forum/message.php?msg_id=3466412

New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user
completes the editing of a headline, and ch is always '\r', regardless of
platform.

http://sourceforge.net/forum/message.php?msg_id=3462294</t>
<t tx="ekr.20051219150602.2"></t>
<t tx="ekr.20051219150602.28">http://sourceforge.net/forum/message.php?msg_id=3467558

What I did:

- atFile.readError deletes root's entire subtree.
- atFile.read only warns about unvisited node if there is no error.
</t>
<t tx="ekr.20051219150602.3"></t>
<t tx="ekr.20051219150602.7"></t>
<t tx="ekr.20051219150602.75">http://sourceforge.net/forum/message.php?msg_id=3461068

And a recent bug: clicking in the expand/contract box didn't save the headline.</t>
<t tx="ekr.20051219150602.81">The problem was caused by the recent change to g.app.gui.setTextSelection.

The default for the new 'insert' keyword must be sel.end for compatibility with old code.</t>
<t tx="ekr.20051219150602.85">Read @file Nodes and Import external file commands no longer create copies of the root node.</t>
<t tx="ekr.20051219151926">leoSettings.leo now contains a node called:

@@shortcuts traditional Leo bindings

This node contains the 'classic' Leo key bindings that appeared in Leo 4.3. I
have proofed these settings carefully, but some errors may remain. Please report
any errors or any other suggestions for these settings.</t>
<t tx="ekr.20060105145125">You must install the Aspell package if you want to use Leo's Spell tab.

1.  Download and install the Aspell package from http://aspell.sourceforge.net/
    Typically this will create a directory called Aspell/bin

2.  Specify the location of the Aspell and Aspell/bin directories using
    the aspell_dir and aspell_bin_dir settings in LeoSettings.leo.
</t>
<t tx="ekr.20060105182648.376">Leo no longer creates a duplicate root node when importing external files.

The code is due to LeoUser.</t>
<t tx="ekr.20060105182648.377"></t>
<t tx="ekr.20060105182648.378"></t>
<t tx="ekr.20060105182648.379"></t>
<t tx="ekr.20060105182648.382">The reason for this assert is unclear.</t>
<t tx="ekr.20060105182648.432"></t>
<t tx="ekr.20060105182648.469">This is the end of the ill-fated settings dialog.

Important: you can use the show-colors and show-fonts commands to help set
colors and fonts in leoSettings.leo.</t>
<t tx="ekr.20060105214753">Leo now allows you to specify input modes. You enter mode x with the
enter-x-mode command. The purpose of a mode is to create different bindings
for keys within a mode. Often plain keys are useful in input modes.

You can specify modes with @mode nodes in leoSettings.leo. @mode nodes work
just like @shortcuts nodes, but in addition they have the side effect of
creating the enter-&lt;mode name&gt;-mode command.

Notes:

- You can exit any mode using the keyboard-quit (Control-g) command. This is the
  **only** binding that is automatically created in each mode. All other bindings
  must be specified in the @mode node. In particular, the bindings specified in
  @shortcuts nodes are **not** in effect in mode (again, except for the
  keyboard-quit binding).

- Leo supports something akin to tab completion within modes: if you type a key
  that isn't bound in a mode a 'Mode' tab will appear in the log pane. This tab
  shows all the keys that you can type and the commands to which they are bound.
  The mode-help command does the same thing.

- @shortcuts nodes specify the bindings for what might be called the 'top-level'
  mode. These are the bindings in effect when no internal state is present, for
  example, just after executing the keyboard-quit command.

- The top_level_unbound_key_action setting determines what happens to
  unbound keys in the top-level mode. Leo ignores unbound keys in all other modes.
  The possibilities are 'insert', 'replace' and 'ignore'.

- The set-insert-mode, set-overwrite-mode and set-ignore-mode
  commands alter what happens to unbound keys in the top-level mode.

With all these options it should be possible to emulate the keyboard behavior of any other editor.</t>
<t tx="ekr.20060111192108">A **dangerous** delete is a deletion of a node so that all the data in the node
is deleted *everywhere* in an outline. The data is gone, to be retrieved only
via undo or via backups. It may not be obvious which deletes are dangerous in an
outline containing clones. Happily, there is a very simple rule of thumb::

    Deleting a non-cloned node is *always* dangerous.
    Deleting a cloned node is *never* dangerous.

We could also consider a delete to be dangerous **if it results in a node being
omitted from an external file.** This can happen as follows. Suppose we have the
following outline (As usual, A' indicates that A is marked with a clone mark)::

    - @thin spam.py
        - A'
            - B
    - Projects
        - A'
            - B

Now suppose we clone B, and move the clone so the tree looks like this::

    - @thin spam.py
        - A'
            - B'
    - Projects
        - A'
            - B'
        - B'

If (maybe much later), we eliminate B' as a child of A will get::

    - @thin spam.py
        - A'
    - Projects
        - A'
        - B

B has not been destroyed, but B is gone from @thin spam.py! So in this sense deleting a clone node can also be called dangerous.</t>
<t tx="ekr.20060116174906">Leo 4.4 beta 1                                             January 17, 2006

The code is stable; there are no known serious bugs. Some features are
incomplete.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060116174906.100">https://sourceforge.net/forum/message.php?msg_id=3514627

c.endUpdate now restores the previous focus by default.</t>
<t tx="ekr.20060116174906.103"></t>
<t tx="ekr.20060116174906.104">http://sourceforge.net/forum/message.php?msg_id=3514755
</t>
<t tx="ekr.20060116174906.113">http://sourceforge.net/forum/message.php?msg_id=3515341</t>
<t tx="ekr.20060116174906.118">http://sourceforge.net/forum/message.php?msg_id=3509141

Problems with cleo.  Installed patch: http://sourceforge.net/forum/message.php?msg_id=3517080

https://sourceforge.net/forum/message.php?msg_id=3515025

Problems with fastgotonode and and groupOperations.</t>
<t tx="ekr.20060116174906.122">http://sourceforge.net/forum/message.php?msg_id=3518722

To generate HTML file I entered the outline header "@file bbb.xml" under which
I put the following body text:

//////////////// beginning of excerpt
@first &lt;?xml version="1.0" encoding="windows-1250" ?&gt;
@language html
@
comment line
@c
@others
//////////////// end of excerpt

This works OK.
But, if I put a space after the sole @ above "comment line",  save and close
the .leo file and then open it, Leo protests in log pane on the right:

//////////////// beginning of excerpt
----- error reading @file: bbb.xml
Missing open block comment
//////////////// end of excerpt</t>
<t tx="ekr.20060116174906.125">This corrects a problem that shows up as 'Invalid cross-device link' messages on Linux.

http://sourceforge.net/forum/message.php?msg_id=3519803</t>
<t tx="ekr.20060116174906.130">These should be considered bug fixes.

- copyBindingsToWidget now binds keys in priority order. This also simplifies
and clarifies the code.

- Removed k.onTextWidgetKey.  Added a callback that invokes k.masterCommand.</t>
<t tx="ekr.20060116174906.160">Hitting Backspace immediately put the focus in the log. Another backspace put
the focus in the body pane.

The problem was in log.clearTab.  It must do call t.update().</t>
<t tx="ekr.20060116174906.163"></t>
<t tx="ekr.20060116174906.164"></t>
<t tx="ekr.20060116174906.185">extensionHelper resets movePoint any time there is no selection.</t>
<t tx="ekr.20060116174906.187"></t>
<t tx="ekr.20060116174906.194">The fix was to call endUpdate() rather than endUpdate(changed) in onHeadChanged.</t>
<t tx="ekr.20060116174906.195"></t>
<t tx="ekr.20060116174906.198">g.top and the associated g.app.log logic is inherently unreliable.</t>
<t tx="ekr.20060116174906.199">This allows code to determine in a standard way whether a window is in the process of being destroyed.</t>
<t tx="ekr.20060116174906.2"></t>
<t tx="ekr.20060116174906.213">This includes k.masterCommand and all event handlers.
</t>
<t tx="ekr.20060116174906.255">Leo now calls doCommand on all commands, so the 'command' hooks and error
processing always get done.</t>
<t tx="ekr.20060116174906.257"></t>
<t tx="ekr.20060116174906.258"></t>
<t tx="ekr.20060116174906.259">@nocolor</t>
<t tx="ekr.20060116174906.262"></t>
<t tx="ekr.20060116174906.263">http://sourceforge.net/forum/message.php?msg_id=3518792

EKR: The change in focus happened in c.endEditing in at.writeFromString.

I added a new restoreFocus keyword arg to c.endEditing.</t>
<t tx="ekr.20060116174906.267"></t>
<t tx="ekr.20060116174906.272">http://sourceforge.net/forum/message.php?msg_id=3515616

Could we have a visible-line-up and visible-line-down command? (I.e. to move
the cursor up or down by a visible rather than a logical line).  With these
commands, the arrows plugin could be permanently retired!

What I did:

- next-line and prev-line now work as requested.  This obsoletes the arrow plugin.
    - Removed the redundant tree.OnUpKey and tree.OnDownKey
    - Retired the arrows plugin.

- Created the extendHelper method.
    This creates and maintains the moveSpot, moveCol an moveSpotNode ivars,
    and is responsible for extending the selection range.</t>
<t tx="ekr.20060116174906.296">Still to do:

Specify what mode to enter after each command:

- command-name -&gt; mode-name = binding

will specify what mode to enter after each command.
At present, all commands exit to the top-level mode.

- Add @string active-keyset setting?</t>
<t tx="ekr.20060116174906.3">A 'backward' delete at the start of a headline deletes the first character.
delete-char did not work in headlines.</t>
<t tx="ekr.20060116174906.306"></t>
<t tx="ekr.20060116174906.63">http://sourceforge.net/forum/message.php?msg_id=3465251</t>
<t tx="ekr.20060116174906.86">http://sourceforge.net/forum/message.php?msg_id=3495741

The plugin now uses sys.getdefaultencoding() to set the encoding.</t>
<t tx="ekr.20060116174906.87">This could have been the source of weird find behavior.</t>
<t tx="ekr.20060116174906.88">The fix was to have x.getSelectedText return '' instead of None.</t>
<t tx="ekr.20060116174906.90">http://sourceforge.net/forum/message.php?msg_id=3510983</t>
<t tx="ekr.20060116174906.97"></t>
<t tx="ekr.20060206111508">Leo 4.4 beta 2                                              February 14, 2006

This version fixes dozens of bugs, improves performance and polishes the user
interface. The code is stable; there are no known serious bugs.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4b2:
----------------------------
- Much better 'fit and finishes'.
- New commands that support mouseless Leo.
- Minibuffer search commands provide all features of Leo's legacy search commands.
- User modes are fully functional and you can create special bindings for the minibuffer.
- New master key and click handlers and improved allocation of screen widgets.

Coming in Leo 4.4b3:
--------------------
- A revived chapters plugin.
- Autocompleter Tab.
- Improved incremental searches.

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060206111508.103">The outline jumps around too much when expanding/contracting nodes
</t>
<t tx="ekr.20060206111508.136"># This is required now that scrolling is disabled by default.</t>
<t tx="ekr.20060206111508.14">@nocolor

What I did:
    
- endMode must not change focus.

- modeHelp calls c.endEditing(retainFocus=True)

@color</t>
<t tx="ekr.20060206111508.2"></t>
<t tx="ekr.20060206111508.3">@nocolor

Must check for c.exists in c.executeScript after executing the script.</t>
<t tx="ekr.20060206111508.4">@nocolor

- keyboard-quit now ends editing.

- print-bindings shows plain keys only in 'ignore' mode.

- Removed k.add_ekr_altx_commands and k.makeHardBindings.

- Added binding to vim plain shortcuts: mode-help = h

- Print the initial mode when first creating a window.
  The change had to be made in g.openWithFileName because of the UNL plugin.

- Improved print-bindings &amp; mode help.

- endMode retains the widget on entry, so e.g., inserting a new node retaining the headline editing state.

@color
</t>
<t tx="ekr.20060206111508.40"></t>
<t tx="ekr.20060206111508.48">
</t>
<t tx="ekr.20060206111508.49">Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 250, in doCommand
    val = command() # Call legacy command

  File "C:\prog\leoCVS\leo\src\leoTkinterFrame.py", line 1777, in cutText
    oldText = w.get('1.0','end')

AttributeError: Canvas instance has no attribute 'get'</t>
<t tx="ekr.20060206111508.5">@nocolor

- Added initialClickExpandsOrContractsNode settings.  Clicking an node expands or contracts the node if this setting is True.  EKR much prefers False. 

- Selecting a headline should not select text in it.

@color
</t>
<t tx="ekr.20060206111508.54"></t>
<t tx="ekr.20060206111508.547">- Replaced frame.xWantsFocus with c.xWantsFocus.
- Added event arg to all legacy commands.
- Replaced k.tkBindingFromSetting by k.shortcutFromSetting.
- Replaced k.canonicalizeShortcut by k.shortcutFromSetting.
- Replaced k.bindShortcut with bindKey.
- k.makeBindingsFromCommandsDict does not call k.bindKey for mode bindings.
- Call update_idletasks when writing to the log.
- Updated selection point immediately in masterKeyHandler.
  Otherwise, updateStatusLine would be one click behind.</t>
<t tx="ekr.20060206111508.550">@nocolor

This is logically and practically dubious.
True, a screen redraw shouldn't mess with the focus,
but there are the following problems:

1. c.endUpdate can happen anytime, and it could interfere with other efforts to set focus.
2. g.app.get_focus might get the 'wrong' or a 'bad' focus.</t>
<t tx="ekr.20060206111508.553"></t>
<t tx="ekr.20060206111508.58"></t>
<t tx="ekr.20060206111508.596">A *major* improvement to the tree allocation code:

1.  Use p.key() to as keys to tree.visibleText.
 This greatly speeds up tree.findEditWidget

2. Eliminated the brain-dead requirement that previously-allocated widgets must match the position.
   - The allocation code just gets *any* previously allocated widget.
     This eliminates an n**2 search!
   - The ancient problem was that theId refers to the *window* not its Text widget:
     the *window* must be moved to the right spot.

3. recycleWidgets is simpler and a bit faster.

4. destroyWidgets now works: (the bug was not clearing tree.ids).</t>
<t tx="ekr.20060206111508.63"></t>
<t tx="ekr.20060206111508.74">Call w.see('insert'), not w.see('insert-5L')</t>
<t tx="ekr.20060206111508.75"></t>
<t tx="ekr.20060206111508.97"></t>
<t tx="ekr.20060206111600"></t>
<t tx="ekr.20060206111717.1"></t>
<t tx="ekr.20060206112001">- Improved format of print-commands and print-bindings commands.

- Eliminated clone-find-all, selection-only, show-context checkboxes
  when show_only_find_tab_options setting is True.

- All minibuffer find commands copy the find string from the Find tab into the minibuffer.

- The replace-string command sets up arguments for Tab find. This is different
  from the normal Emacs replace-string command, but it works well in Leo.

- Leo doesn't abort the minibuffer if the command does not exist.
  This is much more convenient.
</t>
<t tx="ekr.20060210070421">Leo's extensions folder contains Pmw in official distributions, but not in the
Cvs repository, so you won't be able to use a Leo in a sandbox unless you copy
Pmw to the extensions folder or have Pmw otherwise available on Python's path.</t>
<t tx="ekr.20060211104746.12">* Found the reason why focus was *still* sticking in the outline pane:
    - The click handlers must return 'break', not continue.
    - However, OnActivateHeadline must return 'continue' when the headline is active
      so that Tk will handle the click properly.

- UNL does not seem to be causing problems.

- No need to save/restore focus in status line.

- Added several new traces to tkTree class.

* tree.redraw_now now ends editing properly. This fixes lots of bugs. In
particular, it avoid any chance that p.edit_widget won't correspond to the
present position.

- k.masterClickHandler calls tree.OnDeactivate() if there is no callback function.
  This solves most headline focus problems, provided that all panes bind clicks to k.masterClickHandler.

- toggle-active-pane now ends editing properly.

- insert-headline now calls c.editPosition after calling c.endUpdate().</t>
<t tx="ekr.20060211104746.162">Backspace in empty body text sometimes moved focus to canvas, and sometimes
improperly drew icon.

Made several fixes to onBodyChanged. There was no test for unchanged text! This
could have created all sorts of problems for undo.</t>
<t tx="ekr.20060211104746.168">@ This revealed several problems:
    
- Most find dialog commands do not actually exist. All find commands except
open-find-dialog actual refer to the find tab.

- Several other minor shortcut problems.</t>
<t tx="ekr.20060211104746.177">http://sourceforge.net/forum/message.php?msg_id=3549737

for extend selection,
with binding to arrow keys,
if you switch from up to down arrow,
the selection restarts again.
this should just change extend direction
while still using the same selection.
</t>
<t tx="ekr.20060211104746.2">In the new drawing scheme, tree.redraw_now always calls c.endEditing, which
calls tree.onHeadChanged. The effect of this was to reverse the action of
undo/redoNodeContents.

The solution was to change the edit widget directly before calling
tree.redraw_now. To do this, I created the new tree.setHeadline method.</t>
<t tx="ekr.20060211104746.208"></t>
<t tx="ekr.20060211104746.346">select-all-text, move back/forward line/char, start/end-of-line.</t>
<t tx="ekr.20060212102459.4">All minibuffer search commands, with the exception of the isearch (incremental) commands, simply provide a minibuffer interface to Leo's legacy find commands.  This means that all the powerful features of Leo's legacy commands are available to the minibuffer search commands.

Note: all bindings shown are the default bindings for these commands.  You may change any of these bindings using @shortcuts nodes in leoSettings.leo.

Settings

leoSettings.leo now contains several settings related to the Find tab:

- @bool show_only_find_tab_options = True

When True (recommended), the Find tab does not show the 'Find', 'Change', 'Change, Then Find', 'Find All' and 'Change All' buttons.

- @bool minibufferSearchesShowFindTab = True

When True, Leo shows the Find tab when executing most of the commands discussed below.  It's not necessary for it to be visible, but I think it provides good feedback about what search-with-present-options does.  YMMY.  When True, the sequence Control-F, Control-G is one way to show the Find Tab.

Basic find commands

- The open-find-tab command makes the Find tab visible.  The Find tab does **not** need to be visible to execute any search command discussed below.

- The hide-find-tab commands hides the Find tab, but retains all the present settings.

- The search-with-present-options command (Control-F) prompts for a search string.  Typing the &lt;Return&gt; key puts the search string in the Find tab and executes a search based on all the settings in the Find tab.   This command is my 'workhorse' search command.

- The show-search-options command shows the present search options in the status line.  At present, this command also shows the Find tab.

Search again commands

- The find-tab-find command (F3) is the same as the search-with-present-options command, except that it uses the search string in the find-tab.  This is what I use as my default 'search again' command.

- Similarly, the find-tab-find-previous command (F2) repeats the command specified by the Find tab, but in reverse.

- The find-again command a combination of the search-with-present-options and find-tab-find command.  It is the same as the find-tab-find command if a search pattern other than '&lt;find pattern here&gt;' exists in the Find tab.  Otherwise, the find-again is the same as the search-with-present-options command.

Setting find options

- Several minibuffer commands toggle the checkboxes and radio buttons in the Find tab, and thus affect the operation of the search-with-present-options command. Some may want to bind these commands to keys. Others, will prefer to toggle options in a mode.


Here are the commands that toggle checkboxes: toggle-find-ignore-case-option, toggle-find-in-body-option, toggle-find-in-headline-option, toggle-find-mark-changes-option, toggle-find-mark-finds-option, toggle-find-regex-option, toggle-find-reverse-option, toggle-find-word-option, and toggle-find-wrap-around-option.

Here are the commands that set radio buttons: set-find-everywhere, set-find-node-only, and set-find-suboutline-only.

- The enter-find-options-mode (Ctrl-Shift-F) enters a mode in which you may change all checkboxes and radio buttons in the Find tab with plain keys.  As always, you can use the mode-help (Tab) command to see a list of key bindings in effect for the mode.

Search commands that set options as a side effect

The following commands set an option in the Find tab, then work exactly like the search-with-present-options command.

- The search-backward and search-forward commands set the 'Whole Word' checkbox to False.

- The word-search-backward and word-search-forward set the 'Whole Word' checkbox to True.

- The re-search-forward and re-search-backward set the 'Regexp' checkbox to True.

Find all commands

- The find-all command prints all matches in the log pane.

- The clone-find-all command replaces the previous 'Clone Find' checkbox.  It prints all matches in the log pane, and creates a node at the beginning of the outline containing clones of all nodes containing the 'find' string.  Only one clone is made of each node, regardless of how many clones the node has, or of how many matches are found in each node.

Note: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by the find-all and clone-find-all commands.

Search and replace commands

The replace-string prompts for a search string.  Type &lt;Return&gt; to end the search string.  The command will then prompt for the replacement string.  Typing a second &lt;Return&gt; key will place both strings in the Find tab and executes a **find** command, that is, the search-with-present-options command.

So the only difference between the replace-string and search-with-present-options commands is that the replace-string command has the side effect of setting 'change' string in the Find tab.  However, this is an extremely useful side effect, because of the following commands...

- The find-tab-change command (Ctrl-=) replaces the selected text with the 'change' text in the Find tab.

- The find-tab-change-then-find (Ctrl--) replaces the selected text with the 'change' text in the Find tab, then executes the find command again.

The find-tab-find, find-tab-change and find-tab-change-then-find commands can simulate any kind of query-replace command.  **Important**: Leo presently has separate query-replace and query-replace-regex commands, but they are buggy and 'under-powered'.  Fixing these commands has low priority.

- The find-tab-change-all command changes all occurrences of the 'find' text with the 'change' text.  Important: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by this command.

Incremental search commands

Leo's incremental search commands are completely separate from Leo's legacy search commands.  At present, incremental search commands do not cross node boundaries: they work only in the body text of single node.

Coming in Leo 4.4b3: the incremental commands will maintain a list of previous matches.  This allows for

a) support for backspace and
b) an incremental-search-again command.

Furthermore, this list makes it easy to detect the end of a wrapped incremental search.

Here is the list of incremental find commands: isearch-backward, isearch-backward-regexp, isearch-forward and
isearch-forward-regexp.'''</t>
<t tx="ekr.20060214074035.101"></t>
<t tx="ekr.20060214074035.12">http://sourceforge.net/forum/message.php?msg_id=3237845

On startup, it asked me for a unique id, "possibly your CVS username".
As a non-windows-user, that made no sense at all to me - at very least, it should
fill in os.getenv("USER") as a default, because it's right on non-windows systems,
isn't it?  (If it isn't, there's no explanation at that point that would tell
me otherwise, that's the value I used anyway...)  Just an out-of-box-experience
issue.</t>
<t tx="ekr.20060214074035.20">http://sourceforge.net/forum/message.php?msg_id=3534349
By: edcdave

Saving the Leo file is not sufficient - I have to exit the document and open
it again before the rst destination directory is set correctly.

The fix was to set c.frame.openDirectory in save.</t>
<t tx="ekr.20060214074035.41">The problem: event.widget is the minibuffer.  It must be the body text.

- k.fullCommand saves the initial event and passes it on to callAltXFunction.

- There was a bug in c.masterFocusHandler.  The correct test for 'no change' is:

    if c.hasFocusWidget and c.requestedFocusWidget == c.hasFocusWidget:

** Important: the 'extra' calls to set_focus are correct. The minibuffer messes
with the tab pane, and so we *must* be careful to yank the focus back to the
body.</t>
<t tx="ekr.20060214074035.6">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3549737

\src\leoEditCommands.py:340: 
Warning: 'yield' will become a reserved keyword 

for python2.2 leoEditCommands.py needs
from __future__ import generators

Also changed the following plugins:

at_produce.py
fastGotoNode.py
rst3.py
zodb.py</t>
<t tx="ekr.20060214074035.65">http://sourceforge.net/forum/message.php?msg_id=3538274

It's not clear that there were serious problems with the plugin, but I improved the code and error messages.  All features work for me.

Several plugins use the icon-double-click hook.  The reported problems could have been due to plugin conflicts.
</t>
<t tx="ekr.20060214074035.66">http://sourceforge.net/forum/message.php?msg_id=3517080
</t>
<t tx="ekr.20060214074035.67">http://sourceforge.net/forum/message.php?msg_id=3571431
By: ktenney

To reiterate a request:

When doing File-&gt;Open the default directory should the directory which
was navigated to for previous 'Open'

What I did:

- Defined g.app.globalOpenDir # The directory last used to open a file.</t>
<t tx="ekr.20060214074035.9">http://sourceforge.net/forum/message.php?msg_id=3549737

The fix was to call getBool rather than getString.</t>
<t tx="ekr.20060214083647">New settings:

- @int max_undo_stack_size
- @bool minibufferSearchesShowFindTab
- @bool show_only_find_tab_options

New debugging settings:

@bool allow_idle_time_hook
@bool gc_before_redraw
@bool show_tree_stats
@bool trace_bindings
@bool trace_doCommand
@bool trace_f.set_focus
@bool trace_focus = False
@bool trace_g.app.gui.set_focus
@bool trace_gc
@bool trace_gc_calls
@bool trace_gc_verbose
@bool trace_masterClickHandler
@bool trace_masterCommand
@bool trace_masterFocusHandler
@bool trace_masterKeyHandler
@bool trace_modes
@bool trace_redraw_now
@bool trace_select
@bool trace_tree
@bool trace_tree_alloc
@bool trace_tree_edit
@bool use_syntax_coloring
@string trace_bindings_filter
@string trace_bindings_pane_filter</t>
<t tx="ekr.20060214083808">Debugging commands:

- dump-all-objects, ump-new-objects, verbose-dump-objects.
- free-text-widgets.

Find commands:

See the child of this node for details.

- find-again.
- find-all and clone-find-all.
- find-tab-find command, find-tab-find-previous.
- find-tab-change, find-tab-change-all, find-tab-change-then-find.
- hide-find-tab, open-find-tab.
- re-search-forward and re-search-backward.
- replace-string.
- search-with-present-options.
- search-backward and search-forward.
- show-search-options.
- word-search-backward and word-search-forward.

Search options:

- set-find-everywhere, set-find-node-only, and set-find-suboutline-only.
- toggle-find-ignore-case-option, toggle-find-in-body-option,
  toggle-find-in-headline-option, toggle-find-mark-changes-option,
  toggle-find-mark-finds-option, toggle-find-regex-option,
  toggle-find-reverse-option, toggle-find-word-option, 
  toggle-find-wrap-around-option.

Mouseless Leo:

- activate-cmds-menu, activate-edit-menu, activate-file-menu activate-help-menu,
  activate-outline-menu, activate-plugins-menu, activate-window-menu.
- contract-body-pane, contract-log-pane, contract-outline-pane, contract-pane.
- expand-body-pane, expand-log-pane, expand-outline-pane, expand-pane.
- fully-expand-body-pane, fully-expand-log-pane, fully-expand-outline-pane, fully-expand-pane.
- hide-body-pane, hide-log-pane, hide-outline-pane, hide-pane.
- click-click-box, click-headline, click-icon-box, double-click-headline,
  double-click-icon-box, simulate-begin-drag, simulate-end-drag.
  (These commands trigger event hooks. In particular, double-click-icon-box will
  invoke the vim or xemacs plugins if they are enabled.)</t>
<t tx="ekr.20060214085054">The problem with focus 'sticking' in the Pmw.Notebook was due to a call to
bringToFront. Apparently, the side effect was to assign a focus to the widget
that had it previously. This makes sense, and can not be considered a Tk bug.

Remove almost all calls to w.update in Leo.

No more calls to w.after that were used to draw the status line. The master key
and click handlers now call the label update method directly. This may ease a
major stress on Tk.</t>
<t tx="ekr.20060214090742"></t>
<t tx="ekr.20060214092741">- @mode nodes in leoSettings.leo allow you to specify input modes with separate key bindings.

See the child of this node for full details.

- All key bindings specified with !mini pane specifier apply to all modes.

</t>
<t tx="ekr.20060215112429">Leo 4.4 experimental 1                                      February 15, 2006

This version is an emergency measure.  It's goals:

1.  To fix some of the key-handling issues in Leo 4.4 b2.
2.  To allow further experimentation with key handling.
3.  To allow easy reporting of any other key handling problems.

Please do not use this version (or Leo 4.4b2) unless you are ready to report bugs.

My apologies for the key handling problems in Leo 4.4 b2.  I hope this version will
be all that is necessary to fix those problems.

Here are the details of the key-handling changes:

- Added support for trace_key_event setting.
- Added support for ignore_caps_lock setting.
- Added Caps_Lock and Num_Lock to k.tkNamesList and in the list of
  special keys in k.masterCommand and k.masterKeyHandlerHelper.
- Added support for k.ignore_unbound_non_ascii_keys logic in masterKeyHandlerHelper.
- Disabled unknown keysym trace in k.strokeFromEvent.
- Enabled the international keyboard on XP as an aid to testing.
- Added support for swap_mac_keys setting in k.shortcutFromSetting.</t>
<t tx="ekr.20060215112429.2">extract                             = Shift-Ctrl-D
extract-names                       = Shift-Ctrl-N
extract-section                     = Shift-Ctrl-S  # Shift-Ctrl-E: end-of-line-extend-selection

write-at-file-nodes                 = Shift-Ctrl-W # Was enter-file-mode.
write-dirty-at-file-nodes           = Shift+Ctrl+Q

# Removed definitions of find and file modes.  I never used them.</t>
<t tx="ekr.20060215112429.3">http://sourceforge.net/forum/message.php?msg_id=3545403</t>
<t tx="ekr.20060215112429.6">The patch was reported at:

http://sourceforge.net/forum/message.php?msg_id=3577681
</t>
<t tx="ekr.20060215112429.9">http://sourceforge.net/forum/message.php?msg_id=3573470

What I did:

- Added support for trace_key_event setting.
- Added support for ignore_caps_lock setting.
- Added Caps_Lock and Num_Lock to k.tkNamesList and in the list of
  special keys in k.masterCommand and k.masterKeyHandlerHelper.
- Added support for k.ignore_unbound_non_ascii_keys logic in masterKeyHandlerHelper.
- Disabled unknown keysym trace in k.strokeFromEvent.
- Enabled the international keyboard on XP as an aid to testing.
- Added support for swap_mac_keys setting in k.shortcutFromSetting.</t>
<t tx="ekr.20060217071505">Leo 4.4 alpha 6                                         February 17, 2006

Leo 4.4 b2 was broken on some platforms.  Leo 4.4 a6 should fix those problems
forever.  However, only wider distribution will verify that for certain.

Besides fixing the fatal problems with Leo 4.4b2, this version fixes two minor bugs
and adds some new settings in leoSettings.leo.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4 b2 and a6:
----------------------------
- Smoother user interface.
- New commands that support mouseless Leo.
- Minibuffer search commands provide all features of Leo's legacy search commands.
- User modes are fully functional; you can create special bindings for the minibuffer.
- New master key and click handlers and improved allocation of screen widgets.

Coming in Leo 4.4b3:
--------------------
- A revived chapters plugin.
- Autocompleter Tab.
- Improved incremental searches.

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060217071505.1">The new scheme binds to keystrokes, not commands.  This should be as portable
and robust as all previous versions (except b2, which was broken).

- Created k.completeAllBindings, called last in k.makeAllBindings. This binds
all keystrokes in k.bindingsDict to k.masterKeyHandler with an optional stroke
argument. This allows k.masterKeyhandler to dispense with the problematic call
to k.strokeFromEvent. This is all that is really required. 

- Added code to menu.createMenuEntries that clears the accelerator on MacOS for
any key that isn't a control, alt or command key. This solves the recurring
problems with the Return key. The only effect is that the menu won't mention a
binding that is actually in effect, but apparently that cannot be helped.

- Added g.safeCompareStrings, which may, or may not, fix the crasher when
comparing k.abortAllModesKey to the incoming keystroke in k.masterKeyHandler.
It's a bit tricky to test.

- The ignore_caps_lock is no longer functional. Sigh. This depends on knowing
the Caps_Lock bit in key events. I may put this back later, but I can't delay a6
even a minute for this.</t>
<t tx="ekr.20060217072324">- Fixed crasher in k.masterCommand.

- Arrow keys no longer destroy UNL line
</t>
<t tx="ekr.20060217072647">- @bool trace_autocompleter # The autocompleter itself is not ready yet.
- @bool trace_key_event
- @bool trace_minibuffer
- @bool trace_status_line</t>
<t tx="ekr.20060218085144">
This white paper originally appeared in November 2003 as a series of postings to comp.lang.python.
Many features have been added since then.
I rewrote this paper in February 2006.

Those who use Leo know that it is a superb environment for
programming, authoring and managing data and project.
Leo's power comes from combining just two basic elements:

- The organization power of outlines, including clones.
- The power and simplicity of the Python language.

This paper explains in detail how combining these two features can, in fact,
create immense and largely unexpected power and flexibility.
To summarize:

- Outlines with clones are a superb filing cabinet for organizing text,
  including programs and scripts, or in fact any other information.
  This is the obvious aspect of outlines, but it is by no means the most powerful.

- Scripts can be composed of multiple nodes using noweb markup.
  Not only do outlines organize scripts, but scripts can be composed of outlines.
  In other words, Leo can *compose* scripts by concatenating descendant nodes and sections.
  Leo uses the noweb markup language to compose scripts in a flexible manner.

- Outline nodes split text, including programs and scripts, into *easily accessible*, discreet parts.
  Scripts may access nodes and their headlines and body text without any parsing.

- Nodes provide an easy associating the *description* of data with the data itself.
  Indeed, headlines naturally describe the node's body text.
  Leo's users have discovered many ways to take advantage of the unification of data and its description.

- Programs may treat nodes as *separate objects*, no matter what data the nodes contain.
  Because nodes are truly separate objects,
  it becomes easy and natural to define new *operations* on those objects,
  **based on the description of those outline found in the node's headline**.

The combination of these features created a chain reaction of creative uses for outlines.
The result has been an explosion of new ideas and capabilities.

Leo supports the following kinds of 'special' nodes:
@test, @suite, @script, @url, @button, @button timer, @rst, @command, etc.
Each of these kinds of nodes defines new objects and new operations on those objects.
The following paragraph show how Leo's users can use these new objects and their operations

Scripting

- The execute script command executes the body text of the presently selected node
  in an environment containing three variables: c, g and p.
  Thus, all scripts have full and *easy* access to all data in the outline containing the script.

- The scripting plugin creates support for script nodes.
  We can treat a node as a script, and *apply that script to any other part of an outline*.
  This is called 'bringing scripts to data'.
  Leo's users can do this using script buttons as follows.
  Any @button node creates a script button in Leo's icon area.
  The name of the button is the node's headline; the script is the node's body text.
  The user can also create new script buttons using the 'Script Button' button.
  Pressing the 'Script Button' button creates a new script button,
  just as if the presently selected node were an @button node.
  Bringing scripts to data is an immensely powerful and useful feature:
  it has eliminated the need for Leo's previous script-find features.

- @command nodes create new minibuffer commands, complete with keyboard shortcuts.
  The headline defines the command name and an optional keyboard shortcut;
  the body text defines the command.

Unit testing

- We can treat a node as an individual unit test,
  and *automatically* create a subclass of UnitTest.TestCase for the script in that node.
  This is Leo's @test node feature.
  Leo will convert the body text of any @test node into a unit tests.

- Similarly, @suite nodes create suites of unit tests using the script in the @suite node.

- A unit test can get test data from any node in the outline in which it resides.
  Thus, outlines can contain not only unit tests, but the data for those tests.

Text formatting

- The rst3 plugin creates support for @rst nodes.
  @rst trees use outline structure to create document structure.
  This is a revolution in organizing documents.
  Full details [ref]

Organizing data

- @url nodes contain references to web addresses, including files on a local disk.
  Double-clicking an @url node opens a web browser on the given URL.

Plugins

- Plugins support many other kinds of user-defined objects and their associated operations.
  Some examples are @view, @read-only, @folder, @produce, @run, @startfile, etc.
  Writing plugins is easy.
  Python makes the programming as easy as possible;
  and Leo provides plugins with easy access to outlines and their data.</t>
<t tx="ekr.20060218085144.1">The body text of any Leo node may contain a Python script.
The Execute Script commands executes this script in a in an environment,
that predefines three variables: c, g and p.
These variables allow easy access to all the data in the present outline.
For example: the following script prints all the node of the
outline in which the script is embedded::

    for p in c.all_positions():
        indent = ' '*p.level()
        print '%s + %s' % (indent,p.h) # print the node's headline.
        print p.b # print the node's body.

For that matter, scripts can access any data anywhere on your hard drive, or all
the data available on the web, for that matter. You knew that, but this
"innocent" fact will be important later.

**Result 1**:  Leo is a great environment in which to write Python scripts.</t>
<t tx="ekr.20060218085144.2">Leo's outline can organize any text (or other data for that matter).

**Result 2**:  Leo is a great way to organize standalone scripts.

This seemingly simple result will turn out to have important implications.</t>
<t tx="ekr.20060218085144.3">As shown in the example above, scripts may get access to the
headline or body text of any node in a Leo outline.  Therefore, scripts may
use the *structure* of the outline to gain access to

a) other scripts,
b) fragments of code for exec or eval or
c) other data.

**Result 3**: Scripts have can treat outline structure as first-class data.

The first "big" reason why the combination of Python &amp; Leo is spectacular.
It gets better...</t>
<t tx="ekr.20060218085144.4">The body text of a node is the perfect place data itself (including other
scripts).  The headline of the node is the perfect place to *describe* the
data.  That is, headlines are a natural place for meta-data.  Scripts can
use this meta-data in many creative ways.

**Result 4**: Scripts have easy access to user-definable meta-data.</t>
<t tx="ekr.20060218085144.5">I first saw the power of results 2, 3 and 4 when creating unit tests for Leo.
Indeed, the body text of a node is the perfect place for putting regression test
data. Headlines describe the data, which is exactly what is needed for
organizing tests. Indeed, I use a script to create regression tests based on the
structure of the outline of the children of the node containing the script (!)

For example, I run the following script to create and run unit tests of
Leo's colorizer::

    import unittest,leoTest
    suite = leoTest.makeColorSuite("colorizerTests","tempNode")
    runner = unittest.TextTestRunner()
    runner.run(suite)

This works as follows:  the arguments to makeColorSuite tell it to look up
the tree for of an ancestor of the present node (the node containing this
script) for a node whose headline is "colorizerTests".  makeColorSuite then
looks for children of *that* node for nodes containing test data.  The node
whose headline is "tempNode" is used by the colorizer during the tests.
Here is the actual code of makeColorSuite::

    def makeColorSuite(testParentHeadline,tempHeadline):
        """Create a colorizer test for every descendant of testParentHeadline."""
        u = testUtils() ; c = top() ; v = c.currentVnode()
        root = u.findRootNode(v)
        temp_v = u.findNodeInTree(root,tempHeadline)
        vList = u.findSubnodesOf(testParentHeadline)
        # Create the suite and add all test cases.
        suite = unittest.makeSuite(unittest.TestCase)
        for v in vList:
            test = colorTestCase(c,v,temp_v)
            suite.addTest(test)
        return suite

The power and simplicity of this code is breathtaking.  All that is required
are two utility routines, findNodeInTree and findSubnodesOf that find
various nodes in an outline based on the outline structure and the headlines
of the nodes:

- findNodeInTree(root,tempHeadline) returns the node in the entire tree
  contain the current node whose headline is tempHeadline.

- u.findSubnodesOf(testParentHeadline) returns a list of all children of the
  node whose name is testParentHeadline.

In short, it is absolutely trivial for a script embedded in a Leo outline to
generate unit tests based on the data in the outline in which the script is
embedded!

Notice, please, what does *not* have to be done:

A. No unit tests are created statically: everything is driven by data (the
   outline itself)

B. No Python test data is created *at all*.   Before I saw this approach, I
   was putting text for the syntax-coloring text in Python strings and passing
   those strings to the regression tests.  Now, the *unchanged* data in the
   body text of nodes becomes the regression test data.

C.  There is no need to mark meta-data as separate from test data: headlines
are naturally distinct from body text.

We see now that Reasons 2, 3 and 4 are a lot more potent than they might
appear at first.  Indeed, Leo plus Python is the ultimate merging of code,
structure and data.   Scripts can use data organized in outlines.  Outlines
organize scripts.  Outlines (particularly their structure) are *data* for
scripts.  Outlines contains metadata for scripts.  Outlines naturally keep
data and meta-data separate.

Please notice, this discussion merely hints at all the games that scripts
could play with outline structure.  Just for example, scripts can easily
insert, delete and reorganize nodes.  And the uses to which outline
structure may be put are practically unlimited, as we shall see later...

Let's turn now to a completely separate topic...</t>
<t tx="ekr.20060218085144.6">A few days ago I have added a script-based option to Leo's Find/Change
panel.  For more than 30 years I have been disgusted with tools like regular
expressions.  Calling re powerful is an utter joke; it's way too complex and
way too wimpy.  Script-based find-change is infinitely more powerful.
Instead of containing find text or change *text*, Leo's Find/Change panel
may contains find or change *scripts*.  This becomes possible because scripts
have complete access to both the structure of the outline and all of Leo's
code.

It all works so smoothly:   The find script is responsible for traversing
the tree and for highlighting the found text or otherwise indicating to the
change script what the found text was.  Leo dedicates a Python dict called
app.searchDict for communication between the search script and the change
script.  The change script is responsible for:

-  changing the text, typically by using c.setBodyString(p,newText), and

-  implementing undo, typically by calling c.frame.onBodyChanged(p,"Change",oldText=oldText).

Some details:

- When executing the search and change scripts when the user selects the Find
  All or Change All commands, Leo executes the find or change scripts repeatedly
  only if app.searchDict.get("continue") evaluates to True. Otherwise these
  scripts are only executed once. Otherwise, scripts can use app.searchDict as
  they please.

- For simplicity, most find and change scripts will ignore settings in the Find
  Panel like "whole word", "pattern match", and "reverse": the scripts know what
  to do! However, these settings are available to the scripts via ivars such as
  c.whole_word_flag, etc. if desired.

- Either the find and change scripts may use Python's re module. For example,
  the find script could set app.searchDict["m"] to the match object returned by
  re's match method. The change script would then compute the result, change the
  text and set the undo info as usual.

In effect, Leo's Find/Change panel becomes a new platform for running
scripts interactively.  Leo now has all the find/change capability of
pattern matching languages like Snobol and Icon, using the capabilities of
the plain Python language.  Moreover, Leo can deliver these capabilities
interactively or not depending which buttons you push in Leo's Find/Change
panel.

One last point.  As I mentioned much earlier, there is no reason to confine
the find and change scripts to operate on data only within a Leo outline.
These scripts could as easily traverse your file system as the Leo outline.
But notice: scripts could pull data from the file system into the outline so
that you can see the effects of changes as the scripts operate.  Again, this
can all happen interactively if you like.

No, one more last point.  It's convenient to defined an initScriptFind
utility very similar to the makeColorSuite utility, used like this::

    # Initialize Leo's find panel using the named children of this node.
    from leoGlobals import *
    initScriptFind("Find script","Change script")
    # Start searching at the top.
    top().selectVnode(c.rootVnode())

Put the search script in a child node called "Find script" (no quotes), put
the change script in a child node called "Change script", execute this
script and the following happens:

- The body text of "Find script" node gets put in the find text of Leo's Find/Change dialog.

- The body text of "Change script" node gets put in the find text of Leo's Find/Change dialog.

- The Script Find radio buttons gets selected, as does the Script Change checkbox.

- The root of the outline becomes the selected node.

Presto!  Leo is ready for a script search.</t>
<t tx="ekr.20060218085144.7">One more feature greatly expands the generality and power of
Leo's outlines combined with Python.  Plugins may now attach arbitrary data
to any node of a Leo outline.  This is done merely by "injecting" an ivar
called  unknownAttributes ivar into Leo's fundamental vnode or tnode objects
(or adding items to the unknownAttributes dict if it already exists).  The
unknownAttributes ivar should be a Python dictionary whose keys are xml
attribute names and whose values are the values of those attributes.

When writing a file, Leo will write "foreign" attributes in the &lt;v&gt; or &lt;t&gt;
xml elements of Leo's .leo file if the corresponding vnode or tnode contains
this unknownAttributes ivar.  Similarly, Leo will create an
unknownAttributes ivar for a vnode or tnode if the corresponding &lt;v&gt; or &lt;t&gt;
element contains an attribute not normally used by Leo.  Leo performs the
standard xml escapes when writing unknown attributes, so plugins can put
*anything* in the unknownAttributes dictionary.  In particular, plugins may
put xml in v.unknownAttributes or t.unknownAttributes.

This means, for example, that plugins may add anything that can be
represented by xml (and that is *everything*) in any node of a Leo outline.
In effect, Leo's file format is now completely extensible.  BTW, plugins can
override any aspect of Leo's behavior, so not only can Leo passively accept
the data in "extended" .leo files, but plugins can extend Leo to *use* this
data!</t>
<t tx="ekr.20060218085144.8">All the power of Leo derives directly from the power, flexibility and
dynamism of Python.  But making structure explicit as Leo outlines do adds
an important new dimension, literally and figuratively, to Python.
Moreover, Leo's Find/Change dialog creates a new environment from which to
run Python scripts. At long last the full power of the unification of code
and data is becoming apparent.</t>
<t tx="ekr.20060218092725">See the documentation for the `Rst3 plugin`_ for details.</t>
<t tx="ekr.20060218095651">Script buttons are a quick way of automating any task.  Extremely useful.
See the `Scripting plugin`_ for details.

Leo's core provides additional support for @test, @suite, @timer nodes.
For details, see the documentation for `test buttons`_.</t>
<t tx="ekr.20060227102028">Leo 4.4 alpha 7                                             February 28, 2006

This version fixes some minor problems with Leo 4.4a6 and adds autocompletion
and calltips.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060227102028.111">Typing a period when @language python is in effect starts autocompletion. Typing
Return or Control-g (keyboard-quit) exits autocompletion.

Autocompletion shows what may follow a period in code. (Actually you can specify
any character using the auto-complete shortcut setting.) For example, after
typing g. Leo will show a list of all the global functions in leoGlobals.py.
Autocompletion works much like tab completion in the minibuffer. Unlike the
minibuffer, the presently selected completion appears directly in the body
pane.

A leading period brings up 'Autocomplete Modules'. (The period goes away.) You
can also get any module by typing its name. If more than 25 items would appear
in the Autocompleter tab, Leo shows only the valid starting characters. At this
point, typing an exclamation mark shows the complete list. Thereafter, typing
further exclamation marks toggles between full and abbreviated modes.

If x is a list 'x.!' shows all its elements, and if x is a Python dictionary,
'x.!' shows x.keys(). For example, 'sys.modules.!' Again, further exclamation
marks toggles between full and abbreviated modes.

During autocompletion, typing a question mark shows the docstring for the
object. For example: 'g.app?' shows the docstring for g.app. This doesn't work
(yet) directly for Python globals, but '__builtin__.f?' does. Example:
'__builtin__.pow?' shows the docstring for pow.

Autocompletion works in the Find tab; you can use &lt;Tab&gt; to cycle through the
choices. The 'Completion' tab appears while you are doing this; the Find tab
reappears once the completion is finished.
</t>
<t tx="ekr.20060227102028.14">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3586962
By: bwmulder

the open-find-dialog is broken. 
 
Error: 4 
TypeError Exception in Tk callback 
Function: &lt;function findButtonCallback at 0x04E219F0&gt; (type: &lt;type 'function'&gt;) 
Args: () 
Traceback (innermost last): 
File "C:\Python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__ 
return apply(self.func, args) 
TypeError: findButtonCallback() takes at least 1 argument (0 given) 
</t>
<t tx="ekr.20060227102028.15"></t>
<t tx="ekr.20060227102028.16"># This was causing problems.  It may be an easy fix, but I kinda doubt it.</t>
<t tx="ekr.20060227102028.17">
</t>
<t tx="ekr.20060227102028.18">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3597694
By: tfer

Template Plug-in (maybe others too) co,plain when activated:
exception executing command
Traceback (most recent call last):
  File "leoCommands.py", line 265, in doCommand
    val = command(event)
  File "c:\Leo_Cvs\Leo\plugins\plugins_menu.py", line 350, in about
    PluginAbout(self.name, self.version, self.doc)
  File "c:\Leo_Cvs\Leo\plugins\plugins_menu.py", line 576, in __init__
    g.app.dialogs += 1
AttributeError: LeoApp instance has no attribute 'dialogs'</t>
<t tx="ekr.20060227102028.2"></t>
<t tx="ekr.20060227102028.3"># http://sourceforge.net/forum/message.php?msg_id=3583335
</t>
<t tx="ekr.20060323105214">You must create .leoRecentFiles.txt in the config directory.
.leoRecentFiles.txt is part of the standard releases but is not part of the cvs repository.
</t>
<t tx="ekr.20060328171518">Leo 4.4 beta 3                                             April 14, 2006

This version fixes some minor problems and adds various features.  This code
has been in use for several weeks without any major problems reported.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060328171518.1"></t>
<t tx="ekr.20060328171518.10">http://sourceforge.net/forum/message.php?msg_id=3608246

Added the following commands:

scroll-outline-down-line       
scroll-outline-down-page       
scroll-outline-up-line       
scroll-outline-up-page</t>
<t tx="ekr.20060328171518.101">Apparently g.app.unitTesting isn't set properly for the new-window test.</t>
<t tx="ekr.20060328171518.108">The bug: Hit control-f, then select the text that doesn't have focus.</t>
<t tx="ekr.20060328171518.11">It now properly creates bindings.</t>
<t tx="ekr.20060328171518.111">http://sourceforge.net/forum/message.php?msg_id=3641107

ConfigSettings.initEncoding now uses the g.app.config settings if no other settings are available.

In particular, this causes at.encoding to be inited to a reasonable value.</t>
<t tx="ekr.20060328171518.119">- onBodyChanged now converts everything to unicode, either directly or by calling g.app.gui.getAllText.

- Replaced all calls to g.safeStringCompare by g.app.gui.getAllText which calls g.toUnicode.

- Converted all shortcuts to unicode in shortcutFromSetting (a.k.a strokeFromSetting)

- Removed g.safeStringCompare.  This function was a bad idea.

Important: Leo is supposed to convert all characters to unicode, so there should
never be a need for safeStringCompare. The proper way to avoid UnicodeError's is
to call g.toUnicode(s,g.app.tkEncoding).</t>
<t tx="ekr.20060328171518.135">http://sourceforge.net/forum/message.php?msg_id=3607355</t>
<t tx="ekr.20060328171518.15"></t>
<t tx="ekr.20060328171518.151"></t>
<t tx="ekr.20060328171518.152">http://sourceforge.net/forum/message.php?msg_id=3573148

c.openWith now calls g.enableIdleTimeHook</t>
<t tx="ekr.20060328171518.16">http://sourceforge.net/forum/message.php?msg_id=3572598</t>
<t tx="ekr.20060328171518.169">These commands now set g.app.globalOpenDir.</t>
<t tx="ekr.20060328171518.190">http://sourceforge.net/forum/message.php?msg_id=3585710</t>
<t tx="ekr.20060328171518.191"></t>
<t tx="ekr.20060328171518.238">http://sourceforge.net/forum/message.php?msg_id=3637393

I'm trying to set up a default stylesheet for a project and want this to be
held relative to the project directory (where the .leo file is). The default
is to place it in the same directory as the output, which is a couple of levels
down.

http://sourceforge.net/forum/message.php?msg_id=3639216

g.os_path_dirname(self.outputFileName) with self.c.frame.openDirectory. This
makes the path relative to the project. Not 100% as the stylesheet filename
would need a path embedded in it to move the location down the tree. However,
it is consistent with the way the output file is named.</t>
<t tx="ekr.20060328171518.240">See the chapters2 in leoPlugins.leo.

See also:

http://sourceforge.net/forum/message.php?msg_id=3626542

https://sourceforge.net/forum/message.php?msg_id=3629055

http://sourceforge.net/forum/message.php?msg_id=3632004</t>
<t tx="ekr.20060328171518.244">Cleaned up the code and added support minibuffer commands:

group-operations-clear-marked       = Alt-Ctrl-Shift-l
group-operations-mark-for-copy      = Alt-Ctrl-Shift-c
group-operations-mark-for-move      = Alt-Ctrl-Shift-m
group-operations-mark-for-clone     = Alt-Ctrl-`
group-operations-mark-target        = Alt-Ctrl-Shift-t
group-operations-operate-on-marked  = Alt-Ctrl-Shift-o
group-operations-transfer           = Alt-Ctrl-Shift-d

This code has not been tested with the chapters2 plugin.</t>
<t tx="ekr.20060328171518.245">http://sourceforge.net/forum/message.php?msg_id=3617936

The fix was to plugins_menu.py: the cmd_callback must have an event argument.
</t>
<t tx="ekr.20060328171518.246">The fix: all menu commands now have event=None in their argument list.</t>
<t tx="ekr.20060328171518.248">Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.</t>
<t tx="ekr.20060328171518.249">It's not ready for prime time.</t>
<t tx="ekr.20060328171518.45">This is equivalent to the Unit Test script button in unitTest.leo</t>
<t tx="ekr.20060328171518.47"></t>
<t tx="ekr.20060328171518.48">http://sourceforge.net/forum/message.php?msg_id=3619340

Just tried out CVS today, and on Linux left/right and L/R in outline mode
(Ctrl-Shift-O) seem to do nothing, whereas they should expand/contract parent
nodes.</t>
<t tx="ekr.20060328171518.57">http://sourceforge.net/forum/message.php?msg_id=3639193

The dirty bits were not updated properly in several undo/redo operations.</t>
<t tx="ekr.20060328171518.83">http://sourceforge.net/forum/message.php?msg_id=3642892

The present code is probably the best compromise between strict accuracy and marking too many nodes dirty.</t>
<t tx="ekr.20060328171518.85">http://sourceforge.net/forum/message.php?msg_id=3606515

Added insert-newline command and fixed some related commands.</t>
<t tx="ekr.20060329101442">Missing modules can cause installation problems.
If the installer doesn't work (or puts up a dialog containing no text), you may install Leo from the .zip file
as described at `How to install Leo on Windows`_.
However you are installing Leo,
be sure to `run Leo in a console window`_.
because as a last resort Leo prints error messages to the console.</t>
<t tx="ekr.20060414071350.1"></t>
<t tx="ekr.20060414071350.39">leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\leoCVS\leo\config\leoSettings.leo
reading settings in C:\prog\leoCVS\leo\src\LeoPy.leo
rst3 plugin: SilverCity not loaded
AttributeError Exception in Tk callback
  Function: &lt;function bindKeyCallback at 0x016F2E70&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x03510288&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2002, in bindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2928, in masterKeyHandler
    val = self.masterKeyHandlerHelper(event,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2992, in masterKeyHandlerHelper
    val = k.callStateFunction(event) # Calls end-command.
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2219, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 348, in autoCompleterStateHandler
    self.insertNormalChar(ch,keysym)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 856, in insertNormalChar
    self.calltip(obj)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 455, in calltip
    obj = getattr(string,obj.__name__)
AttributeError: 'module' object has no attribute 'startswith'</t>
<t tx="ekr.20060414071350.47">exception executing command
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 884, in clearRecentFiles
    u.afterClearRecentFiles(bunch)
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 621, in afterClearRecentFiles
    u.pushBead(bunch)
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 192, in pushBead
    u.setUndoTypes()
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 341, in setUndoTypes
    u.cutStack()
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 136, in cutStack
    if bunch.kind == 'beforeGroup':
AttributeError: 'Bunch' object has no attribute 'kind'</t>
<t tx="ekr.20060414071350.58"># No change for now
C:\prog\tigris-cvs\leo\src\leoKeys.py:1050: Parameter (thread) not used

# Fixed
C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py:1428: Function returns a value and also implicitly returns None
C:\prog\tigris-cvs\leo\src\leoTkinterTree.py:1222: Local variable (delta) not used
C:\prog\tigris-cvs\leo\src\leoKeys.py:1931: Local variable (f) not used
C:\prog\tigris-cvs\leo\src\leoGlobals.py:5246: Local variable (buttonList) not used
C:\prog\tigris-cvs\leo\src\leoCommands.py:493: No global (enableIdleTimeHook) found</t>
<t tx="ekr.20060414071350.8">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3671350

Change aString.lstrip and aString.rstrip to the aString.replace.
@color</t>
<t tx="ekr.20060417092536">Leo 4.4 beta 4                                             April 21, 2006

This version fixes a long-standing MacOS bug.  It is likely to be the last
beta release before 4.4 final.  This release also adds several new commands
and contains a script for updating leoSettings.leo.

Warning: The previous beta was not widely distributed. Please do some testing in
your environment before recommending this version of Leo to others, (such as
your students).

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060417092825.1">See the (presently disabled) script button in scripts.leo at:

Buttons--&gt;@@button updateSettings

From the docstring:

Here is a **preliminary** script that updates a new leoSettings.leo file
(path2) from the settings in a previous leoSettings.leo file (path1).
Presumably, the path2 file is the leoSettings.leo file from a new distribution,
and the path1 file a leoSettings.leo file containing settings that you have
modified.  You must specify the full path of both files in the top-level @button node.

**Warning**: This script modifies the path2 file. Make sure that you don't mind
modifying this file.

**Warning**: This script is unsophisticated in its update algorithm. If if finds
corresponding nodes (node with the same settings name) in both outlines it simply
replaces the node in the path2 file with the node in the path1 file. In
particular, it does not keep track of individual shortcuts: it replaces the body
of one @shortcuts node with the body of the corresponding @shortcuts node.

**Note**: If the path1 file contains a settings node not in the path2 file it
attempts to create a new node in the corresponding place in the path2 file. If
this is not possible, say because the structures of the files are different, the
script places the new node as the last child of the @settings node in the path2
file.</t>
<t tx="ekr.20060420094611">The mini-buffer is a text area at the bottom of the body pane.
You use it like the Emacs mini-buffer to invoke commands by their so-called *long name*.
The following commands affect the minibuffer:

- **full-command**: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a
  full command name, then hit &lt;Return&gt; to execute the command. Tab completion
  works, but not yet for file names.

.. - **quick-command-mode**: (default shortcut: Alt-x) Like Emacs Control-C. This mode is
..   defined in leoSettings.leo. It is useful for commonly-used commands.

- **universal-argument**: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat
  count for later command. Ctrl-u 999 a adds 999 a's.

- **keyboard-quit**: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts
  the focus in the body pane.

For example, to print a list of all commands type Alt-X print-commands &lt;Return&gt;.

The following sections list the various commands that you can invoke from the minibuffer.
**Important**: you may bind keystrokes to any of these commands.
See `Chapter 8: Customizing Leo`_ for full details.</t>
<t tx="ekr.20060421070409.1"></t>
<t tx="ekr.20060421070409.10">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3692247

Find panel cannot be re-opened. Run open-find-dialog. Close it. Run open-find-dialog
again -- crash.

The fix was to move the line:

self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)

from createBindings to createFrame in the leoTkinterFind class.</t>
<t tx="ekr.20060421070409.11">TclError Exception in Tk callback
  Function: &lt;function bindKeyCallback at 0x0169B170&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x01865EB8&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 1991, in bindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2931, in masterKeyHandler
    val = self.masterKeyHandlerHelper(event,stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2990, in masterKeyHandlerHelper
    val = k.callStateFunction(event) # Calls end-command.
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2208, in callStateFunction
    val = k.state.handler(event)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2289, in fullCommand
    k.callAltXFunction(k.mb_event)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2327, in callAltXFunction
    func(event)
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 2801, in showFindPanel
    c.frame.findPanel.bringToFront()
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFind.py", line 469, in bringToFront
    self.top.withdraw() # Helps bring the window to the front.
  File "c:\python24\lib\lib-tk\Tkinter.py", line 1562, in wm_withdraw
    return self.tk.call('wm', 'withdraw', self._w)
TclError: bad window path name ".25637872"

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 1486
    state: 0
    time: 1717970
    type: 2
    widget: .17570752.17571352.19882152.minibuffer
    width: ??
    x: 183
    x_root: 576
    y: -62
    y_root: 859

</t>
<t tx="ekr.20060421070409.2">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3688804
By: paulpaterson

It seems that copying and pasting nodes with CTRL-SHIFT-C, V is not working.
- (legacy bindings)
- select a node
- CTRL-SHIFT-C
- CTRL-SHIFT-V
- Vim opens up! I expect to paste the node. The clipboard doesn't seem to contain
any XML
- The menu items show that these keys are bound to the copy and paste node
commands

*** Also on legacy bindings the arrow keys don't seem to move the cursor in the
body.</t>
<t tx="ekr.20060421070409.3"></t>
<t tx="ekr.20060421070409.33"># getLeadinWord must clear self.membersList to disable completion.</t>
<t tx="ekr.20060421070409.36">leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\Documents and Settings\Ed\My Documents\ekr.leo
rst3 plugin: SilverCity not loaded
exception executing command
Traceback (most recent call last):

  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)

  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 2969, in pasteOutline
    u.afterInsertNode(pasted,undoType,undoData)

  File "C:\prog\tigris-cvs\leo\src\leoUndo.py", line 750, in afterInsertNode
    u.pushBead(bunch)

  File "C:\prog\tigris-cvs\leo\src\leoUndo.py", line 182, in pushBead
    if bunch2 and bunch2.kind == 'beforeGroup':

AttributeError: 'Bunch' object has no attribute 'kind'</t>
<t tx="ekr.20060421070409.37"></t>
<t tx="ekr.20060421070409.4">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3692247
By: vpe

After cutting selection in the headline, headline area shrinks too much.  Example:
headline is 'NewHeadline', select last 'e', ctrl-x, it shrinks to 'Ne'

To fix by hand: add

s=g.app.gui.getAllText(w)

Just before

w.configure(width=f.tree.headWidth(s=s))

in cutText in leoTkFrame.py</t>
<t tx="ekr.20060421070409.40"></t>
<t tx="ekr.20060421070409.41">New commands:

add-space-to-lines,
add-tab-to-lines
clean-lines
clear-selected-text
goto-global-line
help-for-command
open-outline-by-name (filename completion)
remove-space-from-lines
remove-tab-from-lines</t>
<t tx="ekr.20060421070409.9"></t>
<t tx="ekr.20060421070602"></t>
<t tx="ekr.20060428084553">Leo 4.4 release candidate 1                                 April 28, 2006

This version fixes a few minor bug reported in 4.4b4 and adds 9 new commands.
The open-outline-by-name command supports filename completion.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060428084553.10">http://sourceforge.net/forum/message.php?msg_id=3692247

Find panel cannot be re-opened. Run open-find-dialog. Close it. Run open-find-dialog
again -- crash.</t>
<t tx="ekr.20060428084553.2"></t>
<t tx="ekr.20060428084553.273">At present, only the open-outline-by-name command supports filename completion.</t>
<t tx="ekr.20060428084553.34"># getLeadinWord must clear self.membersList to disable completion.</t>
<t tx="ekr.20060428084553.37">Traceback (most recent call last):

  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)

  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 2969, in pasteOutline
    u.afterInsertNode(pasted,undoType,undoData)

  File "C:\prog\tigris-cvs\leo\src\leoUndo.py", line 750, in afterInsertNode
    u.pushBead(bunch)

  File "C:\prog\tigris-cvs\leo\src\leoUndo.py", line 182, in pushBead
    if bunch2 and bunch2.kind == 'beforeGroup':

AttributeError: 'Bunch' object has no attribute 'kind'</t>
<t tx="ekr.20060428084553.38"></t>
<t tx="ekr.20060428084553.39">Useful, e.g., after a find.</t>
<t tx="ekr.20060428084553.4">http://sourceforge.net/forum/message.php?msg_id=3692247

After cutting selection in the headline, headline area shrank too much.  </t>
<t tx="ekr.20060428084553.41">self.beginCommand(undoType='xxx')
...
self.endCommand(changed=True,setLabel=True)</t>
<t tx="ekr.20060428084553.42">New commands:

add-space-to-lines
add-tab-to-lines
clean-lines
clear-selected-text
goto-global-line
help-for-command
remove-space-from-lines
remove-tab-from-lines</t>
<t tx="ekr.20060428084711">https://sourceforge.net/forum/message.php?msg_id=3699799</t>
<t tx="ekr.20060428084957"></t>
<t tx="ekr.20060430220749">The jEdit_ editor drives its syntax colorer using xml **language description files.**
`jEdit's documentation`_ contain a complete description of these xml files.
Each xml file describes one **colorizing mode**.
A mode consists of one or more **rulesets**, and each ruleset consists of a list of **colorizing rules**.
In addition, modes, rulesets and rules may have associated **properties** and **attributes**.
Various rules may specify that the colorizer uses another ruleset (either in the same mode or another mode).

**Important**: jEdit's xml language description files contain no explicit &lt;RULE&gt; elements
Rules are simply sub-elements of an enclosing &lt;RULES&gt; element.
The element indicates the kind of rule that is specified,
for example, &lt;SPAN&gt;, &lt;SEQ&gt;, etc.
By the term **rule element** we shall mean any sub-element of the &lt;RULES&gt; element.

Rather than using the xml language description files directly,
Leo uses Python **colorer control files**,
created automatically from the xml files by a script called jEdit2Py.
These Python files contain all the information in the jEdit's xml files,
so we can (loosely) speak of modes, rulesets, rules, properties and attributes in the Python colorer control files. 
Later sections of this documentation will make this loose correspondence exact.

**Important**: throughout this documentation,
**x.py** will refer to the Python colorer for language x,
and **x.xml** will refer to the corresponding xml language-description file.

Using Python colorer control files has the following advantages:

- Running jEdit2Py need only be done when x.xml changes,
  and the speed of the xml parser in jEdit2Py does not affect the speed of Leo's colorizer in any way.
  Moreover, the jEdit2Py script can contain debugging traces and checks.

- Colorer control files are valid .py files, so all of Python's import optimizations work as usual.
  In particular, all the data in colorer control files is immediately accessible to Leo's colorer.

- Colorer control files are easier for humans to understand and modify than the equivalent xml file.
  Furthermore, it is easy to insert debugging information into Python colorer control files.

- It is easy to modify the Python colorer control files 'by hand' without changing the corresponding xml file.
  In particular, it would be easy to define entirely new kinds of pattern-matching rules in Python merely
  by creating functions in a colorer control file.</t>
<t tx="ekr.20060430221745">@language rest</t>
<t tx="ekr.20060430221745.1">#########################################
Chapter 15: Controlling Syntax Coloring
#########################################

This chapter discusses how to control Leo's new syntax colorer using Python
files derived from jEdit_'s xml language description files. It also discusses
settings related to syntax coloring.

**Important**: this material is for those who want to support Leo's colorizing
code. You do *not* need to understand this chapter in order to use Leo's
colorizers.

The __jEdit_colorizer__.py plugin was an early prototype of the new colorizer.
This code has been retired. The threading_colorizer.py plugin uses a separate
helper thread to do the colorizing. Coding details for this plugin are discussed
in this chapter.

.. .. contents::
</t>
<t tx="ekr.20060430222753">.. External links...
.. _jEdit:                      http://www.jedit.org/
.. _`jEdit's documentation`:    http://www.jedit.org/42docs/users-guide/writing-modes-part.html

.. Relative links...
.. _`Ruleset name`:      `Ruleset names`_
.. _`Chapter 8`:           customizing.html
</t>
<t tx="ekr.20060502084233">When Leo's syntax colorer sees the '@language x' directive,
it will import x.py from Leo's modes folder.
The colorer can then access any module-level object obj in x.py as x.obj.

Colorizer control files contain **rules functions** corresponding to rule elements in x.xml.
The colorizer can call these functions as if they were members of the colorizer class by
passing 'self' as the first argument of these functions.
I call these rules *functions* to distinguish them from the corresponding
**rules methods** which are actual methods of the colorizer class.
Rules *functions* merely call corresponding rules *methods*.
Indeed, rules functions are simply a way of binding values to keyword arguments of rules methods.
These keywords arguments correspond to the xml attributes of rule elements in x.xml.

The colorizer calls rules functions until one matches, at which point a range of text gets colored and the process repeats.
The inner loop of the colorizer is this code::

    for f in self.rulesDict.get(s[i],[]):
        n = f(self,s,i)
        if n &gt; 0:
            i += n ; break
        else: i += 1

- rulesDict is a dictionary whose keys are rulesets and whose values are ruleset dictionaries.
  Ruleset dictionaries have keys that are single characters and whose values are
  the list of rules that can start with that character. 

- s is the full text to be colorized.

- i is the position within s is to be colorized.

Rules methods (and functions) return n &gt; 0 if they match, and n == 0 if they fail.</t>
<t tx="ekr.20060502084233.1">The following sections describe the top-level data in x.py.</t>
<t tx="ekr.20060502090516">**x.properties** is a Python dictionary corresponding to the &lt;PROPS&gt; element in x.xml.
Keys are property names; values are strings, namely the contents of &lt;PROPERTY&gt; elements in x.xml.
x.properties contains properties for the entire mode.
That is, only modes have &lt;PROPS&gt; elements.
For example, here is x.properties in php.py::

    # properties for mode php.xml
    properties = {
        "commentEnd": "--&gt;",
        "commentStart": "&lt;!--",
        "indentCloseBrackets": "}",
        "indentOpenBrackets": "{",
        "lineUpClosingBracket": "true",
    }</t>
<t tx="ekr.20060502090516.1">x.py contains a **keyword dictionary** for each ruleset in x.xml.
x.py contains an empty keywords dictionary if a ruleset contains no &lt;KEYWORDS&gt; element.

Keys are strings representing keywords of the language describe by the mode.
Values are strings representing syntactic categories,
i.e. a TYPE attribute valid in x.xml, namely:
COMMENT1, COMMENT2, COMMENT3, COMMENT4,
FUNCTION,
KEYWORD1, KEYWORD2, KEYWORD3, KEYWORD4,
LABEL, LITERAL1, LITERAL2, LITERAL3, LITERAL4,
MARKUP, NULL and OPERATOR.

For example, here (parts of) some keyword dictionaries in php.py::

    # Keywords dict for mode php::PHP
    php_PHP_keywords_dict = {
        "COM_invoke": "keyword2",
        "COM_load": "keyword2",
        "__CLASS__": "keyword3",
        ...
        "abs": "keyword2",
        "abstract": "keyword1",
        "accept_connect": "keyword2",
        ...
    }

    # Keywords dict for mode php::JAVASCRIPT_PHP
    php_JAVASCRIPT_PHP_keywords_dict = {}

    # Keywords dict for mode php::PHPDOC
    php_PHPDOC_keywords_dict = {
        "@abstract": "label",
        "@access": "label",
        "@author": "label",
        ...
        "@var": "label",
        "@version": "label",
    }

x.py also contains **x.keywordsDictDict**.
Keys are ruleset names, values are keywords dictionaries.
Here is keywordsDictDict for php.py::

    # Dictionary of keywords dictionaries for php mode.
    keywordsDictDict = {
        "php_javascript": php_javascript_keywords_dict,
        "php_javascript_php": php_javascript_php_keywords_dict,
        "php_main": php_main_keywords_dict,
        "php_php": php_php_keywords_dict,
        "php_php_literal": php_php_literal_keywords_dict,
        "php_phpdoc": php_phpdoc_keywords_dict,
        "php_tags": php_tags_keywords_dict,
        "php_tags_literal": php_tags_literal_keywords_dict,
    }

The colorizer can get the keywords dictionary for a ruleset as follows::

    keywordsDict = x.keywordsDictDict(rulesetName)

**Note**:
The jEdit2Py script creates 'friendly' names for keyword dictionaries *solely* as an aid for people reading the code.
Leo's colorer uses only the name x.keywordsDictDict;
Leo's colorer never uses the actual names of keywords dictionaries such as php_PHPDOC_keywords_dict.</t>
<t tx="ekr.20060502090516.2">x.py contains one **rule function** for every rule in every ruleset (&lt;RULES&gt; element) in x.xml.
These rules have names rule1 through  ruleN,
where N is the total number of rules in all rulesets in x.xml.

Each rules *function* merely calls a rules *method* in Leo's colorizer.
Which method gets called depends on the corresponding element in `x.xml`.
For example, the first rule in php.xml is::

    &lt;SPAN TYPE="MARKUP" DELEGATE="PHP"&gt;
		&lt;BEGIN&gt;&amp;lt;?php&lt;/BEGIN&gt;
		&lt;END&gt;?&amp;gt;&lt;/END&gt;
	&lt;/SPAN&gt;

and the corresponding rule function is::

    def php_rule0(colorer, s, i):
        return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="PHP",exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)


php_rule0 calls colorer.match_span because the corresponding xml rule is a &lt;SPAN&gt; element.

For each ruleset, x.py also contains a **rules dictionary**,
a Python dictionary whose keys are characters and whose values are all lists
of rules functions that that can match the key.
For example::

    # Rules dict for phpdoc ruleset.
    rulesDict8 = {
        "*": [rule64,],
        "0": [rule70,],
        "1": [rule70,],
        "2": [rule70,],
        "3": [rule70,],
        "4": [rule70,],
        "5": [rule70,],
        "6": [rule70,],
        "7": [rule70,],
        "8": [rule70,],
        "9": [rule70,],
        "&lt;": [rule65,rule66,rule67,rule68,rule69,],
        "@": [rule70,],
        "A": [rule70,],
        "B": [rule70,],
        ...
        "X": [rule70,],
        "Y": [rule70,],
        "Z": [rule70,],
        "_": [rule70,],
        "a": [rule70,],
        "b": [rule70,],
       ...
        "x": [rule70,],
        "y": [rule70,],
        "z": [rule70,],
        "{": [rule63,],
    }

**Note**: The order of rules in each rules list is important;
it should be the same as rules element in x.xml.

Finally, x.py contains **x.rulesDictDict**.
Keys are ruleset names, values are rules dictionaries.
The colorer can get the rules list for character ch as follows::

    self.rulesDict = x.rulesDictDict.get(rulesetName) # When a mode is inited.
    ...
    rules = self.rulesDict.get(ch,[]) # In the main loop.

For example, here is the rules dictionary for php.py::

    # x.rulesDictDict for php mode.
    rulesDictDict = {
        "php_javascript": rulesDict6,
        "php_javascript_php": rulesDict7,
        "php_main": rulesDict1,
        "php_php": rulesDict4,
        "php_php_literal": rulesDict5,
        "php_phpdoc": rulesDict8,
        "php_tags": rulesDict2,
        "php_tags_literal": rulesDict3,
    }

**Note**:
The jEdit2Py script creates 'friendly' names for rules lists *solely* as an aid for people reading the code.
Leo's colorer uses only the name x.rulesDictDict;
Leo's colorer never uses the actual names of rules lists such as rulesDict8,
and Leo's colorer never uses the actual names of rules functions such as rule64.</t>
<t tx="ekr.20060502100550">A **ruleset name** is a Python string having the form 'x_setname',
where setname is the value of the SET attribute of the &lt;RULES&gt; element in x.xml.
For example, the ruleset name of the ruleset whose SET attribute is JAVASCRIPT in php.xml is
'php_JAVASCRIPT'.
**Important**: by convention, the ruleset name of the default &lt;RULES&gt; element is 'x_main';
note that default &lt;RULES&gt; element have no SET attributes.

The colorizer uses ruleset names to gain access to all data structures in x.py.
To anticipate a bit, ruleset names are keys into two standard dictionaries,
x.rulesDict and x.keywordsDictDict,
from which the colorizer can get all other information in x.py::

    # The rules list for the 'JAVASCRIPT' ruleset in php.xml.
    rules = x.rulesDict('php_JAVASCRIPT')

    # The keywords dict for the 'JAVASCRIPT' ruleset in php.xml.
    keywordsDict = x.keywordsDictDict('php_JAVASCRIPT')

In fact, ruleset names (and x.rulesDict and x.keywordsDictDict)
are the **only** names that the colorizer needs to know in order to access all information in x.py.</t>
<t tx="ekr.20060502122950">This section describes each rules method in Leo's new colorizer.
Rules methods are called by rules functions in colorizer control file;
they correspond directly to rules elements in jEdit's language description files.
In fact, this documentation is a 'refactoring' of `jEdit's documentation`_.

All rule methods attempt to match a pattern at a particular spot in a string.
These methods all return True if the match succeeds.</t>
<t tx="ekr.20060502122950.10">::

    def match_eol_span_regexp (self,s,i,kind,regex,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        delegate = '',
        exclude_match = False):

match_eol_span_exp succeeds if:

1. The regular expression regex matches at s[i:], and

2. The at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_eol_span_regexp  highlights from i to the end of the line.
If the exclude_match argument is True, only the text before the matched text will be colored.
The delegate argument, if present, specifies the ruleset to color the colored text.</t>
<t tx="ekr.20060502122950.13">::

    def match_keywords (self,s,i):

match_keywords succeeds if s[i:] starts with an identifier contained in the mode's keywords dictionary d.

If successful, match_keywords colors the keyword.
match_keywords does not take a kind keyword argument.
Instead, the keyword is colored as specified by d.get(theKeyword).</t>
<t tx="ekr.20060502122950.14">::

    def match_mark_following (self,s,i,kind,pattern,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        exclude_match = False):

match_mark_following succeeds if s[i:].startswith(pattern), and
the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_mark_following colors from i to the start of the next token
with the color specified by kind.
If the exclude_match argument is True, only the text after the matched text will be colored.</t>
<t tx="ekr.20060502122950.40">::

    def match_seq (self,s,i,kind,seq,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        delegate = ''):

match_seq succeeds if s[i:].startswith(seq) and
the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_seq highlights from i to the end of the sequence
with the color specified by kind.
The delegate argument, if present, specifies the ruleset to color the colored text.</t>
<t tx="ekr.20060502122950.41">::

    def match_seq_regexp (self,s,i,kind,regex,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        delegate = ''):

match_seq succeeds if:

1. The regular expression regex matches at s[i:], and

2. The at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_seq_regexp highlights from i to the end of the sequence
with the color specified by kind.
The delegate argument, if present, specifies the ruleset to color the colored text.</t>
<t tx="ekr.20060502122950.42">::

    def match_span (self,s,i,kind,begin,end,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        exclude_match = False,
        delegate = ''
        no_escape = False,
        no_line_break = False,
        no_word_break = False):

match_span succeeds if there is an index j &gt; i such that
s[:i].startswith(begin) and s[i:j].endswith(end) and the
at_line_start, at_whitespace_end, at_word_start,
no_escape, no_line_break and no_word_break conditions are all satisfied.

If successful, match_span highlights from s[i:j
with the color specified by kind;
but if the exclude_match argument is True, the begin and end text are not colored.
The delegate argument, if present, specifies the ruleset to color the colored text.</t>
<t tx="ekr.20060502122950.47">::

    def match_span (self,s,i,kind,regex,end,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        exclude_match = False,
        delegate = ''
        no_escape = False,
        no_line_break = False,
        no_word_break = False):

match_span_regex succeeds if:

1. The regular expression regex matches at s[i:],

2. There is an index j &gt; i such that s[i:j].endswith(end),

3. The at_line_start, at_whitespace_end, at_word_start,
   no_escape, no_line_break and no_word_break conditions are all satisfied.

If successful, match_span colors s[i:j],
with the color specified by kind;
but if the exclude_match argument is True, the begin and end text are not colored.
The delegate argument, if present, specifies the ruleset to color the colored text.</t>
<t tx="ekr.20060502122950.48">::

    def match_terminate (self,s,i,kind,at_char):

match_terminate succeeds if s[i:] contains at least at_char more characters.

If successful, match_terminate colors at_char characters
with the color specified by kind.</t>
<t tx="ekr.20060502122950.7">::

    def match_eol_span (self,s,i,kind,begin,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        delegate = '',
        exclude_match = False):

match_eol_span succeeds if s[i:].startswith(begin) and
the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_eol_span highlights from i to the end of the line
with the color specified by kind.
If the exclude_match argument is True, only the text before the matched text will be colored.
The delegate argument, if present, specifies the ruleset to color the colored text.</t>
<t tx="ekr.20060502125223">::

    def match_mark_previous (self,s,i,kind,pattern,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        exclude_match = False):

match_mark_previous succeeds if s[i:].startswith(pattern),and
the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_mark_previous colors from the end of the previous token to i
with the color specified by kind.
If the exclude_match argument is True, only the text before the matched text will be colored.</t>
<t tx="ekr.20060503064515">All rule methods take three required arguments and zero or more optional keyword arguments.

Here is a list of the required arguments and their meaning:

- **self**: An instance of Leo's colorizer.

- **s**: The string in which matches may be found.

- **i**: The location within the string at which the rule method looks for a match.

Here is a list of all optional keyword arguments and their meaning:

- **at_line_start**:
  If True, a match will succeed only if i is at the start of a line.

- **at_whitespace_end**:
  If True, the match will succeed only if i is at the first non-whitespace text in a line.

- **at_word_start**:
  If True, the match will succeed only if i is at the beginning of a word.

- **delegate**:
  If non-empty, the value of this argument is a `ruleset name`_.
  If the match succeeds, the matched text will be colored recursively with the indicate ruleset.

- **exclude_match**:
  If True, the actual text that matched will not be colored.
  The meaning of this argument varies slightly depending on whether one or two sequences are matched.
  See the individual rule methods for details.

- **kind**: A string representing a class of tokens, i.e., one of:
  'comment1', 'comment2', 'comment3', 'comment4', 'function',
  'keyword1', 'keyword2', 'keyword3', 'keyword4',
  'label', 'literal1', 'literal2', 'literal3', 'literal4',
  'markup', 'null' and 'operator'.

- **no_escape**:
  If True, the ruleset's escape character will have no effect before the end argument to match_span.
  Otherwise, the presence of the escape character will cause that occurrence of the end string to be ignored.

- **no_line_break**:
  If True, the match will not succeed across line breaks.

- **no_word_break**:
  If True, the match will not cross word breaks.

New in Leo 4.4.1 final: the regular expression rule matchers no longer get a hash_char argument
because such matchers are called only if the present search pattern starts with hash_char.</t>
<t tx="ekr.20060503072213">x.importDict is a Python dictionary.
Keys are ruleset names; values are a list of ruleset names.
For example::

    # Import dict for php mode.
    importDict = {
        "php_javascript_php": ["javascript::main"],
    }

For any ruleset R whose ruleset name is N, x.importDict.get(N)
is the list of rulesets names whose rulesets appear in
a DELEGATE attribute of an &lt;IMPORT&gt; rule element in R's ruleset.
Such **imported** ruleset are copied to the end of the R's rules list.
Leo's colorizer does this copying only once, when loading ruleset R for the first time.

**Note 1**: Loading imported rulesets must be done at 'run time'.
It should definitely not be done by jEdit2Py at 'compile time';
that would require running jEdit2Py on *all* .xml files whenever any such file changed.

**Note 2**:  Multiple &lt;IMPORT&gt; rule elements in a single ruleset are allowed:
delegated rules are copied to the end of N's rules list in the order they appear in the ruleset.

**Note 3**: The DELEGATE attribute of &lt;IMPORT&gt; elements is, in fact,
completely separate from the DELEGATE attributes of other rules as
discussed in `Arguments to rule methods`_.
Indeed, the DELEGATE attribute of &lt;IMPORT&gt; elements creates entries in
x.importDict, which in turn causes the colorizer to append the rules of the imported ruleset
to the end of the present rules list.
In contrast, the DELEGATE attributes of other rules sets the delegate argument to rules methods,
which in tern causes the colorizer to recursively color the matched text with the **delegated** ruleset.
In short:

- The rules of **imported** rulesets are appended to the end of another rules list;
  the rules of **delegated** rulesets never are.

- **Imported** ruleset names appear as the values of items in x.importDict;
  **delegated** ruleset names appear as delegate arguments to rule methods.</t>
<t tx="ekr.20060510085547">x.py contains a **attribute dictionary** for each ruleset in x.xml.
Keys are attribute names, values strings representing the values of the attributes.
This dictionary is empty if a ruleset contains no attributes.
The valid keys are:

- 'default': the default token type.  'null' is the default.

- 'digit_re': a regular expression.
  Words matching this regular expression are colored with the digit token type.

- 'ignore_case': 'true' or 'false'.  Default is 'true'.

- 'highlight_digits': 'true' or 'false'.  Default is 'true'.

- 'no_word_sep': A list of characters treated as 'alphabetic' characters when matching keywords.

For example, here is one attribute dictionary in php.py::

    # Attributes dict for php_javascript ruleset.
    php_javascript_attributes_dict = {
        "default": "MARKUP",
        "digit_re": "",
        "highlight_digits": "true",
        "ignore_case": "true",
        "no_word_sep": "",
    }

x.py also contains **x.attributesDictDict**.
Keys are ruleset names, values are attribute dictionaries.
Here is attributesDictDict for php.py::

    # Dictionary of attributes dictionaries for php mode.
    attributesDictDict = {
        "php_javascript": php_javascript_attributes_dict,
        "php_javascript_php": php_javascript_php_attributes_dict,
        "php_main": php_main_attributes_dict,
        "php_php": php_php_attributes_dict,
        "php_php_literal": php_php_literal_attributes_dict,
        "php_phpdoc": php_phpdoc_attributes_dict,
        "php_tags": php_tags_attributes_dict,
        "php_tags_literal": php_tags_literal_attributes_dict,
    }

**Note**:
The jEdit2Py script creates 'friendly' names for attribute dictionaries *solely* as an aid for people reading the code.
Leo's colorer uses only the name x.attributeDictDict;
Leo's colorer never uses the actual names of attribute dictionaries.</t>
<t tx="ekr.20060511074853">Leo 4.4 Final                                                     May 11, 2006

Leo 4.4 Final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.
  To enable autocompletion, bind a key to the auto-complete command.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060525104232">import leo.core.leoPlugins as leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        p,s = controller.writeNodeToString(ext='.html')
        print '*' * 40,p
        print s
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20060525110135"># Problems with pdf files.

import leo.core.leoPlugins as leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        p,s = controller.writeNodeToString(ext='.pdf')
        print '*' * 40,p
        print s
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20060525110135.1">import leo.core.leoPlugins as leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        p,s = controller.writeNodeToString(ext='.tex')
        print '*' * 40,p
        print s
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20060525110217">import leo.core.leoPlugins as leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        p,s = controller.writeNodeToString(ext=None) # Convert rst nodes to rst text.
        print '*' * 40,p
        print s
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20060527103630">A new method has been added to make it more easily to write rST code from scripts::

    c.rstCommands.writeNodeToString(p)

writeNodeToString scans p's tree (p defaults to presently selected node) looking for @rst nodes.
When the first @rst node is found, writeNodeToString processes the node as usual, with the following changes:

- @rst need not be followed by a filename; any filename and its extension are *ignored*.

- Only the ext argument to writeNodeToString determines the type of output produced.
  The valid values for the ext argument are None (for rst output), '.html', '.pdf', and '.tex'.

- Instead of writing the result to a file, writeNodeToString returns the tuple (p,s),
  where p is the node whose tree produced the output, and s is the output itself.

- writeNodeToString returns after processing at most one @rst node.

Scripts can easily use writeNodeToString to convert @rst trees into various kinds of output.
For example::

    p,s = c.rstCommands.writeNodeToString(p,ext='html')

Notes:

- This script scans the presently selected tree for @rst nodes.
  In particular, if the presently selected tree does not contain an @rst node the search continues in parent trees.
  When an @rst node is found, it converts the node (and descendants) to html and returns p,
  the found @rst node and s, the html itself.
  
- Valid values for the ext argument are ".html", ".tex" or None (specifies rst output)

- There is some support for ext=".pdf", but this is experimental code.  Expect crashes.</t>
<t tx="ekr.20060527105211">@language rest</t>
<t tx="ekr.20060527105617">#######################################
Chapter 16: Debugging with Leo
#######################################

This chapter discusses debugging Python scripts with Leo.
Be aware of the distinction between **Leo-specific** scripts and **general** scripts.
Leo-specific scripts access data in the Leo outline in which they are contained;
general scripts do not.

.. .. contents::
</t>
<t tx="ekr.20060527105804">.. External links...
.. _Idle:                       http://www.python.org/idle/
.. _pdb:                        http://docs.python.org/lib/module-pdb.html
.. _winpdb:                     http://www.digitalpeers.com/pythondebugger/
.. _`the FAQ`:                  http://webpages.charter.net/edreamleo/FAQ.html#how-can-i-use-python-s-pdb-debugger-with-leo
.. _`embedded winpdb`:          http://www.digitalpeers.com/pythondebugger/embedded.htm
.. _`Leo's forums`:             http://sourceforge.net/forum/?group_id=3458
.. _`work flow`:                http://webpages.charter.net/edreamleo/FAQ.html#how-can-i-use-leo-to-develop-leo-itself

.. .. _`running Leo in a console`: http://webpages.charter.net/edreamleo/FAQ.html#how-can-i-run-leo-from-a-console-window
.. _`running Leo from a console window`:    install.html#running-leo-from-a-console-window
.. _`run Leo in a console window`:          install.html#running-leo-from-a-console-window
.. _`console window`:                       install.html#running-leo-from-a-console-window</t>
<t tx="ekr.20060527112801">The following settings in leoSettings.leo control debugger operation.
The settings shown here will be assumed to be in effect throughout this chapter.

@string debugger_kind = winpdb

This setting controls what debugger the 'Debug Script' script button uses.
Eventually this setting will control what debugger the debug command uses.
At present the only valid value is 'winpdb'

@bool write_script_file = True

True: The execute script command writes the script to be executed to a file,
then executes the script using Python's execFile function. The script_file_path
setting specifies the path to this file. False (legacy): The execute script
command uses Python's exec command to execute the script.

@string script_file_path = ../test/scriptFile.py

The path to the file to be written by the execute-script command. Notes:

- This setting has effect only if the write_script_file setting is True.
- Use / as the path delimiter, regardless of platform.
- The default path is ../test/scriptFile.py if no path is given.
- The path starts at g.app.loadDir, so for example ../test/scriptFile.py is equivalent to leo/test/scriptFile.py.
- The filename should end in .py.

@string debugger_path = None

</t>
<t tx="ekr.20060529053407">@ignore can only be used in the root node of @thin trees.  It tells Leo to ignore the tree.

The @ignore directive can not be used elsewhere in @thin trees because of the way Leo recreates 
outlines from external files. This is an absolutely crucial restriction and will never go away.
For a few more details, see `Leo 4.0: Eliminating error 'recovery'`_ in `Chapter 9: History of Leo`_.

There are several workaround, as shown in LeoPy.leo:

- keep notes in the outline outside of any external file.

- Use @all to gather notes in a external file, as in done in @thin leoProjects.txt.</t>
<t tx="ekr.20060601101643">Leo 4.4.1 beta 1                                            June 3, 2006

Leo 4.4.1 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.1:
----------------------------
- A new colorizer plugin controlled by jEdit language description files.
  At present this plugin only reliably colors @language python code.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://webpages.charter.net/edreamleo/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help and toggle-invisibles.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060601101958.1"></t>
<t tx="ekr.20060601101958.13">http://sourceforge.net/forum/message.php?msg_id=3737745

- Added event keyword argument to parameterize function.</t>
<t tx="ekr.20060601101958.14">http://sourceforge.net/forum/message.php?msg_id=3737745

The fix was to add a c argument to g.findTopLevelNode and g.findNodeInTree.
</t>
<t tx="ekr.20060601101958.16"></t>
<t tx="ekr.20060601101958.172">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3575014

Actually, the run-unit-tests command first appeared in Leo 4.4, but it never got
properly announced.</t>
<t tx="ekr.20060601101958.174">http://sourceforge.net/forum/message.php?msg_id=3729823

This is intended to help with redraw problems on Linux.</t>
<t tx="ekr.20060601101958.2">http://sourceforge.net/forum/message.php?msg_id=3729858

Fixed crasher in Leo 4.4 by initing self.p in Quickfind ctor.</t>
<t tx="ekr.20060601101958.218"></t>
<t tx="ekr.20060601101958.234"></t>
<t tx="ekr.20060601101958.235">It is now clearer what the selected values are.</t>
<t tx="ekr.20060601101958.238"></t>
<t tx="ekr.20060601101958.239"></t>
<t tx="ekr.20060601101958.244">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3737745

Added warnings in various places that the setting:

@bool expanded_click_area = True

interferes with the  Universal Scrolling plugin.</t>
<t tx="ekr.20060601101958.245">The add-editor command adds a new editor, the delete-editor command deletes the
presently selected editor, and the cycle-editor-focus command cycles focus
between editors in the body text.</t>
<t tx="ekr.20060601101958.264">@nocolor

leoSettings.leo now contains the following setting, with default as shown:

@bool autoindent_in_nocolor_mode = True


True:  auto-indent regardless of how text is colored.
False: disable auto-indenting if in range @nocolor or @kill.

This will make the default action work as Roger Erens requested, and will allow
you to make Leo work exactly as before if you want.</t>
<t tx="ekr.20060601101958.276">@shortcut nodes never worked and apparently nobody ever used them.</t>
<t tx="ekr.20060601101958.277"></t>
<t tx="ekr.20060601101958.28"></t>
<t tx="ekr.20060601101958.52">This runs the winpdb debugger in a separate process.

The winpdb debugger must be installed for this command to work.

For more details, see: http://webpages.charter.net/edreamleo/debuggers.html</t>
<t tx="ekr.20060601101958.56">This fixes all conflicts between Leo and Idle.</t>
<t tx="ekr.20060601101958.58"></t>
<t tx="ekr.20060601101958.6">http://sourceforge.net/forum/message.php?msg_id=3737879</t>
<t tx="ekr.20060601101958.70">- Allow \1, \2, etc. replacements in re searches.

- Allow \n and \t in plain searches.

- The shortcut for the replace-string command now changes from the find command
to the replace command.</t>
<t tx="ekr.20060601102802"></t>
<t tx="ekr.20060601102802.2"></t>
<t tx="ekr.20060601112502">This plugin puts two buttons in the icon area.
The 'Save Hoist' button hoists the presently selected node and creates a button
which can later rehoist the same node.
The 'Dehoist' button performs one level of dehoisting.

This plugin replaces the old chapters plugin.</t>
<t tx="ekr.20060602142732">

leoKeys.py handles key bindings.
There are two kinds of bindings, gui bindings and pane bindings.

**Gui bindings** are the actual binding as seen by Tkinter (or whatever gui is in effect).
Leo binds every key that has a binding to k.masterKeyHander.
For Tkinter, a *separate* binding must be made, rather than a single &lt;Key&gt; binding,
because, alas, Tkinter key events provide insufficient enough information
to tell what key actually caused the key event(!)
This is a significant hole in Tkinter's event mechanism.

At present Leo makes gui bindings in several places, all equivalent.
Bindings are made to callbacks, all of which have this form::

     def callback(event=None,k=k,stroke=stroke):
        return k.masterKeyHandler(event,stroke)

As a result, changing gui bindings actually has no effect whatever.
It would be clearer to have a single place to make these bindings...

In any case, the purpose of these callbacks is to capture the value of 'stroke' so
that it can be passed to k.masterKeyHandler.
This relieves k.masterKeyHandler of the impossible task of computing the stroke from the event.
**Important**:  No function argument is ever passed to k.masterKeyHandler from these callbacks,
because k.masterKeyHandler binds keys to command handlers as described next.

**Pane bindings** are bindings represented by various Python dictionaries in the keyHandlerClass
(see below).
k.masterKeyHandler and its helpers use these dictionaries to call the proper command or mode handler.
This logic is hairy, but it is completely separate from the gui binding logic.

Here are the dictionaries that k.masterKeyHandler uses:

- c.commandsDict:
  Keys are minibuffer command names; values are functions f.

- k.inverseCommandsDict:
  Keys are f.__name__l values are emacs command names.

- k.bindingsDict:
  Keys are shortcuts; values are *lists* of g.bunch(func,name,warningGiven).

- k.masterBindingsDict:
  Keys are pane names: 'all','text',etc. or mode names.
  Values are dicts:  keys are strokes; values are g.Bunch(commandName,func,pane,stroke).

- k.modeWidgetsDict:
  Keys are mode names; values are lists of widgets to which bindings have been made.

- k.settingsNameDict:
  Keys are lowercase settings; values are 'real' Tk key specifiers.
  Important: this table has no inverse.

- inverseBindingDict:
  This is *not* an ivar; it is computed by k.computeInverseBindingDict().
  Keys are emacs command names; values are *lists* of shortcuts.</t>
<t tx="ekr.20060603072938">This prompts for a string s, then puts the result of help(s) in Leo's log pane.</t>
<t tx="ekr.20060603081045">Creates a 'Shortcut' button in the icon area.
Pressing the Shortcut button creates *another* button which when pressed will
select the presently selected node at the time the button was created.</t>
<t tx="ekr.20060603081537">This plugin creates a 'Shortcut' button in the icon area. Pressing the Shortcut
button creates *another* button which when pressed will select the presently
selected node at the time the button was created.</t>
<t tx="ekr.20060603082009">http://sourceforge.net/forum/message.php?msg_id=3761285

There were actually two bugs:
    
- parseLeoSentinel was not recognizing the closing comment delim (!!)

- putDirective was incorrectly setting delims for @language and @comment delims.
  This is wrong: the init code calls scanAllDirectives, and the comment delims
  **must not change** in the file (except as the result of @delims.)</t>
<t tx="ekr.20060612102055">@language rest</t>
<t tx="ekr.20060612103240">####################################
Chapter 13: Writing Plugins
####################################

.. .. contents::
</t>
<t tx="ekr.20060612103824">.. External links...
.. _docutils:             http://docutils.sourceforge.net
.. _LaTeX:                http://www.latex-project.org/
.. _reStructuredText:     http://docutils.sourceforge.net/rst.html
.. _SilverCity:           http://silvercity.sourceforge.net

.. Relative links...
.. _`Event handlers`:                           scripting.html#event-handlers
.. _`Chapter 7\: Scripting Leo with Python`:    scripting.html
.. _`Chapter 8\: Customizing Leo`:              customizing.html
</t>
<t tx="ekr.20060613062025.1">These commands are for debugging Leo itself::

    collect-garbage
    debug
    disable-gc-trace
    dump-all-objects
    dump-new-objects
    dump-outline
    enable-gc-trace
    free-tree-widgets
    print-focus
    print-gc-summary
    print-stats
    verbose-dump-objects</t>
<t tx="ekr.20060613062025.10">These commands put Leo into various kinds of modes.

- The enter-x-mode commands enter modes defined by \@mode nodes in leoSettings.leo
  (or in other .leo files).

- The set-command-state, set-insert-state, set-overwrite-state commands
  determine how treats unbound plain keys. Leo ignores such keys in command
  state, inserts them into the body pane in insert state, and overwrites the
  character at the cursor position in overwrite state.

- Other commands determine whether autocompletion or calltips are in effect.

- When extend mode is effect, basic editing commands that move the cursor also
  extend the selected text.
  For example, in extend mode the back-char command works the same as the
  back-char-extend-selection command.

Here is the full list of mode-related commands::

    auto-complete
    auto-complete-force
    disable-autocompleter
    disable-calltips
    enable-autocompleter
    enable-calltips
    enter-apropos-mode
    enter-commands-mode
    enter-edit-mode
    enter-emacs-mode
    enter-extract-mode
    enter-file-mode
    enter-gui-mode
    enter-help-mode
    enter-kill-mode
    enter-modes-mode
    enter-move-outline-mode
    enter-outline-mode
    enter-quick-command-mode
    enter-toggle-find-mode
    exit-named-mode
    set-command-state
    set-extend-mode
    set-insert-state
    set-overwrite-state
    set-silent-mode
    show-calltips
    show-calltips-force
    toggle-autocompleter
    toggle-calltips
    toggle-extend-mode
    toggle-input-state</t>
<t tx="ekr.20060613062025.2">The following commands print various helpful messages.
Apropos commands print longer discussions of specific topics.
The help-for-command command prompts for a command name
(you can use typing completion to specify the command)
and then prints a brief description of that command::

    apropos-autocompletion
    apropos-bindings
    apropos-find-commands
    help
    help-for-command
    mode-help
    print-bindings
    print-commands
    python-help</t>
<t tx="ekr.20060613062025.4">The following commands work just like their Emacs counterparts.
Use the help-for-command command for further details::

    abbrev-mode
    add-global-abbrev
    add-space-to-lines
    add-tab-to-lines
    advertised-undo
    append-to-buffer
    append-to-register
    call-last-keyboard-macro
    capitalize-word
    center-line
    center-region
    clean-lines
    clear-extend-mode
    clear-kill-ring
    clear-rectangle
    clear-selected-text
    close-rectangle
    copy-rectangle-to-register
    copy-text
    copy-to-register
    count-region
    dabbrev-completion
    dabbrev-expands
    delete-comments
    delete-file
    delete-indentation
    delete-rectangle
    delete-spaces
    diff
    digit-argument
    downcase-region
    downcase-word
    end-kbd-macro
    escape
    eval-expression
    expand-region-abbrevs
    fill-paragraph
    fill-region
    fill-region-as-paragraph
    flush-lines
    full-command
    goto-char
    how-many
    increment-register
    indent-region
    indent-relative
    indent-rigidly
    indent-to-comment-column
    insert-body-time
    insert-file
    insert-keyboard-macro
    insert-parentheses
    insert-register
    inverse-add-global-abbrev
    jump-to-register
    keep-lines
    keyboard-quit
    kill-all-abbrevs
    kill-buffer
    kill-line
    kill-paragraph
    kill-rectangle
    kill-region
    kill-region-save
    kill-sentence
    kill-word
    line-number
    list-abbrevs
    list-buffers-alphabetically
    load-file
    make-directory
    match-bracket
    name-last-kbd-macro
    negative-argument
    number-command
    number-command-0
    number-command-1
    number-command-2
    number-command-3
    number-command-4
    number-command-5
    number-command-6
    number-command-7
    number-command-8
    number-command-9
    open-rectangle
    point-to-register
    prepend-to-buffer
    prepend-to-register
    read-abbrev-file
    remove-blank-lines
    remove-directory
    remove-sentinels
    remove-space-from-lines
    remove-tab-from-lines
    rename-buffer
    repeat-complex-command
    reverse-region
    run-unit-tests
    select-paragraph
    set-comment-column
    set-fill-column
    set-fill-prefix
    shell-command
    shell-command-on-region
    sort-columns
    sort-fields
    sort-lines
    split-line
    start-kbd-macro
    string-rectangle
    suspend
    switch-to-buffer
    tabify
    transpose-chars
    transpose-lines
    transpose-words
    unindent-region
    universal-argument
    unmark-all
    untabify
    upcase-region
    upcase-word
    view-lossage
    view-register
    what-line
    yank
    yank-pop
    yank-rectangle
    zap-to-character</t>
<t tx="ekr.20060613062025.5">Here is a list of all of Leo's find commands.
The apropos-find-commands command will print a detailed
help message discussing these commands::

    clone-find-all
    find-character
    find-tab-change
    find-tab-change-all
    find-tab-change-then-find
    find-tab-find
    find-tab-find-all
    find-tab-find-prev
    find-word
    isearch-backward
    isearch-backward-regexp
    isearch-forward
    isearch-forward-regexp
    isearch-with-present-options
    query-replace
    query-replace-regex
    re-search-backward
    re-search-forward
    replace-string
    search-again
    search-backward
    search-forward
    search-with-present-options
    set-find-everywhere
    set-find-node-only
    set-find-suboutline-only
    toggle-find-ignore-case-option
    toggle-find-in-body-option
    toggle-find-in-headline-option
    toggle-find-mark-changes-option
    toggle-find-mark-finds-option
    toggle-find-regex-option
    toggle-find-reverse-option
    toggle-find-word-option
    toggle-find-wrap-around-option
    word-search-backward
    word-search-forward</t>
<t tx="ekr.20060613062025.6">The following basic editing commands are typically bound to key strokes::

    back-char
    back-char-extend-selection
    back-paragraph
    back-paragraph-extend-selection
    back-sentence
    back-sentence-extend-selection
    back-to-indentation
    back-word
    back-word-extend-selection
    backward-delete-char
    backward-kill-paragraph
    backward-kill-sentence
    backward-kill-word
    beginning-of-buffer
    beginning-of-buffer-extend-selection
    beginning-of-line
    beginning-of-line-extend-selection
    cut-text
    delete-char
    end-of-buffer
    end-of-buffer-extend-selection
    end-of-line
    end-of-line-extend-selection
    exchange-point-mark
    extend-to-word
    forward-char
    forward-char-extend-selection
    forward-paragraph
    forward-paragraph-extend-selection
    forward-sentence
    forward-sentence-extend-selection
    forward-word
    forward-word-extend-selection
    insert-newline
    move-lines-down
    move-lines-up
    move-past-close
    move-past-close-extend-selection
    newline-and-indent
    next-line
    next-line-extend-selection
    paste-text
    previous-line
    previous-line-extend-selection
    redo
    select-all
    set-mark-command
    undo</t>
<t tx="ekr.20060613062025.7">The following commands invoke Leo's outline commands::

    clone-node
    contract-all
    contract-node
    contract-or-go-left
    contract-parent
    copy-node
    cut-node
    de-hoist
    delete-node
    demote
    expand-to-level-1
    expand-to-level-2
    expand-to-level-3
    expand-to-level-4
    expand-to-level-5
    expand-to-level-6
    expand-to-level-7
    expand-to-level-8
    expand-to-level-9
    expand-all
    expand-and-go-right
    expand-next-level
    expand-node
    expand-or-go-right
    expand-prev-level
    go-back
    go-forward
    goto-first-node
    goto-first-sibling
    goto-last-node
    goto-last-sibling
    goto-last-visible
    goto-line
    goto-line-number
    goto-next-changed
    goto-next-clone
    goto-next-marked
    goto-next-node
    goto-next-sibling
    goto-next-visible
    goto-parent
    goto-prev-node
    goto-prev-sibling
    goto-prev-visible
    hoist
    insert-node
    mark
    mark-changed-items
    mark-changed-roots
    mark-clones
    mark-subheads
    move-outline-down
    move-outline-left
    move-outline-right
    move-outline-up
    outline-to-CWEB
    outline-to-noweb
    paste-node
    paste-retaining-clones
    promote
    sort-children
    sort-siblings</t>
<t tx="ekr.20060613062025.8">Here are various miscellaneous minibuffer commands::

    about-leo
    add-comments
    check-all-python-code
    check-outline
    check-python-code
    clear-recent-files
    convert-all-blanks
    convert-all-tabs
    convert-blanks
    convert-tabs
    execute-script
    export-headlines
    exit-leo
    extract
    extract-names
    extract-section
    flatten-outline
    goto-global-line
    import-at-file
    import-at-root
    import-cweb-files
    import-derived-file
    import-flattened-outline
    import-noweb-files
    insert-headline-time
    new
    open-leoDocs-leo
    open-leoPlugins-leo
    open-leoSettings-leo
    open-offline-tutorial
    open-online-home
    open-online-tutorial
    open-outline
    open-outline-by-name
    open-python-window
    open-with
    open-with-idle
    open-with-word
    open-with-wordpad
    pretty-print-all-python-code
    pretty-print-python-code
    read-at-file-nodes
    read-outline-only
    reformat-paragraph
    revert
    save-buffers-kill-leo
    save-file
    save-file-as
    save-file-to
    settings
    set-colors
    set-font
    show-colors
    show-find-options
    show-fonts
    show-invisibles
    spell-change
    spell-change-then-find
    spell-find
    spell-ignore
    tangle
    tangle-all
    tangle-marked
    toggle-angle-brackets
    untangle
    untangle-all
    untangle-marked
    weave
    write-abbrev-file
    write-at-file-nodes
    write-dirty-at-file-nodes
    write-missing-at-file-nodes
    write-outline-only</t>
<t tx="ekr.20060613062025.9">The following commands simulate mouse clicks, double-clicks or drags::

    abort-edit-headline
    activate-cmds-menu
    activate-edit-menu
    activate-file-menu
    activate-help-menu
    activate-outline-menu
    activate-plugins-menu
    activate-window-menu
    add-editor
    cascade-windows
    click-click-box
    click-headline
    click-icon-box
    close-window
    contract-body-pane
    contract-log-pane
    contract-outline-pane
    contract-pane
    cycle-editor-focus
    cycle-focus
    delete-editor
    double-click-headline
    double-click-icon-box
    edit-headline
    end-edit-headline
    equal-sized-panes
    expand-body-pane
    expand-log-pane
    expand-outline-pane
    expand-pane
    focus-to-body
    focus-to-log
    focus-to-minibuffer
    focus-to-tree
    fully-expand-body-pane
    fully-expand-log-pane
    fully-expand-outline-pane
    fully-expand-pane
    hide-body-pane
    hide-find-tab
    hide-invisibles
    hide-log-pane
    hide-mini-buffer
    hide-outline-pane
    hide-pane
    hide-spell-tab
    iconify-frame
    minimize-all
    open-compare-window
    open-find-dialog
    open-find-tab
    open-spell-tab
    press-rst3-button
    press-save-button
    press-spell-button
    resize-to-screen
    scroll-down
    scroll-down-extend-selection
    scroll-outline-down-line
    scroll-outline-down-page
    scroll-outline-up-line
    scroll-outline-up-page
    scroll-up
    scroll-up-extend-selection
    show-mini-buffer
    simulate-begin-drag
    simulate-end-drag
    toggle-active-pane
    toggle-invisibles
    toggle-mini-buffer
    toggle-split-direction</t>
<t tx="ekr.20060620094033">@language rest</t>
<t tx="ekr.20060620094033.1"></t>
<t tx="ekr.20060620094033.2"></t>
<t tx="ekr.20060620094425">##########################################
What's New in Leo 4.4
##########################################

This page summarizes the changes made in Leo 4.4.
For full details see the release notes section in LeoDocs.leo.

The main features of Leo 4.4 are:

- An Emacs-like mini-buffer: you can now execute any command by typing its long
  name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
  and paragraph manipulation, and commands to manipulate buffers, the kill ring,
  regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
  Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
  dialogs, making those commands much easier to use. Plugins or scripts can easily
  create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.
  To enable autocompletion, bind a key to the auto-complete command.

.. .. contents::</t>
<t tx="ekr.20060620094645">Leo 4.4.1 beta 2                                            June 23, 2006

Leo 4.4.1 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.1:
----------------------------
- A new colorizer plugin controlled by jEdit language description files.
  At present this plugin only reliably colors @language python code.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://webpages.charter.net/edreamleo/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help and toggle-invisibles.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060620094645.103"></t>
<t tx="ekr.20060620094645.106"></t>
<t tx="ekr.20060620094645.107">Leo now supports bindings of the form:

command-name !command = shortcut

You will find examples in leoSettings.leo in the node

@keys EKR bindings: vim mode bindings--&gt;Shortcuts--&gt;@shortcuts top-level keys

Such bindings are essential for all plain key bindings that are *only* to be executed in command mode.  Most, but *not* all plain key bindings should be bound in the !command 'pane'.  The two exceptions presently are '.' which *always* invokes the autocompleter code and '(' which *always* invokes the calltips code.

It is now possible to have a *single* set of key bindings be 'Emacs-like' and
'Vim-like' at the same time. See the node EKR bindings: vim mode bindings in
leoSettings.leo.

One setting switches between emacs-like operation and vim-like operation:

For emacs, use:
@strings  [ignore,insert,overwrite] top_level_unbound_key_action = insert

For vim, use:
@strings  [ignore,insert,overwrite] top_level_unbound_key_action = ignore

Vim-like modes are made possible by two new features:

1. Entry commands in @mode nodes. In the body of @mode nodes, lines of the form

--&gt; command-name

tell Leo to execute the command when entering the mode. More than one such lines
may exist; Leo executes them in the order they appear. Entry commands are
potentially a very powerful feature. To avoid chaos, entry commands should not
alter the minibuffer :-)

2. Silent modes. In order to keep the selected text visible, Leo must *not* move
focus into the minibuffer for editing commands. The set-silent-mode command
tells Leo to treat the mode described in the @mode node as a silent mode. A true
mode is created, but it only affects key bindings and the minibuffer never
becomes active.

Thus, all @mode nodes for vim-like modes contain the following line:

--&gt; set-silent-mode.</t>
<t tx="ekr.20060620094645.108">All sets of key bindings in leoSettings.leo now start with @keys in the headline
of the root node. The @keys convention is used *only* by the Check Bindings
script. So now, instead of having a static list of key bindings sets (which is
guaranteed to get out-of-date), the Check Bindings script can scan all of
leoSettings.leo for sets of key bindings.

Another improvement to the Check Bindings script. Besides doing a better job of
checking, you may now specify optional commands, such as commands defined in
plugins. The Check Bindings will not complain if the commands don't presently
exists in k.commandsDict. You specify such commands by adding items to the
following lists in the root node of the Check Bindings script, i.e., the node
Buttons--&gt;@button Check Bindings.

optionalCommandPrefixes = ['group-operations']
optionalCommandNames = []</t>
<t tx="ekr.20060620094645.109">- added isearch-with-present-options.
- many small improvements to isearch code.
- regex searches now highlighted properly.
- isearches are (and should be) confined to a single body text.
- Backspace now handled properly.

A small glitch. Starting a regexp pattern with '.' will cause the entire pattern
to turn red initially, which is technically correct but perhaps a bit
confusing.</t>
<t tx="ekr.20060620094645.194">http://sourceforge.net/forum/message.php?msg_id=3767016</t>
<t tx="ekr.20060620094645.225"></t>
<t tx="ekr.20060620094645.231">The commands that enable and disable calltips now update the status line.</t>
<t tx="ekr.20060620094645.232">Creating a script button creates the press-xxx-button command,
and you can specify settings for such commands using @shortcuts nodes.</t>
<t tx="ekr.20060620094645.233"></t>
<t tx="ekr.20060620094645.234">@nocolor

The scripting plugin now creates a press-x-button command for each scripting button named x.
You can bind shortcuts to such commands by placing @shortcuts nodes in an @setting tree in the outline containing the @button nodes.  test.leo shows an example.

What I did:
    
- The scripting plugin now defines button bindings with the 'button' pane specifier.
  This takes precedence over all other specifiers.

- k.bindKeyToDict now does a better job of detecting and warning about redefinitions.

- k.printBindings now properly sorts entries.
  This was causing me a great deal of confusion.

- k.registerCommand now properly gets shortcuts from settings if possible,
  and makes bindings in the new 'button' pane specifier.

- masterKeyHandlerHelper now supports the 'button' pane specifier,
  which overrides all others.

@color</t>
<t tx="ekr.20060620094645.242"></t>
<t tx="ekr.20060620094645.243">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3772475

Maybe put a link to the html TOC into the Help Menu,
"%leodir%/doc/html/leo_TOC.html".

This is more intuitive (to newbies) than the LeoDocs.leo link.  I found this
very confusing in the beginning.

What I did:
    
- Created open-users-guide command.
- Created Open Users Guide menu item.
- Removed Open Offline Tutorial menu item.

@color</t>
<t tx="ekr.20060620094645.252"># Important: this can be done better using per-pane bindings as in the default leoSettings.leo.</t>
<t tx="ekr.20060620094645.258"></t>
<t tx="ekr.20060620094645.286"></t>
<t tx="ekr.20060620094645.299">http://sourceforge.net/forum/message.php?msg_id=3778744

Added editor_orientation setting: valid values are vertical and horizontal.</t>
<t tx="ekr.20060620094645.302"></t>
<t tx="ekr.20060620094645.303">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3767601
http://sourceforge.net/forum/message.php?msg_id=3768413
Craig

I have an @thin file with @Doc and @Code sections scattered though out the tree,
where each node has one or more doc and code sections.

I would like to be able to use the rst3 plugin to produce an html file containing
only info from the doc sections, ignoring the code sections.

I added the </t>
<t tx="ekr.20060620094645.304">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3770732
By: ktenney

In &lt;&lt; Theory of operation of find/change &gt;&gt; 
the opening paragraph does not appear in the html,
</t>
<t tx="ekr.20060620094645.305">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3780216
Craig

In Doc_Only_Mode the rst3 plugin outputs headlines irrespective of the show_headlines
setting.  The other modes do honor this setting.

I scratched around and managed to fix this by changing the node: rst3.py--&gt;class
rstClass--&gt;write methods--&gt;writeBody &amp; helpers--&gt;handleDocOnlyMode

In Line 25 I added a new statement:
     if showHeadlines:
and indented the following 3 lines to make them conditional on this if:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.headString())
            self.writeHeadlineHelper(p)</t>
<t tx="ekr.20060620094645.306">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3785400
By: craigj3


I have a @url node pointing to a Leo file which has a filename with %20 in it.
When I double-click this node I get:

"can not open: \\\Documents%20and%20Settings\tftcj1.EDCON\My%20Documents\Proj\RI
CAA\PcasCellLink.leo"

Taking a look with a debugger, I see that Plugins--&gt;Enhancing the icon and status
areas--&gt;@thin UNL.py--&gt;onUrl1 line 29ish does not covert %20 to spaces before
calling openWithFileName.</t>
<t tx="ekr.20060620094645.307">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3783225
Craig

I am looking at the image plugin for organizing photos, and discovered that
it is limited to gif files only.  I found this a bit silly as installing the
ImageTk module from the Python Imaging Library and making a two line change
to the plugin enables it to be used on practically any image type.

The two line are:
1.  a new import:-
import ImageTk

2. In &lt;&lt;select image&gt;&gt; line 9 change 
photo = Tk.PhotoImage(master=a.root, file=filename)

to

photo = ImageTk.PhotoImage(master=a.root, file=filename)</t>
<t tx="ekr.20060620094645.308">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3779706
By: mstarzyk

My point was not about not found CSS, but that .html files are written to
default_path directory, but .txt files are not written to default_path
directory.</t>
<t tx="ekr.20060620094645.309">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3784636
By: craigj3

I note that the scheduler plugin is currently broken.

The problem was that all commands now get an event arg.

The Begin Recording and End Recording commands do not seem to work...</t>
<t tx="ekr.20060620094645.310">##########################################
What's New in Leo 4.4.1
##########################################

This page summarizes the changes made in Leo 4.4.1.
For full details see the release notes section in LeoDocs.leo.

The main features of Leo 4.4.1 are:

- Multiple editors in Leo's body pane and
- A new colorizer plugin controlled by jEdit language description files.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://webpages.charter.net/edreamleo/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help and toggle-invisibles.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

.. .. contents::</t>
<t tx="ekr.20060620094645.34"></t>
<t tx="ekr.20060620094645.35"></t>
<t tx="ekr.20060620094645.43"></t>
<t tx="ekr.20060620094645.44">Called c.bringToFront() after open/save/import dialogs.</t>
<t tx="ekr.20060620094645.45">FAIL: @test return ends editing of headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 155, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 14, in ?
AssertionError: oops2

----------------------------------------------------------------------
Ran 438 tests in 193.628s

FAILED (failures=1)
&gt;&gt;&gt;
</t>
<t tx="ekr.20060620094645.46">http://sourceforge.net/forum/message.php?msg_id=3764077</t>
<t tx="ekr.20060620094645.50"></t>
<t tx="ekr.20060620094645.52">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3771032
By: paulpaterson

The cycle-editor-focus command causes Leo to lock up  on my machine (WinXP,
Python 2.4).

@color
</t>
<t tx="ekr.20060620094645.64">http://sourceforge.net/forum/message.php?msg_id=3771014</t>
<t tx="ekr.20060620094645.68">lstrip and rstrip do not exist in Python 2.2.1.</t>
<t tx="ekr.20060620094645.76">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3778764
By: davidmcnab

When I hit my 'change-editor-focus' binding, the cursor jumps
to unpredictable places within the next editor pane.
</t>
<t tx="ekr.20060620094645.77"></t>
<t tx="ekr.20060620094645.78"></t>
<t tx="ekr.20060620094645.79">Added makeMasterGuiBinding.</t>
<t tx="ekr.20060620094645.85"></t>
<t tx="ekr.20060620094645.86"></t>
<t tx="ekr.20060620094645.96"></t>
<t tx="ekr.20060620094645.97"></t>
<t tx="ekr.20060620095655">- The print-bindings command now properly sorts bindings.
- The help-for-command command now works for almost all commands.
- Improved filename completion.
- Better listings for print-commands and print-bindings &amp;amp; mode-help commands.
- Allow shortcuts to be overridden outside of leoSettings.leo.
- Finished Cmds menu.
- Improved show-fonts command.
- Strip quotes from color, font settings.
- Warn about invalid Enter and Leave key bindings.</t>
<t tx="ekr.20060620095949.15">- Removed warning about changed node.
- Added scroll-outline-left/right commands.
- Leo outputs decorators correctly, assuming the decorator does not conflict with a Leo directive.
- Wrote script to convert g.es to g.et where appropriate.
  The first step in translating all Leo messages.
- Leo highlights (flashes) matching brackets when typing typing (, ), [, ], { or }.
- Fixed long-standing problem reporting indentation errors.
- Fixed long-standing bug in Remove Sentinels command.
- Fixed long-standing bugs in import commands.
- The scroll-up/down commands now scroll the outline if focus is in outline pane.
  However, his can be done better using per-pane bindings as in the default leoSettings.leo.
- Incremental searches are (properly) confined to a single body text.
- Backspace now handled properly in incremental searches.
- The add-editor command adds a new editor in the body pane.
  The delete-editor command deletes the presently selected editor,
  and the cycle-editor-focus command cycles focus between editors in the body text.
- The standard \1, \2, etc. replacements can now be performed in regular expression searches.
- The standard escapes \n and \t are now valid in plain searches.
- The shortcut for the replace-string command now changes from the find command
  to the replace command.</t>
<t tx="ekr.20060620095949.25">::

    @bool autoindent_in_nocolor_mode
    @bool flash_matching_brackets
    @bool idle_redraw
    @bool trace_bind_key_exceptions
    @bool warn_about_redefined_shortcuts
    @color flash_brackets_background_color
    @color flash_brackets_foreground_color
    @int flash-brackets-delay
    @int flash_brackets_count
    @string close_flash_brackets
    @string open_flash_brackets
    @string editor_orientation</t>
<t tx="ekr.20060620130636">::

    cycle-focus
    debug
    find-character
    find-word
    hide-invisibles 
    isearch-with-present-options
    open-users-guide
    python-help
    run-unit-test
    toggle-autocompleter
    toggle-calltips
    toggle-invisibles</t>
<t tx="ekr.20060620130943">- The slideshow plugin
- The mod_scripting plugin now creates a press-x-button command for every button 'x'.
  You can specify settings for such commands using @shortcuts nodes.
- The shortcut_button plugin plugin creates a 'Shortcut' button in the icon area.
  Pressing the Shortcut button creates *another* button which when pressed
  will select the presently selected node at the time the button was created.
- Added Debug button to scripting plugin.
</t>
<t tx="ekr.20060620133820.16">- Added script to update new copies of leoSetttings.leo from previous copies.
- Made all edit command undoable.
- Improved registerCommand.
- Suppressed autocompletion after numbers.
- Added colorizing support for Lua language.
- Added run-unit-test command.
- Autocompletion and calltips.
- Leo remembers the previous open directory.
- Fixed problem with view plugin.
- Installed cleo patch.
- User input modes.
- Installed many standard bindings to leoSettings.leo.
- Added Check Bindings script in leoSettings.leo.
- Scripts now maintain original focus.
- Improved cursor move/extend commands.
- Added support for @mode nodes.
- keyboard-quit restores default input mode.
- Created ut.leo, ut.py and ut.bat.
- Added modes/\*.xml to distribution.
- Revised cursor movement commands and added selection-extension commands.
- Added classic key bindings in leoSettings.leo.
- Allow multiple key bindings to the same command.
- Settings command now opens leoSettings.leo.
- Moved all scripts into scripts.leo.
- Improved how the New Tab and Rename Tab commands work in the log pane.
- Improved the appearance of the Spell tab.
- Added Clone-find checkbox to the Find tab.
- Improved find tab.
- Improved formatting of shortcuts in print-commands and print-bindings.
- Added settings for vim plugin.
- Put up a dialog if can't import Pmw.
- Bound &lt;Return&gt; to end-edit-headline.
- Leo now ignores key bindings in menu tables.
- Created scripts.leo and unitTest.leo.
- c.executeMinibufferCommand executes a minibuffer command by name.
- Improved perl entries in language dicts. 
- The tabbed log.
- The Find tab replaces the old Find panel; the old Find panel is deprecated.</t>
<t tx="ekr.20060620140130">- Changed path to stylesheet in the rst3 plugin.
- Fixed crasher in Word (and other) plugins.
- Fixed problem with labels plugin.
- Added the following commands for the groupoperations plugin::

    group-operations-clear-marked
    group-operations-mark-for-copy
    group-operations-mark-for-move
    group-operations-mark-for-clone
    group-operations-mark-target
    group-operations-operate-on-marked
    group-operations-transfer

- Installed cleo patch.
- The scripting plugin now supports shortcuts in @button nodes::

    @button name @key=shortcut

- The scripting plugin now supports @command nodes::

    @command name @key=shortcut</t>
<t tx="ekr.20060620140228">Added new settings::

    @bool allow_idle_time_hook
    @bool autocomplete-brackets.
    @bool gc_before_redraw
    @bool minibufferSearchesShowFindTab
    @bool show_only_find_tab_options
    @bool show_tree_stats
    @bool trace_autocompleter
    @bool trace_bindings
    @bool trace_doCommand
    @bool trace_f.set_focus
    @bool trace_focus
    @bool trace_g.app.gui.set_focus
    @bool trace_gc
    @bool trace_gc_calls
    @bool trace_gc_verbose
    @bool trace_key_event
    @bool trace_masterClickHandler
    @bool trace_masterCommand
    @bool trace_masterFocusHandler
    @bool trace_masterKeyHandler
    @bool trace_minibuffer
    @bool trace_modes
    @bool trace_redraw_now
    @bool trace_select
    @bool trace_status_line
    @bool trace_tree
    @bool trace_tree_alloc
    @bool trace_tree_edit
    @bool useCmdMenu
    @bool useMinibuffer
    @bool use_syntax_coloring
    @color body_text_selection_background_color
    @color body_text_selection_foreground_color.
    @color log_pane_Find_tab_background_color
    @color log_pane_Spell_tab_background_color, etc.
    @int max_undo_stack_size,
    @string trace_bindings_filter
    @string trace_bindings_pane_filter

- Added @shortcuts nodes.
- Leo now supports per-pane bindings of the form::

    command-name ! pane = shortcut

- The spelling settings replace the settings in spellpyx.ini.</t>
<t tx="ekr.20060621075135">This section provides step-by-step instructions for turning a script button into a plugin.
The plugin will define a minibuffer command that does the same thing as pressing the button.

We shall start with a script button whose script is::

    g.es_print('c: %s' % (c.fileName()),color='red')
    g.es_print('p: %s' % (p.h),color='red')

Not very exciting, but it uses the predefined c and p constants.
Our plugin will create a minibuffer command called print-cp.

Here are the step-by-step instructions:

1. Open leoPlugins.leo and use the Copy Node command to copy the tree at:

Plugins--&gt; Templates: these show recommended ways of defining plugins.--&gt;Template for Tk plugin with per-commander controller class

2. Paste the tree somewhere else and rename it to @thin print_cp.py.
   I copied the tree to::

    Plugins--&gt;Example code--&gt;@thin print_cp.py

3. Update the docstring, the __version__ constant and the &lt;&lt; imports &gt;&gt; section.
   Note that unlike when using script buttons, you must have the following imports::

    import leo.core.leoGlobals as g
    import leo.core.leoPlugins as leoPlugins

4. Because this plugin doesn't require any gui interface, we simplify the init function::

    def init ():
        leoPlugins.registerHandler('after-create-leo-frame',onCreate)
        return True

   The init function registers the onCreate hook and
   returns True to indicate that it loaded properly.

5. Leave the onCreate function unchanged.
   It creates a per-commander instance of the pluginController class.
   This class exists mainly to bind self.c properly to a commander.

6. Change the constructor (__init__ method) of the pluginController class to this::

    def __init__ (self,c):
        self.c = c
        c.k.registerCommand('print-cp',shortcut=None,func=self.print_cp)
        script = "c.k.simulateCommand('print-cp')"
        g.app.gui.makeScriptButton(c,script=script,buttonText='Print c &amp; p',bg='red')

   This registers the print_cp *method* of the pluginController class as the print-cp minibuffer command,
   and creates a script button with the following script::

       c.k.simulateCommand('print-cp')

7. Define the print_cp method as follows::

    def print_cp (self,event=None):
        c = self.c ; p = c.p
        g.es_print('c: %s' % (c.fileName()),color='red')
        g.es_print('p: %s' % (p.h),color='red')

   The print_cp method must have the event argument as shown because it implements a minibuffer command.
   The print_cp method gets the proper commander from the c ivar (instance variable) and computes
   the current position p as shown.

8. Enable the print_cp plugin by putting the following in an @enabled-plugins node::

    print_cp.py

9. Test the plugin by restarting Leo (I just start test.leo).
   You can test the plugin by pressing the 'Print c&amp;p' button
   or by typing &lt;Alt-x&gt; print-cp &lt;Return&gt;.

That's all.  You can find the completed version of the print_cp plugin in leoPlugins.leo,
or leoPluginsRef.leo if you are using cvs.</t>
<t tx="ekr.20060621132338">.. Links used in this document.
</t>
<t tx="ekr.20060621132547">.. Links used in this document.
</t>
<t tx="ekr.20060622130553">
http://sourceforge.net/forum/message.php?msg_id=3784292

http://webpages.charter.net/edreamleo/install.html#updating-settings-from-previous-versions-of-leo</t>
<t tx="ekr.20060622130553.2">http://sourceforge.net/forum/message.php?msg_id=3778946

http://webpages.charter.net/edreamleo/writingPlugins.html#turning-script-buttons-into-plugins</t>
<t tx="ekr.20060622130815">http://sourceforge.net/forum/message.php?msg_id=3790857</t>
<t tx="ekr.20060622130815.3">http://sourceforge.net/forum/message.php?msg_id=3790814</t>
<t tx="ekr.20060622130815.9"></t>
<t tx="ekr.20060622132524"></t>
<t tx="ekr.20060629083400.1">Leo 4.4.1 beta 3                                            June 29, 2006

Leo 4.4.1 beta 3 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.1:
----------------------------
- A new colorizer plugin controlled by jEdit language description files.
  At present this plugin only reliably colors @language python code.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://webpages.charter.net/edreamleo/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help and toggle-invisibles.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060629083935">Leo 4.4 was a year-long effort to incorporate an Emacs-style minibuffer and
related commands into Leo. Thinking in terms of minibuffer commands frees my
thinking. Leo 4.4 also featured many improvements in how keys are bound to
commands, including per-pane bindings and user-defined key-binding modes.

Development on long-delayed projects accelerated after 4.4 final went out the door.
Recent projects include:

- Controlling syntax coloring with jEdit's xml language-description files.
  See Chapter 15.
- Support for debugging scripts using external debuggers.
  See Chapter 16.
- Modifying Leo's vnodes and tnodes so that Leo's data can be used with ZODB.
  See Chapter 17.
- Using pymacs to write Leo scripts within Emacs.
  See Chapter 18.
- Using the leoBridge module to embed Leo support in other programs.
  See Chapter 19.
- Using Leo to run unit tests.
  See Chapter 20.</t>
<t tx="ekr.20060629083935.100">@killcolor

@bool flash_matching_brackets: True: flash matching bracket when typing (, ), [, ], { or }.

@color flash_brackets_background_color and @color flash_brackets_foreground_color.

@int flash_brackets_count: The number of times to flash matching brackets.

@int flash-brackets-delay: One half the total cycle time of bracket flashes, in milliseconds.</t>
<t tx="ekr.20060629083935.15">http://sourceforge.net/forum/message.php?msg_id=3510448

The fix was to getLastTracebackFileAndLineNumber.

I also created handleScriptException.</t>
<t tx="ekr.20060629083935.2"></t>
<t tx="ekr.20060629083935.25">http://sourceforge.net/forum/message.php?msg_id=3413805</t>
<t tx="ekr.20060629083935.3"></t>
<t tx="ekr.20060629083935.32">- Underindented comments do not end the scan of Python classes or methods.
- Handles continued signature lines properly.</t>
<t tx="ekr.20060629083935.61">Note: Editing headline text will happen in insert mode unless

@strings top_level_unbound_key_action = overwrite</t>
<t tx="ekr.20060629083935.70">After executing a command we must be careful to test c.exists.
</t>
<t tx="ekr.20060629083935.71">- A better trace, and the trace goes to the log pane.

- Eliminated k.keysymHistory: Tk keysyms are pretty useless.
</t>
<t tx="ekr.20060629083935.74"></t>
<t tx="ekr.20060629083935.75">@nocolor

- Improved prompt.
- Added message if no previous complex command.
- Added mode entries.</t>
<t tx="ekr.20060629083935.76">http://sourceforge.net/forum/message.php?msg_id=3794854</t>
<t tx="ekr.20060629083935.8">http://sourceforge.net/forum/message.php?msg_id=3795258

The column display doesn't change while typing.

</t>
<t tx="ekr.20060629083935.93">@killcolor

Here are the relevant settings:
    
@bool flash_matching_brackets: True: flash matching bracket when typing (, ), [, ], { or }.

@color flash_brackets_background_color and @color flash_brackets_foreground_color.

@int flash_brackets_count: The number of times to flash matching brackets.

@int flash-brackets-delay: One half the total cycle time of bracket flashes, in milliseconds.
</t>
<t tx="ekr.20060629083935.96"></t>
<t tx="ekr.20060629083935.97"># Ctrl-k is no longer needed by the match-brackets command now that brackets flash automatically.</t>
<t tx="ekr.20060629083935.98"></t>
<t tx="ekr.20060629083935.99">When True, this provides a full traceback for all exceptions taken when binding keyboard shortcuts.</t>
<t tx="ekr.20060805094325">You can 'revert' to old key bindings as follows:

1. Open leoSettings.leo.

2. Find the node 'Keyboard shortcuts'.

3. Disable the old bindings by moving the node
   '@keys EKR bindings: Emacs keys + modes'
   so that it is a child of the node:
   '@ignore Unused key bindings'.

4. Notice that there are two child nodes of the node
   '@ignore Unused key bindings'
   that refer to legacy key bindings:

   - '@keys Legacy Leo shortcuts with important Emacs bindings'

   - '@keys Legacy Leo bindings'.

5. Move **one** of these two legacy nodes up one level so that it is a child of the node
   'Keyboard shortcuts'.
   It should **not** be a child of the node
   '@ignore Unused key bindings'.</t>
<t tx="ekr.20060822111759">By Rich Ries

There is no direct way to make script buttons available in multiple Leo files.
Sure, you could copy and paste the @button nodes, but there is a slightly
easier way using the "New Buttons" plugin.

1) Create and test and debug your desired Script Button.

2) With the Script Button node selected, run Plugins --&gt; New buttons --&gt; Make Template From

Open a new Leo file.

3) Assuming you have only the one New Button Template defined, left-click the
   New button, and a new node will be added to your outline. (Otherwise, you'll
   need to select the Template you want.)

4) Press [Script Button] to create the new script button.

It's easier to *do* this than to *explain* it!</t>
<t tx="ekr.20060822140418"></t>
<t tx="ekr.20060822140418.1">Leo 4.4.1 beta 4                                            August 24, 2006

Leo 4.4.1 beta 4 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.1:
----------------------------
- Leo outputs decorators correctly, provided that the decorator is not a Leo directive.
- A new colorizer plugin controlled by jEdit language description files.
- A new shadow files plugin that allows external files not to have sentinel lines.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://webpages.charter.net/edreamleo/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help, toggle-invisibles,
  and scroll-outline-left/right.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060822140418.26">http://sourceforge.net/forum/message.php?msg_id=3839322</t>
<t tx="ekr.20060822140418.29">http://sourceforge.net/forum/message.php?msg_id=3805745</t>
<t tx="ekr.20060822140418.3"></t>
<t tx="ekr.20060822140418.36">http://sourceforge.net/forum/message.php?msg_id=3841115

There is still some doubt about what the best operation of this command should be.</t>
<t tx="ekr.20060822140418.39">http://leo.zwiki.org/9RussianUnicodeWordsAreNotDetectedProperlyInBodyPane</t>
<t tx="ekr.20060822140418.4">http://sourceforge.net/forum/forum.php?thread_id=1542384&amp;forum_id=10228</t>
<t tx="ekr.20060822140418.41">http://sourceforge.net/forum/message.php?msg_id=3874380

Setting a value for background color in the body pane had no effect.

There were several problems, among which conflicting and confusing settings.
In particular, the insert_mode_bg_color setting overrides the body_text_background_color setting.

I changed the code so that insert_mode_bg_color defaults to
body_text_background_color, and put all the settings for the body text in one
place.</t>
<t tx="ekr.20060822140418.49"></t>
<t tx="ekr.20060822140418.69"></t>
<t tx="ekr.20060822140418.70">http://sourceforge.net/forum/message.php?msg_id=3802624

Added @font menu font setting</t>
<t tx="ekr.20060822140418.76">http://sourceforge.net/forum/message.php?msg_id=3834645</t>
<t tx="ekr.20060822140418.77">http://sourceforge.net/forum/message.php?msg_id=3802513

Added these settings:
    
@string open_flash_brackets = ([{
@string close_flash_brackets = )]}</t>
<t tx="ekr.20060822140418.88">Leo *already* outputs decorators correctly, assuming the decorator does not conflict with a Leo directive.</t>
<t tx="ekr.20060822140418.92">http://sourceforge.net/forum/message.php?msg_id=3858363</t>
<t tx="ekr.20060822140418.97">These were overly complicated an not useful.</t>
<t tx="ekr.20060830141224">Leo 4.4.1 final                                            August 30, 2006

Leo 4.4.1 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.1:
----------------------------
- Leo outputs decorators correctly, provided that the decorator is not a Leo directive.
- A new colorizer plugin controlled by jEdit language description files.
- A new shadow files plugin that allows external files not to have sentinel lines.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://webpages.charter.net/edreamleo/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help, toggle-invisibles,
  and scroll-outline-left/right.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060830141224.13"></t>
<t tx="ekr.20060830141224.14"></t>
<t tx="ekr.20060830141224.15">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3885494
By: mikecrowe

OK, I found out how to duplicate this one.  This caused me a lot of grief until
I found out what is causing it.

NodeA:
...Child1
...Child2
...Child3

NodeB:
...CloneChild1
...CloneChild2
...CloneChild3

Now, put cursor on NodaA.  Ctrl-Shift-C (copy node).
Next, put cursor on CloneChild3.  Paste Node as Clone
You should get an invalid paste clone message.

Now, first cursor move (for me) puts NodeB as top node, ERASING all other nodes.
Warning:  DO NOT SAVE NOW.  It will erase all other nodes.
</t>
<t tx="ekr.20060830141224.16">@nocolor

- Created getLeoOutlineHelper.  This simplifies the code.
- Init self.checking in getLeoFile and getLeoOutline.
- Use self.checking in getVnodes, getVnode and createVnode.
  Using self.checking in getVnode complicates an already way-too-complex method, but it can't be helped.</t>
<t tx="ekr.20060830141224.2"># Possibly a less intrusive warning should be used.</t>
<t tx="ekr.20060830141224.37"></t>
<t tx="ekr.20060830141224.38">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3886250
By: znafets

A .leoID.txt with a \n behind the idstring creates a problem. 
It will be read in g.app.leoID and being used as is when writing the Leo file.

The fix is in app.setLeoID -&gt; &lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;</t>
<t tx="ekr.20060830141224.45"></t>
<t tx="ekr.20060830141224.46">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3890031
By: terry_n_brown

I have a tree of some 2500 nodes, run a script that marks
probably 1500-2000 of them, and that's quick (2-3 seconds max.).

I can clear all the marks with:

for p in c.all_positions():
    p.v.clearMarked()

and that also is quick (2-3 seconds max.).  But when I use the menu option Unmark
All, that takes forever (1-2 minutes :-) running 100% CPU all the while.</t>
<t tx="ekr.20060830142929">This section discusses only those settings that affect syntax coloring.
See `Chapter 8`_ for a general discussion of Leo's settings.

Both the old colorizer (in Leo's core) and the new colorizer (the threading_colorizer plugin)
now support @font settings for colorizing options.
The settings for the old colorizer are::

    comment_font, cweb_section_name_font, directive_font,
    doc_part_font, keyword_font, leo_keyword_font, section_name_font,
    section_name_brackets_font, string_font, undefined_section_name_font,
    latexBackground_font, and latex_background_font.

The settings for the new colorizer are all of the above (except keyword_font) plus the following::

    comment1, comment2_font, comment3_font, comment4_font, function_font,
    keyword1_font, keyword2_font, keyword3_font, keyword4_font, label_font,
    literal1_font, literal2_font, literal3_font, literal4_font, markup_font,
    null_font, and operator_font.

To specify a font, say for keyword_font, to be used as the default font for **all** languages,
put the following in the body text of an @font node in leoSettings.leo::

    # keyword_font_family = None
    keyword_font_size = 16
    keyword_font_slant = roman
        # roman, italic
    keyword_font_weight = bold
        # normal, bold

Comments are allowed and undefined settings are set to reasonable defaults. 
At present, comments can not follow a setting: comments must start a line.

You can specify per-language settings by preceding the settings names by a prefix x.
Such settings affect only colorizing for language x (i.e., all the modes in modes/x.py when using the new colorizer).
For example, to specify a font for php (only), put the following in the body text of an @font node in leoSettings.leo::

    # php_keyword_font_family = None
    php_keyword_font_size = 16
    php_keyword_font_slant = roman
        # roman, italic
    php_keyword_font_weight = bold
        # normal, bold</t>
<t tx="ekr.20060903102158">Leo 4.4.1.1 final                                       September 3, 2006

Leo 4.4.1.1 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.1.1 corrects a serious last-minute unicode bug in Leo 4.4.1.
This version also adds the new slideshow plugin.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.1:
----------------------------
- Leo outputs decorators correctly, provided that the decorator is not a Leo directive.
- A new colorizer plugin controlled by jEdit language description files.
- A new shadow files plugin that allows external files not to have sentinel lines.
- A new slide show plugin allows you to use Leo outlines as slide shows.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://webpages.charter.net/edreamleo/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help, toggle-invisibles,
  and scroll-outline-left/right.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060913164304">@language rest</t>
<t tx="ekr.20060913164304.1">#######################################
Chapter 17: Using ZODB with Leo
#######################################

This chapter discusses how to write Leo scripts that store and retrieve data using ZODB_.

.. .. contents::
</t>
<t tx="ekr.20060913164311">.. External links...
.. _ZODB:               http://www.zope.org/Wikis/ZODB/guide/zodb.html
.. _`Installing ZODB`:  http://www.zope.org/Wikis/ZODB/guide/node3.html#SECTION000310000000000000000
</t>
<t tx="ekr.20060913165542.1"></t>
<t tx="ekr.20060913165542.2">This function inits the zodb.
pathToZodbStorage is the full path to the zodb storage file.
You can call g.init_zodb as many times as you like.
Only the first call for any path actually does anything:
subsequent calls for a previously opened path simply return the same value as the first call.</t>
<t tx="ekr.20060913165542.3">This vnode method returns v2, a copy of v that is completely detached from the
outline. v2.fileIndex is unrelated to v.fileIndex initially, but is may be
convenient to copy this field::

    v2 = v.detach()
    v2.fileIndex = v.fileIndex</t>
<t tx="ekr.20060913170145">To enable zodb scripting within Leo, you must set use_zodb = True in the root node of leoNodes.py.
You must also install ZODB itself.  See `Installing ZODB`_ for details.

When ZODB is installed and use_zodb is True
Leo's vnode and tnode classes become subclasses of ZODB.Persistence.Persistent.
This is all that is needed to save/retrieve vnodes or tnodes to/from the ZODB.

**Important notes**:

- Scripts **should not** store or retrieve positions using the ZODB!
  Doing so makes sense neither from Leo's point of view nor from ZODB's point of view.

- The examples below show how to store or retrieve Leo data by accessing
  the so-called root of a ZODB connection.
  However, these are only examples.
  Scripts are free to do with Leo's vnodes and tnodes *anything* that can
  be done with ZODB.Persistence.Persistent objects.</t>
<t tx="ekr.20060913170403">Scripts should call g.init_zodb to open a ZODB.Storage file.
g.init_zodb returns an instance of ZODB.DB.  For example::

    db = g.init_zodb (zodbStorageFileName)

You can call g.init_zodb as many times as you like.
Only the first call for any path actually does anything:
subsequent calls for a previously opened path simply return the same value as the first call.</t>
<t tx="ekr.20060913170403.1">The following script writes v, a tree of vnodes, to zodb::

    db = g.init_zodb (zodbStorageFileName)
    connection = db.open()
    try:
        root = connection.root()
        root[aKey] = v # See next section for how to define aKey.
    finally:
        get_transaction().commit()
        connection.close()

Notes:

- v must be a vnode (or a tnode).
  Scripts should *not* attempt to store Leo positions in the zodb.
  v can be the root of an entire outline or a subtree.
  For example, either of the following would be reasonable::

    root[aKey] = c.rootPosition().v
    root[aKey] = c.p.v

- To write a single vnode without writing any of its children you can use v.detach.
  For example::

    root[aKey] = v.detach()

- **Important**: It is simplest if only one zodb connection is open at any one time,
  so scripts would typically close the zodb connection immediately after processing the data.
  The correct way to do this is in a finally statement, as shown above.

- The script above does not define aKey.
  The following section discusses how to define reasonable zodb keys.</t>
<t tx="ekr.20060913170403.2">The following script reads a tree of vnodes from zodb and sets p as the root position of the tree::

    try:
        connection = db.open()
        root = connection.root()
        v = root.get(aKey)
        p = leoNodes.position(v)
    finally:
        get_transaction().commit()
        connection.close()
</t>
<t tx="ekr.20060913175437">The keys used to store and retrieve data in connection.root() can be any string that uniquely identifies the data.
The following are only suggestions: you are free to use any string you like.

1. When saving a file, you would probably use a key that is similar to a real file path.
   For example::

        aKey = c.fileName()

2. When saving a single vnode or tree of vnodes, say v,
   a good choice would be to use v's gnx, namely::

        aKey = g.app.nodeIndices.toString(v.fileIndex)

   Note that v.detach() does not automatically copy v.fileIndex to the detached node,
   so when writing a detached node you would typically do the following::

       v2 = v.detach()
       v2.fileIndex = v.fileIndex
       aKey = g.app.nodeIndices.toString(v2.fileIndex)</t>
<t tx="ekr.20060913175437.1">The scripts shown above close the zodb connection after processing the data.
This is by far the simplest strategy.
I recommend it for typical scripts.

**Important**: you must **leave the connection open** if your script modifies persistent data in any way.
(Actually, this statement is not really true,
but you must define zodb transaction managers if you intend to use multiple connections simultaneously.
This complication is beyond the scope of this documentation.)
For example, it would be possible to create a new Leo outline from the data just read,
but the script must leave the connection open.
I do not recommend this tactic, but for the adventurous here is some sample code::

    connection = self.db.open()
    root = connection.root()
    v = root.get(fileName)
    if v:
        c2 = c.new()
        c2.openDirectory = c.openDirectory # A hack.
        c2.mFileName = fileName # Another hack.
        c2.beginUpdate()
        try:
            c2.setRootVnode(v)
            c2Root = c2.rootPosition()
            c2.atFileCommands.readAll(c2Root)
            g.es_print('zodb read: %s' % (fileName))
        finally:
            c2.endUpdate()
        # Do *not* close the connection while the new Leo window is open!
    else:
        g.es_print('zodb read: not found: %s' % (fileName))


This will work **provided** that no other zodb connection is ever opened while this connection is opened.
Unless special zodb precautions are taken (like defining zodb transaction managers)
calling get_transaction().commit() will affect **all** open connections.
You have been warned.</t>
<t tx="ekr.20060915112109">Find the @thin leoApp.py node in leoPy.leo.
In the ctor for the LeoApp class set self.use_psyco to True or False.
You will find this ctor in the node::

    Code--&gt;Core classes...--&gt;@thin leoApp.py--&gt;app.__init__

Note that this ivar can not be set using settings in leoSettings.leo because
Leo uses g.app.use_psyco before processing configuration settings.</t>
<t tx="ekr.20060917130130">Add the following to the start of your scripts::

    @first # -*- coding: utf-8 -*-

Without this line, constructs such as::

    u = u'a-(2 unicode characters here)-z'
    u = 'a-(2 unicode characters here)-z'

will not work when executed with Leo's execute script command.
Indeed, the Execute Script command creates the script by writing the tree
containing the script to a string. This is done using Leo's write logic, and
this logic converts the unicode input to a utf-8 encoded string. So *all
non-ascii characters* get converted to their equivalent in the utf-8 encoding. 
Call these encoding &lt;e1&gt; and &lt;e2&gt;. In effect the script becomes::

    u = u'a-&lt;e1&gt;-&lt;e2&gt;-z'
    u = 'a-&lt;e2&gt;-&lt;e&gt;-z'

which is certainly *not* what the script writer intended!
Rather than defining strings using actual characters, Instead, one should use
the equivalent escape sequences. For example::

    u = u'a-\\u0233-\\u8ce2-z'
    u = 'a-\\u0233-\\u8ce2-z'
</t>
<t tx="ekr.20060920054924">.. _OPML:                   http://en.wikipedia.org/wiki/OPML
.. _`OPML 2.0 standard`:    http://www.opml.org

**Warning**: the OPML plugin is not fully functional at present.  Use with caution.

The OPML plugin creates two new commands that read and write
Leo outlines in OPML_ format.
The read-opml-file command creates a Leo outline from an .opml file.
The write-opml-file command writes the present Leo outline to an .opml file.

Various settings control what gets written to .opml files, and in what format.
As usual, you specify settings for the OPML plugin using leoSettings.leo.
The settings for the OPML are found in the node::

    @settings--&gt;Plugins--&gt;opml plugin

Here are the settings that control the format of .opml files.
The default values are shown.

- @bool opml_read_derived_files = True

  If True, Leo reads external files when reading .opml files.

- @string opml_namespace = leo:com:leo-opml-version-1

  The namespace urn for the xmlns attribute of &lt;opml&gt; elements.
  This value typically is not used, but it should refer to Leo in some way.

- @bool opml_use_outline_elements = True

  If True, Leo writes body text to &lt;:body&gt; elements nested in &lt;outline&gt; elements.
  Otherwise, Leo writes body text to :body attributes of &lt;outline&gt; elements.

  **Note**: Leo-specific attributes and elements are clearly distinguished from 'standard' opml elements:
  they are preceded by a colon, which marks them as members of the default namespace specified specified
  by this option.  Thus, all OPML text generated by this plugin should conform to the `OPML 2.0 standard`_.

- @string opml_version = 2.0

  The opml version string written to the &lt;OPML&gt; element.
  Use 2.0 unless there is a specific reason to use 1.0.

- @bool opml_write_body_text = True

  If True, Leo writes body text to the OPML file.

- @bool opml_write_derived_files = True

  If True, Leo writes external files when writing .opml files.

- @bool opml_write_leo_details = True

  If True, Leo writes the native attributes of Leo's &lt;v&gt; elements
  as attributes of the opml &lt;outline&gt; elements.
  The native attributes of &lt;v&gt; elements are
  a, descendentTnodeUnknownAttributes, expanded, marks,
  t, and tnodeList.

- @bool opml_write_leo_globals_attributes = True

  If True, Leo writes body_outline_ratio and global_window_position
  attributes to the &lt;head&gt; element of the .opml file.

- @bool opml_write_uAs = True

  If True, Leo writes unknown attributes (uA's) in &lt;:uA&gt; sub-elements of &lt;outline&gt; elements.</t>
<t tx="ekr.20060920145745">Three commands in the Cmds-&gt;Body Editors menu allow one to create, destroy, or focus on separate editors in the body pane.
- The ``add-editor`` (Cmds-&gt;Body Editors-&gt;Add Body Editor) command adds a new editor in the body pane and gives it the body editor focus.
- The ``delete-editor`` (Cmds-&gt;Body Editors-&gt;Delete Body Editor) command deletes the editor with body editor focus.
- The ``cycle-editor-focus`` (Cmds-&gt;Body Editors-&gt;Change Body Editor) command cycles body editor focus between editors in the body text.

There is a single body editor focus which determines which body editor shows the content of the selected outline node and which allows that node to be edited; other body editors continue to show the node contents they last had when they had the body editor focus.
</t>
<t tx="ekr.20060921064744.1">This section describe the format of external files.
Leo's `sentinel lines`_ are comments, and this section describes those comments.

The format of external files produced by Leo 4.0 and later meets the following goals:

- The minimum of sentinels needed to properly recreate the outline.

- A robust way of telling whether newlines belong to sentinels or not.
  Prior to Leo 4.0, deleting blank lines before and after sentinel lines
  could corrupt the outline structure of the external file.

- A minimum of intrusion and ugliness.

**New in Leo 4.2**:
Files derived from @thin use gnx's in @+node and @-node sentinels.
Such gnx's permanently and uniquely identify nodes.
Gnx's have the form::

    id.yyyymmddhhmmss
    id.yyyymmddhhmmss.n

The second form is used if two gnx's would otherwise be identical.

- id is a string unique to a developer, e.g., a cvs id.

- yyyymmddhhmmss is the node's creation date.

- n is an integer.

Here are the sentinels used by Leo, in alphabetical order.
Unless otherwise noted, the documentation applies to all versions of Leo.
In the following discussion, gnx denotes a gnx as described above.

\@&lt;&lt;
    A sentinel of the form @&lt;&lt;section_name&gt;&gt; represents a section reference.

    If the reference does not end the line,
    the sentinel line ending the expansion is followed by the remainder of the reference line.
    This allows the Read code to recreate the reference line exactly.

\@@
    The @@ sentinel represents any line starting with @ in body text
    except @*whitespace*, @doc and @others.
    Examples::

      @@nocolor
      @@pagewidth 80
      @@tabwidth 4
      @@code

\@afterref **(Leo 4.0 and later)**
    Marks non-whitespace text appearing after a section references.

\@+all **(Leo 4.0 and later)**
    Marks the start of text generated by the @all directive.

\@-all **(Leo 4.0 and later)**
    Marks the end of text generated by the @all directive.

\@at and \@doc
    The @+doc and @-doc sentinels delimit doc parts within a node that starts with @doc.
    These sentinels are nested within @body directives.
    Similarly, @+at and @-at sentinels delimit doc parts within a node that start with @ *whitespace*.
    We use the following **trailing whitespace convention**
    to determine where putDocPart has inserted line breaks::

        A line in a doc part is followed by an inserted newline
        if and only if the newline if preceded by whitespace.

    To make this convention work,
    Leo's write code deletes the trailing whitespace of all lines that are followed by a "real" newline.

    **Leo 4.0 and later**:
    The @+doc and @+at sentinels now contain the whitespace that follows
    the corresponding @doc or @ directives.

\@+body **(Leo 3.x only)**
    Marks the start of body text.

\@-body **(Leo 3.x only)**
    Marks the end of body text.

\@delims
    The @delims sentinel inserts @@delims sentinels into the external file.
    The new delimiter strings continue in effect until the next @@delims sentinel
    *in the external file* or until the end of the external file.
    Adding, deleting or changing @@delim *sentinels* will destroy Leo's ability to read the external file.
    Mistakes in using the @delims *directives* have no effect on Leo,
    though such mistakes will thoroughly mess up a external file as far as compilers,
    HTML renderers, etc. are concerned. 

\@+leo
    Marks the start of any external file.
    This sentinel has the form::

        &lt;opening_delim&gt;@leo&lt;closing_delim&gt;

    The read code uses single-line comments if &lt;closing_delim&gt; is empty.
    The write code generates single-line comments if possible.

    **New in Leo 4.0**: The @+leo sentinel contains other information following
    @leo.  For example::

        &lt;opening_delim&gt;@leo-ver=4-thin&lt;closing_delim&gt;

\@-leo
    Marks the end of the Leo file.
    Nothing but whitespace should follow this directive.

\@+middle **(Leo 4.0 and later)**
    Marks the start of intermediate nodes between the node that
    references a section and the node that defines the section.
    Typically no such sentinels are needed: most sections are defined in a direct child of the referencing node.

\@-middle **(Leo 4.0 and later)**
    Marks the end of intermediate nodes between the node that
    references a section and the node that defines the section.

\@+node and \@-node
    Mark the start and end of a node.

    **Leo 4.2 and later**::
    @+node and @-node sentinels use gnx's as described above::

        @+node:gnx:&lt;headline&gt;
        @-node:gnx:&lt;headline&gt;

    Leo generates these sentinels only for nodes containing body text.
    Leo no longer generates other @+node sentinels to indicate outline structure.
    As a result, there is no longer any need for @+body sentinels.

    **Before Leo 4.2**::
    @+node and @-node sentinels used child indices, and status fields as described below::

      @+node:&lt;child_index&gt;:&lt;status_fields&gt;:&lt;headline&gt;
      @-node::&lt;child_index&gt;:&lt;status_fields&gt;:&lt;headline&gt;

    &lt;child_index&gt; is a number from 1 to n indicating the index of the node in the list of its parent's children.
    &lt;status_field&gt; is the cloneIndex field of the form: "C=nnn", where nnn is an immutable clone index.
    &lt;headline&gt; contains *headline* text, not reference text.

\@nl **(Leo 4.0 and later)**
    Adds a newline to the body text.

\@nonl **(Leo 4.0 and later)**
    Suppresses a newline from the body text.

\@others
    The @+others sentinel indicates the start of the expansion of an @+others directive,
    which continues until the matching @-others sentinel.
    @others sentinels are nested within @body sentinels;
    the expansion of the @others directive always occurs within the body text of some node.

\@verbatim
    @verbatim indicates that the next line of the external file is not a sentinel.
    This escape convention allows body text to contain lines that would otherwise be considered sentinel lines.

\@@verbatimAfterRef
    @verbatimAfterRef is generated when a comment following a section reference would otherwise be treated as a sentinel.
    In Python code, an example would be::

      &lt;&lt; ref &gt;&gt; #+others

    This sentinel is required only when blank lines are suppressed between sentinel lines.</t>
<t tx="ekr.20060928172040">Leo 4.4.2 beta 1                                  September 29, 2006

Leo 4.4.2 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.2:
----------------------------
- You can now store settings in myLeoSettings.leo without fear of those settings
  being changed by cvs updates or in future versions of Leo.
- Leo's vnode and tnode classes are now completely independent of the rest of Leo.
  Some api's have been changed.  This 'big reorg' and may affect scripts and plugins.
- Leo's vnode and tnode classes can optionally be compatible with ZODB databases,
  i.e., they can optionally derive from ZODB.Persistence.Persistent.
  See Chapter 17: Using ZODB with Leo for details.
- The leoOPML plugin defines commands to read and write OPML files.
- The slideshow plugin allows Leo to run slideshows defined by @slideshow and @slide nodes.
- The leo_to_rtf and leo_to_html plugins create rtf and html files from Leo outlines.
- Much faster navigation through the outline using Alt-arrow keys.
- When focus is in the outline pane, you can move to headlines by typing the first letter of headlines.
- The find command now closes nodes not needed to show the node containing the present match.
- Numerous changes that make Leo easier to use without using a mouse.
- Many new minibuffer commands now appear in the Cmds menu.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060928172457"></t>
<t tx="ekr.20060928172457.1">##########################################
What's New in Leo 4.4.2
##########################################

This page summarizes the changes made in Leo 4.4.2
For full details see the release notes section in LeoDocs.leo.

.. .. contents::</t>
<t tx="ekr.20060928172457.2">.. Links used in this document.
.. _Emacs:                          http://www.xemacs.org/
.. _pymacs:                         http://pymacs.progiciels-bpi.ca/index.html
.. _`Chapter 18: Leo and Emacs`:    emacs.html
</t>
<t tx="ekr.20060928172457.4">- Added support for controlling Leo from Emacs_ with pymacs_.
  See `Chapter 18: Leo and Emacs`_ for full details.
- Added Minibuffer and Settings submenus of the Cmds menu.
- At long last Leo creates a proper help menu on the Mac.
- Added a new convention for menu tables. If the first item (a string
  representing the menu label) starts with '*' Leo will convert hyphens to
  spaces and upcase the label. This convention allows a single string to
  represent both the menu label and its associated minibuffer command. As part
  of this reorganization, all menu tables in Leo's core now use only strings.
  This is an essential precondition to supporting @menu nodes in
  leoSettings.leo.
- Leo's Help menu now contains the Open scripts.leo command.
- Leo uses ctypes to import Aspell when run from Python 2.5 or later.
  Leo no longer needs Python-specific versions of aspell.dll.
- Added support for x-windows middle-button paste.
  This only works when the paste is made in the pane containing the selected text.
- Leo looks for myLeoSettings.leo files in the same place Leo looks for leoSettings.leo files.
- Created three scripts (in test.leo) that help create unit tests for Leo's edit commands.
  Create Created runEditCommandTest for use by these scripts.
- Improved print-bindings command.
  The bindings are sorted by prefix: this is a big help in understanding bindings.
  For each prefix, first print items with only a single character after the prefix.
- Made writing .leo files faster.
  The new code almost exactly twice as fast as the old.
- Added p.archivedPosition.
  This is a key first step towards Leap 204.
- Integrated sax with read logic.
- You can now store settings in myLeoSettings.leo without fear of those settings
  being changed by cvs updates or in future versions of Leo.
- Eliminated unnecessary redraws when moving the cursor in the outline pane.
- Much faster navigation through the outline using Alt-arrow keys.
- When focus is in the outline pane, you can move to headlines by typing the first letter of headlines.
- The find command now closes nodes not needed to show the node containing the present match.
- Numerous changes that make Leo easier to use without using a mouse.
- Many new minibuffer commands now appear in the Cmds menu.

Further improved outline navigation:

- Generalized navigation in outline pane to ignore @file, @thin, etc prefixes.
- Made outline navigation cumulative.
  When keystrokes in the outline pane are typed 'close' together Leo first tries to look
  for prefix + ch, where ch is the character just typed and prefix is the previous match.
  The term 'close together' is specified by the setting @float outline_nav_extend_delay.
  The outline search revers to a single-character if the extended search
  fails, so in fact the delay is not too significant. In practice everything works
  well without me thinking at all about what is happening.</t>
<t tx="ekr.20060928172457.5">- Improved the mod_scripting plugin. Every button created by the plugin creates
  a corresponding command. The command name is the 'cleaned' version of the
  button name. Likewise, the plugin also creates a delete-x-button command,
  where x is the command name as just discussed. So now you can delete script
  buttons without right-clicking.
- Made 'About Plugin' dialog scrollable.
- Fixed bugs in groupoperations, multifile, nodenavigator and shortcut_button plugins.
- The rst3 plugin now registers the rst3-process-tree command.
- The leoOPML.py plugin defines commands to read and write OPML files.
- The slideshow.py plugin allows Leo to run slideshows defined by @slideshow and @slide nodes.
- The leo_to_rtf and leo_to_html plugins create rtf and html files from Leo outlines.
- The paste_as_headlines.py plugins creates multiple headlines at once.
- The word_count.py plugin.

Improved the mod_scripting plugin:

- Made showing the Run Script button optional.
- The Script Button button now creates the press-script-button-button command.
- A new utility method does a much better job of massaging button and command names.</t>
<t tx="ekr.20060928172525.167"></t>
<t tx="ekr.20060928172525.172">It now prints the binding for the command.</t>
<t tx="ekr.20060928172525.180">Rewrote moveWordHelper. It now avoids Tk and regexes.  *Much* simpler.</t>
<t tx="ekr.20060928172525.195">@nocolor

My present thinking is that scripts should be able to store/retrieve persistent
objects to/from the zodb. That is, the zodb plugin is likely to be retired.

Leo's vnode and tnode classes now derive from ZODB.Persistence.Persistent if
leoNodes.use_zodb is True. It remains to be seen whether having use_zodb = True
will cause any serious problems.

See the posting below (Scripting using zodb) for latest details.

See the node 'zodb get/put buttons' in test.leo for examples of how scripts can access zodb easily.

Created g.init_zodb and v.detach.</t>
<t tx="ekr.20060928172525.197">&gt; Do you see zodb as persisting Leo files or Leo nodes?

Interesting question.  I now see the zodb plugin as a proof-of-concept for *user-defined* scripts.  The zodb plugin is probably going to go away.

Let us suppose that db is a ZODB.DB instance. (To see how to create such an instance, see the init_zodb method in the zodb plugin.  Perhaps I'll defines something like g.openZodb to make this easier.)  Then the statements:

connection = db.open()
root = connection.root()
root[aKey] = v
get_transaction().commit()
connection.close()

will write all of v's data (all vnodes and tnodes) to the zodb.  This is true whatever v is: it can be the root of an entire outline, or any suboutline.  If you want to write a single node, you would have to 'detach' that node from the outline.  You can do this by copying the node and then unlinking the node from its descendants. Perhaps I could add a convenience method to the vnode class to make this easier.

&gt;Do you see zodb work as providing enhanced access to nodes across multiple files?

Scripts could do so easily.  Happily, the distinction between 'long-lived' and 'short-lived' connections is not important for scripts: a script should hold a connection open only for as long as needed.  So it would be easy to write any number of vnode trees to the zodb.  Later, another script could access any of the data in the zodb by zodb key.  Like this:

connection = db.open()
root = connection.root()
v = root.get(aKey)
p = leoNodes.position(v,[])

After running this script, p is a position representing the root of the tree of 'imported' vnodes.  The script above does not 'connect' the imported trees to an outline, nor should it do so.  As I write this, I realize that the position ctor should make the second argument optional, so that leoNodes.position(v) would be equivalent to leoNodes.position(v,[]).

Each script should open at most connection at a time and be sure to close any zodb connection it creates.  The proper way to do this is in a finally statement, like this:

try:
....connection = db.open()
....root = connection.root()
....v = root.get(aKey)
....p = leoNodes.position(v,[])
....&lt;&lt; do something with the nodes in p's tree&gt;&gt;
finally:
....get_transaction().commit()
....connection.close()

In short, the recent changes to Leo's vnode and tnode classes give scripts the ability to save/retrieve Leo data to/from the zodb in any way a script wants, without any further support from Leo, or from me.

I shall spend an hour or two more with the zodb plugin, but it looks to me that the plugin has served its purpose.  Rather than trying to guess how people will want to use the zodb, it will be simpler and more general to have people write scripts that do exactly what they want.  In particular, such scripts can easily sidestep the problems with multiple open connections.

Edward

P.S. Please note that the scripts shown above could not have been written without all the recent work with the zodb plugin and the big code reorg.

P.P.S. A couple of unit tests involving the new v/t.__hash__ methods just failed, so it may be just a little bit longer before the code on cvs is truly zodb ready.  I'll also be working on example scripts and the convenience methods described above.

EKR
</t>
<t tx="ekr.20060928172525.198">- Removed all modes except Alt-C mode.
- Use Shift-arrows for outline moves when focus is in outline pane.
- Put help / apropos commands in help menu.
- Put focus commands in Cmds menu.
- When focus is in outline, normal character navigates like Windows explorer.
- Put Scrolling commands in Cmds menu.
- Screened out(some) unwanted characters from affecting outline navigation.More work is needed.
- Esc character is never inserted into text.
- Replaced @button clones-tab with @command clones-tab.
- Scripting plugins now sets verbose=True so @commands get shown.
* Alt keys (outline move commands) should set focus to outline even if nothing else happens.
- Closing a window no longer puts focus in limbo: added force argument to c.set_focus.
- New gui bindings: (I should actually be able to remember these).
    cycle-all-focus                     = Alt-Y
    contract-pane                       = Alt+Ctrl+-
    expand-pane                         = Alt+Ctrl-=
    focus-to-tree                       = Alt-space
    scroll-outline-down-page            = Alt-PageDn
    scroll-outline-down-page            ! tree = PageDn
    scroll-outline-up-page              = Alt-PageUp
    scroll-outline-up-page              ! tree = PageUp
    scroll-outline-left                 = Alt+Ctrl+LtArrow
    scroll-outline-right                = Alt+Ctrl+RtArrow
- Put find-character and back-find-character in Edit:Find menu.
- Use Alt-S,Alt-R for incremental searches.
- Created find-character-extend-selection and back-find-character-extend-selection.
- Added binding (Ctrl-W) and entry in Cmds menu for select-word-at-cursor.
- Added binding (Ctrl-P) for repeat-complex-command.
- Added binding (Ctrl-B) for execute-script.
* Fixed bug in extend mode.
- Added binding (Ctrl-space) for toggle extend mode.
- Removed most cursor move bindings involving ctrl keys. Exception: ctrl-a and ctrl-e.
    ** The idea is that I'll use extend mode instead.
- Stay in outline mode: added @bool stayInTreeAfterEditHeadline setting.
- Added Cmds:Toggle Settings submenu.
- Use emacs names in Cmds menu (and in some other places): allow single item in menu tables.</t>
<t tx="ekr.20060928172525.237">http://sourceforge.net/forum/message.php?msg_id=3935368</t>
<t tx="ekr.20060928172525.240">http://sourceforge.net/forum/message.php?msg_id=3935780

This greatly speeds searches that used to open many nodes.</t>
<t tx="ekr.20060928172525.252">http://sourceforge.net/forum/message.php?msg_id=3935981

@url nodes of the form::

    @url -- aComment
    
now get the actual url from the entire first line of body text.
Such url's need not be quoted if they contain spaces.

</t>
<t tx="ekr.20060928172525.81">What I did:
    
- Removed c argument from t, v and p ctors.
- Removed c argument from most position methods.
    - In particular, p.link, p.unlink, v.link and v.unlink no longer update c.currentPosition()
    - Moved all position methods that still had a c argument to the Commands class.
- Removed p.all_positions.
- Added c.findRootPosition and c.findRootVnode.
- c.rootPosition now returns c.findRootPosition(c.currentPosition())

As a result:
    
- The tnode, vnode and position classes are *completely* independent of Leo.
  In particular, no tnode, vnode or position method gets a c argument.
- The p.link, p.unlink, v.link and v.unlink are significantly simpler.
- The machinery for keeping the root position up-to-date is
  simple and confined to one place in the Commands class.</t>
<t tx="ekr.20060928194633.1">The myLeoSettings.leo file is a way of ensuring that your customized settings are not altered when updating Leo from cvs or while installing a new version of Leo.  The myLeoSettings.leo acts much like Python's site-customize.py file.  The myLeoSettings.leo file will never be part of any Leo distribution, and it will never exist in Leo's cvs repository.  This solution is *much* better than trying to update leoSettings.leo with scripts.

Leo loads settings from myLeoSettings.leo *after* loading settings from leoSettings.leo files but *before* loading settings from the .leo file being opened.</t>
<t tx="ekr.20060928195040"></t>
<t tx="ekr.20060928195040.1">The following plugins are new in Leo 4.4.2 b2:
    
leo_to_rtf
leo_to_html
leoOPML  (At present, contained in leoOPML.leo instead of leoPlugins.leo)
paste_as_headlines
slideshow
word_count

The __saxRead__.py plugin is an **experimental** for use by EKR.
It will be folded into Leo's core in the near future.</t>
<t tx="ekr.20060928200207.1">This plugin takes an outline stored in LEO and outputs it as a numbered list to
an RTF file. The RTF file can be loaded into Microsoft Word and formatted as a
proper outline.

If this plug-in loads properly, you should have an "Outline to Microsoft RTF"
option added to your File &gt; Export... menu in Leo.

Settings such as outputting just the headlines (vs. headlines &amp; body text) and whether
to include or ignore the contents of @file nodes are stored in the rtf_export.ini file
in your Leo\plugins folder.

The default export path is also stored in the INI file. By default, it's set to c:\ so
you may need to modify it depending on your system.</t>
<t tx="ekr.20060928200207.2">This plugin takes an outline stored in LEO and converts it to html which is
then either saved in a file or shown in a browser.

The outline can be represented as a bullet list, a numbered list or using html
&lt;h?&gt; type headings. Optionally, the body text may be included in the output.

If desired, only the current node will be included in the output rather than
the entire outline.

An xhtml header may be included in the output, in which case the generated html
will be valid XHTML 1.0 Strict.

The plugin is fully scriptable as all its functionality is available through a
Leo_to_HTML object which can be imported and used in scripts.

Several commands and menu items are provided to give easy access to the plugins
various features and options may be set via leo_to_html.ini file and the plugins
properties dialog.</t>
<t tx="ekr.20060928200207.3">This plugin reads and writes Leo outlines in .opml (http://en.wikipedia.org/wiki/OPML) format.

The OPML plugin creates two new commands that read and write Leo outlines in OPML format.
The read-opml-file command creates a Leo outline from an .opml file.
The write-opml-file command writes the present Leo outline to an .opml file.

Various settings control what gets written to .opml files, and in what format.
As usual, you specify settings for the OPML plugin using leoSettings.leo.
The settings for the OPML are found in the node: @settings--&gt;Plugins--&gt;opml plugin

Here are the settings that control the format of .opml files. The default values are shown.

- @string opml_namespace = leo:com:leo-opml-version-1

  The namespace urn for the xmlns attribute of &lt;opml&gt; elements.
  This value typically is not used, but it should refer to Leo in some way.

- @bool opml_use_outline_elements = True

  If True, Leo writes body text to &lt;:body&gt; elements nested in &lt;outline&gt; elements.
  Otherwise, Leo writes body text to :body attributes of &lt;outline&gt; elements.

- @string opml_version = 2.0

  The opml version string written to the &lt;OPML&gt; element.
  Use 2.0 unless there is a specific reason to use 1.0.

- @bool opml_write_body_text = True

  Leo writes body text to the OPML file only if this is True.

- @bool opml_write_leo_details = True

  If True, Leo writes the native attributes of Leo's &lt;v&gt; elements as attributes of
  the opml &lt;outline&gt; elements. The native attributes of &lt;v&gt; elements are a,
  descendentTnodeUnknownAttributes, expanded, marks, t, and tnodeList.

- @bool opml_write_leo_globals_attributes = True

  If True, Leo writes body_outline_ratio` and global_window_position attributes to
  the &lt;head&gt; element of the .opml file.</t>
<t tx="ekr.20060928200600">This plug-in takes any text is stored in the clipboard and creates new headlines
for each line of text. The paste routine checks to make sure the line of text is not
greater than 50 characters in length. If it is, the routine truncates the headline to
50 characters and pastes the entire line into the body text of that node.

If the plug-in is functioning properly, a "Paste as Headlines" option should appear in
the Edit menu directly under the existing Paste option.</t>
<t tx="ekr.20060928201227">This plugin displays a message box with information about the body text of the current node 
such as number of: characters, words, lines, and paragraphs. It adds a "Word Count..." option
to the bottom of the Edit menu that will activate the message box.

The Word Count... menu has a shortcut key of 'W'.</t>
<t tx="ekr.20060928201227.1">This plugin supports slideshows in Leo outlines.

It defines four new commands:

- next-slide-show:  move to the start of the next slide show,
  or the first slide show if no slide show has been seen yet.

- prev-slide-show:  move to the start of the previous slide show,
  or the first slide show if no slide show has been seen yet.

- next-slide: move to the next slide of a present slide show.

- prev-slide: move to the previous slide of the present slide show.

Slides shows consist of a root @slideshow node with descendant @slide nodes.
@slide nodes may be organized via non-@slide nodes that do not appear in the slideshow.

All these commands ignore @ignore trees.</t>
<t tx="ekr.20060929040750">Leo has many commands that select nodes in the outline. These commands can be
found in the Outline:Go To menu.

As described in the tutorial, you can move about the outline by clicking on the headlines or using Alt+arrow keys.

When using the Tk GUI and focus is in the outline Pane, you can move from
node to node by typing the first letter of a headline. For example, typing 'a'
will go to the next visible headline that starts with either 'a' or 'A',
wrapping around to the start of the outline if needed. Typing an uppercase 'A'
will go to the next headline that starts with 'a' or 'A', making the node
visible (expanding its ancestors) if the node was not visible.

When keystrokes (in the outline pane) are typed 'close' together in time Leo
first looks for prefix + ch, where ch is the character just typed and prefix is
the previous match. The term 'close together' is defined in seconds by the setting: 

@float outline_nav_extend_delay = 2.0 

The outline nav search reverts to a single-character search if the extended
search fails, so in fact the delay is not too significant. In practice
everything works well without thinking about what is happening.

This character search navigation is not currently implemented for the Qt interface.
</t>
<t tx="ekr.20060929043325">Leo's vnode and tnode classes are now completely independent of the rest of Leo.
Some api's have been changed.  This 'big reorg' and may affect scripts and plugins.</t>
<t tx="ekr.20060929043325.1">Leo's vnode and tnode classes can optionally be compatible with ZODB databases,
i.e., they can optionally derive from ZODB.Persistence.Persistent.
See Chapter 17: Using ZODB with Leo for details.</t>
<t tx="ekr.20061003204952">Plugins and scripts can create new tabs in the log panel.
The following creates a tab named test or make it visible if it already exists::

    c.frame.log.selectTab('Test')

g.es, g.enl, g.ecnl, g.ecnls write to the log tab specified by the optional
tabName argument. The default for tabName is 'Log'. The put and putnl methods of
the tkinterLog class also take an optional tabName argument which defaults to
'Log'.

Plugins and scripts may call the
c.frame.canvas.createCanvas method to create a log tab containing a Tk.Canvas
widget. Here is an example script::

    log = c.frame.log ; tag = 'my-canvas'
    w = log.canvasDict.get(tag)
    if not w:
        w = log.createCanvas(tag)
        w.configure(bg='yellow')
    log.selectTab(tag)
</t>
<t tx="ekr.20061003204952.1">The c.frame.log class contains the following 'official' ivars::

    g.es('tabName',c.frame.log.tabName)     # The name of the active tab.
    g.es('tabFrame',c.frame.log.tabFrame)   # The Tk.Frame containing all the other widgets of the tab.
    g.es('logCtrl',c.frame.log.logCtrl)     # Tk.Text widget containing the log text.

The following ivars provide access to the body pane::

    g.es('bodyFrame',c.frame.body.frame)    # The Tk.Frame widget containing the c.frame.body.bodyCtrl

The following ivars provide access to the outline pane::

    g.es('canvas',c.frame.tree.canvas) # The Tk.Canvas on which Leo's outline is drawn.

Tkinter provides a way of determining the enclosing widget of any widget.
The body text is enclosed in a Pmw.PanedWidget to support multiple editors.

    w = c.frame.body.bodyCtrl
    parent = w.pack_info().get('in') 
    g.es('bodyCtrl.parent',parent) # The Tk.Frame containing the body text.</t>
<t tx="ekr.20061003204952.2">The following line removes the initial text widget::

    c.frame.log.logCtrl.pack_forget()

To make the text widget visible again::

    c.frame.log.logCtrl.pack(side='top',expand=1,fill='both')

Plugins and scripts can pack any other widgets into c.frame.log.tabFrame.
For example, the following replaces the default text widget with a red box::

    import Tkinter as Tk

    # Remove the old contents.
    w = c.frame.log.logCtrl
    parent =  w.pack_info().get('in')
    w.pack_forget()

    # Replace with a red frame.
    f = c.frame.newLog = Tk.Frame(parent,background='red')
    f.pack(side='left',expand=1,fill='both')

And the following will restore the original pane::

    c.frame.newLog.pack_forget()
    w = c.frame.log.logCtrl
    w.pack(side='left',expand=1,fill='both')</t>
<t tx="ekr.20061003204952.3">Warning: you will find it hard to execute scripts after removing the body pane,
so you had best make the following two scripts into script buttons before
executing them :-)

Plugins and scripts can pack any other widgets into c.frame.log.tabFrame.
For example, the following replaces the default text widget with a red box::

    import Tkinter as Tk

    w = c.frame.body.bodyCtrl
    parent =  w.pack_info().get('in')
    w.pack_forget()

    f = c.frame.newBody = Tk.Frame(parent,background='red')
    f.pack(side='left',expand=1,fill='both')

To restore::

    c.frame.newBody.pack_forget()
    w = c.frame.body.bodyCtrl
    w.pack(side='left',expand=1,fill='both')</t>
<t tx="ekr.20061003204952.4">The following replaces the outline pane with a red frame::

    import Tkinter as Tk

    w = c.frame.tree.canvas
    parent =  w.pack_info().get('in')
    w.pack_forget()

    f = c.frame.newTree = Tk.Frame(parent,background='red')
    f.pack(side='left',expand=1,fill='both')

And this script restores the outline::

    c.frame.newTree.pack_forget()
    c.frame.tree.canvas.pack(side='left',expand=1,fill='both')</t>
<t tx="ekr.20061003212136">The following is no substitute for a full discussion of programming the Tk.Text
widget: it can do lots.

To clear the log::

    w = c.frame.log.logCtrl
    w.delete('1.0','end')

To write a line to the end of the log::

    w = c.frame.log.logCtrl
    w.insert('end','This is a test\n')

To get the entire contents of the log::

    w = c.frame.log.logCtrl
    g.es(w.get('1.0','end')+'\n')</t>
<t tx="ekr.20061008190633.248"></t>
<t tx="ekr.20061008190633.249">http://sourceforge.net/forum/message.php?msg_id=3932641

LEO *always* outputs the first line of a node without indentation even if it is indented in the node.
</t>
<t tx="ekr.20061008190633.250">This was a very weird one.  It's not clear why it wasn't biting before.

Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 321, in &lt;module&gt;
    run(fileName)
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 151, in run
    g.app.gui.runMainLoop()
  File "c:\prog\tigris-cvs\leo\src\leoTkinterGui.py", line 182, in runMainLoop
    self.root.mainloop()
  File "c:\python25\lib\lib-tk\Tkinter.py", line 1023, in mainloop
    self.tk.mainloop(n)
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1756, in __call__
    _reporterror(self.func, args)
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1782, in _reporterror
    msg = exc_type + ' Exception in Tk callback\n'
TypeError: unsupported operand type(s) for +: 'type' and 'str'</t>
<t tx="ekr.20061008190633.257">- created g.isWordChar.  It does proper test for letters and numbers.
- Used g.isWordChar in extendToWord and moveWordHelper.
- OnBodyDoubleClick now just calls c.editCommands.extendToWord.

So Russian characters, e.g., no longer 'interrupt' words.

Another fix: extend-to-word now works properly at the very end of a word.</t>
<t tx="ekr.20061008190633.261">Installer does not complain about missing Python and does not install anything
either. Here is a fix to this behavior. In most user-friendly way it would be
better to provide a clickable link to Python site and a way to specify the path
manually, but for now it is just that - a fix.</t>
<t tx="ekr.20061008190633.262"></t>
<t tx="ekr.20061008190633.264">w was set to self.w, rather than event.widget.</t>
<t tx="ekr.20061008190633.265">Added self.editWidget.  This sets self.w and makes sure w is a text widget.</t>
<t tx="ekr.20061008190633.283">This fixes a long-standing, annoying bug.</t>
<t tx="ekr.20061008190633.294">The solution was to call setTimestamp if needed in getNewIndex.

</t>
<t tx="ekr.20061008190633.295"></t>
<t tx="ekr.20061008190633.296">- Make showing the Run Script button optional.
- The Script Button button now creates the press-script-button-button command.
- A new utility method does a much better job of massaging button and command names.
</t>
<t tx="ekr.20061008190633.297"></t>
<t tx="ekr.20061008190633.298">New in beta 2: Leo looks for myLeoSettings.leo files in the same place Leo looks for leoSettings.leo files.
</t>
<t tx="ekr.20061008190633.306"></t>
<t tx="ekr.20061008190633.307">http://sourceforge.net/forum/message.php?msg_id=3935780

This greatly speeds searches that used to open many nodes.

Added support for @bool collapse_nodes_during_finds setting.</t>
<t tx="ekr.20061008190633.311">The code that writes .leo files is now almost exactly twice as fast as the old code.</t>
<t tx="ekr.20061008190633.325"></t>
<t tx="ekr.20061008190633.347"></t>
<t tx="ekr.20061008190633.351">http://sourceforge.net/forum/message.php?msg_id=3941670

The code on cvs now supports the 'extended' character search. When keystrokes
(in the outline pane) are typed 'close' together in time Leo first tries to look
for prefix + ch, where ch is the character just typed and prefix is the previous
match.

By 'close together' I mean the time interval specified by the new setting:

@float outline_nav_extend_delay = 2.0

The unit of time is seconds.

The outline nav search revers to a single-character if the extended search
fails, so in fact the delay is not too significant. In practice everything works
well without me thinking at all about what is happening.
</t>
<t tx="ekr.20061008190633.353"></t>
<t tx="ekr.20061008190633.354"></t>
<t tx="ekr.20061008190633.356">The bindings are sorted by prefix: this is a big help in understanding bindings.
For each prefix, first print items with only a single character after the prefix.
</t>
<t tx="ekr.20061008190633.360"></t>
<t tx="ekr.20061008190633.362">


   
       </t>
<t tx="ekr.20061008190633.364">Possibly define kill-sentence and kill-paragraph in terms of these.</t>
<t tx="ekr.20061008190633.371"></t>
<t tx="ekr.20061008190633.382"></t>
<t tx="ekr.20061008190655">Leo 4.4.2 beta 2                                  October 9, 2006

Leo 4.4.2 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.2:
----------------------------
- You can now store settings in myLeoSettings.leo without fear of those settings
  being changed by cvs updates or in future versions of Leo.
- Leo's vnode and tnode classes are now completely independent of the rest of Leo.
  Some api's have been changed.  This 'big reorg' and may affect scripts and plugins.
- Leo's vnode and tnode classes can optionally be compatible with ZODB databases,
  i.e., they can optionally derive from ZODB.Persistence.Persistent.
  See Chapter 17: Using ZODB with Leo for details.
- The leoOPML plugin defines commands to read and write OPML files.
- The slideshow plugin allows Leo to run slideshows defined by @slideshow and @slide nodes.
- The leo_to_rtf and leo_to_html plugins create rtf and html files from Leo outlines.
- Much faster navigation through the outline.
- When focus is in the outline pane, you can move to headlines by typing the first letter of headlines.
- The find command now optionally closes nodes not needed to show the node containing the present match.
- Numerous changes that make Leo easier to use without using a mouse, including new commands and options.
- Many new minibuffer commands now appear in the Cmds menu.
- A sax parser can now optionally read .leo files.
- Fixed numerous bugs.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20061008190905"></t>
<t tx="ekr.20061008192040"></t>
<t tx="ekr.20061008192040.1"></t>
<t tx="ekr.20061009074305">See: http://sourceforge.net/forum/forum.php?thread_id=1587064&amp;forum_id=10226

Leo's theory of relativity

1. We can archive any position p by saving the list [p.childIndex() for p in
   p.self_and_parents_iter()]. Let us call the *reverse* of this list the
   **parents index list**. Clearly, this list provides an unambiguous way of
   reaching position p from the root node. Archived positions, like all other
   positions, become invalid when the outline changes. 
 
2. Leo's position class can be based on parents index lists. Let us call such
   positions **new positions**. Replacing legacy positions with new position
   will have important benefits: 
 
- The only structure information in vnodes will be a v.links field. Two
  interpretations of v.links are possible. When Leo's data is a DAG (the clone
  world), v.links is a lists of v's children. This is the legacy world we all
  know and love. When Leo's data is an arbitrary graph, v.links is simply the
  list of all vnodes to which v points, with *no* necessary restrictions on what
  nodes may be contained in v.links. 
 
- New positions provide a self contained way of traversing an arbitrary graphs
  **largely independently** of the data. This is Leo's theory of relativity. The
  notions of 'parent' and 'sibling' have meaning *only* in the context of a
  particular position. The v.links field appears to be the absolute minimum
  amount of structure information that vnodes must contain. v.links defines the
  children or linked-to nodes in a general graph. 
 
- Leo's data can be considered an unrooted tree: *any* node could be considered
  the root. New positions provide enough information to traverse an arbitrary
  graph starting at any node. 
 
- The fundamental p.moveToX methods should be significantly faster. All of Leo's
  iterators use p.moveToX methods. 
 
3. The changeover to new positions can be done easily. Initially, the api of the
   new position class will be identical to the api of the present position
   class. Later, the api for the new position class might be extended in an
   upward compatible manner. The api's for the vnode and tnode class will remain
   strictly unchanged. 
 
4. These changes imply no change to the separation of data into vnodes and
   tnodes. This separation is required to handle clones. Furthermore, the format
   of .leo files is a separate issue from the internal representation of Leo's
   data, as proved by the opml plugin. Thus, the transition to new positions
   will have *no* effect on file formats, and no effect of scripts. All scripts
   will continue to work *exactly* as they have before, *except* scripts, e.g.
   unit tests, that probe Leo's internals. 
 
Summary 
 
Leo's theory of relativity is this: the position class provides a 'frame of
reference' for traversing data. **Only in a particular frame of reference** do
the notions of 'parent' and 'siblings' have meaning. Leo's theory of relatively
is the ultimate expression of LeoUser's notion of a 'sea of nodes'. It provides
a solid context on which to base traversals of either outlines with clones
(DAG's) or general directed graphs. 
 
Leo's position class, far from being just a technical tool, is important
theoretically. The position class (old or new) provides the essential tool
needed to separate data from traversals of the data. The re-visioning of the
position and vnode classes brings that potential into reality. 
</t>
<t tx="ekr.20061009111417.11">- Removed .leoRecentFiles.txt from the distribution and cvs and added @bool
  write_recent_files_as_needed. The presence or absence of .leoRecentFiles.txt
  no longer controls whether Leo creates and updates .leoRecentFiles.txt.
- Added @bool insert_new_nodes_at_end.
- Added @bool select_all_text_when_editing_headlines.
  Creating a new node always selects the entire text, regardless of this option.
- Leo looks for myLeoSettings.leo files in the same place Leo looks for leoSettings.leo files.
- Added settings for all mod_scripting switches.
- Added @bool collapse_nodes_during_finds.
  This greatly speeds searches that used to open many nodes.
  See: http://sourceforge.net/forum/message.php?msg_id=3935780
- Added @bool outline_pane_has_initial_focus.
- Added @bool sparse_move_outline_left.
- Added bindings for Alt-Shift-Arrow keys to force an outline move.
- Added @bool use_sax_based_read = False.
  True:  Use a sax-based parser to read .leo files.
  This is slower than using Leo's legacy xml parser, but may solve some unicode problems.

Changed default settings::

    focus-to-body = Alt-D
    focus-to-tree = Alt-T
    toggle-extend-mode = Alt-3
</t>
<t tx="ekr.20061009111417.18">::

    extend-to-line
    extend-to-paragraph
    extend-to-sentence
    forward-end-word
    forward-end-word-extend-selection
</t>
<t tx="ekr.20061009112808">True:  Use a sax-based parser to read .leo files.
       This is slower than using Leo's legacy xml parser, but may solve some unicode problems.

False: Use Leo's legacy xml parser code.</t>
<t tx="ekr.20061020155235.1"></t>
<t tx="ekr.20061020155235.123">http://sourceforge.net/forum/message.php?msg_id=3960993
</t>
<t tx="ekr.20061020155235.124">https://sourceforge.net/forum/message.php?msg_id=3961623
</t>
<t tx="ekr.20061020155235.125">No longer needed now that the datenodes plugins gets settings from cvs.</t>
<t tx="ekr.20061020155235.126"></t>
<t tx="ekr.20061020155235.149">Did not restore selection after indent/undent commands.
</t>
<t tx="ekr.20061020155235.180">The 'hang' was due to removeRKeys, which removes the bindings create by
setRegion (set-mark-command) by *also* cleared all the other bindings!
For now I have simply disabled the set-mark-command and commented out all
calls to removeRKeys.

Note that toggle-extend-mode (Alt-3) is a good way to define regions.</t>
<t tx="ekr.20061020155235.185">onFocusIn and its associated binding were a very bad idea.  It is not needed:
k.masterClickHandler simply calls the new onClick method.

What I did:
    
- Eliminating onFocusIn and its associated binding.
  Hurray: this also fixed the Find problem.
- Fixed problem with deleting nodes when multiple editors are present.
- Fixed minor problem with cycle-all-focus.
- Removed title bar when penultimate editor is deleted.</t>
<t tx="ekr.20061020155235.2"></t>
<t tx="ekr.20061020155235.254"></t>
<t tx="ekr.20061020155235.255">Double-clicking  @url &lt;leo-file&gt; did not bring Leo file to top.
</t>
<t tx="ekr.20061020155235.263"></t>
<t tx="ekr.20061020155235.264">What I did

- @bool write_recent_files_as_needed = True

People who don't want Leo to update .leoRecentFiles.txt can set this to False.

- Remove .leoRecentFiles from cvs
- Remove .leoRecentFiles from distribution list.</t>
<t tx="ekr.20061020155235.27">@command whatever @key Alt-1 didn't work
Actually, no Alt-n keys worked for n in (1,2,3,4,5) in any context.</t>
<t tx="ekr.20061020155235.271">http://sourceforge.net/forum/message.php?msg_id=3588148

One way to make Leo more newbie friendly is to add menu items for key features
that are likely to cause confusion in the beginning.
</t>
<t tx="ekr.20061020155235.292">This is much more visible.</t>
<t tx="ekr.20061020155235.294">Added support for @bool sparse_move_outline_left

When True, Leo collapses the (former) parent of a node when moving that node left.
Takes getting used to, but I like it.

Note that the move-outline-up/down commands can have the effect of moving an outline left.</t>
<t tx="ekr.20061020155235.304">At long last Leo creates a proper help menu on the Mac.</t>
<t tx="ekr.20061020155235.307">This would greatly simplify menu entries.</t>
<t tx="ekr.20061020155235.308">This is an important step towards making all menus configurable.</t>
<t tx="ekr.20061020155235.335">The open-scripts-leo command.</t>
<t tx="ekr.20061020155235.337"></t>
<t tx="ekr.20061020155235.34">http://sourceforge.net/forum/message.php?msg_id=3956836
</t>
<t tx="ekr.20061020155235.35">http://sourceforge.net/forum/message.php?msg_id=3958333
</t>
<t tx="ekr.20061020155235.36"></t>
<t tx="ekr.20061020155235.37"></t>
<t tx="ekr.20061020155235.385"></t>
<t tx="ekr.20061020155235.393"></t>
<t tx="ekr.20061020155235.394">http://sourceforge.net/forum/message.php?msg_id=3958380
</t>
<t tx="ekr.20061020155235.395">http://sourceforge.net/forum/message.php?msg_id=3423121
</t>
<t tx="ekr.20061020155235.396">http://sourceforge.net/forum/message.php?msg_id=3959003
</t>
<t tx="ekr.20061020155235.397"></t>
<t tx="ekr.20061020155235.398">http://sourceforge.net/forum/message.php?msg_id=3962632
</t>
<t tx="ekr.20061020155235.399">- Every button created by the plugin creates a corresponding command. The
command name is the 'cleaned' version of the button name.

- Every button created by the plugin also creates a delete-x-button command,
where x is the command name as just discussed. So now you can delete script
buttons without right-clicking.

- I took the time to revise, refactor, clean up, reorganize and better document
the code. This was overdue: the previous code had grown difficult to understand
through multiple small accretions. I can actually understand the new code.</t>
<t tx="ekr.20061020155235.400"></t>
<t tx="ekr.20061020155235.402">http://sourceforge.net/forum/message.php?msg_id=3963657
</t>
<t tx="ekr.20061020155235.403"></t>
<t tx="ekr.20061020155235.404">As always, you can set max_undo_stack_size in myLeoSettings.leo.</t>
<t tx="ekr.20061020155235.405">A highly useful option.
However, creating a new node always selects the entire text, regardless of this options.
</t>
<t tx="ekr.20061020155235.41">The warning was disabled due to a programming error (not not)
Enabling this found two errors: view-lossage (missing comma) and
find-with-present-options --&gt; search-with-present-options.</t>
<t tx="ekr.20061020155235.410">- Added bindings for toggle-autocompleter (Alt-1) and toggle-calltips (Alt-2)

- Ctrl-. and ctrl-( do not seem to do anything.

** Mystery solved: there was a trace in the calltip logic!

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the process
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off. It's been added to a 'later'
section of the to-do list.</t>
<t tx="ekr.20061020155235.411">Added the node: Candidates for settings in myLeoSettings.leo. This lists the
most 'controversial' settings in leoSetting.leo, and is a quick-start to
creating myLeoSettings.leo."
</t>
<t tx="ekr.20061020155235.412">- Added shift-ctrl keys to extend the selection.
focus-to-body = Alt-D
focus-to-tree = Alt-T
toggle-extend-mode = Alt-3</t>
<t tx="ekr.20061020155235.413"></t>
<t tx="ekr.20061020155235.47">https://sourceforge.net/forum/message.php?msg_id=3957980

This was a major effort.  What I did:
    
- Defined g.isWordChar in terms of ch.isalnum()

- Replace almost all instances of string.letters and string.digits by calls to
  ch.isalnum(), ch.isalpha(), ch.isdigit(), etc.
  
- Similarly, replaced word_chars.

- The new code uses string literals only for

a) small constants like '+-' and
b) constants in a very limited context, as in the input to regexp.</t>
<t tx="ekr.20061020155235.9"></t>
<t tx="ekr.20061020155306">Leo 4.4.2 beta 3                                  October 20, 2006

Leo 4.4.2 beta 3 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

The beta release fixed dozens of bugs and smoothed many rough edges.  There
are no known major bugs in Leo.  This will be the last beta release before
LEo 4.4.2 final.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.2:
----------------------------
- You can now store settings in myLeoSettings.leo without fear of those settings
  being changed by cvs updates or in future versions of Leo.
- Leo's vnode and tnode classes are now completely independent of the rest of Leo.
  Some api's have been changed.  This 'big reorg' and may affect scripts and plugins.
- Leo's vnode and tnode classes can optionally be compatible with ZODB databases,
  i.e., they can optionally derive from ZODB.Persistence.Persistent.
  See Chapter 17: Using ZODB with Leo for details.
- The leoOPML plugin defines commands to read and write OPML files.
- The slideshow plugin allows Leo to run slideshows defined by @slideshow and @slide nodes.
- The leo_to_rtf and leo_to_html plugins create rtf and html files from Leo outlines.
- Much faster navigation through the outline.
- When focus is in the outline pane, you can move to headlines by typing the first letter of headlines.
- The find command now optionally closes nodes not needed to show the node containing the present match.
- Numerous changes that make Leo easier to use without using a mouse, including new commands and options.
- Many new minibuffer commands now appear in the Cmds menu.
- A sax parser can now optionally read .leo files.
- Fixed numerous bugs.

Links:
------
Leo:        http://webpages.charter.net/edreamleo/front.html
What's new: http://webpages.charter.net/edreamleo/new-4-4-2.html
Home:       http://sourceforge.net/projects/leo/
Download:   http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:        http://leo.tigris.org/source/browse/leo/
Quotes:     http://webpages.charter.net/edreamleo/testimonials.html
</t>
<t tx="ekr.20061021164213">Set @bool ignore_unbound_non_ascii_keys = False in LeoSettings.leo or myLeoSettings.leo.</t>
<t tx="ekr.20061021164213.1">This is a known bug in Tk/Tkinter and there is no good workaround. Some
keyboards allow you to disable the caps-lock key.</t>
<t tx="ekr.20061025065357">@language rest</t>
<t tx="ekr.20061025065357.1">#######################################
Chapter 18: Leo and Emacs
#######################################

This chapter several topics relating to the Emacs editor.

.. .. contents::
</t>
<t tx="ekr.20061025065357.2">.. Links
.. _elisp:              http://en.wikipedia.org/wiki/Emacs_Lisp
.. _Emacs:              http://www.xemacs.org/
.. _ZODB:               http://www.zope.org/Wikis/ZODB/guide/zodb.html
.. _`Installing ZODB`:  http://www.zope.org/Wikis/ZODB/guide/node3.html#SECTION000310000000000000000
.. _pymacs:             http://pymacs.progiciels-bpi.ca/index.html
.. _`Chapter 8: Customizing Leo`:   customizing.html
</t>
<t tx="ekr.20061025070825.1">The leoPymacs module is intended to be called from Emacs using pymacs.  It contains the following top-level functions:

- get_app()

  Returns the hidden app created by the leoPymacs.init function.

- dump(anyPythonObject)

  Returns str(repr(anyPythonObject)).

- get_g()

  Returns the leoGlobals module of the hidden app created by the leoPymacs.init function.

- get_script_result()

  Returns g.app.scriptResult, where g.app is the hidden app.

- init()
  Calls leo.run(pymacs=True) to create a hidden Leo application.
  Later calls to open can open hidden Leo outlines that can be accessed via runScript.

- open(fileName)

  Opens the .leo file given by fileName.
  fileName must be the full path to a .leo file.
  Returns the commander of the open Leo outline, or None if the outline could not be opened.

- run_script(c,script,p=None)

  Executes a script in the context of a commander c returned by the leoPymacs.open.
  c may be None, in which case a dummy commander is created in which to run the script.
  In the executed script, p is set to c.p if no p argument is specified.
  Returns g.app.scriptResult, where g.app is the hidden app.
</t>
<t tx="ekr.20061025081359">Leo's leoPymacs module is a simple 'server' for the pymacs_ package.
Using pymacs and leoPymacs, elisp_ scripts in Emacs_ can open .leo files and execute *Python* scripts
as if they were executed inside Leo.
In particular, such scripts can use Leo's predefined c, g and p variables.
Thus, *Python* scripts running in Emacs can:

- Open any .leo file. 
- Access any part of the outline. 
- Change any part of the outline, including external files, 
- Save .leo files.
- Execute *any* Leo script.

In short, you can now do from Emacs anything that you can do with Leo scripting inside Leo.

Here are step-by-step instructions for executing Python scripts in Emacs:

**Step 1. Install pymacs** 

   The pymacs installation instructions should be clear enough.
   A clarification is needed about two-way communication between Python and lisp scripts:
   in truth, Python scripts can call the Pymacs.lisp function *only* if the Python script
   was invoked from emacs.
   Otherwise, calling Pymacs.lisp will hang the process making the call.
   For example, executing the following script as an ordinary Leo script will hang Leo::

        from Pymacs import lisp
        print lisp("""2+2""") # Hangs

**Step 2. Load the leoPymacs module from Emacs, creating a hidden Leo application**

  From inside Emacs, you load Leo's leoPymacs module as follows::

    (pymacs-load "leoPymacs" "leo-")

  The call to pymacs-load is similar to 'import leoPymacs as leo-' in Python.
  The side effect of pymacs-load is to define the elisp function leo-x for every top-level function x in leoPymacs.py,
  namely leo-dump, leo-get-app, leo-get-g, leo-get-script-result, leo-init, leo-open and leo-run-script.
  The first call to any of these functions creates a **hidden Leo application**
  in which .leo files may be loaded, modified and saved,
  and in which Leo scripts may be executed.
  This hidden Leo application uses Leo's nullGui class as its gui,
  so Leo commands and Leo scripts that require a fully functional gui will not work as
  expected in the hidden Leo application.
  Steps 3 and 4 tell how to use this hidden Leo application.

  pymacs-load works like a Python reload, so you can redefine leoPymacs.py while Emacs is running.
  However, calling pymacs-load destroys the old hidden Leo application and creates a new one,
  so typically you would want to call pymacs-load only once per Emacs session.
  Like this::

        (setq reload nil) ; change nil to t to force a reload.

        (if (or reload (not (boundp 'leoPymacs)))
            (setq leoPymacs (pymacs-load "leoPymacs" "leo-"))
            (message "leoPymacs already loaded")
        )

**Step 3. From Emacs, open .leo files**

   Once we have loaded the leoPymacs module
   we can open a .leo file as follows::

    (setq c (leo-open fileName))

   This binds the elisp c variable to the Leo commander created by opening fileName.
   fileName should be the full path to a .leo file.
   In the next step we will use this c variable to execute *Leo* scripts in the
   context of an open Leo outline.

   Sometimes we want to execute a Leo script before opening any Leo commanders.
   For example, we might want to compute the fileName passed to leo-open.
   leo-run-script allows the c argument to be nil,
   in which case leo-run-script creates a dummy commander in which to run the script.
   For example, the following script calls g.os_path_join and g.os_path_abspath::

        (setq script "g.app.scriptResult =
            g.os_path_abspath(g.os_path_join(
                g.app.loadDir,'..','test','ut.leo'))"
        )

        (setq fileName (leo-run-script nil script))

   leo-run-script returns the value of g.app.scriptResult
   As shown above, Python scripts may set g.app.scriptResult to indicate their result.
   elisp scripts can also get g.app.scriptResult using leo-script-result.
   Note that the Python script may span multiple lines.

**Step 4. From Emacs, execute Leo (Python) scripts**

   From emacs we can execute a Python script **as if** it were executed in an
   open Leo outline.
   Suppose aLeoScript is an **elisp** string containing a Leo (Python) script.
   We can execute that script in the hidden Leo application as follows::

        (leo-run-script c aLeoScript)

   For example::

        (setq c (leo-open fileName)
        (csetq script "print 'c',c,'h',c.p.h")
        (leo-run-script c script)

Putting this all together, we get::

        ; Step 1: load leoPymacs if it has not already been loaded.
        (setq reload nil)
        (if (or reload (not (boundp 'leoPymacs)))
            (setq leoPymacs (pymacs-load "leoPymacs" "leo-"))
            (message "leoPymacs already loaded")
        )

        ; Step 2: compute the path to leo/test/ut.leo using a Leo script.
        (setq script
            "g.app.scriptResult = g.os_path_abspath(
                g.os_path_join(g.app.loadDir,'..','test','ut.leo'))"
        )
        (setq fileName (leo-run-script nil script))

        ; Step 3: execute a script in ut.leo.
        (setq c (leo-open fileName))
        (setq script "print 'c',c.shortFileName() ,'current:',c.p.h")
        (leo-run-script c script)</t>
<t tx="ekr.20061025142434">Leo's mini-buffer is a text area at the bottom of the body pane.
You use Leo's minibuffer like the Emacs mini-buffer to invoke commands by their so-called *long name*.
The following commands affect the minibuffer:

- **full-command**: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a
  full command name, then hit &lt;Return&gt; to execute the command. Tab completion
  works, but not yet for file names.

- **quick-command-mode**: (default shortcut: Alt-x) Like Emacs Control-C. This mode is
  defined in leoSettings.leo. It is useful for commonly-used commands.

- **universal-argument**: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat
  count for later command. Ctrl-u 999 a adds 999 a's.

- **keyboard-quit**: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts
  the focus in the body pane.

For example, to print a list of all commands type Alt-X print-commands &lt;Return&gt;.</t>
<t tx="ekr.20061026095728">Leo 4.4.2.1 final                                October 29, 2006

Leo 4.4.2.1 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.2.1 final fixes a recent bug that caused Leo not to create the
.leoRecentFiles.txt file properly in some situations. There are no known
significant bugs in this version of Leo.

Leo 4.4.2 final fixes a few bugs and adds support for pymacs. 

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.2:
----------------------------
- You can now store settings in myLeoSettings.leo without fear of those settings
  being changed by cvs updates or in future versions of Leo.
- Leo's vnode and tnode classes are now completely independent of the rest of Leo.
  Some api's have been changed.  This 'big reorg' and may affect scripts and plugins.
- Leo's vnode and tnode classes can optionally be compatible with ZODB databases,
  i.e., they can optionally derive from ZODB.Persistence.Persistent.
  See Chapter 17: Using ZODB with Leo for details.
- The leoOPML plugin defines commands to read and write OPML files.
- The slideshow plugin allows Leo to run slideshows defined by @slideshow and @slide nodes.
- The leo_to_rtf and leo_to_html plugins create rtf and html files from Leo outlines.
- Much faster navigation through the outline.
- When focus is in the outline pane, you can move to headlines by typing the first letter of headlines.
- The find command now optionally closes nodes not needed to show the node containing the present match.
- Numerous changes that make Leo easier to use without using a mouse, including new commands and options.
- Many new minibuffer commands now appear in the Cmds menu.
- A sax parser can now optionally read .leo files.
- Fixed numerous bugs.

Links:
------
Leo:        http://webpages.charter.net/edreamleo/front.html
What's new: http://webpages.charter.net/edreamleo/new-4-4-2.html
Home:       http://sourceforge.net/projects/leo/
Download:   http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:        http://leo.tigris.org/source/browse/leo/
Quotes:     http://webpages.charter.net/edreamleo/testimonials.html
</t>
<t tx="ekr.20061026095922.1"></t>
<t tx="ekr.20061026095922.15">http://sourceforge.net/forum/message.php?msg_id=3971242
</t>
<t tx="ekr.20061026095922.17"></t>
<t tx="ekr.20061026095922.19"></t>
<t tx="ekr.20061026095922.2"></t>
<t tx="ekr.20061026095922.25">The new colorizer was innocent: the problem is that at.directiveKind4 uses leoColor.leoKeywords,
so multipath must add entries to leoColor.leoColors.</t>
<t tx="ekr.20061026095922.3"></t>
<t tx="ekr.20061026095922.32">It required a space after the '@'
</t>
<t tx="ekr.20061026095922.33">http://sourceforge.net/forum/message.php?msg_id=3975898
</t>
<t tx="ekr.20061026095922.35"></t>
<t tx="ekr.20061026095922.36">For full details, see Chapter 18 of Leo's Users Guide: Emacs and Leo.</t>
<t tx="ekr.20061026095922.51">http://sourceforge.net/forum/message.php?msg_id=3980193

</t>
<t tx="ekr.20061129170155.2">CC2 allocated objects one-at-a-time (simple allocation), in blocks of
fixed-sized objects (block allocation) or in blocks of variable-sized objects
(lifetime-based allocation). Simple-allocation was used for short-lived objects
and will not be discussed further. Block allocation was used in several ways, the
most interesting of which was to allocate "cons cells" used to represent lists.
These cons cells could be reused by placing them on a global avail list. Thus,
the blocks holding cons cells could (and did) have permanent lifetime: they were
never deallocated.

The most interesting aspect of CC2's storage allocation scheme was what I
eventually came to call **lifetime-based** storage allocation. This was, for me,
an new discovery, though clearly I was not the first to discover it. The Aha is
that a lifetime is defined by the time (or equivalently by the place in program
code) at which objects are **deallocated**. A lifetime may hold many different
kinds of objects that were allocated at many different times. The essence of
lifetime-based allocation is that **the proper time to specify when an object
will be deallocated is when the object is created**.

Lifetime-based allocation is a superb invention:

- It becomes an effective design tool. Thinking of objects in terms of their
  lifetimes often shows the essence of a design problem.

- It can be used for any kind of object, regardless of its size or type.

- It reduces the number of calls to calloc and free by one or two orders of
  magnitude over naive schemes. Furthermore, it typically requests
  standard-sized blocks (say 8K or more) from calloc, further easing the burden
  on calloc and free.

- CC2 could allocate objects with a particular lifetime using small, extremely fast, macros.
  The macros expanded to C code something like this::

    if lifetime -&gt; avail &gt;= sizeof(theObjectKind) {
        // Allocate the storage.
        theObject = lifetime -&gt; ptr 
        lifetime -&gt; ptr += sizeof(theObjectKind)
    }
    else {
        &lt;&lt; allocate theObject in another block &gt;&gt;
    }

Importantly, the speed of the else clause makes absolutely no difference because
it is so seldom executed. Thus, it uses a function call. Clearly then, this code
is optimal: it could not be improved even if coded in assembly language.

</t>
<t tx="ekr.20061129170454">This white paper describes the storage allocation used in a commercial
optimizing C compiler written for Tuple, Inc. ca. 1993. The last section
discusses tantalizing possibilities for the pypy project. These possibilities
are why I wrote this paper.

Storage allocation is crucial to any compiler because of the number, size and
complexity of data which must be allocated. You might event say that a compiler
consists of storage allocation and everything else. I paid a lot of attention to
storage allocation in CC2, and that work paid off. The resulting compiler was a
few percent faster than the CodeWarrior C compiler, perhaps the fastest C
compiler in existence at that time. The original notes were written around 1993,
so I would do some things differently today. However, the design discussed below
still seems relevant today. Indeed, attention to low-level details can make a
huge difference.
</t>
<t tx="ekr.20061129175952">What makes lifetime-based allocation so powerful is that so few lifetimes are
typically required. Indeed, CC2 had only the following lifetimes:

- Permanent: These objects were never deallocated. Examples were list pointers
  held in cons cells and other kinds of application-wide objects.

- Tokenizer: Tokenizing in C is complex due to C's various preprocessing
  directives and macro expansion. Objects with tokenizer lifetime are
  deallocated before the parser starts.

- Function: Objects with function lifetime are deallocated after the compiler
  generates code for the function.

- File: Objects with file lifetime are deallocated after the compiler completes
  a source file.

That's all. Similarly, if Leo were recast as a C program only the following
lifetimes would be needed:

- Permanent: application-wide objects.

- Window/outline: All data associated with a single Leo outline. This is a
  'semi-permanent' lifetime. Leo has unlimited undo, so it is essentially
  impossible to delete any data object (an object that could be written to an
  output file) until the entire outline closes.

- Dialog: data associated with a temporary dialog.

- Function/method: data not used outside a single function or method.

The remarkable thing about dynamic languages like Python is how often objects
can, in fact, be assigned static lifetimes.</t>
<t tx="ekr.20061129202238">Lifetime allocation isn't used in Java, Python, etc. because these languages
have no way of knowing (in general) what the lifetime of any object will be.
Furthermore, translating Python to C would be straightforward were it not for
storage allocation issues. For example, most of Leo's code could easily be
translated into C, **provided** that the lifetime of all objects were known.
Again, just for example, the prospect of translating the Python version of Leo
to a fully optimized C version is tantalizing.

This is where pypy comes in: its extensive flow analysis may be sufficient to
discover lifetimes for a significant percentage of objects. Perhaps user hints
may be effective. For example, pypy offers the chance to make something like
`region inference`_ truly useful. Note that the pypy project might benefit from
deducing lifetimes even if not all objects could be assigned a static
lifetime. Another reason why lifetimes are not a standard technique is that they
are a potentially dangerous optimization. Errors in specifying lifetimes will
result in dangling pointer references. But this danger might disappear if pypy
could deduce lifetimes automatically.
</t>
<t tx="ekr.20070115172724">The following three section discuss three ways of debugging scripts with winpdb_.
The first two sections tell how to debug general scripts;
the last section tells how to debug Leo-specific scripts.

winpdb_ and its documentation have been improved recently.
For more details, see the `embedded winpdb`_ docs.
The discussion of embedded debugging may have been written specifically with Leo in mind.
</t>
<t tx="ekr.20070115172724.1">This way of debugging can only be used for general scripts, not leo-specific scripts.  
The debug command writes the script to scriptFile.py and invokes winpdb.
winpdb opens and is already 'attached' to the script to be debugged.
You can single-step as you like.
Leo continues to run, but killing the debugger will also kill Leo.
</t>
<t tx="ekr.20070115172724.2">test.leo contains an @button windpdb node.
Select the test to be debugged, then press the winpdb button or do &lt;Alt&gt;x winpdb&lt;return&gt;.
This way is essentially the same as using the debug command, though the code is slightly different.
</t>
<t tx="ekr.20070115172724.3">This way of debugging scripts allows winpdb to debug scripts that use c, g and p.
A bit more work is needed because winpdb does not start automatically.
Here are step-by step instructions:

1. Insert the following two lines of code at the start of the script to be debugged::

    import rpdb2
    rpdb2.start_embedded_debugger('go',fAllowUnencrypted=True)

2. Execute Leo's execute-script command (*not* the debug command).
   Leo will appear to hang: start_embedded_debugger is waiting for *another* copy of winpdb to 'attach' to the script's process.
   The default timeout is 5 minutes, after which an exception gets thrown.

3. Start winpdb explicitly by executing something like the following in a console::

    python /Python26/Scripts/_winpdb.py -t

   The -t option tells winpdb that no encoding of password is necessary.
   The password is specified in the call to rpdb2.start_embedded_debugger in your script.
   In our example, the password is 'go'.

4. Use winpdb's File:Attach command to attach winpdb to Leo.
   Specify the password as 'go' and you will see the scriptFile.py containing your entire script.
   You can now execute or single-step through the script. 
   To repeat, c, g and p are defined, so you can debug any script this way.
</t>
<t tx="ekr.20070116062405">Inserting g.trace statements in my Python code is usually my first debugging
choice. The g.trace statement prints the name of the function in which the call
to g.trace occurs, followed by the value of its arguments. The output of the
g.trace goes to the console, so you must `run Leo in a console window`_ to use
g.trace.

Inserting and deleting g.trace statements is fast, provided that your `work
flow`_ makes it easy to restart the program under test. As a result, using
g.trace statements is similar to setting tracepoints in a debugger, with the
advantage that (disabled) tracepoints remain in the source code for future use.
You will find many examples of using g.trace throughout Leo's source code.

My second choice is using g.pdb to set breakpoints for the pdb_ debugger. Pdb
uses the console for all interaction, so you must `run Leo in a console window`_.
See `the FAQ`_ for a discussion of both g.trace and g.pdb.
</t>
<t tx="ekr.20070120075236">Leo's execute script command predefines the c, g and p constants
when it runs any script inside Leo:

- c is the commander of the outline containing the script.
- g is Leo's leo.core.leoGlobals module.
- p is the presently selected position, the same as c.p.

Leo scripts can use c and g to gain access to all of Leo's source code.</t>
<t tx="ekr.20070122070619">Leo 4.4.3 alpha 1                                  January 26, 2006

Leo 4.4.3 alpha 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

Important: the wxGui plugin is still alpha-quality code at present.

The highlights of Leo 4.4.3:
----------------------------
- A functional wxWidgets plugin.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Many minor improvements, new settings and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20070122070634.1"></t>
<t tx="ekr.20070122070634.13">http://sourceforge.net/forum/message.php?msg_id=3924236

Added unit tests for yank and all kill commands.
</t>
<t tx="ekr.20070122070634.2">Example:

print "\\" + " this is a test"

The escape mechanism must treat an even number of trailing escapes as not an escape.</t>
<t tx="ekr.20070122070634.209">The spell tab is only shown if Aspell was properly imported.
</t>
<t tx="ekr.20070122070634.220">http://sourceforge.net/forum/message.php?msg_id=3987635
</t>
<t tx="ekr.20070122070634.223">New settings

The following two new settings now control whether the execute-script and debug commands write the script to an external file.

- @bool write_script_file = True

True: The execute script command writes the script to be executed to a file, then executes the script using Python's execFile function. The script_file_path setting specifies the path to this file.
    
False (legacy): The execute script command uses Python's exec command to execute the script. 

- @string script_file_path = ../test/scriptFile.py

The path to the file to be written by the execute-script command.

Notes:
    
- This setting has effect only if the write_script_file setting is True.
- Use / to as the path delimiter, regardless of platform.
- The default path is ../test/scriptFile.py if no path is given.
- The path starts at g.app.loadDir, so for example ../test/scriptFile.py is equivalent to leo/test/scriptFile.py
- The filename should end in .py.

From here on, let us assume the settings are as shown above.  There are at least three ways of debugging scripts, depending on your preferences and whether the script contains leo-specific code (g, c or p) or not.

First way:  The debug command

The debug command now works almost exactly like Kent's original @button node. This way of debugging can only be used for general scripts, not leo-specific scripts.  

The debug command writes the script to scriptFile.py and invokes the debugger as specified by the existing @string debugger_kind option.  winpdb opens and is already 'attached' to the script to be debugged.  You can single-step as you like.  Leo continues to run, but killing the debugger will also kill Leo.  When started this way, winpdb is really 'attached' to *all* of Leo, which means you can single step past the end of the script into Leo's executeScript code and from there into all of Leo(!)

As I write this I realize that the code uses arguments specific to winpdb.  That may have to be generalized, though I am not sure why anyone would want to use another debugger...

Second way: @button winpdb

This is almost exactly equivalent to the debug command, except that the script file must be *different* from the script file specified by the  script_file_path setting (The @button code *itself* uses the execute-script command, so we have to pass the script code, not the @button code to the debugger).

Third way: The execute-script command with explicit debugger breaks

The third way of debugging scripts allows winpdb to debug scripts that use c, g and p.  I'm actually not sure of exactly how and why it works, but it certainly does work.

In contrast to the previous two ways, a little more work is needed because winpdb does not start automatically.  But I am getting ahead of myself.

To use this way, insert the following two lines of code at the start of the script to be debugged::

import rpdb2
rpdb2.start_embedded_debugger('go',fAllowUnencrypted=True)

Now just execute the execute-script command (*not* the debug command)  Leo will appear to hang.  Indeed, the  start_embedded_debugger command is waiting for *another* copy of winpdb to 'attach' to the script's process.  This process is all of Leo!  The default timeout is 5 minutes: I'm not sure what happens when the timeout happens: probably an exception gets thrown.

So you must start winpdb explicitly.  On XP just do something like

python c:\python25\Scripts\_winpdb.py -t

The -t option tells winpdb that no encoding of password is necessary.  The password is specified in the call to rpdb2.start_embedded_debugger in your script.  In this example, the password is 'go'.  Use the File:Attach command in winpdb to attach winpdb to Leo.  Specify the password as 'go' and you will see the scriptFile.py containing your entire script.  You can execute or single-step through the script. 

To repeat, the big difference is that c, g and p are defined, so you can debug any script this way.  As before, killing winpdb also kills Leo.

P.S.  winpdb and its documentation has been improved recently.  See

http://www.digitalpeers.com/pythondebugger/  and especially

http://www.digitalpeers.com/pythondebugger/embedded.htm

The discussion of embedded debugging may have been written specifically with Leo in mind.  It certainly could have been.
</t>
<t tx="ekr.20070122070634.298"></t>
<t tx="ekr.20070122070634.299">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3991223

I assigned both Control and Shift modifiers to do scrolling: this is so my
finger can hit a key in the lower left corner of the keyboard, and I don't have
to worry too much about my aim (I have LARGE fingers). Also, I stop the
scrolling on the JUST button release -- less worry about my finger slipping off
the key.</t>
<t tx="ekr.20070122070634.300"></t>
<t tx="ekr.20070122070634.301"></t>
<t tx="ekr.20070122070634.302">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3916155

When a node is among several other nodes at the same level of hierarchy, which
are all children of a node, and the "MOVE LEFT" command is executed, the node
does move left in the outline hierarchy, but it also move down to just before
the next node at the higher hierarchy level - the level to which it is moving
left.

EKR: I love this new option: how did we ever live without it?

@color</t>
<t tx="ekr.20070122070634.303">@nocolor

This option tells how to treat an uppercase letter typed when the outline pane
is active but no headline is being edited. In such situations Leo searches for an
node whose headline starts with the present prefix, ignoring case The prefix
starts with the first letter typed and other letters are added if they are typed
within a 'short' period of time, as specified by the outline_nav_extend_delay

True: Look in invisible nodes.
False: Look only in visible nodes.

I set this option to False because it is too easy form me to type Shift-whatever
when I meant Ctrl-whatever.

@color</t>
<t tx="ekr.20070122070634.304">http://sourceforge.net/forum/message.php?msg_id=3985382

</t>
<t tx="ekr.20070122070634.305">Leo's core is now largely free of gui-dependent code, and should be completely
free of such code by the time Leo 4.4.3 final is released.</t>
<t tx="ekr.20070122070634.4"></t>
<t tx="ekr.20070122070634.40">http://sourceforge.net/forum/message.php?msg_id=3991369

The bindings to f.f.OnControlKeyDown/Up were mistakenly deleted in createOuterFrames.
</t>
<t tx="ekr.20070122070634.51"></t>
<t tx="ekr.20070122070634.54">http://sourceforge.net/forum/message.php?msg_id=4112347
</t>
<t tx="ekr.20070122070634.55"># Simplified version by EKR: stringCompare not used.

def CheckVersion (s1,s2,condition="&gt;=",stringCompare=None,delimiter='.',trace=False):
    
    vals1 = [g.CheckVersionToInt(s) for s in s1.split(delimiter)] ; n1 = len(vals1)
    vals2 = [g.CheckVersionToInt(s) for s in s2.split(delimiter)] ; n2 = len(vals2)
    n = max(n1,n2)
    if n1 &lt; n: vals1.extend([0 for i in xrange(n - n1)])
    if n2 &lt; n: vals2.extend([0 for i in xrange(n - n2)])
    for cond,val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('&lt;',  vals1 &lt;  vals2), ('&lt;=', vals1 &lt;= vals2),
        ('&gt;',  vals1 &gt;  vals2), ('&gt;=', vals1 &gt;= vals2),
    ):
        if condition == cond:
            result = val ; break
    else:
        raise EnvironmentError,"condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='."
    
    if trace:
        # print '%10s' % (repr(vals1)),'%2s' % (condition),'%10s' % (repr(vals2)),result
        print '%7s' % (s1),'%2s' % (condition),'%7s' % (s2),result
    return result</t>
<t tx="ekr.20070122070634.56">def CheckVersionToInt (s):
    
    try:
        return int(s)
    except ValueError:
        aList = []
        for ch in s:
            if ch.isdigit(): aList.append(ch)
            else: break
        if aList:
            s = string.join(aList)
            return int(s)
        else:
            return 0</t>
<t tx="ekr.20070122070634.57">def test_CheckVersionToInt (*args):
    
    assert g.CheckVersionToInt('12') == 12,'fail 1'
    assert g.CheckVersionToInt('2a5') == 2, 'fail 2'
    assert g.CheckVersionToInt('b2') == 0, 'fail 3'</t>
<t tx="ekr.20070122070634.58"></t>
<t tx="ekr.20070122070634.59"></t>
<t tx="ekr.20070122070634.66"></t>
<t tx="ekr.20070122070634.69"></t>
<t tx="ekr.20070122070634.81">This is much less confusing.</t>
<t tx="ekr.20070122070634.82"></t>
<t tx="ekr.20070122070634.83">http://sourceforge.net/forum/message.php?msg_id=4014079
</t>
<t tx="ekr.20070122070634.89">http://sourceforge.net/forum/message.php?msg_id=4005750

I like the option @string relative_path_base_directory = .

which puts @file nodes in the same directory as the current Leo file.

I would like it if 
open('file.txt','w').close()

put file.txt in the same directory as the current Leo file.</t>
<t tx="ekr.20070122070634.91"></t>
<t tx="ekr.20070122072110"></t>
<t tx="ekr.20070122093626">Positions become invalid whenever the outline changes. Plugins and scripts that
can make sure the position p is still valid by calling c.positionExists(p).

The following code will find a position p2 having the same vnode as p::

    if not c.positionExists(p):
        for p2 in c.all_positions():
            if p2.v == p.v: # found
                c.selectPosition(p2)
        else:
            print('position no longer exists')
</t>
<t tx="ekr.20070122104240">http://sourceforge.net/forum/message.php?msg_id=4113315
</t>
<t tx="ekr.20070316182323"></t>
<t tx="ekr.20070316182323.1">Leo 4.4.3 alpha 2                                  March 17, 2006

Leo 4.4.3 alpha 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version of Leo should be safe enough for production use. It is an alpha
distribution because not all plugins have been tested on the reorganized code
base.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.3:
----------------------------
- A leoBridge module that allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Added support for @enabled-plugins nodes in settings files.
- The__wx_gui plugin is now functional.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Many minor improvements, new settings and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20070316182341.1"></t>
<t tx="ekr.20070316182341.10">http://sourceforge.net/forum/message.php?msg_id=4134384</t>
<t tx="ekr.20070316182341.112">It's about Nav_buttons v1.5 (cvs version from last Saturday) 

Pressing the green back button causes 

Error: 1 
AttributeError Exception in Tk callback 
Function: &lt;bound method Commands.goPrevVisitedNode of Commander 39717104: u'F:\\D\\PIM\\PIM_main.leo'&gt; (type: &lt;type 'instancemethod'&gt;) 
Args: () 
Traceback (innermost last): 
File "F:\C\Programs\Leo_cvs\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__ 
return apply(self.func, args) 
File "F:\C\Programs\Leo_cvs\src\leoCommands.py", line 4435, in goPrevVisitedNode 
c.treeCommandHelper(v) 
AttributeError: Commands instance has no attribute 'treeCommandHelper' 
</t>
<t tx="ekr.20070316182341.113">http://sourceforge.net/forum/message.php?msg_id=4201463
</t>
<t tx="ekr.20070316182341.137">http://sourceforge.net/forum/message.php?msg_id=4205072
</t>
<t tx="ekr.20070316182341.138">Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2474, in doHook
    return f(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 92, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 49, in callTagHandler
    result = handler(tag,keywords)

  File "C:\prog\tigris-cvs\leo\plugins\rClick.py", line 156, in rClicker
    n0,p0=ind0.split('.',2)

AttributeError: 'int' object has no attribute 'split'
</t>
<t tx="ekr.20070316182341.139">Leo did not write to the log pane that settings, either present
in myLeoSettings.leo or the current file, were read.
</t>
<t tx="ekr.20070316182341.155"></t>
<t tx="ekr.20070316182341.2"></t>
<t tx="ekr.20070316182341.39">Down arrow wasn't handled properly.</t>
<t tx="ekr.20070316182341.41"></t>
<t tx="ekr.20070316182341.42">http://sourceforge.net/forum/message.php?msg_id=3994218
</t>
<t tx="ekr.20070316182341.43"></t>
<t tx="ekr.20070316182341.437"></t>
<t tx="ekr.20070316182341.438">http://sourceforge.net/forum/message.php?msg_id=4162357
</t>
<t tx="ekr.20070316182341.440">The leoBridge module allows complete access to all aspects of Leo from programs
running independently of Leo. Let us call such a program a **host** program.
Using the leoBridge module, foreign programs can get access to:
    
- all of Leo's source code,
- the contents of any .leo file,
- the commander of any .leo file.

Host programs use the leoBridge module as follows::

    import leoBridge
    controller = leoBridge.controller(gui='nullGui')
    g = controller.globals()
    c = controller.openLeoFile(path)
    
Let us look at these statements in detail.  The statements::
    
    import leoBridge
    controller = leoBridge.controller(gui='nullGui')
    
import the leoBridge module and create a **bridge controller**. In effect, these
statements embed an 'invisible' copy Leo into the host program. This embedded
copy of Leo uses a 'null' gui, which simulates all aspects of Leo's normal gui
code without creating any screen objects.

The statement::

    g = controller.globals()
    
provides access to Leo's leoGlobals module, and properly inits globals such as g.app, g.app.gui, etc.  Host programs **should not** import leoGlobals directly, because doing so would not init the g.app object properly.

The statement::

    c = controller.openLeoFile(path)
    
invisibly opens the .leo file given by the pathargument. This call returns a
completely standard Leo commander, properly inited. This is the big payoff from
the leoBridge module: the host program gets instant access to c.config.getBool,
etc. Do you see how sweet this is?

The following script runs leo/test/leoBridgeTest.py outside of Leo.
leoBridgeTest.py uses the leoBridge module to run all unit tests in leo/test/unitTest.leo.
Try it::
    
    import os,sys

    path = g.os_path_abspath(
        g.os_path_join(
            g.app.loadDir,'..','test','leoBridgeTest.py'))
    
    os.system('%s %s' % (sys.executable,path))
</t>
<t tx="ekr.20070316182341.54"></t>
<t tx="ekr.20070316182341.56"># The buggy code only happens when there is no binding for backward-delete-char.
# http://sourceforge.net/forum/forum.php?thread_id=1681392&amp;forum_id=10227</t>
<t tx="ekr.20070316182341.6">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4132529

I'm generating Leo files with ElementTree and ran into a minor issue.

ElementTree generates an empty tag with a space before the closing slash:
    
&lt;globals /&gt;

in Leo's code for dummy elements to allow copied nodes to be valid Leo files,
the empty tags are generated without the space

leoFileCommands.py 2917
        self.put('&lt;globals/&gt;\n')
        self.put('&lt;preferences/&gt;\n')
        self.put('&lt;find_panel_settings/&gt;\n')
        
it then checks for these tags in getDummyElements() leoFileCommands.py 1298

Since ElementTree has the space before the slash, 
it's XML is considered invalid by Leo according to
this test.

I would like it if the space could be added in Leo's
self.put(...) and the check in getDummyElements()

The XML specs show the space as optional.

@color</t>
<t tx="ekr.20070316182341.66"></t>
<t tx="ekr.20070316182341.718">http://sourceforge.net/forum/message.php?msg_id=4169720</t>
<t tx="ekr.20070316182341.723">Any .leo file may now contain an @enabled-plugins node as a child of an
@settings node.

Notes:

A) Leo attempts to load all plugins every time an @enabled-plugins node is seen.
   If the plugin has already been loaded, Leo silently ignores the
   request to re-enable the plugin.
   Leo never attempts to disable a plugin while processing enabled plugin
   strings. Thus, plugins enabled in an @enabled-plugins node in leoSettings.leo
   *will* be enabled regardless of the contents of any other @enabled-plugins node.

B) The default plugins will be enabled in an @enabled-plugins
   node in leoSettings.leo.
   
C) g.app.gui.getEnabledPlugins contains the last value last processed @enabled-plugins node.
</t>
<t tx="ekr.20070317033759">@language rest</t>
<t tx="ekr.20070317033759.1">############################################################
Chapter 19: Embedding Leo with the leoBridge module
############################################################

The leoBridge module allows complete access to all aspects of Leo from programs
running independently of Leo. Let us call such a program a **host** program.
Using the leoBridge module, host programs can get access to:

- all of Leo's source code,
- the contents of any .leo file,
- the commander of any .leo file.

.. .. contents::
</t>
<t tx="ekr.20070317033759.2">.. Links
</t>
<t tx="ekr.20070317033759.3">Host programs use the leoBridge module as follows::

    import leo.core.leoBridge as leoBridge
    controller = leoBridge.controller(gui='nullGui')
    g = controller.globals()
    c = controller.openLeoFile(path)

Let us look at these statements in detail.  The statements::

    import leo.core.leoBridge as leoBridge
    controller = leoBridge.controller(gui='nullGui')

import the leoBridge module and create a **bridge controller**. In effect, these
statements embed an invisible copy Leo into the host program. This embedded
copy of Leo uses a null gui, which simulates all aspects of Leo's normal gui
code without creating any screen objects.

The statement::

    g = controller.globals()

provides access to Leo's leoGlobals module, and properly inits globals such as
g.app, g.app.gui, etc. *Host programs should not import leoGlobals directly*,
because doing so would not init the g.app object properly.

The statement::

    c = controller.openLeoFile(path)

invisibly opens the .leo file given by the path argument. This call returns a
completely standard Leo commander, properly inited. This is the big payoff from
the leoBridge module: the host program gets instant access to c.config.getBool,
etc. Do you see how sweet this is?

For example, the following script runs leo/test/leoBridgeTest.py outside of Leo.
leoBridgeTest.py uses the leoBridge module to run all unit tests in leo/test/unitTest.leo::

    import os,sys

    path = g.os_path_abspath(
        g.os_path_join(
            g.app.loadDir,'..','test','leoBridgeTest.py'))

    os.system('%s %s' % (sys.executable,path))

The file leo/test/test.leo contains the source code for leoBridgeTest.py.
Here it is, stripped of its sentinel lines::

    '''A program to run unit tests with the leoBridge module.'''

    import leo.core.leoBridge as leoBridge
    import leo.core.leoTest as leoTest

    def main ():
        tag = 'leoTestBridge'

        # Setting verbose=True prints messages that would be sent to the log pane.
        bridge = leoBridge.controller(gui='nullGui',verbose=False)
        if bridge.isOpen():
            g = bridge.globals()
            path = g.os_path_abspath(g.os_path_join(
                g.app.loadDir,'..','test','unitTest.leo'))
            c = bridge.openLeoFile(path)
            g.es('%s %s' % (tag,c.shortFileName()))
            runUnitTests(c,g)

        print tag,'done'

    def runUnitTests (c,g):
        nodeName = 'All unit tests' # The tests to run.
        try:
            u = leoTest.testUtils(c)
            p = u.findNodeAnywhere(nodeName)
            if p:
                g.es('running unit tests in %s...' % nodeName)
                c.selectPosition(p)
                c.debugCommands.runUnitTests()
                g.es('unit tests complete')
            else:
                g.es('node not found:' % nodeName)
        except Exception:
            g.es('unexpected exception')
            g.es_exception()
            raise

    if __name__ == '__main__':
        main()
</t>
<t tx="ekr.20070317043727">Organizer nodes have headlines that do no start with @.
Organizer nodes may be inserted freely without changing the meaning of an @setting tree.</t>
<t tx="ekr.20070317043727.2">Simple settings nodes have headlines of the form::

    @&lt;type&gt; name = val

set the value of name to val, with the indicated type.

&lt;type&gt; may be one of the following:

=============== =========================================================================================
&lt;type&gt;          Valid values
--------------- -----------------------------------------------------------------------------------------
\@bool           True, False, 0, 1
\@color          A Tk color name or value, such as 'red' or 'xf2fddff' (without the quotes)
\@directory      A path to a directory
\@float          A floating point number of the form nn.ff.
\@int            An integer
\@ints[list]     An integer (must be one of the ints in the list).
                 Example: @ints meaningOfLife[0,42,666]=42
\@keys[name]     Gives a name to a set of bindings for the Check Bindings script in leoSettings.leo.
\@path           A path to a directory or file
\@ratio          A floating point number between 0.0 and 1.0, inclusive.
\@string         A string
\@strings[list]  A string (must be one of the strings in the list).
                 Example: @strings tk_relief['flat','groove','raised']='groove'
=============== =========================================================================================

**Note**: For a list of Tk color specifiers see:

- http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm
- http://www.tcl.tk/man/tcl8.4/TkLib/GetColor.htm

**Important**: you can use the show-colors minibuffer command to guide you in making these settings.</t>
<t tx="ekr.20070317043727.3">Complex settings nodes have headlines of the form::

    @&lt;type&gt; description

The type may be one of the following:

=================== =====================================================================
&lt;type&gt;              Valid values 
------------------- ---------------------------------------------------------------------
\@buttons           Child @button nodes create global buttons
\@commands          Child @command nodes create global buttons
\@data              Body text contains a list of strings, one per line.
\@enabled-plugins   Body text contains a list of enabled plugins
\@font              Body text contains a font description
\@menus             Child @menu and @item nodes create menus and menu items.
\@menuat            Child @menu and @item nodes modify menu tree create by \@menus.
\@mode [name]       Body text contains a list of shortcut specifiers.
\@recentfiles       Body text contains a list of file paths.
\@shortcuts         Body text contains a list of shortcut specifies.
=================== =====================================================================

Complex nodes specify settings in their body text.
See the following sections for details.</t>
<t tx="ekr.20070317044545">The __wx_gui.py plugin is now minimally functional. All significant unit tests
pass with this plugin in effect. However, problems remain. See the bug list in
the plugin for details.
</t>
<t tx="ekr.20070325123558"></t>
<t tx="ekr.20070513111132">Leo 4.4.3 beta 1                                May 18, 2006

Leo 4.4.3 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.3:
----------------------------
- Added support for chapters in Leo's core.
  Chapters are disabled by default.  To enable, set @bool use_chapters = True.
- Added support for zipped .leo files.
- Added a leoBridge module that allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Added support for @enabled-plugins nodes in settings files.
- Added support for @open-with nodes in settings files.
- The__wx_gui plugin is now functional.
- Many minor improvements, new settings, commands and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20070513111526.1"></t>
<t tx="ekr.20070513111526.10"></t>
<t tx="ekr.20070513111526.105"></t>
<t tx="ekr.20070513111526.14">http://sourceforge.net/forum/message.php?msg_id=3737745

http://sourceforge.net/forum/message.php?msg_id=3785897

Would it be possible to have the table of "Open With" editors to be part of
the config system? I find myself patching the list every time I D/L a new Leo
version to add the editor I use. This would also help isolate the user from
the "guts" of Leo, thereby being less intimidating.
</t>
<t tx="ekr.20070513111526.198">http://sourceforge.net/forum/message.php?msg_id=4215654

There was a bug with ordinary hoisting: in the "Outline" menu the "Delete Node"
menu item was not disabled when the local root is selected.
</t>
<t tx="ekr.20070513111526.2">It is True by default. In effect, this setting was False in previous versions
of Leo, which might be considered a bug.</t>
<t tx="ekr.20070513111526.200"></t>
<t tx="ekr.20070513111526.39"></t>
<t tx="ekr.20070513111526.42">Leo now supports zipped .leo files:

- Leo now has save-file-as-zipped and save-file-as-unzipped commands, and
corresponding Save File As Zipped and Save File as Unzipped items in the File
menu. These are exactly the same as Leo's Save As commands except that they
temporarily force Leo to write the file in either zipped or unzipped format.

- Leo remembers whether a file was originally zipped. The read logic handles
either zipped or unzipped .leo files automatically. The write logic will zip the
file if it was originally zipped or if the save-file-as-zipped command is being
executed.

- Leo writes files with .leo extension, regardless of whether the file is zipped
or not. Zipped .leo files contain a single archive, whose name is the same as
the .leo file itself.

Notes:

- The new save commands suffice to compress and expand .leo files on a
file-by-file basis. In particular, there is no need for any user settings.

- Outside of Leo you can change the extension to .leo.zip and use stuffit or
other program to expand the .leo file contained within. I've only tested this on
XP, but it should work everywhere...

- At present the code uses Python's zipfile module to read and write zipped files.
In turn, the zipfile module uses the zlib module to do the compression.
Conceivably somebody might want Leo to use some other compression technique, say
Python's tarfile module. However, I think the present way should suffice for
most people.</t>
<t tx="ekr.20070513111526.7"></t>
<t tx="ekr.20070513111526.77"></t>
<t tx="ekr.20070513111526.78"># Found via unit test.  Happens regardless of chapters.</t>
<t tx="ekr.20070513111526.8"></t>
<t tx="ekr.20070513111526.80"># Returns in finally clauses prevent the re-raising of the saved exception(!!)</t>
<t tx="ekr.20070513111526.99">https://sourceforge.net/forum/message.php?msg_id=4283692</t>
<t tx="ekr.20070513112414">- Added support for chapters to Leo's core

  Chapters are regions of a Leo outline whose root is an @chapter node. @chapter
  nodes may appear anywhere in an outline, but the create-chapter command (see
  below) creates @chapter nodes as children of a single @chapters node.
  
  Selecting a chapter shows only then nodes in the selected chapter; in this
  respect, chapters are like hoists. The main chapter represents the entire
  outline and can not be deleted by name. When chapters are in effect, Leo
  creates a hidden @chapters node containing one @chapter node for every chapter
  except the 'main' chapter.
  
  Associated settings:
      
  - The @bool use_chapters setting determines whether chapters are enabled.
  - The @bool use_chapter_tabs setting determines whether the chapters
    pop-up menu appears in the icon area. Choosing a chapter name from this list selects a chapter.

  When chapters are enabled, the Cmds:Chapters menu shows all available chapter commands:
      
  - The create-chapter command creates an @chapter node and with a single node.
  - The delete-chapter command deletes the presently selected chapter.
  - The select-chapter command makes only the nodes of the selected chapter visible.
  - The move-node-to-chapter, clone-node-to-chapter and copy-node-to-chapter commands
    add a node (and its descendants) to another chapter.</t>
<t tx="ekr.20070513113903"></t>
<t tx="ekr.20070513113931">##########################################
What's New in Leo 4.4.3
##########################################

The highlights of Leo 4.4.3:

- @test and @suite nodes may now be embedded directly in external files.
- Added support for chapters in Leo's core.
- Added support for zipped .leo files.
- The new leoBridge module allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Better support for the winpdb debugger.
- Added support for @enabled-plugins and @open-with nodes in settings files.
- Removed all gui-dependent code from Leo's core.
- The__wx_gui plugin is now functional.

.. .. contents::</t>
<t tx="ekr.20070513113931.1">.. Links used in this document.
.. _`leoBridge chapter`:    leoBridge.html
.. _`debugging with Leo`:   debuggers.html
</t>
<t tx="ekr.20070513115832.1">::

    apropos-debugging-commands
    clean-all-lines
    clone-node-to-chapter
    copy-node-to-chapter
    create-chapter
    delete-chapter
    goto-first-visible-node 
    move-node-to-chapter
    print-plugin-handlers
    print-plugins
    print-settings
    save-file-as-unzipped
    save-file-as-zipped
    select-chapter
</t>
<t tx="ekr.20070513115832.2">- @test and @suite nodes may now be embedded in external files.
- Added support for chapters to Leo's core

  Chapters are regions of a Leo outline whose root is an @chapter node. @chapter
  nodes may appear anywhere in an outline, but the create-chapter command (see
  below) creates @chapter nodes as children of a single @chapters node.

  Selecting a chapter shows the nodes in the selected chapter; in this
  respect, chapters are like hoists. The main chapter represents the entire
  outline and can not be deleted by name. When chapters are in effect, Leo
  creates a hidden @chapters node containing one @chapter node for every chapter
  except the 'main' chapter.

  Associated settings:

  - The @bool use_chapters setting determines whether chapters are enabled.
  - The @bool use_chapter_tabs setting determines whether the chapters
    pop-up menu appears in the icon area. Choosing a chapter name from this list selects a chapter.

  When chapters are enabled, the Cmds:Chapters menu shows all available chapter commands:

  - The create-chapter command creates an @chapter node and with a single node.
  - The delete-chapter command deletes the presently selected chapter.
  - The select-chapter command makes only the nodes of the selected chapter visible.
  - The move-node-to-chapter, clone-node-to-chapter and copy-node-to-chapter commands
    add a node (and its descendants) to another chapter.

- Added support for compressed .leo files

  Leo now has save-file-as-zipped and save-file-as-unzipped commands, and
  corresponding Save File As Zipped and Save File as Unzipped items in the File
  menu. These are exactly the same as Leo's Save As commands except that they
  temporarily force Leo to write the file in either zipped or unzipped format.
  Leo remembers whether a file was originally zipped. The read logic handles
  either zipped or unzipped .leo files automatically. The write logic will zip
  the file if it was originally zipped or if the save-file-as-zipped command is
  being executed. Leo writes files with .leo extension, regardless of whether
  the file is zipped or not. Zipped .leo files contain a single archive, whose
  name is the same as the .leo file itself.

  **Notes**: The new save commands suffice to compress and expand .leo files on
  a file-by-file basis. In particular, there is no need for any user settings.
  Outside of Leo you can change the extension to .leo.zip and use stuffit or
  other program to expand the .leo file contained within. I've only tested this
  on XP, but it should work everywhere...At present the code uses Python's
  zipfile module to read and write zipped files.

- Added leoBridge module.
  See the `leoBridge chapter`_ for full details.

- Removed all (or almost all) gui-independent from Leo's core.

- Improved support for the winpdb debugger.
  See the `debugging with Leo`_ chapter for full details.</t>
<t tx="ekr.20070513115832.3">::

    @openwith nodes
    @enabled-plugins nodes 
    @bool center_selected_tree_node
    @bool chdir_to_relative_path
    @bool contractVisitedNodes
    @bool force_newlines_in_at_nosent_bodies
    @bool invisible_outline_navigation
    @bool show_full_tracebacks_in_scripts
    @bool use_chapter_tabs
    @bool use_chapters

For details of these new settings, see leoSettings.leo



</t>
<t tx="ekr.20070513115832.4">- The __wx_gui.py plugin is now minimally functional. Alas, some problems
  remain. See the bug list in the plugin for details.

- Changed bindings in the UniversalScrolling plugin.

- Registered the write-restructured-text command in rst3 plugin.
</t>
<t tx="ekr.20070513115832.5">- See the release notes for a list of the many bugs fixed in Leo 4.4.3.

- Warn on dubious section brackets.
  For details, see http://sourceforge.net/forum/message.php?msg_id=4162357

- Added Find and Spell tabs to log pane on startup.
  The spell tab is only shown if Aspell was properly imported.

- Added shortcuts for goto-first/last-sibling commands.

- Made escape in the minibuffer work like ctrl-g.

- Only do one message re writing recent files.

- Added handleUrlInUrlNode helper for OnIconDoubleClick.

- Made copied nodes valid Leo files.
  For details, see http://sourceforge.net/forum/message.php?msg_id=4014079

- changeAll now works like findAll

- Clear status line in repeat-complex-command.
</t>
<t tx="ekr.20070610063456">Leo 4.4.3 beta 2                                June 12, 2006

Leo 4.4.3 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.3:
----------------------------
- Added support for chapters in Leo's core.
  Chapters are disabled by default.  To enable, set @bool use_chapters = True.
- Added support for zipped .leo files.
- Added a leoBridge module that allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Added support for @enabled-plugins nodes in settings files.
- Added support for @open-with nodes in settings files.
- Added support for @bool write_strips_blank_lines setting.
- The__wx_gui plugin is now functional.
- Leo can use aspell on Linux when using Python 2.5 or later.
- Many minor improvements, new settings, commands and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20070610063538.1"></t>
<t tx="ekr.20070610063538.151"></t>
<t tx="ekr.20070610063538.163">http://sourceforge.net/forum/message.php?msg_id=4320971
</t>
<t tx="ekr.20070610063538.164">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4309448

Still to do: update urls for tigris.</t>
<t tx="ekr.20070610063538.165">http://sourceforge.net/forum/message.php?msg_id=4301021
</t>
<t tx="ekr.20070610063538.168">- Select a node by clicking on it.
- The node is selected, but shift-arrow does not work.

However, clicking the canvas does work.

The fix was to give the canvas, not the headline focus when clicking on a headline.
This results in canvas bindings, not text bindings, having priority.
This is not a kludge: the text widget isn't active, so text bindings should not be in effect.
</t>
<t tx="ekr.20070610063538.171"></t>
<t tx="ekr.20070610063538.175">http://sourceforge.net/forum/message.php?msg_id=4340244
</t>
<t tx="ekr.20070610063538.2">http://sourceforge.net/forum/message.php?msg_id=4315027

The fix was to g.skip_to_end_of_line (!)

All such functions now return len(s) as a boundary condition.
This is a major change.  All unit tests pass.</t>
<t tx="ekr.20070610063538.209">http://sourceforge.net/forum/message.php?msg_id=4341644
</t>
<t tx="ekr.20070610063538.212"></t>
<t tx="ekr.20070610063538.280"></t>
<t tx="ekr.20070610063538.281"></t>
<t tx="ekr.20070610063538.334">The following chapter commands now exist:

clone-node-to-chapter
convert-node-to-chapter
copy-node-to-chapter
create-chapter
create-chapter-from-node
move-node-to-chapter
remove-chapter
rename-chapter
select-chapter</t>
<t tx="ekr.20070610063538.336">http://sourceforge.net/forum/message.php?msg_id=4318634

- Use ctypes.util.find_library('aspell') to find aspell lib.
</t>
<t tx="ekr.20070610063538.366">http://sourceforge.net/forum/message.php?msg_id=4255709

Added globalDynamicAbbrevs setting.
Added tab completion for dabbrev-expand.</t>
<t tx="ekr.20070610063538.377">This for the use of the hoist plugin.</t>
<t tx="ekr.20070610173300">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4134565

The following are now enabled by default:

# Plugin_manager.py needs plugins_menu.py
plugins_menu.py
plugin_manager.py
open_with.py
mod_scripting.py
rst3.py
UNL.py

# Enabled by default in Leo 4.4.3. (order is important)
nav_buttons.py
hoist.py
image.py
leo_to_html.py

I left out cleo because it has been reported not to be fully functional with Leo 4.4.3.</t>
<t tx="ekr.20070610174018"></t>
<t tx="ekr.20070611161859">http://sourceforge.net/forum/message.php?msg_id=4356197</t>
<t tx="ekr.20070622090350">Leo 4.4.3 beta 3                                June 23, 2006

Leo 4.4.3 beta 3 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This release fixes all known bugs and adds several new features.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.3:
----------------------------
- Added support for chapters in Leo's core.
- Added support for zipped .leo files.
- Added a leoBridge module that allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Added support for @enabled-plugins nodes in settings files.
- Added support for @open-with nodes in settings files.
- Added support for @bool write_strips_blank_lines setting.
- The__wx_gui plugin is now functional.
- Leo can use aspell on Linux when using Python 2.5 or later.
- @test nodes can now be run from any .leo file.
- Many minor improvements, new settings, commands and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20070622090350.1"></t>
<t tx="ekr.20070622090350.2"># ctypes comes standard with Python 2.5, but can be installed for Python 2.4.
</t>
<t tx="ekr.20070622090350.22">http://sourceforge.net/forum/message.php?msg_id=4362825
</t>
<t tx="ekr.20070622090350.42">Selecting a node now never truncates the beadList.</t>
<t tx="ekr.20070622090350.57">CleanLines was adding a trailing newline.
The fix was to suppress this during unit tests.</t>
<t tx="ekr.20070622090350.59"></t>
<t tx="ekr.20070622090350.60"></t>
<t tx="ekr.20070622090350.61"></t>
<t tx="ekr.20070622090350.62">Alt-home is now bound to goto-first-visible rather than goto-first.</t>
<t tx="ekr.20070622090350.65">This script runs all @test nodes as follows:

- Copies all @suite and @tests nodes to dynamicUnitTests.leo.

- Runs leoDynamicTest.py in a separate process. In turn, leoDynamicTest.py
  use the leoBridge module to run dynamicUnitTests.leo.
  (test.leo contains the source code for leoDynamicTest.py.)

Thus, all unit tests will be run with the latest Leo sources.

Allowing @test nodes in leoPy.leo is important: unit tests can be placed near
the code they are intended to test.</t>
<t tx="ekr.20070622090350.66">The test 'if g.unitTesting:' is a shorter replacement for the test 'if g.app and g.app.unitTesting:'.

Using g.getTestVars eliminates pychecker warnings about undefined c and p variables.</t>
<t tx="ekr.20070622090350.8"></t>
<t tx="ekr.20070622090350.9"># Created menu-command-key command that just returns 'continue'.</t>
<t tx="ekr.20070622141457">1. Install Python from http://www.python.org/download/releases/

2. Install PyQt. Get binary package from
   http://www.riverbankcomputing.co.uk/software/pyqt/download which
   matches installed Python version.
   Then run the installer.

3. Install Leo.  Get Leo's .zip file from http://sourceforge.net/projects/leo/
   You can unpack the .zip file anywhere, including Python's *site-packages* folder,
   for example, C:\\Python26\\Lib\\site-packages

4. [optional] Generate/update a junction link from unpacked
   leo folder to ...\\site-packages\\leo::

      cd C:\Python26\Lib\site-packages\
      junction leo leo-4-6-2-final

5. Create windows shortcut (edit paths as necessary):

      Target   =  C:\\Python26\\pythonw.exe "C:\\Python26\\Lib\\site-packages\\leo\\launchLeo.py"
      Start in =  D:\\code

6. Associate .leo filetype batch file:

      ftype LeoFile=C:\\Python26\\pythonw.exe "C:\\Python26\\Lib\\site-packages\\leo\\launchLeo.py" "%1"
      assoc .leo=LeoFile

7. [optional] Put this leo.bat in %PATH%:

      @C:\\Python26\\python.exe -i "C:\\Python26\\Lib\\site-packages\\leo\\launchLeo.py" %*


For more information see::

    Junction links:
        http://technet.microsoft.com/en-gb/sysinternals/bb896768.aspx,
        http://groups.google.com/group/leo-editor/msg/30116f9193241dc4
    ftype:
        http://ss64.com/nt/ftype.html
    assoc:
        http://ss64.com/nt/assoc.html
</t>
<t tx="ekr.20070622180342">- Added support for chapters to Leo's core

  Chapters are regions of a Leo outline whose root is an @chapter node. @chapter
  nodes may appear anywhere in an outline, but the create-chapter command (see
  below) creates @chapter nodes as children of a single @chapters node.
  
  Selecting a chapter shows only then nodes in the selected chapter; in this
  respect, chapters are like hoists. The main chapter represents the entire
  outline and can not be deleted by name. When chapters are in effect, Leo
  creates a hidden @chapters node containing one @chapter node for every chapter
  except the 'main' chapter.
  
  Associated settings:
      
  - The @bool use_chapters setting determines whether chapters are enabled.
  - The @bool use_chapter_tabs setting determines whether the chapters
    pop-up menu appears in the icon area. Choosing a chapter name from this list selects a chapter.

  When chapters are enabled, the Cmds:Chapters menu shows all available chapter commands:
      
  - The create-chapter command creates an @chapter node and with a single node.
  - The delete-chapter command deletes the presently selected chapter.
  - The select-chapter command makes only the nodes of the selected chapter visible.
  - The move-node-to-chapter, clone-node-to-chapter and copy-node-to-chapter commands
    add a node (and its descendants) to another chapter.</t>
<t tx="ekr.20070622185234">The 'official' way to start a replace command is::

    &lt;Ctrl-shift-r&gt;find-pattern&lt;return&gt;replace-text&lt;return&gt;

But suppose you with start with::

    &lt;ctrl-f&gt;find-pattern

and then realize you want to do a replace instead of a find.
No problem.  The following also works::

    &lt;Ctrl-f&gt;find-pattern&lt;Ctrl-shift-r&gt;replace-text&lt;return&gt;

In other words, you can think of `&lt;ctrl-f&gt;` as meaning 'show the find dialog'.
There is another trick you should know.
After typing `&lt;ctrl-f&gt;` or `&lt;shift-ctrl-r&gt;` you can use `&lt;alt-ctrl&gt;` keys to set or clear find options.
For example::

    &lt;ctrl-f&gt;&lt;alt-ctrl-w&gt;&lt;find-pattern&gt;&lt;return&gt;

That is, `&lt;ctrl-f&gt;`shows the find dialog,
`&lt;alt-ctrl-w&gt;` toggles the Whole Word checkbox and
`&lt;return&gt;` starts the search.
You can type the `&lt;alt-ctrl&gt;` keys anytime after `&lt;ctrl-f&gt;` (or `&lt;shift-ctrl-r&gt;`) and before `&lt;return&gt;`. 
You can also type multiple `&lt;alt-ctrl-keys&gt;` to toggle multiple checkboxes.</t>
<t tx="ekr.20070622212132">::

    activate-cmds-menu
    activate-edit-menu
    activate-file-menu
    activate-help-menu
    activate-outline-menu
    activate-plugins-menu
    activate-window-menu
    add-space-to-lines
    add-tab-to-lines
    clean-lines
    clear-selected-text
    click-click-box
    click-headline
    click-icon-box
    clone-find-all
    contract-and-go-right
    contract-body-pane
    contract-log-pane
    contract-outline-pane
    contract-pane
    double-click-headline
    double-click-icon-box
    dump-all-objects
    dump-new-objects
    expand-body-pane
    expand-log-pane
    expand-outline-pane
    expand-pane
    find-again
    find-all
    find-tab-change
    find-tab-change-all
    find-tab-change-then-find
    find-tab-find command
    find-tab-find-previous
    free-text-widgets
    fully-expand-body-pane
    fully-expand-log-pane
    fully-expand-outline-pane
    fully-expand-pane
    goto-first-sibling
    goto-global-line
    goto-last-sibling
    help
    help-for-command
    hide-body-pane
    hide-find-tab
    hide-log-pane
    hide-minibuffer
    hide-outline-pane
    hide-pane,
    open-find-tab
    open-find-tab
    open-outline-by-name (uses filename completion)
    open-spell-tab
    print-bindings
    print-commands    re-search-backward
    re-search-forward
    remove-space-from-lines
    remove-tab-from-lines
    replace-string
    scroll-down
    scroll-down-extend-selection
    scroll-outline-down-line
    scroll-outline-down-page 
    scroll-outline-up-line
    scroll-outline-up-page
    scroll-up
    scroll-up-extend-selection
    search-backward
    search-forward
    search-with-present-options
    set-find-everywhere
    set-find-node-only
    set-find-suboutline-only
    show-colors
    show-fonts
    show-minibuffer
    show-search-options
    simulate-begin-drag
    simulate-end-drag
    toggle-find-ignore-case-option
    toggle-find-in-body-option,
    toggle-find-in-headline-option
    toggle-find-mark-changes-option
    toggle-find-mark-finds-option
    toggle-find-regex-option
    toggle-find-reverse-option
    toggle-find-word-option and
    toggle-find-wrap-around-option
    toggle-mini-buffer
    verbose-dump-objects
    word-search-backward
    word-search-forward
</t>
<t tx="ekr.20070622212732">- Added @font menu font setting.
- Added support for commands to be executed on entry to a mode.
- Added support for bindings that are active only in command, enter and insert key states.
- Added support for @abbrev nodes in leoSettings.leo.
- Improved check bindings script in leoSettings.leo.
- Allow @mode outside of leoSettings.leo.
- Added warnings about the @bool expanded_click_area setting.
</t>
<t tx="ekr.20070623145346"></t>
<t tx="ekr.20070623145346.1">Leo's setup.py script is intended only to create source distributions. It can't
be used to install Leo because Leo is not a Python package.</t>
<t tx="ekr.20070623145346.2">Chapters are regions of a Leo outline whose root is an ``@chapter`` node. They are available in an outline if the ``@bool usechapters`` option is True.  ``@chapter``
nodes may appear anywhere in an outline, but the ``create-chapter`` command (see
below) creates ``@chapter`` nodes as children of the first ``@chapters`` (note the ``s``) node in the outline.

One selects a chapter with the ``select-chapter`` command, after which Leo shows only the nodes in the selected chapter; in this
respect, chapters are like hoists. The ``main`` chapter represents the entire
outline and can not be deleted by name. When chapters are in effect, Leo
creates an ``@chapters`` node for the use of ``create-chapter``.

Associated settings:

- The ``@bool use_chapters`` setting determines whether chapters are enabled.
- The ``@bool use_chapter_tabs`` setting determines whether the chapters
  pop-up menu appears in the icon area. Choosing a chapter name from this list selects a chapter.  Currently, this works in Qt, but a bug in Tk prevents it from functioning correctly in that GUI.

When chapters are enabled, the Cmds-&gt;Chapters menu shows all available chapter commands:

- The ``chapter-create`` command creates an @chapter node and populates it with a single node.
- The ``chapter-remove`` command deletes the currently selected chapter.
- The ``chapter-select`` command promptes for a chapter name and makes only the nodes of the selected chapter visible.
- The ``chapter-move-node-to``, ``chapter-clone-node-to`` and ``chapter-copy-node-to`` commands
  prompt for a chapter name and add the currently selected node (and its descendants) to another chapter.
</t>
<t tx="ekr.20070626082732">Leo 4.4.3 final                                  June 26, 2006

Leo 4.4.3 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.3:
----------------------------
- Added support for chapters in Leo's core.
- Added support for zipped .leo files.
- Added a leoBridge module that allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Added support for @enabled-plugins nodes in settings files.
- Added support for @open-with nodes in settings files.
- Added support for @bool write_strips_blank_lines setting.
- The__wx_gui plugin is now functional.
- Leo can use aspell on Linux when using Python 2.5 or later.
- @test nodes can now be run from any .leo file.
- Many minor improvements, new settings, commands and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20070628083442">@language rest
@tabwidth -4</t>
<t tx="ekr.20070628083442.1">############################################################
Chapter 20: Unit testing with Leo
############################################################

This chapter describes how you can execute Python unit test from within Leo outlines.

.. .. contents::
</t>
<t tx="ekr.20070628083442.2">.. Links

.. _`run Leo in a console window`:      install.html#running-leo-from-a-console-window</t>
<t tx="ekr.20070628084351">**@test nodes** are nodes whose headlines start with @test. The unit test
commands convert the body text of @test nodes into a unit test automatically.
That is, Leo's unit test commands automatically create a unittest.TestCase
instances which run the body text of the @test node. For example, let us
consider one of Leo's actual unit tests. The headline is::

    @test consistency of back/next links

The body text is::

    if g.unitTesting:
        c,p = g.getTestVars() # Optional: prevents pychecker warnings.
        for p in c.all_positions():
            back = p.back()
            next = p.next()
            if back: assert(back.getNext() == p)
            if next: assert(next.getBack() == p)

When either of Leo's unit test commands finds this @test node the command will
run a unit test equivalent to the following::

    import leo.core.leoGlobals as g

    class aTestCase (unittest.TestCase):
        def shortDescription():
            return '@test consistency of back/next links'
        def runTest():
            c,p = g.getTestVars()
            for p in c.all_positions():
                back = p.back()
                next = p.next()
                if back: assert(back.getNext() == p)
                if next: assert(next.getBack() == p)

As you can see, using @test nodes saves a lot of typing:

- You don't have to define a subclass of unittest.TestCase.
- Within your unit test, the c, g and p variables are predefined, just like in Leo scripts.
- The entire headline of the @test node becomes the short description of the unit test.

**Important note**: notice that the first line of the body text is a **guard line**::

    if g.unitTesting:

This guard line is needed because this particular @test node is contained in the
file leoNodes.py. @test nodes that appear outside of Python source files do not
need guard lines. The guard line prevents the unit testing code from being
executed when Python imports the leoNodes module; the g.unitTesting variable is
True only while running unit tests.

**New in Leo 4.6**: When Leo runs unit tests, Leo predefines the 'self' variable to
be the instance of the test itself, that is an instance of unittest.TestCase.
This allows you to use methods such as self.assertTrue in @test and @suite nodes.

**Note**: Leo predefines the c, g, and p variables in @test and @suite nodes,
just like in other scripts.  Thus, the line::

    c,p = g.getTestVars()

is not needed.  However, it prevents pychecker warnings that c and p are undefined.
</t>
<t tx="ekr.20070628094515.1">**@suite nodes** are nodes whose headlines start with @suite. @suite nodes allow
you to create and run custom subclasses of unittest.TestCase.

Leo's test commands assume that the body of an suite node is a script that
creates a suite of tests and places that suite in g.app.scriptDict['suite'].
Something like this::

    if g.unitTesting:
        __pychecker__ = '--no-reimport' # Prevents pychecker complaint.
        import unittest
        c,p = g.getTestVars() # Optional.
        suite = unittest.makeSuite(unittest.TestCase)
        &lt;&lt; add one or more tests (instances of unittest.TestCase) to suite &gt;&gt;
        g.app.scriptDict['suite'] = suite

**Note**: as in @test nodes, the guard line, 'if unitTesting:', is needed only if the
@suite node appears in a Python source file.

Leo's test commands first execute the script and then run suite in
g.app.scriptDict.get('suite') using the standard unittest text runner.

You can organize the script in an @suite nodes just as usual using @others,
section references, etc. For example::

    if g.unitTesting:
        __pychecker__ = '--no-reimport'
        import unittest
        c,p = g.getTestVars() # Optional.
        # children define test1,test2..., subclasses of unittest.TestCase.
        @others 
        suite = unittest.makeSuite(unittest.TestCase)
        for test in (test1,test2,test3,test4):
            suite.addTest(test)
        g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20070628094515.2">The run-all-unit-tests-locally and run-unit-tests-locally commands run unit
tests in the process that is running Leo. These commands *can* change the
outline containing the unit tests.

The run-all-unit-tests and run-unit-tests commands run all tests in a separate
process, so unit tests can never have any side effects. These commands never
changes the outline from which the tests were run. These commands do the
following:

1. Copy all @test, @suite and @unit-tests nodes (including their descendants) to the
   file test/dynamicUnitTest.leo.

2. Run test/leoDynamicTest.py in a separate process.

   - leoDynamicTest.py opens dynamicUnitTest.leo with the leoBridge module.
     Thus, all unit tests get run with the nullGui in effect.

   - After opening dynamicUnitTest.leo, leoDynamicTest.py runs all unit tests
     by executing the leoTest.doTests function.

   - The leoTests.doTests function searches for @test and @suite nodes and
     processes them generally as described above. The details are a bit
     different from as described, but they usually don't matter. If you *really*
     care, see the source code for leoTests.doTests.
</t>
<t tx="ekr.20070629130418" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333722206e616d653d22687474702d6e6f64652d6d61726b65722d3337223e710158040000003c2f613e71025d71032858260000003c64697620636c6173733d2273656374696f6e222069643d22672d726566696e64616c6c223e710458060000003c2f6469763e71055d710628584f0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a711258070000003c2f6469763e0a711358350000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e0a7114586c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313922206e616d653d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e52756e6e696e67204c656f20696e206261746368206d6f64653c2f613e3c2f68313e0a7115652e">On startup, Leo looks for two arguments of the form::

    --script scriptFile

If found, Leo enters batch mode. In batch mode Leo does not show any windows.
Leo assumes the scriptFile contains a Python script and executes the contents of
that file using Leo's Execute Script command. By default, Leo sends all
output to the console window. Scripts in the scriptFile may disable or enable
this output by calling app.log.disable or app.log.enable

Scripts in the scriptFile may execute any of Leo's commands except the Edit Body
and Edit Headline commands. Those commands require interaction with the user.
For example, the following batch script reads a Leo file and prints all the
headlines in that file::

    path = r"&lt;path-to-folder-containing-the-leo-folder&gt;\\leo\\test\\test.leo"

    g.app.log.disable() # disable reading messages while opening the file
    flag,newFrame = g.openWithFileName(path,None)
    g.app.log.enable() # re-enable the log.

    for p in newFrame.c.all_positions():
        g.es(g.toEncodedString(p.h,"utf-8"))
</t>
<t tx="ekr.20070701101808">@language rest</t>
<t tx="ekr.20070701101809">############
Preface
############

.. .. contents::</t>
<t tx="ekr.20070701101809.1">.. links...
.. _`SourceForge`:      http://sourceforge.net/projects/leo/
.. _`noweb`:            http://www.eecs.harvard.edu/~nr/noweb/
.. _reStructuredText:   http://docutils.sourceforge.net/rst.html

.. _outline:            intro.html#introduction
.. _plugins:            intro.html#plugins-settings
.. _scripting:          intro.html#scripting-leo
.. _users:              http://sourceforge.net/projects/leo/

.. _`cloned nodes`:     intro.html#clones-views
.. _`external files`:   intro.html#external-files

.. _`Chapter 14\: Using the Rst3 Plugin`:           rstplugin3.html
</t>
<t tx="ekr.20070702162421">Leo 4.4.3.1                                 July 3, 2006

Leo 4.4.3.1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.3.1:
----------------------------
- Fixed a few minor bugs reported since Leo 4.4.3 was released.
- Added better support for unit testing in Leo.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20070703095207.1"></t>
<t tx="ekr.20070703095207.2"></t>
<t tx="ekr.20070703095207.34">https://sourceforge.net/forum/message.php?msg_id=4385604
</t>
<t tx="ekr.20070703095207.35">Misspelled words were not selected properly on Linux.</t>
<t tx="ekr.20070703095207.40">http://sourceforge.net/forum/message.php?msg_id=4385699
</t>
<t tx="ekr.20070703095207.41">Moving into a chapters node from the main chapter did an automatic hoist.</t>
<t tx="ekr.20070703095207.43">- Made inter-outline moves &amp; copies work again.
- Also, warn that inter-outline clones transfer have no effect.
- Note: none of these operations are presently undoable.

In short, this code is no worse than it has ever been.</t>
<t tx="ekr.20070703095207.5">It's a bit tricky to ensure that leo/src is in sys.path
The code now changes the working directory to leo/src,
and leoDynamicTest.py adds os.getcwd() to sys.path if it is not there.

</t>
<t tx="ekr.20070703095207.50"># Added calls to c,p = g.getTestVars()

(fixed) leoNodes.py:2801: No global (p) found
(fixed) leoNodes.py:2804: No global (c) found

(fixed) leoConfig.py:1739: No global (c) found

(fixed) leoKeys.py:4446: No global (c) found

(fixed) leoEditCommands.py:7823: No global (c) found
(fixed) leoEditCommands.py:8508: No global (e) found
</t>
<t tx="ekr.20070703095207.51"></t>
<t tx="ekr.20070703095207.55"></t>
<t tx="ekr.20070703095207.56"></t>
<t tx="ekr.20070703095207.57">def es_print(s,*args,**keys):

    print g.toEncodedString(s,'ascii')

    if g.app.gui and not g.app.gui.isNullGui and not g.unitTesting:
        g.es(s,*args,**keys)
</t>
<t tx="ekr.20070703095207.58">if g.unitTesting:
    if 0: # Not usually enabled.
        g.es_print('\ntest of es_print: ',color='red')
</t>
<t tx="ekr.20070703095207.59">def es(s,*args,**keys):
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    log = app.log
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            if newline: print s
            else: print s,
    else:
        if log and log.isNull:
            pass
        elif log:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
</t>
<t tx="ekr.20070703095207.61">For full details, see Chapter 20: Unit testing with Leo.
</t>
<t tx="ekr.20070703095207.72">It is essential to protect them with::

     if g.unitTesting:

A new unit test ensures that this is so.</t>
<t tx="ekr.20070703095207.73">http://sourceforge.net/forum/message.php?msg_id=4382336
</t>
<t tx="ekr.20070704074747">Leo's **unit test commands** run the unit tests
created by @test and @suite nodes. run-unit-tests and run-unit-tests-locally
run all unit tests in the presently selected part of the Leo outline;
run-all-unit-tests and run-all-unit-tests-locally run all unit
tests in the entire Leo outline.

Important: you must `run Leo in a console window`_ to see the output the unit tests.
Leo's unit test commands run all the unit tests using the standard unittest text test
runner, and the output of the unit tests appears in the console.

test/unitTest.leo contains many examples of using @test and @suite nodes.</t>
<t tx="ekr.20070723100037">Why, oh why, would anyone be interested in Leo? After all, Emacs and Vim are
superb text editors, and Visual Studio and Eclipse are great IDE's. How can Leo
possibly compete with such strong competition? What does Leo offer that these
other tools don't?

Leo does have something unique to offer--something missing from Emacs,Vim,
Visual Studio and Eclipse. Leo's users often speak of an Aha! moment when they
understand what this 'something' is. The Aha! arises from considering programs,
design and data in a new light. You might call this 'The Leo Way'. In essence,
Leo shows that computer programs, designs and data are *not*, after all, mostly
about text. Yes, people usually *express* programs, designs and data as text.
Yes, people manipulate programs, designs and data *using* text, but *text is not
the whole story*.

In The Leo Way, text is simply a manifestation (a shadow) of something more
fundamental. That 'something else' might be called 'organization' or 'structure'
or 'views' or even 'architecture'. However, let us use the term **node** to
represent the fundamental unit of structure in Leo. We'll see why in a moment.

In architectural terms, nodes are bricks that make up a building. In computer
programming terms, nodes make up methods, classes, files and entire
applications. So the term 'node' does *not* have a fixed meaning--it is simply a
unit of organization. Any node can be built from other nodes, and any node can
be used by any other node. Leo represent nodes directly, as nodes (headlines) in
an outline. An outline node contains a headline and body text. The **outline
pane** shows all headlines; the **body pane** shows the body text of the
presently selected node.

**Outline structure is real data**

To repeat: the fundamental unit in Leo is *not* text. True, headlines and body
*consist* of text, but a node is just not text, it is a true (Python) object.
This means several specific things:

1. Because nodes are true objects, Leo commands understand what a node is, and
   where a node fits into the entire outline. I'll say more about outline
   organization soon, but let me give an example. Every node has exactly one
   parent node, (except for top-level nodes that have no parents) and every node
   has zero or more children and zero or more siblings. A node's parent,
   children and siblings are real properties of the node, *completely
   independent* of the node's headline or body text. Furthermore, any of Leo's
   commands (or user-written scripts or plugins, the big sisters of user
   scripts.) can *easily* access the all aspects of an outline *without* having
   to parse any text whatsoever. Commands, scripts and plugins can easily do the
   following: get the root of the outline, the presently selected node in the
   outline, the parent, siblings, children or descendants of any node in the
   outline, etc., etc. Commands, scripts and plugins can easily insert, delete
   or move nodes, and can alter the headline or body text in any node. All this
   *without* parsing text.

2. Having nodes be true objects means that commands scripts and plugins can
   treat the headline text as *something truly different from* body text. The
   natural interpretation of headline text is as a description of the body text.
   This is important! Headlines often control Leo's commands. For example,
   headlines that start with @thin, @file, @asis, @auto, etc. serve to guide and
   control Leo's read and write commands. Headlines that start with @test,
   @suite and @mark-for-unit-tests guide Leo's unit testing commands. Moreover,
   it is easy to create new conventions for headlines that control user-written
   scripts or plugins. For example, plugins define specific meanings for
   headlines that start with @url, @rst, @bookmark, @slideshow, etc., etc. So
   the separation of headline and body text, **as true components of a node
   object**, is a very big deal.

3. One application of these ideas deserves special mention. Leo's scripting
   plugin provides support for @button nodes. The headline is @button
   &lt;command-name&gt;. The body text contains a script. When Leo opens a Leo
   outline, each @button node creates a command and an icon. Clicking the icon
   (or executing the command) applies the script in the @button node **to the
   presently selected outline**. That is, the script is executed in a context in
   which it is easy to get access to all aspects of the outline in which the
   script is embedded. This is a major advance in scripting. It allows you to
   'bring scripts to data', i.e., any part of an outline. In particular, it is
   very easy to create **editing scripts** that automate what would otherwise be
   boring and repetitive editing tasks.

**Leo outlines aren't your average outline**

Earlier I said that *any* node can be built from other nodes, and *any* node can
be used by any other node. It takes a very special kind of outline for this to
be possible. In a typical outline, such as Emacs outline mode, for example,
nodes appear exactly once in the outline. This makes it impossible to 'reuse'
nodes in multiple places. Leo removes that limitation: any outline node can be
**cloned**, and clones can appear in as many places in an outline as you like.

Cloned nodes are distinct: they must be distinct so they can be moved throughout
the outline, but **cloned nodes share all their information**. That is, changing
the headline or body text in a node instantly changes the headline and body text
in all the other nodes cloned to it. Furthermore, similar remarks apply to the
children and descendants of any node--changing any child (or other descendant)
of a node, say node A, instantly makes corresponding changes to all nodes cloned
to node A.

Earlier I said that you can think of nodes as representing 'organization' or
'structure' or 'views' or even 'architecture'. Clones are the crucial feature
that allows this point of view. For example, we can build up multiple 'views' of
data in an outline using clones as follows:

- Create a 'view node' that will represent a *user-specified* view.

- Clone all nodes that are to be part of the view, and move them so that each
  clone is a child of the view node.

That's about all there is to it. The view node, and its children *is* a new view
of the outline. This notion of 'view' is so important that Leo supports it
directly. Leo's **chapters** are simply views created as I have just described.
When you select one chapter, you only see the nodes of that chapter in Leo's
outline pane.

**Conclusions &amp; encouragements**

So Leo offers a new way to understand, organize and manipulate *any* kind of
complex data, including computer programs, *designs* of computer programs, web
sites, personal data, whatever. The Aha that I invite you to experience is this:
Outlines are more than mere eye candy. Having organization be real data creates
an entirely new dimension, literally and figuratively, in computer programming,
computer design and data organization, including web-site design, database
design, etc. Leo's commands use headline and body text in many creative ways. So
can you and your scripts. It's easy, it's fun, and it's revolutionary.

That's about it, except for some words of caution and advice:

1. Leo has been under active development for over 10 years. The new world
   created by nodes is rich and varied. You won't learn it all in a day or so.
   Please be patient. Start by learning Leo's basic features as explained in the
   tutorial. You can learn more advanced features later.

2. Those of you who are comfortable with Emacs should feel pretty much at home
   with Leo. Leo has shamelessly stolen the best features of Emacs, including
   the minibuffer and many Emacs-like commands.

3. For those of you who are *not* comfortable with Emacs, please understand that
   you do *not* need to understand all of Leo's commands in order to use Leo.
   Start by ignoring the minibuffer. Later, the minibuffer can become your
   friend, but you can get the Aha! without it.

Edward K. Ream
July, 2007</t>
<t tx="ekr.20070724081553">This section contains code-level notes for the threading colorizer. You do not
need to understand this material in order to use the threading colorizer.

The threading_colorizer plugin uses a separate **helper thread** to compute the
ranges of text that should be colored. **The helper thread must not contain any
calls to Tk**. Tk is not thread safe--calling Tk in the helper thread will cause
hard crashes in the Tk dll. However, the code in the helper thread is gui
independent. The **main thread** contains all of Leo's code except for a helper
thread. The main thread contains all calls to Tk, all entry points to the
colorizer, and idleHandler, an idle-time handler.

Only one helper thread is ever active at any one time. If a keystroke occurs
while the helper thread is active, the colorizer code in the main thread sets
the killFlag ivar and calls join to wait for the helper thread to terminate. The
helper thread will terminate promptly because it looks at killFlag each time
through its main loop. Using a separate helper thread allows the main thread to
continue working while the helper thread computes. This allows Tk (in the main
thread) to respond to events. This in turn allows the colorizer code in the main
thread to kill the helper thread if it is still working.

The helper thread runs to completion before the main thread
uses any of its results. Thus, no thread locking is needed, an important
simplification. Once the helper thread completes, the main thread computes the
tags to be sent to Tk, and actually sends those tags. When the user is typing
rapidly, the colorizer will ignore the results of all helper threads except the
last.

After the helper thread generates the list of all requested
tags, the main thread uses a kind of sort-merge algorithm to compare the
existing tags (obtained from Tk) with the requested tags. In many cases, the
lists are the same and colorizer issues *no* calls to Tk. This is a sensational
optimization.  It absolutely minimizes the load on Tk.

When the 'interruptible' argument to the colorizer is False,
no threading is used and the main thread completely colors the entire text. This
must be done when multiple body editors are present.</t>
<t tx="ekr.20070806090226.1">The run-unit-tests command now includes *all* @mark-for-unit-test trees.
</t>
<t tx="ekr.20070806090226.14">The old __jEdit_colorizer__.py plugin has been retired.</t>
<t tx="ekr.20070806090226.15"></t>
<t tx="ekr.20070806090235"></t>
<t tx="ekr.20070806090235.1">Leo 4.4.4 beta 1                                August 10, 2007

Leo 4.4.4 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.4:
----------------------------

- A threading_colorizer plugin replaces the __jEdit_colorizer__ plugin.
  This plugin features much better performance.

- Support for @auto nodes.  Such nodes allow people to collaborate using Leo
  without inserting Leo sentinels in the files Leo generates.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20070806095535.1">@auto trees allows people to use Leo in collaborative environments without using
sentinels in the files Leo generates. In contrast to @nosent, @auto trees can
change when the corresponding file changes outside of Leo.

Leo will automatically recreate (import) all @auto trees when reading a .leo
file, and will write all dirty @auto trees when saving a .leo file. There are
two exceptions to this statement:

1. Leo will never read (import) or write an @auto tree if
the root @auto tree is under the influence of an @ignore directive.

2. Saving a .leo file does not save @auto nodes if a) they haven't been changed
or b) they do not contain a **significant** amount of information. An @auto tree
contains a significant amount of information if it has  children or if the
root node contains more than 10 characters.

Leo creates @auto trees by parsing the corresponding external file. Parsers
create descendant nodes of the @auto tree: one node for each class, method and
function in the external file.

Parsers presently exist for C, elisp, Java, Pascal, PHP and Python. Leo
determines the language using the file's extension. If no parser exists for a
language, the entire body of an @auto tree contains a significant amount of
information if it has any children or if the root node contains more than 10
non-blank lines. the external file is copied to the body of the @auto node.

Leo does not write the contents of @auto trees to .leo files. In this respect,
@auto trees work much like @thin trees. @auto trees whose root node is under the
scope of an @ignore directive *will* be written to the .leo, just like @thin
trees.</t>
<t tx="ekr.20070806100055">All present parsers are short overrides of a powerful base parser class. Thus,
it would be simple to add support for other languages. See the node

@thin leoImport.py--&gt;Import--&gt;Scanners for createOutline

in leoPy.leo to see how easy it is to create new parsers.

</t>
<t tx="ekr.20070806101412">Three new commands in the File:Read/Write menu allow you to manually read and
write @auto nodes from the presently selected outline. As always, an @ignore
directive in the @auto node or its ancestors will suppress any of these
commands:

- The Read @auto Nodes (read-at-auto-nodes) command reads all @auto nodes in the
  presently selected outline. An @ignore directive will suppress this import.

- The Write @auto Nodes (write-at-auto-nodes) command writes all @auto nodes. An
  @ignore directive will suppress this import. Caution: the write will occur even
  if Leo has not previously read the @auto node.

- The Write Dirty @auto Nodes (write-dirty-at-auto-nodes) is the same as the
  write-at-auto-nodes command, except that only changed @auto trees are written.

Most users will rarely use these explicit commands, because reading and writing
.leo files handles @auto nodes well enough. However, you can use the
read-at-auto-nodes command to update @auto nodes without having to reload the
.leo file.
</t>
<t tx="ekr.20070809141529">Leo performs several checks to ensure that the result of importing an external
file will be equivalent to the file that writing the @auto tree would produce.

These checks can produces **errors** or **warnings**. Errors indicate a
potentially serious problem. Leo inserts an @ignore directive in the @auto tree
if any error is found. This @ignore directive prevents the @auto tree from
modifying the external file. If you @ignore directive, a later write of the
@auto tree will attempt to fix the problems that gave rise to the errors. There
are no guarantees however.

**Strict languages** are languages like Python for which leading whitespace is
especially significant. Before importing a file for a strict language, Leo
**regularizes** the leading whitespace of all lines of the original source file.
That is, Leo converts blanks to tabs or tabs to blanks depending on the value of
the @tabwidth directive in effect for the @auto node. Leo cannot guarantee to
reproduce the original source file exactly if problems are discovered while
regularizing leading whitespace.

After importing a file, Leo verifies that writing the @auto node would create
the same file as the original file. For strict languages, the comparison must be
exact, or nearly so. For non-strict languages, differences in leading whitespace
generate warnings, not errors.

File comparison mismatches can arise for several reasons:

1. Bugs in the import parsers. Please report any suspected bugs immediately.

2. Underindented lines in classes, methods or functions in strict languages. An
   **underindented line** is a line that is indented less then the starting line
   of the class, method or function in which it appears. Leo outlines can not
   represent such lines exactly: every line of node implicitly has at least the
   indentation of any unindented line of the node.

Leo will issue a warning (not an error) for underindented Python comment lines.
Such lines can not change the meaning of Python programs.</t>
<t tx="ekr.20070809145744"></t>
<t tx="ekr.20070809145744.1">##########################################
What's New in Leo 4.4.4
##########################################

Leo 4.4.4 contains many important features originally planned for later releases.
The highlights of Leo 4.4.4:

- **The Great Graph Aha**:
  A Leo outline doesn't have to *be* an arbitrary graph in order to *represent* an arbitrary graph.

  That is, simple scripts allow Leo outlines to represent arbitrary
  directed graphs. There is no need for a separate 'graph world'. The graphed.py
  plugin is a direct result of this Aha. It allows you to create general graphs
  from Leo outlines.

- Support for **@auto nodes**.  Such nodes allow people to collaborate using Leo
  without inserting Leo sentinels in the files Leo generates.

- **@menus trees** in settings files create all of Leo's menus.  It is now dead
  easy to make Leo's menus look the way you want.

- **@buttons trees** in settings files create common @button nodes created in all
  Leo outlines.

- A new, faster, **colorizer plugin** replaces the __jEdit_colorizer__ plugin.

- New commands for **resolving cvs conflicts**.

- Leo's core is now compatible with jython.

.. .. contents::</t>
<t tx="ekr.20070809145744.2">.. Links used in this document.
.. _`leoBridge chapter`:    leoBridge.html
.. _`debugging with Leo`:   debuggers.html
</t>
<t tx="ekr.20070809145744.3"></t>
<t tx="ekr.20070809145744.4">::

    check-derived-file
    check-leo-file
    compare-leo-outlines
    insert-child
    read-at-auto-nodes
    read-file-into-node
    write-at-auto-nodes
    write-dirty-at-auto-nodes
    write-file-from-node</t>
<t tx="ekr.20070809145744.5"></t>
<t tx="ekr.20070809145744.6">- The graphed plugin allows users to manipulate parts of Leo outlines as if they
  were general graphs. It is still early days for this exciting plugin.

- The threading_colorizer plugin replaces the __jEdit_colorizer__ plugin. This
  plugin features an elegant new algorithm that has much better performance and
  eliminates almost all flash.
</t>
<t tx="ekr.20070809145744.7">- See the release notes for a list of bugs fixed in Leo 4.4.4.

- Added the 'clear-all-marks' hook.

- Added button font setting. See the node: "@settings--&gt;Fonts--&gt;@font button font" in leoSettings.leo.

- Plugins and scripts may call the c.frame.canvas.createCanvas method to create a
  log tab containing a Tk.Canvas widget. Here is an example script::

    log = c.frame.log ; tag = 'my-canvas'
    w = log.canvasDict.get(tag)
    if not w:
        w = log.createCanvas(tag)
        w.configure(bg='yellow')
    log.selectTab(tag)

- Improved the yank and yank-pop commands and added @bool add_ws_to_kill_ring setting.

- Improved the debug command: it now adds the following code to the beginning of debug scripts::

    class G:
        def es(s,c=None):
          pass
    g = G()

- Added the @bool rst3 strip_at_file_prefixes setting.

- Added the g.app.inBridge ivar.

- Added @bool big_outline_pane setting. False (legacy): Top pane contains outline and log panes.
  True: Top pane contains only the outline pane.  Bottom pane contains body and log panes.</t>
<t tx="ekr.20070814104719">You enable or disable plugins using @enabled-plugins nodes in leoSettings files (leoSettings.leo, myLeoSettings.leo or the .leo file being loaded).  See `Specifying settings`_ for full details of settings files.

The body text of the @enabled-plugins node contains a list of enabled plugins.
Notes:

- Leo attempts to load all plugins every time an @enabled-plugins node is seen.
   If the plugin has already been loaded, Leo silently ignores the request to
   re-enable the plugin. Leo never attempts to disable a plugin while processing
   enabled plugin strings. Thus, plugins enabled in an @enabled-plugins node in
   leoSettings.leo *will* be enabled regardless of the contents of any other
   @enabled-plugins node.

- g.app.gui.getEnabledPlugins contains the last value last processed
   @enabled-plugins node.
</t>
<t tx="ekr.20070816092449">Question and answer from plumloco.

Add the equivalent of::

    import sys 
    leocore = "path/to/leo/core" 
    if leocore not in sys.path: sys.path.append(leocore) 
    import leo.core.leoBridge as leoBridge

at the head of each file that uses leoBridge.

The problem is not importing leoBridge itself but (if I use 'from leo.core') the
importing of plugins, who get a different leoGlobals from leoBridge, without
g.app etc, and so do not work if they rely on dynamic values in g.etc.

&gt; Why can't you simply add leo/core to sys.path in sitecustomize.py?  

Putting leo/core on the python path as you suggest would put forty python modules
in the global module namespace for all python programs when I want just one.
Also, I have a safe working copy of leo and a cvs/testing version. I would wish
to test any programs against the testing version while using the working
version, but both /core directories can't be exposed at the same time.

&gt; Do you need plugins while running from the leoBridge? 

Afraid so, at least the rst3 plugin. The solution I am using now is to place::

    sys.modules['leoGlobals'] = leoGlobals  

in leoBridge after import leo.core.leoGlobals as leoGlobals

This allows my scripts
to be portable over the several computers/platforms I need to use them on, and
makes testing scripts against multiple leo versions easy. It does mean that my
scripts are not portable to other leo users but that is not likely to be a
problem.</t>
<t tx="ekr.20070915101157.1"></t>
<t tx="ekr.20070915101157.14">http://sourceforge.net/forum/message.php?msg_id=4445685
</t>
<t tx="ekr.20070915101157.16">http://sourceforge.net/forum/message.php?msg_id=4446937
</t>
<t tx="ekr.20070915101157.168">When saving a .leo file, Leo now *reads* an @auto node if

1) the external file exists,
2) an 'insignificant' amount of data exists in the @auto tree, and
3)the @auto node has not been read previously.

This promises to fix some quite awkward use cases.

The 'perfect import' code now is a bit more relaxed, especially for 'non-strict'
languages (all languages except Python):

- Leo leaves leading whitespace alone for non-strict languages.

- Leo complains about intermixed tabs and blanks in leading whitespace only for
strict languages.

- Leo ignores leading whitespace in the perfect import tests for non-strict
languages.

These changes mean that Leo might change a external file if such a change occurs
only in leading whitespace in a non-strict language.</t>
<t tx="ekr.20070915101157.17"># The code that was removing tags was not working properly.</t>
<t tx="ekr.20070915101157.18">http://sourceforge.net/forum/message.php?msg_id=4437415
</t>
<t tx="ekr.20070915101157.19">http://sourceforge.net/forum/message.php?msg_id=4462693
</t>
<t tx="ekr.20070915101157.3">Email from Terry Brown

A softish bug, but the use of findNodeInTree() in the UNL code can 
take you to the wrong place if more than one node in the tree has 
the same headString.  Patch below - can still go wrong if more than 
one sibling has the same name, but the UNL system doesn't have a 
solution for that.

An observation - the UNL jumping code will drop you as far down the 
path as it gets, i.e. you're moved to the last node that was one the 
path, even if the path ends before the last part of the UNL is 
reached.  This is ok, i.e. "this is as far as I could follow the 
UNL", the alternative would be to not move at all if the whole UNL 
can't be followed.

Cheers -Terry

anon_cvs&gt; cvs diff leo/plugins/UNL.py
Index: leo/plugins/UNL.py
===================================================================
RCS file: /cvs/leo/plugins/UNL.py,v
retrieving revision 1.14
diff -r1.14 UNL.py
183c183,186
&lt;                             p = g.findNodeInTree(c2,p,headline)
---
&gt;                             for tmpp in p.copy().children_iter():
&gt;                                 if tmpp.headString() == headline:
&gt;                                     p = tmpp
&gt;                                     break
206c209,212
&lt;                             p = g.findNodeInTree(c,p,headline)
---
&gt;                             for tmpp in p.copy().children_iter():
&gt;                                 if tmpp.headString() == headline:
&gt;                                     p = tmpp
&gt;                                     break

</t>
<t tx="ekr.20070915101157.40">http://sourceforge.net/forum/message.php?msg_id=4464980
</t>
<t tx="ekr.20070915101157.45">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4465132
By: terry_n_brown

So I changed all my indentation to multiples of four, having decided I like
the extra line space this buys over aligning with the opening (.

leo said this when it read the file:

@auto did not import the file perfectly

but never mentioned @ignore or anything.  I made a trivial change and saved
and diff could find no difference except my trivial change... which seems perfect
to me...?

@color</t>
<t tx="ekr.20070915101157.48">https://sourceforge.net/forum/message.php?msg_id=4459798</t>
<t tx="ekr.20070915101157.5">http://sourceforge.net/forum/message.php?msg_id=4444579
</t>
<t tx="ekr.20070915101157.50">http://sourceforge.net/forum/message.php?msg_id=4509897
</t>
<t tx="ekr.20070915101157.70">http://sourceforge.net/forum/message.php?msg_id=4514130
</t>
<t tx="ekr.20070915101157.81">http://sourceforge.net/forum/message.php?msg_id=4468174</t>
<t tx="ekr.20070915101157.82"></t>
<t tx="ekr.20070915101216">Leo 4.4.4 beta 2                                September 19, 2007

Leo 4.4.4 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.4:
----------------------------

- A threading_colorizer plugin replaces the __jEdit_colorizer__ plugin.
  This plugin features much better performance.

- Support for @auto nodes.  Such nodes allow people to collaborate using Leo
  without inserting Leo sentinels in the files Leo generates.
  
- New commands for resolving cvs conflicts.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20070920092716">The so-called resolve-cvs-conflict project has resolved itself into small,
easily understood commands.

The **read-file-into-node** command prompts for a filename, and creates an node
whose headline is @read-file-into-node &lt;filename&gt; and whose body text is the
entire contents of the file.

The **write-file-from-node** command writes the body text of the selected not to a file.
If the headline of the presently selected node starts with @read-file-into-node
the command use the filename that follows in the headline. Otherwise, the
command prompts for a filename.

When a cvs conflict occurs, the user will:

- read the file into a node using the read-file-into-node command,

- fix the conflict, as with any other editor, and

- write the file with the write-file-from-node command.

Any file can be fixed in this way, including external files and .leo files. The
only complication is that the user must not change sentinel lines. Two new
commands check the contents of a node: The **check-derived-file** and
**check-leo-file** commands tell whether a trial read of the presently selected
node can be done successfully. The check-derived-file command assumes the body
text is a external file; the check-leo-file command assumes the body text is an
entire .leo file.

The **compare-leo-outlines** command prompts for another (presumably similar)
.leo file that will be compared with the presently selected outline file (main
window). It then creates clones of all inserted, deleted and changed nodes.</t>
<t tx="ekr.20071001122703">All @buttons tree in a settings file defines global buttons that are created in
the icon area of all .leo files. You define @button nodes in the @buttons tree
as usual.</t>
<t tx="ekr.20071004101349">Leo 4.4.4 beta 3                            October 23, 2007

Leo 4.4.4 beta 3 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.4 contains many important features originally planned for later releases.
It's been a good month :-)

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.4:
----------------------------

- The Great Graph Aha (tm): simple scripts allow Leo outlines to represent
  arbitrary directed graphs. There is no need for a separate 'graph world'. The
  graphed.py plugin is a direct result of this Aha. The graphed.py plugin allows
  you to create general graphs from Leo outlines.
  
- @menus trees in settings files create all of Leo's menus.  It is now dead
  easy to make Leo's menus look the way you want.

- @buttons trees in settings files create common @button nodes created in all
  Leo outlines.

- @auto nodes eliminate sentinels in external files, thereby allowing people to
  collaborate using Leo more easily.
  
- New commands for resolving cvs conflicts.

- A threading_colorizer plugin replaces the __jEdit_colorizer__ plugin.
  This plugin features much better performance and a new, elegant algorithm.
  
- Leo is now compatible with jython.

- The usual assortment of bug fixes and other minor improvements.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20071004101443.1"></t>
<t tx="ekr.20071004101443.105">Leo creates its menus using @menus trees. Within @menus trees,
@menu nodes create menus and @item nodes create menu items.

Notes:

- The menu name always follows @menu. If the menu name is 'Plugins', Leo will
  create the Plugins menu and populate the menu by calling the
  'create-optional-menus' hook. This creates the Plugins menu as usual.

- Nested @menu nodes contain submenus.

- The command name follows @item. If the body text of an @item node exists, this
  body text is the menu name. Otherwise, the menu name is the command name.
  However, if the command name starts with a '*', hyphens are removed from the
  menu name.

- Menu names and command names may contain a single ampersand (&amp;). If present,
  the following character is underlined in the name.

- If the command name in an @item node is just a hyphen (-), the item represents
  a menu separator.
  
- Unicode characters, e.g., Chinese characters *are* allowed.</t>
<t tx="ekr.20071004101443.178">The c.frame.logcreateCanvas convenience method create a canvas tab in the log pane.
Here is a sample script:

log = c.frame.log ; tag = 'my-canvas'

w = log.canvasDict.get(tag)
if not w:
..w = log.createCanvas(tag)
..w.configure(bg='yellow')

log.selectTab(tag)
</t>
<t tx="ekr.20071004101443.18"></t>
<t tx="ekr.20071004101443.26">http://sourceforge.net/forum/message.php?msg_id=4543844
</t>
<t tx="ekr.20071004101443.29"></t>
<t tx="ekr.20071004101443.30">See the node:
    
@settings--&gt;Fonts--&gt;@font button font

in leoSettings.leo.</t>
<t tx="ekr.20071004101443.52">@button nodes in the @buttons tree in settings file define **global buttons** that appear in all Leo outlines.</t>
<t tx="ekr.20071004103659">The Great Graph Aha is:

A Leo outline doesn't have to *be* an arbitrary graph in order to *represent* an arbitrary graph.

So the graph world is unnecessary because we can use Leo nodes and trees as data
to other graphing packages.** That is, Python scripts can build arbitrary graphs
using Leo's existing nodes and trees. And Python scripts can manipulate those
graphs. And Python scripts could do the reverse: manipulate the Leo outline by
traversing general graphs. So there is no need to complicate Leo's fundamental
data structures. Hurray! Instead, we build on the strengths of already existing
graphing packages.

The Great Graph Aha created the opportunity for immediate action:

1. test.leo contains the essential scripts to implement graphs in Leo files.
   These short, simple, self-contained, easily modifiable scripts make possible
   everything ever envisaged by the (now-defunct) graph world project::

    leo2graph: convert a normal Leo tree to a NetworkX graph. 
    at-graph2graph: convert an @graph tree to a NetworkX graph. 
    at-networkx2graph: convert an @networkx tree to a NetworkX graph 
    at-networkx2at-graph: create an @graph tree from an @networkx tree.

2. The graphed plugin allows users to manipulate parts of Leo outlines as if
they were general graphs. It is still early days for this exciting plugin.</t>
<t tx="ekr.20071004105000">The graphed plugin allows users to manipulate parts of Leo outlines as if
they were general graphs. It is still early days for this exciting plugin.</t>
<t tx="ekr.20071004110818">Leo creates its menus from the @menu and @item nodes in the @menus tree. Within
@menus trees, @menu nodes create menus and @item nodes create menu items.

The menu name always follows @menu. If the menu name is 'Plugins', Leo will
create the Plugins menu and populate the menu by calling the
'create-optional-menus' hook. This creates the Plugins menu as usual. Nested
@menu nodes define submenus.

The command name follows @item. If the body text of an @item node exists, this
body text is the menu name. Otherwise, the menu name is the command name.
However, if the command name starts with a '*', hyphens are removed from the
menu name. Menu names and command names may contain a single ampersand (&amp;). If
present, the following character is underlined in the name. If the command name
in an @item node is just a hyphen (-), the item represents a menu separator.</t>
<t tx="ekr.20071005095907">- Replaced all 'yield' statements with iterators.

- Added 'jyLeo' keyword to leo.run.

- All of Leo's startup code works with the swing gui enabled (jyLeo = True in leo.run).</t>
<t tx="ekr.20071005100213">Essentially all of Leo's startup code now runs with jython 2.2 and the (unfinished!) swing gui.</t>
<t tx="ekr.20071006093614">This inserts a child node.</t>
<t tx="ekr.20071006155647"></t>
<t tx="ekr.20071021101506">Hurray--these are no longer needed.

The following methods exist for the convenience of plugins.

**g.enableIdleTimeHook(idleTimeDelay=100)**

Enables the "idle" hook. Afterwards, Leo will call the "idle" hook approximately every idleTimeDelay milliseconds.
Leo will continue to call the "idle" hook periodically until disableIdleTimeHook is called.

**g.disableIdleTimeHook()**

Disables the "idle" hook.


**c.frame.menu.createMenuItemsFromTable (self,menuName,table,openWith=0)**

This method adds items to the menu whose name is menuName.
The table argument describes the entries to be created.
This table is a sequence of items of the form (name,None,command):

- name is the command name.
- None was a shortcut in previous versions of Leo, but shortcuts for user-defined commands
  should now be defined in @shortcuts nodes.
- command is the routine to execute when the menu item is selected.
- An entry of the form ("-",None,None) creates a separator line between menu items.


For example::

    table =
        ("Toggle Active Pane",None,self.OnToggleActivePane),
        ("-",None,None),
        ("Toggle Split Direction",None,self.OnToggleSplitDirection))
    c.frame.menu.createMenuItemsFromTable("Window",table)

If the openWith keyword argument is 1 the items are added to a submenu of the Open With menu.
However, it will be more convenient to use the createOpenWithMenuFromTable method to create the Open With menu.

**c.frame.menu.createNewMenu (self,menuName,parentName="top")**

This method creates a new menu:

- menuName is the name of the menu to be created.
- parentName is the name of the parent menu, or "top" if the menu is to created in the menu bar.

This method returns the menu object that was created, or None if there was a problem.
Your code need not remember the value returned by this method.  Instead, your code will refer to menus by name.

**c.frame.menu.createOpenWithMenuFromTable (self,table)**

This method adds items to submenu of the Open With menu item in the File menu.
The table argument describes the entries to be created.
This table is a sequence of items of the form (name,shortcut,data):

- name is the command name
- shortcut is the shortcut, or None to indicate no shortcut.
- data is a tuple of the form (command,arg,ext)
- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- arg is an argument to be passed to the given command.
- ext is a file extension or None.

When the user selects the Open With item corresponding to the table item Leo executes command(arg).
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on what @language directive is in effect.
For example::

    table = (
        ("Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
        ("Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
        ("Wordpad","Alt+Shift+T",("os.startfile",None,".txt")))

    top().frame.createOpenWithMenuFromTable(table)

**c.frame.menu.deleteMenu (self,menuName)**

Deletes the menu whose name is given, including all entries in the menu.

**c.frame.menu.deleteMenuItem (self,itemName,menuName="top")**

Deletes the item whose name is itemName from the menu whose name is menuName.
To delete a menu in the menubar, specify menuName="top".

**c.frame.menu.setRealMenuNamesFromTable(table)**

Translates names of menus and menu items into another language.  For example::

    table = (
        ("Help", "&amp;Aide"),
        ("About Leo...", "Au &amp;sujet de Leo..."),
        ("Online Home Page", "&amp;Page d'Accueil en ligne"),
        ("Open Online Tutorial", "Ouvrir &amp;Tutoriel en ligne"),
        ("Open LeoDocs.leo", "Ouvrir Leo&amp;Docs.leo"),
        ("Open LeoConfig.leo", "Ouvrir Leo&amp;Config.leo"),
        ("Apply Settings", "Appliquer les &amp;Rglages"),
    )

    c.frame.menu.setRealMenuNamesFromTable(table)</t>
<t tx="ekr.20071021102946">Two methods in leoGlobals.py allow scripts and plugins to enable and disable 'idle' events.
**g.enableIdleTimeHook(idleTimeDelay=100)** enables the "idle" hook.
Afterwards, Leo will call the "idle" hook approximately every idleTimeDelay milliseconds.
Leo will continue to call the "idle" hook periodically until disableIdleTimeHook is called.
**g.disableIdleTimeHook()** disables the "idle" hook.</t>
<t tx="ekr.20071021111856.124">This should have been done long ago.</t>
<t tx="ekr.20071021111856.127">http://sourceforge.net/forum/message.php?msg_id=4573990
</t>
<t tx="ekr.20071021111856.20">In some cases the find-previous command did not work.

After much investigation, the cause of the bug was found to be a blunder in backwardsHelper.  Changed:
    
pattern.lower()

to:

pattern = pattern.lower()</t>
<t tx="ekr.20071021111856.252">https://sourceforge.net/forum/message.php?msg_id=4576436
</t>
<t tx="ekr.20071021111856.412">Optimized yank, by using yanked leading whitespace if it exists

New default bindings: Alt-Y: yank-pop.  Alt-Ctrl-Y: cycle-all-focus.

New option: add-ws-to-kill-ring (or kill-ws-adds-to-kill-ring)
</t>
<t tx="ekr.20071021111856.437">Suppressed doc-part-delims when show_doc_parts_as_paragraphs is True.</t>
<t tx="ekr.20071021111856.441">The new code is simple and elegant.  Almost all flash is gone.</t>
<t tx="ekr.20071021111856.458">
http://sourceforge.net/forum/message.php?msg_id=4568499

I like doctests, often debug with g.es()
statements, and open winpdb to examine what's
going on.

I've a small patch to the debug command
leoEditCommands.py--&gt;debugCommandsClass--&gt;debug
to simplify this.

The patch writes the following to the beginning of
the script being debugged;

class G:
def es(s,c=None):
  pass
g = G()

This makes the g.es() statements legal.

The patch also checks for doctests in the script,
and if found, converts them to regular code.

A node containing;

&gt;&gt;&gt; import inspect, sys
&gt;&gt;&gt; insp = sys.modules['inspect']
&gt;&gt;&gt; print insp.__name__
inspect
&gt;&gt;&gt; g.es(dir(insp))

can be run as a doctest;
&lt;alt x&gt; dt
(if the dtest.py plugin is active)

or sent to winpdb;
&lt;alt x&gt; debug

The patch doesn't change the handling of regular scripts.

It goes right after;
if not winpdb: return

#check for doctest examples
try:
    import doctest
    parser = doctest.DocTestParser()
    examples = parser.get_examples(script)

    # if this is doctest, extract the examples as a script
    if len(examples) &gt; 0:
        script = doctest.script_from_examples(script)

except ImportError:
    pass

# special case; debug code may include g.es("info string")
# insert code fragment to make this expression legal outside Leo
hide_ges = "class G:\n def es(s,c=None):\n  pass\ng = G()\n"
script = hide_ges + script
</t>
<t tx="ekr.20071021111856.459">From the documentation at: http://webpages.charter.net/edreamleo/rstplugin3.html#options

strip_at_file_prefixes (default: True)

True: remove @auto, @file, @nosent and @thin from the start of headlines.</t>
<t tx="ekr.20071021111856.461"></t>
<t tx="ekr.20071021111856.476">This is used, at present, by g.getScript.  It is a natural status ivar in any case.</t>
<t tx="ekr.20071021111856.477">- Use the term 'event handler' for hook.  This is much better terminology.

- Move the discussion of event handlers to the scripting chapter.

- Removed the discussion of all menu convenience routines: they are not needed now that Leo supports @menus nodes.

- The 'writing plugins' chapter is now very simple.</t>
<t tx="ekr.20071021111856.83">There were at least 3 bugs:
    
At least three bugs.

- Place cursor on last (blank) line.  Cursor up goes one line too far.
- Place cursor at end of line 1.  Second cursor down does nothing.
- Place cursor at end of xxxx line.  Second cursor down goes one line too far.

xxxxxxxxx
line 1
line 2

The fix was to g.getLine--potentially a major change.</t>
<t tx="ekr.20071023080957">The run-unit-tests command runs tests using the bridge, which uses a nullGui and a stringTextWidget.

Added a hack to g.getScript so it always gets the script from p.bodyString when
g.app.gui.inBridge is True.</t>
<t tx="ekr.20071026053825">Leo 4.4.4 beta 4                            October 27, 2007

Leo 4.4.4 beta 4 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This beta 4 version fixes all bugs reported against Leo 4.4.4 beta 3.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

Leo 4.4.4 contains many important features originally planned for later releases.

The highlights of Leo 4.4.4:
----------------------------

- The Great Graph Aha (tm): simple scripts allow Leo outlines to represent
  arbitrary directed graphs. There is no need for a separate 'graph world'. The
  graphed.py plugin is a direct result of this Aha. The graphed.py plugin allows
  you to create general graphs from Leo outlines.
  
- @menus trees in settings files create all of Leo's menus.  It is now dead
  easy to make Leo's menus look the way you want.

- @buttons trees in settings files create common @button nodes created in all
  Leo outlines.

- @auto nodes eliminate sentinels in external files, thereby allowing people to
  collaborate using Leo more easily. **Warning**: for now, please make backup
  copies of files imported with @auto.
  
- New commands for resolving cvs conflicts.

- A threading_colorizer plugin replaces the __jEdit_colorizer__ plugin.
  This plugin features much better performance and a new, elegant algorithm.
  
- Leo is now compatible with jython.

- Better support for icons in headlines.

- The usual assortment of bug fixes and other minor improvements.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20071026053931.1"></t>
<t tx="ekr.20071026053931.13">http://sourceforge.net/forum/message.php?msg_id=4574271
</t>
<t tx="ekr.20071026053931.156">This should have been done a long time ago.</t>
<t tx="ekr.20071026053931.157">http://sourceforge.net/forum/message.php?msg_id=4585396

The threading colorizer must be run with interruptible=False when there are multiple body editors.</t>
<t tx="ekr.20071026053931.2">Replaced the (useless) trace with an error message to the console window.</t>
<t tx="ekr.20071026053931.219"></t>
<t tx="ekr.20071026053931.220"></t>
<t tx="ekr.20071026053931.221">False (legacy): Top pane contains outline and log panes.
True: Top pane contains only the outline pane.  Bottom pane contains body and log panes.</t>
<t tx="ekr.20071026053931.234">To allow Python's print statement to print unicode characters properly, you must
change Python's default encoding to something other than 'ascii'. To do this,
put the following in your sitecustomize.py file in Python's Lib folder::
 
    import sys 
    sys.setdefaultencoding('utf-8') # 'iso-8859-1' is another choice.
 
You must restart Python after doing this: sys.setdefaultencoding can not be
called after Python starts up.
 
Leo's g.es_print function attempts to convert incoming arguments to unicode
using the default encoding. For example, the following Leo script always prints
La Pea::
 
    @first # -*- coding: utf-8 -*-
    # The line above is required for Python 2.5
     
    for s in (u'La Pe\xf1a','La Pea',u'La Pea'): 
        g.es_print(s)
 
For still more details, see:
    
http://www.diveintopython.org/xml_processing/unicode.html 
</t>
<t tx="ekr.20071026055929"></t>
<t tx="ekr.20071026055929.1">First, you must change Python's default encoding to something other than 'ascii'.  To do this, put the following in your sitecustomize.py file in Python's Lib folder::

    import sys 
    sys.setdefaultencoding('utf-8') # 'iso-8859-1' is another choice.

You must restart Python after doing this: sys.setdefaultencoding can not be called after Python starts up. 

Leo's g.es_print and g.pr functions attempts to convert incoming arguments to unicode using the default encoding.
For example, the following Leo script shows various ways of printing La Pea properly::

    @first # -*- coding: utf-8 -*-

    import sys
    e = sys.getdefaultencoding()
    print 'encoding',e
    table = (
        'La Pea',
        unicode('La Pea','utf-8'),
        u'La Pea',
        u'La Pe\\xf1a',
    )

    for s in table:
        print type(s)
        g.es_print('g.es_print',s)
        if type(s) != type(u'a'):
            s = unicode(s,e)
        print 'print     ',s
        print 'repr(s)   ',repr(s)

For still more details, see:
http://www.diveintopython.org/xml_processing/unicode.html 
</t>
<t tx="ekr.20071026075016">This fixes a fairly old crasher in the fastGotoNode plugin.</t>
<t tx="ekr.20071026092552"></t>
<t tx="ekr.20071026180804">The prototype in test.leo now will use PIL (Python Imaging Library) if
available, so many more kinds of icons can be used. Buttons now exist to add
icons to do the following:

- Add any icon to any node.
- Delete all icons from a single node or the entire tree.
- Print the icon files associated with a node.
- Print the sizes of icons in a directory.

Fixed a bug in the icon handling in the outline widget that caused
duplicate icons not to be drawn properly.</t>
<t tx="ekr.20071026180804.1">The prototype in test.leo now uses PIL (Python Imaging Library) if available,
so many more kinds of icons can be used.

Buttons now exist to add icons to do the following:
    
- Add any icon to any node.
- Delete all icons from a single node or the entire tree.
- Print the icon files associated with a node.
- Print the sizes of icons in a directory.

In addition, fixed a bug in the icon handling in the outline widget that caused
duplicate icons not to be drawn properly.</t>
<t tx="ekr.20071026182824"></t>
<t tx="ekr.20071026183116">Scripts can invoke various dialogs using the following methods of the g.app.gui object.
Here is a partial list. You can use typing completion(default bindings: Alt-1 and Alt-2) to get the full list!
::

    g.app.gui.runAskOkCancelNumberDialog(c,title,message)
    g.app.gui.runAskOkCancelStringDialog(c,title,message)
    g.app.gui.runAskOkDialog(c,title,message=None,text='Ok')
    g.app.gui.runAskYesNoCancelDialog(c,title,message=None,
        yesMessage='Yes',noMessage='No',defaultButton='Yes')
    g.app.gui.runAskYesNoDialog(c,title,message=None)

The values returned are in ('ok','yes','no','cancel'), as indicated by the
method names. Some dialogs also return strings or numbers, again as indicated by
their names.

Scripts can run File Open and Save dialogs with these methods::

    g.app.gui.runOpenFileDialog(title,filetypes,defaultextension,multiple=False)
    g.app.gui.runSaveFileDialog(initialfile,title,filetypes,defaultextension)

For details about how to use these file dialogs, look for examples in Leo's own
source code. The runOpenFileDialog returns a list of file names.</t>
<t tx="ekr.20071101162646">Leo 4.4.4 Final                           November 2, 2007

Leo 4.4.4 Final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

Leo 4.4.4 contains many important features originally planned for later releases.

The highlights of Leo 4.4.4:
----------------------------

- The Great Graph Aha (tm): simple scripts allow Leo outlines to represent
  arbitrary directed graphs. There is no need for a separate 'graph world'. The
  graphed.py plugin is a direct result of this Aha. The graphed.py plugin allows
  you to create general graphs from Leo outlines.
  
- @menus trees in settings files create all of Leo's menus.  It is now dead
  easy to make Leo's menus look the way you want.

- @buttons trees in settings files create common @button nodes created in all
  Leo outlines.

- @auto nodes eliminate sentinels in external files, thereby allowing people to
  collaborate using Leo more easily. **Warning**: for now, please make backup
  copies of files imported with @auto.
  
- New commands for resolving cvs conflicts.

- A threading_colorizer plugin replaces the __jEdit_colorizer__ plugin.
  This plugin features much better performance and a new, elegant algorithm.
  
- Leo is now compatible with jython.

- Better support for icons in headlines.

- Many bug fixes and other minor improvements.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20071101162751"></t>
<t tx="ekr.20071101162751.149">The spell tab now uses the same font as the find tab.</t>
<t tx="ekr.20071101162751.150">http://sourceforge.net/forum/message.php?msg_id=4596477
</t>
<t tx="ekr.20071101162751.178"></t>
<t tx="ekr.20071101162751.184"></t>
<t tx="ekr.20071101162751.19">The fix doesn't actually remember which chapter was previously selected; it
picks some chapter containing the initially selected node. This works exactly
for non-cloned nodes, but can select the 'wrong' chapter for cloned nodes.
Still, this is a big improvement over the previous code, which would not select
any node if the selected node was not in the main chapters.</t>
<t tx="ekr.20071101162751.2">http://sourceforge.net/forum/message.php?msg_id=4591494
</t>
<t tx="ekr.20071101162751.28"></t>
<t tx="ekr.20071101162751.32">It is too confusing at present, because it doesn't support @enabled-plugins nodes.
</t>
<t tx="ekr.20071101162751.33"></t>
<t tx="ekr.20071101162751.34"></t>
<t tx="ekr.20071101162751.4"></t>
<t tx="ekr.20071101162751.97">http://sourceforge.net/forum/forum.php?thread_id=1853660&amp;forum_id=10228
</t>
<t tx="ekr.20071101163257"></t>
<t tx="ekr.20071115102156">Leo 4.4.5 beta 1                          November 16, 2007

Leo 4.4.5 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

Leo 4.4.5 fixes several long-delayed bug fixes and adds several new features.

The highlights of Leo 4.4.5:
----------------------------

- Fixes all known bugs.
- Leo now recognizes directives in headlines.
- Adds 3 new sort-lines commands.
- Adds commands to insert and delete icons from headlines.
- Adds all the Tango 16x16 icons to Leo's icon library.
- Adds support for @rst-preformat nodes to the rst3 plugin.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20071115102156.11">http://sourceforge.net/forum/message.php?msg_id=3525277

The atFile read logic only **adds** nodes, it never deletes nodes. Thus,
the 'changed2' node 'survived' the atFile read logic. The 'changed2' node became
a 'vampire' node that couldn't be killed.

The fix will require some care. The present atFile.read logic is robust because
it *doesn't* delete nodes. I suspect the solutions will be as follows:

A. The atFile.read code can not delete the subtree of @thin nodes initially,
because it doesn't know whether there will be read errors later. If there are
read errors absolutely nothing must change. This ensures that read errors never
destroy information.

B. A new post-pass will look for vampire nodes: nodes that were not actually
read from the external file. I think (but haven't proven) that all descendants of
vampire nodes are also vampire nodes. If that is so the post-pass will simply
delete vampire nodes without worrying about whether they have descendants.
</t>
<t tx="ekr.20071115102156.123">http://sourceforge.net/forum/message.php?msg_id=4615931
</t>
<t tx="ekr.20071115102156.124">http://sourceforge.net/forum/message.php?msg_id=4618014</t>
<t tx="ekr.20071115102156.141">http://sourceforge.net/forum/message.php?msg_id=4620890
</t>
<t tx="ekr.20071115102156.146">From email from Terry Brown

python /home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py /home/tbrown/.tnb.leo

(should be all on one line, i.e. run and open /home/tbrown/.tnb.leo)

gives the traceback below.  Opening the file from within Leo works fine.

Bah - I just now looked at it closely enough to realize it's the evil
pickled Tk classes in cleo uAs.  So I don't know whether you want to
fix that or not, it makes sense Leo would read the file specified on
the command line before Tk is initialized - if it's just scanning for
settings maybe it could catch and ignore failed uA reads at that time?

At some point I want to take pickled Tk vars out of cleo, I was
thinking when that guy was working on the wx gui would be a good time,
too bad he got sick.

reading settings in /mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/config/leoSettings.leo
reading settings in /home/tbrown/leoSettings.leo
reading settings in /home/tbrown/myLeoSettings.leo
reading settings in /home/tbrown/.tnb.leo
Traceback (most recent call last):
  File "/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py", line 398, in &lt;module&gt;
    run(fileName)
  File "/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py", line 118, in run
    g.app.config.readSettingsFiles(fileName,verbose)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoConfig.py", line 1649, in readSettingsFiles
    c = self.openSettingsFile(path)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoConfig.py", line 1674, in openSettingsFile
    theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 892, in open
    silent=silent)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 779, in getLeoFile
    self.getAllLeoElements(fileName,silent)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1317, in getAllLeoElements
    self.getVnodes()
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1898, in getVnodes
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1738, in getVnode
    attr,val = self.getUa("vnode")
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1658, in getUa
    val2 = pickle.loads(binString)
  File "/usr/lib/python2.5/pickle.py", line 1374, in loads
    return Unpickler(file).load()
  File "/usr/lib/python2.5/pickle.py", line 858, in load
    dispatch[key](self)
  File "/usr/lib/python2.5/pickle.py", line 1217, in load_build
    setstate(state)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/plugins/cleo.py", line 130, in __setstate__
    Tk.Variable.__init__(self)
  File "/usr/lib/python2.5/lib-tk/Tkinter.py", line 188, in __init__
    self._tk = master.tk
AttributeError: 'NoneType' object has no attribute 'tk'
Exception exceptions.AttributeError: "TkPickleVar instance has no attribute '_tk'" in &lt;bound method TkPickleVar.__del__ of &lt;cleo.TkPickleVar instance at 0xb73a876c&gt;&gt; ignored
</t>
<t tx="ekr.20071115102156.148"></t>
<t tx="ekr.20071115102156.149"></t>
<t tx="ekr.20071115102156.2"></t>
<t tx="ekr.20071115102156.21">@nocolor

From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

** Also, no ignore inserted.

Current CVS, ubuntu

From the code below I get:

reading: /mnt/removable/bkup_proj/Mammals/mammaldb/mammaldb.leo
*** first mismatch at line 119
original line:      def provide(self, what):
generated line: def provide(self, what):
@auto did not import the file perfectly
first mismatched line: 119
u'def provide(self, what):\n'
inserting @ignore
Errors inhibited read
@auto /mnt/removable/bkup_proj/Mammals/mammaldb/mammalShow.py

In the code below line 119 is not the first "def provide(self, what):"
but the second, the one in class mainPages - I've included the preceding
class def because context seems to be important.

@color</t>
<t tx="ekr.20071115102156.237">This option has effect only when importing so-called non-strict languages,
for which leading whitespace is not terribly significant.

True: @auto warns about mismatches that occur solely in leading whitespace.</t>
<t tx="ekr.20071115102156.238"></t>
<t tx="ekr.20071115102156.256">Added sort-lines-ignoring-case, reverse-sort-lines and reverse-sort-lines-ignoring-case.</t>
<t tx="ekr.20071115102156.258">This provides further information when there are problems using aspell.</t>
<t tx="ekr.20071115102156.289">There is also an @bool trace_plugins setting.</t>
<t tx="ekr.20071115102156.301">And reorganized the unit tests by Leo source file.</t>
<t tx="ekr.20071115102156.302">http://sourceforge.net/forum/message.php?msg_id=4622384

vim.py does not open url nodes if the new setting: 

@bool vim_plugin_opens_url_nodes 

is False (or does not exist). </t>
<t tx="ekr.20071115102156.303">The code now remembers the relative file name as well as the full path name.
This allows Leo to find the icon when multiple machines are involved.</t>
<t tx="ekr.20071115102156.320">http://sourceforge.net/forum/message.php?msg_id=4614081
</t>
<t tx="ekr.20071115102156.321">http://tango.freedesktop.org/Tango_Icon_Library

These icons are now part of Leo's distribution.</t>
<t tx="ekr.20071115102156.5"></t>
<t tx="ekr.20071115102156.6">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3768494
By: ktenney

I'm using current CVS, W2k

1 open a Leo file (I'm using a batch file / console)

2 click Edit-&gt;Open   &lt;-- Having this dialog open is the problem.

3 return focus to the Leo window

4 click Help-&gt;Open leoDocs.leo

Zombie!

@color</t>
<t tx="ekr.20071115102156.78">@nocolor

In the following code:

extern  "C"
{
#include "stuff.h"
void    init(void);
#include "that.h"
}

produces the following in the log window:

Leo Log Window...
Leo 4.4.4 final, build  1.216 , November 2, 2007
Python 2.5.1, Tk 8.4.14, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

leoID = rshanley (in C:\)
global config dir: C:\Program Files\Leo\config
home dir: C:\
reading settings in C:\Program Files\Leo\config\leoSettings.leo
*** first mismatch at line 2
original line:  {
generated line:
import command did not import the file perfectly
first mismatched line: 2
u'\n'
input...
  0 extern  "C"
  1 {
  2 #include "stuff.h"
  3 void    init(void);
  4 #include "that.h"
  5 }
output...
  0 extern  "C"
  1
inserting @ignore
imported C:/test/aa.cc

@color</t>
<t tx="ekr.20071115102156.79">@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1865290&amp;forum_id=10226

@bool at_auto_warns_about_leading_whitespace

@color</t>
<t tx="ekr.20071115102156.81">http://sourceforge.net/forum/message.php?msg_id=4464649
By: terry_n_brown

An argument I'm always having with leo has to do with its conversion of file
paths to 'absolute' forms.

In the file browser I select '/home/tbrown/misc/foo.leo'.
Leo reinterprets this as '/media/hda2/usr1/home/tbrown/misc/foo.leo'

Then I switch machines, and while
'/home/tbrown/misc/foo.leo' would still be valid,
'/media/hda2/usr1/home/tbrown/misc/foo.leo' isn't - on the other machine it
would be '/media/hdb1/home/tbrown/misc/foo.leo'.

I end up with the two entries in recent files, having to identify the right one.

If the Tk dialog is returning '/home/tbrown/misc/foo.leo', which I assume it is
because that's what it's displaying, I wish leo would use and store that.
</t>
<t tx="ekr.20071115102421"></t>
<t tx="ekr.20071116062917"></t>
<t tx="ekr.20071116062917.1">##########################################
What's New in Leo 4.4.5
##########################################

Leo 4.4.5 fixes several long-delayed bug fixes and adds several new features.

The highlights of Leo 4.4.5:

- Fixes all known bugs.
- Adds 3 new sort-lines commands.
- Adds commands to insert and delete icons from headlines.
- Adds all the Tango 16x16 icons to Leo's icon library.
- Adds support for @rst-preformat nodes to the rst3 plugin.

.. .. contents::</t>
<t tx="ekr.20071116062917.18">::

    delete-all-icons
    delete-first-icon
    delete-last-icon
    delete-node-icons
    insert-icon
    reverse-sort-lines
    reverse-sort-lines-ignoring-case.
    sort-lines-ignoring-case
    toggle-collapse_nodes_during_finds
</t>
<t tx="ekr.20071116062917.2">.. Links used in this document.
.. _`leoBridge chapter`:    leoBridge.html
.. _`debugging with Leo`:   debuggers.html
</t>
<t tx="ekr.20071116062917.3">- Leo now supports all directives in headlines.

- Moved all unit tests to unitTest.leo and reorganized the unit tests by Leo source file.

- Installed small icon set from Tango library.

- The rst3 plugin now supports @rst-preformat nodes.</t>
<t tx="ekr.20071116063202">- Fixed hung (zombie) windows.
  http://sourceforge.net/forum/message.php?msg_id=3768494

- Fixed resurrected (vampire) nodes.
  http://sourceforge.net/forum/message.php?msg_id=3525277</t>
<t tx="ekr.20071116063649">- @bool at_auto_warns_about_leading_whitespace

  This option has effect only when importing so-called non-strict languages, for
  which leading whitespace is not terribly significant.

- @bool diagnose-aspell-installation

  This provides further information when there are problems using aspell.

- @bool warn_when_plugins_fail_to_load

  There is also an @bool trace_plugins setting.

- @bool vim_plugin_opens_url_nodes

  vim.py does not open url nodes if this setting is False.
</t>
<t tx="ekr.20071116081521"></t>
<t tx="ekr.20071116081521.1"></t>
<t tx="ekr.20071206093323.1"></t>
<t tx="ekr.20071206093323.112">http://sourceforge.net/forum/message.php?msg_id=4634600</t>
<t tx="ekr.20071206093323.2">pylint reported the following errors:

E1101:1877:atFile.readEndNode: Instance of 'atFile' has no 'correctedLines' member
E1101:2725:atFile.norefWrite:  Instance of 'atFile' has no 'putBuffered' member
</t>
<t tx="ekr.20071206093323.29">http://sourceforge.net/forum/message.php?msg_id=4646055
</t>
<t tx="ekr.20071206093323.3"></t>
<t tx="ekr.20071206093323.30">https://sourceforge.net/forum/message.php?msg_id=4643992
</t>
<t tx="ekr.20071206093323.31">The init base classes can now be inited in a more standard way.</t>
<t tx="ekr.20071206093323.32">http://sourceforge.net/forum/message.php?msg_id=4639426
</t>
<t tx="ekr.20071206093323.4">http://sourceforge.net/forum/message.php?msg_id=4632695</t>
<t tx="ekr.20071206093323.59">http://sourceforge.net/forum/message.php?msg_id=4639872
</t>
<t tx="ekr.20071206093323.72">Several problems still remain:

- Files that contain what look like section references.

- Underindented docstrings.</t>
<t tx="ekr.20071206093323.76"></t>
<t tx="ekr.20071206093323.77">http://sourceforge.net/forum/message.php?msg_id=4658901</t>
<t tx="ekr.20071206093323.80">http://sourceforge.net/forum/message.php?msg_id=4652514</t>
<t tx="ekr.20071206093323.87">http://sourceforge.net/forum/message.php?msg_id=4654762
</t>
<t tx="ekr.20071206093323.96">@nocolor

I have clones that traverse chapters.

Given the following Chapters:

&gt; Main
&gt; Big Picture
&gt; Smaller Chunk

I have in Main, my organization, with my group in it.  It's also cloned around
all the other views (really, everything starts in the Big Picture).

This is the layout of my clone:

1:  Chapter:Main &gt; me
2:  Chapter:Main &gt; MyOrg &gt; me
3:  Chapter:Big Picture &gt; CEO &gt; Some Big Honcho &gt; MyOrg &gt; me
4:  Chapter:Smaller Chunk &gt; Some Big Honcho &gt; MyOrg &gt; me

If I Go-To-Next-Clone  (ALT-N) from (1), focus will move to the selected node
in Chapter:Main, namely (2).

So here's the issue: 

Let each successive line below represent a starting focus, and the next line
the node that ALT-N selects.  If focus changes in the Outline pane (including
Chapter pane change) to match the Node, that case is marked with [f] - a successful
focus transition.

The issue are the lines w/o [f];  Here's a couple of test runs.

1: [f] (starting node / focus)
2: [f]
3:
4:
1: [f]

Next test:

3: [f]
1: [f]
1: [f]
4:
3:
1: [f]

Next test:

4: [f]
3:
1: [f]
2: [f]
4:
3:
1: [f]
2: [f]
... and so on...

In cases with NO [f], the outline pane seems moved to the "end", but no node
selected.

Not a show stopper, but a bug nonetheless.

@color
</t>
<t tx="ekr.20071206093346">Leo 4.4.5 beta 2                          December 7, 2007

Leo 4.4.5 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This beta 2 release fixes several recently reported bugs.  A final release
is due in about a week.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

Leo 4.4.5 fixes several long-delayed bug fixes and adds several new features.

The highlights of Leo 4.4.5:
----------------------------

- Fixes all known bugs.
- Leo now recognizes directives in headlines.
- Adds 3 new sort-lines commands.
- Adds commands to insert and delete icons from headlines.
- Adds all the Tango 16x16 icons to Leo's icon library.
- Adds support for @rst-preformat nodes to the rst3 plugin.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20071210094621">This following is adapted from Terry Brown's entry in Leo's wiki.

You can not just run leoBridge from Leo, because the leoBridge module is design
to run a separate copy of Leo. However, it is possible to run leoBridge from a
separate process. That turned out to be more, um, interesting than anticipated,
so I'm recording the results here.

The idea is that script A running in Leo (i.e. in a regular GUI Leo session)
calls script B through subprocess.Popen(), script B uses LeoBridge to do
something (parse unloaded Leo files), and returns the result to script A.
Passing the result back via the clipboard seemed like a possibility, but
XWindows / tcl/tk clipboard madness being what it is, that didn't seem to work.

First trick, calling script B from script A::

    import subprocess
    p = subprocess.Popen(('python',
        path_to_script_B,
        parameter_for_script_B,),
        stdout=subprocess.PIPE,
        env={'PYTHONPATH': g.app.loadDir,'USER': g.app.leoID},
    )
    p.wait()

Setting PYTHONPATH in the environment seemed like the easiest way to let
script B find leoBridge.py (which it needs to import).  But by setting the
env parameter you limit script B's environment to be **only** PYTHONPATH,
which causes leoBridge to fail because, in unix at least, it depends
on USER in the environment.  So you need to pass that through too.

Now, because passing stuff back on the clipboard seems unreliable, at least
in XWindows, script B passes results back to script A via stdout (print),
but there's some Leo initialization chatter you want to avoid.  So put a
sentinel, 'START_CLIPBOARD', in the output, and collect it like this::

    response = p.stdout.readlines()
    while response and 'START_CLIPBOARD' not in response[0]:
        del response[0]
    del response[0]  # delete the sentinel as well
    response = ''.join(response)

This is the basic mechanism.  What I *actually* wanted to do was have script
B generate a branch of nodes and pass that back to script A for insertion in
the tree script A is running in.  That's relatively easy if you use::

    c.setCurrentPosition(pos_of_branch_to_return)
    c.copyOutline()
    print '&lt;!-- START_CLIPBOARD --&gt;'
    print g.app.gui.getTextFromClipboard()
    print '&lt;!-- END_CLIPBOARD --&gt;'

at the end of script B, and back in script A, after you've rebuilt
`response` as shown above, just::

    g.app.gui.replaceClipboardWith(response)
    c.pasteOutline()</t>
<t tx="ekr.20071211083251">Leo 4.4.5 final                               December 11, 2007

Leo 4.4.5 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.5 fixes several long-delayed bug fixes and adds several new features.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.5:
----------------------------

- Fixes all known bugs.
- Leo now recognizes directives in headlines.
- Adds 3 new sort-lines commands.
- Adds commands to insert and delete icons from headlines.
- Adds all the Tango 16x16 icons to Leo's icon library.
- Adds support for @rst-preformat nodes to the rst3 plugin.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20071217092203.1"></t>
<t tx="ekr.20071217092203.127">The last char was not colored in the following doc part:
    
@

&lt;tag /&gt;</t>
<t tx="ekr.20071217092203.128">http://sourceforge.net/forum/message.php?msg_id=4676037
</t>
<t tx="ekr.20071217092203.130">This prevents over-long traces.</t>
<t tx="ekr.20071217092203.131"></t>
<t tx="ekr.20071217092203.136"></t>
<t tx="ekr.20071217092203.137"></t>
<t tx="ekr.20071217092203.138">The patch attached against leoConfig.py (current CVS) adds a machine
specific config file to the config files Leo loads.

I synchronize files between multiple (3) machines. This means I can't
use different myLeoSettings files on each.

Tk fonts are screen dpi sensitive.  But (in Linux at least)
Tk's attempts to switch a font you picked to something equivalent at a
different dpi always result in a font that looks terrible.

So every time I switch machines I edit ~/myLeoSettings.leo to move the
font defs I picked for the current machine to the bottom of the body
text for the appropriate settings node, and then restart Leo.

This patch means I don't have to do that any more.  I'm sure there are
other uses for it.  Python doesn't seem to have a generic machine name
finding function, hence the sequence of alternatives.</t>
<t tx="ekr.20071217092203.145">The version of plugins_menu.py at http://leo.zwiki.org/Plumloco separates out
the gui dependent dialogs (the menus are already gui independent) and made them
general purpose dialogs available to all plugins.

I have also slightly enhanced the dialogs to provide user defined buttons. </t>
<t tx="ekr.20071217092203.146"></t>
<t tx="ekr.20071217092203.147">The finds the next cloned node, regardless of whether the presently selected node is a clone or not.</t>
<t tx="ekr.20071217092203.149">The command toggles whether moving a node left collapses the outline.</t>
<t tx="ekr.20071217092203.152"></t>
<t tx="ekr.20071217092203.154">Use @data import_xml_tags setting to specify the xml tags that act as organizers.</t>
<t tx="ekr.20071217092203.161">This fixes a focus problem.</t>
<t tx="ekr.20071217092203.163">Javascript regexps that look like section references cause problems, but that can not be helped.</t>
<t tx="ekr.20071217092203.2">http://sourceforge.net/forum/message.php?msg_id=4668960

It seems in external files you can delete some text and save, causing the derived
file to be written and all dirty flags cleared.  But then undo makes the text
come back, as expected, but save only saves the outline, because the dirty flag
wasn't set on the node in which the text was restored by undo.</t>
<t tx="ekr.20071217092203.30"></t>
<t tx="ekr.20071217092203.31">Added k.overrideCommand.</t>
<t tx="ekr.20071217092203.45">http://sourceforge.net/forum/message.php?msg_id=4671771
</t>
<t tx="ekr.20071217092203.51">http://sourceforge.net/forum/message.php?msg_id=4667105</t>
<t tx="ekr.20071217092203.52">The command now clears all .leoRecentFiles.txt files and write a message.</t>
<t tx="ekr.20071217092203.64">This was a very long-standing bug: the most annoying in all of Leo.</t>
<t tx="ekr.20071217092250">Leo 4.4.6 beta 1                           December 17, 2007

Leo 4.4.6 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.6 fixes several recently reported bugs, all minor.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.6:
----------------------------
- Fixes all known bugs.
- Added @auto importers for javascript and xml files.
- Added find-next-clone and toggle-sparse-move commands.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20071217093444"></t>
<t tx="ekr.20071217093444.1">##########################################
What's New in Leo 4.4.6
##########################################

Leo 4.4.6 fixes all known bugs and adds a few new features.

.. .. contents::</t>
<t tx="ekr.20071217093444.2">.. Links used in this document.
.. _`leoBridge chapter`:    leoBridge.html
.. _`debugging with Leo`:   debuggers.html
</t>
<t tx="ekr.20071217093444.5">::

    find-next-clone
    toggle-sparse-move

Replaced the delete-all-icons command with a script in scripts.leo.  This command was too dangerous.</t>
<t tx="ekr.20071217093444.6">- Added support for @data nodes in settings files.

- The @data import_xml_tags setting specifies the xml tags that act as organizers.
  This settings is used by @auto when importing xml files.</t>
<t tx="ekr.20080106114203.1">http://sourceforge.net/forum/message.php?msg_id=4682598
</t>
<t tx="ekr.20080106114203.2">http://sourceforge.net/forum/message.php?msg_id=4681175

- There was a horrendous bug in the match_seq_regexp matcher which could cause the colorizer to loop.
- There was another horrendous bug in match_regexp_helper that cause spurious matches.
- Added some more defensive code to have the colorizer recover more gracefully in this case. 
- The jedit2py script was not associating regexp rules whose regex starts with
  '\' with the proper character. The proper character is the hash_char
  character, not the '\' character. As a result, regexp's that start with '\'
  never got matched.

The following colorizers are affected by the change:

modes/apacheconf.py
modes/erlang.py
modes/moin.py
modes/perl.py
modes/php.py
modes/pl1.py
modes/rest.py
modes/shell.py
modes/shellscript.py</t>
<t tx="ekr.20080106114203.3"></t>
<t tx="ekr.20080106114203.4">http://sourceforge.net/forum/message.php?msg_id=4687706
</t>
<t tx="ekr.20080106114225">Leo 4.4.6 beta 2                           January 15, 2008

Leo 4.4.6 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.6 fixes several recently reported bugs, all minor.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.6:
----------------------------
- Fixes all known bugs.
- Added @auto importers for javascript and xml files.
- Added find-next-clone and toggle-sparse-move commands.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080106114331"></t>
<t tx="ekr.20080106114648"></t>
<t tx="ekr.20080109074102">You can add an icon to the presently selected node with
c.editCommands.insertIconFromFile(path). path is an absolute path or a path
relative to the leo/Icons folder. A relative path is recommended if you plan to
use the icons on machines with different directory structures.

For example::

    path = 'rt_arrow_disabled.gif' 
    c.editCommands.insertIconFromFile(path) 

Scripts can delete icons from the presently selected node using the following methods::

    c.editCommands.deleteFirstIcon() 
    c.editCommands.deleteLastIcon() 
    c.editCommands.deleteNodeIcons() 
</t>
<t tx="ekr.20080115093848.18">See http://webpages.charter.net/edreamleo/scripting.html#inserting-and-deleting-icons</t>
<t tx="ekr.20080115093848.19">http://sourceforge.net/forum/message.php?msg_id=4712329
</t>
<t tx="ekr.20080115093848.23">http://sourceforge.net/forum/message.php?msg_id=4714779
</t>
<t tx="ekr.20080116071239">- Added support for @auto xml and @auto javascript.
  Use @data import_xml_tags setting to specify the xml tags that act as organizers.
  Javascript regexps that look like section references cause problems, but that can not be helped.
</t>
<t tx="ekr.20080126090039">Leo 4.4.6 final                           January 26, 2008

Leo 4.4.6 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.6 fixes several recently reported bugs, all minor.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.6:
----------------------------
- Fixes all known bugs.
- Added @auto importers for javascript and xml files.
- Added find-next-clone and toggle-sparse-move commands.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080203101507">@language rest</t>
<t tx="ekr.20080203101507.1">############################################################
Chapter 21: IPython and Leo
############################################################

.. _`run Leo in a console window`: install.html#running-leo-from-a-console-window

Leo's ipython plugin provides two-way communication (a bridge) between Leo and
IPython: you can run Leo scripts from IPython, and IPython scripts from Leo. To
use this plugin, you must `run Leo in a console window`_. When this plugin is
enabled, Leo's start-ipython command starts IPython_ in this console.

Remarkably, Leo and IPython run simultaneously in the same process,
yet their separate event loops do not interfere with each other.
Scripts run from IPython *immediately* change Leo,
*exactly* as if the script were run from Leo.
Conversely, scripts run from Leo *immediately* affect the IPython interpreter.
As a result, Leo might be considered an `IPython Notebook`_.

The bridge between Leo and IPython is powerful because it is simple. Indeed,

1. **You can run any IPython script from Leo**.
On the Leo side, a single statement::

    ip = IPython.ipapi.get()

assigns ip to IPython's _ip variable. The ip variable allows scripts running in
Leo to do *anything* that an IPython script can do.

2. **You can run any Leo script from IPython**. 
The ipython plugin injects a single object named '_leo' into the IPython namespace. 
IPython scripts access Leo's c and g objects as
follows::

    c,g = _leo.c, _leo.g

The c and g variables allow scripts running in IPython to do *anything* that a
Leo script can do. 

This is basically everything that is required for IPython-Leo interaction.
However, you probably wont use 'c' and 'g' directly, but use a series of
convenience wrappers described in this document that make interactive work
painless and powerful.

.. .. contents::

</t>
<t tx="ekr.20080203101507.2">.. Links
.. _discussions:            http://sourceforge.net/forum/forum.php?thread_id=1911662&amp;forum_id=10226
.. _ipython:                http://ipython.scipy.org/
.. _IPython:                http://ipython.scipy.org/
.. _`IPython Notebook`:     http://projects.scipy.org/ipython/ipython/wiki/NoteBook
.. _extensionAPI:           http://ipython.scipy.org/moin/IpythonExtensionApi
.. _`The Ipython Extension API`: extensionAPI_
.. _`Chapter 7\: Scripting Leo with Python`:    scripting.html

.. _`run Leo in a console window`:  install.html#running-leo-from-a-console-window
.. _`console window`:               install.html#running-leo-from-a-console-window
</t>
<t tx="ekr.20080204100523">This plugin creates an instance of the **ipythonController** class for each Leo
window. The ipythonController objects manage a singleton instance of IPython's
IPShellEmbed class. See http://ipython.scipy.org/doc/manual/node9.html. Creating
this singleton instance starts IPython running in the console from which Leo was
run. As mentioned in the introduction, Leo and IPython appear to run
simultaneously. Their event loops do not interfere with each other.

The term **startup time** refers to the time that the singleton IPython instance is created.

Initializing Leo from IPython is easier than initializing IPython from Leo.
Indeed, the start-ipython command typically blocks and never returns, so it is not possible
to schedule a Leo script to be run after the start-ipython command returns.
Instead, it will typically be more convenient to use IPython's normal facilities to
schedule a script that initializes Leo when IPython starts.

The start-ipython command starts IPython running in the console and injects leox, a
**Leo Interface Object** into IPython's user namespace.
Using the leox object, IPython scripts can gain access to Leo's c and g variables::

    c,g = leox.c,leox.g

Thus, IPython scripts can do *anything* that can be done in Leo.
See `Scripting Leo from IPython`_ for full details.

Conversely, Leo scripts can gain access to IPython's _ip variable::

    ip = c.ipythonController.ip

Thus, Leo scripts can do *anything* that can be done in IPython.
See `Scripting IPython from Leo`_ for full details.</t>
<t tx="ekr.20080204100523.1">This plugin creates the following Leo commands commands:

- The start-ipython command starts the singleton IPython instance running in the
  console and injects a Leo Interface Object into IPython's user namespace.
  **Run the start-ipython command before running the other commands**.


  **Important**: The start-ipython command blocks. That is, the command does not
  finish execution until IPython exits. In a typical workflow, IPython exits
  after Leo does, so the the start-ipython command *never* completes.

  Remarkably, this does not affect Leo's main loop: Leo itself does not block.
  However, because the start-ipython command blocks, it is not possible for the
  command to do any follow up initialization of IPython. In practice, this does
  not matter, because IPython provides several ways of executing scripts on
  startup. In short, it is often more convenient to initialize Leo from IPython
  than to initialize IPython from Leo.

- The push-to-ipython command pushes data to IPython.
  By default, it executes the body text of the presently
  selected node in IPython.
</t>
<t tx="ekr.20080204100523.2">Just as c and g provide full access to all aspects of Leo,
IPython's _ip var (and _ip.IP) provide full access of all of IPython's internals.
See extensionAPI_ for details.
The following script sets ip to IPython's _ip var::

    ip = c.ipythonController.ip # set ip to IPython's _ip var.

With ip defined as above, IPython scripts **running in Leo**
can do anything that a script running in IPython can do.

Leo scripts can simulate this plugins's minibuffer commands as follows.

To simulate the start-ipython command::

    x = c.ipythonController
    if x and not x.started(): x.startIPython()

To simulate the push-to-ipython command::

    x = c.ipythonController
    if x and x.started(): x.pushToIPython()

To run a given script in IPython::

    x = c.ipythonController
    if x and x.started(): x.pushToIPython(script=script)
</t>
<t tx="ekr.20080204100523.3"></t>
<t tx="ekr.20080205080801">The start-ipython command injects the leox object into IPython's
user namespace.
The c and g ivars of the leox object are
the leoGlobals module and
the commander of the Leo outline that created the IPython shell, respectively.
Thus scripts **running in IPython** can do *anything* a Leo script can do.
For, such scripts can insert and delete nodes in Leo outlines.
The changes will become visible as soon as the script (running in IPython)
redraws the screen.

See `Chapter 7\: Scripting Leo with Python`_ for full details about how to script
Leo.  The following are merely examples about what can be done from IPython.
All these examples have been tested.

1. g.app.windowList is a list of all open Leo frames, so an IPython script can
   get a list of all commanders as follows::

    c,g = leox.c, leox.g
    commanders = [f.c for f in g.app.windowList]

2. IPython scripts can use the c.config object to get Leo settings.
   Suppose the body text of an @data
   ipython-bridge-startup-script setting contains a script to be executed when
   ipython starts up. An Ipython script can get that startup script as follows::

    c = leox.c
    startupScript = c.config.getData('ipython-bridge-startup-script')

3. Suppose the body text of an @data ipython-bridge-auto-open setting contains a
   list of .leo files to be automatically opened on startup. The following
   IPython script opens those files::

    c,g = leox.c, leox.g
    files = c.config.getData('ipython-bridge-auto-open-leo-files')
        # getData strips lines starting with '#'.
    for z in files:
        fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,z))
        g.openWithFileName(fileName, old_c=c)
</t>
<t tx="ekr.20080210101336">This plugin would not have been possible without the help of Ville M. Vainio.
</t>
<t tx="ekr.20080212221711.1"></t>
<t tx="ekr.20080212221711.15">http://groups.google.com/group/leo-editor/browse_thread/thread/4fa4709969fc04d</t>
<t tx="ekr.20080212221711.2"></t>
<t tx="ekr.20080212221711.26">When reading an @auto tree, createOutline now does the following:
    
1. When importing Python files, createOutline uses the encoding implied by
Python's # -*- coding line. This line must be the first line of the imported file.

2. Otherwise, createOutline scans the @auto node and its ancestors for Leo's @encoding directive.

3. If no such @encoding directive is found, createOutline uses the encoding specified by the setting: @string default_at_auto_file_encoding = utf-8

4. If this setting does not exist, the utf-8 encoding is used.
</t>
<t tx="ekr.20080212221711.32"></t>
<t tx="ekr.20080212221711.33"></t>
<t tx="ekr.20080212221711.34"></t>
<t tx="ekr.20080212221711.35"></t>
<t tx="ekr.20080212221711.4"></t>
<t tx="ekr.20080212221711.47">If the @bool open_with_save_on_update setting is True,
Leo will automatically save the outline whenever an external editor
changes the outline.</t>
<t tx="ekr.20080212221734">Leo 4.4.7 beta 1                           February 12, 2008

Leo 4.4.7 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features the ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://webpages.charter.net/edreamleo/IPythonBridge.html

Leo's main discussion is now at: http://groups.google.com/group/leo-editor

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.7:
----------------------------
- The ipython plugin creates a simple, powerful, effective bridge between IPython and Leo.
  See http://webpages.charter.net/edreamleo/IPythonBridge.html
- Improved handling of unicode encodings in @auto files.
- All import commands now support @path directives in ancestor nodes.
- Fixed several minor bugs.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080213094948.1">There appear to be problems with Python's subprocess module on Ubuntu.</t>
<t tx="ekr.20080213094948.4">The version of PIL that ships with Ubuntu (and presumably Debian and maybe some
other distributions) no longer includes the ImageTk module. ImageTk is now
located in the python- imaging-tk package.</t>
<t tx="ekr.20080218153931">Leo 4.4.7 final                           February 18, 2008

Leo 4.4.7 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://webpages.charter.net/edreamleo/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.7:
----------------------------
- The ipython plugin creates a simple, powerful, effective bridge between IPython and Leo.
  See http://webpages.charter.net/edreamleo/IPythonBridge.html
- Improved handling of unicode encodings in @auto files.
- All import commands now support @path directives in ancestor nodes.
- Fixed several minor bugs.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080218153931.1"></t>
<t tx="ekr.20080218153931.10"></t>
<t tx="ekr.20080218153931.11">If the @bool open_with_save_on_update setting is True,
Leo will automatically save the outline whenever an external editor
changes the outline.</t>
<t tx="ekr.20080218153931.12">When reading an @auto tree, createOutline now does the following:
    
1. When importing Python files, createOutline uses the encoding implied by
Python's # -*- coding line. This line must be the first line of the imported file.

2. Otherwise, createOutline scans the @auto node and its ancestors for Leo's @encoding directive.

3. If no such @encoding directive is found, createOutline uses the encoding specified by the setting: @string default_at_auto_file_encoding = utf-8

4. If this setting does not exist, the utf-8 encoding is used.
</t>
<t tx="ekr.20080218153931.2"></t>
<t tx="ekr.20080218153931.3"></t>
<t tx="ekr.20080218153931.4">http://groups.google.com/group/leo-editor/browse_thread/thread/4fa4709969fc04d</t>
<t tx="ekr.20080218153931.5"></t>
<t tx="ekr.20080218153931.6">There appear to be problems with Python's subprocess module on Ubuntu.</t>
<t tx="ekr.20080218153931.7">The version of PIL that ships with Ubuntu (and presumably Debian and maybe some
other distributions) no longer includes the ImageTk module. ImageTk is now
located in the python- imaging-tk package.</t>
<t tx="ekr.20080218153931.8"></t>
<t tx="ekr.20080218153931.9"></t>
<t tx="ekr.20080218154129"></t>
<t tx="ekr.20080218154129.1"></t>
<t tx="ekr.20080301071818"></t>
<t tx="ekr.20080304112802.1">http://mail.google.com/mail/#inbox/1184b70ea10f5aa3

Leo now contains minimal support for arguments to minibuffer commands.

- k.simulateCommand now puts arguments following the command name in k.givenArgs.
  Whitespace separates arguments.

- k.simulateCommand knows nothing about what the arguments mean. That is up to
  the individual commands.

- At present, only the following minibuffer commands now support k.givenArgs:
  open-outline, open-outline-by-name, save-file, save-file-as,
  save-file-as-unzipped and save-file-as-zipped.

  These commands use ''.join(k.givenArgs) to get the file name,
  which may cause problems if the file name contains whitespace.

- At present, the repeat-complex-command command does not support arguments.</t>
<t tx="ekr.20080304112802.25">@language rest
@color</t>
<t tx="ekr.20080304112808">Leo 4.4.8 beta 1                           March 5, 2008

Leo 4.4.8 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://webpages.charter.net/edreamleo/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.8:
----------------------------
- Leo's source code is now managed by bzr.
  See the Bzr link below.
- Leo's discussion is now hosted by Google Groups:
  See the Forum link below.
- The first, third, fifth etc. arguments to g.es and g.es_print
  can now be translated using Python's gettext.gettext function.
- Completed ILeo: a bridge between IPython and Leo.
  See http://webpages.charter.net/edreamleo/IPythonBridge.html
- Added support for arguments to minibuffer commands.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080306071848">&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458&amp;amp;package_id=29106"&gt;
    Download Leo[4.7.1 final]&lt;/a&gt;</t>
<t tx="ekr.20080310093038.4">.. _gettext: http://docs.python.org/lib/module-gettext.html

It is easy to translate Leo's menu strings: simply create an @menus tree in
leoSettings.leo or myLeoSettings.leo that contains the translated menu names.

**New in Leo 4.4.8**:
Leo now contains support for translating messages sent to Leo's log:

- Rather than using an '_' function to denote strings to be translated, Leo's
  g.es and g.es_print functions translate "odd" (first, third, fifth) arguments,
  leaving "even" arguments untranslated. Keyword arguments, color, newline, etc.
  are never translated.

- All calls to g.es and g.es_print in Leo's core follow this convention.

- g.translateString does the actual translation using Python's `gettext`_ module.

- You can use the script in the node "@button print g.es stats" in scripts.leo
  to create catalogs of all scripts that need to be translated. Such catalogs
  are used by Python's gettext module. (This script was also used to check that
  the proper arguments to g.es and g.es_print were translated.)
</t>
<t tx="ekr.20080311060457.1">Leo 4.4.8 beta 2                           March 14, 2008

Leo 4.4.8 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://webpages.charter.net/edreamleo/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.8:
----------------------------
- Leo's source code is now managed by bzr.
  See the Bzr link below.
- Leo's discussion is now hosted by Google Groups:
  See the Forum link below.
- The first, third, fifth etc. arguments to g.es and g.es_print
  can now be translated using Python's gettext.gettext function.
- Completed ILeo: a bridge between IPython and Leo.
  See http://webpages.charter.net/edreamleo/IPythonBridge.html
- Added support for arguments to minibuffer commands.
- @menu trees can now refer to commands created by
  @command and @button nodes
- Added support for common @commands nodes in settings files.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080311060457.125"></t>
<t tx="ekr.20080311060457.128"></t>
<t tx="ekr.20080311060457.188">http://sourceforge.net/forum/message.php?msg_id=4677335</t>
<t tx="ekr.20080311060457.198">This allows @menu items to refer to commands created by @button.
</t>
<t tx="ekr.20080311060457.2"></t>
<t tx="ekr.20080311060457.210"></t>
<t tx="ekr.20080311060457.211">http://mail.google.com/mail/#inbox/1184b70ea10f5aa3

Leo now contains minimal support for arguments to minibuffer commands.

- k.simulateCommand now puts arguments following the command name in k.givenArgs.
  Whitespace separates arguments.

- k.simulateCommand knows nothing about what the arguments mean. That is up to
  the individual commands.

- At present, only the following minibuffer commands now support k.givenArgs:
  open-outline, open-outline-by-name, save-file, save-file-as,
  save-file-as-unzipped and save-file-as-zipped.

  These commands use ''.join(k.givenArgs) to get the file name,
  which may cause problems if the file name contains whitespace.

- At present, the repeat-complex-command command does not support arguments.</t>
<t tx="ekr.20080311060457.212">@language rest
@color</t>
<t tx="ekr.20080311060457.213">.. _gettext: http://docs.python.org/lib/module-gettext.html

It is easy to translate Leo's menu strings: simply create an @menus tree in
leoSettings.leo or myLeoSettings.leo that contains the translated menu names.

**New in Leo 4.4.8**:
Leo now contains support for translating messages sent to Leo's log:

- Rather than using an '_' function to denote strings to be translated, Leo's
  g.es and g.es_print functions translate "odd" (first, third, fifth) arguments,
  leaving "even" arguments untranslated. Keyword arguments, color, newline, etc.
  are never translated.

- All calls to g.es and g.es_print in Leo's core follow this convention.

- g.translateString does the actual translation using Python's `gettext`_ module.

- You can use the script in the node "@button print g.es stats" in scripts.leo
  to create catalogs of all scripts that need to be translated. Such catalogs
  are used by Python's gettext module. (This script was also used to check that
  the proper arguments to g.es and g.es_print were translated.)
</t>
<t tx="ekr.20080311060457.214"></t>
<t tx="ekr.20080311060457.215"></t>
<t tx="ekr.20080311060457.216"></t>
<t tx="ekr.20080311060457.28"></t>
<t tx="ekr.20080311060457.3">@nocolor

Eureka! I have just discovered an elegant solution to this problem!

The Aha is this:  we can create a "base" timestamp just *once*, when
the commander (i.e. the nodeIndices class) is created.  Thereafter,
code that writes gnx's simply calls nodeIndices.getIndex if the node
doesn't already have an index (or if indices are being reassigned in a
copied tree).

In other words, there is no need to be picky about timestamps, the
base timestamp will do, so there is no need to assign indices before
writing nodes!

I didn't see this before because computing timestamps is quite time
consuming.  In fact, we can't do so "on the fly".  That being so, the
old code computed the "new" timestamp once in assignFileIndices, which
lead me away from getting gnx's as needed.  But if there is only *one*
timestamp everything becomes easy.  There is no need to "batch" the
computation of gnx's.  In other words, timestamps don't have to be up-
to-the-second accurate.  They simply guarantee that two nodes (in a
particular outline) created by the *same* person can't collide.

This is the way it is written in "The Book". All calls to
assignFileIndices disappear!  All the code I wrote this morning that
remembers whether indices have been assigned disappears.  I'll keep a
do-nothing assignFileIndices around for compatibility with old
scripts.

This is *so* important.  It eliminates forever a source of serious
file write problems.  Furthermore, nodeIndices.getIndex becomes
substantially simpler. Even though the code was short, it implied some
very tricky assumptions.  Every time I read it I had to recreate why
it worked.  Those mental gymnastics should disappear.

A great day for Leo. 

@color</t>
<t tx="ekr.20080311060457.38"># This should have been done long ago.</t>
<t tx="ekr.20080314081157.1">- Added show-marks-dialog and show-recent-sections-dialog commands.
- Select an item initially.
- Added bindings for up and down arrows.</t>
<t tx="ekr.20080314081157.121">#######################################
What's New in Leo 4.4.7 and Leo 4.4.8
#######################################

.. .. contents::</t>
<t tx="ekr.20080314081157.122">.. Links used in this document.
.. _`leoBridge chapter`:    leoBridge.html
.. _`debugging with Leo`:   debuggers.html
.. _gettext: http://docs.python.org/lib/module-gettext.html
</t>
<t tx="ekr.20080314081157.124">- Better support for unicode in \@auto trees.

- All import commands now honor \@path

- Leo now supports arguments to minibuffer commands.

- Leo can now translate messages sent to Leo's log. Rather than using an '_'
  function to denote strings to be translated, Leo's g.es and g.es_print
  functions translate "odd" (first, third, fifth) arguments, leaving "even"
  arguments untranslated. Keyword arguments, color, newline, etc. are never
  translated. g.translateString does the actual translation using Python's
  `gettext`_ module.

- \@menu items may not refer to commands created by @button and @command nodes.</t>
<t tx="ekr.20080314081157.125">- Added support for @commands trees in leoSettings files.

- Added support for @bool open_with_save_on_update setting. If True, Leo will
  automatically save the outline whenever an external editor changes the
  outline.
</t>
<t tx="ekr.20080314081157.127">@language rest</t>
<t tx="ekr.20080314081157.128">- The ipython plugin creates a simple, powerful, effective bridge between IPython and Leo.
  See http://webpages.charter.net/edreamleo/IPythonBridge.html

- Improved marks/recent buttons plugin.</t>
<t tx="ekr.20080314081157.2"></t>
<t tx="ekr.20080315115427.568">Leo 4.4.1 through 4.4.8 contained many incremental improvements,
as documented in Chapters 15 through 21 of this Users Guide.
</t>
<t tx="ekr.20080315115427.569">- Supported multiple editors in body pane.
- Added the jEdit_colorizer plugin. See `Chapter 15: Controlling Syntax Coloring`_.
- Added the slideshow plugin.</t>
<t tx="ekr.20080315115427.570">- Added support for myLeoSettings.leo
- The 'Big Reorg' made Leo's vnodes and tnode classes independent of the rest of Leo.
- Added support for ZODB. See `Chapter 17: Using ZODB with Leo`_.
- Added leoPymacs module. See `Chapter 18: Leo and Emacs`_.
- Added the leoOPML, leo_to_rtf and leo_to_html plugins.
- Added outline navigation: typing a letter selects the next outline node that starts with that letter.
- Added autocontract during finds.
- Added new commands and options to make Leo usable without a mouse.
- Added an option sax parser for reading .leo files.</t>
<t tx="ekr.20080315115427.571">- Added support for chapters in Leo's core.
- Added support for zipped .leo files.
- Added the leoBridge module. See `Chapter 19: Embedding Leo with the leoBridge Module`_.
- Removed all gui-dependent code from Leo's core.
- Added better support for the winpdb debugger.
- Added support for @enabled-plugins and @open-with nodes in settings files.
</t>
<t tx="ekr.20080315115427.572">- The Great Graph Aha: Outlines don't have to *be* graphs to *represent* graphs.
  This Aha meant that there is no need for a separate 'graph world'.  
- Added support for @menus and @buttons trees in settings files.
- Added perfect import of foreign files with @auto nodes.
- Added new commands for resolving cvs conflicts.
- Replaced the jEdit_colorizer plugin with the threading_colorizer plugin.
- Made Leo compatible with jython.
- Added better support for icons in headlines.
</t>
<t tx="ekr.20080315115427.573">- Leo now recognizes directives in headlines.
- Added support for @rst-preformat nodes to the rst3 plugin.
</t>
<t tx="ekr.20080315115427.574">- Added the ILeo, the IPython bridge. See `Chapter 21: ILeo - the IPython bridge`_.
- Added support for translating messages to Leo's log.
</t>
<t tx="ekr.20080328074117.12">http://groups.google.com/group/leo-editor/browse_thread/thread/62fe73901d14f6c3</t>
<t tx="ekr.20080328074117.135">The new setting is @string target_language, not @language default_target_language.</t>
<t tx="ekr.20080328074117.2"></t>
<t tx="ekr.20080328074117.215">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/6a5087a59d6d23

- Changed menu1 to menu2 in several plugins.
- Changed menu2 to menu-update.
- Moved after-create-leo-frame to after menu2.</t>
<t tx="ekr.20080328074117.216"></t>
<t tx="ekr.20080328074117.217">This hugely speeds up spelling when there are lots of misspelled words.</t>
<t tx="ekr.20080328074117.220"></t>
<t tx="ekr.20080328074117.262">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/62fe73901d14f6c3

And, while you're looking at the editor code :-) - in linux when you paste in
text to a body editor with a middle mouse button click, it's not stored unless
you follow that with a key stroke or some other action in the body editor. If
you instead middle button paste to the editor and then click on another node in
the tree, the text's forgotten.

To do--&gt;@thin ../doc/leoToDoLater.txt--&gt;Can't or won't--&gt;Known Bugs: can't be fixed or can wait--&gt;Bug: can't be fixed--&gt;Cut/paste bug on X windows (waiting for help)

@color</t>
<t tx="ekr.20080328074117.297"></t>
<t tx="ekr.20080328074117.3"></t>
<t tx="ekr.20080328074117.30">http://groups.google.com/group/leo-editor/browse_thread/thread/f802b083dee96312
</t>
<t tx="ekr.20080328074117.340">Leo 4.4.8 beta 3                           March 28, 2008

Leo 4.4.8 beta 3 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://webpages.charter.net/edreamleo/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.8:
----------------------------
- Leo's source code is now managed by bzr: see link below.
- Leo's discussion is now hosted by Google Groups: see link below.
- Arguments to g.es and g.es_print can be translated using gettext.
- Completed ILeo: a bridge between IPython and Leo.
  See http://webpages.charter.net/edreamleo/IPythonBridge.html
- Minibuffer commands may have arguments.
- @menu trees can now refer to commands created by
  @command and @button nodes.
- Added support for common @commands nodes in settings files.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080328074117.4">This fixes a bug that can corrupt .leo files.</t>
<t tx="ekr.20080328074117.76">http://mail.google.com/mail/#inbox/11899019a43f74ca

When you have two editors open on the same node most actions show up in both
editors, however, if you do an undo the change only show up in the selected
editor. (The change shows up in the other editor when you select it).
</t>
<t tx="ekr.20080328074117.77">http://groups.google.com/group/leo-editor/browse_thread/thread/71822f48720e71bc/6e0fd1c72fa39817#6e0fd1c72fa39817
</t>
<t tx="ekr.20080403065258.10">Leo 4.4.8 rc1                        April 3, 2008

Leo 4.4.8 rc1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://webpages.charter.net/edreamleo/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.8:
----------------------------
- Leo's source code is now managed by bzr: see link below.
- Leo's discussion is now hosted by Google Groups: see link below.
- Arguments to g.es and g.es_print can be translated using gettext.
- Completed ILeo: a bridge between IPython and Leo.
  See http://webpages.charter.net/edreamleo/IPythonBridge.html
- Minibuffer commands may have arguments.
- @menu trees can now refer to commands created by
  @command and @button nodes.
- Added support for common @commands nodes in settings files.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080403065258.6">http://groups.google.com/group/leo-editor/browse_thread/thread/ed5d82429e1ec821

The following sequence of commands caused problems:

add-editor
add-editor
delete-editor
delete-editor
add-editor
</t>
<t tx="ekr.20080405074410.38"></t>
<t tx="ekr.20080405074410.4">Leo 4.4.8 final                        April 6, 2008

Leo 4.4.8 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://webpages.charter.net/edreamleo/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4.8:
----------------------------
- Leo's source code is now managed by bzr: see link below.
- Leo's discussion is now hosted by Google Groups: see link below.
- Arguments to g.es and g.es_print can be translated using gettext.
- Completed ILeo: a bridge between IPython and Leo.
  See http://webpages.charter.net/edreamleo/IPythonBridge.html
- Minibuffer commands may have arguments.
- @menu trees can now refer to commands created by
  @command and @button nodes.
- Added support for common @commands nodes in settings files.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080405074410.7"></t>
<t tx="ekr.20080405074410.9"></t>
<t tx="ekr.20080408060320.784">Python's HOME environment variable specifies Leo's HOME directory.
See http://docs.python.org/lib/os-procinfo.html for details.

Leo uses os.expanduser('~') to determine the HOME directory if no HOME environment variable exists.

Leo puts several files in your HOME/.leo directory:
.leoID.txt, .leoRecentFiles.txt, and myLeoSettings.leo.

</t>
<t tx="ekr.20080411111008.1">Leo ignores any subtree of an @settings tree whose headline starts with @ignore.

You can use several other kinds of nodes to cause Leo to ignore parts of  an @settings tree:

- @if *expression*

  A node whose headline starts with @if *expression* acts like an organizer node if the expression evaluates to True,    
  otherwise acts like an @ignore node.
  If the expression is empty the body text should contain a script that will be evaluated (in an empty context).

- @ifplatform *platform-name*

  Same as @if sys.platform == "platform-name": except that it isn't necessary to import sys.

- @ifhostname *hostA,!hostB*

  Evaluates to True iff: h=g.computeMachineName(); h==hostA and h!=hostB.
  The "!" version allows matching to every machineName except the given one
  to allow differing settings on only a few machines.</t>
<t tx="ekr.20080412124815.1"></t>
<t tx="ekr.20080527063511.1">I had a need to figure out why a part of some python code I had written
was taking too long.

I pulled the code into LEO and the relevant part of the outline looked
something like this::

    + Main module
    -- Generate cryptographic key
    -- Hashing algorithm

etc. So I cloned just the segment I wanted to profile and pulled it under a new
section::

    + Main module
    -- [clone] Generate cryptographic key
    -- Hashing algorithm

    + Profiling Experiment
    -- [clone] Generate cryptographic key

And in the body of the "Profiling experiment", I used this code::

    code_under_here = """
    @others
    """

    from timeit import Timer
    t = Timer("print my_key_generator()", code_under_here)
    print t.timeit(number = 10)

And then I hit Control-B to execute the Profiling Experiment body. This
let me make adjustments to the code in the clone body and keep hitting
Control-B to execute the code with the timeit module to see immediately
if what I had done was making a difference.

The great thing about this was that I just used the LEO @others construct
to create a wrapper around the code and did not need to litter my code
with debug or profiling statements.  -- Kayvan</t>
<t tx="ekr.20080603124653.1">Many users will want to track the development version of Leo, in order to stay
on top of the latest features and bugfixes. Running the development version is
quite safe and easy, and it's also a requirement if you want to contribute to
Leo.

1. First, you need to get Bazaar (bzr) from http://bazaar-vcs.org. For windows
   users we recommend the standalone installer - the python installer may have
   problems pushing to Launchpad. Plain bzr installer only contains the command
   line version, so you might want to augment that with a friendly GUI - qbzr is
   recommended as it's the easiest one to install. It provides command like
   'bzr qlog', 'bzr qannotate' etc.

2. Get Leo from launchpad by doing::

    bzr branch lp:leo-editor

And that's it! You can run the launchLeo script (in the top-level branch directory) directly.
When you want to refresh the code with latest modifications from Launchpad, 'run bzr pull'.

If you make modifications to Leo (with the interest in sharing them with the Leo
community), you can check them in to your local branch by doing 'bzr checkin'.
Now, to actually request your changes to be merged to Leo trunk, you need a
Launchpad account with RSA keys in place. There is showmedo video about how to
accomplish this on Windows using puttygen and pageant at
http://showmedo.com/videos/video?name=1510070&amp;fromSeriesID=151.

After your Launchpad account is set up, go to
https://launchpad.net/leo-editor, choose Code tab -&gt; Register Branch, select
Branch type "Hosted" and fill in descriptive details about the branch. After
that, go to the branch home page from Code tab again, and copy-paste the push
command line to terminal. For example, for branch::

 https://code.launchpad.net/~leo-editor-team/leo-editor/mod_rclick

The push command is::

 bzr push bzr+ssh://my_name@bazaar.launchpad.net/~leo-editor-team/leo-editor/mod_rclick

You may wish to add --remember command line option to bzr push, to direct all
future pushes to that location. Then, you only need to execute 'bzr push'.

After your branch is pushed, you can email the Leo mailing list and request it
to be reviewed and merged to trunk.

-- Ville M. Vainio - vivainio.googlepages.com</t>
<t tx="ekr.20080624093059.1">Leo 4.5 beta 1                      June 28, 2008

Leo 4.5 beta 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.5:
--------------------------
- A major revision of Leo's node structures, compatible with so-called unified nodes.
- A major revision of Leo's key-handling code.  Most per-pane key bindings have been eliminated.
- A major revision of Leo's outline drawing and focus handling code.
  Calls to c.beginUpdate and c.endUpdate simply request later redrawing in c.outerUpdate.
- The beginning of usable vim-like bindings.  More support is coming.
- Many small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080624093059.10"></t>
<t tx="ekr.20080624093059.11">Leo's running, so I create a new outline with File-&gt;New

Then I save as in a location where foo.py exists.

The I create a node '@auto foo.py'

Then I use File-&gt;Read/Write-&gt;Read @auto (with that node selected)

Leo says it can't read it.

I close the leo file, re-open in from the recent files menu of the
outline that spawned it, and the @auto file is read no problems.</t>
<t tx="ekr.20080624093059.12">http://groups.google.com/group/leo-editor/browse_thread/thread/c6c4faf6fdead672
</t>
<t tx="ekr.20080624093059.13"></t>
<t tx="ekr.20080624093059.14">findAll now just creates undo info for clone-find-all for one inserted node.</t>
<t tx="ekr.20080624093059.15"></t>
<t tx="ekr.20080624093059.16"></t>
<t tx="ekr.20080624093059.17">exception executing command
Traceback (most recent call last):
 File "C:\_Proj\Leo\key-handling\leo\src\leoCommands.py", line 298, in doCommand
   val = command(event)
 File "C:\_Proj\Leo\key-handling\leo\src\leoEditCommands.py", line 2946, in insertNewLine
   self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
 File "C:\_Proj\Leo\key-handling\leo\src\leoEditCommands.py", line 3104, in insertNewlineHelper
   w.setInsertPoint(i+1)
TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'
truncating headline to one line
</t>
<t tx="ekr.20080624093059.18"></t>
<t tx="ekr.20080624093059.19"></t>
<t tx="ekr.20080624093059.2"></t>
<t tx="ekr.20080624093059.20"></t>
<t tx="ekr.20080624093059.21"></t>
<t tx="ekr.20080624093059.22">http://groups.google.com/group/leo-editor/browse_thread/thread/35a8ea2024036623s</t>
<t tx="ekr.20080624093059.23">http://sourceforge.net/forum/forum.php?thread_id=1858451&amp;forum_id=10228
</t>
<t tx="ekr.20080624093059.24">http://groups.google.com/group/leo-editor/browse_thread/thread/d2a9aeac0d0082f6
</t>
<t tx="ekr.20080624093059.25"></t>
<t tx="ekr.20080624093059.26"></t>
<t tx="ekr.20080624093059.27">Changed c.outerUpdate and added c.bind and c.bind2.</t>
<t tx="ekr.20080624093059.28"></t>
<t tx="ekr.20080624093059.29">Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 311, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoEditCommands.py", line 4781, in selectAllText
    return w.selectAllText()
AttributeError: Canvas instance has no attribute 'selectAllText'
</t>
<t tx="ekr.20080624093059.3"></t>
<t tx="ekr.20080624093059.30"></t>
<t tx="ekr.20080624093059.31">http://groups.google.com/group/leo-editor/browse_thread/thread/8edc4e7b809189cf
</t>
<t tx="ekr.20080624093059.32"></t>
<t tx="ekr.20080624093059.33"></t>
<t tx="ekr.20080624093059.34"></t>
<t tx="ekr.20080624093059.35">- Made t arg optional in vnode ctor.

- Removed the t arg from insertAsX.  Affects these plugins:

wrote:     base64Packager.py
wrote:     macros.py
wrote:     table.py
wrote:     templates.py
wrote:     xsltWithNodes.py

Search for tnode.</t>
<t tx="ekr.20080624093059.36">Leo puts several files in the home directory: .leoID.txt,
.leoRecentFiles.txt, and myLeoSettings.leo.  There are various fallback directories if there is no home directory.

If you want more details, you can do what I did: do a clone-find-all for homeDir.

As for how the home directory is set, the code to do this is g.computeHomeDir.  We get the home directory with

home = os.getenv('HOME',default=None)

There are some mind-numbing details to be handled if there os.getenv does, in fact, return a directory.</t>
<t tx="ekr.20080624093059.37">Leo suppresses marks, expansion state, orphan bits and current
position bits when writing fixed .leo files.  As a result, all nodes
will be collapsed and the root node will always be selected when Leo
opens a fixed .leo file.

When writing fixed .leo files, Leo writes fixed, immutable, reasonable
defaults for window size, position and body-outline ratio.
Specifically, width,height,left,top = 700,500,50,50 and the ratio is
0.5. These values are written so older versions of Leo can read fixed
files.

You make a file fixed by putting '@bool fixedWindow = True' in the
@settings tree of a particular .leo file.  The file will be fixed
after you save the file, reload the file, and save the file again.
Yes, this is clumsy, but it only has to be done once.  A toggle-fixed
file command doesn't seem that useful: using an @bool node is simple
and clear.

You can optionally specify the size and position on the screen of
fixed .leo files by putting an '@data fixedWindowPosition' node in the
@settings tree of myLeoSettings.leo or leoSettings.leo.  You should
**not** put such a node in the fixed .leo file itself--everyone who
opens the file would get that fixed position.

The body of the '@data fixedWindowPosition' node should contain
something like this:

# Must be four entries: width,height,left,top.
# Put this in myLeoSettings.leo, **not** in individual .leo files.

1200
800
50
50

Leo uses reasonable defaults for fixed .leo files if this node does
not exist, or contains something other than 4 numbers, one per line. </t>
<t tx="ekr.20080624093059.38">This allows substantially simpler key bindings. Indeed, most per-pane bindings
have been eliminate.</t>
<t tx="ekr.20080624093059.39"></t>
<t tx="ekr.20080624093059.4">On Mon, Apr 7, 2008 at 7:07 PM, SegundoBob &lt;bhossley@ieee.org&gt; wrote:

I installed Leo 4.4..8 final on Ubuntu.  The installation failed
because the installation put files in /usr/lib/leo/leo.  The
duplicated leo is a mistake.
On line 13 of install I changed:
LEO_LIB_DIR="${LEO_PREFIX}/lib/leo"
to
LEO_LIB_DIR="${LEO_PREFIX}/lib"

With the change the installation worked.</t>
<t tx="ekr.20080624093059.40"># Added ')' at end.</t>
<t tx="ekr.20080624093059.41"></t>
<t tx="ekr.20080624093059.42">This is necessary to simulate operation as a package.</t>
<t tx="ekr.20080624093059.43">This code appears to have been reverted in such a way that it never got pushed to launchpad.</t>
<t tx="ekr.20080624093059.44">This is a Python 'debugger' that computes a call graph.

To trace a function and its callers, put the following at the function's start::

    g.startTracer()</t>
<t tx="ekr.20080624093059.45"></t>
<t tx="ekr.20080624093059.46">This determines whether cleo colors @ignore headlines. The default is True.</t>
<t tx="ekr.20080624093059.47">This affect the following commands:

open, save, save-as, save-to, read-outline-only, read-file-into-node, write-file-from-node and all the import/export commands.</t>
<t tx="ekr.20080624093059.48">Headline pane:

- Prevented "--&gt; exit-named-modes" from switching focus to the Body pane.
    Removed 'c.frame.log.deleteTab('Mode') from endMode

Body pane:

- Enabled search for 'space' character in text
    Removed 'if ch.isspace(): return' in zapToCharacter:

- Eliminated delete-word from removing trailing white space
    Removed 'self.killWs(event)' in killWord and backwardKillWord

- Put zapped text to clipboard
    Added 'g.app.gui.replaceClipboardWith(s[ins:i])' after 'sel.addToKillBuffer(s[ins:i])' in zapToCharacter
    
@nocolor</t>
<t tx="ekr.20080624093059.49">Leo Configuration:
    | The following configuration was used for all testing:
        @strings  top_level_unbound_key_action = command
        @bool stayInTreeAfterEditHeadline = True
        @bool stayInTreeAfterSelect = True
        @bool outline_pane_has_initial_focus = True

Leo's Panes:
    | A "pane" is a area of the screen containing a user interface
    | dedicated to supporting a common set of tasks.  Vi key mappings are
    | associated with the Outline pane, the Body pane, or to the Leo
    | program.  See the no pane (see "General Commands" below). (Outline
    | pane, Body pane)

Leo's Command/Insert States:
    Command state - Denoted by a blue background color (Outline,Body pane)
        | Keys are mapped to commands.
    Insert state - Denoted by a red background color (Outline,Body pane)
        | Keys pressed are inserted into the text.
    Grayed state - Denoted by a gray background color (Outline pane)
        | Keys pressed will cause the next node with a headline starting
        | with that key to be selected.  This "select node by first
        | character" feature is built into Leo. It is not part of the vi
        | support.
        | 
        | This state is intentionally avoided in the vi based outline key
        | mappings. If in the "Grayed" state, enter Ctrl-i to switch to the
        | "Command" state.  The "Grayed" state can be entered from the
        | outline's "Command" state by pressing the Ctrl-] key.

Leo's modes:
| Most vi commands are implemented using Leo's "mode" functionality.
| Modes beginning with "vi-" denote a vi command for the body pane.
| Modes beginning with "tree-" denote a vi-like command for the outline.
| Modes beginning with "body-" denote outline commands that can be called
| from the body pane (and return focus back to the body pane)
| 
| Modes are used both for managing multi-key vi commands and for defining
| macros.
    
    Multi-key command modes:
    | Vi has many commands that require multiple keys to invoke.  Each key
    | accept the last in the command are assigned to a mode that, when
    | executed, maps the subsequent allowed keys in the command sequence.
    | The last key in the sequence is mapped directly to a Leo command or
    | to a "Macro" mode (see below). Any modes mapped to a key by another
    | mode are located in a child node of the mode node doing the mapping.
    | 
    | Example:
    |     dtw = Delete To the 'W' character (note the capital letters)
    |   The 'd' key is mapped to vi-delete-object
    |   vi-delete-object maps the 't' key to vi-delete-to-char
    |   vi-delete-to-char contains Leo commands to perform the vi command.

    Macros modes:
    | Most vi commands do not have an equivalent Leo command.  Instead, a
    | series of Leo commands must be issued to emulate the vi command.
    | The Leo commands needed to emulate a vi command are placed in a
    | single @mode node.

Code limitations:
    Current character:
    | Vi implementation normally use two different "current character"
    | designators depending on the current state.

        Insert state:
        | In the Insert state, a vertical bar is placed between two
        | characters to indicate where the next key will be inserted.
        | Leo's cursor is of this type.

        Command state: 
        | In the Command state, vi expects that the cursor is highlighting
        | a current character and provides commands to enter the insert
        | state or paste text either before or after that current
        | character.  Leo's vi emulation currently does not support a
        | "current character" cursor. As a result, inserting and pasting
        | before or after is replaced by inserting or pasting "at" the
        | current cursor location.  For example, the 'i' and 'a' command
        | are both mapped to enter the insert state at the current cursor
        | location.

    Conditional code execution:
    | No conditional command invocation exits.  Instead, conditional
    | branching is replace by setup commands that insure that, regardless
    | of current state, the command performs correctly.  For example,
    | Beginning-of-line command will go to previous line if called when
    | cursor is at beginning of line.  Vi requires that '|' always goes to
    | beginning of current line.  Problme is solved by issueing
    | forward-char command to insure cursor is moved off of the beginning
    | of the line before beginning-of-line command is issued.

    Commands requesting user input:
    | Commands getting user input must be the last command within the
    | mode.  See "Commands getting user input" in Problems section below.

    Edit headings using modes:
    | Commands modifying or selecting headline text do not work correctly
    | within a mode.  See "Editing headlines within modes" in Problems
    | section below.  This eliminates accurate implementation of vi's
    | delete/change/substitute/yank object commands.  Instead, the
    | commands are modified to only select text.</t>
<t tx="ekr.20080624093059.5"></t>
<t tx="ekr.20080624093059.50">Binding numeric keys:
| Mapping a number to a command or mode prevents the number from being
| entered as text while in the insert state.

Binding '?' key:
| No response when key pressed.

Binding 'bksp' key:
| Binding 'bksp' key to back-char to move back a character in command mode
| prevents 'bksp' from deleting characters in text edit mode.

Commands getting user input:
| Commands requesting user input must be the last command executed.  These
| commands include: find-character and zap-to-character.

Editing headlines within modes:
| Text editing commands do not work within modes assigned to outline key
| mappings.

Undo command:
| The 'undo' command sometimes does not work when returning to a node's
| command mode.  Moving to another node fixes the problem.(i.e. delete-char, set-insert-state, ...)

Matching bracket command:
| Performs bracket matching on Body text when in node's headline command
| state.

Word definition:
| "Word" related commands determine boundries of a word differently.

Toggle case:
| Leo provides support for switching to upper or lower case but no method |
| exists to toggle between cases.

Find settings
| Leo commands only allow toggling of search settings.  If specific "set"
| and "clear" search setting commands were available then searches from the
| body pane could be restricted to the body pane and searches from the
| outline could be restricted to the outline.
Forward and backward sentences:
| Leo's forwardSentenceHelper and backSentenceHelper functions do not stop
| at empty lines nor do they skip over periods within words nor do they stop
| at sentences ending in non-periods nor do they stop at the end or
| beginning of the buffer.

Focus to Body pane:
| Leo functions exist which unconditionally set focus to the body pane
| regardless of the active pane.
    deleteTab() function:
        | Issuing "--&gt; exit-named-mode" calls "endMode" function which calls
        | "c.frame.log.deleteTab('Mode')" function which sets the focus to the
        | body pane.  

Displaying mode help:
| The "--&gt; mode-help" command displays all mapped keys using a capitol
| letter regardless of the actual binding.
    Recommendations:
    | To better support narrow tab cards, display the mode's label without
    | the "enter-" and "-mode" text and place key label before mode label.
    | Results in change from:
    |                enter-vi-delete-line-mode D
    |    enter-vi-delete-to-begin-of-word-mode B 
    | to:
    |    D : vi-delete-line
    |    B : vi-delete-to-begin-of-word</t>
<t tx="ekr.20080624093059.51">Yank vs. Yank
| A vi "yank" operation copies the selected text TO the clipboard.
| A Leo "yank" operation inserts text FROM the clipboard.

copy-text in modes:
| Leo's copy-text does not work within a mode.  As a result, all "copy to
| clipboard" capability is being implemented using kill-&lt;object&gt; command
| followed by a "yank" command.

paste-text in modes:
| paste-text in modes does not work.  Use Leo's "yank" instead.

delete-node does not copy node to clipboard:
| Issue copy-node command followed by delete-node</t>
<t tx="ekr.20080624093059.52"></t>
<t tx="ekr.20080624093059.53">These are now treated much like empty @auto nodes</t>
<t tx="ekr.20080624093059.6">http://groups.google.com/group/leo-editor/browse_thread/thread/294866696257802e
</t>
<t tx="ekr.20080624093059.7">Trying to edit the minibuffer, when I backspace to a character and
press delete the cursor moves to the end of the buffer and deletes the
last character instead.</t>
<t tx="ekr.20080624093059.8">find-word
=========
This command is supposed to:

"Put the cursor at the next word (on a line) that starts with a
character"

It does not. You have to type in a whole word to get any result and
even then
it only selects the word it does not move the cursor to it.


goto-charachter
==============
'''Put the cursor at the n'th character of the buffer.'''

Doesn't do anything.</t>
<t tx="ekr.20080624093059.9">http://groups.google.com/group/leo-editor/browse_thread/thread/b068e88a577a0547
</t>
<t tx="ekr.20080628062747.69">http://groups.google.com/group/leo-editor/browse_thread/thread/794ca596f7c58ae5

The fix was to call c.redraw_now in undo() and redo().  This allows the undo interlock to work.
</t>
<t tx="ekr.20080628062747.70">Minor nit - insert-file to load a file into a node, text appears in the
body pane.  Without doing anything else to the body pane click on
another node.  Inserted text is lost - body for node is empty.  As long
as you move the cursor into the body frame and press a key after
inserting the contents, it's retained.</t>
<t tx="ekr.20080628062747.71">@nocolor

c.beginUpdate()
try:
 add / change icons on some nodes
 c.setChanged(True)
finally:
 c.endUpdate()

seems not to give a redraw *after* a script button is pressed.

It does give one before the action is taken, so pressing the button
twice shows the change.

EKR: The fix was to mod_scripting.py.

@color</t>
<t tx="ekr.20080628062747.72">The fix was a major addition to p._adjustPositionBeforeUnlink.

Report:

Run this script:

t = p.insertAfter()
c.setHeadString(t, 'test node 1')
t = t.insertAfter()
c.setHeadString(t, 'test node 2')
t = t.insertAfter()
c.setHeadString(t, 'test area')
for i in range(200):
   n = t.insertAsLastChild()
   c.setHeadString(n, str(i))
   if i == 3: x = n

for i in range(100):
   n = x.insertAsLastChild()
   c.setHeadString(n, str(i+500))

t.expand()

It creates an outline, you might need to click on the node from which
the script was run to see what was added.  It should look like this:

test node 1
test node 2
test area
   1
   2
  +3
   4
   5
   etc.

Now, use the mouse to drag test node 1 down to a position after node
4... for me at least this results in the outline view leaping to the
bottom of the tree, which it shouldn't do.

Scroll back up to the top, and drag test node 2 down to a position
after node 4, this time no leap.

It appears that the first time you drag something into the test area it
reacts as if 3 is expanded and repositions to allow for all those
actually not visible lines, but the second time you drag something in
it's ok, as if it has an accurate count on visible lines now.
</t>
<t tx="ekr.20080729064227.6">The timit button in unitTest.leo allows you to apply Python's timeit module.
See http://docs.python.org/lib/module-timeit.html.
The contents of @button timer is::

    import leo.core.leoTest as leoTest
    leoTest.runTimerOnNode(c,p,count=100)

runTimerOnNode executes the script in the presently selected node using timit.Timer and prints the results.
</t>
<t tx="ekr.20080729064227.7">The profile button in unitTest.leo allows you to profile nodes using Python's profiler module.
See http://docs.python.org/lib/module-profile.html
The contents of @button profile is::

    import leo.core.leoTest as leoTest
    leoTest.runProfileOnNode(p,outputPath=None) # Defaults to leo\test\profileStats.txt

runProfileOnNode runs the Python profiler on the script in the selected node, then reports the stats.
</t>
<t tx="ekr.20080730095710.1"></t>
<t tx="ekr.20080730095710.2">Leo 4.5 beta 2                      August 7, 2008

Leo 4.5 beta 2 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.5 contains many important new features.  See below for details.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several magor reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080730212711.14">@language rest</t>
<t tx="ekr.20080730212711.15">############################################################
Chapter 23: Eliminating sentinel lines with @shadow
############################################################

This chapter describes an important new feature that debuted in Leo 4.5 b2: @shadow trees.
These trees combine the benefits of @auto, @thin, @file and @nosent trees:

- The (public) files created by @shadow trees contain no sentinels, but
- Leo is able to update @shadow trees in the Leo outline based on changes made
  to public files outside of Leo.

@shadow trees are often useful for studying or editing source files from projects that don't use Leo. 
In such situations, it is convenient to import the @shadow tree from the (public) sources.
As discussed below, Leo can import @shadow trees automatically,
using the same algorithms used by `@auto trees`_.

The crucial ideas and algorithms underlying @shadow trees are the invention of Bernhard Mulder.

.. .. contents::
</t>
<t tx="ekr.20080730212711.16">.. Links
.. _`@auto trees`:          directives.html#auto    
</t>
<t tx="ekr.20080730212711.39">Using @shadow trees is the best choice when you want to have the full power of
Leo's outlines, but wish to retain the source files in their original format,
without Leo sentinels (markup) in comments in the source file. 

Leo's @file and @thin trees create external files containing comments called sentinels.
These sentinel lines allow Leo to recreate the outlines structure of @file and @thin trees.
Alas, many people and organizations find these added sentinel lines unacceptable.
@nosent nodes create external files without sentinels, but at a cost:
Leo can not update @nosent trees when the corresponding external file is changed outside of Leo.

@shadow trees provide a way around this dilemma.
When Leo saves an @shadow tree, it saves two copies of the tree:
a **public** file without sentinels, and a **private** file containing sentinels.
Using Bernhard Mulder's brilliant **update algorithm**,
Leo is able to update @shadow trees in the Leo outline based *solely* on changes to public files.

Leo writes private files to a subfolder of the folder containing the public file:
by default this folder is called .leo_shadow.
You can change the name of this folder using the @string shadow_subdir setting.
Note that private files need not be known to source code control systems such as bzr or cvs.

That's *almost* all there is to it.  The following sections discuss important details:

- How to create @shadow trees.
- How @shadow works.
- Why the update algorithm is sound.</t>
<t tx="ekr.20080730212711.40">Suppose our @shadow tree is @shadow a.py. When Leo writes this tree it creates a
public file, a.py, and a private file, .leo_shadow/xa.p (or just xa.p for
short). Public files might can committed to a source code control system such as
cvs or bzr. Private files should *not* be known to cvs or bzr.

Now suppose a.py has been changed outside of Leo, say as the result of a bzr
merge. The corresponding private file, xa.p, will *not* have been changed.
(Private files should *never* change outside of Leo.

When Leo reads the *new* (and possibly updated) public file it does the
following:

1. Recreates the *old* public file by removing sentinels from the (unchanged!) *private* file.
2. Creates a set of diffs between the old and new *public* files.
3. Uses the diffs to create a new version of the *private* file.
4. Creates the @shadow tree using  the new *private* file.

**Important**: The update algorithm never changes sentinels. This means that the
update algorithm never inserts or deletes nodes. The user is responsible for
creating nodes to hold new lines, or for deleting nodes that become empty as the
result of deleting lines.

Step 3 is the clever part. To see all the details of how the algorithm works,
please study the x.propagate_changed_lines method in leoShadow.py. This code is
heavily commented.
</t>
<t tx="ekr.20080730212711.42">The first step in creating an @shadow tree is to create a node whose headline is
@shadow *&lt;filename&gt;*. This is always safe, even if *&lt;filename&gt;* already
exists: Leo writes the @shadow tree to the public and private files only if the
@shadow tree contains a **significant** amount of information. An @shadow tree
contains a significant amount of information if it has children or if the @shadow node
node contains more than 10 characters, excluding Leo directives.

Thus, you can create an @shadow node and save your outline, regardless of whether the original file exists.
The next time Leo reads the @shadow node, Leo will **create** the entire @shadow tree
using the same logic as for `@auto trees`_.
You can cause Leo to read the @shadow node in two ways:
1) by closing and reloading the Leo outline or
2) by selecting the @shadow node and executing the File:Read/Write:Read @shadow Node command.

**Important**: Leo imports the private file into the @shadow tree only if
a) the public file exists and b) the private file does *not* exist.
Thus, Leo will import code into each @shadow node at most once.
After the first import, updates are made using the update algorithm.

**Note**: just as for @auto, Leo will never read (import) or write an @shadow tree if
the @shadow node is under the influence of an @ignore directive.
</t>
<t tx="ekr.20080730212711.52">There is one boundary case that the update algorithm can not resolve.
If a line is inserted at the boundary between nodes,
the updated algorithm can not determine whether the line should be inserted
at the end of one node of the start of the next node.

Happily, the inability of the update algorithm to distinguish between
these two cases **does not matter**, for three very important reasons:

1. No matter which choice is made, the *public* file that results is the same.
   **The choice doesn't matter**, so the update algorithm is completely and
   absolutely safe.

2. Leo reports any nodes that were changed as the result of the update
   algorithm. In essence, these reports are exactly the same as the reports Leo
   makes when @file or @thin trees were changed as the result of changes made
   externally to Leo. It is as easy for the user to review changes to @shadow
   trees as it is to review changes to @thin or @file trees.

3. Suppose the user moves a line from the end of one node to the beginning of
   the following node, or vice versa. Once the user saves the file, the
   *private* file records the location of the moved line. The next time the user
   reads the @shadow file, the line will *not* be subject to the update
   algorithm because the line has not been changed externally. The location of
   the line (on the boundary) will be completely determined and it will never
   need to be moved across the boundary.

Understanding these three reasons finally convinced me that @shadow could be made to work reliably.
</t>
<t tx="ekr.20080806211440.185">@language rest</t>
<t tx="ekr.20080806211440.186">#######################################
What's New in Leo 4.5
#######################################

.. .. contents::</t>
<t tx="ekr.20080806211440.187">.. Links used in this document.
.. _`Chapter 23`:           atShadow.html
</t>
<t tx="ekr.20080806211440.188">- Added support for @shadow files.
  This is a major breakthrough.
  See `Chapter 23`_ for full details.

- Added much improved support for vim bindings.

- Allow v.uA's in @thin and @shadow nodes.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/750bb3099090f5b
</t>
<t tx="ekr.20080806211440.189">- The default settings for @shadow files are now located in leoSettings.leo in the node::

    @settings--&gt;File options--&gt;Shadow files

  The defaults for these settings are::

    @string shadow_prefix = x
    @string shadow_subdir = .leo_shadow

- Added support for @bool fixedWindow option. Leo suppresses marks, expansion
  state, orphan bits and current position bits when writing fixed .leo files. As
  a result, all nodes will be collapsed and the root node will always be
  selected when Leo opens a fixed .leo file.

  You can optionally specify the size and position on the screen of fixed .leo
  files by putting an '@data fixedWindowPosition' node in the
  @settings tree of myLeoSettings.leo or leoSettings.leo.  You should
  **not** put such a node in the fixed .leo file itself--everyone who
  opens the file would get that fixed position.

  The body of the '@data fixedWindowPosition' node should contain
  something like this::

    # Must be four entries: width,height,left,top.
    # Put this in myLeoSettings.leo, **not** in individual .leo files.

    1200
    800
    50
    50

- Added @bool cleo_color_ignore = True
  This determines whether cleo colors @ignore headlines. The default is True.</t>
<t tx="ekr.20080806211440.253">- Leo now uses a sax-based parser to read .leo files.
  This makes it possible to extend Leo's file format without invalidating previous versions of Leo.

- Leo now supports the so-called 'Graph World'.
  When g.unified_nodes is True, Leo moves all information from tnodes into vnodes.

- Leo now uses a new key binding scheme.
  This allows substantially simpler key bindings. Indeed, most per-pane bindings
  have been eliminated.
  Added support for kill bindings.

- Leo is now an installable package.
  To make this work, Leo adds os.curdir to sys.path if needed on startup.

- Reorganized Leo's drawing and focus code.
  As a result, calls to c.beginUpdate and c.endUpdate are no longer needed.

- Leo is now ready for Python 3.x:
  Change most print statements to calls to g.pr.
</t>
<t tx="ekr.20080806211440.256">- Added g.Tracer class.  This is a Python 'debugger' that computes a call graph.
  To trace a function and its callers, put the following at the function's start::

    g.startTracer()

- The find-character command now finds characters across line boundaries.

- Set cwd in read/write commands. This affect the following commands:
  open, save, save-as, save-to, read-outline-only, read-file-into-node,
  write-file-from-node and all the import/export commands.

- Leo creates the .leo folder in the user's HOME directory, and puts several configuration files there.
  Leo looks for myLeoSettings.leo in HOME/.leo.
  Leo uses os.path.expanduser("~") if there is no home setting.</t>
<t tx="ekr.20080813064908.2">In version 4.5, Leo changed to using a sax parser for .leo files. This can cause
problems if your .leo file contains invalid characters.
Bugs in previous versions of Leo permitted these bad characters to appear.

The sax parser complains that these characters are not valid in .xml files.
Remove these invalid characters as follows:

1. `run Leo in a console window`_, and load the .leo file.
   Near the bottom of the error message you will see a line like::

    SAXParseException: &lt;unknown&gt;:123:25: not well-formed (invalid token)

   This line reports a bad character at character 25 of line 123.

2. Open the .leo file in an external editor.
   The Scite editor, http://www.scintilla.org/SciTE.html,
   is a good choice because it clearly shows non-printing characters.
   Remove the invalid character, save the .leo file.

Repeat steps 1 and 2 until all invalid characters are gone.
</t>
<t tx="ekr.20080815093141.89">Leo 4.5 beta 3                      August 15, 2008

Leo 4.5 beta 3 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.5 contains many important new features.  See below for details.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several magor reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080815093141.90">- Added support for @shadow files.
  This is a major breakthrough.
  See `Chapter 23`_ for full details.
  
- Added much improved support for vim bindings.

- Allow v.uA's in @thin and @shadow nodes.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/750bb3099090f5b
</t>
<t tx="ekr.20080815093141.91">- Leo now uses a sax-based parser to read .leo files.
  This makes it possible to extend Leo's file format without invalidating previous versions of Leo.
  
- Leo now supports the so-called 'Graph World'.
  When g.unified_nodes is True, Leo moves all information from tnodes into vnodes.
  
- Leo now uses a new key binding scheme.
  This allows substantially simpler key bindings. Indeed, most per-pane bindings
  have been eliminated.
  Added support for kill bindings.
  
- Leo is now an installable package.
  To make this work, Leo adds os.curdir to sys.path if needed on startup.
  
- Reorganized Leo's drawing and focus code.
  As a result, calls to c.beginUpdate and c.endUpdate are no longer needed.
  
- Leo is now ready for Python 3.x:
  Change most print statements to calls to g.pr.
</t>
<t tx="ekr.20080815093141.92">- Added g.Tracer class.  This is a Python 'debugger' that computes a call graph.
  To trace a function and its callers, put the following at the function's start::

    g.startTracer()
  
- The find-character command now finds characters across line boundaries.

- Set cwd in read/write commands. This affect the following commands:
  open, save, save-as, save-to, read-outline-only, read-file-into-node,
  write-file-from-node and all the import/export commands.
  
- Create myLeoSettings.leo if it does not exist.
  Leo create a simple template myLeoSettings.leo in the home directory if no other
  copy of myLeoSettings.leo exists.

- Added support for @args list for @button nodes.
  See the docstring for the mod_scripting plugin for details.
  </t>
<t tx="ekr.20080815093141.93">- The default settings for @shadow files are now located in leoSettings.leo in the node::

    @settings--&gt;File options--&gt;Shadow files
    
  The defaults for these settings are::

    @string shadow_prefix = x
    @string shadow_subdir = .leo_shadow

- Added support for @bool fixedWindow option. Leo suppresses marks, expansion
  state, orphan bits and current position bits when writing fixed .leo files. As
  a result, all nodes will be collapsed and the root node will always be
  selected when Leo opens a fixed .leo file.
  
  You can optionally specify the size and position on the screen of fixed .leo
  files by putting an '@data fixedWindowPosition' node in the
  @settings tree of myLeoSettings.leo or leoSettings.leo.  You should
  **not** put such a node in the fixed .leo file itself--everyone who
  opens the file would get that fixed position.

  The body of the '@data fixedWindowPosition' node should contain
  something like this::

    # Must be four entries: width,height,left,top.
    # Put this in myLeoSettings.leo, **not** in individual .leo files.
    
    1200
    800
    50
    50

- Added @bool cleo_color_ignore = True
  This determines whether cleo colors @ignore headlines. The default is True.
  
- Added @bool suppress_import_parsing setting
  When True, @auto and @shadow import the entire file into a single node.</t>
<t tx="ekr.20080827175609.55">Leo 4.5 release candidate 1                      August 28, 2008

Leo 4.5 rc1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.5 contains many important new features.  See below for details.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several magor reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  and simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080827175609.56">- Added support for @shadow files.
  This is a major breakthrough.
  See `Chapter 23`_ for full details.
  
- Added much improved support for vim bindings.

- Allow v.uA's in @thin and @shadow nodes.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/750bb3099090f5b
</t>
<t tx="ekr.20080827175609.57">- Leo now uses a sax-based parser to read .leo files.
  This makes it possible to extend Leo's file format without invalidating previous versions of Leo.
  
- Leo now supports the so-called 'Graph World'.
  When g.unified_nodes is True, Leo moves all information from tnodes into vnodes.
  
- Leo now uses a new key binding scheme.
  This allows substantially simpler key bindings. Indeed, most per-pane bindings
  have been eliminated.
  Added support for kill bindings.
  
- Leo is now an installable package.
  To make this work, Leo adds os.curdir to sys.path if needed on startup.
  
- Reorganized Leo's drawing and focus code.
  As a result, calls to c.beginUpdate and c.endUpdate are no longer needed.
  
- Leo is now ready for Python 3.x:
  Change most print statements to calls to g.pr.
</t>
<t tx="ekr.20080827175609.58">- Added g.Tracer class.  This is a Python 'debugger' that computes a call graph.
  To trace a function and its callers, put the following at the function's start::

    g.startTracer()
  
- The find-character command now finds characters across line boundaries.

- Set cwd in read/write commands. This affect the following commands:
  open, save, save-as, save-to, read-outline-only, read-file-into-node,
  write-file-from-node and all the import/export commands.

- Added support for @args list for @button nodes.
  See the docstring for the mod_scripting plugin for details.
  
- Leo creates the .leo folder in the user's HOME directory, and puts several configuration files there.
  Leo looks for myLeoSettings.leo in HOME/.leo.</t>
<t tx="ekr.20080827175609.59">- The default settings for @shadow files are now located in leoSettings.leo in the node::

    @settings--&gt;File options--&gt;Shadow files
    
  The defaults for these settings are::

    @string shadow_prefix = x
    @string shadow_subdir = .leo_shadow

- Added support for @bool fixedWindow option. Leo suppresses marks, expansion
  state, orphan bits and current position bits when writing fixed .leo files. As
  a result, all nodes will be collapsed and the root node will always be
  selected when Leo opens a fixed .leo file.
  
  You can optionally specify the size and position on the screen of fixed .leo
  files by putting an '@data fixedWindowPosition' node in the
  @settings tree of myLeoSettings.leo or leoSettings.leo.  You should
  **not** put such a node in the fixed .leo file itself--everyone who
  opens the file would get that fixed position.

  The body of the '@data fixedWindowPosition' node should contain
  something like this::

    # Must be four entries: width,height,left,top.
    # Put this in myLeoSettings.leo, **not** in individual .leo files.
    
    1200
    800
    50
    50

- Added @bool cleo_color_ignore = True
  This determines whether cleo colors @ignore headlines. The default is True.
  
- Added @bool suppress_import_parsing setting
  When True, @auto and @shadow import the entire file into a single node.</t>
<t tx="ekr.20080830082008.1">Leo 4.5 release candidate 2                     August 30, 2008

Leo 4.5 rc2 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.5 contains many important new features.  See below for details.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several magor reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  and simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080830082008.2">- Added support for @shadow files.
  This is a major breakthrough.
  See `Chapter 23`_ for full details.
  
- Added much improved support for vim bindings.

- Allow v.uA's in @thin and @shadow nodes.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/750bb3099090f5b
</t>
<t tx="ekr.20080830082008.3">- Leo now uses a sax-based parser to read .leo files.
  This makes it possible to extend Leo's file format without invalidating previous versions of Leo.
  
- Leo now supports the so-called 'Graph World'.
  When g.unified_nodes is True, Leo moves all information from tnodes into vnodes.
  
- Leo now uses a new key binding scheme.
  This allows substantially simpler key bindings. Indeed, most per-pane bindings
  have been eliminated.
  Added support for kill bindings.
  
- Leo is now an installable package.
  To make this work, Leo adds os.curdir to sys.path if needed on startup.
  
- Reorganized Leo's drawing and focus code.
  As a result, calls to c.beginUpdate and c.endUpdate are no longer needed.
  
- Leo is now ready for Python 3.x:
  Change most print statements to calls to g.pr.
</t>
<t tx="ekr.20080830082008.4">- Added g.Tracer class.  This is a Python 'debugger' that computes a call graph.
  To trace a function and its callers, put the following at the function's start::

    g.startTracer()
  
- The find-character command now finds characters across line boundaries.

- Set cwd in read/write commands. This affect the following commands:
  open, save, save-as, save-to, read-outline-only, read-file-into-node,
  write-file-from-node and all the import/export commands.

- Added support for @args list for @button nodes.
  See the docstring for the mod_scripting plugin for details.
  
- Leo creates the .leo folder in the user's HOME directory, and puts several configuration files there.
  Leo looks for myLeoSettings.leo in HOME/.leo.</t>
<t tx="ekr.20080830082008.5">- The default settings for @shadow files are now located in leoSettings.leo in the node::

    @settings--&gt;File options--&gt;Shadow files
    
  The defaults for these settings are::

    @string shadow_prefix = x
    @string shadow_subdir = .leo_shadow

- Added support for @bool fixedWindow option. Leo suppresses marks, expansion
  state, orphan bits and current position bits when writing fixed .leo files. As
  a result, all nodes will be collapsed and the root node will always be
  selected when Leo opens a fixed .leo file.
  
  You can optionally specify the size and position on the screen of fixed .leo
  files by putting an '@data fixedWindowPosition' node in the
  @settings tree of myLeoSettings.leo or leoSettings.leo.  You should
  **not** put such a node in the fixed .leo file itself--everyone who
  opens the file would get that fixed position.

  The body of the '@data fixedWindowPosition' node should contain
  something like this::

    # Must be four entries: width,height,left,top.
    # Put this in myLeoSettings.leo, **not** in individual .leo files.
    
    1200
    800
    50
    50

- Added @bool cleo_color_ignore = True
  This determines whether cleo colors @ignore headlines. The default is True.
  
- Added @bool suppress_import_parsing setting
  When True, @auto and @shadow import the entire file into a single node.</t>
<t tx="ekr.20080902080930.2">Leo 4.5 final                                  September 2, 2008

Leo 4.5 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several magor reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  and simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Quote of the month:
-------------------
Squeak and Leo have been two of the most significant technologies to
redefine my personal computer experience and the ideas behind computing.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080902080930.3">- Added support for @shadow files.
  This is a major breakthrough.
  See `Chapter 23`_ for full details.
  
- Added much improved support for vim bindings.

- Allow v.uA's in @thin and @shadow nodes.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/750bb3099090f5b
</t>
<t tx="ekr.20080902080930.4">- Leo now uses a sax-based parser to read .leo files.
  This makes it possible to extend Leo's file format without invalidating previous versions of Leo.
  
- Leo now supports the so-called 'Graph World'.
  When g.unified_nodes is True, Leo moves all information from tnodes into vnodes.
  
- Leo now uses a new key binding scheme.
  This allows substantially simpler key bindings. Indeed, most per-pane bindings
  have been eliminated.
  Added support for kill bindings.
  
- Leo is now an installable package.
  To make this work, Leo adds os.curdir to sys.path if needed on startup.
  
- Reorganized Leo's drawing and focus code.
  As a result, calls to c.beginUpdate and c.endUpdate are no longer needed.
  
- Leo is now ready for Python 3.x:
  Change most print statements to calls to g.pr.
</t>
<t tx="ekr.20080902080930.5">- Added g.Tracer class.  This is a Python 'debugger' that computes a call graph.
  To trace a function and its callers, put the following at the function's start::

    g.startTracer()
  
- The find-character command now finds characters across line boundaries.

- Set cwd in read/write commands. This affect the following commands:
  open, save, save-as, save-to, read-outline-only, read-file-into-node,
  write-file-from-node and all the import/export commands.

- Added support for @args list for @button nodes.
  See the docstring for the mod_scripting plugin for details.
  
- Leo creates the .leo folder in the user's HOME directory, and puts several configuration files there.
  Leo looks for myLeoSettings.leo in HOME/.leo.</t>
<t tx="ekr.20080902080930.6">- The default settings for @shadow files are now located in leoSettings.leo in the node::

    @settings--&gt;File options--&gt;Shadow files
    
  The defaults for these settings are::

    @string shadow_prefix = x
    @string shadow_subdir = .leo_shadow

- Added support for @bool fixedWindow option. Leo suppresses marks, expansion
  state, orphan bits and current position bits when writing fixed .leo files. As
  a result, all nodes will be collapsed and the root node will always be
  selected when Leo opens a fixed .leo file.
  
  You can optionally specify the size and position on the screen of fixed .leo
  files by putting an '@data fixedWindowPosition' node in the
  @settings tree of myLeoSettings.leo or leoSettings.leo.  You should
  **not** put such a node in the fixed .leo file itself--everyone who
  opens the file would get that fixed position.

  The body of the '@data fixedWindowPosition' node should contain
  something like this::

    # Must be four entries: width,height,left,top.
    # Put this in myLeoSettings.leo, **not** in individual .leo files.
    
    1200
    800
    50
    50

- Added @bool cleo_color_ignore = True
  This determines whether cleo colors @ignore headlines. The default is True.
  
- Added @bool suppress_import_parsing setting
  When True, @auto and @shadow import the entire file into a single node.</t>
<t tx="ekr.20080912143702.137">Leo 4.5.1 final                                  September 14, 2008

Leo 4.5.1 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.5.1 final fixes several important bugs in Leo 4.5 final:

- Eliminated spurious error messages in the goto-global-line command.
- @shadow files with unknown file extensions now work properly.
- Improved Leo's installer.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several major reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  and simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Quote of the month:
-------------------
Squeak and Leo have been two of the most significant technologies to
redefine my personal computer experience and the ideas behind computing.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20080912143702.138"># goToLineNumber was always complaining about a missing private shadow file.</t>
<t tx="ekr.20080912143702.139">@

adjustTargetLanguage, a helper of writeOneAtShadowNode, no longer sets
c.target_language to 'unknown_language' when the file extension is unknown.</t>
<t tx="ekr.20080912143702.140">The script failed for paths such as c:\xp\python25\python.exe
for which python was not the top-most directory.</t>
<t tx="ekr.20080922124033.1">The following code can be run from a script to get input from the user using the minibuffer::

    def getInput (event=None):

       stateName = 'get-input'
       k = c.k
       state = k.getState(stateName)

       if state == 0:
           k.setLabelBlue('Input: ',protect=True)
           k.getArg(event,stateName,1,getInput)
       else:
           k.clearState()
           g.es_print('input: %s' % k.arg)

    getInput()

Let's look at this in detail.  The lines::

    stateName = 'get-input'
    k = c.k
    state = k.getState(stateName)

define a state *name*, 'get-input', unique to this code.
k.getState returns the present state (an int) associated with this state.

When getInput() is first called, the state returned by k.getState will be 0,
so the following lines are executed::

    if state == 0:
        k.setLabelBlue('Input: ',protect=True)
        k.getArg(event,stateName,1,getInput)

These lines put a protected label in the minibuffer:
the user can't delete the label by backspacing.
getArg, and the rest of Leo's key handling code, take care of the extremely
complex details of handling key strokes in states.
The call to getArg never returns.
Instead, when the user has finished entering the input by typing &lt;Return&gt;
getArg calls getInput so that k.getState will return state 1, the value
passed as the third argument to k.getArg.
The following lines handle state 1::

    else:
        k.clearState()
        g.es_print('input: %s' % k.arg)

k.arg is the value returned by k.getArg.
This example code just prints the value of k.arg and clears the input state.
</t>
<t tx="ekr.20080923181012.1">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

A test of creating directories.

############
html test
############</t>
<t tx="ekr.20080923182326.1">This option applies to directories specified in filenames in all kinds of @file trees, and to filenames specified in the @path directive.

True:  Leo attempts to create directories if they do not exist.
False: Leo never attempts to create directories.</t>
<t tx="ekr.20081205084002.2">Scripts can easily determine what directives are in effect at a particular
position in an outline. c.scanAllDirectives(p) returns a Python dictionary whose
keys are directive names and whose values are the value in effect at position p.
For example::

    d = c.scanAllDirectives(p)
    g.es(g.dictToString(d))

In particular, d.get('path') returns the full, absolute path created by all
\@path directives that are in ancestors of node p. If p is any kind of @file node
(including @thin, @auto, @nosent, @shadow, etc.), the following script will
print the full path to the created file::

    path = d.get('path')
    name = p.anyAtFileNodeName()
    if name:
       name = g.os_path_finalize_join(path,name)
       g.es(name)
</t>
<t tx="ekr.20090116094356.10">The form of this node is::

    @menuat *&lt;path&gt;* *&lt;action&gt;* *[clipboard]*

The @menuat setting has 2-3 parameters in its head text, its children are @menu and
@item nodes as for the @menu setting.  @menuat modifies the menu tree created by @menus.
It is intended to be used in myLeoSettings.leo to modify the menu tree created
in leoSettings.leo. This allows you to change the menus without having to
re-create the entire menu tree from leoSettings.leo, and ensures you don't miss
out when new things are added in the @menus in leoSettings.leo, as you would if
you replaced the @menus in leoSettings.leo with one in myLeoSettings.leo.
@menuat should occur in a @settings tree, but not as a descendant of a @menus
tree. There is an example of the use of the
@menuat setting in the file .../leo/core/test/menuAtTest.leo.

The **path** argument specifies a target location in the menu tree as defined by
@menus and modified by earlier @menuat settings. The path takes the form
/entry1/entry2/entry3 where each entry is the name of a menu or item with all
text except a-z and 0-9 removed. Upper case letters are converted to lower case.
So for example to use the `Outline-&gt;Move-&gt;Move Down` menu item as a target, you
would specify a path as `/outline/move/movedown`.

The **action** argument specifies what the menu item does.
There are 5 available actions:

- **before**: The supplied items and sub menus will be inserted immediately
  before the target menu or item.

- **after**: The supplied items and sub menus will be inserted immediately after
  the target menu or item.

- **append**: The supplied items and sub menus will be appended at the end of
  the menu containing the target menu or item.

- **cut**: The target menu or item will be removed from the menu tree and saved
  to an internal clipboard. This can be used for deleting menus or items.
  Descendants of the @menuat setting are ignored.

- **copy**: The target menu or item will be copied and saved to
  an internal clipboard.  Descendants of the @menuat setting are ignored.

The optional **clipboard** argument modifies the action of the before, after,
and append actions. By default these actions insert the menus and items supplied
as descendants of the @menuat setting. If you specify "clipboard" (without the
quotes) as the source, the contents of the clipboard from a previous cut or copy
action will be used instead. This parameter is optional and can be left blank.</t>
<t tx="ekr.20090116094356.11">The body text contains a list of settings for a font.  For example::

    body_text_font_family = Courier New
    body_text_font_size = None
    body_text_font_slant = None
    body_text_font_weight = None

**Important**: you can use the show-fonts minibuffer command to guide you in making these settings.

</t>
<t tx="ekr.20090116094356.12">The body text contains a list of shortcut specifiers.</t>
<t tx="ekr.20090116094356.13">The body text contains a list of paths of recently opened files, one path per
line. Leo writes the list of recent files to .leoRecentFiles.txt in Leo's
config directory, again one file per line.</t>
<t tx="ekr.20090116094356.14">The form of this node is::

    @mode *&lt;mode name&gt;*

The body text contains a list of shortcut specifiers. @mode nodes work just
like @shortcuts nodes, but in addition they have the side effect of creating
the enter-&lt;mode name&gt;-mode command.</t>
<t tx="ekr.20090116094356.2">When reading a .leo file, Leo looks for settings in default settings
files first, then settings in personal settings files, and finally
settings in local settings files.  The exact search order is:

1. Default settings files:

   a. configDir/leoSettings.leo
   b. homeDir/leoSettings.leo
   c. localDir/leoSettings.leo

2. Personal settings files:

   a. configDir/myLeoSettings.leo
   b. homeDir/myLeoSettings.leo
   c. homeDir/&lt;machine-name&gt;LeoSettings.leo (note capitalization)
   d. localDir/myLeoSettings.leo

3. Local settings files:

   a. The file specified by the -c command-line option.
   b. The file being loaded.

Settings that appear later in this list override settings that
appear earlier in this list.  This happens on a setting-by-setting
basis, *not* on a file-by-file basis.  In other words, each individual
setting overrides only the *corresponding* setting in previously-read
files.  Reading a setting file does *not* reset all previous settings.
Note that the same file might appear several times in the search list.
Leo detects such duplicate file names and only loads each settings file once.
Leo remembers all the settings in settings files and does not reread those
settings when reading another .leo file.

**Caution**: This search order offers almost too much flexibilty. This can be
confusing, even for power users. It's important to choose the "simplest
configuration scheme that could possibly work".  Something like:

- Use a single leoSettings.leo file for installation-wide defaults.
- Use a single myLeoSettings.leo files for personal defaults.
- Use local settings sparingly.

**Important**: it is good style to limit settings placed in 
myLeoSettings.leo to those settings that differ from default settings.</t>
<t tx="ekr.20090116094356.3">You should use special care when placing default or personal settings files in
**local** directories, that is, directories other than homeDir, configDir or
machineDir. In particular, the value of localDir can change when Leo reads
additional files. This can result in Leo finding new default and personal
settings files. The values of these newly-read settings files will, as always,
override any previously-read settings.

Let us say that a setting is **volatile** if it is different from a default
setting. Let us say that settings file A.leo **covers** settings file if B.leo
if all volatile settings in B.leo occur in A.leo. With these definitions, the
**safe rule** for placing settings files in local directories is::

   Settings files in local directories should
   cover all other settings files.

Following this rule will ensure that the per-directory defaults specified in the
local settings file will take precedence over all previously-read default and
personal settings files. Ignore this principle at your peril.</t>
<t tx="ekr.20090116094356.5">An @buttons tree in a settings file defines global buttons that
are created in the icon area of all .leo files.
All @button nodes in the @commands tree create global buttons.
All @button nodes outside the commands tree create buttons local to the settings file.
</t>
<t tx="ekr.20090116094356.6">An @commands tree in a settings file defines global commands.
All @command nodes in the @commands tree create global commands.
All @command nodes outside the commands tree create commands local to the settings file.
</t>
<t tx="ekr.20090116094356.7">The body text contains a list of strings, one per line.
Lines starting with '#' are ignored.</t>
<t tx="ekr.20090116094356.8">The body text of the @enabled plugins node contains a list of enabled plugins,
one per line. Comment lines starting with '#' are ignored. Leo loads plugins in
the order they appear.
**Important**: Leo handles @enabled-plugins nodes a differently from other kinds
of settings. To avoid confusion, **please read the following carefully**.

As always, Leo looks for @enabled-plugins nodes in settings files in the order
specified by `Search order for settings files`_. Leo will enable all plugins
found in the @enabled-plugins node it finds *last* in the search order. Leo does
*not* enable plugins found in any other @enabled-plugins node. In particular,
**you can not specify a list of default plugins by placing that list in a
settings file that appears early in the search list**. Instead, the last
@enabled-plugins node found in the search list specifies all and *only* the plugins
that will be enabled.

Let us distinguish two different situations. First, what Leo does when loading a
file, say x.leo. Second, what Leo does when loading a second file, say y.leo,
*from x.leo*. When loading the first .leo file, Leo enables plugins from the
@enabled-plugins node it finds *last* in the search order. But after plugins
have *already* been loaded and enabled, there is no way to disable previously
loaded-and-enabled plugins. But local settings files can enable additional
plugins.

To avoid confusion, I highly recommend following another kind of safe rule.
We say that an @enabled-plugin node in file A.leo **covers** an @enabled-plugin
node in file B.leo if all plugins specified in B's @enabled-plugin node appear
A's @enabled-plugin node. The safe rule for plugins is::

  @enabled-plugin nodes in settings files in local directories
  should cover @enabled-plugins nodes in all other settings files.</t>
<t tx="ekr.20090116094356.9">Leo creates its menus from the @menu, @item and @popup nodes in the @menus tree.
Within @menus trees, @menu nodes create menus and @item nodes create menu items. 

The menu name always follows @menu. If the menu name is 'Plugins', Leo will
create the Plugins menu and populate the menu by calling the
'create-optional-menus' hook. This creates the Plugins menu as usual. Nested
@menu nodes define submenus.

The command name follows @item. If the body text of an @item node exists, this
body text is the menu name. Otherwise, the menu name is the command name.
However, if the command name starts with a '*', hyphens are removed from the
menu name. Menu names and command names may contain a single ampersand (&amp;). If
present, the following character is underlined in the name. If the command
name in an @item node is just a hyphen (-), the item represents a menu
separator.

@popup *&lt;widget-name&gt;* creates a popup menu for use by the rClick plugin.
The children of this node should be @menu and @item nodes, used as with
@menus.</t>
<t tx="ekr.20090116130002.1">Settings files can be found in the following directories:

- **homeDir**, the HOME/.leo directory. HOME is given by Python's HOME
  environment variable, or by os.expanduser('~') if no HOME environment variable
  exists.

- **configDir**, Leo's configuration directory: leo/config.

- **machineDir**, the HOME/.leo/MACHINE directory. MACHINE is given by Python's
  HOSTNAME environment variable, or by Python's COMPUTERNAME environment
  variable if there is no HOSTNAME variable, or by the value returned by
  socket.gethostname() if neither environment variable exists.

- **localDir**, the directory containing the .leo file being loaded.

In addition, Leo's -c command-line option can specify any .leo file anywhere.</t>
<t tx="ekr.20090130144433.1">All questions are welcome at http://groups.google.com/group/leo-editor</t>
<t tx="ekr.20090130144433.2">You can discuss possible bugs at
http://groups.google.com/group/leo-editor

Please report bugs at
http://bugs.launchpad.net/leo-editor

When reporting a bug, please include *all* of the following:

- The version of Leo used.

- The version of Python used.

- The platform or platforms used: Linux, Windows, MacOs.

- A clear description of the problem.

- Information sufficient to recreate the problem.

It's polite to make the bug report self contained, so that six weeks later
somebody will be able to understand the report as it stands.
</t>
<t tx="ekr.20090202191501.7">You can simply unpack Leo anywhere and run from there.  You don't need the
installer.

From a console window, cd to the top-level leo folder.  Run Leo as follows::

    python launchLeo.py

To run Leo with Qt look and feel, use the --gui=qt option::

    python launchLeo.py --gui=qt

To load Leo's source, load leoPyRef.leo::

    python launchLeo.py --gui=qt leo\\core\\leoPyRef.leo</t>
<t tx="ekr.20090212054250.5"></t>
<t tx="ekr.20090212054250.6">You can get the latest official releases of Leo at
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

However, if at all possible, it is better to use bzr to get the latest sources.  See the next entry.</t>
<t tx="ekr.20090212054250.7">Daily snapshots are available at http://www.greygreen.org/leo/</t>
<t tx="ekr.20090221070927.1">All parts of Leo are distributed under the following copyright. This is intended
to be the same as the MIT license, namely that Leo is absolutely free, even for
commercial use, including resale. There is no GNU-like "copyleft" restriction.
This license is compatible with the GPL.

**Copyright 1997-2010 by Edward K. Ream. All Rights Reserved.**

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

**THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.**</t>
<t tx="ekr.20090223065025.3">Let::

    w = c.frame.body.bodyCtrl # Leo's body pane.
    
Scripts can get or change the context of the body as follows::

    w.appendText(s)                     # Append s to end of body text.
    w.delete(i,j=None)                  # Delete characters from i to j.
    w.deleteTextSelection()             # Delete the selected text, if any.
    s = w.get(i,j=None)                 # Return the text from i to j.
    s = w.getAllText                    # Return the entire body text.
    i = w.getInsertPoint()              # Return the location of the cursor.
    s = w.getSelectedText()             # Return the selected text, if any.
    i,j = w.getSelectionRange (sort=True) # Return the range of selected text.
    w.replace(i,j,s)                    # Replace the text from i to j by s.
    w.setAllText(s)                     # Set the entire body text to s.
    w.setBackgroundColor(color)         # Set the background color.
    w.setSelectionRange(i,j,insert=None) # Select the text.
    w.setForegroundColor(color)         # Set the foreground color.

**Notes**:

- These are only the most commonly-used methods.
  For more information, consult Leo's source code.

- i and j are zero-based indices into the the text.
  When j is not specified, it defaults to i.
  When the sort parameter is in effect, getSelectionRange
  ensures i &lt;= j.

- color is a tk color name, even when using the qt gui plugin.
</t>
<t tx="ekr.20090324085713.2">Leo 4.6 beta 1                                       March 23, 2009

Leo 4.6 b1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.6:
--------------------------

- Leo now requires Python 2.4 or later.
- Leo now features a modern Qt interface;
  Leo's legacy Tk interface can also be used.
- New --config --file and --gui command-line options.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20090324085713.272"></t>
<t tx="ekr.20090324085713.285"></t>
<t tx="ekr.20090324085713.289">http://groups.google.com/group/leo-editor/browse_thread/thread/5f5219fedd977ec2
</t>
<t tx="ekr.20090324085713.292"></t>
<t tx="ekr.20090324085713.318">http://groups.google.com/group/leo-editor/browse_thread/thread/414137b93c7e4b90

Calls g.makeAllNonExistentDirectories instead of os.mkdir.</t>
<t tx="ekr.20090324085713.320">http://groups.google.com/group/leo-editor/browse_thread/thread/707a910f975f3715

http://groups.google.com/group/leo-editor/browse_thread/thread/74c6ab4809bde980

There were two separate bugs:

1. The eol_span and eol_span_regex now honor the mode's escape character.

2. colorRangeWithTag now colors delegates with the default tag color.

No changes were made in modes/c.py or modes/c.xml.</t>
<t tx="ekr.20090324085713.326"></t>
<t tx="ekr.20090324085713.327">http://groups.google.com/group/leo-editor/browse_thread/thread/7d8325d055cbef30</t>
<t tx="ekr.20090324085713.350">The code should save/restore, just as in the clean_file function (from scripts.leo)</t>
<t tx="ekr.20090324085713.358">The problem was missing calls to initAfterLoad in c.new.</t>
<t tx="ekr.20090324085713.395">http://groups.google.com/group/leo-editor/browse_thread/thread/f27e3514310a5c90</t>
<t tx="ekr.20090324085713.404"></t>
<t tx="ekr.20090324085713.513"></t>
<t tx="ekr.20090324085713.605">Pulled trunk, got r1599

python launchLeo.py leo/plugins/leoPlugins.leo

go to

Plugins--&gt;Graph world--&gt;@shadow backlink.py--&gt;backlink declarations

All I did was add the full stop at the end of the docstring, but see
the diff:

=== modified file 'leo/plugins/backlink.py'
--- leo/plugins/backlink.py     2009-02-19 18:16:01 +0000
+++ leo/plugins/backlink.py     2009-02-25 22:14:46 +0000
@@ -1,4 +1,4 @@
-'''Backlink - allow arbitrary links between nodes
+'''Backlink - allow arbitrary links between nodes.
 '''

 # Notes
@@ -296,7 +296,7 @@
                break
        else:
            self.showMessage("Error: no such link")
-
+
        gcc = getattr(self.c, 'graphcanvasController')
        if gcc:
            gcc.update()
</t>
<t tx="ekr.20090324085713.661"></t>
<t tx="ekr.20090324085713.662">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac

&gt; As I said, all I need would be is for leo to call callback/hook with
&gt; signature like
&gt; def complete(line-up-to-cursor, current_node) =&gt; list of strings

The actual signature is:

theObject,completionList = getExternalCompletions (self,s,p=None,language='python')

p is used only to get the language, or you can set the language by hand.

@color</t>
<t tx="ekr.20090324085713.663"></t>
<t tx="ekr.20090324085713.666">c.config.doEnabledPlugins sets g.app.config.enabledPluginsFileName</t>
<t tx="ekr.20090324085713.672">p.b, p.h and p.gnx
t.b, t.h, t.gnx and t.u
v.b, v.h, v.gnx, and v.u</t>
<t tx="ekr.20090324085713.688"></t>
<t tx="ekr.20090324085713.689">c.config.getSettingSource('show_full_tracebacks_in_scripts')
returns the name of the file which Leo used to determine the setting

- D indicates default settings.
- F indicates the file being loaded
- L indicates leoSettings.leo
- M indicates myLeoSettings.leo</t>
<t tx="ekr.20090324085713.690"></t>
<t tx="ekr.20090324085713.691"></t>
<t tx="ekr.20090324085713.726">http://groups.google.com/group/leo-editor/browse_thread/thread/d6449236bc140713#

Added support for @string default_leo_file = ~/.leo/workbook.leo</t>
<t tx="ekr.20090324085713.732">http://groups.google.com/group/leo-editor/browse_thread/thread/f1c7c5134b95c77e
</t>
<t tx="ekr.20090324085713.740"># Useful: we don't need a closing @color to enable coloring in descendants.</t>
<t tx="ekr.20090324085713.745">http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7</t>
<t tx="ekr.20090324085713.746">http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1</t>
<t tx="ekr.20090324085713.747"></t>
<t tx="ekr.20090324085713.748">@string underindent-escape-string = \-</t>
<t tx="ekr.20090324085713.792">http://groups.google.com/group/leo-editor/browse_thread/thread/c80fd8375534afdf</t>
<t tx="ekr.20090324085713.814">Changed config.get so that settings in leoSettings.leo are read *last*.
This means that myLeoSettings.leo will override leoSettings.leo,
even when leoSettings.leo is the local file.</t>
<t tx="ekr.20090324085713.817">http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626

The open file dialog now shows all files by default.
Selecting a non-.leo file will load that file into a new node in the present outline.

This plugs what may have been the biggest hole in Leo's history.
</t>
<t tx="ekr.20090324085713.835">Only .zip and .leo extensions are allowed at present.</t>
<t tx="ekr.20090324085713.836">This works, but stops Leo in the middle of the command-handling logic.

However, it is possible to pick up the commander by stepping out into
k.masterKeyHandler or k.masterCommandHandler. Using c, one can then get all
other info.</t>
<t tx="ekr.20090324085713.837">- Tab = indent when there is a text selection
- Shift-Tab unindents always</t>
<t tx="ekr.20090324085713.847">Escape now ends isearch
</t>
<t tx="ekr.20090324085713.848"></t>
<t tx="ekr.20090324085713.849">@nocolor

The setting is called -c or --config.  The one-config-file arg no longer exists.

http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

Personally, I'd like to see another config file available via -c on
the command line:
(a common idiom)

leo myproject.leo -c /usr/lib/myproject/myLeoSettings.leo

or better yet:

leo myproject.leo -c /etc/leo/style01.leo
leo myotherproject.leo -c /etc/leo/style02.leo
leo anotherproject.leo -c /etc/leo/style23.leo

Each file opens in an editor with the shortcuts, buttons, commands,
plugins, appearance etc.  that has been tuned for that data management task.

or best yet:

leo myproject.leo -c /usr/lib/python2.5/site-packages/leo/config/style94.leo

==================

http://groups.google.com/group/leo-editor/browse_thread/thread/b5a736089079acaf#

Please, I think each file has a distinct and required role.

- config/leoSettings.leo = Edward's base, required for a sane starting point

- home/.leo/myLeoSettings.leo = adjust Edwards suggestions to taste

- cwd/myLeoSettings.leo = provide a customized working environment in
this folder

- leo -c /usr/lib/leo-editor/src/config/zope3_ide.leo =
  - open this file in a specialized environments, mine or community contributed
  - ...

- currentfile/@settings =
  - I'm working on some customization ideas
  - Here, try out this Leo file I sent you, check out all the spiffy
modifications 

@color</t>
<t tx="ekr.20090324085713.850"></t>
<t tx="ekr.20090324085713.867"></t>
<t tx="ekr.20090324085713.868"></t>
<t tx="ekr.20090324085713.869"></t>
<t tx="ekr.20090324085713.881"></t>
<t tx="ekr.20090324085713.890">This contains all gui plugins.</t>
<t tx="ekr.20090324105223.10"></t>
<t tx="ekr.20090324105223.15"></t>
<t tx="ekr.20090324105223.9"></t>
<t tx="ekr.20090324145450.20"></t>
<t tx="ekr.20090324145450.21">#######################################
What's New in Leo 4.6
#######################################

.. .. contents::</t>
<t tx="ekr.20090324145450.22">.. Links used in this document.
.. .. _`Chapter 23`:           atShadow.html
</t>
<t tx="ekr.20090324145450.23">- Leo opens a default .leo file if no other is specified, using the @string
  default_leo_file setting. The default for this setting is
  ~/.leo/workbook.leo

- Added escapes for underindented lines. The escape is specified by the @string
  underindent-escape-string setting. By default, this escape is \- If a line
  starts with \-N, Leo will write the line with N fewer spaces than expected.

- Leo now warns when attempting to write a file that has been changed outside of
  Leo. This prevents bzr reversions.

- Leo tests syntax of .py files when saving them.

- Leo can now open any file into an @edit node. This allows Leo to be associated
  with the edit action of .py files. Like this::

    C:\Python26\python.exe "c:\leo.repo\trunk\launchLeo.py" --gui=qt %1 %2

- Leo now warns if when writing an @auto node if the the file exists and the
  node has not been read previously.  This prevents a newly-created
  @auto node from overwriting an existing file.
</t>
<t tx="ekr.20090324145450.27">- Added autoCompleter.getExternalCompletions.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac

- Added g.posList.

- c.config.doEnabledPlugins sets g.app.config.enabledPluginsFileName

- Added the following properties:
    - p.b, t.b and v.b return the body string of the position or node.
    - p.h, t.h and v.h return the head string of the position or node.
    - t.u and v.u return the uA of the node.
    - p.gnx, t.gnx and v.gnx return the gnx of the position or node.

- Added script to leoSettings.leo to ensure all menu items are valid.

- c.config.getSettingSource(setting_name)
  returns the name of the file which Leo used to determine the setting:

    - D indicates default settings.
    - F indicates the file being loaded
    - L indicates leoSettings.leo
    - M indicates myLeoSettings.leo

- Predefined 'self' in @test/@suite nodes.

- Added c.getNodePath and c.getNodeFileName.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7
</t>
<t tx="ekr.20090324145450.36">- The --config command-line option specifies a single config (.leo) file
  to use for configuration.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

- The --file=fileName command-line option load a file.
  Only .zip and .leo extensions are allowed at present.

- The --gui=name command-line option specifies the gui to use.
  The valid values are --gui=qt, --gui=tk
</t>
<t tx="ekr.20090324145450.40">- Added smart home (back-to-home) command.

- Added support for standard behavior of Tab and Shift-Tab keys.
  The tab key indents the text selection, if there is one;
  otherwise, the tab key insert a tab or blanks, depending on the @tabwidth setting.
  Shift-Tab always unindents one or more lines.

- The open command creates @edit nodes when opening non-.leo files
  The open file dialog now shows all files by default.
  Selecting a non-.leo file will load that file into a new node in the present outline.

- Added added pdb minibuffer command.
  This works, but stops Leo in the middle of the command-handling logic.
  You may get the commander c by stepping out into
  k.masterKeyHandler or k.masterCommandHandler.
  Using c, you can then get all other info.

- Improved the isearch commands.

- find-clone-all is a synonym for clone-find-all.

- open-quickstart-leo command opens leo/doc/quickstart.leo.

- The Alt-Right and Alt-Left keys (expand-and-go-right and contract-or-go-left
  commands) now move to the previous or next node if now left/right movement is
  possible.
</t>
<t tx="ekr.20090324145450.46">- Added @nocolor-node directive.

- Improved \@path handling.
</t>
<t tx="ekr.20090324145450.49">- @string default_leo_file = ~/.leo/workbook.leo

- @string underindent-escape-string = \-

- @int icon_bar_widgets_per_row

- Added support for meta keys.
  http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1

- The qt gui is now the default.

- The old bindings bound the PageUp/Down keys to back/forward page commands, and
  these commands work only for text.

  The new default bindings in leoSettings.leo: @keys EKR bindings are::

    back-page                       ! text = PageUp
    back-page-extend-selection      ! text = Shift-PageUp
    forward-page                    ! text = PageDn
    forward-page-extend-selection   ! text = Shift-PageDn

    scroll-down-half-page   ! tree = Shift-PageDn
    scroll-down-page        ! tree = PageDn
    scroll-up-half-page     ! tree = Shift-PageUp
    scroll-up-page          ! tree = PageUp    

- @bool enable_alt_ctrl_bindings.
  The default is False, needed for AltGr functionality on Windows.
</t>
<t tx="ekr.20090324145450.54">- Improved nav_buttons plugin and corresponding nodeHistory class.

- Created qtGui and tkGui plugins.

- Created leoGuiPluginsRef.leo.

- Leo issues an error message if a non-existent plugin appears
  in an @enabled-plugin node.
  
- New plugins: spydershell.py, qtframecommands.py, and mod_framesize.py.</t>
<t tx="ekr.20090401113141.1">To generate .odt or .rtf or .pdf files, you create an intermediate file and
ignore the the "official" output file, in this case test.html. The intermediate
file contains the rST text corresponding to the @rst tree.

To tell the rst3 plugin to generate an intermediate file, do::

    write_intermediate_file = True

After you create the intermediate file, in this case, test.html.txt,
You can create an odt file as follows::

    python &lt;path-to-python&gt;/scripts/rst2odt.py test.html.txt test.odt

I a batch file, rst2odt.bat, like this:

    rst2odt test

Note that rst3odt.py is in the tools directory of the DocUtils distribution.

To generate .rtf, you can use PanDoc to convert test.html.txt to RTF.

To generate .pdf files, you would first convert test.html.txt to LaTeX::

    python rst2newlatex.py test.html.txt test.tex

    -- OR --

    cd leo\docs\html
    make latex

You can then use one of the LaTeX to .pdf converters to create the final .pdf
file. See http://docutils.sourceforge.net/docs/user/latex.html#pdf-generation
for details.
</t>
<t tx="ekr.20090401113141.2">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

====
Test
====

This is a test.</t>
<t tx="ekr.20090401113141.4">This is section 1</t>
<t tx="ekr.20090428101858.1">1. doc\html\conf.py contains settings,
including the name of the master toctree document, leo_toc.html.txt.

2. leo_toc.html.txt contains a list of all file to be included.

3. To create one or more docs:

    - From this file, run rst3 on desired tree.
    - cd leo\doc\html
    - make html

4. To create pdf (probably easiest on Linux, with necessary latex packages installed):

    - make latex
    - cd _build/latex
    - make all-pdf
</t>
<t tx="ekr.20090501091345.2"></t>
<t tx="ekr.20090501093330.1"></t>
<t tx="ekr.20090501093330.2"></t>
<t tx="ekr.20090501093330.3"></t>
<t tx="ekr.20090501093330.4"></t>
<t tx="ekr.20090501093330.5"></t>
<t tx="ekr.20090501093330.6"></t>
<t tx="ekr.20090501093330.7"></t>
<t tx="ekr.20090526102407.10028"></t>
<t tx="ekr.20090526102407.10029">To gather statistics, do the following in a console window, not idle::

    &gt; python
    &gt;&gt;&gt; import leo
    &gt;&gt;&gt; import leo.core.runLeo as r
    &gt;&gt;&gt; r.prof()  (this runs leo)
    load any .leo file from Leo
    quit Leo

Intermediate data is written to cwd.leoProfile.txt.
The statistics are written to stdout.
</t>
<t tx="ekr.20090526102407.10030">I've often said that I don't remember many details about Leo. This documentation
describes what I *do* remember about Leo's various modules. I hope this will be
useful to potential readers, users and modifiers of Leo's code.

In general, if you want to understand the code, read through it quickly, looking
for pieces of code that are unexpected complex, or unexpectedly simple. Forget
the details; remember the shape. Once you have the general shape in mind, you
are ready to modify the code. No kidding. Besides, more reading won't help :-)</t>
<t tx="ekr.20090526102407.10031">In general, write code is much simpler than read code,
because reading requires parsing. There are a few exceptions below.

leoFileCommands.py contains the code that reads and writes .leo files.

- This file uses the sax parser to parse the xml in .leo files.
- Complex code, driven by sax, turns sax nodes into Leo nodes.
- The putVnode method is "interesting".  Take a look.
  In the past, there have been significant, surprising bottlenecks in
  putVnode and maybe putTnode as well.  No longer.

leoAtFileCommands.py contains the code that reads and writes external files.

- There are options to read and write strings.
  These are useful for performance and for unit testing.
- atFile.replaceTargetFileIfDifferent is an important optimization.
- There are a lot of read/write commands for external files,
  and this results in lots of options being passed around.

Initing is tricky for both leoFileCommands.py and leoAtFileCommands.py.

- The bizarre call to initReadIvars() at the end of getLeoFile is one
  symptom of the difficulties.
- Never change init code without careful thought and unit testing.</t>
<t tx="ekr.20090526102407.10032">I. Background

Leo has had a robust MVC (Model,View,Controller) architecture from day one.

Leo's model are the classes in leoNodes.py. They are completely independent from
the rest of Leo. Many parts of Leo *use* these classes, but not vice versa!

Leo's controller is everything else in 'Code--&gt;Core classes'. This code has *no*
direct dependencies on Leo's gui code, as will be explained next.

Leo's view has two parts:

1. The classes in the tree 'Code--&gt;Gui Base classes'.
   These are part of Leo's core.

2. The classes in the tree 'Code--&gt;Gui Tkinter classes'.
   These are essentailly a gui plugin.

Leo's core consists of the Model, Controller and the gui base classes.


II. Why Leo's core is gui-independent

Leo uses a completely standard way of separating gui-dependent code from
gui-independent code. Base gui classes (part 1 of the view) define an interface
used by Leo's core. Subclasses (part 2 of the view) implement the interface for
a particular gui.

** Subclasses can change without affecting Leo's code in any way.**

The essential design rule is: if gui-related code can be made gui- independent,
it should be part of a base class. Otherwise it must be part of a subclass of a
base gui class.

The gui base classes are far more than do-nothing interfaces. Examples of
complex code that reside in base classes:

A. tree.select. I am proud that this method is gui-independent. Switching nodes
is a very tricky business. Making it gui-independent is a big win.

B. leoFind.py. Finds the next/previous matches, and dealing with an "idealized"
find tab. Adapter classes exist in leoEditCommands.py.

C. Autocompletion and minibuffer code in leoKeys.py. For comparison, look how
simple leoTkinterKeys.py is.

D. A generalized, gui-independent interface to Leo's body pane. The commands in
leoEditCommands.py (part of the controller) use this interface (baseTextWidget)
rather than calling Tk directly.

**If you want to understand Leo's design, study Leo's base gui classes.**
</t>
<t tx="ekr.20090620073906.11072">Leo 4.6 beta 2                                  June 22, 2009

Leo 4.6 b2 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.6:
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes support "round-tripping" of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20090620073906.11073"></t>
<t tx="ekr.20090620073906.11074"></t>
<t tx="ekr.20090620073906.11081">https://bugs.launchpad.net/leo-editor/+bug/367462

The expected/customary behaviour (one you get used to in almost every editor) is:

End: always move to end of line
Home: Move to first visible chararacter on the line. When pressing home again, move to column zero. If Home is pressed one more time, move to first visible character again.

This is also the way emacs behaves, though ctrl+a always moves to column zero.</t>
<t tx="ekr.20090620073906.11083">A patch at the start of loadOnePlugin prevents leo from crashing and allows the
gui prompt for a leoID to come up.</t>
<t tx="ekr.20090620073906.11086">http://mail.google.com/mail/#inbox/11ef0076a3f4d866</t>
<t tx="ekr.20090620073906.11087">This is reasonable now that old-style file indices are rare.</t>
<t tx="ekr.20090620073906.11091">exception loading plugin
Traceback (most recent call last):

  File "C:\leo.repo\trunk\leo\core\leoPlugins.py", line 429, in loadOnePlugin
    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName

AttributeError: StubConfig instance has no attribute 'enabledPluginsFileName'

leoID='ekr'
.leoID.txt created in C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo
load </t>
<t tx="ekr.20090620073906.11094">The problem is imports in the Commands ctor. When executed the first time from
the bridge the imports take about 3/4 sec. on my machine. There is nothing that
can or should be done. Ctrl-5 is still hugely faster than opening unitTest.leo!</t>
<t tx="ekr.20090620073906.11107">onTextChanged in the qt gui was calling setUndoTypingParams, in many case
redundently and with bad params.

It remains to be seen whether onTextChanged is ever needed. If it is, it may be
difficult to set the old selection properly.</t>
<t tx="ekr.20090620073906.11137">Added call to isFKey in k.handleUnboundKeys.
</t>
<t tx="ekr.20090620073906.11296">- Removed forceGnxOnPosition from leoImport.py and leoAtFile.py.

- readStartNode now always uses root.v for the first node
  instead of calling createThinChild4</t>
<t tx="ekr.20090620073906.11349"></t>
<t tx="ekr.20090620073906.11352">The outline wasn't being redrawn properly.</t>
<t tx="ekr.20090620073906.11374"></t>
<t tx="ekr.20090620073906.11376">http://bugs.launchpad.net/leo-editor/+bug/376634

The fix was to putVnodes.</t>
<t tx="ekr.20090620073906.11377">http://bugs.launchpad.net/leo-editor/+bug/306671

If a Leo editor window is opened, and the "NewHeadline" node is renamed to
"@auto &lt;path to some valid file&gt;", and then the "File-&gt;Read/Write-&gt;Read @auto
nodes" menu option is selected, the renamed node reverts to its previous name
("NewHeadline"), and nothing is loaded into the node.</t>
<t tx="ekr.20090620073906.11378">http://bugs.launchpad.net/leo-editor/+bug/353925

The "kill-region" function did nothing when using the qt gui.

The fix was to replace tag_ranges with w.getSelectionRange, etc.
This was the only call to tag_ranges in the core.</t>
<t tx="ekr.20090620073906.11380">http://bugs.launchpad.net/leo-editor/+bug/362048

I have 'dabbrev-expands' bound to the F4 key. When I press F4 after
the word "freq" in a body pane containing the word "frequency" then
Leo 4.5.1 shows a hour-glass for a while before giving an empty
dabbrev-expand: prompt in the minibuffer.

If I back up one character, putting point between the e and q and then
type F4, I get the expected behavior: the word "frequency" is inserted
immediately.

What I did:

- Removed "not ready messages".
- Made the code undoable.
- Added wimpy unit test.</t>
<t tx="ekr.20090620073906.11387">http://bugs.launchpad.net/leo-editor/+bug/376189</t>
<t tx="ekr.20090620073906.11390"></t>
<t tx="ekr.20090620073906.11521">The problem arose when reading a zipped file:

 File "C:\Programme\Leo-4-6-b1\leo\core\leoFileCommands.py", line
1265, in parse_leo_file
   s = theFile.read()
TypeError: read() takes at least 2 arguments (1 given)
saved: [zipped] Dive-into-Python-3.leo
</t>
<t tx="ekr.20090620073906.11564">http://groups.google.com/group/leo-editor/browse_thread/thread/6cab5e676d4d75a0</t>
<t tx="ekr.20090620073906.11590"></t>
<t tx="ekr.20090620073906.11612"></t>
<t tx="ekr.20090620073906.11620"></t>
<t tx="ekr.20090620073906.11666"></t>
<t tx="ekr.20090620073906.11707">http://bugs.launchpad.net/leo-editor/+bug/363403

With a long body text you might place the cursor on a line, hold down Shift, and
PgDn several pages to select a large block of text. The last PgDn may overshoot
the range you want selected, so you should be able to use UpArrow to bring the
bottom of the range back up to where you want it. However, on the first UpArrow
the selection is lost and restarted from the current cursor position. I.e. you
end up with just one line selected, instead of trimming one line of the
selection of several pages, as intended.
</t>
<t tx="ekr.20090620073906.11740">http://groups.google.com/group/leo-editor/browse_thread/thread/430287018f9d773d

The fix to minibufferFind.changeAll fixes a bug that is several years old.
The fix to findNextMatch fixes a bug that is likely much older than that.</t>
<t tx="ekr.20090620073906.11759">http://bugs.launchpad.net/leo-editor/+bug/377907

I'm going to mark this invalid, although the behavior is way too confusing.

I added the following to the plugin's docstring:

Configuration
~~~~~~~~~~~~~

At present, the file leo/plugins/leo_to_html.ini contains configuration settings.
In particular, the default export path, "c:\" must be changed for *nix systems.
</t>
<t tx="ekr.20090620073906.11760">The crash happened inside the call to::

    c.widgetWantsFocusNow(event.widget)

in callAltXFunction. Actually, the crash happened later, in c.outerUpdate.

A better fix would be to use wrappers for all edit widgets, and recalculate the
edit widget any it needs to be used.</t>
<t tx="ekr.20090620073906.11771">http://groups.google.com/group/leo-editor/browse_thread/thread/a04dcefbb672078f</t>
<t tx="ekr.20090620073906.11776">http://bugs.launchpad.net/leo-editor/+bug/382221
</t>
<t tx="ekr.20090620073906.11818"></t>
<t tx="ekr.20090620073906.11824"></t>
<t tx="ekr.20090620073906.11833"></t>
<t tx="ekr.20090620073906.11850">The generated @nocolor line now ends with a newline.</t>
<t tx="ekr.20090620073906.11864">http://groups.google.com/group/leo-editor/browse_thread/thread/21bddd50f3400bdc?hl=en</t>
<t tx="ekr.20090620073906.11865">http://groups.google.com/group/leo-editor/browse_thread/thread/981c27d5c24c90f8</t>
<t tx="ekr.20090620073906.11866">http://groups.google.com/group/leo-editor/browse_thread/thread/606277d73b193037</t>
<t tx="ekr.20090620073906.11870"></t>
<t tx="ekr.20090620073906.11873">- leoDynamicTest.py now supports a --path argument giving the .leo file.
  This is so useful!

- leoDynamicTest.py now honors the --silent argument.

- leoTest.runUnitTestLeoFile runs all unit tests in a given .leo file
  in a separate process.

- leoTest.runTestsExternally calls runUnitTestLeoFile after creating
  dynamicUnitTest.leo.

- When reporting that no unit tests were found, all unit tests commands tell
  whether the entire outline or just the selected outline was searched.
  This fixes sometimes-misleading error messages.

- test.leo contains a 'run-test.leo-tests' button.

- leoPy.leo contains a 'run-all-core-tests' button.</t>
<t tx="ekr.20090620073906.11898"></t>
<t tx="ekr.20090620073906.11923">Leo can now open, for example, any .py file.
It will be put in an @edit node in an otherwise-empty outline.

This allows Leo to be associated with the edit action of .py files.
Something like this::

C:\Python26\python.exe "c:\leo.repo\trunk\launchLeo.py" --gui=qt %1 %2</t>
<t tx="ekr.20090620073906.11935"></t>
<t tx="ekr.20090620073906.11960">Html files are a good test case.</t>
<t tx="ekr.20090620073906.11973"></t>
<t tx="ekr.20090620073906.11981"></t>
<t tx="ekr.20090620073906.12044">http://bugs.launchpad.net/leo-editor/+bug/383204</t>
<t tx="ekr.20090620073906.12061"></t>
<t tx="ekr.20090620073906.12095">- leoDynamicTest.py now supports a --path argument giving the .leo file.
  This is so useful!

- leoDynamicTest.py now honors the --silent argument.

- leoTest.runUnitTestLeoFile runs all unit tests in a given .leo file
  in a separate process.

- leoTest.runTestsExternally calls runUnitTestLeoFile after creating
  dynamicUnitTest.leo.

- When reporting that no unit tests were found, all unit tests commands tell
  whether the entire outline or just the selected outline was searched.
  This fixes sometimes-misleading error messages.

- test.leo contains a 'run-test.leo-tests' button.

- leoPy.leo contains a 'run-all-core-tests' button.</t>
<t tx="ekr.20090620082840.5608">Added support for @auto-rst nodes. These import reStructuredText (rST) files
so that the files can be "round-tripped" without introducing extraneous changes.
This makes Leo a superb environment for using rST.
</t>
<t tx="ekr.20090620103431.5601">The @verbatim was being inserted into the outline.
</t>
<t tx="ekr.20090620131445.5595">I just tweaked conf.py a bit to enable pdf generation.

Howto:

QQQ

4. To create pdf (probably easiest on Linux, with necessary latex
packages installed):

- make latex
- cd _build/latex
- make all-pdf

QQQ

There were several errors in the pdf generation process. Notably,
there are probably lots of unicode errors (and toc doesn't appear).
Nevertheless, you can steal a peek at the doc here:

http://vvtools.googlecode.com/files/Leodocumentation.pdf </t>
<t tx="ekr.20090622091845.5623">Installing Leo on MacOS 10.5 (Leopard) is straightforward.

1. MacOS 10.5 comes with Python pre-installed.
   See http://www.python.org/download/mac/ and
   http://wiki.python.org/moin/MacPython/Leopard
   for information about using the latest version of Python.

2. Download and install bzr:

   - Download bzr from http://bazaar-vcs.org/Download

   - Install bzr using the file just downloaded.

3. Get Leo's sources from Leo's trunk::

    cd ~
    mkdir leo.repo
    cd leo.repo
    bzr init
    bzr branch lp:leo-editor
    cd leo-editor

4. You can run the tk version of Leo as follows::

    python launchLeo.py --gui=tk

5. If you already have Qt and PyQt installed, you can run the qt version of Leo as follows::

    python launchLeo.py --gui=qt

6. If you don't have Qt or PyQt installed, you will have to install Qt and PyQt
    from sources. There does not seem to be any pre-built binaries.

    A: You may need to install XCode from http://developer.apple.com/mac/
       in order to get a development environment.

    B: Download and install the sip package, following the direction at
       http://www.riverbankcomputing.co.uk/software/sip/download

    C: Download the OpenSource Qt libraries for Mac from
       http://www.qtsoftware.com/downloads

    D: At various points along the way you will need to build the sources::

         python configure.py 
         make
         sudo make install
</t>
<t tx="ekr.20090705111443.10370">Leo sends more detailed error messages to stderr,
the output stream that goes to the console window. In Linux and MacOS
environments, python programs normally execute with the console window visible.
On Windows, can run Leo with the console window visible by associating .leo
files with python.exe *not* pythonw.exe. 

.. For full instructions about how
.. to do this, see `Associating Leo with .leo Files`_.</t>
<t tx="ekr.20090706042206.14718">Leo's sentinels add outline structure to source files.
However, those sentinels annoy some people who don't use Leo.

You can use @auto, @shadow or @nosent trees to edit
files that are shared with those who don't want to see sentinel comments.

- @auto is best for files whose imported outline structure often changes. In
  most cases, this will be the best option. The drawback of @auto files are a)
  you can't use clones and b) you can't add your own organizer nodes.

- @shadow will work for files whose outline structure seldom changes.
  The advantage of @shadow is that you can add your own structure.

- @nosent is appropriate only for files that you alone modify.
</t>
<t tx="ekr.20090709084001.5944">Leo 4.6 release candidate 1                             July 9, 2009

Leo 4.6 rc1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.6:
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes allow easy editing of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20090709084001.5945"></t>
<t tx="ekr.20090709084001.5946">- There was a blunder in standardize_name.
- Inited print_mode in tangle.scanAllDirectives.
- Changed .default_directory to .tangle_directory throughout leoTangle.py.

</t>
<t tx="ekr.20090709084001.5968"></t>
<t tx="ekr.20090709084001.6086"></t>
<t tx="ekr.20090709084001.6096"></t>
<t tx="ekr.20090709084001.6119"></t>
<t tx="ekr.20090709084001.6138"></t>
<t tx="ekr.20090709084001.6140"></t>
<t tx="ekr.20090709084001.6144"></t>
<t tx="ekr.20090709084001.6149"></t>
<t tx="ekr.20090709084001.6153">Various get-focus methods must translate from wrapped widget to wrapper widget.
This happens in g.app.gui.get_focus, which needs a c arg to work properly in some cases!</t>
<t tx="ekr.20090709084001.6156"></t>
<t tx="ekr.20090709084001.6164">https://bugs.launchpad.net/leo-editor/+bug/345917</t>
<t tx="ekr.20090709084001.6192">Exact repro steps (using trunk):

Help -&gt; open quickstart.leo

Go to Programming--&gt;External files--&gt;reStructuredText (@auto-
rst)--&gt;@path ~--&gt;@@auto-rst myfile_rst.txt

Remove first @ from @auto-rst

Save =&gt; exception occurs.</t>
<t tx="ekr.20090709084001.6204">@test nodes in the generated file were being run when modules were imported.

The fix was to set g.unitTesting = False while importing in safeImportModule.</t>
<t tx="ekr.20090709084001.6238"></t>
<t tx="ekr.20090709084001.6241"></t>
<t tx="ekr.20090709084001.6254">@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/394965

Several changes:

- Fixed bug in runLeo.py.completeFileName.
  Do not add ".leo" suffix if the file exists without it!

- Fixed (???) the bug by not calling g.doHook("new"...) in g.openWrapperFile.
  This **might** be a perfect fix, but maybe not.
  But if a bug remains, it might be less bad than the duplicated buttons bug :-)</t>
<t tx="ekr.20090709084001.6283">The culprit was the code in atFile.read that deleted all children.

Added several important new unit tests.</t>
<t tx="ekr.20090709084001.6291">Also added test for leoQtBody to existing test.</t>
<t tx="ekr.20090709084001.6296"></t>
<t tx="ekr.20090709084001.6297"></t>
<t tx="ekr.20090709084001.6300">This was a binding issue. Leo has a full range of scrolling commands. They work.

The old bindings bound the PageUp/Down keys to back/forward page commands, and
these commands work only for text.

The new default bindings in leoSettings.leo: @keys EKR bindings are:

back-page                       ! text = PageUp
back-page-extend-selection      ! text = Shift-PageUp
forward-page                    ! text = PageDn
forward-page-extend-selection   ! text = Shift-PageDn

scroll-down-half-page   ! tree = Shift-PageDn
scroll-down-page        ! tree = PageDn
scroll-up-half-page     ! tree = Shift-PageUp
scroll-up-page          ! tree = PageUp         
</t>
<t tx="ekr.20090709084001.6301">Leo now prints an error message when @enabled-plugins node contains a plugin
that does not exist.</t>
<t tx="ekr.20090709084001.6304"></t>
<t tx="ekr.20090709084001.6307">Warn if the file exists and has never been read. This prevents a newly-created
@auto node from overwriting an existing file.</t>
<t tx="ekr.20090709084001.6308">def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    c = self
    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        # g.trace('no stamp for %s' % (fn))
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        return True

    if g.app.unitTesting:
        return False

    # g.trace(timeStamp, timeStamp2)
    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)
    return ok == 'yes'
</t>
<t tx="ekr.20090709084001.6309">def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    try:
        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(p, fileContent)
    except IOError:
        cachefile = None

    if cachefile is not None and cachefile in c.db:        
        # g.es('uncache:',p.h)
        tree = c.db[cachefile]
        g.create_tree_at_vnode(c, p.v, tree)
        p.v.at_auto_read = True # Create the attribute
        return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)
    p.v.at_auto_read = True # Create the attribute

    if ic.errors:
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        # c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        self.writeCachedTree(p, cachefile)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
</t>
<t tx="ekr.20090709084001.6310">def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName and not toString: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # Prompt if writing a new @auto node would overwrite an existing file.
    if not hasattr(p.v,'at_auto_read') and g.os_path_exists(fileName):
        ok = self.promptForAtAutoRead(fileName)
        if ok:
            p.v.at_auto_read = True # Create the attribute
        else:
            g.es("not written:",fileName)
            return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"&lt;string-file&gt;",fileName)
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        if root.isAtAutoRstNode():
            c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
        else:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        if at.errors == 0:
            at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",at.outputFileName)
            root.setDirty() # New in Leo 4.4.8.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("not written:",at.outputFileName)

    return ok
</t>
<t tx="ekr.20090709084001.6311">@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
</t>
<t tx="ekr.20090709084001.6312">def promptForAtAutoRead (self,fileName):

    c = self.c

    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForAtAutoRead')
        return val in (None,True)

    # g.trace(timeStamp, timeStamp2)
    message = '@auto %s\n%s\n%s' % (
        fileName,
        g.tr('already exists.'),
        g.tr('Overwrite this file?'))

    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite existing file?',
        message = message)

    return ok == 'yes'
</t>
<t tx="ekr.20090711120622.10446">@language rest
</t>
<t tx="ekr.20090711120622.10447">################
Leo screen shots
################

</t>
<t tx="ekr.20090712122931.10453"></t>
<t tx="ekr.20090717084250.10702"></t>
<t tx="ekr.20090717084250.10704"></t>
<t tx="ekr.20090717084250.10808">Leo 4.6 final                             July 15, 2009

Leo 4.6 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.6:
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes allow easy editing of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20090717084250.10809"></t>
<t tx="ekr.20090717084250.10810"></t>
<t tx="ekr.20090717084250.10811">A patch at the start of loadOnePlugin prevents leo from crashing and allows the
gui prompt for a leoID to come up.</t>
<t tx="ekr.20090717084250.10812">This is reasonable now that old-style file indices are rare.</t>
<t tx="ekr.20090717084250.10813">Html files are a good test case.</t>
<t tx="ekr.20090717084250.10814"></t>
<t tx="ekr.20090717084250.10815">http://bugs.launchpad.net/leo-editor/+bug/376634

The fix was to putVnodes.</t>
<t tx="ekr.20090717084250.10816"></t>
<t tx="ekr.20090717084250.10817">http://bugs.launchpad.net/leo-editor/+bug/383204</t>
<t tx="ekr.20090717084250.10818">http://groups.google.com/group/leo-editor/browse_thread/thread/981c27d5c24c90f8</t>
<t tx="ekr.20090717084250.10819">The generated @nocolor line now ends with a newline.</t>
<t tx="ekr.20090717084250.10820">http://groups.google.com/group/leo-editor/browse_thread/thread/6cab5e676d4d75a0</t>
<t tx="ekr.20090717084250.10821">- Removed forceGnxOnPosition from leoImport.py and leoAtFile.py.

- readStartNode now always uses root.v for the first node
  instead of calling createThinChild4</t>
<t tx="ekr.20090717084250.10822">https://bugs.launchpad.net/leo-editor/+bug/367462

The expected/customary behaviour (one you get used to in almost every editor) is:

End: always move to end of line
Home: Move to first visible chararacter on the line. When pressing home again, move to column zero. If Home is pressed one more time, move to first visible character again.

This is also the way emacs behaves, though ctrl+a always moves to column zero.</t>
<t tx="ekr.20090717084250.10823">The @verbatim was being inserted into the outline.
</t>
<t tx="ekr.20090717084250.10824"></t>
<t tx="ekr.20090717084250.10825"></t>
<t tx="ekr.20090717084250.10826">The problem arose when reading a zipped file:

 File "C:\Programme\Leo-4-6-b1\leo\core\leoFileCommands.py", line
1265, in parse_leo_file
   s = theFile.read()
TypeError: read() takes at least 2 arguments (1 given)
saved: [zipped] Dive-into-Python-3.leo
</t>
<t tx="ekr.20090717084250.10827">exception loading plugin
Traceback (most recent call last):

  File "C:\leo.repo\trunk\leo\core\leoPlugins.py", line 429, in loadOnePlugin
    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName

AttributeError: StubConfig instance has no attribute 'enabledPluginsFileName'

leoID='ekr'
.leoID.txt created in C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo
load </t>
<t tx="ekr.20090717084250.10828">http://bugs.launchpad.net/leo-editor/+bug/362048

I have 'dabbrev-expands' bound to the F4 key. When I press F4 after
the word "freq" in a body pane containing the word "frequency" then
Leo 4.5.1 shows a hour-glass for a while before giving an empty
dabbrev-expand: prompt in the minibuffer.

If I back up one character, putting point between the e and q and then
type F4, I get the expected behavior: the word "frequency" is inserted
immediately.

What I did:

- Removed "not ready messages".
- Made the code undoable.
- Added wimpy unit test.</t>
<t tx="ekr.20090717084250.10829"></t>
<t tx="ekr.20090717084250.10830">Added call to isFKey in k.handleUnboundKeys.
</t>
<t tx="ekr.20090717084250.10831">http://bugs.launchpad.net/leo-editor/+bug/376189</t>
<t tx="ekr.20090717084250.10832">http://bugs.launchpad.net/leo-editor/+bug/382221
</t>
<t tx="ekr.20090717084250.10833">http://bugs.launchpad.net/leo-editor/+bug/363403

With a long body text you might place the cursor on a line, hold down Shift, and
PgDn several pages to select a large block of text. The last PgDn may overshoot
the range you want selected, so you should be able to use UpArrow to bring the
bottom of the range back up to where you want it. However, on the first UpArrow
the selection is lost and restarted from the current cursor position. I.e. you
end up with just one line selected, instead of trimming one line of the
selection of several pages, as intended.
</t>
<t tx="ekr.20090717084250.10834">http://bugs.launchpad.net/leo-editor/+bug/306671

If a Leo editor window is opened, and the "NewHeadline" node is renamed to
"@auto &lt;path to some valid file&gt;", and then the "File-&gt;Read/Write-&gt;Read @auto
nodes" menu option is selected, the renamed node reverts to its previous name
("NewHeadline"), and nothing is loaded into the node.</t>
<t tx="ekr.20090717084250.10835">http://groups.google.com/group/leo-editor/browse_thread/thread/21bddd50f3400bdc?hl=en</t>
<t tx="ekr.20090717084250.10836">The outline wasn't being redrawn properly.</t>
<t tx="ekr.20090717084250.10837">http://groups.google.com/group/leo-editor/browse_thread/thread/430287018f9d773d

The fix to minibufferFind.changeAll fixes a bug that is several years old.
The fix to findNextMatch fixes a bug that is likely much older than that.</t>
<t tx="ekr.20090717084250.10838"></t>
<t tx="ekr.20090717084250.10839"></t>
<t tx="ekr.20090717084250.10840">http://mail.google.com/mail/#inbox/11ef0076a3f4d866</t>
<t tx="ekr.20090717084250.10841">The crash happened inside the call to::

    c.widgetWantsFocusNow(event.widget)

in callAltXFunction. Actually, the crash happened later, in c.outerUpdate.

A better fix would be to use wrappers for all edit widgets, and recalculate the
edit widget any it needs to be used.</t>
<t tx="ekr.20090717084250.10842"></t>
<t tx="ekr.20090717084250.10843">http://groups.google.com/group/leo-editor/browse_thread/thread/606277d73b193037</t>
<t tx="ekr.20090717084250.10844"></t>
<t tx="ekr.20090717084250.10845">onTextChanged in the qt gui was calling setUndoTypingParams, in many case
redundently and with bad params.

It remains to be seen whether onTextChanged is ever needed. If it is, it may be
difficult to set the old selection properly.</t>
<t tx="ekr.20090717084250.10846">http://bugs.launchpad.net/leo-editor/+bug/353925

The "kill-region" function did nothing when using the qt gui.

The fix was to replace tag_ranges with w.getSelectionRange, etc.
This was the only call to tag_ranges in the core.</t>
<t tx="ekr.20090717084250.10847">http://bugs.launchpad.net/leo-editor/+bug/377907

I'm going to mark this invalid, although the behavior is way too confusing.

I added the following to the plugin's docstring:

Configuration
~~~~~~~~~~~~~

At present, the file leo/plugins/leo_to_html.ini contains configuration settings.
In particular, the default export path, "c:\" must be changed for *nix systems.
</t>
<t tx="ekr.20090717084250.10848">The problem is imports in the Commands ctor. When executed the first time from
the bridge the imports take about 3/4 sec. on my machine. There is nothing that
can or should be done. Ctrl-5 is still hugely faster than opening unitTest.leo!</t>
<t tx="ekr.20090717084250.10849"></t>
<t tx="ekr.20090717084250.10850"></t>
<t tx="ekr.20090717084250.10851"></t>
<t tx="ekr.20090717084250.10852">http://groups.google.com/group/leo-editor/browse_thread/thread/a04dcefbb672078f</t>
<t tx="ekr.20090717084250.10853"></t>
<t tx="ekr.20090717084250.10854"></t>
<t tx="ekr.20090717084250.10855"></t>
<t tx="ekr.20090717084250.10856"></t>
<t tx="ekr.20090717084250.10857">The code should save/restore, just as in the clean_file function (from scripts.leo)</t>
<t tx="ekr.20090717084250.10858">The problem was missing calls to initAfterLoad in c.new.</t>
<t tx="ekr.20090717084250.10859">http://groups.google.com/group/leo-editor/browse_thread/thread/f27e3514310a5c90</t>
<t tx="ekr.20090717084250.10860"></t>
<t tx="ekr.20090717084250.10861"></t>
<t tx="ekr.20090717084250.10862">Pulled trunk, got r1599

python launchLeo.py leo/plugins/leoPlugins.leo

go to

Plugins--&gt;Graph world--&gt;@shadow backlink.py--&gt;backlink declarations

All I did was add the full stop at the end of the docstring, but see
the diff:

=== modified file 'leo/plugins/backlink.py'
--- leo/plugins/backlink.py     2009-02-19 18:16:01 +0000
+++ leo/plugins/backlink.py     2009-02-25 22:14:46 +0000
@@ -1,4 +1,4 @@
-'''Backlink - allow arbitrary links between nodes
+'''Backlink - allow arbitrary links between nodes.
 '''

 # Notes
@@ -296,7 +296,7 @@
                break
        else:
            self.showMessage("Error: no such link")
-
+
        gcc = getattr(self.c, 'graphcanvasController')
        if gcc:
            gcc.update()
</t>
<t tx="ekr.20090717084250.10863">http://groups.google.com/group/leo-editor/browse_thread/thread/7d8325d055cbef30</t>
<t tx="ekr.20090717084250.10864">http://groups.google.com/group/leo-editor/browse_thread/thread/5f5219fedd977ec2
</t>
<t tx="ekr.20090717084250.10865">http://groups.google.com/group/leo-editor/browse_thread/thread/414137b93c7e4b90

Calls g.makeAllNonExistentDirectories instead of os.mkdir.</t>
<t tx="ekr.20090717084250.10866">http://groups.google.com/group/leo-editor/browse_thread/thread/707a910f975f3715

http://groups.google.com/group/leo-editor/browse_thread/thread/74c6ab4809bde980

There were two separate bugs:

1. The eol_span and eol_span_regex now honor the mode's escape character.

2. colorRangeWithTag now colors delegates with the default tag color.

No changes were made in modes/c.py or modes/c.xml.</t>
<t tx="ekr.20090717084250.10867"></t>
<t tx="ekr.20090717084250.10868"></t>
<t tx="ekr.20090717084250.10869"></t>
<t tx="ekr.20090717084250.10870">http://groups.google.com/group/leo-editor/browse_thread/thread/d6449236bc140713#

Added support for @string default_leo_file = ~/.leo/workbook.leo</t>
<t tx="ekr.20090717084250.10871">@string underindent-escape-string = \-</t>
<t tx="ekr.20090717084250.10872">http://groups.google.com/group/leo-editor/browse_thread/thread/c80fd8375534afdf</t>
<t tx="ekr.20090717084250.10873"></t>
<t tx="ekr.20090717084250.10874">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac

&gt; As I said, all I need would be is for leo to call callback/hook with
&gt; signature like
&gt; def complete(line-up-to-cursor, current_node) =&gt; list of strings

The actual signature is:

theObject,completionList = getExternalCompletions (self,s,p=None,language='python')

p is used only to get the language, or you can set the language by hand.

@color</t>
<t tx="ekr.20090717084250.10875"></t>
<t tx="ekr.20090717084250.10876">c.config.doEnabledPlugins sets g.app.config.enabledPluginsFileName</t>
<t tx="ekr.20090717084250.10877">p.b, p.h and p.gnx
t.b, t.h, t.gnx and t.u
v.b, v.h, v.gnx, and v.u</t>
<t tx="ekr.20090717084250.10878"></t>
<t tx="ekr.20090717084250.10879">c.config.getSettingSource('show_full_tracebacks_in_scripts')
returns the name of the file which Leo used to determine the setting

- D indicates default settings.
- F indicates the file being loaded
- L indicates leoSettings.leo
- M indicates myLeoSettings.leo</t>
<t tx="ekr.20090717084250.10880"></t>
<t tx="ekr.20090717084250.10881">http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7</t>
<t tx="ekr.20090717084250.10882"></t>
<t tx="ekr.20090717084250.10883">@nocolor

The setting is called -c or --config.  The one-config-file arg no longer exists.

http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

Personally, I'd like to see another config file available via -c on
the command line:
(a common idiom)

leo myproject.leo -c /usr/lib/myproject/myLeoSettings.leo

or better yet:

leo myproject.leo -c /etc/leo/style01.leo
leo myotherproject.leo -c /etc/leo/style02.leo
leo anotherproject.leo -c /etc/leo/style23.leo

Each file opens in an editor with the shortcuts, buttons, commands,
plugins, appearance etc.  that has been tuned for that data management task.

or best yet:

leo myproject.leo -c /usr/lib/python2.5/site-packages/leo/config/style94.leo

==================

http://groups.google.com/group/leo-editor/browse_thread/thread/b5a736089079acaf#

Please, I think each file has a distinct and required role.

- config/leoSettings.leo = Edward's base, required for a sane starting point

- home/.leo/myLeoSettings.leo = adjust Edwards suggestions to taste

- cwd/myLeoSettings.leo = provide a customized working environment in
this folder

- leo -c /usr/lib/leo-editor/src/config/zope3_ide.leo =
  - open this file in a specialized environments, mine or community contributed
  - ...

- currentfile/@settings =
  - I'm working on some customization ideas
  - Here, try out this Leo file I sent you, check out all the spiffy
modifications 

@color</t>
<t tx="ekr.20090717084250.10884">Only .zip and .leo extensions are allowed at present.</t>
<t tx="ekr.20090717084250.10885"></t>
<t tx="ekr.20090717084250.10886"></t>
<t tx="ekr.20090717084250.10887"></t>
<t tx="ekr.20090717084250.10888">http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626

The open file dialog now shows all files by default.
Selecting a non-.leo file will load that file into a new node in the present outline.

This plugs what may have been the biggest hole in Leo's history.
</t>
<t tx="ekr.20090717084250.10889">This works, but stops Leo in the middle of the command-handling logic.

However, it is possible to pick up the commander by stepping out into
k.masterKeyHandler or k.masterCommandHandler. Using c, one can then get all
other info.</t>
<t tx="ekr.20090717084250.10890">- Tab = indent when there is a text selection
- Shift-Tab unindents always</t>
<t tx="ekr.20090717084250.10891">Escape now ends isearch
</t>
<t tx="ekr.20090717084250.10892"></t>
<t tx="ekr.20090717084250.10893"># Useful: we don't need a closing @color to enable coloring in descendants.</t>
<t tx="ekr.20090717084250.10894"></t>
<t tx="ekr.20090717084250.10895"></t>
<t tx="ekr.20090717084250.10896">http://groups.google.com/group/leo-editor/browse_thread/thread/f1c7c5134b95c77e
</t>
<t tx="ekr.20090717084250.10897"></t>
<t tx="ekr.20090717084250.10898">http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1</t>
<t tx="ekr.20090717084250.10899">Changed config.get so that settings in leoSettings.leo are read *last*.
This means that myLeoSettings.leo will override leoSettings.leo,
even when leoSettings.leo is the local file.</t>
<t tx="ekr.20090717084250.10900"></t>
<t tx="ekr.20090717084250.10901"></t>
<t tx="ekr.20090717084250.10902"></t>
<t tx="ekr.20090717084250.10903">This contains all gui plugins.</t>
<t tx="ekr.20090717084250.10904"></t>
<t tx="ekr.20090717084250.10905">Leo can now open, for example, any .py file.
It will be put in an @edit node in an otherwise-empty outline.

This allows Leo to be associated with the edit action of .py files.
Something like this::

C:\Python26\python.exe "c:\leo.repo\trunk\launchLeo.py" --gui=qt %1 %2</t>
<t tx="ekr.20090717084250.10906">- leoDynamicTest.py now supports a --path argument giving the .leo file.
  This is so useful!

- leoDynamicTest.py now honors the --silent argument.

- leoTest.runUnitTestLeoFile runs all unit tests in a given .leo file
  in a separate process.

- leoTest.runTestsExternally calls runUnitTestLeoFile after creating
  dynamicUnitTest.leo.

- When reporting that no unit tests were found, all unit tests commands tell
  whether the entire outline or just the selected outline was searched.
  This fixes sometimes-misleading error messages.

- test.leo contains a 'run-test.leo-tests' button.

- leoPy.leo contains a 'run-all-core-tests' button.</t>
<t tx="ekr.20090717084250.10907"></t>
<t tx="ekr.20090717084250.10908"></t>
<t tx="ekr.20090717084250.10909"></t>
<t tx="ekr.20090717084250.10910">Leo now warns on dangerous writes to @thin and @file nodes.</t>
<t tx="ekr.20090718092032.10405">Leo 4.6.1 final                             July 30, 2009

Leo 4.6.1 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

Leo 4.6.1 fixes several minor bugs in Leo 4.6.


The highlights of Leo 4.6
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes allow easy editing of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20090718092032.10406"></t>
<t tx="ekr.20090718092032.10407"></t>
<t tx="ekr.20090718092032.10408">A patch at the start of loadOnePlugin prevents leo from crashing and allows the
gui prompt for a leoID to come up.</t>
<t tx="ekr.20090718092032.10409">This is reasonable now that old-style file indices are rare.</t>
<t tx="ekr.20090718092032.10410">Html files are a good test case.</t>
<t tx="ekr.20090718092032.10411"></t>
<t tx="ekr.20090718092032.10412">http://bugs.launchpad.net/leo-editor/+bug/376634

The fix was to putVnodes.</t>
<t tx="ekr.20090718092032.10413"></t>
<t tx="ekr.20090718092032.10414">http://bugs.launchpad.net/leo-editor/+bug/383204</t>
<t tx="ekr.20090718092032.10415">http://groups.google.com/group/leo-editor/browse_thread/thread/981c27d5c24c90f8</t>
<t tx="ekr.20090718092032.10416">The generated @nocolor line now ends with a newline.</t>
<t tx="ekr.20090718092032.10417">http://groups.google.com/group/leo-editor/browse_thread/thread/6cab5e676d4d75a0</t>
<t tx="ekr.20090718092032.10418">- Removed forceGnxOnPosition from leoImport.py and leoAtFile.py.

- readStartNode now always uses root.v for the first node
  instead of calling createThinChild4</t>
<t tx="ekr.20090718092032.10419">https://bugs.launchpad.net/leo-editor/+bug/367462

The expected/customary behaviour (one you get used to in almost every editor) is:

End: always move to end of line
Home: Move to first visible chararacter on the line. When pressing home again, move to column zero. If Home is pressed one more time, move to first visible character again.

This is also the way emacs behaves, though ctrl+a always moves to column zero.</t>
<t tx="ekr.20090718092032.10420">The @verbatim was being inserted into the outline.
</t>
<t tx="ekr.20090718092032.10421"></t>
<t tx="ekr.20090718092032.10422"></t>
<t tx="ekr.20090718092032.10423">The problem arose when reading a zipped file:

 File "C:\Programme\Leo-4-6-b1\leo\core\leoFileCommands.py", line
1265, in parse_leo_file
   s = theFile.read()
TypeError: read() takes at least 2 arguments (1 given)
saved: [zipped] Dive-into-Python-3.leo
</t>
<t tx="ekr.20090718092032.10424">exception loading plugin
Traceback (most recent call last):

  File "C:\leo.repo\trunk\leo\core\leoPlugins.py", line 429, in loadOnePlugin
    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName

AttributeError: StubConfig instance has no attribute 'enabledPluginsFileName'

leoID='ekr'
.leoID.txt created in C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo
load </t>
<t tx="ekr.20090718092032.10425">http://bugs.launchpad.net/leo-editor/+bug/362048

I have 'dabbrev-expands' bound to the F4 key. When I press F4 after
the word "freq" in a body pane containing the word "frequency" then
Leo 4.5.1 shows a hour-glass for a while before giving an empty
dabbrev-expand: prompt in the minibuffer.

If I back up one character, putting point between the e and q and then
type F4, I get the expected behavior: the word "frequency" is inserted
immediately.

What I did:

- Removed "not ready messages".
- Made the code undoable.
- Added wimpy unit test.</t>
<t tx="ekr.20090718092032.10426"></t>
<t tx="ekr.20090718092032.10427">Added call to isFKey in k.handleUnboundKeys.
</t>
<t tx="ekr.20090718092032.10428">http://bugs.launchpad.net/leo-editor/+bug/376189</t>
<t tx="ekr.20090718092032.10429">http://bugs.launchpad.net/leo-editor/+bug/382221
</t>
<t tx="ekr.20090718092032.10430">http://bugs.launchpad.net/leo-editor/+bug/363403

With a long body text you might place the cursor on a line, hold down Shift, and
PgDn several pages to select a large block of text. The last PgDn may overshoot
the range you want selected, so you should be able to use UpArrow to bring the
bottom of the range back up to where you want it. However, on the first UpArrow
the selection is lost and restarted from the current cursor position. I.e. you
end up with just one line selected, instead of trimming one line of the
selection of several pages, as intended.
</t>
<t tx="ekr.20090718092032.10431">http://bugs.launchpad.net/leo-editor/+bug/306671

If a Leo editor window is opened, and the "NewHeadline" node is renamed to
"@auto &lt;path to some valid file&gt;", and then the "File-&gt;Read/Write-&gt;Read @auto
nodes" menu option is selected, the renamed node reverts to its previous name
("NewHeadline"), and nothing is loaded into the node.</t>
<t tx="ekr.20090718092032.10432">http://groups.google.com/group/leo-editor/browse_thread/thread/21bddd50f3400bdc?hl=en</t>
<t tx="ekr.20090718092032.10433">The outline wasn't being redrawn properly.</t>
<t tx="ekr.20090718092032.10434">http://groups.google.com/group/leo-editor/browse_thread/thread/430287018f9d773d

The fix to minibufferFind.changeAll fixes a bug that is several years old.
The fix to findNextMatch fixes a bug that is likely much older than that.</t>
<t tx="ekr.20090718092032.10435"></t>
<t tx="ekr.20090718092032.10436"></t>
<t tx="ekr.20090718092032.10437">http://mail.google.com/mail/#inbox/11ef0076a3f4d866</t>
<t tx="ekr.20090718092032.10438">The crash happened inside the call to::

    c.widgetWantsFocusNow(event.widget)

in callAltXFunction. Actually, the crash happened later, in c.outerUpdate.

A better fix would be to use wrappers for all edit widgets, and recalculate the
edit widget any it needs to be used.</t>
<t tx="ekr.20090718092032.10439"></t>
<t tx="ekr.20090718092032.10440">http://groups.google.com/group/leo-editor/browse_thread/thread/606277d73b193037</t>
<t tx="ekr.20090718092032.10441"></t>
<t tx="ekr.20090718092032.10442">onTextChanged in the qt gui was calling setUndoTypingParams, in many case
redundently and with bad params.

It remains to be seen whether onTextChanged is ever needed. If it is, it may be
difficult to set the old selection properly.</t>
<t tx="ekr.20090718092032.10443">http://bugs.launchpad.net/leo-editor/+bug/353925

The "kill-region" function did nothing when using the qt gui.

The fix was to replace tag_ranges with w.getSelectionRange, etc.
This was the only call to tag_ranges in the core.</t>
<t tx="ekr.20090718092032.10444">http://bugs.launchpad.net/leo-editor/+bug/377907

I'm going to mark this invalid, although the behavior is way too confusing.

I added the following to the plugin's docstring:

Configuration
~~~~~~~~~~~~~

At present, the file leo/plugins/leo_to_html.ini contains configuration settings.
In particular, the default export path, "c:\" must be changed for *nix systems.
</t>
<t tx="ekr.20090718092032.10445">The problem is imports in the Commands ctor. When executed the first time from
the bridge the imports take about 3/4 sec. on my machine. There is nothing that
can or should be done. Ctrl-5 is still hugely faster than opening unitTest.leo!</t>
<t tx="ekr.20090718092032.10446"></t>
<t tx="ekr.20090718092032.10447"></t>
<t tx="ekr.20090718092032.10448"></t>
<t tx="ekr.20090718092032.10449">http://groups.google.com/group/leo-editor/browse_thread/thread/a04dcefbb672078f</t>
<t tx="ekr.20090718092032.10450"></t>
<t tx="ekr.20090718092032.10451"></t>
<t tx="ekr.20090718092032.10452"></t>
<t tx="ekr.20090718092032.10453"></t>
<t tx="ekr.20090718092032.10454">The code should save/restore, just as in the clean_file function (from scripts.leo)</t>
<t tx="ekr.20090718092032.10455">The problem was missing calls to initAfterLoad in c.new.</t>
<t tx="ekr.20090718092032.10456">http://groups.google.com/group/leo-editor/browse_thread/thread/f27e3514310a5c90</t>
<t tx="ekr.20090718092032.10457"></t>
<t tx="ekr.20090718092032.10458"></t>
<t tx="ekr.20090718092032.10459">Pulled trunk, got r1599

python launchLeo.py leo/plugins/leoPlugins.leo

go to

Plugins--&gt;Graph world--&gt;@shadow backlink.py--&gt;backlink declarations

All I did was add the full stop at the end of the docstring, but see
the diff:

=== modified file 'leo/plugins/backlink.py'
--- leo/plugins/backlink.py     2009-02-19 18:16:01 +0000
+++ leo/plugins/backlink.py     2009-02-25 22:14:46 +0000
@@ -1,4 +1,4 @@
-'''Backlink - allow arbitrary links between nodes
+'''Backlink - allow arbitrary links between nodes.
 '''

 # Notes
@@ -296,7 +296,7 @@
                break
        else:
            self.showMessage("Error: no such link")
-
+
        gcc = getattr(self.c, 'graphcanvasController')
        if gcc:
            gcc.update()
</t>
<t tx="ekr.20090718092032.10460">http://groups.google.com/group/leo-editor/browse_thread/thread/7d8325d055cbef30</t>
<t tx="ekr.20090718092032.10461">http://groups.google.com/group/leo-editor/browse_thread/thread/5f5219fedd977ec2
</t>
<t tx="ekr.20090718092032.10462">http://groups.google.com/group/leo-editor/browse_thread/thread/414137b93c7e4b90

Calls g.makeAllNonExistentDirectories instead of os.mkdir.</t>
<t tx="ekr.20090718092032.10463">http://groups.google.com/group/leo-editor/browse_thread/thread/707a910f975f3715

http://groups.google.com/group/leo-editor/browse_thread/thread/74c6ab4809bde980

There were two separate bugs:

1. The eol_span and eol_span_regex now honor the mode's escape character.

2. colorRangeWithTag now colors delegates with the default tag color.

No changes were made in modes/c.py or modes/c.xml.</t>
<t tx="ekr.20090718092032.10464"></t>
<t tx="ekr.20090718092032.10465"></t>
<t tx="ekr.20090718092032.10466"></t>
<t tx="ekr.20090718092032.10467">http://groups.google.com/group/leo-editor/browse_thread/thread/d6449236bc140713#

Added support for @string default_leo_file = ~/.leo/workbook.leo</t>
<t tx="ekr.20090718092032.10468">@string underindent-escape-string = \-</t>
<t tx="ekr.20090718092032.10469">http://groups.google.com/group/leo-editor/browse_thread/thread/c80fd8375534afdf</t>
<t tx="ekr.20090718092032.10470"></t>
<t tx="ekr.20090718092032.10471">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac

&gt; As I said, all I need would be is for leo to call callback/hook with
&gt; signature like
&gt; def complete(line-up-to-cursor, current_node) =&gt; list of strings

The actual signature is:

theObject,completionList = getExternalCompletions (self,s,p=None,language='python')

p is used only to get the language, or you can set the language by hand.

@color</t>
<t tx="ekr.20090718092032.10472"></t>
<t tx="ekr.20090718092032.10473">c.config.doEnabledPlugins sets g.app.config.enabledPluginsFileName</t>
<t tx="ekr.20090718092032.10474">p.b, p.h and p.gnx
t.b, t.h, t.gnx and t.u
v.b, v.h, v.gnx, and v.u</t>
<t tx="ekr.20090718092032.10475"></t>
<t tx="ekr.20090718092032.10476">c.config.getSettingSource('show_full_tracebacks_in_scripts')
returns the name of the file which Leo used to determine the setting

- D indicates default settings.
- F indicates the file being loaded
- L indicates leoSettings.leo
- M indicates myLeoSettings.leo</t>
<t tx="ekr.20090718092032.10477"></t>
<t tx="ekr.20090718092032.10478">http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7</t>
<t tx="ekr.20090718092032.10479"></t>
<t tx="ekr.20090718092032.10480">@nocolor

The setting is called -c or --config.  The one-config-file arg no longer exists.

http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

Personally, I'd like to see another config file available via -c on
the command line:
(a common idiom)

leo myproject.leo -c /usr/lib/myproject/myLeoSettings.leo

or better yet:

leo myproject.leo -c /etc/leo/style01.leo
leo myotherproject.leo -c /etc/leo/style02.leo
leo anotherproject.leo -c /etc/leo/style23.leo

Each file opens in an editor with the shortcuts, buttons, commands,
plugins, appearance etc.  that has been tuned for that data management task.

or best yet:

leo myproject.leo -c /usr/lib/python2.5/site-packages/leo/config/style94.leo

==================

http://groups.google.com/group/leo-editor/browse_thread/thread/b5a736089079acaf#

Please, I think each file has a distinct and required role.

- config/leoSettings.leo = Edward's base, required for a sane starting point

- home/.leo/myLeoSettings.leo = adjust Edwards suggestions to taste

- cwd/myLeoSettings.leo = provide a customized working environment in
this folder

- leo -c /usr/lib/leo-editor/src/config/zope3_ide.leo =
  - open this file in a specialized environments, mine or community contributed
  - ...

- currentfile/@settings =
  - I'm working on some customization ideas
  - Here, try out this Leo file I sent you, check out all the spiffy
modifications 

@color</t>
<t tx="ekr.20090718092032.10481">Only .zip and .leo extensions are allowed at present.</t>
<t tx="ekr.20090718092032.10482"></t>
<t tx="ekr.20090718092032.10483"></t>
<t tx="ekr.20090718092032.10484"></t>
<t tx="ekr.20090718092032.10485">http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626

The open file dialog now shows all files by default.
Selecting a non-.leo file will load that file into a new node in the present outline.

This plugs what may have been the biggest hole in Leo's history.
</t>
<t tx="ekr.20090718092032.10486">This works, but stops Leo in the middle of the command-handling logic.

However, it is possible to pick up the commander by stepping out into
k.masterKeyHandler or k.masterCommandHandler. Using c, one can then get all
other info.</t>
<t tx="ekr.20090718092032.10487">- Tab = indent when there is a text selection
- Shift-Tab unindents always</t>
<t tx="ekr.20090718092032.10488">Escape now ends isearch
</t>
<t tx="ekr.20090718092032.10489"></t>
<t tx="ekr.20090718092032.10490"># Useful: we don't need a closing @color to enable coloring in descendants.</t>
<t tx="ekr.20090718092032.10491"></t>
<t tx="ekr.20090718092032.10492"></t>
<t tx="ekr.20090718092032.10493">http://groups.google.com/group/leo-editor/browse_thread/thread/f1c7c5134b95c77e
</t>
<t tx="ekr.20090718092032.10494"></t>
<t tx="ekr.20090718092032.10495">http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1</t>
<t tx="ekr.20090718092032.10496">Changed config.get so that settings in leoSettings.leo are read *last*.
This means that myLeoSettings.leo will override leoSettings.leo,
even when leoSettings.leo is the local file.</t>
<t tx="ekr.20090718092032.10497"></t>
<t tx="ekr.20090718092032.10498"></t>
<t tx="ekr.20090718092032.10499"></t>
<t tx="ekr.20090718092032.10500">This contains all gui plugins.</t>
<t tx="ekr.20090718092032.10501"></t>
<t tx="ekr.20090718092032.10502">Leo can now open, for example, any .py file.
It will be put in an @edit node in an otherwise-empty outline.

This allows Leo to be associated with the edit action of .py files.
Something like this::

C:\Python26\python.exe "c:\leo.repo\trunk\launchLeo.py" --gui=qt %1 %2</t>
<t tx="ekr.20090718092032.10503">- leoDynamicTest.py now supports a --path argument giving the .leo file.
  This is so useful!

- leoDynamicTest.py now honors the --silent argument.

- leoTest.runUnitTestLeoFile runs all unit tests in a given .leo file
  in a separate process.

- leoTest.runTestsExternally calls runUnitTestLeoFile after creating
  dynamicUnitTest.leo.

- When reporting that no unit tests were found, all unit tests commands tell
  whether the entire outline or just the selected outline was searched.
  This fixes sometimes-misleading error messages.

- test.leo contains a 'run-test.leo-tests' button.

- leoPy.leo contains a 'run-all-core-tests' button.</t>
<t tx="ekr.20090718092032.10504"></t>
<t tx="ekr.20090718092032.10505"></t>
<t tx="ekr.20090718092032.10506"></t>
<t tx="ekr.20090718092032.10507">Leo now warns on dangerous writes to @thin and @file nodes.</t>
<t tx="ekr.20090802162204.5798">Leo 4.6.2 final                             August 3, 2009

Leo 4.6.2 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

Leo 4.6.2 fixes several bugs reported since Leo 4.6 was released.

The highlights of Leo 4.6
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes allow easy editing of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20090803084828.5800">- AltGr properly handled as Alt+Ctrl.
  Created a setting: @bool enable_alt_ctrl_bindings.
  The default is False, needed for AltGr functionality on Windows.

- Fixed unpickling problems in getDescendentUnknownAttributes
  The old catcing wasn't extensive enough.
  
- Plugins that fail to import Pmw no longer prevent Leo from launching.

- Fixed bug 397433, tk chapter menu crash, on all platforms.</t>
<t tx="ekr.20090811090022.14451">.. Links used in this document...

.. |leoQtMainWindow| image:: screen-shots/leo-qt-main-window.JPG

.. |leoTkMainWindow| image:: screen-shots/leo-tk-main-window.jpg

.. |leoQtMainWindowLinux| image:: screen-shots/leo-qt-main-window-linux.png
.. .. |findTab| image:: screen-shots/find-tab.jpg

.. |leoQtFindTab| image:: screen-shots/leo-qt-find-tab.JPG</t>
<t tx="ekr.20090811090022.14452">Here is Leo's main window rendered with the Qt gui.
Top-left: the outline pane.
Top-right: the log pane.
Bottom: the body pane.
Below the body pane is the minibuffer.

|leoQtMainWindow|

Here is Leo's main window rendered with the Tk gui.
Just as with the Qt gui, you may adjust font sizes, colors, et.

|leoTkMainWindow|

Here is Leo's find tab, rendered with the Tk gui.
All parts of the find tab can be controlled from the keyboard.

|leoQtFindTab|
</t>
<t tx="ekr.20090811090022.14453">Here is Leo's main window as it appears on Linux:

|leoQtMainWindowLinux|</t>
<t tx="ekr.20090909083000.6547">Leo 4.7 beta 1                          September 9, 2009

Leo 4.7 beta 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

This version of Leo is labeled a beta version because it contains some new,
relatively untested plugins.  However, Leo's core should be quite reliable.

In particular, Leo 4.7 beta 1 fixes a bug that caused Leo 4.6 releases to crash
if .leoID.txt did not exist. Usually this file does exist, but Leo will prompt
for the contents of this file (a user id) the very first time somebody uses Leo.
Alas, an unfortunate reversion of code caused Leo to crash. Not exactly the best
introduction to Leo!

The highlights of Leo 4.7:
--------------------------

- A major simplification of internal data model: the so-called
  one-node world. Note: this is **disabled** in the beta 1 release.
- A new executable Windows installer, whose manifest is created from
  the files that bzr actively manages.
- Leo no longer adds directories to sys.path on startup.
- New plugins.
- The usual assortment of bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20090909083000.6552">The setting::

    @string vim_trigger_event = icondclick2

is the default.  It opens vim when the user double-clicks the icon box.

Alternatives are::

    @string vim_trigger_event = iconclick2
    @string vim_trigger_event = select2

The former opens vim on single clicks in the icon bar.
The latter opens vim whenever a new node is selected in Leo.</t>
<t tx="ekr.20090909083000.6553">http://groups.google.com/group/leo-editor/browse_thread/thread/b868abd65fb57759

Leo no longer adds directories to sys.path on startup.

(Merged the clean-sys-path branch into the trunk.)_
</t>
<t tx="ekr.20090909083000.6555">@nocolor-node

New command-line option
    --gui=qttabs

new plugins:
    spydershell,
    qtframecommands
    mod_framesize.

Improved plugin:  "show folder" in rclick menu.

Improved plugin: contextmenu.py

    If you rclick on @thin / whatever item, you should see "open
    /home/ville/foo" (or equivalent) menu entry. It open up the file manager on
    that folder (using xdg-open on linux, os.startfile on windows). I have no
    idea what to do with mac, now it runs xdg-open and probably fails.</t>
<t tx="ekr.20090909083000.6556">Unlike previous installers, the manifest is created from the
@button make leo.nsi script in dist.leo.</t>
<t tx="ekr.20091006063434.13802">c.rstCommands.rst3()</t>
<t tx="ekr.20091006093902.6558">Leo 4.6.3 final                             September 4, 2009

Leo 4.6.3 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

Leo 4.6.3 fixes a significant caching bug in Leo 4.6.2.
Leo 4.6.3 also comes with an executable installer for Windows.
Leo 3.6.3 adds several new plugins.

The highlights of Leo 4.6
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes allow easy editing of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20091006093902.6559">- Leo marks nodes dirty if the nodes changed during read.

- Fixed a bug in g.adjustTripleString.</t>
<t tx="ekr.20091006093902.6560">- Added --gui=qttabs command-line option

- Added new plugins: spydershell.py, qtframecommands.py, and mod_framesize.py.

- Added "show folder" in rclick menu.</t>
<t tx="ekr.20091104200540.6566"></t>
<t tx="ekr.20091104200540.6567">
    **Note**:
    For compatibility with old (pre-4.2) scripts, c.currentVnode and
    c.rootVnode methods return *positions* not vnodes.
    
**Important**: With the exception of the p.v ivar, scripts should be careful to
use only the methods of the position and vnode classes rather than the internal
ivars of these classes. Doing so will ensure that the script is as simple as
possible and that the script will continue to work regardless of future changes
to the internals of these classes.

 **Important**:
    Positions can become *invalid* when the structure of the outline changes.
    As discussed below, plugins and scripts that store positions for use at a later time should make sure the
    position p is still valid by calling c.positionExists(p)
    
**baseTextWidget** and its subclasses
    Leo's body pane, c.frame.body.bodyCtrl, is a subclass of baseTextWidget.
    Gui plugins implement Leo's body pane by subclassing baseTextWidget.
    
**frame**
    Frames contain the internal data needed to manage a Leo window. Given a
    commander c, c.frame is commander's frame. Given a frame f,
    f.c is the frame's commander.
    
**g.app.gui**
    This object represents gui-specific subclasses of Leo's base gui code.</t>
<t tx="ekr.20091105080104.11492">@font nodes only work with the Tk gui. When using the Qt gui, you specify fonts
using the node in leoSettings.leo called::

    @data qt-gui-plugin-style-sheet
    
As usual, you will probably want to put this node in your myLeoSettings.leo file.</t>
<t tx="ekr.20091105080104.9031">@font nodes only work with the Tk gui. When using the Qt gui, you specify fonts
using the node in leoSettings.leo called::

    @data qt-gui-plugin-style-sheet
    
As usual, you will probably want to put this node in your myLeoSettings.leo file.</t>
<t tx="ekr.20091107093823.6790">This is the rST version of the Tech Report handed out at EuroPython in 2005.

**Important**: Leo's tutorial is now a clearer explanation of the basics.
This tech report should be rewritten.

@nocolor
@tabwidth -4</t>
<t tx="ekr.20091107093823.6791">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

##########################################
The Essentials of Leo
##########################################

.. contents::</t>
<t tx="ekr.20091107093823.6792"></t>
<t tx="ekr.20091107093823.6793">Leo organizes all data into nodes containing a **headline**, an expandable page of
**body text** and a (possibly empty) subtree of **descendant nodes**. The **contents** of a
node are its headline and body text. Leos main window contains an **outline** pane
at the top left, a **log pane** at the top right, and a **body pane** at the bottom. The
outline pane shows headlines; the body pane shows the body text of the selected
headline. The log pane displays messages from Leo.

Small red arrows mark **cloned nodes** (clones). Clones share the same content and
descendants. All clones of the same node are equivalent, so changing the
contents of one node (call it node N) changes the contents of all clones of N.
Furthermore, inserting, deleting or changing any descendant of node N causes the
corresponding insertion, deletion or change in all other clones of N.</t>
<t tx="ekr.20091107093823.6794">Clones allow you to organize data in multiple ways within the same outline. You
do not have to choose a single correct organization: you can organize your
data in as many ways as you like.

You can use **organizer nodes** to create explicit relations (relationships) among
the data in your outline. The headline of the organizer node is the
relationships name. Now make clones of nodes from other parts of the outline
that participate in the relation. Drag the newly created clones so they become
children of the organizer node. You may want to create other (non-cloned)
children of the organizer node that contain data found nowhere else in the
outline. Voil: you have just created the set of all nodes that pertain to the
relationship. The organizer node is the relation; the terms relation,
relationship and organizer node are interchangeable.

Three kinds of relations deserve special mention. A **view** is a relation (an
organizer node) containing all nodes related to a desired view (or slice) of the
data in the outline. Similarly, a **task** is an organizer node containing all nodes
related to a task. Relations are not limited to tasks or views: the notion of
relationship is completely general. Headlines naturally describe the data in
body text. That is, nodes relate **metadata** (descriptions of data) to data.
Separating data from metadata is useful for humans. It is even more valuable for
scripts: scripts can access data and metadata without complex parsing.
</t>
<t tx="ekr.20091107093823.6795">Plugins are Python (.py) files contained in Leos plugins folder. Users can
write plugins to change how Leo works and to add new features without changing
Leos core code. Well discuss plugins in more detail later.
</t>
<t tx="ekr.20091107093823.6796">Leo can generate many external files called **derived files** from an outline. Leo
outlines can organize files throughout your computers file system. Nodes whose
headlines start with @ are special nodes. Several **special nodes** indicate the
root of a tree that generates a derived file::

    @asis filename    Creates a derived file. Ignores all markup in body text.
    @file filename    Creates a derived file. Duplicates outline structure in .leo file.
    @noref filename   Creates a derived file. Ignores all section references.
    @nosent filename  Creates a derived file without sentinels.
    @thin filename    (Recommended) Like @file, but thin derived files contain all outline structure.

Leo recognizes several other special nodes::

    @settings   Defines settings local to the .leo file.
    @url url    Double-clicking the nodes icon opens the url in Leo or in a browser.

The scripting plugin scans for the following nodes when opening an outline::

    @button         Creates a button in the **icon area** at the top of the Leo window.
    @plugin plugin  Enables a plugin if the plugin has not already been enabled.
    @script         Executes a script when opening the outline. This is a security risk: it is disabled by default.

Plugins, @button nodes and @script nodes can create other kinds of special nodes::

    @suite       Creates a suite of unit tests from script in body. Requires scripting plugin.
    @test        Creates a unit text from script in body. Requires scripting plugin.
    @rst         Outputs a tree containing markup for reStructuredText. Requires rst2 plugin.
    @run command Double clicking the nodes icon executes the command.  Requires run_nodes plugin.</t>
<t tx="ekr.20091107093823.6797">Leos Execute Script command **preprocesses** the script to be executed by scanning
a node N and its descendents looking for markup. **Markup** is special syntax that
controls this preprocessing. If node N contains no markup, the resulting script
is just Ns body text. Otherwise, the preprocessed script will include text from
descendent nodes as described below. The main kinds of markup are **section
references**, **directives** and **doc parts**.

1.  **Section references** have the form::

        &lt;&lt;section name&gt;&gt;

    The &lt;&lt; and &gt;&gt; must appear on the same line. Conversely, any line
    containing &lt;&lt; and &gt;&gt; is a section reference, regardless of context. However,
    section references are not recognized in doc parts. Any characters may appear
    between &lt;&lt; and &gt;&gt;.
    
    Section references are functional pseudo-code: while preprocessing a script, Leo
    replaces section references by the actual text of the sections definition.
    Sections are defined in **section definition nodes**, whose headlines start with a
    section reference and whose body text defines the section. Each section
    definition node must descend from the node containing the section reference.

2.  **Directives** start with @ in the leftmost column of body text. Directives
    specify options and control Leos operation. The @others directive is the
    minimal markup needed to organize scripts. @others tells Leo to insert the
    preprocessed text of all descendant nodes (except section definition nodes) at
    the spot at which the @others directive occurs. Nodes are inserted in **outline
    order**, the order in which nodes appear in the outline. **Important**: Leo adds the
    whitespace preceding the @others directive to the indentation of all
    preprocessed text.
    
    Using @others is more convenient than using section references. Use @others when
    the order of included text does not matter::
    
        class myClass:
	        @others # Include the methods of the class. Order doesnt matter.

    Use section references when the order of included text does matter. In the following script, for example,
    &lt;&lt; imports &gt;&gt; ensures that imports come first. The @others directive then includes the body text of all other
    descendant nodes::
    
        @language python
        &lt;&lt; imports&gt;&gt;
        @others # Define classes &amp; functions in child nodes.
        main()

    Here is a list of all of Leos standard directives::
    
        @whitespace (or @doc)   Starts a doc part &amp; ends code part.
        @all                    Like @others, but includes all descendent nodes.
        @c, @code               Starts a code part and ends a doc part.
        @color                  Enables syntax coloring.
        @delims                 Temporarily changes comment delims.
        @nocolor, @killcolor    Disables syntax coloring.
        @comment                Sets comment delimiters in external (derived) files.
        @language languagename  Sets language for syntax coloring and comments.
        @lineending lineending  Sets ending of lines in derived files.
        @others                 Inserts body text of all descendents except definition nodes. 
        @pagewidth n            Sets page width for justifying comments in doc parts.
        @path path              Sets prefix to use in relative file names in @file nodes, etc.
        @root filename          Marks the root of a tree that creates an external file.
        @raw, @end_raw          Inhibits sections references in a range of text. (@file only.)
        @tabwidth n             Sets width of tabs (negative widths convert tabs to spaces.)
        @wrap, @nowrap          Controls wrapping of text in body pane.
    
3.  Doc parts start with the @ directive and continue until the end of the body text or until the @c directive.
    Body text not in a doc part is in a code part. Here is an example of a doc part::

        @ This is a doc part. Doc parts may span many lines. Leo converts doc parts to comments.
        Leo reformats the doc part by justifying lines so they are no longer than the page width.
        @c

    Leo reformats doc parts by justifying the text into comment lines.
    The @pagewidth directive controls the length of these comment lines.
    The @language and @comment directives specify the comment delimiters used in doc parts.</t>
<t tx="ekr.20091107093823.6798">The Execute Script command preprocesses the selected text of the presently
selected outline node, or the entire text of the node if there is no selected
text. See the section called Markup for Scripts for a discussion of how Leo
preprocesses scripts. That section also discusses how Leo organizes scripts
using outlines. Conversely, scripts can use outlines to organize their data. To
write such scripts you must understand at least the basics of Leos modules and
classes...
</t>
<t tx="ekr.20091107093823.6799">Leos source code is organized as a collection of modules. The following
paragraphs describe five of the most important modules. See LeoPy.leo (Leos
full source code) for more details: scripts have full access to all of Leos
classes and data.

1.  The **leoGlobals** module contains utility functions.
    By convention, in Leos code g is always the leoGlobals module.

2.  The **leoApp** module defines a class representing the entire Leo application.
    **g.app** is the singleton object of this class: the application object.
    The instance variables (ivars) of the application object are Leos global variables.
 
3.  The leoCommands module defines the Commands class.
    A commander is an instance of this class.
    Commanders contain the operations that can be performed on a particular outline.
    Each open Leo outline has its own commander.
    By convention, in Leos code **c** is always a commander.

4.  The leoFrame module defines the base leoFrame class for objects that create and manage
    the visual appearance of Leos windows and panes.
    The **leoTkinterFrame** and **leoTkinterTree** modules contain subclasses of the base classes in the leoFrame module.
    A frame (an instance of the leoFrame class, or a subclass)
    contains all the internal data needed to manage a Leo window.
    **c.frame** is the frame associated with commander c.
    If **f** is a frame, **f.c** is the frames commander, **f.body** is the frames body pane,
    **f.tree** is the frames outline pane, and **f.log** is the frames log pane.

5.  The leoNodes module defines several classes that implement Leos fundamental data structures.
    These classes are complex.
    Happily, scripts can and should ignore these complications by accessing nodes using
    high-level methods of the position class.

A **position** (an instance of the position class) is the state of some traversal of an outline. Equivalently, a position is a particular visual place in an outline. Cloned nodes may appear many times in an outline. Non-cloned nodes may also appear in many places: consider a non-cloned descendant of a cloned node. By convention, in Leos source code p is a position.
</t>
<t tx="ekr.20091107093823.6800">When executing scripts Leo predefines the following three symbols:
**c** is the commander of the outline in which the script is defined,
**g** is the leoGlobals module and
**p** is the position of the selected node in cs outline, i.e., c.currentPosition().
</t>
<t tx="ekr.20091107093823.6801">Scripts should get and set data using high-level access methods. Here are some important getters::

    g.app                The application object. Its ivars are Leos global variables.
    g.app.windowList     The list of all open frames.
    c.currentPosition()  The position of the selected node.
    c.rootPosition()     The position of the first node in the outline.
    p.headString()       The headline of position p.
    p.bodyString()       The body text of position p.
    p.childIndex()       The number of siblings that precede p.
    p.numberOfChildren() The number of ps children.
    p.level()            The number of ps ancestors.
    p.hasChildren()      True if p has children.
    p.isAncestorOf(p2)   True if p2 is a child, grandchild, etc. of p.
    p.isCloned()         True if p is a clone.
    p.isDirty()          True if ps contents have been changed.
    p.isExpanded()       True if p has children and ps outline is expanded.
    p.isMarked()         True if ps headline is marked.
    p.isVisible()        True if all of ps ancestors are expanded.

And here are some important setters::

    p.setBodyStringOrPane(s) Set body text of p to s.
    p.setHeadString(s)       Set headline of p to s.</t>
<t tx="ekr.20091107093823.6802">Scripts can visit some or all of the nodes of a Leo outline using the following iterators::

    c.allNodes_iter             # All positions in the outline, in outline order.
    p.children_iter()           # All children of p.
    p.parents_iter()            # All parents of p.
    p.siblings_iter()           # All siblings of p, including p.
    p.following_siblings_iter() # All siblings following p, not including p.

For example, the following prints all the nodes of an outline, properly indented::

    for p in c.allNodes_iter():
        print ' '*p.level(), p.headString()</t>
<t tx="ekr.20091107093823.6803">Scripts may open other Leo outlines, or execute any of Leos commands.  Here are some examples::

    ok,frame = g.openWithFileName(path,c)	# Opens the .leo file found at path.
    c.deleteOutline()   # Deletes the selected node.
    c.insertHeadline()  # Inserts a new node after present position.

For more examples, see Chapter 7: Scripting Leo with Python, in Leos Users Guide.</t>
<t tx="ekr.20091107093823.6804">The scripting plugin creates two buttons in the icon area at the top of the Leo
window. The Run Script button executes the script in the selected node just
like the Execute Script command. The Script Button button creates a new
button whose headline is the headline of the presently selected node, call it
node N. Pressing this button executes the script in node N with p predefined as
c.currentPosition() at the time the script is executed. This clever trick
brings the script to the data in the selected outline.
</t>
<t tx="ekr.20091107093823.6805">test.leo contains all of Leos unit tests. An @button node in test.leo
creates a blue Unit Test button in the icon area. This button is an
excellent example of bringing scripts to data. The Unit Test button executes
all the unit tests specified by @test and @suite nodes in the selected
outline. **Important**: @button, @test and @suite nodes require the
scripting plugin to be enabled.

@test nodes greatly simplify unit testing. The Unit Test button creates
a unit test from the body text of each @test node. In effect, the Unit
Test button automatically creates an instance of unittest.TestCase whose
run method is the body text of the @test node. There is no need to create
TestCase objects explicitly!

@suite nodes support legacy unit tests. When the Unit Test script button
finds an @suite node it executes the script in its body text. This script
should create a suite of unit tests and set::

    g.app.scriptDict['suite'] = suite

where suite is the created suite. The Unit Test button then runs that
created suite of unit tests.</t>
<t tx="ekr.20091107093823.6806">Plugins are Python (.py) files in Leos plugin subdirectory. It is easy to
create new plugins: Leos users have contributed dozens of plugins that extend
Leos capabilities in new ways. Leo imports all enabled plugins during startup.
The file pluginsManager.txt lists all enabled plugins. You can use the plugin
manager plugin to control plugins without updating pluginsManager.txt by hand.

Plugins can override any class, method or function in Leos core, the files in
Leos src subdirectory (the files derived from LeoPy.leo). Besides altering
Leos core, plugins can register functions called hooks that Leo calls at
various times during Leos execution. Events that trigger hooks include key
pressed events, screen drawing events, node selection events and many others.
When importing a plugin, Leo will call the top-level init() function if it
exists. This function should register the plugins hooks by calling
leoPlugins.registerHandler.

For full details about hooks and events see Chapter 8: Customizing Leo, in
Leos Users Guide. The file leoPlugins.leo contains all plugins that are
presently distributed with Leo; studying these plugins is a good way of learning
to write your own plugins.</t>
<t tx="ekr.20091107093823.6807">- Leos home page:  google edreamleo or http://webpages.charter.net/edreamleo/front.html

- Edward K. Ream:  edreamleo@charter.net, 166 N. Prospect Ave., Madison WI 53726, (608) 231-0766</t>
<t tx="ekr.20091107181442.26607">Leo's **vnode** classe represents all the data in a particular node.
In the simplied data model, a single vnode represents all clones on the screen.
When Leo clones a vnode v, alters data structures in v and v's parent vnode,
but Leo does *not* create another vnode to represent the clone.
Thus, the *exact same* vnode may appear in several places on Leo's outline pane.

Leo's **position** class represents a position (spot) in Leo's outline pane.
More exactly, a position represents the state of a tree traversal of Leo's data.
Vnode's may appear several times in a traversal, which is another way of saying
that vnodes may appear several times in Leo's outline pane.

Leo's **generators** generate lists of positions.
For example, c.all_positions() generates a list of all positions in the outline.
As another example, given a position p,
p.self_and_subtree() generates a list of all descendants of the vnode at position p.

Leo' **position methods** provide other ways ways of finding positions.
Given a position p, p.parent() is the p's parent position,
p.firstChild() is the position of p's first child (if it exists),
and p.next() is the position of p's next sibling (again, if it exists).
Many other position methods exist, as discussed below.

Leo's execute-script command predefines several symbols.  This makes it easy to
access the data in Leo outlines and the Leo's own source code. g is predefined
to the leoGlobals module. Scripts commonly use utility functions such as g.es,
g.trace, etc. The g.app object represents Leo itself. The instance vars (ivars)
of g.app are Leo's global variables and constants. The execute-script command
predefines c to be the commander (see below) of the Leo outline in which the
script is contained. Whenever possible, scripts should use the high-level
methods of the commander to insert, delete or clone nodes. Finally, the
execute-script commands predefines p to be the presently selected position.
</t>
<t tx="ekr.20091111112709.6671">@language rest</t>
<t tx="ekr.20091111112709.6672">.. _glossary:

#########
Glossary
#########

We often refer to outline nodes by the directives they contain.
For example, an ``@file`` node is a node whose headline starts with ``@file``, etc.

.. glossary::

    @&lt;file&gt; node
        A node whose headline starts with
        ``@asis``, ``@edit``, ``@file``, ``@nosent``, ``@shadow``, ``@thin``, or their longer forms.
   
    @all directive
        Cause Leo to copy the body text of all nodes in an @thin tree to the corresponding external file.
        For more information, see `directives for programming`_ in `Leo's tutorial`_.

    outline order
        Were you to expand every node in a Leo outline (``expand-all``), then nodes would be in the
        outline panel in outline order from top to bottom.  Specifically, a node; its descendants in
        outline order, then each of its siblings with their descendants in outline order.
</t>
<t tx="ekr.20091111112709.6676">.. Links used in this document.

.. ----- External links.

.. _`CWEB language`:                    http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`literate programming web page`:    http://www.literateprogramming.com/
.. _`noweb language`:                   http://www.eecs.harvard.edu/~nr/noweb/
.. _`rST primer`:                       http://docutils.sourceforge.net/docs/user/rst/quickstart.html

.. ----- Relative links.

.. _`Chapter 8: Customizing Leo`:   customizing.html
.. _`Writing plugins and hooks`:    writingPlugins.html

.. _`programming reference`:    directives.html
.. _`@asis`:                    directives.html#asis
.. _`@auto`:                    directives.html#auto
.. _`@file`:                    directives.html#file-and-thin
.. _`@nosent`:                  directives.html#nosent
.. _`@root`:                    directives.html#root
.. _`@thin`:                    directives.html#file-and-thin
.. _`@unit documentation`:      directives.html#root
.. _`tangling @root trees`:     directives.html#tangling-root-trees-with-the-tangle-commands
.. _`untangling @root trees`:   directives.html#untangling-root-trees-with-the-untangle-commands

.. ----- References to the tutorial.
.. _`clones &amp; views`:               intro.html#clones-views
.. _`leo's tutorial`:               intro.html
.. _`external files section`:        intro.html#derived-files
.. _`directives for programming`:   intro.html#directives-for-programming
.. _`leo directives`:               intro.html#leo-directives
.. _`quick start for programmers`:  intro.html#quick-start-for-programmers
.. _`sentinels lines`:              intro.html#sentinel-lines
</t>
<t tx="ekr.20091111112709.6677"></t>
<t tx="ekr.20091112060950.6677">s = p.bodyString()

s = s.replace('\n\n','***2***')
s = s.replace('\n',' ')
s = s.replace('***2***','\n\n')
s = s.replace('\n  ','\n')
s = s.replace('\n ','\n')
s = s.replace('     ',' ')
s = s.replace('    ',' ')
s = s.replace('   ',' ')
s = s.replace('  ',' ')

p.setBodyString(s)</t>
<t tx="ekr.20091130111843.6787">@language rest</t>
<t tx="ekr.20091130111843.6788">############################
Chapter 2: The Leo Tutorial
############################

Leo is a power tool for people who want to organize, study and work with data,
especially complex data like computer programs, books, web sites and data bases.
Superficially, Leo may look like other outlining programs, code folding editors
or class browsers, but it most certainly is not.

People say Leo is a revolutionary tool, and that Leo is fun to use, even
additive. There is a unique "Leo way" of managing data; the term **Leonine**
describes how people treat data in "the world according to Leo". Leo definitely
takes a bit of work to understand. Leo's users speak of an "Aha" moment, when
they see how these pieces fit together: outline structure is significant
everywhere.

Leo is freely available in source or binary form for all major platforms. You
may download Leo from http://sourceforge.net/projects/leo/files/Leo/ Leo is Open
Software and may be freely distributed.

`Leo's home page`_ contains additional documentation and links to other
resources. For another introduction to Leo, open the file quickstart.leo in the
leo/doc folder.

This tutorial introduces the reader to the basic concepts and features of Leo.
It helps to have Leo running for hands-on experience, but all examples here are
self-contained, so the tutorial can be read off-line as well.
See `Leo's Installation Guide`_. for detailed installation instructions. If you
have problems installing Leo, please ask for help on `Leo's help forum`_. 

This tutorial does not attempt to be comprehensive and cover every single
feature of Leo, or even every commonly used feature. Instead, it introduces many
of Leo's most noteworthy features, and will give you a good idea of Leo's flavor
and style. After reading it, you will be able to use Leo in basic ways to create
external files, organize data and run simple scripts. You will then be ready to
learn more about Leo's many advanced features in `Leo's Users Guide`_.

.. The :ref:`glossary` is also worth going through.

.. contents::
</t>
<t tx="ekr.20091130111843.6810">.. Links used in this document...

.. ----- External references.

.. _`LaTeX`:                    http://www.latex-project.org/
.. _`Leo's help forum`:         http://groups.google.com/group/leo-editor-users
.. _`Leo's home page`:          http://webpages.charter.net/edreamleo/front.html
.. _`Literate Programming`:     http://www.literateprogramming.com/
.. _`MySQL`:                    http://www.mysql.com/
.. _`noweb`:                    http://www.eecs.harvard.edu/~nr/noweb/
.. _`Python`:                   http://www.python.org/
.. _`reStructuredText`:         http://docutils.sourceforge.net/rst.html
.. _`XML`:                      http://en.wikipedia.org/wiki/XML

.. ----- Relative links....

.. _`external file`:        `external files`_
.. _glossary:               glossary.html
.. _`Good style and bad`:   `style`_
.. _outline:                `Leo's main window`_
.. _outlines:               `Leo's main window`_
.. _plugin:                 `extending`_
.. _plugins:                `extending`_
.. .. _quickstart:             `Quick start for programmers`_
.. _scripts:                `scripting`_
.. _settings:               `config`_
.. _`Configuring Leo`:      `config`_

.. ----- References to other chapters.

.. _`What people are saying about Leo`:             testimonials.html
.. _`@auto trees`:                                  directives.html#auto-trees
.. _command:                                        commands.html
.. _commands:                                       commands.html
.. _directive:                                      directives.html
.. _directives:                                     directives.html
.. _`Leo directives`:                               directives.html
.. _`editing commands`:                             commands.html#the-edit-menu
.. _front:                                          front.html
.. _`install Leo`:                                  install.html
.. _`launch Leo`:                                   install.html#running-leo
.. _`Leo's Users Guide`:                            leo_TOC.html
.. _`Leo's Installation Guide`:                     install.html
.. _`Chapter 4: Writing Programs in Leo`:           directives.html
.. _`Chapter 5: Using Leo's Commands`:              commands.html
.. _`Chapter 6: Leo and Literate Programming`:      design.html
.. _`Chapter 7: Scripting Leo with Python`:         scripting.html
.. _`Chapter 8: Customizing Leo`:                   customizing.html

.. ----- References to the glossary

.. _`@auto`:                    glossary.html#auto
.. _`@file`:                    glossary.html#file
.. _`@nosent`:                  glossary.html#nosent
.. _`@others`:                  glossary.html#others
.. _`@thin`:                    glossary.html#thin
.. _`@thin trees`:              glossary.html#thin-trees
.. _`body text`:                glossary.html#body-text
.. _ancestor:                   glossary.html#ancestor
.. _children:                   glossary.html#child
.. _clone:                      glossary.html#clone
.. _cloned:                     glossary.html#cloned
.. _cloning:                    glossary.html#clone
.. _clones:                     glossary.html#clones
.. _`code part`:                glossary.html#code-part
.. _`doc part`:                 glossary.html#doc-part
.. _descendant:                 glossary.html#descendant
.. _descendants:                glossary.html#descendants
.. _`doc part`:                 glossary.html#doc-part
.. _grandchildren:              glossary.html#grandchildren
.. _headline:                   glossary.html#headline
.. _headlines:                  glossary.html#headlines
.. _`organizer node`:           glossary.html#organizer-node
.. _`organizer nodes`:          glossary.html#organizer-nodes
.. _`outline order`:            glossary.html#outline-order
.. _node:                       glossary.html#node
.. _nodes:                      glossary.html#nodes
.. _reference:                  glossary.html#reference
.. _references:                 glossary.html#references
.. _root:                       glossary.html#root
.. _`root node`:   	            glossary.html#root
.. _section:                    glossary.html#section
.. _sections:                   glossary.html#section
.. _`section definition`:       glossary.html#section-definition
.. _`section definitions`:      glossary.html#section-definitions
.. _`section definition nodes`: glossary.html#section-definition-nodes
.. _`section name`:             glossary.html#section-name
.. _`section names`:            glossary.html#section-names
.. _`section reference`:        glossary.html#section-reference
.. _`section references`:       glossary.html#section-references
.. _siblings:                   glossary.html#siblings

.. For reasons unknown, this image must appear in the _images folder on the web site.
.. |leoMainWindow| image:: screen-shots/leo-qt-main-window.JPG

</t>
<t tx="ekr.20091130111843.6814">Let's start looking at Leo in detail. We'll start with what you see when you
first open Leo, Leo's main window. Leo's main window, shown below, represents an
entire project. As you can see, the main window contains three panes: the
**outline pane** at the top left, the **log pane** at the top right, and the
**body pane** at the bottom. The window also contains an **icon area** at the
very top, a **status area** and a **mini-buffer** at the very bottom.

|leoMainWindow|

The outline pane
    The outline pane shows your project as an outline. The outline
    contains all your project's data. An outline consists of **nodes**. The
    **icon box** is a small icon directly to the left of the headline text. If a
    node contains children, a smaller icon appears to the left of the icon box.
    This icon contains a '+' or '-' symbol. Clicking this **expansion box**
    expands or contracts the node.
    
Nodes
    Nodes have two parts, a **headline** and **body text**. The outline pane
    shows headlines. Selecting a headline selects the entire node; the node's
    body text appears in the body pane. Leo uses standard terminology to
    describe the relationships of nodes in an outline. We speak of **parent**
    nodes, **child** nodes, **ancestor** nodes and **descendant** nodes.

Body pane
    The body pane contains the body text of the node selected in the
    outline pane.

Log pane
    The log pane contains informational messages from Leo or your scripts.

Icon area Depending on what plugins are enabled, the icon area may contain
    buttons and other widgets that extend what Leo can do. The scripting plugin
    makes it easy to add buttons to the icon area.

Status area
    The status area shows the line and column containing the body text's cursor,
    and the **UNL** (Uniform Node Location), the path from the top of the outline
    to the selected node.  This path will change as you change outline nodes.

Mini-buffer
    You can type command and search strings in the minibuffer. It works much
    like the Emacs mini-buffer. To enter a command, type &lt;Alt-x&gt; followed by the
    command name and then &lt;return&gt;. To type a search string, type &lt;ctrl-f&gt;
    followed by the search string and then &lt;return&gt;. For full details, see
    `Chapter 5: Using Leo's Commands`_.
</t>
<t tx="ekr.20091130111843.6816">You can use Leo as fairly typical outliner. Play around with some of the
commands from the Outline menu:

- Click the expansion box of nodes to show and hide their children.

- The Insert Node command (Ctrl+I) inserts a new headline into the outline.

- The Cut Node command (Ctrl+Shift+X) deletes a headline and all its children,
  and copies the structure to clipboard - ready to paste with Paste Node command
  (Ctrl+Shift+V). Use the Copy Node command (Ctrl+Shift+C) to copy node to
  clipboard without deleting it from outline. Copy-paste command family works
  across different Leo documents.

- The Move Up (Ctrl+U), Move Down (Ctrl+D), Move Left (Ctrl+L) and Move Right
  (Ctrl+R) commands move the currently selected node, along with all its
  descendants.

- The Promote (Ctrl+}) command makes all the children of a headline siblings of
  the headline. The Demote (Ctrl+{) command makes all following siblings of a
  headline children of the headline.

- Move around the tree and expand/collapse nodes by pressing Alt + arrow keys.
  This also moves the focus to tree, so, after pressing Alt + arrow, you can
  move around by using arrow keys alone. Return the focus to the body control by
  pressing Enter.

- To edit the headline, use press Ctrl+H. This works regardless of whether body
  or headline has focus.

- We'll discuss the Clone Node command in the next section.

You enter body text for any node by selecting the node's headline in the outline
pane and then typing in the body pane. Leo has a full range of `editing
commands`_ that apply to the body pane.
</t>
<t tx="ekr.20091130111843.6817">A **clone** is a node that appears in more than one place in a Leo outline.
Clones are marked with a small red arrow in the icon box. All clones of a node
are actually *the same node*, so any change to one clone affects all clones. For
example, inserting, moving or deleting any child of a clone will change all
other clones on the screen.

Please take a few moments to experiment with clones. Create a node whose
headline is A. Clone node A using the Clone Node command in Leo's Outline menu.
Type some text into the body of either clone of A. The same text appears in the
bodies of all other clones of A. Now insert a node, say B, as a child of any of
the A nodes. All the A nodes now have a B child. See what happens if you clone
B. See what happens if you insert, delete or move nodes that are children of A.
Verify that when you delete the penultimate clone, the last clone becomes a
regular node again.

Clones are much more than a cute feature. Clones allow multiple views of data to
exist **within a single outline**. With Leo, there is no such thing as a single,
"correct" view of data. You can have as many views of data as you like.

To create a new view of the data in your outline, just do the following:

1. Create an *ordinary* node, that will represent the view. We call these nodes
   **view nodes** merely to indicate they represent a view.
   
2. Clone all the nodes from the outline that you want the view to contain. Move
   these clones so they become children of the view node.
   
3. (Optional) You can add regular nodes as children of the view node too.
   
For example, when I fix a bug in Leo, I create an ordinary node to represent the
bug. This **bug node** is my view of all the data in Leo's source code that
relates to the bug. As I discover code related to the bug, I clone their nodes
and move them under the bug node. I'll also add ordinary nodes as children of
the bug node. These nodes contain the original bug report, descriptions of how I
fixed the bug, test data, or any other notes I might want to keep.

Once I have created the bug node, I concentrate *only* on that node and its
children. I can examine the bug node and its children without having to jump
around the outline. Everything I need is in one place. When I get around to
actually fixing the bug I can do so by changing the clones. Again, I do not have
to jump around the outline. It doesn't matter how big or complex the entire
outline is: I am only dealing with the bug node and its children. This extremely
narrow focus makes it *much* easier to fix bugs.

By the way, I never have to remember to save external files. When I change any
clone, Leo marks all instances of that clone throughout the entire outline as
dirty (changed). When I save the Leo outline, Leo automatically writes all the
external files that contain dirty nodes.

Views have an unlimited number of uses. Use them whenever you want to focus your
attention on some smaller set of nodes. For example, I often create view nodes
when studying other people's code. The view node helps me concentrate on just
the part of the code that interests me at the moment.
</t>
<t tx="ekr.20091130111843.6838">.. _style:

Newcomers to Leo frequently ask when to use the \@others directive and when to
use sections. It is good style to use section references only when the order of
text within a external file matters. For example, Python programmers put
docstrings and imports at the start of files. So the body text of
\@thin nodes typically look something like this::

    &lt;&lt; docstring &gt;&gt;
    @language python
    @tabwidth -4
    &lt;&lt; imports &gt;&gt;
    @others

This ensures that the docstring is first in the file, followed by imports,
followed by everything else. Note that the order in which functions are defined
in a file, or methods defined within a class, typically does *not* matter. Thus,
it is good style to define classes like this::

  class myClass:
        &lt;&lt; class attributes &gt;&gt;
        @others

It would be bad style to define a class like this::

  class myClass:
        &lt;&lt; class attributes &gt;&gt;
        &lt;&lt; method 1 &gt;&gt;
        &lt;&lt; method 2 &gt;&gt;
        ...

Not only does this over-specify the order in which methods are defined, but it
requires lots of extra typing. Not only must you add a line for each method, but
headlines must contain section names such as &lt;&lt; method 1 &gt;&gt;, &lt;&lt;method 2&gt;&gt;, etc.
When using \@others it is good style simply to put the name of each method in the
headline.
</t>
<t tx="ekr.20091130111843.6839">A few more words about style:

- It is good style to put each class, function or method in its own node. This
  makes it easy to see the shape of your code.

- It is good style to use organizer nodes to group related functions or methods.
  An organizer node has no content except maybe for comments. Like this::

    + myClass
        + birth and death
            + __init__
            etc.
        + getters
            etc.
        + setters
            etc.
        + misc methods
            etc.

  (In this notation, '+' denotes a headline.) This organization is far superior
  to using hideous comments like::

    ###########
    # Getters #
    ###########

- It is bad style to use \@others in organizer nodes. There is no need to do so.

- It is bad style to use \@others when order does matter. The reason is that it
  is very easy to move nodes in a tree by mistake, say by alphabetizing nodes.
  One wants to make the meaning of a external file immune from such movements.

One last word about style. The world won't end if you happen to use bad style by
mistake: you just might cause a bit more work for yourself than was strictly
necessary. Feel free to invent your own style of using Leo. Still, it would be
wise to "know the rules before you break them."
</t>
<t tx="ekr.20091130111843.6840">.. _scripting:

Leo is fully scriptable using the Python language. Leo can execute any body text
as a Python script. To run the entire body text as a script, simply choose the
node and execute the Execute Script command (Ctrl+B). If text is selected, the
Execute Script command will run just the selected text as the script.

The Execute Script command **preprocesses** the script before executing it, in
exactly the same way that Leo writes external files. Leo expands section
references and processes \@others directives before executing the script. This
allows you to use all of Leo's outlining capabilities to organize your scripts.

Your Python scripts can easily access data in an outline. Leo's execute-script
(Ctrl-B) command predefines three variables, c, g and p, that scripts can use to
easily access any part of any Leo outline, and Leo's own source code. For
example, the following script will print all the headlines in an outline::

    for p in c.all_positions():
        print ' '*p.level(),p.h

The example above is only the beginning of what scripts can do. See `Chapter 7:
Scripting Leo with Python`_ for a complete discussion of scripting Leo.

.. _extending:

**Plugins** are Python modules that change how Leo works. Leo's user have
contributed dozens of plugins that have extended Leo's capabilities in many new
directions. The file leoPlugins.leo contains all plugins that are included in
Leo distributions.

.. _config:

Plugins and other parts of Leo can get options from **@settings** trees.
\@settings trees allow plugins to get options without any further support from
Leo's core code. For a full discussion of \@settings trees, see `Chapter 8:
Customizing Leo`_.
</t>
<t tx="ekr.20091130111843.6843">LeoPyRef.leo (in the core subdirectory of the leo folder) contains almost all of
Leo's source code. It provides hundreds of examples of everything discussed
here. This file will repay close study. For full details on all aspects of Leo
see LeoDocs.leo or `Leo's Users Guide`_.
</t>
<t tx="ekr.20091130111843.6846">.. _`external files`:

Leo stores outline data on your file system in **.leo files**. The format of
these files is `XML`_. You don't have to store all your data in .leo files: Leo
allows you to store parts of your outline data **external files**, that is,
other files on your file system.

**@thin nodes** create external files. \@thin nodes have headlines starting with
\@thin followed by a file name. Some examples::

    @thin leoNodes.py
    @thin ../../notes.text
    
The file name can be an absolute path or a relative path to the file that starts
at Leo's **load directory**, the directory containing the .leo file.

Leo reads and writes external files automatically when you open or save your Leo
outline:

- When you open an outline (.leo file) Leo reads all the external files created
  by the \@thin nodes in the outline. If you have changed an external file
  outside of Leo, Leo will update the corresponding \@thin tree to reflect those
  changes when Leo next opens the outline.

- When you save your outline, Leo writes all **dirty** \@thin nodes. An \@thin
  is dirty if the node or any of its descendant nodes has changed.
  **Important**: When Leo writes an external file, Leo writes all the essential
  information in the \@thin tree to the external file, *not* to the .leo file.
  The only nodes that gets written to the .leo file are nodes that are not
  contained in any \@thin tree.
</t>
<t tx="ekr.20091130194648.6811">Leo's **directives** control such things as syntax coloring, line wrapping
within the body pane and the width of tabs. Leo directives may appear in
headlines or body text. Leo directives start with '@', followed by the name of
the directive. Here are some of Leo's directives::

    @language python
    @tabwidth -4
    @wrap
    @nowrap
    @color
    @nocolor
    @killcolor
    
Most directives must start with the '@' in the leftmost column, but whitespace
may appear before the '@others' and '@all' directives. As we have seen, such
whitespace is significant.
    
Directives apply until overridden in a subtree. All of these directives apply to
the node they are contained in, and also to the entire tree of descendant nodes,
unless **over-ridden** by a similar directive in a descendant node. For example,
the directive::

    @language python
    
tells Leo to syntax color the node and all descendant nodes as Python code.
However, some descendant node mignt contain::

    @language rest
    
which tells Leo to color that node and all of *its* decendants as
reStructureText. This principle applies to almost all of Leo's directives: the
directive is in effect throughout a tree, unless overridden in some subtree.

- **\@color**, **\@nocolor** and **\@killcolor** control syntax coloring.

  You can mix \@nocolor and \@color directives in a single node, but these
  directives apply to descendant nodes only if they are **unambiguous**, that
  is, only if the ancestor node contains exactly one \@color or \@nocolor
  directive.

- **\@encoding** Sets the Unicode encoding used in external files.

- **\@first** directives orces lines to appear before the first sentinel of a
  external file.

    This directive may only appear in \@&lt;file&gt; nodes. A common use of \@first
    directives is to add shebang lines::
    
        @first #! /usr/bin/env python
        
    or Python encoding specifications::
    
        @first # -*- coding: utf-8 -*-

- **\@language** Sets the language used for syntax coloring **and** sets the
  comment delimiters used in sentinel lines and in doc parts. Some examples::

    @language python
    @language c
    @language rest # restructured text
    @language plain # text, that is, no syntax coloring.

- **\@last** Forces lines to appear after the last sentinel of a external file.

- **\@lineending** Specifies the line ending to be used in external files.

- **\@pagewidth** Sets the page width used to break doc parts into lines.

- **\@path** Sets the path to be prepended to filenames in descendant \@thin
  nodes.

- **\@tabwidth** sets the width of tabs.

  Negative tab widths cause Leo to convert tabs to spaces and are highly
  recommended for Python programming.

- **\@wrap** and **\@nowrap** enable or disable line wrapping the Leo's body pane.

Leo treats lines starting with \@ as a normal code line unless the \@ starts a
Leo directive. In particular, Leo will output Python decorators correctly,
provided the name of the decorator does not conflict with a Leo directive.
</t>
<t tx="ekr.20091201091455.6809">We come now to one of Leo's most important and unusual features. When Leo writes
an external file, it does so in a flexible manner, directed by **outline-based
markup**. This markup tells Leo exactly how to create the external file from an
\@thin node.

The **obvious** way to write an external file would be to write the ``@thin`` node
itself followed by all the descendant nodes in **outline order** (the order in
which nodes appear in the outline). But Leo does *not* write external files
exactly this way.

Yes, Leo does indeed start by writing the \@thin node itself. But Leo writes the
``@thin`` node's descendants only when it sees one of three kinds of Leo
markup: section references, the ``@others`` directive and the ``@all`` directive.
We'll discuss these three kinds of markup in the next section.

Section references and the ``@others`` and ``@all`` directives tell Leo to write the
**expansion** of one or more descendant nodes to the external file. Programmers
will recognize this process as akin to macro expansion. The following sections
will explain this process in detail.
</t>
<t tx="ekr.20091201091455.6813">A **section reference** is a line of body text of the form::

    &lt;&lt; a section name &gt;&gt;
    
Here, "a section name" can be any descriptive text not containing "&gt;&gt;". When Leo
encounters a section reference, Leo searches all the descendants of the node
containing the reference looking for a node whose headline matches the section
reference. That is, Leo looks for a descendant node whose headline starts with::

     &lt;&lt; a section name &gt;&gt;
     
We call such nodes **named nodes**. Leo doesn't require an exact match. Leo
ignores whitespace and the case of letters when comparing headlines to section
reference. Also, Leo ignores anything that may follow the section name in a
named node. For example, the following headline will match the section reference
above::

    &lt;&lt; A Section Name &gt;&gt; (to do)

If Leo does find a match, Leo *replaces* the section reference ("&lt;&lt; a section
name&gt;&gt;") by the *expansion* of the body text of the matched node. That is, Leo
replaces the section reference by the body text of the matched node, but Leo
**expands all markup** in the matched node *before* making the replacement. The
entire expansion of the matched node replaces the original section reference.
Programmers will recognize this process as recursive macro expansion.

We have just discussed what happens if Leo does find a descendant named node
that matches the section reference. If no such match is found the section
reference is said to be **undefined** and Leo does not write any data to the
external file. This is *not* a serious error: Leo will will save the erroneous
\@&lt;file&gt; tree in the .leo file instead of the external file. No information is
lost. By the way, Leo's syntax coloring will indicate undefined section
reference by underlining the section name.

**Important**: the indentation of section references matters. When expanding a
section reference, Leo indents every line of the expansion by the leading
whitespace that occurs before the section reference. Note also that you can't
write something after a section reference and expect it to end up on the same
line after expansion--Leo always writes a newline after the expansion.
</t>
<t tx="ekr.20091201091455.6814">The **@others directive** is the second (and most common) way of including
descendant nodes in an external files. When Leo encounters the \@others
directive it replaces the \@others directive by the *expansion* of all
**unnamed** descendant nodes. As with section references, Leo replaces all
markup in the descendant nodes, and the entire expansion replaces the \@others
directive.

In short, section references write *named* nodes; \@others directives write all
*unnamed* nodes. By the way, no node may contain more than one \@others
directive because there would be no way to "apportion" descendant nodes to more
than one \@others directive. However, nodes may contain as many section
references as you like.

As with section references, the indentation of the \@others directive matters.
This allows Leo to handle Python source code properly. For exmple, the following
is a common way of representing a Python class::

    class myClass:
        '''a docstring'''
        @others
        
When Leo writes this node to an external file, Leo will write the first two
lines to the external file, with the indentation in effect for the node. Leo
will then write all descendant nodes to the external files, with *additional*
indentation equal to the leading whitespace appearing before the \@others
directive.
</t>
<t tx="ekr.20091201091455.6815">The \@all directive is the third, simplest (and least common) way of including
descendant nodes. This directive causes Leo to write all descendant nodes in
outline order, regardless of whether they are named or not. Furthermore, the
\@all directive does not expand any markup in descendant nodes. This results in
Leo writing the external file in the "obvious" way. That is, Leo writes all
descendant nodes in outline order.

Use the all directive if your external file contains unrelated nodes. For
example, I use an external file to store programming notes. These notes
typically contain snippets of programming source code, but there is no real
relationships between the snippets--the file is simply a grab bag of
information. The \@all directive is designed for this situation.
</t>
<t tx="ekr.20091216113613.6638">Create buttons to quickly move nodes to other nodes

Quickly move nodes from around the tree to one or more target nodes.

Adds 'Move/Clone/Copy To Last Child Button' and 'Move/Clone/Copy To First Child
Button' commands to the Move submenu on the Outline menu, and the context menu,
if contextmenu.py is enabled.

Select a node 'Foo' and then use the 'To Last Child Button' command. The adds a
'to Foo' button to the button bar. Now select another node and click the 'to
Foo' button. The selected node will be moved or cloned to the last child of the
node 'Foo'.

'To First Child Button' works the same way, except that moved nodes are inserted
as the first child of the target node.
</t>
<t tx="ekr.20091222125456.6641">Using Leo quickly becomes second nature:

- You can use Leo like any ordinary outliner, as a filing cabinet, but Leo's
  clones makes this filing cabinet much more flexible and useful than usual.

- You create external files using \@thin trees. Within \@thin trees, you use
  section references and the \@others directive to tell Leo how to write nodes
  to the external file. Directives such as \@tabwidth and \@language provide other
  information to Leo. Leo's \@thin trees allow you to organize your scripts
  and programs with Leo's outline structure.
  
- You can execute Python scripts from any node in a Leo outline. Leo scripts
  have full, easy, access to all the information in the outline. Using scripts
  and plugins, you can easily add new features to Leo.</t>
<t tx="ekr.20100118181428.7557"></t>
<t tx="ekr.20100118181428.7559">They wiped out the newly-inserted selection range.</t>
<t tx="ekr.20100118181428.7570">My biggest annoyance is the invalid bug 409442, I have to use the tk
GUI because of it.

I've also complained about it in this thread:
http://groups.google.com/group/leo-editor/browse_thread/thread/07cdbb... 

----- Ville +1
I feel your pain.

Please try this workaround (run with ctrl+b):

tree = c.frame.tree.treeWidget
tree.setColumnCount(2)

-----
&gt; Isn't it possible to stick this tree.setColumnCount(2) into some
&gt; constructor in the leo qt GUI plugin so the outline pane would have
&gt; the horizontal scrollbar by default?

Yes, but it's not sure we want to have 2 columns in the tree widget -
and it would create scrollbar on many occasions when it's not
necessary.

So this is not a simple fix for your problem, it has implications
beyond your problem. </t>
<t tx="ekr.20100118181428.7571"></t>
<t tx="ekr.20100118181428.7614">Fixed bug Bug 498688: Undo back to last saved content still shows file as
modified ("*" in title)</t>
<t tx="ekr.20100118181428.7712"></t>
<t tx="ekr.20100118181428.7715">Bug 362950: during body text undo selection goes nuts and view moves</t>
<t tx="ekr.20100118181428.7830"></t>
<t tx="ekr.20100118181428.7831"></t>
<t tx="ekr.20100118181428.8070"></t>
<t tx="ekr.20100118181428.8077">Fixes bug 497332: importing xml via @data import_xml_tags does not allow dashes in tag.

For characters valid in names see:
www.w3.org/TR/2008/REC-xml-20081126/#NT-Name</t>
<t tx="ekr.20100118181428.8086"></t>
<t tx="ekr.20100118181428.8090">Bug 404993: alt+U (universal argument) "freezes" leo state

Press alt+U displays "Universal argument:" in minibuffer, and there is no
obvious way to get out of this state. It seems ctrl+G gets you out of it, but
that's not really obvious. ESC should do it.
</t>
<t tx="ekr.20100118181428.8109">http://groups.google.com/group/leo-editor/browse_thread/thread/81f7bb5060ed8b01</t>
<t tx="ekr.20100118181428.8236"></t>
<t tx="ekr.20100118181428.8239"></t>
<t tx="ekr.20100118181428.8240"></t>
<t tx="ekr.20100118181428.8242"></t>
<t tx="ekr.20100118181428.8248">Leo now adds a leading period if needed.</t>
<t tx="ekr.20100118181428.8252"></t>
<t tx="ekr.20100118181428.8257"></t>
<t tx="ekr.20100118181428.8262"></t>
<t tx="ekr.20100118181428.8275"></t>
<t tx="ekr.20100118181428.8278"></t>
<t tx="ekr.20100118181428.8281"></t>
<t tx="ekr.20100118181428.8294"></t>
<t tx="ekr.20100118181428.8297">http://groups.google.com/group/leo-editor/browse_thread/thread/8616f4e171e1a24b</t>
<t tx="ekr.20100118181428.8298">http://groups.google.com/group/leo-editor/browse_thread/thread/33e87adbff5d69d9
</t>
<t tx="ekr.20100118181428.8299"></t>
<t tx="ekr.20100118181428.8302">This is now bound in the EKR bindings to insert-node.</t>
<t tx="ekr.20100118181428.8306">http://groups.google.com/group/leo-editor/browse_thread/thread/add6242d6f4fc476</t>
<t tx="ekr.20100118181428.8307"></t>
<t tx="ekr.20100118181428.8334"></t>
<t tx="ekr.20100118181428.8358">Form-feed characters were causing problems with Python 3k.</t>
<t tx="ekr.20100118181428.8362">It can be alarming to select a small chapter in a large outline.</t>
<t tx="ekr.20100118181428.8363"></t>
<t tx="ekr.20100118181428.8365">This fixes the following two bugs:

- 421957 When body_pane_wraps is set to true, Previous-Line and Next-Line do not
  work as expected.

- 489917 Cursor placement defect </t>
<t tx="ekr.20100118181428.8413">http://groups.google.com/group/leo-editor/browse_thread/thread/b84659e608ba44d5</t>
<t tx="ekr.20100118181428.8447">http://groups.google.com/group/leo-editor/browse_thread/thread/cdf78cbca5c526be</t>
<t tx="ekr.20100118181428.8449">Shift-PageUp/Down were not working.</t>
<t tx="ekr.20100118181428.8473">http://bugs.launchpad.net/leo-editor/+bug/381895</t>
<t tx="ekr.20100118181428.8481">https://bugs.launchpad.net/leo-editor/+bug/451377</t>
<t tx="ekr.20100118181428.8485">The Tk part of this bug can not be fixed.</t>
<t tx="ekr.20100118181428.8486">http://groups.google.com/group/leo-editor/browse_thread/thread/b77b5260854ffbf6</t>
<t tx="ekr.20100118181428.8497">http://groups.google.com/group/leo-editor/browse_thread/thread/b77b5260854ffbf6</t>
<t tx="ekr.20100118181428.8502">http://groups.google.com/group/leo-editor/browse_thread/thread/c8f3edda9de05484
</t>
<t tx="ekr.20100118181428.8514">ctrl-tab (currently binded to cycle-focus) didn't work in windows with pyqt.
</t>
<t tx="ekr.20100118181428.8517">https://bugs.launchpad.net/leo-editor/+bug/349027</t>
<t tx="ekr.20100118181428.8518"></t>
<t tx="ekr.20100118181428.8522">https://bugs.launchpad.net/leo-editor/+bug/486433</t>
<t tx="ekr.20100118181428.8523">https://bugs.launchpad.net/leo-editor/+bug/420988</t>
<t tx="ekr.20100118181428.8524"></t>
<t tx="ekr.20100118181428.8525"></t>
<t tx="ekr.20100118181428.8813">Leo 4.7 beta 1                January 28, 2009

Leo 4.7 release beta 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.7 beta 1 fixes all known serious bugs in Leo.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.7:
--------------------------

- Leo now uses the simplest possible internal data model.
  This is the so-called "one-node" world.
- Leo supports Python 3.x.
- Leo requires Python 2.6 or above.
- Several important improvements in file handling.
    - Leo converts @file nodes to @thin nodes automatically.
    - Leo creates a 'Recovered Nodes' node to hold data that
      otherwise might be lost due to clone conflicts.
    - @auto-rst now works much more reliably reliably.
    - Leo no longer @noref trees.  Such trees are not
      reliable in cooperative environments.
- A new Windows installer.
- Many other features, including new command line options and new plugins.
- Dozens of bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20100118181428.8815">Leo requires Python 2.6 or above, including Python 3.0 and above.</t>
<t tx="ekr.20100118181428.8827"></t>
<t tx="ekr.20100119145003.7319"></t>
<t tx="ekr.20100119145003.7320"></t>
<t tx="ekr.20100119145003.7322"></t>
<t tx="ekr.20100119145003.7324"></t>
<t tx="ekr.20100119145003.7325"></t>
<t tx="ekr.20100119145003.7327">Note: changing a headline as *no effect* on an @nosent file!
The only bug was that redraw_after_head_changed must update icons.</t>
<t tx="ekr.20100119145003.7358"></t>
<t tx="ekr.20100119145003.7531"></t>
<t tx="ekr.20100119145003.7546"></t>
<t tx="ekr.20100119145003.7612"></t>
<t tx="ekr.20100119145003.7618"></t>
<t tx="ekr.20100119145003.7625"></t>
<t tx="ekr.20100119145003.7629"></t>
<t tx="ekr.20100119145003.7632"></t>
<t tx="ekr.20100119145003.7643"></t>
<t tx="ekr.20100119145003.7718"></t>
<t tx="ekr.20100122073254.11655">This section describes the process of creating an importer for a new language.
There are a set of "importers" in leoImport.py, all based on the
baseScannerClass class. You can define your own importer by creating a subclass.
This shouldn't be too difficult: baseScannerClass is supposed to do almost all
the work. With luck, your subclass might be very simple, as with class cScanner.

**Important** As I write this, I realize that I remember very little about the
code, but I do remember its general organization and the process of creating a
new importer. The following should be all you need to write any importer.

This base class has three main parts:

1. The "parser" that recognizes where nodes begin and end.

2. The "code generator" the actually creates the imported nodes.

3. Checking code that ensures that the imported code is equivalent
   to the original code.

You should never have to change the code generators or the checking code.
Confine your attention to the parser.

The parser thinks it is looking for classes, and within classes,
method definitions.  Your job is to tell the parser how to do this.
Let's look at part of the ctor for baseScannerClass for clues::

   # May be overridden in subclasses.
   self.anonymousClasses = [] # For Delphi Pascal interfaces.
   self.blockCommentDelim1 = None
   self.blockCommentDelim2 = None
   self.blockCommentDelim1_2 = None
   self.blockCommentDelim2_2 = None
   self.blockDelim1 = '{'
   self.blockDelim2 = '}'
   self.blockDelim2Cruft = [] # Stuff that can follow .blockDelim2.
   self.classTags = ['class',] # tags that start a tag.
   self.functionTags = []
   self.hasClasses = True
   self.hasFunctions = True
   self.lineCommentDelim = None
   self.lineCommentDelim2 = None
   self.outerBlockDelim1 = None
   self.outerBlockDelim2 = None
   self.outerBlockEndsDecls = True
   self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
   self.sigFailTokens = []
       # A list of strings that abort a signature when seen in a tail.
       # For example, ';' and '=' in C.
   self.strict = False # True if leading whitespace is very significant.

Naturally, this looks like gibberish at first. I do *not* remember what all
these things do in detail, although obviously the names mean something. What I
*do* remember is that these ivars control the operation of the startsFunction
and startsClass methods and their helpers (especially startsHelper) and
the methods that call them, scan and scanHelper. Most of these methods have a
trace var that will enable tracing during importing.

So the strategy is simple: study startsHelper in detail, set the ivars above to
make startsHelper do what you want, and trace until things work as you want.

There is one more detail. Sometimes the ivars above are not sufficient to get
the job done. In that case, subclasses will override various methods of the
parser, but *not* the code generator. If indentation is important, you will want
to look at the Python importer. Notice that it overrides skipCodeBlock, called
by startsHelper.

That's about it. It would be pointless to give you more details, because those
details would lead you *away* from the process you need to follow. Having said
that, feel free to ask further questions. I'll be glad to answer them.</t>
<t tx="ekr.20100124164700.11919">@nocolor-node

It looks like you should be able to put the following in an
@font node, and get restructured text bold to appear in bold onscreen:

rest_keyword2_font_size = 16
rest_keyword2_font_family = Bitstream Charter
rest_keyword2_font_slant = roman
rest_keyword2_font_weight = bold

However nothing happens when I do this. The python examples in the
test.leo file work fine for me, so I'm not sure what's gone wrong.

I think that the following should also work, but it's also currently
not doing anything for me:

@color rest_keyword2_color = black

==================

Rev 2706 fixes a significant colorizer bug that caused your problem.
Previously, the colorizer inited the so-called configuration tags only
once, which is wrong. These tags are what the @font settings specify.
Now, the colorizer inits the tags when the language changes when
switching nodes.  Usually the language doesn't change, so the new code
will be approximately as fast as the old. 
</t>
<t tx="ekr.20100124164700.11920">'backward-find-character'
'find-character'
</t>
<t tx="ekr.20100124164700.11921">@nocolor-node

On Mon, Jan 18, 2010 at 9:25 PM, tfer &lt;tfetherston@aol.com&gt; wrote:

cmd.exe /k C:\PyDev\leo-editor\trunk\launchLeo.py --gui=qttabs -- ipython

1) (??) the button removal menu just flash on right mouse click, disappears immediately.

2) Leo opens up the workbook, I open a new doc in a tab, 'untitled', save it,
   get saved ... in log, however, tab title does not change unless I close and
   reload it.
</t>
<t tx="ekr.20100124164700.11922">@
The problem occurs because the QtGui.QLineEdit object goes away
when the minibuffer gets focus and the QTreeWidget loses focus.

The fix: add a 'permanent' ivar to leoQtTextWidgets, and set
this ivar to False for headline widgets.</t>
<t tx="ekr.20100124164700.11923">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/db797dd1d4dddffb

1) Create an @thin file based outline.
2) In the @thin file, create an unreferenced section (something like a
  header &lt;&lt;This Section Is Bogus&gt;&gt;).
3) Now, File-&gt;Exit
4) A dialog box pops up
  (Save changes to leo_file.leo before quitting? Yes/No/Cancel)
5) Click "Yes"
6) In the log pane, you will see: "undefined section" and "saved: leo_file.leo"
  and in the console window, you see "undefined section: ..."

The point is that I can't kill Leo if I keep saying "Yes" to the
"Save change before quitting" dialog. This is definitely not the
intended behavior. The correct behavior would be to save the file,
give me the warning about the undefined section, and exit.

EKR: The fix was simple: write_leo_file ignores the status returned from
c.atFileCommands.writeAll.

Note that Leo writes the write error to the console as well as the log pane,
so this should be safe enough.</t>
<t tx="ekr.20100124164700.11924"></t>
<t tx="ekr.20100124164700.11925"></t>
<t tx="ekr.20100124164700.11926">@nocolor-node

I also unhappily discovered that any file named somedoc.leo.bak will
get deleted whenever you save a file named somedoc.leo.

===========

This turned into a major refactoring of write_Leo_file.</t>
<t tx="ekr.20100124164700.11927">https://bugs.launchpad.net/leo-editor/+bug/510148

The fix was in sortSiblings.
</t>
<t tx="ekr.20100124164700.11928">@nocolor-node

- 'encoding' arg removed from appendStringToBody, setBodyString

- There are too many usages of _bodyString !!

- There is no way to give an encoding to setBodyString:
    It should give an internal error if the s arg is not unicode.</t>
<t tx="ekr.20100124164700.11929"># see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    nl = g.choose(newline,'\n','')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.
    if app.logInited:
        s = s + '\n'

    if g.isPython3:
        s2 = s
    else:
        s2 = g.toEncodedString(s,encoding)

    if app.logInited:
        try: # We can't use any print keyword args in Python 2.x!
            sys.stdout.write(s2)
        except Exception:
            if not g.pr_warning_given:
                g.pr_warning_given = True
                print('unexpected Exception in g.pr')
                print('make sure your sitecustomize.py contains::')
                print('    sys.setdefaultencoding("utf-8")')
                g.es_exception()
                g.trace(g.callers())
            s2 = s.encode('ascii',"replace")
            if g.isPython3:
                s2 = str(s2,'ascii','replace')
            sys.stdout.write(s2)
    else:
        app.printWaiting.append(s2)
</t>
<t tx="ekr.20100124164700.11930">
c:\leo.repo\trunk&gt;bzr di -r2685..2686 leo\plugins\qtGui.py   
=== modified file 'leo/plugins/qtGui.py'
--- leo/plugins/qtGui.py	2010-01-15 15:18:58 +0000
+++ leo/plugins/qtGui.py	2010-01-16 14:51:14 +0000
@@ -429,7 +429,7 @@
         newText = w.getAllText() # Converts to unicode.

         # Get the previous values from the vnode.
-        oldText = g.app.gui.toUnicode(p.v._bodyString)
+        oldText = p.v._bodyString ### already unicode ### g.app.gui.toUnicode(p.v._bodyString)
         if oldText == newText:
             # This can happen as the result of undo.
             # g.trace('*** unexpected non-change',color="red")
@@ -669,7 +669,7 @@

         w = self.widget
         s = w.text()
-        return g.app.gui.toUnicode(s)
+        return g.u(s) ### g.app.gui.toUnicode(s)
     #@nonl
     #@-node:ekr.20081121105001.551:getAllText
     #@+node:ekr.20081121105001.552:getInsertPoint
@@ -687,7 +687,7 @@
         if w.hasSelectedText():
             i = w.selectionStart()
             s = w.selectedText()
-            s = g.app.gui.toUnicode(s)
+            s = g.u(s) ### (s)
             j = i + len(s)
         else:
             i = j = w.cursorPosition()
@@ -722,7 +722,7 @@

         w = self.widget
         s = w.text()
-        s = g.app.gui.toUnicode(s)
+        s = g.u(s) ### g.app.gui.toUnicode(s)
         i = w.toPythonIndex(i)
         i = max(0,min(i,len(s)))
         w.setCursorPosition(i)
@@ -734,7 +734,7 @@
         # g.trace(i,j,insert,w)
         if i &gt; j: i,j = j,i
         s = w.text()
-        s = g.app.gui.toUnicode(s)
+        s = g.u(s) ### g.app.gui.toUnicode(s)
         n = len(s)
         i = max(0,min(i,n))
         j = max(0,min(j,n))
@@ -1407,7 +1407,7 @@

         w = self.widget
         s = w.text()
-        s = g.app.gui.toUnicode(s)
+        s = g.u(s) ### g.app.gui.toUnicode(s)
         return s
     #@-node:ekr.20081121105001.564:getAllText
     #@+node:ekr.20081121105001.565:getInsertPoint
@@ -1538,7 +1538,7 @@
         if self.check():
             w = self.widget
             s = w.text()
-            return g.app.gui.toUnicode(s)
+            return g.u(s) ### g.app.gui.toUnicode(s)
         else:
             return ''
     #@nonl
@@ -1561,7 +1561,7 @@
             if w.hasSelectedText():
                 i = w.selectionStart()
                 s = w.selectedText()
-                s = g.app.gui.toUnicode(s)
+                s = g.u(s) ### g.app.gui.toUnicode(s)
                 j = i + len(s)
             else:
                 i = j = w.cursorPosition()
@@ -1608,7 +1608,7 @@

         w = self.widget
         s = w.text()
-        s = g.app.gui.toUnicode(s)
+        s = g.u(s) ### g.app.gui.toUnicode(s)
         i = self.toPythonIndex(i)
         i = max(0,min(i,len(s)))
         w.setCursorPosition(i)
@@ -1621,7 +1621,7 @@
         # g.trace(i,j,insert,w)
         if i &gt; j: i,j = j,i
         s = w.text()
-        s = g.app.gui.toUnicode(s)
+        s = g.u(s) ### g.app.gui.toUnicode(s)
         n = len(s)
         i = max(0,min(i,n))
         j = max(0,min(j,n))
@@ -5551,7 +5551,6 @@
     def setMenuLabel (self,menu,name,label,underline=-1):

         def munge(s):
-            # s = g.app.gui.toUnicode(s)
             return g.u(s or '').replace('&amp;','')

         # menu is a qtMenuWrapper.
@@ -6878,8 +6877,9 @@
         cb = self.qtApp.clipboard()
         if cb:
             # cb.clear()  # unnecessary, breaks on some Qt versions
-            if type(s) == type(''):
-                s = g.app.gui.toUnicode(s)
+            ###
+            ###if type(s) == type(''):
+            ###    s = g.app.gui.toUnicode(s)

             QtGui.QApplication.processEvents()
             cb.setText(s)
@@ -6898,7 +6898,7 @@
             QtGui.QApplication.processEvents()
             s = cb.text()
             if trace: g.trace (len(s),type(s))
-            s = g.app.gui.toUnicode(s)
+            s = g.app.gui.toUnicode(s) # Assume nothing about the type of s.
             return s
         else:
             g.trace('no clipboard!')
@@ -7017,7 +7017,7 @@
         parent = None
         title = 'Enter Leo id'
         s,ok = QtGui.QInputDialog.getText(parent,title,message)
-        return g.app.gui.toUnicode(s)
+        return g.u(s) ### g.app.gui.toUnicode(s)
     #@nonl
     #@-node:ekr.20081121105001.484:runAskLeoIDDialog
     #@+node:ekr.20081121105001.485:runAskOkDialog
@@ -7099,9 +7099,7 @@
             return [g.u(s) for s in lst]
         else:
             s = QtGui.QFileDialog.getOpenFileName(parent,title,os.curdir,filter)
-            s = g.app.gui.toUnicode(s)
-            return s
-    #@nonl
+            return g.u(s) ### g.app.gui.toUnicode(s)
     #@-node:ekr.20081121105001.488:runOpenFileDialog
     #@+node:ekr.20090722094828.3653:runPropertiesDialog (qtGui)
     def runPropertiesDialog(self,
@@ -7125,7 +7123,7 @@
         parent = None
         filter_ = self.makeFilter(filetypes)
         s = QtGui.QFileDialog.getSaveFileName(parent,title,os.curdir,filter_)
-        return g.app.gui.toUnicode(s)
+        return g.u(s) ### g.app.gui.toUnicode(s)
     #@-node:ekr.20081121105001.489:runSaveFileDialog
     #@+node:ekr.20081121105001.490:runScrolledMessageDialog
     def runScrolledMessageDialog (self, title='Message', label= '', msg='', c=None, **kw):
@@ -7421,7 +7419,7 @@
             s = g.u(s)
             return s
         except Exception:
-            g.trace('*** Unicode Error: bugs possible')
+            # g.trace('*** Unicode Error: bugs possible')
             return g.toUnicode(s,'utf-8',reportErrors='replace')
     #@-node:ekr.20081121105001.502:toUnicode (qtGui)
     #@+node:ekr.20081121105001.503:widget_name (qtGui)

</t>
<t tx="ekr.20100124164700.11931">def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                s = theFile.read() # type(s) is bytes.
                s = self.cleanSaxInputString(s)
                theFile = BytesIO(s)
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the &lt;?xml&gt; element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
</t>
<t tx="ekr.20100124164700.11932"></t>
<t tx="ekr.20100124164700.11933">def toEncodedString (s,encoding,reportErrors=False):

    if g.isUnicode(s):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors: g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
</t>
<t tx="ekr.20100124164700.11934">def toEncodedStringWithErrorCode (s,encoding,reportErrors=False):

    ok = True

    if g.isUnicode(s):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors: g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
            ok = False
    return s, ok
</t>
<t tx="ekr.20100124164700.11935">def toUnicode (s,encoding=None,reportErrors=False):

    # The encoding is usually g.app.defaultEncoding,
    # but is may be different while importing or reading files.
    if encoding is None:
        encoding = g.app.defaultEncoding

    if isPython3:
        convert,mustConvert,nullVal = str,g.isBytes,''
    else:
        convert,nullVal = unicode,unicode('')
        def mustConvert (s):
            return type(s) != types.UnicodeType

    if not s:
        s = nullVal
    elif mustConvert(s):
        try:
            s = convert(s,encoding,'strict')
        except (UnicodeError,Exception):
            s = convert(s,encoding,'replace')
            if reportErrors: g.reportBadChars(s,encoding)
    else:
        pass

    return s
</t>
<t tx="ekr.20100124164700.11936">if isPython3: # g.not defined yet.
    def u(s):
        return s
    def ue(s,encoding):
        return str(s,encoding)
else:
    def u(s):
        return unicode(s)
    def ue(s,encoding):
        return unicode(s,encoding)
</t>
<t tx="ekr.20100124164700.11937">def toUnicodeWithErrorCode (s,encoding,reportErrors=False):

    ok = True
    if g.isPython3: f = str
    else: f = unicode
    if s is None:
        s = g.u('')
    if not g.isUnicode(s):
        try:
            s = f(s,encoding,'strict')
        except (UnicodeError,ValueError):
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = f(s,encoding,'replace')
            ok = False
    return s,ok
</t>
<t tx="ekr.20100124164700.11938"></t>
<t tx="ekr.20100124164700.11939">def put (self,s):

    '''Put string s to self.outputFile. All output eventually comes here.'''

    # Improved code: self.outputFile (a cStringIO object) always exists.
    # g.trace(g.callers(1),repr(s))
    if s:
        self.putCount += 1
        if not g.isPython3:
            s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
        self.outputFile.write(s)

def put_dquote (self):
    self.put('"')

def put_dquoted_bool (self,b):
    if b: self.put('"1"')
    else: self.put('"0"')

def put_flag (self,a,b):
    if a:
        self.put(" ") ; self.put(b) ; self.put('="1"')

def put_in_dquotes (self,a):
    self.put('"')
    if a: self.put(a) # will always be True if we use backquotes.
    else: self.put('0')
    self.put('"')

def put_nl (self):
    self.put("\n")

def put_tab (self):
    self.put("\t")

def put_tabs (self,n):
    while n &gt; 0:
        self.put("\t")
        n -= 1</t>
<t tx="ekr.20100124164700.11944"></t>
<t tx="ekr.20100124164700.11946">@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/510145

Current leo trunk, r2732, Slackware Linux

- I go to /tmp in terminal
- there is no aaa.leo there (this is important, see below why)
- I launch leo (the current working directory is /tmp)
- I select "File-&gt;Save as" menu item
- the save file dialog opens in /tmp, this is correct
- I type in the file name "aaa" then hit "Save" button
- leo dumps an error in the log pane:

exception renaming /tmp/aaa.leo to /tmp/tmpbNydoS
IOError: [Errno 2] No such file or directory: u'/tmp/aaa.leo'

=============

The solution was to create the backup file only if fileName exists.</t>
<t tx="ekr.20100124164700.11947">def writeToFileHelper (self,fileName,toOPML):

    c = self.c ; toZip = c.isZipped
    ok,backupName = self.createBackupFile(fileName)
    if not ok: return False
    fileName,theActualFile = self.createActualFile(fileName,toOPML,toZip)
    self.mFileName = fileName
    self.outputFile = StringIO() # Always write to a string.

    try:
        if toOPML:
            self.putToOPML()
        else:
            self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s # 2010/01/19: always set this.
        if toZip:
            self.writeZipFile(s)
        else:
            if g.isPython3:
                s = bytes(s,self.leo_file_encoding,'replace')
            theActualFile.write(s)
            theActualFile.close()
            c.setFileTimeStamp(fileName)
            # raise AttributeError # To test handleWriteLeoFileException.
            # Delete backup file.
            if backupName and g.os_path_exists(backupName):
                self.deleteFileWithMessage(backupName,'backup')
        return True
    except Exception:
        self.handleWriteLeoFileException(
            fileName,backupName,theActualFile)
        return False
</t>
<t tx="ekr.20100124164700.11948">def createActualFile (self,fileName,toOPML,toZip):

    c = self.c

    if toOPML and not self.mFileName.endswith('opml'):
        fileName = self.mFileName + '.opml'

    if toZip:
        self.toString = True
        theActualFile = None
    else:
        try:
            # 2010/01/21: always write in binary mode.
            theActualFile = open(fileName,'wb')
        except IOError:
            theActualFile = None

    return fileName,theActualFile
</t>
<t tx="ekr.20100124164700.11949">def createBackupFile (self,fileName):

    '''
        Create a closed backup file and copy the file to it,
        but only if the original file exists.
    '''

    c = self.c

    if g.os_path_exists(fileName):
        # backupName = g.os_path_join(g.app.loadDir,fileName+'.bak')
        fd,backupName = tempfile.mkstemp(text=False)
        os.close(fd)
        ok = g.utils_rename(c,fileName,backupName)
        if not ok and self.read_only:
            g.es("read only",color="red")
    else:
        ok,backupName = True,None

    return ok,backupName
</t>
<t tx="ekr.20100124164700.11950">def handleWriteLeoFileException(self,fileName,backupName,theActualFile):

    c = self.c

    g.es("exception writing:",fileName)
    g.es_exception(full=True)

    if theActualFile:
        theActualFile.close()

    # Delete fileName.
    if fileName and g.os_path_exists(fileName):
        self.deleteFileWithMessage(fileName,'')

    # Rename backupName to fileName.
    if backupName and g.os_path_exists(backupName):
        g.es("restoring",fileName,"from",backupName)
        g.utils_rename(c,backupName,fileName)
    else:
        g.es_print('does not exist!',backupName)

</t>
<t tx="ekr.20100124164700.11951">@nocolor-node

Made sure _bodyString _headString used only in leoNodes.py.

We allow setting this vars in file reading code.

*** p.b/p.h setters call c.setBody/HeadString,
    which are very slow!
</t>
<t tx="ekr.20100124164700.11952">def bodyString (self):

    return self.v.bodyString()

def headString (self):

    return self.v.headString()

def cleanHeadString (self):

    return self.v.cleanHeadString()
</t>
<t tx="ekr.20100124164700.11953"></t>
<t tx="ekr.20100124164700.11954">def __get_b(self):

    p = self
    return p.bodyString()

def __set_b(self,val):

    p = self ; c = p.v and p.v.context
    if c:
        c.setBodyString(p, val)
        # Don't redraw the screen: p.b must be fast.
        # c.redraw_after_icons_changed()

b = property(
    __get_b, __set_b,
    doc = "position body string property")
</t>
<t tx="ekr.20100124164700.11955">def __get_h(self):

    p = self
    return p.headString()

def __set_h(self,val):

    p = self ; c = p.v and p.v.context
    if c:
        c.setHeadString(p,val)
        # Don't redraw the screen: p.h must be fast.
        # c.redraw_after_head_changed()

h = property(
    __get_h, __set_h,
    doc = "position headline string property")  
</t>
<t tx="ekr.20100124164700.11956">def __get_gnx(self):
    p = self
    return g.app.nodeIndices.toString(p.v.fileIndex)

gnx = property(
    __get_gnx, # __set_gnx,
    doc = "position gnx property")
</t>
<t tx="ekr.20100124164700.11957"></t>
<t tx="ekr.20100124164700.11958">def __get_b(self):

    v = self
    return v.bodyString()

def __set_b(self,val):

    v = self
    v.setBodyString(val)

b = property(
    __get_b, __set_b,
    doc = "vnode body string property")
</t>
<t tx="ekr.20100124164700.11959">def __get_h(self):

    v = self
    return v.headString()

def __set_h(self,val):

    v = self
    v.setHeadString(val)

h = property(
    __get_h, __set_h,
    doc = "vnode headline string property")  
</t>
<t tx="ekr.20100124164700.11960">def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
</t>
<t tx="ekr.20100124164700.11961">def __get_gnx(self):
    v = self
    return g.app.nodeIndices.toString(v.fileIndex)

gnx = property(
    __get_gnx, # __set_gnx,
    doc = "vnode gnx property")
</t>
<t tx="ekr.20100124164700.11962">def setBodyString (self,s):

    # trace = False and not g.unitTesting
    v = self
    # if trace and v._bodyString != s:
        # g.trace('v %s %s -&gt; %s %s\nold: %s\nnew: %s' % (
            # v.h, len(v._bodyString),len(s),g.callers(5),
            # v._bodyString,s))
    v._bodyString = g.toUnicode(s,reportErrors=True)

def setHeadString (self,s):
    v = self
    v._headString = g.toUnicode(s,reportErrors=True)

initBodyString = setBodyString
initHeadString = setHeadString
setHeadText = setHeadString
setTnodeText = setBodyString
</t>
<t tx="ekr.20100124164700.11963">def setBodyString (self,p,s):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s)
    current = c.p
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v==current.v:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the vnode up-to-date.
    if v.b != s:
        v.setBodyString(s)
        v.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
        c.redraw_after_icons_changed()</t>
<t tx="ekr.20100124164700.11964">def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types &amp; helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())

    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            v = bunch2.v
            afterTree.append(
                g.Bunch(v=v,head=v.h[:],body=v.b[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)
</t>
<t tx="ekr.20100124164700.11965">@nocolor-node

- Removed thinFile arg from atFile.read.
  atFile.read can uncache *any* cached file.
- Removed thinfile arg from initReadIvars.
- self.thinFile ivar set only in readOpenFile.
- atFile.read no longer calls scanHeaderForThin:
  we simply use the thinFile value returned by scanHeader.
- atFile.readOpenFile deletes children as needed.</t>
<t tx="ekr.20100124164700.11972">def readOpenFile(self,root,theFile,fileName,deleteNodes=False):

    '''Read an open derived file.

    Leo 4.5 and later can only read 4.x derived files.'''

    at = self

    firstLines,read_new,thinFile = at.scanHeader(theFile,fileName)
    at.thinFile = thinFile
        # 2010/01/22: use *only* the header to set self.thinFile.

    if deleteNodes and at.shouldDeleteChildren(root,thinFile):
        root.v.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        firstLines = [] ; lastLines = []
        if at.atShadow:
            g.trace(g.callers())
            g.trace('invalid @shadow private file',fileName)
            at.error('invalid @shadow private file',fileName)
        else:
            at.error('can not read 3.x derived file',fileName)
            g.es('you may upgrade these file using Leo 4.0 through 4.4.x')
            g.trace('root',root and root.h,fileName)

    if root:
        root.v.setVisited() # Disable warning about set nodes.

    &lt;&lt; handle first and last lines &gt;&gt;

    return thinFile
</t>
<t tx="ekr.20100124164700.11973">try:
    body = root.v.tempBodyString
except Exception:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.tempBodyString = s
</t>
<t tx="ekr.20100124164700.11974">def shouldDeleteChildren (self,root,thinFile):

    '''Return True if we should delete all children before a read.'''

    # Delete all children except for old-style @file nodes

    if root.isAtNoSentFileNode():
        return False
    elif root.isAtFileNode() and not thinFile:
        return False
    else:
        return True
</t>
<t tx="ekr.20100124164700.11975">def initReadIvars(self,root,fileName,
    importFileName=None,
    perfectImportRoot=None,
    atShadow=False,
):

    importing = importFileName is not None

    self.initCommonIvars()

    &lt;&lt; init ivars for reading &gt;&gt;

    self.scanDefaultDirectory(root,importing=importing)
    if self.errors: return

    # Init state from arguments.
    self.perfectImportRoot = perfectImportRoot
    self.importing = importing
    self.root = root
    self.targetFileName = fileName
    self.thinFile = False # 2010/01/22: was thinFile
    self.atShadow = atShadow
</t>
<t tx="ekr.20100124164700.11977">def scanHeader(self,theFile,fileName):

    """Scan the @+leo sentinel.

    Sets self.encoding, and self.start/endSentinelComment.

    Returns (firstLines,new_df,isThinDerivedFile) where:
    firstLines        contains all @first lines,
    new_df            is True if we are reading a new-format derived file.
    isThinDerivedFile is True if the file is an @thin file."""

    trace = False
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    &lt;&lt; skip any non @+leo lines &gt;&gt;
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
        # g.trace('start',repr(start),'end',repr(end))
    else:
        at.error("No @+leo sentinel in: %s" % fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile
</t>
<t tx="ekr.20100124164700.11978">@ Queue up the lines before the @+leo.

These will be used to add as parameters to the @first directives, if any.
Empty lines are ignored (because empty @first directives are ignored).
NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on
the comment delimiters we set here.

at-first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
if trace: g.trace('first line',repr(s))
while len(s) &gt; 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)

n = len(s)
valid = n &gt; 0
</t>
<t tx="ekr.20100124164700.11979">def parseLeoSentinel (self,s):

    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    start = '' ; end = '' ; isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    &lt;&lt; set the opening comment delim &gt;&gt;
    &lt;&lt; make sure we have @+leo &gt;&gt;
    &lt;&lt; read optional version param &gt;&gt;
    &lt;&lt; read optional thin param &gt;&gt;
    &lt;&lt; read optional encoding param &gt;&gt;
    &lt;&lt; set the closing comment delim &gt;&gt;
    if not new_df and not g.unitTesting:
        g.trace('not new_df(!)',repr(s))
    return valid,new_df,start,end,isThinDerivedFile
</t>
<t tx="ekr.20100124164700.11980"># s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i &lt; n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j &lt; i:
    start = s[j:i]
else:
    valid = False

</t>
<t tx="ekr.20100124164700.11981">@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False
</t>
<t tx="ekr.20100124164700.11982">new_df = g.match(s,i,version_tag)

if new_df:
    # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
    # Leo 4.4.1 +:   Skip to next minus sign, end-of-line, or non numeric character.
    # This is required to handle trailing comment delims properly.
    i += len(version_tag)
    j = i
    while i &lt; len(s) and (s[i] == '.' or s[i].isdigit()):
        i += 1

    if j &lt; i:
        pass
    else:
        valid = False
</t>
<t tx="ekr.20100124164700.11983">if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
</t>
<t tx="ekr.20100124164700.11984"># Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j &gt; -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j &gt; -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            g.es_print("bad encoding in derived file:",encoding)
    else:
        valid = False
</t>
<t tx="ekr.20100124164700.11985"># The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i &lt; n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
</t>
<t tx="ekr.20100124164700.11986">def scanText4 (self,theFile,fileName,p,verbose=False):

    """Scan a 4.x derived file non-recursively."""

    trace = False and not g.unitTesting
    at = self
    &lt;&lt; init ivars for scanText4 &gt;&gt;
    if trace: g.trace(fileName)
    try:
        while at.errors == 0 and not at.done:
            s = at.readLine(theFile)
            self.lineNumber += 1
            if len(s) == 0: break
            kind = at.sentinelKind4(s)
            if kind == at.noSentinel:
                i = 0
            else:
                i = at.skipSentinelStart4(s,0)
            func = at.dispatch_dict[kind]
            if trace: g.trace('%15s %16s %s' % (
                at.sentinelName(kind),func.__name__,repr(s)))
            func(s,i)
    except AssertionError:
        junk, message, junk = sys.exc_info()
        at.error('unexpected assertion failure in',fileName,'\n',message)

    if at.errors == 0 and not at.done:
        &lt;&lt; report unexpected end of text &gt;&gt;

    return at.lastLines
</t>
<t tx="ekr.20100124164700.11987"># Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.lineNumber = 0
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.v = p.v
at.tStack = []
# New code: always identify root @thin node with self.root:
at.lastThinNode = None
at.thinNodeStack = []</t>
<t tx="ekr.20100124164700.11988">assert at.endSentinelStack,'empty sentinel stack'

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
</t>
<t tx="ekr.20100124164700.11989">def readNormalLine (self,s,i):

    at = self

    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to docOut &gt;&gt;
</t>
<t tx="ekr.20100124164700.11990">if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)
</t>
<t tx="ekr.20100124164700.11991">line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)
</t>
<t tx="ekr.20100124164700.11992"></t>
<t tx="ekr.20100124164700.11994">def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert g.match(s,i,"+at"),'missing +at'
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)

def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert g.match(s,i,"+doc"),'missing +doc'
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)

def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
</t>
<t tx="ekr.20100124164700.11995">def readStartLeo (self,s,i):

    """Read an unexpected @+leo sentinel."""

    at = self
    assert g.match(s,i,"+leo"),'missing +leo sentinel'
    at.readError("Ignoring unexpected @+leo sentinel")
</t>
<t tx="ekr.20100124164700.11996">def readStartMiddle (self,s,i):

    """Read an @+middle sentinel."""

    at = self

    at.readStartNode(s,i,middle=True)
</t>
<t tx="ekr.20100124164700.12000">def readStartOthers (self,s,i):

    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert g.match(s,j,"@+others"),'missing @+others'
    else:
        assert g.match(s,j,"+others"),'missing +others'

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")

    at.endSentinelStack.append(at.endOthers)
</t>
<t tx="ekr.20100124164700.12001"></t>
<t tx="ekr.20100124164700.12002">def readEndAll (self,unused_s,unused_i):

    """Read an @-all sentinel."""

    at = self
    at.popSentinelStack(at.endAll)
</t>
<t tx="ekr.20100124164700.12003">def readEndAt (self,unused_s,unused_i):

    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True

def readEndDoc (self,unused_s,unused_i):

    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
</t>
<t tx="ekr.20100124164700.12004">def readEndLeo (self,unused_s,unused_i):

    """Read an @-leo sentinel."""

    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
</t>
<t tx="ekr.20100124164700.12005">def readEndMiddle (self,s,i):

    """Read an @-middle sentinel."""

    at = self

    at.readEndNode(s,i,middle=True)
</t>
<t tx="ekr.20100124164700.12009">def readEndOthers (self,unused_s,unused_i):

    """Read an @-others sentinel."""

    at = self
    at.popSentinelStack(at.endOthers)
</t>
<t tx="ekr.20100124164700.12010">def readLastDocLine (self,tag):

    """Read the @c line that terminates the doc part.
    tag is @doc or @."""

    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)

    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ','\t'):
        tag = tag + s[0] ; s = s[1:]

    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
</t>
<t tx="ekr.20100124164700.12011"># Ooops: shadow files are cleared if there is a read error!!</t>
<t tx="ekr.20100124164700.12012">def  ignoreOldSentinel (self,s,unused_i):

    """Ignore an 3.x sentinel."""

    g.es("ignoring 3.x sentinel:",s.strip(),color="blue")
</t>
<t tx="ekr.20100124164700.12013">def  readAfterRef (self,s,i):

    """Read an @afterref sentinel."""

    at = self
    assert g.match(s,i,"afterref"),'missing afterref'

    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)
</t>
<t tx="ekr.20100124164700.12014">def readClone (self,s,i):

    at = self ; tag = "clone"

    assert g.match(s,i,tag),'missing clone sentinel'

    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))

    # Get the clone count.
    junk,val = g.skip_long(s,i)

    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount = val
</t>
<t tx="ekr.20100124164700.12015">def readComment (self,s,i):

    """Read an @comment sentinel."""

    assert g.match(s,i,"comment"),'missing comment sentinel'

    # Just ignore the comment line!
</t>
<t tx="ekr.20100124164700.12016">def readDelims (self,s,i):

    """Read an @delims sentinel."""

    at = self
    assert g.match(s,i-1,"@delims"),'missing @delims'

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)

    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1

    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # g.pr("delim1:", at.startSentinelComment)

        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # g.pr("delim2:",end)
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")
</t>
<t tx="ekr.20100124164700.12017">def readDirective (self,s,i):

    """Read an @@sentinel."""

    trace = False and not g.unitTesting
    at = self
    assert g.match(s,i,"@"),'missing @@ sentinel' # The first '@' has already been eaten.

    if trace: g.trace(repr(s[i:]))
        # g.trace(g.get_line(s,i))

    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False

    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'

    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')

    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            &lt;&lt; handle @language &gt;&gt;
        elif g.match_word(s,i,"@comment"):
            &lt;&lt; handle @comment &gt;&gt;

    at.out.append(s2)
</t>
<t tx="ekr.20100124164700.12018"># Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

if trace:
    g.trace(g.get_line(s,i))
    g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @language sentinel:",line,color="red")
</t>
<t tx="ekr.20100124164700.12019">j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @comment sentinel:",line,color="red")
</t>
<t tx="ekr.20100124164700.12020">def readNl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert g.match(s,i,"nl"),'missing nl sentinel'

    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')
</t>
<t tx="ekr.20100124164700.12021">def readNonl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert g.match(s,i,"nonl"),'missing nonl sentinel'

    if at.inCode:
        s = ''.join(at.out)
        # 2010/01/07: protect against a mostly-harmless read error.
        if s:
            if s[-1] == '\n':
                at.out = [s[:-1]]
            else:
                g.trace("out:",s)
                at.readError("unexpected @nonl directive in code part")
    else:
        s = ''.join(at.pending)
        if s:
            if s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
</t>
<t tx="ekr.20100124164700.12022">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):

    """Handle an @&lt;&lt; sentinel."""

    at = self
    j = g.skip_ws(s,i)
    assert g.match(s,j,"&lt;&lt;"),'missing @&lt;&lt; sentinel'

    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.

    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
</t>
<t tx="ekr.20100124164700.12023">def readVerbatim (self,s,i):

    """Read an @verbatim sentinel."""

    at = self
    assert g.match(s,i,"verbatim"),'missing verbatim sentinel'

    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    # Do **not** insert the verbatim line itself!
        # at.out.append("@verbatim\n")
    at.out.append(s[i:])
</t>
<t tx="ekr.20100124164700.12024">if g.unitTesting:
    c,p = g.getTestVars()

    # Here is something that should generate a verbtim sentinel::

    #@+leo-encoding=iso-8859-1.

    # The length of this node should remain constant.

    assert len(p.b) == 235,len(p.b)</t>
<t tx="ekr.20100124164700.12025">def badEndSentinel (self,expectedKind):

    """Handle a mismatched ending sentinel."""

    at = self
    assert at.endSentinelStack,'empty sentinel stack'
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)

def popSentinelStack (self,expectedKind):

    """Pop an entry from endSentinelStack and check it."""

    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)
</t>
<t tx="ekr.20100124164700.12026"># Note: Import code uses this.

def scanHeaderForThin (self,theFile,fileName):

    '''Scan the header of a derived file and return True if it is a thin file.

    N.B. We are not interested in @first lines, so any encoding will do.'''

    at = self

    # The encoding doesn't matter.  No error messages are given.
    at.encoding = at.c.config.default_derived_file_encoding

    junk,junk,isThin = at.scanHeader(theFile,fileName)

    return isThin
</t>
<t tx="ekr.20100124164700.12027"></t>
<t tx="ekr.20100124164700.12028"># Called from writeOpenFile.

def warnAboutOrphandAndIgnoredNodes (self):

    # Always warn, even when language=="cweb"
    at = self ; root = at.root

    for p in root.self_and_subtree():
        if not p.v.isVisited():
            at.writeError("Orphan node:  " + p.h)
            if p.hasParent():
                g.es("parent node:",p.parent().h,color="blue")
            if not at.thinFile and p.isAtIgnoreNode():
                at.writeError("@ignore node: " + p.h)

    if at.thinFile:
        p = root.copy() ; after = p.nodeAfterTree()
        while p and p != after:
            if p.isAtAllNode():
                p.moveToNodeAfterTree()
            else:
                if p.isAtIgnoreNode():
                    at.writeError("@ignore node: " + p.h)
                p.moveToThreadNext()
</t>
<t tx="ekr.20100124164700.12029">@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the external
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):

    at = self

    parent_v = p._parentVnode()

    if False: # 2010/01/23: This generates atFile errors about orphan nodes.
        clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(parent_v,p.v)
        if clonedSibs &gt; 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else:
            g.trace('**** ignoring',p.h)
            p.v.setVisited() # 2010/01/23
            return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 

    for child in p.children():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20100124164700.12046"># This code no longer reads @noref trees.

def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    # g.trace(root.h,len(root.b))
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    if at.errors:
        return False
    fileName = at.openFileForReading(fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False
    root.v.at_read = True # Remember that we have read this file.
    # Get the file from the cache if possible.
    ok,cachefile = self.readFromCache(fileName,force,root)
    if ok:
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    root.clearVisitedInTree()
    d = at.scanAllDirectives(root,importing=at.importing,reading=True)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.warnAboutUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if at.errors == 0:
        self.writeCachedTree(root,cachefile)

    return at.errors == 0
</t>
<t tx="ekr.20100124164700.12047">def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
</t>
<t tx="ekr.20100124164700.12049">def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "&lt;string-file&gt;"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName

    # isAtFile = (
        # not thinFile and
        # not importFileName and
        # not atShadow and
        # not fromString and
        # root.h.startswith('@file'))
</t>
<t tx="ekr.20100124164700.12051">def warnAboutUnvisitedNodes (self,root):

    resurrected = 0

    for p in root.self_and_subtree():
        if not p.v.isVisited():
            g.trace('**** not visited',p.v,p.h)
            g.es('resurrected node:',p.h,color='blue')
            g.es('in file:',root.h,color='blue')
            resurrected += 1

    if resurrected:
        g.es('you may want to delete ressurected nodes')
</t>
<t tx="ekr.20100124164700.12070">self.atAllFlag = False # True if @all seen.
self.cloneSibCount = 0 # n &gt; 1: Make sure n cloned sibs exists at next @+node sentinel
self.correctedLines = 0
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelStack = []
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastThinNode = None # Used by createThinChild4.
self.leadingWs = ""
self.lineNumber = 0 # New in Leo 4.4.8.
self.out = None
self.outStack = []
self.rootSeen = False
self.tnodeList = [] # Needed until old-style @file nodes are no longer supported.
self.tnodeListIndex = 0
self.v = None
self.tStack = []
self.thinNodeStack = [] # Used by createThinChild4.
self.updateWarningGiven = False
</t>
<t tx="ekr.20100124164700.12071">def findChild4 (self,headline):

    """Return the next vnode in at.root.tnodeLisft.
    This is called only for @file/@noref nodes"""

    # Note: tnodeLists are used _only_ when reading @file (not @thin) nodes.
    # tnodeLists compensate (a hack) for not having gnx's in derived files! 

    trace = False and not g.unitTesting
    at = self ; v = at.root.v

    if not g.unitTesting:
        if v.isAtFileNode():
            g.es_print('Warning: @file logic',v.h)

    if trace: g.trace('%s %s %s' % (
        at.tnodeListIndex,
        v.tnodeList[at.tnodeListIndex],headline))

    if not hasattr(v,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v,g.callers())
        return None

    if at.tnodeListIndex &gt;= len(v.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.tnodeList),v)
        return None

    v = v.tnodeList[at.tnodeListIndex]
    assert(v)
    at.tnodeListIndex += 1

    # Don't check the headline.  It simply causes problems.
    v.setVisited() # Supress warning/deletion of unvisited nodes.
    return v
</t>
<t tx="ekr.20100124164700.12072">def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
</t>
<t tx="ekr.20100124164700.12128">def readFromCache (self,fileName,force,root):

    at = self ; c = at.c
    s = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root.h,s)

    # 2010/01/22: uncache *any* file provided 'force' is False.
    doCache = g.enableDB and not force
    ok = doCache and cachefile in c.db
    if ok:
        # Delete the previous tree, regardless of the @&lt;file&gt; type.
        while root.hasChildren():
            root.firstChild().doDelete()
        # Recreate the file from the cache.
        aList = c.db[cachefile]
        root.v.createOutlineFromCacheList(c,aList)
        at.inputFile.close()
        root.clearDirty()

    return ok,cachefile
</t>
<t tx="ekr.20100124164700.12129">def readStartNode (self,s,i,middle=False):

    """Read an @+node or @+middle sentinel."""

    trace = False and not g.unitTesting
    at = self
    if middle:
        assert g.match(s,i,"+middle:"),'missing +middle'
        i += 8
    else:
        assert g.match(s,i,"+node:"),'missing +node'
        i += 6

    if at.thinFile:
        &lt;&lt; set gnx and bump i &gt;&gt;
    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
    if not at.root_seen:
        # g.trace(repr(s[0:i+20]))
        at.root_seen = True

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent

    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.v)

    if trace: g.trace(at.root)
    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.v = p.v
    elif at.thinFile:
        if at.thinNodeStack:
            at.thinNodeStack.append(at.lastThinNode)
            v = at.createThinChild4(gnx,headline)
        else:
            v = at.root.v
            at.thinNodeStack.append(v)
        at.lastThinNode = v
        at.v = v
    else:
        at.v = at.findChild4(headline)

    if trace: g.trace('scanning',at.v)

    at.endSentinelStack.append(at.endNode)
</t>
<t tx="ekr.20100124164700.12130"># We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i
</t>
<t tx="ekr.20100124164700.12131"># Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')
</t>
<t tx="ekr.20100124164700.12140">def readEndNode (self,unused_s,unused_i,middle=False):

    """Handle end-of-node processing for @-others and @-ref sentinels."""

    trace = False and not g.unitTesting
    at = self ; c = at.c

    # End raw mode.
    at.raw = False

    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s)

    # g.trace(repr(s))

    if at.importing:
        at.v._bodyString = s # Allowed use of _bodyString.
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.v,"tempBodyString") and s != at.v.tempBodyString:
            old = at.v.tempBodyString
        elif at.v.hasBody() and s != at.v.getBody():
            old = at.v.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and at.v != at.root.v: # and not g.app.unitTesting
            &lt;&lt; indicate that the node has been changed &gt;&gt;
        if old and at.atAllFlag:
            if trace: g.trace('*** no update\nold: %s\nnew: %s' % (repr(old),repr(s)))
            pass # Don't change.
        else:
            if trace: g.trace('*** update\nold: %s\nnew: %s' % (repr(old),repr(s)))
            at.v.tempBodyString = s

    # Indicate that the vnode has been set in the derived file.
    at.v.setVisited()
    # g.trace('visit',at.v)

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.v = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
</t>
<t tx="ekr.20100124164700.12141">if at.perfectImportRoot:
    &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
    at.v._bodyString = s # Allowed use of _bodyString.
        # Just setting at.v.tempBodyString won't work here.
    at.v.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    # New in Leo 4.4.1 final.  This warning can be very confusing.
    # New in Leo 4.7 b2: We suppress warning for trees containing '@all'
    if at.atAllFlag: # Give the warning if we are not in an '@all' tree.
        pass
    # elif not at.updateWarningGiven:
    else:
        # at.updateWarningGiven = True
        # g.pr("***",at.v,at.root.v)
        g.es_print("uncached read node changed",at.v.h,color="red") # was at.root.h
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.v.setDirty()
    # Important: the dirty bits won't stick unless we set c.changed here.
    # Do *not* call c.setChanged(True) here: that would be too slow.
    c.changed = True</t>
<t tx="ekr.20100124164700.12142"># Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree():
    if p.v == at.v:
        found = True ; break

if found:
    if 0: # For debugging.
        g.pr('\n','-' * 40)
        g.pr("old",len(old))
        for line in g.splitLines(old):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
        g.pr("new",len(s))
        for line in g.splitLines(s):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
else:
    # This should never happen.
    g.es("correcting hidden node: v=",repr(at.v),color="red")
</t>
<t tx="ekr.20100124164700.12143">def readStartAll (self,s,i):

    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert g.match(s,j,"@+all"),'missing @+all'
    else:
        assert g.match(s,j,"+all"),'missing +all'

    # g.trace('root_seen',at.root_seen,at.root.h,repr(s))
    at.atAllFlag = True

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")

    at.endSentinelStack.append(at.endAll)
</t>
<t tx="ekr.20100128094926.12524">These marks were just annoying.</t>
<t tx="ekr.20100128094926.12739"></t>
<t tx="ekr.20100128094926.12747"></t>
<t tx="ekr.20100128094926.12756">Deleting a range of line containing unicode characters deletes too much.</t>
<t tx="ekr.20100129054823.11924">@language rest</t>
<t tx="ekr.20100129054823.11925">#######################################
What's New in Leo 4.7
#######################################

.. .. contents::</t>
<t tx="ekr.20100129054823.11926">.. Links used in this document.
</t>
<t tx="ekr.20100129054823.11928">- Leo now treats @file nodes just like it treats @thin nodes. This makes Leo
  much safer to use in cooperative environments that use source code control
  systems. As part of this change, Leo no longer supports @noref nodes.

- @auto-rst now works much more reliably.

- Leo now has a simple, robust, and extremely useful scheme to recover from
  clone conflicts, no matter how they may arise. This removes all the dread from
  "node changed" messages. It is easy to see what the changes were, and it is
  easy to choose what, if anything to do.

  When a clone conflict occurs, you will see a red message in the log pane and a
  "Recovered Nodes" node as the last top-level node. This node has one child per
  red message. Each of these children contains two nodes: an "old" node and a
  "new" node. Unless there are multiple conflicts for a single node, the "new"
  node will have "won": every clone contains the new node's headline and body
  text. All these nodes are plain nodes, *not* clones. It is up to you to change
  the corresponding clone nodes if you choose to do so.

- Leo minimizes unnecessary changes to .leo files. Leo writes outline-size and
  orientation to the cache in your .leo directory. This eliminates unnecessary
  changes to .leo files.

- Leo now creates temporary files in the systems standard temporary directory.
  This prevents Leo from over-writing user-generated .bak files.
</t>
<t tx="ekr.20100129054823.11931">- The --debug command-line option sets g.debug.

- The --version command-line option causes Leo
  to print it's version and exit.

</t>
<t tx="ekr.20100129054823.11934">The qt colorizer now supports font specifications in @font nodes.</t>
<t tx="ekr.20100129054823.11935">Added options for vim plugin. The setting::

    @string vim_trigger_event = icondclick2

is the default. It opens vim when the user double-clicks the icon box.
Alternatives are::

    @string vim_trigger_event = iconclick2
    @string vim_trigger_event = select2

The former opens vim on single clicks in the icon bar.
The latter opens vim whenever a new node is selected in Leo.

</t>
<t tx="ekr.20100129054823.17680">Leo requires Python 2.6 or above, including Python 3.0 and above.</t>
<t tx="ekr.20100129054823.17683">- The --debug command-line option sets g.debug.

- The --version command-line option causes Leo
  to print it's version and exit.

</t>
<t tx="ekr.20100129054823.17685">The qt colorizer now supports font specifications in @font nodes.</t>
<t tx="ekr.20100201192329.7018">Leo 4.7 beta 3                       February 2, 2009

Leo 4.7 beta 3 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.7 beta 3 fixes all known serious bugs in Leo.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.7:
--------------------------

- Leo now uses the simplest possible internal data model.
  This is the so-called "one-node" world.
- Leo supports Python 3.x.
- Leo requires Python 2.6 or above.
- Several important improvements in file handling.
    - Leo converts @file nodes to @thin nodes automatically.
    - @auto-rst now works much more reliably reliably.
    - Leo no longer @noref trees.  Such trees are not
      reliable in cooperative environments.
- A new Windows installer.
- Many other features, including new command line options and new plugins.
- Dozens of bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20100201192329.7095"></t>
<t tx="ekr.20100201192329.7101">This was a serious error.  It could cause clone clashes on later reloads.</t>
<t tx="ekr.20100201192329.7106">This only happened if two nodes had the same headline.</t>
<t tx="ekr.20100201192329.7108"></t>
<t tx="ekr.20100201192329.7112"></t>
<t tx="ekr.20100201192329.7113">@nocolor-node

The problem arises because an @path directive ended with ':':

    @path: aPath

What I did:

- g.get_directives_dict now carefully checks for non-whitespace following a directive.
- The qt colorizer does the same.
- Added unit test to check for this.
</t>
<t tx="ekr.20100201192329.7116">Eliminated most imports from the leo/extensions folder.

</t>
<t tx="ekr.20100201192329.7141">'utf-8' is now the official, explicit unicode encoding unless overridden when
reading files.
  
This simplifies the code in several ways. In particular, the 'mbcs' encoding is
never used by default, and there is no g.app.defaultEncoding argument.

The rst3 command now uses 'utf-8' for all encodings unless explicitly overridden.</t>
<t tx="ekr.20100205152016.14053">Leo 4.7 rc 1                    February 12, 2009

Leo 4.7 release candidate 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.7 rc 1 fixes all known bugs in Leo, serious or minor.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.7:
--------------------------

- Leo now uses the simplest possible internal data model.
  This is the so-called "one-node" world.
- Leo supports Python 3.x.
- Leo requires Python 2.6 or above.
- Several important improvements in file handling.
    - Leo converts @file nodes to @thin nodes automatically.
    - Leo creates a 'Recovered Nodes' node to hold data that
      otherwise might be lost due to clone conflicts.
    - @auto-rst now works much more reliably reliably.
    - Leo no longer supports @noref trees.  Such trees are not
      reliable in cooperative environments.
- A new Windows installer.
- Many other features, including new command line options and new plugins.
- Dozens of bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20100205152016.14054">Leo now has a simple, robust, and extremely useful scheme to recover from clone
battles, no matter how they may arise. This removes all the dread from "node
changed" messages. It is easy to see what the changes were, and it is easy to
choose what, if anything to do.

It is easy to test the code to see how it works:

1. Put a clone in an external file, and put another clone in Leo
outside of any external file.

2. Change the clone outside of Leo using an external editor.

3. Reload Leo.

When a clone conflict occurs, you will see a red message in the log pane and a
"Recovered Nodes" node as the last top-level node. This node has one child per
red message. Each of these children contains two nodes: an "old" node and a
"new" node. Unless there are multiple conflicts for a single node, the "new"
node will have "won": every clone contains the new node's headline and body
text. All these nodes are plain nodes, *not* clones. It is up to you to change
the corresponding clone nodes if you choose to do so.</t>
<t tx="ekr.20100209160132.11690"></t>
<t tx="ekr.20100209160132.11691"></t>
<t tx="ekr.20100209160132.11692">@nocolor-node

The fix: back-to-home is now included in k.singleLineCommandList.</t>
<t tx="ekr.20100209160132.11694">There was code in tnodeAttributes that did something brain-dead when unit
testing, just to support a unit test!</t>
<t tx="ekr.20100209160132.11700"></t>
<t tx="ekr.20100209160132.11701">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/6d87d95ecbc3b986

If a @path directive is within the body text of an @thin node then the
file write uses the @path directive but the file read does not.  Since
the file read cannot know of the @path directive until after it has
read the file it has no choice but to not use it.  The @thin file
write code should not use any @path declarations found in its body
text.

What I did:

- Defined g.app.atPathInBodyWarning, set by g.get_directives_dict to p.h
- g.get_directives_dict also sets d['@path_in_body'] = p.h
- c.scanAtPathDirectives doesn't set the path if d['@path_in_body'] is true.
- atFile.scanAllDirectives issues a warning if g.app.atPathInBodyWarning is true,
  but only if the issuePathWarning keyword arg is true.</t>
<t tx="ekr.20100209160132.11711">@nocolor-node

Traceback (most recent call last):
  File "launchLeo.py", line 8, in &lt;module&gt;
    leo.core.runLeo.run()
  File "c:\leo.repo\trunk\leo\core\runLeo.py", line 95, in run
    ok = doPostPluginsInit(args,fn,relFn,script,versionFlag)
  File "c:\leo.repo\trunk\leo\core\runLeo.py", line 354, in doPostPluginsInit
    c,frame = createFrame(fileName,relativeFileName,script)
  File "c:\leo.repo\trunk\leo\core\runLeo.py", line 383, in createFrame
    ok, frame = g.openWithFileName(relativeFileName or fileName,None)
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 2439, in openWithFileName
    ok = g.handleOpenHooks(c,old_c,gui,fn,f,readAtFileNodesFlag)
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 2502, in handleOpenHooks
    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 911, in open
    silent=silent)
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 811, in getLeoFile
    c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 659, in readAll
    at.readOneAtAutoNode (fileName,p)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 732, in readOneAtAutoNode
    self.writeCachedTree(p, cachefile)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 593, in writeCachedTree
    elif cachefile in c.db:
  File "c:\leo.repo\trunk\leo\external\pickleshare.py", line 138, in __contains__
    return self.has_key(key)
  File "c:\leo.repo\trunk\leo\external\pickleshare.py", line 234, in has_key
    value = self[key]
  File "c:\leo.repo\trunk\leo\external\pickleshare.py", line 160, in __getitem__
    fil = self.root / key
  File "c:\leo.repo\trunk\leo\external\path.py", line 102, in __div__
    return path(os.path.join(self, rel))
  File "c:\python31\lib\ntpath.py", line 111, in join
    elif isabs(b):
  File "c:\python31\lib\ntpath.py", line 92, in isabs
    s = splitdrive(s)[1]
  File "c:\python31\lib\ntpath.py", line 198, in splitdrive
    if len(p) &gt; 1:
TypeError: object of type 'NoneType' has no len()

c:\leo.repo\trunk&gt;</t>
<t tx="ekr.20100209160132.11712">@nocolor-node

Adding a blank line did not change the file!

The culprit was the ignoreLineEndings logic in compareFiles.
A new unit test is needed.
</t>
<t tx="ekr.20100209160132.11718">@nocolor-node

What I did:

- fc.createBackupFile now calls shutils.move directly,
  avoiding g.utils_rename which does way too much:
  it calls g.makeAllNonExistentDirectories(!!)

- Simplified g.utils_rename.  We can assuem shutils exists.

- Removed an unwise call to g.utils_remove in g.utils_rename.
  This could cause havoc with the following call to
  shutils_move!!
</t>
<t tx="ekr.20100209160132.11736"></t>
<t tx="ekr.20100209160132.11742">@nocolor-node

Removed call to g.makeAllNonExistentDirectories in g.utils_rename.

This has global effects. Happily, there were only three callers of g.utils_rename:

- handleWriteLeoFileException: should *not* create directories.

- x.rename: no longer used!

- g.update_file_if_changed:
    - called only from tangle.put_all_roots.
    - I added call to g.makeAllNonExistentDirectories there.</t>
<t tx="ekr.20100209160132.11751">Non-extending cursor moves now always clear the selection.</t>
<t tx="ekr.20100209160132.11755"></t>
<t tx="ekr.20100209160132.11756">The title says it all.

This was likely fixed at rev 2438 of the trunk, in early October, 2009.</t>
<t tx="ekr.20100209160132.11765">@nocolor-node

The module imported correctly, but leoTest.checkFileSyntax was failing.

It was a whitespace problem--the fix was stripping '\r' characters in checkFileSyntax.</t>
<t tx="ekr.20100209160132.11767"></t>
<t tx="ekr.20100209160132.11770">@nocolor-node

There may have been a bug in the open_with plugin that allowed it to be active
when it shouldn't have been.</t>
<t tx="ekr.20100209160132.11771">@nocolor-node

I am getting an exception when double-clicking to rename a node. The
exception does not occur when I rename a new node immediately
following creation while it is highlighted.

#---#
Leo Log Window
Leo 4.7 beta 3, build 2835, February 2, 2010
Python 3.1.1, qt version 4.6.1
Windows 6, 1, 7600, 2,
reading: C:\Users\skrivsm\Documents\toolbox\scratch\ruby_scratch.leo
creating:   newHeadline_LeoTemp_63898064.py
exception creating temp file
Traceback (most recent call last):
 File "C:\leo-editor\trunk\leo\core\leoCommands.py", line 1164, in
createOpenWithTempFile
   f.write(s)
TypeError: must be str, not bytes
recreating:   newHeadline_LeoTemp_63898064.py
exception creating temp file
Traceback (most recent call last):
 File "C:\leo-editor\trunk\leo\core\leoCommands.py", line 1164, in
createOpenWithTempFile
   f.write(s)
TypeError: must be str, not bytes
#---#</t>
<t tx="ekr.20100209160132.11773">https://bugs.launchpad.net/leo-editor/+bug/518823

Clone headline modification not propogated after edit</t>
<t tx="ekr.20100209160132.11888">@nocolor-node

Global entries are in g.app.leoHomeDir/db/global

Per-leo-files entries are in g.app.homeLeoDir/db/&lt;filename&gt;_&lt;hash&gt;
</t>
<t tx="ekr.20100211125418.11596"></t>
<t tx="ekr.20100211125418.11599">This bug was highly annoying: it caused the newly-selected node to have the
insert point of a just-deleted node. This bug made it difficult, for example, to
delete nodes while examining the nodes created by clone-find-all.
</t>
<t tx="ekr.20100211125418.11602"></t>
<t tx="ekr.20100211125418.11611"></t>
<t tx="ekr.20100211221936.7098">- The clear-cache and clear-all-caches commands.</t>
<t tx="ekr.20100223063657.7182"># This fixed a Python 3.x compatibility problem.</t>
<t tx="ekr.20100223063657.7183"></t>
<t tx="ekr.20100223063657.7184"># New in Leo 4.7 final: this method no longer supports
# the 'cmp' keyword arg.

def sortSiblings (self,event=None,key=None,p=None,sortChildren=False):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer
    if p is None: p = c.p
    if not p: return

    c.endEditing()

    undoType = g.choose(sortChildren,'Sort Children','Sort Siblings')
    parent_v = p._parentVnode()
    parent = p.parent()
    oldChildren = parent_v.children[:]
    newChildren = parent_v.children[:]

    if key == None:
        def lowerKey (self):
            return (self.h.lower())
        key = lowerKey

    newChildren.sort(key=key)

    if oldChildren == newChildren:
        return

    # 2010/01/20. Fix bug 510148.
    c.setChanged(True)

    # g.trace(g.listToString(newChildren))

    bunch = u.beforeSort(p,undoType,oldChildren,newChildren,sortChildren)
    parent_v.children = newChildren
    if parent:
        dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
    else:
        dirtyVnodeList = []
    u.afterSort(p,bunch,dirtyVnodeList)

    # Sorting destroys position p, and possibly the root position.
    p = c.setPositionAfterSort(sortChildren)
    c.redraw(p)
</t>
<t tx="ekr.20100223063657.7186">def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    if not d: return g.es('no bindings')
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # Print keys by type:
    result = []
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
        'Meta+Ctrl+Shift', 'Meta+Shift', 'Meta+Ctrl', 'Meta+Key','Meta',
        # Meta support
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        # g.es('','%s %s' % (sep, prefix),tabName=tabName)
        result.append('%s %s\n' % (sep, prefix))
        self.printBindingsHelper(result,data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('%s %s\n' % (sep, 'Plain Keys'))
    self.printBindingsHelper(result,data,n1,n2,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
    return result # for unit test.
</t>
<t tx="ekr.20100223063657.7187">def printBindingsHelper (self,result,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) &gt;  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        for s1,s2,s3 in data:
            # g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
            result.append('%*s %*s %s\n' % (-n1,s1,-(min(12,n2)),s2,s3))
</t>
<t tx="ekr.20100223063657.7188">def printGcAll (tag=''):

    # Suppress warning about keywords arg not supported in sort.

    tag = tag or g._callerName(n=2)
    d = {} ; objects = gc.get_objects()
    if not g.unitTesting:
        g.pr('-' * 30)
        g.pr('%s: %d objects' % (tag,len(objects)))

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except Exception: pass
        # if type(obj) == type(()):
            # g.pr(id(obj),repr(obj))
        d[t] = d.get(t,0) + 1

    if 1: # Sort by n
        items = list(d.items())
        items.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        if not g.unitTesting:
            for z in items:
                g.pr('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        for t in sorted(d):
            g.pr('%40s %7d' % (t,d.get(t)))
</t>
<t tx="ekr.20100223063657.7189">def reverseSortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True,reverse=True)

def reverseSortLines(self,event):
    return self.sortLines(event,reverse=True)

def sortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True)

def sortLines (self,event,ignoreCase=False,reverse=False):

    '''Sort lines of the selected text by comparing the entire text of a line.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not self._chckSel(event): return

    undoType = g.choose(reverse,'reverse-sort-lines','sort-lines')
    self.beginCommand(undoType=undoType)
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        s2 = s[i:j]
        if not s2.endswith('\n'): s2 = s2+'\n'
        aList = g.splitLines(s2)
        def lower(s):
            if ignoreCase: return s.lower()
            else: return s
        aList.sort(key=lower)
            # key is a function that extracts args.
        if reverse:
            aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20100223063657.7190">def sortRecentFiles(self,event=None):

    c = self

    orig = c.recentFiles[:]
    c.clearRecentFiles()

    def key(s):
        return g.os_path_basename(s).lower()
    orig.sort(key=key) # 2010/01/12
    orig.reverse() # 2010/01/12
    for i in orig:
        c.updateRecentFiles(i)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
</t>
<t tx="ekr.20100223063657.7192"></t>
<t tx="ekr.20100223063657.7212">The edit pane lost focus after save commands.</t>
<t tx="ekr.20100223063657.7232">fileKey is needed even if force is True.</t>
<t tx="ekr.20100223063657.7238">https://bugs.launchpad.net/leo-editor/+bug/508108
</t>
<t tx="ekr.20100223063657.7245">Default fonts were not being properly restored after being overridden in another language.

For example, after colorizing php, python keywords looked like php keywords.</t>
<t tx="ekr.20100223063657.7246">The bug: Find/change prompts were not fully protected after the user hit the
&lt;home&gt; key.</t>
<t tx="ekr.20100223063657.7249"></t>
<t tx="ekr.20100223063657.7253">def helpForCommand (self,event):

    '''Prompts for a command name and prints the help message for that command.'''

    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)

def helpForCommandFinisher (self,commandName):

    c = self.c
    bindings = self.getBindingsForCommand(commandName)
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        s = ''.join([
            g.choose(line.strip(),line.lstrip(),'\n')
                for line in g.splitLines(func.__doc__)])
    else:
        s = 'no docstring'
    g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')

def getBindingsForCommand(self,commandName):

    c = self.c ; k = c.k ; d = k.bindingsDict
    data = [] ; n1 = 4 ; n2 = 20
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            if b.commandName == commandName:
                pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
                s1 = pane
                s2 = k.prettyPrintKey(key,brief=True)
                s3 = b.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)

    data.sort(key=lambda x: x[1])
        # key is a function that extracts args.

    return ','.join(['%s %s' % (s1,s2) for s1,s2,s3 in data])</t>
<t tx="ekr.20100223063657.7262">Leo 4.7 final                    February 23, 2010

Leo 4.7 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.7 final fixes all known bugs in Leo.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.7:
--------------------------

- Leo now uses the simplest possible internal data model.
  This is the so-called "one-node" world.
- Leo supports Python 3.x.
- Leo requires Python 2.6 or above.
- Several important improvements in file handling.
    - Leo converts @file nodes to @thin nodes automatically.
    - Leo creates a 'Recovered Nodes' node to hold data that
      otherwise might be lost due to clone conflicts.
    - @auto-rst now works much more reliably reliably.
    - Leo no longer supports @noref trees.  Such trees are not
      reliable in cooperative environments.
- A new Windows installer.
- Many other features, including new command line options and new plugins.
- Dozens of bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20100223063657.7263"></t>
<t tx="ekr.20100223063657.7264"></t>
<t tx="ekr.20100225102026.7139">Leo 4.7.1 final                    February 26, 2010

Leo 4.7.1 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.7.1 fixes a dangerous bug in Leo 4.7. When converting file-like sentinels
to thin-like sentinels in an external file, Leo now issues a warning and sets
the corresponding @file node dirty. This ensures that Leo will write the
converted external file and .leo file together, making it impossible to lose
data.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.7:
--------------------------

- Leo now uses the simplest possible internal data model.
  This is the so-called "one-node" world.
- Leo supports Python 3.x.
- Leo requires Python 2.6 or above.
- Several important improvements in file handling.
    - Leo converts @file nodes to @thin nodes automatically.
    - Leo creates a 'Recovered Nodes' node to hold data that
      otherwise might be lost due to clone conflicts.
    - @auto-rst now works much more reliably reliably.
    - Leo no longer supports @noref trees.  Such trees are not
      reliable in cooperative environments.
- A new Windows installer.
- Many other features, including new command line options and new plugins.
- Dozens of bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20100225102026.7140">- Fixed a dangerous bug that could cause data loss when converting @file nodes
  from file-like to thin-like sentinels. The problem arose because it was too
  easy to save the .leo file (thus deleting the tnodeList) without forcing the
  converted external files to be saved. The next time Leo attempted to read the
  external files, the tnodeList would be missing and data would be lost.
  
  Leo's read logic now determines whether the file has file-like sentinels by
  reading the *uncached* contents of the file. When converting file-like
  sentinels to thin-like sentinels, Leo warns that it is converting the file and
  sets the @file node dirty. This ensures that Leo will write the converted
  external file whenever Leo writes the .leo file. This will make it impossible
  for a naive user to lose data. A sophisticated user might cause problems by
  using the write-outline-only command...

- Fixed expand/contract-pane commands.

- Fixed Python 3.x problems in delete-editor and cycle-editor-focus.

- Added a log message for show-colors saying the color picker does not exist for qt.

- Corrected date in trunk/license.txt.</t>
<t tx="ekr.20100504092040.17423">Calltips appear after you type an open parenthesis in code. Calltips shows the
expected arguments to a function or method. Calltips work for any Python
function or method, including Python's global functions. Typing Return or
Control-g (keyboard-quit) exits calltips.

Examples:

a)  'g.toUnicode('  gives 'g.toUnicode(s, encoding, reportErrors=False'
b) 'c.widgetWantsFocusNow' gives 'c.widgetWantsFocusNow(w'
c) 'reduce(' gives 'reduce(function, sequence[, initial]) -&gt; value'

The calltips appear directly in the text and the argument list is highlighted so
you can just type to replace it. The calltips appear also in the status line for
reference after you have started to replace the args.

Options

Both autocompletion and calltips are initially enabled or disabled by the
enable_autocompleter and enable_calltips settings in leoSettings.leo. You may
enable or disable these features at any time with these commands:
enable-auto-completer-command, enable-calltips-command,
disable-auto-completer-command and disable-calltips-command.</t>
<t tx="ekr.20100506062734.11593">The mod_scripting plugin runs @scripts before plugin initiation is complete.
Thus, such scripts can not directly modify plugins. Instead, a script can create
an event handler for the after-create-leo-frame that will modify the plugin.

For example, the following modifies the cleo.py plugin after Leo has completed loading it::

    def prikey(self, v):
        try:
            pa = int(self.getat(v, 'priority'))
        except ValueError:
            pa = -1
        
        if pa == 24:
            pa = -1
        if pa == 10:
            pa = -2
        
        return pa
    
    import types
    from leo.core import leoPlugins
    
    def on_create(tag, keywords):
        c.cleo.prikey = types.MethodType(prikey, c.cleo, c.cleo.__class__)

    leoPlugins.registerHandler("after-create-leo-frame",on_create)

Attempting to modify c.cleo.prikey immediately in the @script gives an
AttributeError as c has no .cleo when the @script is executed. Deferring it by
using registerHandler() avoids the problem.
</t>
<t tx="shadow.20080825171547.9">**Question**: I must follow a coding standard when writing source code. It
includes a maximum line length restriction. How can I know the length of a
line when it gets written to the external file?

**Answer**: If a node belongs to a external file hierarchy, its body might get
indented when it is written to the external file. It happens when an
\@others directive or a section name appears indented in a higher-level
node body. While (**line**, **col**) in status area show the line and column
containing the body text's cursor, **fcol** shows the cursor coordinate
relative to the external file, not to the curent node. The relation
**fcol &gt;= col** is always true.</t>
<t tx="sps.20100708203040.19008">@language python
import os
pos = c.find_h("Users Guide")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
&lt;&lt; pdf manual &gt;&gt;
</t>
<t tx="sps.20100708203040.19009">d = c.scanAllDirectives(p)
mandir = d.get('path') + "/html"
g.es(mandir)
os.chdir(mandir)
os.system('make html')</t>
<t tx="sps.20100708203040.19010"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = d.get('path') + "/html"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex')
os.system('make LeoDoc.pdf')
</t>
<t tx="sps.20100708213227.44914"></t>
<t tx="sps.20100710110337.12186">I've ordered these sections in approximate ascending complexity of concepts and descending importance.
</t>
<t tx="sps.20100710110337.12187"></t>
<t tx="sps.20100710110337.12188"></t>
<t tx="sps.20100710110337.12189"></t>
<t tx="sps.20100712151944.7128">Leo has an initially bewildering array of ways to turn outlines into external files.  This history, simplified to the point of inaccuracy, may help you decide which of the varieties are appropriate to your project.  For a better and more detailed history, see the chapter `History of Leo`_.

The earliest variety of file generation was the ``@root`` directive, designed to work with either `CWEB`_ or `noweb`_ markup.  The model for CWEB and noweb were for a person to edit a text ("web") file containing code and markup, and then "tangle" the file into a source code file appropriate for the compiler or interpreter, and to "weave" the text file into a beautifully typeset narrative which explained all the inner workings of the code.  Leo's innovation was to realize that a lot of what the markup was doing was to expose the often hidden conceptual structure of the code, and that this could be done better with an outline.  Thus in Leo, "tangling" creates the source files from the outline, "weaving" is dropped, and "untangling" turns source files into outlines.  That last trick nearly always requires some assistance from the source file, in the form of special comments called "sentinels" which help Leo discover the names of outline headlines and the boundaries in the chunks of text (bodies) corresponding to those headlines - and which chunks are subheads to other subheads.  As with CWEB and noweb, the specifications for how to assemble the nodes into the program source code are explicit: ``&lt;&lt;`` *section* ``&gt;&gt;`` specifies the location where Leo emits the section, and ``&lt;&lt;`` *section* ``&gt;&gt;=`` *code* adds snippets of code to the end of the section definition.

Patterns in how ``@root`` trees were used suggested a different and easier way of deriving code from the outline: ``@file``.  This directive occurs in the headline.  Instead of explicitly naming each section, one puts an ``@others`` directive where Leo interpolates the otherwise unplaced child sections; if you want a section put in a more specific place, specifying ``&lt;&lt;`` *section* ``&gt;&gt;`` will put it at that location in the body, and consequently require that ``&lt;&lt;`` *section* ``&gt;&gt;`` appear as a child headline defining that section.  The other innovation with ``@file`` is what happens when Leo starts: there is an immediate "untangle" of each ``@file``, thus incorporating changes from outside Leo into Leo's model of the file.  Correspondingly, when Leo exits, you're prompted to "save" (tangle) any altered ``@file`` (including alterations to child nodes).

The next innovation was ``@thin``.  ``@file`` created source code with sentinels containing almost, but not all, of what was needed to recreate the outline for the ``@file``.  That same information was in the .leo file.  Situations could arise where that information was inconsistent, and created headaches.  ``@thin`` was like ``@file``, except that *everything* needed to create the ``@thin`` outline goes into the sentinels, and *does not* go into the .leo file, thus severely reducing opportunities for inconsistency.  This has been so successful that the old ``@file`` directive now forcibly converts ``@file`` derived source code to ``@thin`` style sentinels, and otherwise acts as a synonym for ``@thin``.  (Beware, however, if you use both pre-4.7 and 4.7 *et post* versions of Leo with ``@file``: change each ``@file`` headline to ``@thin`` immediately, otherwise the incompatible sentinels for ``@file`` between the versions will be most painful.)

If you look at source code managed with ``@thin``, the sentinels will stand silently in their commented multitudes - which may be reassuring to the Leo user, but appear to the non-Leo reader as a massive invasion.  The sentinels are almost necessary for pulling in changes from external files, but if those sentinels are banished, any number of compromise approaches can be imagined - and most of them seem to have been implemented.  All these directives can appear in a headline and create files without sentinels: 

\@auto
  parses the external file to put language apppropriate nodes (modules, classes, methods, functions...) into an @thin-like outline
  
\@asis
  does a strict tree walk to generate the file, ignoring ``@others`` and ``&lt;&lt;`` *section* ``&gt;&gt;`` references, keeps everything in the .leo file and ignores changes from outside Leo

\@edit
  honors markup directives like ``@others`` when writing the external file, but when opening the .leo file, the contents of the external file all go into one node, which *might* have a language directive (e.g., ``@language python``), but never any children

\@nosent
  writes files honoring the directives in the manner of ``@thin``, keeps copies of everything in the .leo file, and ignores changes introduced into the external file

\@shadow
  reads and writes two versions of each file, one without sentinels, and a hidden one with sentinels as if it were ``@thin``, then uses the sentinels in the hidden file to make sense of externally introduced changes to the unsentineled file

There are subtleties and crucial details to each of these external file generation directives: read the descriptive sections carefully.</t>
<t tx="sps.20100712151944.7132">Differing external file directives are appropriate in different situations:

\@asis
  Use this directive only when you must have complete control over
  every character of the external file: it copies body text verbatim,
  without even ensuring that newlines terminate each node.  

\@auto
  Use this when you don't want sentinels and Leo's parser for your language
  works well.  It can be tricky: see the `@auto reference`_ for full details.

\@edit
  Use for small files which can't have sentinels and it's ok for them to occupy a single node.

\@file
  As of Leo 4.7 b2, ``@file`` works exactly like ``@thin``.  See the `@file reference`_

\@thin
  Use ``@thin`` unless you have a good reason not to.

\@nosent
  Use ``@nosent`` only as a last resort:
  ``@auto`` or ``@shadow`` are usually a better choice.
  Leo can not update ``@nosent`` trees from changes made to external files.

\@shadow
  Use this directive when you can't have sentinels in the **public** version
  of the file, but want all the features of ``@thin`` trees.  This directive writes
  *two* external files, a **public** file without sentinels, and a **private**
  file (by default in the ``.leo_shadow`` subfolder) containing sentinels.

\@root
  Use this directive when you need to create different pieces of multiple files within a single node.
  This directive is the most flexible, the most difficult to use, and behaves
  differently from every other file generating directive. It comes closest
  in spirit to traditional literate programming tools.
  Avoid using ``@root`` unless you have a compelling reason.  Forget nearly everything
  you've read about ``@&lt;file&gt;`` family file generation as you carefully study the `@root Directive Family`_.</t>
<t tx="sps.20100712151944.7141">Here is a brief summary of each directive.  Directives valid in the node body text usually must occur at the start of a line.  Those directives that cause code to be interpolated may be preceded by whitespace, wich becomes the indentation for that code in the intepolation.  Some directives are valid in a headline; others are valid only in a headline.

</t>
<t tx="sps.20100712151944.7142">These directives are valid only in body text.

- **\@color**, **\@nocolor**, **\@nocolor-node** and **\@killcolor**
  Control syntax coloring.

- **\@wrap** and **\@nowrap**
  Enable or disable line wrapping the Leo's body pane.
</t>
<t tx="sps.20100712151944.7143"></t>
<t tx="sps.20100712151944.7144">These directives are valid only in a node headline, and are followed by the name of the file to which they apply.

- **\@asis**
  Creates an external file without sentinels,
  containing exactly the data in the ``@asis`` tree,
  without expanding section references or ``@others`` directives.

- **\@auto**
  Imports the external file every time Leo reads the outline.
  The ``read-at-auto-nodes`` and ``write-at-auto-nodes`` commands can
  be used to read and write and ``@auto`` nodes.

- **\@edit**
  Reads an external file into a single node.

- **\@file**
  A synonym for ``@thin``.

- **\@nosent**
  Same as ``@thin``, but the external file contains no sentinels.

- **\@path**
  Sets the path prefix for relative filenames (influences all child external file directives).

- **\@shadow**
  Creates two external files, a **public** file without sentinels,
  and a **private** file containing sentinels.
  Imports the file just as ``@auto`` does if the private file does not exist.

- **\@thin**
  Creates an external file containing sentinels.
  Thin external files miminize cvs and bzr conflicts.
  All essential information is stored in the thin external file.
</t>
<t tx="sps.20100712151944.7145">These directives are valid only as in the first column of body text, *unless* otherwise noted.

- **\@**
  Starts a doc part. ``@doc`` is a deprecated synonym.

- **\@c**
  Starts a code part. ``@code`` is a deprecated synonym.

- **\@comment**
  Sets comment delimiters in ``@thin``, ``@file`` and ``@shadow`` trees.

- **\@delims**
  Sets comment delimiters in ``@thin``, ``@file`` and ``@shadow`` trees.

- **\@encoding**
  Sets the Unicode encoding used in external files.

- **\@first**
  Forces lines to appear before the first sentinel of an external file.

- **\@last**
  Forces lines to appear after the last sentinel of an external file.

- **\@language**
  Sets the language used for syntax coloring *and*
  sets the comment delimiters used in sentinel lines (where they appear) and in doc parts.

- **\@lineending**
  Sets the line ending to be used in external files.

- **\@path**
  Sets the path prefix for relative filenames (influences all child external file directives).  May appear in the headline.

- **\@pagewidth**
  Sets the page width used to break doc parts into lines.

- **\@raw** and **\@end_raw**
  Delimit a section of 'raw' text.

- **\@tabwidth**
  Sets the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces.

</t>
<t tx="sps.20100712151944.7146">With the exception of ``&lt;&lt;`` *section* ``&gt;&gt;``, these directives must appear in body text.

- **&lt;&lt;** *section* **&gt;&gt;**
  In a node body, interpolates a named section; in a node headline, the body defines a named section.

- **\@all**
  Copies *all* descendant nodes to the external file, with node sentinels.
  No further descendant directives are honored.
 
- **\@ignore**
  Causes Leo to skip conversion to and from all or part of an external file.

- **\@others**
  Copies all descendant nodes *except* ``&lt;&lt;`` *section* ``&gt;&gt;`` definition nodes to the external file.
</t>
<t tx="sps.20100712151944.7147">All but noted exceptions must appear in the first column of node body text.

- **&lt;&lt;** *section name* **&gt;&gt;**
  Interpolate a named section of code.

- **&lt;&lt;** *section name* **&gt;&gt;=**
  Begin or add to the definition of a named section of code.

- **\@root**, **\@root-code** and **\@root-code**
  Start an ``@root`` tree.
  The last two forms set the starting mode for descendant node body text.

- **\@**
  Start a doc part. ``@doc`` is a synonym.

- **\@c**
  Start a code part. ``@code`` is a synonym.

- **\@comment**
  Set comment delimiters.

- **\@language**
  Set the language used for syntax coloring **and**
  set the comment delimiters used in sentinel lines.

- **\@path**
  Sets the path prefix for relative filenames (influences all child external file directives).  May appear in the node headline or the first column of body text.

- **\@tabwidth**
  Set the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces.

- **\@unit**
  Change the scope within which ``@root`` section names are valid.

- **@verbose**, **@terse**, **@quiet** and **@silent**
  Set the verbosity of sentinels.</t>
<t tx="sps.20100712151944.7183">The following sections give full details about each directive.  The same directive may have different effects depending on whether it is governed by an ``@&lt;file&gt;`` directive or an ``@root`` directive.
</t>
<t tx="sps.20100712151944.7184"></t>
<t tx="sps.20100712151944.7185">Syntax coloring is on by default in all body text.
Leo formats comments and documentation parts in red,
directives and C keywords in blue,
strings and character constants in green and all other text in code parts in black.
The color directives are recognized only in the first column of the body text.
The ``@nocolor`` directive disables syntax coloring for the lines of body text after which it appears.
No syntax coloring is done until an ``@color`` directive re-enables syntax coloring.

If a node contains neither the ``@color`` nor the ``@nocolor`` directive
it may inherit the syntax coloring attribute from an ancestor.
The nearest ancestor that contains exactly one of the ``@color`` or ``@nocolor`` directives
will control the syntax coloring.
**Ambiguous nodes**, nodes containing both the ``@color`` and ``@nocolor`` directives,
never affect the coloring of their children.

The ``@nocolor-node`` directive completely disables coloring for that node only, taking precedence over other color directives that may be present.
Descedant nodes are not affected.

The ``@killcolor`` directive completely disables the colorizer for that node and its descendants, although
``@killcolor`` may itself be overridden in descendant nodes.
The differences between ``@killcolor`` and ``@nocolor``:

- ``@nocolor`` suppresses coloring only until the next ``@color`` directive.

- ``@killcolor`` overrides ``@nocolor`` and ``@color`` directives.
  Any node containing ``@killcolor`` is unambiguously an ``@killcolor`` node regardless of
  whether that node also contains ``@color`` or ``@nocolor`` directives.

``@killcolor`` and ``@nocolor-node`` differ in that the influence of ``@nocolor-node`` does not extend to descendant nodes, whereas ``@killcolor`` does influence descendant nodes.

Leo recognizes the color directives only in the first column of body text, not in headlines.
They have no effect on the tangle process.
</t>
<t tx="sps.20100712151944.7186">@nowrap
By default, the ``@bool body_pane_wraps`` setting controls whether body text wraps.  You may override this setting for a particular tree using the ``@wrap`` and ``@nowrap`` directives.  Only the first ``@wrap`` or ``@nowrap`` directive in a node has any effect.  ``@wrap`` and ``@nowrap`` are recognized in both headlines and the body.  In the body, these directives are recognized only in the first column of body text.

</t>
<t tx="sps.20100712151944.7187">Here's an simple example using ``@thin`` to create a file.  The bodies of the three nodes can be seen in the three screenshots:

|leoAtFileMainNode|
|leoAtFileFirstChild|
|leoAtFileNamedChild|

Saving the .leo file creates not only the .leo file but also creates the file ``/var/tmp/example.py`` containing the following text::

    #@+leo-ver=5-thin
    #@+node:sps.20100713093238.7252: * @thin /var/tmp/example.py
    #@@language python 
    #@+&lt;&lt;includes&gt;&gt;
    #@+node:sps.20100713093238.7253: ** &lt;&lt;includes&gt;&gt;
    import os
    #@-&lt;&lt;includes&gt;&gt;
    #@+others
    #@+node:sps.20100713093238.7254: ** first action
    print "Hello, world!"
    #@-others
    #@-leo
</t>
<t tx="sps.20100712151944.7188">These file directives are valid only in headlines, with the exception of ``@path``, which may appear in both a headline or a body.

In the following table all terms in each row are equivalent.
The spelling in the first column is preferred:

=========== =============== =================
\@asis      \@file-asis     \@silent
----------- --------------- -----------------
\@nosent    \@file-nosent   \@nosentinelsfile
=========== =============== =================

The following table summarizes the differences between
the various kinds of external file directives.

+---------+------------+------------------+-----------------+
|         |            | Sections and     | Sections and    |
| Type    | Sentinels? | @others expanded | @others created |
|         |            | on write?        | on read?        |
+---------+------------+------------------+-----------------+
| @asis   | no         | no               | no              |
+---------+------------+------------------+-----------------+
| @auto   | no         | yes              | yes             |
+---------+------------+------------------+-----------------+
| @edit   | no         | yes              | no              |
+---------+------------+------------------+-----------------+
| @file   | yes        | yes              | .leo file       |
|         |            |                  | updated by      |
|         |            |                  | external file   |
+---------+------------+------------------+-----------------+
| @nosent | no         | yes              | no              |
+---------+------------+------------------+-----------------+
| @shadow | yes and no | yes              | yes             |
+---------+------------+------------------+-----------------+
| @thin   | yes        | yes              | .leo file       |
|         |            |                  | updated by      |
|         |            |                  | external file   |
+---------+------------+------------------+-----------------+

The ``@all`` directive in any environment supercedes ``@others`` and section expansion.

Leo uses a variety of means to create the outline structure for external files.  For ``@thin`` and ``@file`` external files, it uses the sentinels embedded in the external file.  For ``@auto`` external files, it relies on a parser for the source code to infer meaningful structure.   For ``@shadow`` trees, Leo creates *two* files, a **public** file without sentinels, and a **private** file (by default in the ``.leo_shadow`` subfolder) containing sentinels. The primary sources for ``@shadow`` trees are the private files, updated by changes to the public file.  The source for ``@nosent`` and ``@asis`` trees are the .leo file from which those files were created.  For ``@edit`` files, the external file goes into a single node body.  One may temporarily structure an ``@edit`` node in the manner of an ``@thin`` node, but that structure vanishes once you close the .leo file.


</t>
<t tx="sps.20100712151944.7189">Leo creates files from ``@asis`` trees by writing the body text of all nodes of the
``@asis`` tree in outline order. Leo writes the body text *as is*, without recognizing
section definitions, without expanding section references, and without treating
directives specially in any way. In particular, Leo copies all directives,
including ``@`` or ``@c`` directives, to the external file as text.

Leo does recognize the ``@ignore`` directive in the *ancestors* of ``@asis`` nodes, so
you may use the ``@ignore`` directive as usual to prevent Leo from writing ``@asis``
trees.

**Notes**:

- Within ``@asis`` trees only, if a headline starts with ``@@``, Leo writes
  everything in the headline following the ``@@`` just before the corresponding
  body text.

- Files created from ``@asis`` trees contain *nothing* not contained in body
  text (or ``@@`` headlines). In particular, if body text does not end in a
  newline, the first line from the next node will concatenated to the last line
  of the preceding node.
</t>
<t tx="sps.20100712151944.7190">.. _`auto reference`:

``@auto`` trees allow people to use Leo in collaborative environments without using
sentinels in the files Leo generates. In contrast to ``@nosent``, ``@auto`` trees can
change when the corresponding file changes outside of Leo.

Leo automatically recreates (imports) all ``@auto`` trees when reading a .leo
file, and writes all dirty ``@auto`` trees when saving a .leo file. There are
two exceptions to this statement:

1. Leo will not read (import) or write an ``@auto`` tree if the ``@auto`` node or its parents contain an ``@ignore`` directive.  ``@ignore`` in the descendants of a node only affect the node containing the ``@ignore`` directive and the descendants of that node.

2. Saving a .leo file does not save ``@auto`` nodes if:

    a) they haven't changed or,

    b) they do not contain a **significant** amount of information. An ``@auto`` tree
       contains a significant amount of information if it has  children or if the
       root node contains more than 10 characters.

Leo creates ``@auto`` trees by parsing the corresponding external file. Parsers
create descendant nodes of the @auto tree: one node for each class, method and
function in the external file, and sometimes nodes for declarations, docstrings
or other recognized components.

Parsers presently exist for C, elisp, Java, Javascript, Pascal, PHP, Python and xml. Leo
determines the language using the file's extension.  Notes:

- If no parser exists for a language, Leo copies the entire body of the external file into the ``@auto`` node.

- Lines that look like section references are dealt with using the ``@verbatim`` pseudo-directive which suppresses all directive interpretation on the immediately following line (the colorizer may remain confused).  Although Leo interprets ``@verbtim`` when writing all but the ``@asis`` type of ``@&lt;file&gt;`` directives, only in ``@auto`` does it get inserted when the file is read into Leo.  Thus, one might succeed in using ``@verbatim`` to write a file with ``&lt;&lt;`` section ``&gt;&gt;`` delimiters uninterpreted, and one may further read that file back into Leo, but unless the ``@&lt;file&gt;`` directive is ``@auto``, the ``@verbatim`` guard will have absconded, and a further attempt to write the file from Leo will fail.

- Use the ``@data import_xml_tags`` setting to specify the xml tags that create outline nodes. By default, the **organizer tags** are html, body, head, and div.
</t>
<t tx="sps.20100712151944.7191">Leo performs several checks to ensure that the result of importing an external
file will be equivalent to the file that writing the ``@auto ``tree would produce.

These checks can produces **errors** or **warnings**. Errors indicate a
potentially serious problem. Leo inserts an ``@ignore`` directive in the ``@auto`` tree
if any error is found. This ``@ignore`` directive prevents the ``@auto`` tree from
modifying the external file. If you remove or displace the ``@ignore`` directive, a later write of the
``@auto`` tree will attempt to fix the problems that gave rise to the errors. There
are no guarantees however.

Before importing a file, Leo **regularizes** the leading whitespace of all lines
of the original source file. That is, Leo converts blanks to tabs or tabs to
blanks depending on the value of the ``@tabwidth`` directive in effect for the ``@auto``
node. Leo also checks that the indentation of any non-blank line is not a
multiple of the indentation specified by the ``@tabwidth`` directive in effect for
the ``@auto`` node.

Leo cannot guarantee to reproduce the original source file exactly if problems
are discovered while regularizing leading whitespace. **Strict languages** are
languages such as Python for which leading whitespace must be preserved exactly
as it appears in the original source file. Problems during regularizing whitespace generate
errors for strict languages and warnings for non-strict languages.

After importing a file, Leo verifies that writing the ``@auto`` node would create
*exactly* the same file as the original file. Such file comparison mismatches
generate errors unless the problem involves only leading whitespace for
non-strict languages. Whenever a mismatch occurs the first non-matching line is
printed.

File comparison mismatches can arise for several reasons:

1. Bugs in the import parsers. Please report any suspected bugs immediately.

2. Underindented lines in classes, methods or function. An **underindented
   line** is a line that is indented less then the starting line of the class,
   method or function in which it appears. Leo outlines can not represent such
   lines exactly: every line of node implicitly has at least the indentation of
   any unindented line of the node.

Leo will issue a warning (not an error) for underindented Python comment lines.
Such lines can not change the meaning of Python programs.</t>
<t tx="sps.20100712151944.7192">Three commands allow you to manually read and write ``@auto`` nodes from the presently selected outline. As always, an ``@ignore`` directive in the ``@auto`` node or its ancestors will suppress any of these commands.  Invokw the following in the minibuffer with Alt-x:

- The ``read-at-auto-nodes`` command reads all ``@auto`` nodes in the
  presently selected outline. An ``@ignore`` directive will suppress this import.

- The ``write-at-auto-nodes`` command writes all ``@auto`` nodes. An
  ``@ignore`` directive will suppress this write. Caution: if the node contains the "significant" content described above, the write will occur even if Leo has not previously read the ``@auto`` node.

- The ``write-dirty-at-auto-nodes`` is the same as the ``write-at-auto-nodes`` command, except that only changed ``@auto`` trees are written.

Most users will rarely use these explicit commands, because reading and writing
.leo files handles ``@auto`` nodes well enough. However, you can use the
``read-at-auto-nodes`` command to update ``@auto`` nodes changed outside of Leo (e.g., by a text editor or version control system) without having to reload the .leo file.
</t>
<t tx="sps.20100712151944.7193">When Leo starts, an ``@edit`` node reads a file into its body without any child nodes, possibly with appropriate ``@language`` or ``@nocolor`` directives.  Like ``@auto``, Leo writes no sentinels when writing the external file.  ``@edit`` is also similar to ``@auto`` in that saving a .leo file does not save a dirty ``@edit`` node unless it contains a **significant** amount of information.  An ``@edit`` noe contains a significant amount of information if it has children or if the root node contains more than 10 characters.  In an ``@edit`` noe, Leo interprets text generation and tree walk directives in the manner of an ``@file`` or ``@thin`` subtree, but any such structure is lost once you close the Leo window.
</t>
<t tx="sps.20100712151944.7194">.. _`file reference`:

``@file`` is a synonym for ``@thin``. The ``@file`` directive creates an external file
containing sentinels.

This was not always entirely so; if you work on the same .leo file with Leo 4.6
or earlier as well as with Leo 4.7 and later, the two interpretations will corrupt
each other: the workaround is to change all ``@file`` directives to ``@thin``, then save the
.leo file and its generated files.  ``@thin`` works in any Leo version that supports it, since all
versions support ``@thin`` in the same way -- although, beware of impending changes in sentinel syntax, which will again prevent differing version of Leo ``@&lt;file&gt;`` directives from interoperating.  </t>
<t tx="sps.20100712151944.7195">Leo writes ``@nosent`` trees just as for ``@thin`` trees, except it writes no sentinels at all.
All the information for the ``@nosent`` tree is kept in the .leo file,
and Leo incorporates no changes from the external file.

The ``@bool force_newlines_in_at_nosent_bodies`` setting
controls whether Leo writes a trailing newline if non-empty body text does not
end in a newline. The default is True. In effect, the default value of this
setting was False in early versions of Leo.
</t>
<t tx="sps.20100712151944.7196">``@path`` directives override the deprecated ``@directory default_tangle_directory`` setting.

The form is:

 ``@path`` *directory*

where *directory* is taken to be the first non-whitespace following ``@path`` to the end of the line.

When an external file directive such as ``@thin`` specifies an absolute path,
no ``@path`` or setting affects the external file name.
When an external file directive specifies a relative name,
Leo derives the directory to which that name is relative as follows:

1. the directory specified by ``@path`` directives in parent nodes, or
2. the ``@directory default_tangle_directory`` if no ``@path`` directive is in effect, or
3. the directory in which the .leo file resides if the .leo file has ever been saved.

As parent nodes are examined beginning with the closest, Leo prepends relative path components, and finishes when prepending an absolute path.  In other words, ``@path`` directives specifying relative directory names are relative to their parent nodes.  If no ``@path`` directive gives an absolute directory name, then the topmost ``@path`` is relative to either (2) or (3) in the list above.

An error occurs if no absolute path can be computed according to these rules,
or if the derived directory name does not exist.
</t>
<t tx="sps.20100712151944.7197">When writing an ``@shadow`` tree, Leo writes *two* files, a **public** file without
sentinels, and a **private** file (by default in the ``.leo_shadow`` subfolder)
containing sentinels. The primary sources for ``@shadow`` trees are the private
files, updated by changes to the public file.

When reading an ``@shadow`` tree, Leo will import the tree from the public file if
the private file does not exist.  **Important**: just as for ``@auto``, the following
exceptions apply:

1. Leo will not read (import) or write an ``@shadow`` tree if the ``@shadow`` node or its parents contain an ``@ignore`` directive.  ``@ignore`` in the descendants of a node only affect the node containing the ``@ignore`` directive and the descendants of that node.

2. Saving a .leo file does not save ``@shadow`` nodes if:

   a) they haven't been changed or,

   b) they do not contain a **significant** amount of information. An ``@shadow`` tree
      contains a significant amount of information if it has children or if the
      root node contains more than 10 characters.

Leo can do an initial import of ``@shadow`` trees by parsing the corresponding public file, exactly as is done for ``@auto`` node. See the discussion of `@auto reference`_ for details.
</t>
<t tx="sps.20100712151944.7198">``@thin`` creates an external file containing sentinels.  An ``@thin`` external file contains all the
information needed to recreate the ``@thin`` tree in the outline.  In a collaborative environment,
where everyone uses Leo for editing and a version control system, ``@thin`` is the recommended way to hold most content.
</t>
<t tx="sps.20100712151944.7199"></t>
<t tx="sps.20100712151944.7200">The ``@`` directive starts a doc part.
Doc parts continue until an ``@c`` directive or the end of the body text.
For example::

    @ This is a comment in a doc part.
    Doc parts can span multiple lines.
    The next line ends the doc part
    @c

``@doc`` is a synonym for ``@``, but ``@`` is preferred.

The directive is only recognized in the first column.

In ``@thin`` style external files, such documentation sections appear as comments, using comment
characters appropriate to the language, or as specified by the prevailing ``@comment`` or ``@delims``
directive.  

A governing ``@asis``, ``@all``, or ``@raw`` directive causes the directive
to be uninterpreted and simply copied to the external file.
</t>
<t tx="sps.20100712151944.7201">The ``@c`` directive ends a doc part and begins a code part.
``@code`` is a synonym for ``@c``, but ``@c`` is preferred.

The directive is only recognized in the first column.

A governing ``@asis``, ``@all``, or ``@raw`` directive causes the directive
to be uninterpreted and simply copied to the external file.
</t>
<t tx="sps.20100712151944.7202">**Note**: You should use the ``@language`` directive whenever possible.  However, sometimes using both ``@language`` and ``@comment`` is useful. For this to be effective the ``@comment`` directive should appear after the ``@language`` directive (in outline order).  In such cases ``@comment`` overrides the comment delimiters normally used by ``@language``.  Even in this case, you will generally do better combining ``@language`` and ``@delims``.  See `@delims`_.  **DO NOT** combine ``@comment`` with ``@delims``: the result is undefined and often generates a file which Leo cannot read and from which **data will be lost** after any subsequent ''save''.

``@comment`` controls the text used to designate comment strings in the external file.
By default, saving an ``@thin`` style tree produces C-language
comments.  Single-line comments generated during generation start with ``//``, while
documentation parts are surrounded by ``/*`` and ``*/``. The ``@comment`` directive allows
you to work with source code for almost any programming languages.

The ``@comment`` directive may be followed by zero to three delimiters, separated by
whitespace. This directive sets the single-line comment delimiter and the
opening and closing block comment delimiters as follows:

========================  =====================================================================
``@comment``              no args\: restores the defaults to ``//``, ``/*`` and ``*/``
------------------------  ---------------------------------------------------------------------
``@comment //``           \1 arg\: sets the single-line comment and clears the other delims.
------------------------  ---------------------------------------------------------------------
``@comment /* */``        \2 args\: sets the block comment delims; clears the single-line delim.
------------------------  ---------------------------------------------------------------------
``@comment // /* */``     \3 args\: sets all three delimiters.
========================  =====================================================================

If only one delimiter is given, Leo uses it to begin each line of a
recognized documentation part (that is, one ungoverned by something like ``@all``).

If two delimiters are given, Leo uses block-style comments instead of single-line comments.
For example, ``@comment { }`` could be used with Pascal files.

The ``@comment`` directive must precede the first section name or ``@c`` directive.

Leo will convert underscores in the ``@comment`` directives to significant spaces.  For example::

    @comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).
</t>
<t tx="sps.20100712151944.7203">.. _`delims reference`:

The ``@delims`` directive changes the comment strings used to mark sentinel lines from that point forward in the body text.
This directive is often used to place Javascript text inside XML or HTML files.

The ``@delims`` directive contains one or two delimiters, separated by whitespace.
If only one delim is present it delimits single-line comments.
If two delims are present they delimit block comments.
The ``@delims`` directive can not be used to change the comment strings at the start of the external file,
that is, the comment strings for the ``@+leo`` sentinel and the initial ``@+body`` and ``@+node`` sentinels.

The ``@delims`` directive inserts ``@@delims`` sentinels into the external file.
The new delimiter strings continue in effect until the next ``@@delims`` sentinel in the external file or
the end of the external file.

**Note**: Leo can not revert to previous delimiters automatically;
you must change back to previous delimiters using another ``@delims`` directive. For example::

    @delims /* */
    Javascript stuff
    @delims &lt;-- --&gt;
    HTML stuff

Adding, deleting or changing ``@delims`` sentinels will destroy Leo's ability to read the external file.
``@delims`` affects only external files, having no effect on Leo's colorizer or internal data representation.
Incorrect use will thoroughly corrupt the external file as far as compilers, HTML renderers, etc. are concerned.  Do not mix ``@delims`` with ``@comment``.</t>
<t tx="sps.20100712151944.7204">You may use the ``@encoding`` directive to specify the encoding used in an external file.
You can't mix encodings in a single external file.  For example::

    @encoding iso-8859-1

If the encoding used in an external file is not "utf-8" it is represented in the ``@+leo`` sentinel line, like this::

    #@+leo-encoding=iso-8859-1.

The utf-8 encoding is used by default.
The utf-8 encoding is a "lossless" encoding (it can represent all unicode code points),
so encoding and decoding to and from utf-8 plain strings will never cause a problem.
When reading or writing a character not in a "lossy" encoding (such as iso-8859-1),
Leo converts such characters to '?' and issues a warning. </t>
<t tx="sps.20100712151944.7205">The ``@first`` directive allows you to place lines at the very start of external files.  (Like all directives, it is not interpreted in ``@asis`` nodes.)  For example, the first line of body text of ``@file spam.py`` might be::

	@first #! /usr/bin/env python

The first line of body text of ``@file foo.pl`` might be::

	@first #/usr/bin/perl

``@first`` directives are recognized only at the start of the body text of external
file directive nodes.  No text may precede ``@first`` directives.
More than one ``@first`` directive may exist, like this::

	@first #!/bin/sh -- # perl, to stop looping
	@first eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
	@first     if 0;

</t>
<t tx="sps.20100712151944.7206">The ``@language`` directive specifies the comment delimiters and string types used by the tangle and untangle processes.  The ``@language`` directive over-rides the default specified in the ``@string targetlanguage`` setting.

The valid ``@language`` directives are::

    @language actionscript
    @language ada
    @language autohotkey
    @language batch
    @language c
    @language config
    @language cpp
    @language csharp
    @language css
    @language cweb
    @language elisp
    @language forth
    @language fortran
    @language fortran90
    @language haskell
    @language haxe
    @language html
    @language ini
    @language java
    @language javascript
    @language kshell
    @language latex
    @language lua
    @language noweb
    @language pascal
    @language perl
    @language perlpod
    @language php
    @language plain
    @language plsql
    @language python
    @language rapidq
    @language rebol
    @language rest
    @language rst
    @language ruby
    @language shell
    @language tcltk
    @language tex
    @language unknown
    @language unknown_language
    @language vim
    @language vimoutline
    @language xml
    @language xslt

Shell files have comments that start with `#`.
Case is ignored in the language specifiers, but not in the ``@language`` itself.
Thus, the following are equivalent::

    @language html
    @language HTML
    @language hTmL

but the following is invalid::

    @LANGUAGE html</t>
<t tx="sps.20100712151944.7207">The ``@last`` directive allows you to place lines at the very end of external files (except those
constructed with ``@asis``).  The ``@last`` directive is recognized only at
the end of body text of the node with the external file directive in its headline (e.g., the ``@thin`` node).  No text may follow ``@last`` directives. More than one ``@last`` directive may exist.  For example, here is how a PHP file might be set up::

	@first &lt;?php
	...
	@last ?&gt;
</t>
<t tx="sps.20100712151944.7208">The ``@lineending`` directive sets the line endings for individual external files.
This directive will override the ``@string output_newline`` setting.
The ``@lineending`` *never* affects the line endings in .leo files themselves:
.leo files must have consistent line endings!

The valid forms of the @lineending directive are:

========================   ======================================================
``@lineending nl``         The default, Linux.
------------------------   ------------------------------------------------------
``@lineending cr``         Mac
------------------------   ------------------------------------------------------
``@lineending crlf``       Windows
------------------------   ------------------------------------------------------
``@lineending lf``         Same as 'nl', not recommended
------------------------   ------------------------------------------------------
``@lineending platform``   Same as platform value for output_newline setting.
========================   ======================================================</t>
<t tx="sps.20100712151944.7209">The ``@pagewidth`` directive overrides the ``@int page_width`` setting.
The form of the ``@pagewidth`` directive is ``@pagewidth`` *n*,
where *n* is a positive integer that indicates the width of tangled pages in columns.
For example::

    @pagewidth 100

This setting only affects how Leo tangles doc parts into block comments.

</t>
<t tx="sps.20100712151944.7210">The ``@raw`` directive starts a section of "raw" text. The ``@end_raw`` directive ends
such a section, as does the end of body text.  In this way, content that might otherwise be mistaken for a section definition or directive can be escaped.  None of the leading whitespace which is normally generated by the position of ``@others`` or a section reference gets inserted within raw text when writing the external file.
</t>
<t tx="sps.20100712151944.7211">The ``@tabwidth`` directive overrides the ``@int tab_width`` setting.
The form of the ``@tabwidth`` directive is ``@tabwidth`` *n*,
where the absolute value of *n* is the width of tabs in spaces.
For example::

    @tabwidth -4

Negative values cause Leo to convert tabs to spaces.
</t>
<t tx="sps.20100712151944.7213"></t>
<t tx="sps.20100712151944.7214">In the ``@auto``, ``@edit``, ``@file``, ``@nosent``, ``@shadow`` and ``@thin`` trees, ``&lt;&lt;`` *section* ``&gt;&gt;`` in the headline specifies that this node and its descendants define a named section.  In the body of a node, it specifies the location at which the text of a named section (defined in a child node) is to be interpolated.  It is the only directive recognized in the body when preceded by something other than whitespace.

As with nearly all other directives, sections are ignored in ``@asis`` trees or when governed by ``@all``.
</t>
<t tx="sps.20100712151944.7215">The ``@all`` directive is valid only in the body of ``@thin`` style trees.  The ``@all`` directive is similar to ``@others`` in that it interpolates descendant nodes at the location where it appears, but it is less fastidious: it writes *all* descendant nodes in outline order to the external file, including ``@ignore`` nodes and nodes that in an ``@others`` tree would be considered to be orphan nodes, generally ceasing to interpret any further tree walk or text generation modifying directives.  Node headlines become part of sentinels in the external file.

The ``@all`` directive is used for nodes such as ``@thin leoProjects.txt`` in ``LeoPy.leo``.  ``leoProjects.txt`` contains so-called project nodes.  It doesn't have any meaning as a program file: it is simply a collection of unrelated data.  ``@others`` would not work at all: it would complain about lots of orphan nodes.
</t>
<t tx="sps.20100712151944.7216">Generally speaking, an ``@ignore`` directive in the body of a node prevents that node and its descendants from being processed.  It is not recognized in headlines.

#. In the body of the root node of any ``@auto``, ``@edit``, ``@file``, ``@nosent``, ``@thin`` or ``@shadow`` tree, 
   the ``@ignore`` directive prevents Leo from writing the external file. 

#. ``@auto`` trees are an exception.  Everything, including ``@ignore`` directives occuring in descendants of the root node, are written.
   However, you can disable the writing of an ``@auto`` tree by putting an ``@ignore`` directive in the body of the ``@auto`` node or in an
   ancestor of the ``@auto`` tree.

#. Extensions to Leo such as plugins and scripts should preserve the behavior in item 1 above.
</t>
<t tx="sps.20100712151944.7217">The ``@others`` directive in the node body specifies where to interpolate the body text of all nodes *except* section
definition nodes.  Section definition nodes are those with headlines that do not contain the patter ``&lt;&lt;`` *section* ``&gt;&gt;``.   The ``@others`` directive places the body text of non-section definition nodes into the external file in outline order.

An  ``@&lt;file&gt;`` tree may contain more than one ``@others`` directive. ``@others``
directives that descend from other ``@others`` directives refer only to non-section
nodes that descend from them.  The ``@others`` directive that occurs highest in the
``@&lt;file&gt;`` tree refers to all other unnamed nodes.  If ``@others`` occurs multiple times in the same node, all non-section nodes appear at the location of the first instance of the ``@others`` directive; the remainder
are remembered as sentinels but have no other content.
</t>
<t tx="sps.20100712151944.7218">.. _`root reference`:
</t>
<t tx="sps.20100712151944.7220">The ``@root`` directive specifies the name of a file to create.  The remaining lines of the node body, until the next section definition or ``@`` doc part specify the contents of the file.  Normally, there is a combination of literal text and section references.  The sections referenced must be defined either within the node body (not recommended), within a descendant node body, or within the descendants of an (optional) ancesetor ``@unit`` directive.
</t>
<t tx="sps.20100712151944.7222">Leo allows you to choose whether body text in ``@root`` trees will start in code
mode or doc mode by default. The ``@root-doc`` *filename* and ``@root-code`` *filename*
directives specify that body text is assumed to start in doc mode or code mode
respectively. The options (-doc and -code) must follow @root immediately with no
intervening whitespace. In effect, @root-code and @root-doc are two new
directives.

These ``@root`` options override the ``@bool at_root_bodies_start_in_doc_mode`` setting, which affects only ``@root`` trees without options.  It is better style to use the explicit
``@root-code`` or ``@root-doc`` directive, since the meaning of plain
``@root`` trees will depend on the ``@bool at_root_bodies_start_in_doc_mode setting``.  By default, ``@bool at_root_bodies_start_in_doc_mode = True`` for
compatibility with earlier Leo ``@root`` trees.  The distinction in whether to expect doc or code at the beginning of a node applies only to descendants of the ``@root`` node; the node containing the ``@root`` directive always effectively begins in doc mode.</t>
<t tx="sps.20100712151944.7224">The ``@`` directive starts a doc part.
Doc parts continue until an ``@c`` directive, a section definition of the form ``&lt;&lt;`` *section* ``&gt;&gt;=``, or the end of the body text.
For example, in a node headlined ``&lt;&lt; careful open &gt;&gt;``::

    @ Exit with an error if we
    can't open the file
    @c
    FILE *
    careful_open(char *s) {
        FILE *f;
        f = fopen(s,"r");
        if (f == NULL) {
            fprintf(stderr,"File open of %s failed.\n",s);
            exit(1);
        }
        return f;
    }
    @ we need stdio
    &lt;&lt; includes &gt;&gt;=
    #include &lt;stdio.h&gt;

``@doc`` is a synonym for ``@``, but ``@`` is preferred.
</t>
<t tx="sps.20100712151944.7226">If the headline is of the form ``&lt;&lt;`` *section* ``&gt;&gt;``, the ``@c`` directive ends a doc part and begins a code part.  Multiple parts may occur in the node; each of the ``@c`` will add another code part to the code section named in the headline.  If the headline does not contain a double angle bracketed section name, attempts to tangle or untangle the ``@root`` tree will generate an error.  ``@code`` is a synonym for ``@c``, but ``@c`` is preferred.
</t>
<t tx="sps.20100712151944.7228">The ``@comment`` directive is followed by zero to three delimiters, separated by
whitespace. This directive sets the single-line comment delimiter and the
opening and closing block comment delimiters as follows:

====================== =====================================================================
``@comment``           no args\: restores the defaults to ``//``, ``/*`` and ``*/``
---------------------- ---------------------------------------------------------------------
``@comment //``        \1 arg\: sets the single-line comment and clears the other delims.
---------------------- ---------------------------------------------------------------------
``@comment /* */``     \2 args\: sets the block comment delims; clears the single-line delim.
---------------------- ---------------------------------------------------------------------
``@comment // /* */``  \3 args\: sets all three delimiters.
====================== =====================================================================

For example, the directive ``@comment { }`` could be used to tangle Pascal files.

Leo will convert underscores in the @comment directives to significant spaces.  For example::

    @comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).  Leo interprets a double underscore as a newline so that ``@comment __=pod__ __=cut__`` could support perl's POD facility.
</t>
<t tx="sps.20100712151944.7230">You may use the @encoding directive to specify the encoding used in an external file.
You can't mix encodings in a single external file.  For example::

    @encoding iso-8859-1

If the encoding used in an external file is not "utf-8" it is represented in the @+leo sentinel line, like this::

    #@+leo-encoding=iso-8859-1.

The utf-8 encoding is used by default.
The utf-8 encoding is a "lossless" encoding (it can represent all unicode code points),
so encoding and decoding to and from utf-8 plain strings will never cause a problem.
When reading or writing a character not in a "lossy" encoding (such as iso-8859-1),
Leo converts such characters to '?' and issues a warning. </t>
<t tx="sps.20100712151944.7232">The @first directive allows you to place vebatim lines at the very start of external files.
For example, the body text of ``foo.py`` nmight begin::

	@first #! /usr/bin/env python

The first line of body text of ``@file foo.pl`` might be::

	@first #/usr/bin/perl

``@first`` directives are recognized only at the start of the body text of external
file directive nodes.  No text may precede ``@first`` directives.
More than one ``@first`` directive may exist, like this::

	@first #!/bin/sh -- # perl, to stop looping
	@first eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
	@first     if 0;
</t>
<t tx="sps.20100712151944.7234">Generally speaking, the ``@ignore`` directive prevents tangle and untangle from processing a node and its descendants.  It is recognized in both the headline and body text.
</t>
<t tx="sps.20100712151944.7236">The ``@language`` directive specifies the comment delimiters and string types recognized by the
tangle and untangle processes.  This directive over-rides the default specified ``@string target-language`` setting.
The languages for which comment delimiters are known for the tangle and untangle processes are::

    actionscript                ada                     autohotkey              batch
    c                           config                  cpp                     csharp
    css                         cweb                    elisp                   forth
    fortran                     fortran90               haskell                 haxe
    html                        ini                     java                    javascript
    kshell                      latex                   lua                     noweb
    pascal                      perl                    perlpod                 php
    plain                       plsql                   python                  rapidq
    rebol                       rest                    rst                     ruby
    shell                       tcltk                   tex                     unknown
    unknown_language            vim                     vimoutline              xml
    xslt

The ``@language`` directive also specifies how the colorizer operates.  The languages supported by the colorizer are
described by *language* ``.py`` in the ``leo/modes`` directory.  Currently, the list of languages there is::

    actionscript            ada95                   ahk                     antlr
    apacheconf              apdl                    applescript             aspect_j
    asp                     assembly_macro32        assembly_mcs51          assembly_parrot
    assembly_r2000          assembly_x86            awk                     batch
    bbj                     bcel                    bibtex                  b
    chill                   cobol                   coldfusion              cplusplus
    c                       csharp                  css                     cvs_commit
    doxygen                 d                       dsssl                   eiffel
    embperl                 erlang                  factor                  forth
    fortran90               fortran                 foxpro                  freemarker
    gettext                 groovy                  haskell                 haxe
    hex                     html                    i4gl                    icon
    idl                     inform                  ini                     inno_setup
    interlis                io                      java                    javascript
    jcl                     jhtml                   jmk                     jsp
    latex                   lilypond                lisp                    lotos
    lua                     mail                    makefile                maple
    matlab                  ml                      modula3                 moin
    mqsc                    netrexx                 nqc                     nsis2
    objective_c             objectrexx              occam                   omnimark
    pascal                  patch                   perl                    php
    phpsection              pike                    pl1                     plain
    plsql                   pop11                   postscript              povray
    powerdynamo             progress                prolog                  props
    pseudoplain             psp                     ptl                     pvwave
    pyrex                   python                  rebol                   redcode
    relax_ng_compact        rest                    rhtml                   rib
    rpmspec                 r                       rtf                     ruby
    rview                   sas                     scheme                  sdl_pr
    sgml                    shell                   shellscript             shtml
    smalltalk               smi_mib                 splus                   sqr
    squidconf               ssharp                  svn_commit              swig
    tcl                     texinfo                 tex                     text
    tpl                     tsql                    uscript                 vbscript
    velocity                verilog                 vhdl                    xml
    xsl                     zpt

If you choose to use a language for which the comment delimiters are unknown, use an ``@comment`` directive to inform Leo so that it may generate appropriate sentinels.

Case is ignored in the language specifiers, but not in the @language itself.
Thus, the following are equivalent::

    @language html
    @language HTML
    @language hTmL

but the following is invalid::

    @LANGUAGE html

For the purposes of colorization, only the first ``@language`` directive in a node or its nearest ancestor is effective.
</t>
<t tx="sps.20100712151944.7238">**SCHAEFER, IMPLEMENT THIS FOR @ROOT**

The @last directive allows you to place lines at the very end of external files
created from @file and @thin nodes. The @last directive is recognized only at
the end of body text of @file and @thin nodes. No text may follow @last
directives. More than one @last directive may exist. For example, here is how a
PHP file might be set up::

	@first &lt;?php
	...
	@last ?&gt;</t>
<t tx="sps.20100712151944.7242">``@path`` directives override the ``@directory default_tangle_directory`` setting.

``@path`` only influences ``@root`` directives which specify a relative path for their filename.

The form of the ``@path`` directive is ``@path`` *direcotryname*,
where *directoryname* is taken to be everything following ``@path`` to the end of the line.  ``@path`` may occur in both body text and headlines; only the first occurrence in a node is effective effective, with the headline taking precedence over the body.  The ``@path`` directive may occur in the same node with the ``@root`` directive.

If *directoryname* is an absolute path (e.g., beginning with ``C:\\`` or ``/``) the location of the external file is specified only by that directory name and any relative ``@path`` directives intervening between the absolute name node and the ``@root`` directive.  If *directoryname* is relative, the location of the external file is relative to:

1. the directory specified by all applicable ancestor ``@path`` directives, or
2. the ``@directory default_tangle_directory``, or
3. the directory in which the .leo file resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules,
or if *filename* does not exist.

It is usually advisable to have the Leo outline parallel the file system structure - which one hopes was chosen to be meaningful.  Put the .leo file in the topmost directory where it will be generating a file, and for all subdirectories where it will be generating files, have an ``@path`` directive in a node for that subdirectory.  For example (designating nodes by their function)::

    + @root README
    + @root Makefile
    + @path include
        + @root azaza.h
    + @path a2z
        + @root a2z.c
        + @root a2z.h
    + @path z2a
        + @root z2a.c
        + @root z2a.h
    + @path lib
        + @root azaza.c
        + @path sublib
            + @root zazaz.c
            + @root zazaz.h

would correspond to the files::

    azaza.leo
    README
    Makefile
    include/azaza.h
    a2z/a2z.c
    a2z/a2z.h
    z2a/z2a.c
    z2a/z2a.h
    lib/azaza.c
    lib/sublib/zazaz.c
    lib/sublib/zazaz.h

If the conceptual structure does not follow the file system structure, use an ``@unit`` directive as a parent to all the ``@root`` directives, then define the named sections of the files in a structure beneath the ``@unit`` directive that *is* faithful to the concepts.  Alternatively, one may use clones to pull out nodes into sibling non-``@root`` trees that expose concepts, e.g., call-into or call-out diagrams.
</t>
<t tx="sps.20100712151944.7244">The ``@pagewidth`` directive overrides the ``@int page_width`` setting.
The form of the ``@pagewidth`` directive is ``@pagewidth`` *n*,
where *n* is a positive integer that indicates the width of tangled pages in columns.
For example::

    @pagewidth 100

This setting only affects how Leo tangles doc parts into block comments when ``@bool output-doc-flag = True``.
</t>
<t tx="sps.20100712151944.7246">The ``@tabwidth`` directive overrides the ``@int tab_width`` setting.
The form of the ``@tabwidth`` directive is ``@tabwidth`` *n*,
where the absolute value of *n* is the width of tabs in spaces.
For example::

    @tabwidth -4

Negative values cause Leo to convert tabs to spaces.
</t>
<t tx="sps.20100712151944.7248">The ``@unit`` directive is placed as an ancestor to``@root`` trees so that a section defined anywhere in its descendants may be referenced in any of its descendant ``@root`` trees.  There is no equivalent for ``@&lt;file&gt;`` trees.
</t>
<t tx="sps.20100712151944.7250">Whem the ``@verbose``, ``@terse``, ``@quiet`` and ``@silent`` directives appear in body text, they determine
how the tangle process puts comments in ``@root`` derived files.
Comments written by the user in code sections (which must of course use the native comment syntax) are always output.
These directives control only:
a) the comments containing doc sections and
b) sentinel comments that delimit the beginning and end of code sections.

When ``@verbose`` is in effect, the tangle process emits the sentinels necessary for the untangle process.  If ``@bool print_doc_flag = True``, the tangle process also puts doc parts in the derived file as comments.

When ``@quiet`` is in effect, the tangle process emits comments indicating section names, **BUT** does not emit the section end comments necessary for the untangle process.  If ``@bool print_doc_flag = True``, the tangle process also puts the doc parts in the derived file as comments.

When ``@terse`` is in effect, tangle outputs only those comments necessary for untangle to work; it *does not* emit doc parts, regardless of the value of ``@bool print_doc_flag``.

When ``@silent`` is in effect tangle adds no additional comments, does not emit doc parts (regardless of ``@bool print_doc_flag``), and suppresses generation of whitespace not explicitly present in section definitions.

``@verbose`` is the default.  If more than one of these directives appear in the same body text the "most verbose" of these options will be in effect.</t>
<t tx="sps.20100712151944.7253"></t>
<t tx="sps.20100712151944.7254"></t>
<t tx="sps.20100712151944.7259">This section discusses ``@root`` trees.  Every code sction in an ``@root`` tree must be part of t
``@root`` directives must appear in body text, not headlines (though this may change in the future).

You should carefully consider whether the extra flexibility afforded by ``@root``
trees is worth the extra bother; ``@&lt;file&gt;`` trees are typically easier to use than
``@root`` trees, for the following reasons:

- ``@&lt;file&gt;`` trees use less markup than ``@root`` trees, since every code section
  must be explicitly named explicitly placed by name.  In particular, the ``@others``
  directive is valid only within ``@&lt;file&gt;`` trees.

- You must explicitly tangle and untangle ``@root`` trees using tangle and
  untangle commands.

However, ``@root`` trees are more flexible than ``@&lt;file&gt;`` trees:

- Sections may be defined anywhere within ``@root`` trees.

- The ``@unit``  directive can expand the scope of section definitions to all descendant ``@root`` trees so that a
  section may be referenced in several ``@root`` trees.

- Sections definitions may be extended by multiple nodes within the governing scope; in the external file, the corresponding parts appear in the outline order of the appearance of the multiple section definitions.

- Multiple sections may be defined within a single node, so if a concept requires implementation in multiple files or multiple locations within a file, it can still be presented in a coherent unit.

- The meaning of section definitions in ``@root`` trees are independent of their position within the tree, except for the influence of ancestor ``@language`` and ``@comment`` directives.
</t>
<t tx="sps.20100712151944.7260">Just as with ``@file`` trees, ``@root`` trees may contain code parts and doc parts, but their delineation is different.
Code parts start with section definition lines (see below) or the ``@c`` directive.
Doc parts start with ``@`` directive.  Parts continue until the end of body text or until the next section definition, ``@c`` or ``@`` directive.

Body text in ``@root`` trees contain zero or more code and doc parts in any order.
The ``@c`` directive starts a named code section if the node's headline starts with ``&lt;&lt;`` *section name* ``&gt;&gt;``.
Otherwise, the ``@c`` directive is invalid.

**Section definition lines** are lines of the form::

	&lt;&lt; section name&gt;&gt;=

(note the equal sign).
Such lines also start named code parts.
Named code parts in ``@root`` trees may be defined in several places.
The definition of a named code part is the concatenation of all code parts with the same name.
Body text that defines no code part is considered the doc part; it is associated with the following code section, but unless the output mode directive ``@verbose`` governs the external file generation, the doc part is ignored.
At least one non-blank line must follow at least one section definition line for the named section; empty sections generate an error and prevent any update to the external file. 

Paired &lt;&lt; and &gt;&gt; characters on the same line always denote a section name, even within comments and strings.  Thus, &lt;&lt; and &gt;&gt; characters that do not delimit a section name must be placed on separate lines.  Specifically, the ``@raw`` and ``@end_raw`` directives are not available.  If &lt;&lt; and &gt;&gt; are not paired on a line, they are treated as ordinary &lt;&lt; and &gt;&gt; characters.

Here is a typical example of the body text within an ``@root`` tree::

    @ This method puts an open node sentinel for node v.
    &lt;&lt;atFile methods&gt;&gt;=
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            &lt;&lt; issue an error message &gt;&gt;
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

The example adds a part consisting of a documentation line and six lines of code to the ``&lt;&lt;atFile methods&gt;&gt;`` code section.  Elsewhere within the ``@root`` tree, other parts may be added to the ``&lt;&lt;atFile methods&gt;&gt;`` definition.

If we have a node with a headline starting with ``&lt;&lt;atFile methods&gt;&gt;``, an equivalent to the example above is::

    @ This method puts an open node sentinel for node v.
    @c
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            &lt;&lt; issue an error message &gt;&gt;
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

If we convert the doc part to a comment we have::

    @c
    # This method puts an open node sentinel for node v.
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            &lt;&lt; issue an error message &gt;&gt;
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)


The following escape convention applies only in @root trees.
Within a code part ``@@@`` in the first column (and only in the first column) stands for a single ``@`` sign.</t>
<t tx="sps.20100712151944.7261">Each ``@root`` directive corresponds to an external file. **Tangling** is a process
of creating external files from ``@&lt;file&gt;`` or ``@root`` trees.  Leo tangles ``@&lt;file&gt;``
trees automatically whenever an outline is saved. The user must tangle
``@root`` trees explicitly using one of the Tangle commands.

The tangle process for ``@root`` directives is quite different from that for ``@&lt;file&gt;`` directives, reflecting the differing semantics of ``@root`` directives.  Leo creates external files by expanding all section references in an ``@root`` node.  Leo expands a section reference by substituting the code section itself for the
section reference. This is a recursive process: the substituted code section may
contain other code references which are themselves expanded, and so on.

The outline provides a natural way of organizing by placing the definition of a section S in a child of the node containing the reference to S.  However, if a section is referenced in more than one node, it may be placed in an ancestor of all the nodes that refer to it. Usually these rules of thumb
creates an outline whose structure mirrors the intrinsic organization of a
program.  If not, use a separate tree not containing ``@root`` directives but containing clones of the source code nodes along with organizing and documentation nodes to explain the program files.

The Tangle command creates external files from an ``@root`` node. The ``@root`` directive
indicates which sections constitute an output file. The text following an ``@root``
directive forms the entire content of the file, that is, after section
references are expanded. An outline can contain arbitrarily many ``@root``
directives: Leo's ``tangle-all``  command will create one output file for each. The
process of creating external files is called "tangling" because the code from
the outline is rearranged to create the external files.

For example, the following @root section shows a typical way of specifying a
header file xx.h::

    @root xx.h
    #ifndef xx_defined
    #define xx_defined
    &lt;&lt; declarations of public constants of the xx class &gt;&gt;
    &lt;&lt; declarations of public types of the xx class &gt;&gt;
    &lt;&lt; declarations of public variables of the xx class &gt;&gt;
    &lt;&lt; public prototypes of the xx class &gt;&gt;
    #endif

The Tangle commands will create the file xx.h from this body text by expanding
all the section references.  Any text preceding the ``@root`` directive is treated
just like the doc part of a section definition and does not appear in the external file.

As another example, the following shows a typical way of specifying the
corresponding xx.c file::

    @root xx.c
    &lt;&lt; public variables of the xx class &gt;&gt;
    &lt;&lt; private types of the xx class &gt;&gt;
    &lt;&lt; private variables of the xx class &gt;&gt;
    &lt;&lt; private function prototypes of the xx class &gt;&gt;
    &lt;&lt; methods of the xx class &gt;&gt;

Three commands tangle an outline: ``tangle``, ``tangle-all``, and ``tangle-marked``; they appear in the File-&gt;Tangle submenu.  These commands are identical except for how much of the outline
is tangled.  ``tangle`` processes only the selected portion of the outline;
``tangle-all`` processes the entire outline, and ``tangle-marked`` processes only marked headlines.

The ``@root`` directive has three forms. All three forms mean exactly the same
thing::

    @root filename
    @root "filename"
    @root &lt;filename&gt;

If *filename* is an absolute filename the location of the external file is specified only by the filename.
Otherwise, when ``@root`` is given a relative filename, the location of the external file is relative to:

1. the directory specified by ``@path`` directives in parent nodes, or
2. the ``@directory default_tangle_directory`` if no ``@path`` directive is in effect, or
3. the directory in which the .leo file resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules,
or if the filename or directory does not exist.

The scope of a definition is the tree in which the definition is known. By
default, tangle commands look for section definitions only in the suboutline of
the ``@root`` directive being tangled. That is, all sections are assumed to be defined
either in the body text of the node, say with headline *h*, containing the ``@root`` directive,
or in the body texts of the descendants of *h*. The ``@unit`` directive explicitly
indicates the scope of section definitions. When a tangle command encounters the
``@unit`` directive it treats the suboutline containing the ``@unit`` command as the
scope for all enclosed roots. This ensures that the group of roots in the
subtree use the same section definitions.

For example, suppose we have a tree organized as follows with nodes indicated by their body contents::

	+ @unit
		+ @root A
		    sections in A
		+ @root B
		    sections in B

The @unit directive ensures that only sections defined in the unit can affect
files A and B and that all sections definitions in A and B are compatible with
each other.

The tangle commands ignore any node (and its descendants) with a body containing an ``@ignore``
directive.  Use of the ``@ignore`` directive allows trees to contain cloned nodes
or other subsidiary information without causing the tangle commands to issue spurious
error messages.  It also ensures that part of the outline does not contribute a section
definition to another part of the outline by mistake.
</t>
<t tx="sps.20100712151944.7262">The ``untangle``, ``untangle-all``, and ``untangle-marked`` commands are the
reverse of the corresponding tangle commands. They are found in the File-&gt;Untangle
submenu.  They update one or more ``@root`` nodes based on
changes made to the corresponding external files.

For example, suppose you create a new part of the outline and tangle it for the
first time. When you compile the external files you may get
syntax errors.  You could fix those errors in the outline and tangle the
outline again, but you may also fix the errors in the
external files using the compiler's editor, then run the untangle command on the
part of the outline that created the external files. The untangle command uses the sentinels in the external files to update the outline to match the changes in the external files.  The untangle command marks all the nodes in the outline
that it updates, so by doing ``unmark-all`` before the untangle you can review all such nodes with the ``goto-next-marked`` command (menu Outline-&gt;Go To...-&gt;Go To Next Marked).

You cannot use Untangle to update doc parts, since those are not present in
the external file.

Untangle does not change the structure of an outline; it never inserts, deletes or
moves nodes.  Don't attempt to change the structure of an outline by modifying
external files; it won't work.  Also, never delete, move or alter the sentinel
lines in external files written by the tangle command.  Such lines start with the
comment delimiter followed by a section name, and are easily recognizable.

If you change the section name in a sentinel line untangle will not update the
code in the outline (with the old name) that generated the renamed section.
Untangle warns about sections that appear in an external file but not in the
outline.  Untangle has no trouble with changed section references in external
files; it is only changed sentinel lines that cause problems.

Cloned nodes that generate code in several files may cause problems for
untangle.  Untangle will update all cloned nodes each time it is encounters
the code section referenced, so only the code in the last encountered referenced
section will take effect. Therefore, the safe way to update text in cloned
nodes is to make the change in the .leo file rather than the external files.
</t>
<t tx="sps.20100714141211.16549"># run this node with Control-b to discover Leo's current list of languages
for lang in sorted(g.app.language_delims_dict.keys()):
    g.es("    @language %s" % lang)

</t>
<t tx="sps.20100716120121.18081">The following sections are ordered for didactic clarity.
</t>
<t tx="sps.20100716120121.18082"></t>
<t tx="sps.20100716120121.18083">Leo puts special comments into the derived files called *sentinels*.  Their purpose is to guide the untangle process as it incorporates changes made to the external file into the Leo outline.  If a node contains section definitions destined for different files with different languages, you may need to change comment conventions in the midst of a node.  This is now possible by preceding a section definition with an ``@language`` or ``@comment`` directive appropriate to that section's syntax; the new syntax will remain in effect for the remainder of the node and for all descendants until the next ``@language`` or ``@comment`` directive.  For example, one might have a node containing::

    @language java
    &lt;&lt; invoke stored procedure normalize_time_period_limit &gt;&gt;=
    String sql = new StringBuilder()
                 .append("SELECT * FROM ")
                 .append("    normalize_time_period_limit(")
                 .append("        NULL::timestamp with time zone,")
                 .append("        NULL::timestamp with time zone)")
                 .tostring();
    statement.execute(sql);

    @ here's the definition of the stored procedure
    Taken from an example at
    http://www.postgresql.org/docs/8.1/interactive/sql-createfunction.html
    @language plsql
    @comment --_
    &lt;&lt; normalize_time_period_limit &gt;&gt;=
    CREATE OR REPLACE FUNCTION normalize_time_period_limit(
        P_StartTime INOUT timestamp with time zone,
        P_EndTime INOUT timestamp with time zone)
    AS $$
    BEGIN
        P_StartTime = COALESCE(P_StartTime, (timestamp with time zone '1980-01-01 00:00:00.0+00'));
        P_EndTime = COALESCE(P_EndTime, current_timestamp);
    END;
    $$ LANGUAGE PLPGSQL;

In that example, the different section definitions are destined for different files, and each begins and ends with the same comment convention.  Sometimes one needs to mix languages within a single file; for example, here is javascript embedded in html::

    @language html
    &lt;&lt;head&gt;&gt;=
    &lt;head&gt;
        &lt;title&gt;Your Royal Magnificence&lt;/title&gt;
        &lt;script type="text/javascript"&gt;&lt;!--
        &lt;&lt;initialize javascript&gt;&gt;
    &lt;/head&gt;
    @
    End the head definition before starting the
    javascript section with the new comment convention
    @comment //
    &lt;&lt;initialize javascript&gt;&gt;=
        var img = "http://example.com/heraldry.jpg";
    --&gt;&lt;/script&gt;
    @comment &lt;!-- --&gt;

Note that ``@comment`` and ``@language`` take effect in both doc and code parts, and they apply from that point forward to the sentinels of the *defined* section; they **DO NOT** apply to *referenced* sections: referenced sections must be defined under the influence of ``@comment`` or ``@language`` directives appropriate to the context in which they will be referenced.  Note how the javascript section in the example ends with an ``@comment`` that prepares for the transition back to html.

The ``@comment`` and ``@language`` directives do not appear in external files; if untangle is applied to such files, the ``@comment`` and ``@language`` are recovered into potentially modified code sections (doc sections do not change) by placing them as the last line of the code section.  The effect on sentinels is the same regardless of where in the code section the ``@comment`` or ``@language`` directive appear.  An attempt to retain the former position within the code would be ambiguous if the context around the directive changed.  Putting ``@comment`` and ``@language`` directives at the end of the code section will lead to the fewest surprises.  In doc sections, their position may be anything that communicates clearly to the reader.</t>
<t tx="sps.20100716120121.22542">The ``@lineending`` directive sets the line endings for individual external files.
This directive will override the ``@string output_newline`` setting.
The ``@lineending`` *never* affects the line endings in .leo files themselves:
.leo files must have consistent line endings!

The valid forms of the @lineending directive are:

========================   ======================================================
``@lineending nl``         The default, Linux.
------------------------   ------------------------------------------------------
``@lineending cr``         Mac
------------------------   ------------------------------------------------------
``@lineending crlf``       Windows
------------------------   ------------------------------------------------------
``@lineending lf``         Same as 'nl', not recommended
------------------------   ------------------------------------------------------
``@lineending platform``   Same as platform value for output_newline setting.
========================   ======================================================</t>
<t tx="tbrown.20091203211538.14165">Makes \@path nodes "active".

With this plugin running, double clicking on \@path nodes
and their descendents synchronizes the node with the
filesystem.  If the node refers to a fodler (as the top
level \@path node always will), the folder's contents are
loaded as child nodes.  If it refers to a file, the file is
loaded as an @auto node.

For files not previously seen in a folder a new node will appear on top of
the children list (with a mark).

Folders appear in the list as /foldername/.  If you double click on the
icon-box of the folder node, it will have children added to it based on
the contents of the folder on disk.  These folders have the '@path' directive
as the first line of their body text.

When files are deleted from the folder and the list is updated by double
clicking the files will appear in the list as *filename* (or */foldername/*).

You can describe files and directories in the body of the nodes.

You can organize files and directories with organizer nodes, an organizer
node name cannot contain with '/'.

Files and folders can be created by entering a node with the required
name as its headline (must start and/or end with "/" for a folder)
and then double clicking on the node's status-iconbox.

@auto nodes can be set up for existing files can be loaded by
double clicking on the node's status-iconbox.  If you prefer
@shadow or something else use the "active_path_attype" setting,
without the "@".

There are commands on the Plugins active_path submenu:

    - show path - show the current path
    - set absolute path - changes a node "/dirname/" to "@path /absolute/path/to/dirname".
    - purge vanished (recursive) - remove *entries*
    - purge unoaded files (recursive) - remove *entries*
    - update recursive - recursive load of directories, use with caution on large
      file systems

If you want to use an input other than double clicking a node's status-iconbox
set active_path_event to a value like 'iconrclick1' or 'iconclick1'.


active_path is a rewrite of the at_directory plugin to use \@path directives (which influence
@auto and other @file type directives), and to handle sub-folders more automatically.
'''</t>
<t tx="tbrown.20091203211538.20637">  @string active_path_attype = auto
    Change to load file nodes as something other than @auto
  
  @string active_path_event = icondclick1
    The default is probably the most useful event binding here
  
  @data active_path_ignore
    List of regex expressions active_path doesn't list in folders
    
  @data active_path_autoload
    List of regex expressions active_path @auto loads automatically</t>
<t tx="ville.20090520232034.6345">g.app.gui.runScrolledMessageDialog(c=c, msg = u'rst:' + p.b)</t>
<t tx="ville.20090520232138.11304">Qt version of nav_buttons.py (history navigation)</t>
<t tx="ville.20090520232138.11305">This plugin adds a fast-to-use search widget, in the style of "Find in files" feature of many editors.

Just load the plugin, activate "Nav" tab, enter search text and press enter.</t>
<t tx="ville.20090520235245.10337">A plugin that manipulates appearance of individual tree widget items.

This plugin is mostly an example of how to change appearance of headlines - as
such, it does a relatively mundane chore of highlighting @thin, @auto, @shadow
nodes in bold.</t>
<t tx="ville.20090603183524.5672">You can use the @g.command decorator to create new commands. This is an easy-to-use
wrapper for c.k.registerCommand(), with the following advantages over it:

* The new command is automatically created for all Leo controllers (open Leo documents).

* The new command is also automatically available on all new Leo controllers 
  (documents that will be opened in the future).

* Prettier syntax.

Therefore, @g.command can be naturally 
prototyped with execute-script (Ctrl+b) in Leo node.

As an example, you can execute this script to make command hello available::

    @g.command('hello')
    def hello_f(event):
        # use even['c'] to access controller
        c = event['c']
        pos = c.currentPosition()
        g.es('hello from', pos.h)

If you want to create a plugin that only exposes new commands, this is basically all you need in the plugins .py file.
There is no need to hook up for 'after-create-leo-frame' just to make your commands available.

If you want to create a command in object oriented style (so that the commands deal with your own objects), 
create them using closures like this (note how self is available inside command functions)::

    class MyCommands:
        def create(self):        
            @g.command('foo1')
            def foo1_f(event):
               self.foo = 1

            @g.command('foo2')
            def foo2_f(event):
               self.foo = 2

            @g.command('foo-print')
            def foo_print_f(event):
               g.es('foo is', self.foo)

    o = MyCommands()
    o.create()

Note that running create() in this example in `after-create-leo-frame` is pointless - the
newly created commands will override the commands in all previous controllers. You should consider 
this in your plugin design, and create your commands only once per Leo session.</t>
<t tx="ville.20090704073251.9442">Define various useful actions for context menus (for Qt ui)

Examples are:

- Edit in $EDITOR
- Edit @thin node in $EDITOR (remember to do "refresh" after this!)
- Refresh @thin node from disk (e.g. after editing it in external editor)
- Go to clone

Here's an example on how to implement your own context menu items 
in your plugins::

    def nextclone_rclick(c,p, menu):
        """ Go to next clone """

        # only show the item if you are on a clone
        # this is what makes this "context sensitive"
        if not p.isCloned():
            return    

        def nextclone_rclick_cb():
            c.goToNextClone()

        # 'menu' is a QMenu instance that was created by Leo 
        # in response to right click on tree item

        action = menu.addAction("Go to clone")
        action.connect(action, QtCore.SIGNAL("triggered()"), nextclone_rclick_cb)

And call this in your plugin *once*::

    g.tree_popup_handlers.append(nextclone_rclick)    </t>
<t tx="ville.20090705224948.5734">import os
pos = c.find_h("Users Guide")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
# no pdf manual creation, perhaps too "involved" for many</t>
<t tx="ville.20090705225609.5736">mandir = g.app.leoDir + "/doc/html"
g.es(mandir)
os.chdir(mandir)
os.system('make html')</t>
<t tx="ville.20090705225609.5738"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = g.app.leoDir + "/doc/html"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
os.system('make all-pdf')
</t>
<t tx="vivainio.20080302174639.1">ILeo, or leo-ipython bridge, creates a two-way communication channel between Leo
and IPython. The level of integration is much deeper than conventional
integration in IDEs; most notably, you are able to store and manipulate **data**
in Leo nodes, in addition to mere program code - essentially making ILeo a
hierarchical spreadsheet, albeit with non-grid view of the data. The
possibilities of this are endless, and the approach can be applied in wide range
of problem domains with very little actual coding.

IPython users are accustomed to using things like %edit to produce non-trivial
functions/classes (i.e. something that they don't want to enter directly on the
interactive prompt, but creating a proper script/module involves too much
overhead). In ILeo, this task consists just going to the Leo window, creating a node
and writing the code there, and pressing alt+I (push-to-ipython).

Obviously, you can save the Leo document as usual - this is a great advantage
of ILeo over using %edit, you can save your experimental scripts all at one
time, without having to organize them into script/module files (before you
really want to, of course!)
</t>
<t tx="vivainio.20080302174639.2">You need at least Leo 4.4.8, and IPython 0.8.3

The ILeo concept is still being developed actively, so if you want to get access
to latest features you can get IPython from Launchpad by installing bzr and
doing::

    bzr branch lp:ipython
    cd ipython
    python setupegg.py develop

You need to enable the 'ipython.py' plugin in Leo: 

- Help -&gt; Open LeoSettings.leo

- Edit @settings--&gt;Plugins--&gt;@enabled-plugins, add/uncomment 'ipython.py'

- Alternatively, you can add @settings--&gt;@enabled-plugins with body ipython.py to your leo document.

- Restart Leo. Be sure that you have the console window open
  (`run Leo in a console window`_, or double-click leo.py on windows)

- When using the Qt ui, add --ipython argument to command line (e.g. launchLeo.py --ipython).

- Press alt+shift+i OR alt-x start-ipython to launch IPython in the console that
  started leo. You can start entering IPython commands normally, and Leo will keep
  running at the same time.

- Note that you can just press alt-I (push-to-ipython) - it will start IPython
  if it has not been previously started. However, when you open a new leo
  document, you have to execute start-ipython (alt+shift+I) again to tell
  IPython that the new commands should target the new document. IPython session
  will not be restarted, only the leo commander object is updated in the
  existing session.

- If you want to specify command line arguments to IPython (e.g. to choose a
  profile, or to start in 'pylab' mode), add this to your @settings:
  '@string ipython_argv = ipython -pylab' (where -pylab is the command line argument)</t>
<t tx="vivainio.20080302174639.3">IPython code
------------

Just enter IPython commands on a Leo node and press alt-I to execute
push-to-ipython in order to execute the script in IPython. 'commands' is
interpreted loosely here - you can enter function and class definitions, in
addition to the things you would usually enter at IPython prompt - calculations,
system commands etc.

Everything that would be legal to enter on IPython prompt is legal to execute
from ILeo.

Results will be shows in Leo log window for convenience, in addition to the console.

Suppose that a node had the following contents::

    1+2
    print "hello"
    3+4

    def f(x):
        return x.upper()

    f('hello world')

If you press alt+I on that node, you will see the following in Leo log window (IPython tab)::

    In: 1+2
    &lt;2&gt; 3
    In: 3+4
    &lt;4&gt; 7
    In: f('hello world')
    &lt;6&gt; 'HELLO WORLD'

(numbers like &lt;6&gt; mean IPython output history indices; the actual object can be
referenced with _6 as usual in IPython).


Plain Python code
-----------------

If the headline of the node ends with capital P, alt-I will not run the code
through IPython translation mechanism but use the direct python 'exec' statement
(in IPython user namespace) to execute the code. It wont be shown in IPython
history, and sometimes it is safer (and more efficient) to execute things as
plain Python statements. Large class definitions are good candidates for P
nodes.
</t>
<t tx="vivainio.20080302174639.4">The real fun starts when you start entering text to leo nodes, and are using
that as data (input/output) for your IPython work.

Accessing Leo nodes happens through the variable **wb** (short for "WorkBook")
that exist in the IPython user namespace. Nodes that are directly accessible are
the ones that have simple names which could also be Python variable names;
'foo_1' will be accessible directly from IPython, whereas 'my scripts' will not.
If you want to access a node with arbitrary headline, add a child node '@a foo'
(@a stands for 'anchor'). Then, the parent of '@a foo' is accessible through
'wb.foo'.

You can see what nodes are accessible be entering (in IPython) wb.&lt;TAB&gt;. Example::

    [C:leo/core]|12&gt; wb.
    wb.b           wb.tempfile    wb.rfile       wb.NewHeadline
    wb.bar         wb.Docs        wb.strlist     wb.csvr    
    [C:leo/core]|12&gt; wb.tempfile
                &lt;12&gt; &lt;ipy_leo.LeoNode object at 0x044B6D90&gt;

So here, we meet the 'LeoNode' class that is your key to manipulating Leo
content from IPython!

LeoNode
-------

Suppose that we had a node with headline 'spam' and body::

    ['12',2222+32]

we can access it from IPython (or from scripts entered into other Leo nodes!) by doing::

    C:leo/core]|19&gt; wb.spam.v
               &lt;19&gt; ['12', 2254]

'v' attribute stands for 'value', which means the node contents will be run
through 'eval' and everything you would be able to enter into IPython prompt
will be converted to objects. This mechanism can be extended far beyond direct
evaluation (see '@cl definitions').

'v' attribute also has a setter, i.e. you can do::

    wb.spam.v = "mystring"

Which will result in the node 'spam' having the following text::

    'mystring'

What assignment to 'v' does can be configured through generic functions
('simplegeneric' module, see ipy_leo.py for examples).

Besides v, you can set the body text directly through::

    wb.spam.b = "some\nstring", 

headline by::

    wb.spam.h = 'new_headline' 

(obviously you must access the node through wb.new_headline from that point
onwards), and access the contents as string list (IPython SList) through
'wb.spam.l'.

If you do 'wb.foo.v = 12' when node named 'foo' does not exist, the node titled
'foo' will be automatically created and assigned body 12.

LeoNode also supports go() that focuses the node in the Leo window, and ipush()
that simulates pressing alt+I on the node (beware of the possible recursion!).

You can access unknownAttributes by .uA property dictionary. Unknown attributes
allow you to store arbitrary (pickleable) python objects in the Leo nodes; the
attributes are stored when you save the .leo document, and recreated when you
open the document again. The attributes are not visible anywhere, but can be
used for domain-specific metadata. Example::

    [C:leo/core]|12&gt; wb.spam.uA['coords'] = (12,222)
    [C:leo/core]|13&gt; wb.spam.uA
                &lt;13&gt; {'coords': (12, 222)}    

Accessing children with iteration and dict notation
---------------------------------------------------

Sometimes, you may want to treat a node as a 'database', where the nodes
children represent elements in the database. You can create a new child node for
node 'spam', with headline 'foo bar' like this::

    wb.spam['foo bar'] = "Hello"

And assign a new value for it by doing::

    wb.spam['foo bar'].v = "Hello again"

Note how you can't use .v when you first create the node - i.e. the node needs
to be initialized by simple assignment, that will be interpreted as assignment
to '.v'. This is a conscious design choice.

If you try to do wb.spam['bar'] = 'Hello', ILeo will assign '@k bar' as the
headline for the child instead, because 'bar' is a legal python name (and as
such would be incorporated in the workbook namespace). This is done to avoid
crowding the workbook namespace with extraneous items. The item will still be
accessible as wb.spam['bar']

LeoNodes are iterable, so to see the headlines of all the children of 'spam' do::

    for n in wb.spam:
        print n.h
</t>
<t tx="vivainio.20080302174639.5">If the first line in the body text is of the form '@cl sometext', IPython will
evaluate 'sometext' and call the result with the rest of the body when you do
'wb.foo.v' or press alt+I on the node. An example is in place here. Suppose that we have defined a class (I
use the term class in a non-python sense here)::

    def rfile(body,node):
        """ @cl rfile 

        produces a StringIO (file like obj) of the rest of the body """

        import StringIO
        return StringIO.StringIO(body)

(note that node is ignored here - but it could be used to access headline,
children etc.),

Now, let's say you have node 'spam' with text::

    @cl rfile
    hello
    world
    and whatever

Now, in IPython, we can do this::

    [C:leo/core]|22&gt; f = wb.spam.v
    [C:leo/core]|23&gt; f
                &lt;23&gt; &lt;StringIO.StringIO instance at 0x04E7E490&gt;
    [C:leo/core]|24&gt; f.readline()
                &lt;24&gt; u'hello\n'
    [C:leo/core]|25&gt; f.readline()
                &lt;25&gt; u'world\n'
    [C:leo/core]|26&gt; f.readline()
                &lt;26&gt; u'and whatever'
    [C:leo/core]|27&gt; f.readline()
                &lt;27&gt; u''    

You should declare new @cl types to make ILeo as convenient your problem domain
as possible. For example, a "@cl etree" could return the elementtree object for
xml content.

In the preceding examples, the return value matter. That, of course, is optional.
You can just use the @cl node as a convenient syntax for "run this body text through 
a function". 

Consider this example::

    def remote(body, node):
        out = sshdo(body)
        c = node.append()
        c.b = "@nocolor\n" + out
        c.h = "Command output"

(sshdo(s) is a just a trivial function implemented using paramiko, that
returns the output from command run over ssh on remote host).

After running the above node (by, say, wb.require('remote_impl') if the function is 
declared in a node named 'remote_impl'), you can create nodes that have various 
little sysadmin tasks (grep the logs, gather data, kick out all the users) like this::

    @cl remote
    cd /var/log
    ls -l
    echo " --- temp ---"
    cd /var/tmp
    ls -l

Press alt+I on the node to run it. The output will be written to
"Command output" child node.</t>
<t tx="vivainio.20080302174639.6">@ipy-startup
------------

If this node exist, the *direct children* of this will be pushed to IPython when
ILeo is started (you press alt+shift-i). Use it to push your own @cl
definitions, import the modules you will be using elsewhere in the document, etc.

The contents of of the node itself will be ignored.


@ipy-results
------------

If you press alt+I on a node that has @cl, it will be evaluated and the result
will be put into this node. Otherwise, it will just be displayed in log tab.

@ipy-root
---------

You can set up a subportion of the leo document as a "sandbox" for your IPython
work. Only the nodes under @ipy-root will be visible through the 'wb' variable.

Also, when you create a new node (wb.foo.v = 'stuff'), the node foo will be created as
a child of this node. 

@a nodes
--------

You can attach these as children of existing nodes to provide a way to access
nodes with arbitrary headlines, or to provide aliases to other nodes. If
multiple @a nodes are attached as children of a node, all the names can be used
to access the same object.
</t>
<t tx="vivainio.20080302174639.7">Sometimes, you might want to configure what alt+I on a node does. You can do
that by creating your own push function and expose it using
ipy_leo.expose_ileo_push(f, priority). The function should check whether the
node should by handled by the function and raise IPython.ipapi.TryNext if it
will not do the handling, giving the next function in the chain a chance to see
whether it should handle the push.

This example would print an uppercase version of node body if the node headline ends
with U (yes, this is completely useless!)::

    def push_upcase(node):
        if not node.h.endswith('U'):
            raise TryNext
        print node.b.upper()

    ipy_leo.expose_ileo_push(push_upcase, 12)

(the priority should be between 0-100, with 0 being the highest (first one to
try) - typically, you don't need to care about it and can usually omit the
argument altogether)
</t>
<t tx="vivainio.20080302174639.8">Get list of all headlines of all the nodes in leo::

    [node.h for node in wb]

Create node with headline 'baz', empty body::

    wb.baz

Create 10 child nodes for baz, where i is headline and 'Hello ' + i is body::

    for i in range(10):
        wb.baz[i] = 'Hello %d' % i

Create 5 child nodes for the current node (note the use of special _p variable,
which means "current node") and moves focus to node number 5::

    for i in range(10):
        _p[i] = 'hello %d' % d
    _p[5].go()

Sort contents of a node in alphabetical order (after pushing this to
IPython, you can sort a node 'foo' in-place by doing sort_node(wb.foo))::

    def sort_node(n):
        lines = n.l
        lines.sort()
        n.l = lines
</t>
<t tx="vivainio.20080302174639.9">This idea got started when I (Ville M. Vainio) saw this post by Edward Ream (the author of
Leo) on IPython developer mailing list:

    http://lists.ipython.scipy.org/pipermail/ipython-dev/2008-January/003551.html

I was using FreeMind as mind mapping software, and so I had an immediate use
case for Leo (which, incidentally, is superior to FreeMind as mind mapper). The
wheels started rolling, I got obsessed with the power of this concept
(everything clicked together), and Edwards excitement paralleled mine.
Everything was mind-bogglingly easy/trivial, something that is typical of all
promising technologies.

Discussions_ on SourceForge show how the goal of close cooperation between Leo and IPython went from
vague dream to completed reality over the span of about 10 days.

</t>
<t tx="vivainio.20080302174957"></t>
<t tx="vivainio.20080302194307">%mb
---

Execute leo minibuffer command. Tab completion works. Example::

    mb open-outline

%lee
----

Stands for "LEo Edit". Allows you to open file(s), and even objects in Leo for editing. Examples::

    lee *.txt

Opens all txt files in @auto nodes

::

    lee MyMacro

Opens the macro MyMacro for editing. Press alt-I to push the edited macro back to IPython.

::

  s = 'hello word'
  lee s

Opens the variable s for editing. Press alt+I to push the new value to IPython.

::

    lee hist   

Opens IPython interactive history (both input and output) in Leo.
</t>
<t tx="vivainio.20080318125834.2">If you install matplotlib and numpy, you can use ILeo to interactively edit and
view your data. This is convenient for storing potentially valuable information
in Leo document, and yields an interactive system that is comparable in
convenience to various commercial mathematical packages (at least if you compare
it agains plain IPython, that forgets the data on exit unless explicitly saved
to data files or %store:d).

Startup
-------

It's probably safest to rely on TkAgg backend, to avoid two event loops running
in the same process. TkAgg is the default, so the only thing you need to do is
to install numpy and matplotlib::

    easy_install numpy
    easy_install matplotlib

Finally, you need to start up IPython with '-pylab' option. You can accomplish
this by having the following under some @settings node::

    @string ipython_argv = ipython -pylab

Then, you just need to press alt+I to launch IPython.

Usage
-----

The simplest use case is probably pushing an existing array to Leo for editing.
Let's generate a simple array and edit it::

    [c:/ipython]|51&gt; a = arange(12).reshape(3,4)
    [c:/ipython]|52&gt; a
    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])
    [c:/ipython]|53&gt; %lee a

This (the magic command %lee, or 'leo edit') will open variable 'a' for editing
in Leo, in a convenient pretty-printed format. You can press alt+I on the node
to push it back to IPython.

If you want to store the variable in a node with a different name (myarr), you can do::

    [c:/ipython]|54&gt; wb.myarr.v = a

Then, you can always get the value of this array with wb.myarr.v. E.g. you could
have a node that plots the array, with content::

    # press alt+i here to plot testarr

    plot(wb.myarr.v)

And, as per instructions, pressing alt+I will launch a new Tk window with the
plotted representation of the array!</t>
<t tx="vivainio.20080401152121.2">Sometimes you may decide to launch Leo when an IPython session is already
running. This is typically the case when IPython is launched from/as another
application (Turbogears/Django shell, Sage, etc.), or you only decide later on
that you might want to roll up some scripts or edit your variables in Leo.

Luckily, this is quite easy, if not automatic (yet) using IPython's %run command
that runs python code in the IPython process. The only special consideration is
that we need to run IPython.Shell.hijack_tk() to prevent Leo Tk mainloop from
blocking IPython in %run. Here we launch an embedded Leo instance, and create a
macro 'embleo' for later use (so that we don't have to repeat these steps)::

    IPython 0.8.3.bzr.r57   [on Py 2.5.1]
    [C:opt/Console2]|2&gt; import IPython.Shell
    [C:opt/Console2]|3&gt; IPython.Shell.hijack_tk()
    [C:opt/Console2]|4&gt; cd c:/leo.repo/trunk
    [c:leo/leo.repo/trunk]|5&gt; %run launchLeo.py

    reading settings in C:\leo\leo\config\leoSettings.leo

    ... Leo is starting at this point, but IPython prompt returns ...

    [c:leo/leo.repo/trunk]|6&gt; macro embleo 2-5

    [c:leo/leo.repo/trunk]|7&gt; store embleo
    Stored 'embleo' (Macro)

Now, in Leo, you only need to press Alt+Shift+I (launch-ipython) to actually
make the document visible in IPython. Despite the name, launch-ipython will not
create a new instance of IPython; if an IPython session already exists, it will
be automatically used by ILeo.</t>
<t tx="vivainio.20080409164902.1">Many users will want to track the development version of Leo, in order to stay
on top of the latest features and bugfixes. Running the development version is
quite safe and easy, and it's also a requirement if you want to contribute to
Leo.

1. First, you need to get Bazaar (bzr) from http://bazaar-vcs.org. For windows
   users we recommend the standalone installer - the python installer may have
   problems pushing to Launchpad. Plain bzr installer only contains the command
   line version, so you might want to augment that with a friendly GUI - qbzr is
   recommended as it's the easiest one to install. It provides command like
   bzr qlog, bzr qannotate etc.

2. Get Leo from launchpad by doing::

     bzr branch lp:leo-editor

And that's it! You can run leo/core/leo.py directly. When you want to refresh the
code with latest modifications from Launchpad, run bzr pull.

If you make modifications to Leo (with the interest in sharing them with the Leo
community), you can check them in to your local branch by doing bzr checkin.
Now, to actually request your changes to be merged to Leo trunk, you need a
Launchpad account with RSA keys in place. There is showmedo video about how to
accomplish this in Windows using puttygen and pageant at
http://showmedo.com/videos/video?name=1510070&amp;fromSeriesID=151.

After your Launchpad account is set up, go to
https://launchpad.net/leo-editor, choose "Code" tab -&gt; Register Branch,
select Branch type "Hosted" and fill in descriptive details about the branch.
After that, go to the branch home page from Code tab again, and copy-paste the
push command line to terminal. For example, for branch::

    https://code.launchpad.net/~leo-editor-team/leo-editor/mod_rclick

The push command is::

    bzr push bzr+ssh://my_name@bazaar.launchpad.net/~leo-editor-team/leo-editor/mod_rclick    

You may wish to add --remember command line option to bzr push, to direct all
future pushes to that location. Then, you only need to execute bzr push.

After your branch is pushed, you can email the Leo mailing list and request it
to be reviewed and merged to trunk.</t>
</tnodes>
</leo_file>
