.. @+leo-ver=5-thin
.. @+node:ekr.20100805165051.7176: * @file other_docs.txt
.. @@language rest
.. @@tabwidth -4
.. @+all
.. @+node:ekr.20090711120622.10446: ** Screen shots page
@language rest
.. @+node:ekr.20090711120622.10447: *3* @rst html/screen-shots.html
################
Leo screen shots
################

.. @+node:ekr.20090811090022.14452: *4* Windows screen shots
.. |leoQtMainWindow|    image:: screen-shots/leo-main-window.png

Here is Leo's main window on Windows 7 showing
the outline pane (1),
the body pane (2),
the minibuffer (3),
the log pane, showing the find tab (4).

The body pane shows the contents of the presently selected node in the outline pane.

|leoQtMainWindow|

.. _`reStructuredText`: http://docutils.sourceforge.net/rst.html

.. |renderRST|      image:: screen-shots/render-rst.png
.. |renderSVGref|   image:: screen-shots/render-svg-movie.png
.. |renderSVGsrc|   image:: screen-shots/render-svg-sources.png
.. |renderSplash|   image:: screen-shots/render-splash-screen.png

The following screenshots show Leo's rendering pane.  It can render `reStructuredText`_:

|renderRST|

The rendering pane can render svg pictures, including animated pictures.  Here we see
an .svg file included by reference:

|renderSVGref|

The rendering pane can also render svg sources contained in the body pane:

|renderSVGsrc|

The rendering pane can show pictures, music and movies.  Here we see Leo's splash screen:

|renderSplash|
.. @+node:ekr.20090811090022.14453: *4* Linux screen shots
.. |LinuxMainWindow| image:: screen-shots/leo-qt-main-window-linux.png

Here is Leo's main window as it appears on Linux:

|LinuxMainWindow|
.. @+node:ekr.20090526102407.10028: ** Important notes about Leo's code
.. @+node:ekr.20090526102407.10029: *3* How to profile Leo
To gather statistics, do the following in a console window, not idle::

    > python
    >>> import leo
    >>> import leo.core.runLeo as r
    >>> r.prof()  (this runs leo)
    load any .leo file from Leo
    quit Leo

Intermediate data is written to cwd.leoProfile.txt.
The statistics are written to stdout.
.. @+node:ekr.20090526102407.10030: *3* High-level code notes
I've often said that I don't remember many details about Leo. This documentation
describes what I *do* remember about Leo's various modules. I hope this will be
useful to potential readers, users and modifiers of Leo's code.

In general, if you want to understand the code, read through it quickly, looking
for pieces of code that are unexpected complex, or unexpectedly simple. Forget
the details; remember the shape. Once you have the general shape in mind, you
are ready to modify the code. No kidding. Besides, more reading won't help :-)
.. @+node:ekr.20090526102407.10031: *4* leoFileCommands.py and leoAtFile.py
In general, write code is much simpler than read code,
because reading requires parsing. There are a few exceptions below.

leoFileCommands.py contains the code that reads and writes .leo files.

- This file uses the sax parser to parse the xml in .leo files.
- Complex code, driven by sax, turns sax nodes into Leo nodes.
- The putVnode method is "interesting".  Take a look.
  In the past, there have been significant, surprising bottlenecks in
  putVnode and maybe putTnode as well.  No longer.

leoAtFileCommands.py contains the code that reads and writes external files.

- There are options to read and write strings.
  These are useful for performance and for unit testing.
- atFile.replaceTargetFileIfDifferent is an important optimization.
- There are a lot of read/write commands for external files,
  and this results in lots of options being passed around.

Initing is tricky for both leoFileCommands.py and leoAtFileCommands.py.

- The bizarre call to initReadIvars() at the end of getLeoFile is one
  symptom of the difficulties.
- Never change init code without careful thought and unit testing.
.. @+node:ekr.20090526102407.10032: *4* Leo's MVC architecture
I. Background

Leo has had a robust MVC (Model,View,Controller) architecture from day one.

Leo's model are the classes in leoNodes.py. They are completely independent from
the rest of Leo. Many parts of Leo *use* these classes, but not vice versa!

Leo's controller is everything else in 'Code-->Core classes'. This code has *no*
direct dependencies on Leo's gui code, as will be explained next.

Leo's view has two parts:

1. The classes in the tree 'Code-->Gui Base classes'.
   These are part of Leo's core.

2. The classes in Leo's Qt gui, in qtGui.py.

Leo's core consists of the Model, Controller and the gui base classes.

II. Why Leo's core is gui-independent

Leo uses a completely standard way of separating gui-dependent code from
gui-independent code. Base gui classes (part 1 of the view) define an interface
used by Leo's core. Subclasses (part 2 of the view) implement the interface for
a particular gui.

** Subclasses can change without affecting Leo's code in any way.**

The essential design rule is: if gui-related code can be made gui- independent,
it should be part of a base class. Otherwise it must be part of a subclass of a
base gui class.

The gui base classes are far more than do-nothing interfaces. Examples of
complex code that reside in base classes:

A. tree.select. I am proud that this method is gui-independent. Switching nodes
is a very tricky business. Making it gui-independent is a big win.

B. leoFind.py. Finds the next/previous matches, and dealing with an "idealized"
find tab. Adapter classes exist in leoEditCommands.py.

C. Autocompletion and minibuffer code in leoKeys.py.

D. A generalized, gui-independent interface to Leo's body pane. The commands in
leoEditCommands.py (part of the controller) use this interface (baseTextWidget)
rather than using gui widgets directly.

**If you want to understand Leo's design, study Leo's base gui classes.**
.. @+node:ekr.20090401113141.1: ** How to generate odt/rtf/pdf files
To generate .odt or .rtf or .pdf files, you create an intermediate file and
ignore the the "official" output file, in this case test.html. The intermediate
file contains the rST text corresponding to the @rst tree.

To tell the rst3 plugin to generate an intermediate file, do::

    write_intermediate_file = True

After you create the intermediate file, in this case, test.html.txt,
You can create an odt file as follows::

    python <path-to-python>/scripts/rst2odt.py test.html.txt test.odt

I a batch file, rst2odt.bat, like this:

    rst2odt test

Note that rst3odt.py is in the tools directory of the DocUtils distribution.

To generate .rtf, you can use PanDoc to convert test.html.txt to RTF.

To generate .pdf files, you would first convert test.html.txt to LaTeX::

    python rst2newlatex.py test.html.txt test.tex

    -- OR --

    cd leo\docs\html
    make latex

You can then use one of the LaTeX to .pdf converters to create the final .pdf
file. See http://docutils.sourceforge.net/docs/user/latex.html#pdf-generation
for details.
.. @+node:ekr.20090620131445.5595: *3* Post from ville
I just tweaked conf.py a bit to enable pdf generation.

Howto:

QQQ

4. To create pdf (probably easiest on Linux, with necessary latex
packages installed):

- make latex
- cd _build/latex
- make all-pdf

QQQ

There were several errors in the pdf generation process. Notably,
there are probably lots of unicode errors (and toc doesn't appear).
Nevertheless, you can steal a peek at the doc here:

http://vvtools.googlecode.com/files/Leodocumentation.pdf 
.. @+node:ekr.20090401113141.2: *3* @rst c:\prog\test\test.html
@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

====
Test
====

This is a test.
.. @+node:ekr.20090401113141.4: *4* section 1
This is section 1
.. @+node:ekr.20091107093823.6790: ** Leo Tech report
This is the rST version of the Tech Report handed out at EuroPython in 2005.

**Important**: Leo's tutorial is now a clearer explanation of the basics.
This tech report should be rewritten.

@nocolor
@tabwidth -4
.. @+node:ekr.20091107093823.6791: *3* @rst html\techReport.html
@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

##########################################
The Essentials of Leo
##########################################

.. contents::
.. @+node:ekr.20091107093823.6792: *4* Old
.. @+node:ekr.20091107093823.6793: *5* Leo’s window, outlines & clones
Leo organizes all data into nodes containing a **headline**, an expandable page of
**body text** and a (possibly empty) subtree of **descendant nodes**. The **contents** of a
node are its headline and body text. Leo’s main window contains an **outline** pane
at the top left, a **log pane** at the top right, and a **body pane** at the bottom. The
outline pane shows headlines; the body pane shows the body text of the selected
headline. The log pane displays messages from Leo.

Small red arrows mark **cloned nodes** (clones). Clones share the same content and
descendants. All clones of the same node are equivalent, so changing the
contents of one node (call it node N) changes the contents of all clones of N.
Furthermore, inserting, deleting or changing any descendant of node N causes the
corresponding insertion, deletion or change in all other clones of N.
.. @+node:ekr.20091107093823.6794: *5* Relations: organizer nodes, views, tasks and metadata
Clones allow you to organize data in multiple ways within the same outline. You
do not have to choose a single ‘correct’ organization: you can organize your
data in as many ways as you like.

You can use **organizer nodes** to create explicit relations (relationships) among
the data in your outline. The headline of the organizer node is the
relationship’s name. Now make clones of nodes from other parts of the outline
that participate in the relation. Drag the newly created clones so they become
children of the organizer node. You may want to create other (non-cloned)
children of the organizer node that contain data found nowhere else in the
outline. Voilà: you have just created the set of all nodes that pertain to the
relationship. The organizer node is the relation; the terms relation,
relationship and organizer node are interchangeable.

Three kinds of relations deserve special mention. A **view** is a relation (an
organizer node) containing all nodes related to a desired view (or slice) of the
data in the outline. Similarly, a **task** is an organizer node containing all nodes
related to a task. Relations are not limited to tasks or views: the notion of
relationship is completely general. Headlines naturally describe the data in
body text. That is, nodes relate **metadata** (descriptions of data) to data.
Separating data from metadata is useful for humans. It is even more valuable for
scripts: scripts can access data and metadata without complex parsing.
.. @+node:ekr.20091107093823.6795: *5* Plugins
Plugins are Python (.py) files contained in Leo’s plugins folder. Users can
write plugins to change how Leo works and to add new features without changing
Leo’s core code. We’ll discuss plugins in more detail later.
.. @+node:ekr.20091107093823.6796: *5* Derived files and special nodes
Leo can generate many external files called **derived files** from an outline. Leo
outlines can organize files throughout your computer’s file system. Nodes whose
headlines start with ‘@’ are special nodes. Several **special nodes** indicate the
root of a tree that generates a derived file::

    @asis filename    Creates a derived file. Ignores all markup in body text.
    @file filename    Creates a derived file. External files contain all outline structure.
    @nosent filename  Creates a derived file without sentinels.

Leo recognizes several other special nodes::

    @settings   Defines settings local to the .leo file.
    @url url    Double-clicking the node’s icon opens the url in Leo or in a browser.

The scripting plugin scans for the following nodes when opening an outline::

    @button         Creates a button in the **icon area** at the top of the Leo window.
    @plugin plugin  Enables a plugin if the plugin has not already been enabled.
    @script         Executes a script when opening the outline. This is a security risk: it is disabled by default.

Plugins, @button nodes and @script nodes can create other kinds of special nodes::

    @suite       Creates a suite of unit tests from script in body. Requires scripting plugin.
    @test        Creates a unit text from script in body. Requires scripting plugin.
    @rst         Outputs a tree containing markup for reStructuredText. Requires rst2 plugin.
    @run command Double clicking the node’s icon executes the command.  Requires run_nodes plugin.
.. @+node:ekr.20091107093823.6797: *5* Markup for scripts
Leo’s Execute Script command **preprocesses** the script to be executed by scanning
a node N and its descendants looking for markup. **Markup** is special syntax that
controls this preprocessing. If node N contains no markup, the resulting script
is just N’s body text. Otherwise, the preprocessed script will include text from
descendant nodes as described below. The main kinds of markup are **section
references**, **directives** and **doc parts**.

1.  **Section references** have the form::

        <<section name>>

    The << and >> must appear on the same line. Conversely, any line
    containing << and >> is a section reference, regardless of context. However,
    section references are not recognized in doc parts. Any characters may appear
    between << and >>.

    Section references are functional pseudo-code: while preprocessing a script, Leo
    replaces section references by the actual text of the section’s definition.
    Sections are defined in **section definition nodes**, whose headlines start with a
    section reference and whose body text defines the section. Each section
    definition node must descend from the node containing the section reference.

2.  **Directives** start with ‘@’ in the leftmost column of body text. Directives
    specify options and control Leo’s operation. The @others directive is the
    minimal markup needed to organize scripts. @others tells Leo to insert the
    preprocessed text of all descendant nodes (except section definition nodes) at
    the spot at which the @others directive occurs. Nodes are inserted in **outline
    order**, the order in which nodes appear in the outline. **Important**: Leo adds the
    whitespace preceding the @others directive to the indentation of all
    preprocessed text.

    Using @others is more convenient than using section references. Use @others when
    the order of included text does not matter::

        class myClass:
	        @others # Include the methods of the class. Order doesn’t matter.

    Use section references when the order of included text does matter. In the following script, for example,
    << imports >> ensures that imports come first. The @others directive then includes the body text of all other
    descendant nodes::

        @language python
        << imports>>
        @others # Define classes & functions in child nodes.
        main()

    Here is a list of all of Leo’s standard directives::

        @whitespace (or @doc)   Starts a doc part & ends code part.
        @all                    Like @others, but includes all descendant nodes.
        @c, @code               Starts a code part and ends a doc part.
        @color                  Enables syntax coloring.
        @delims                 Temporarily changes comment delims.
        @nocolor, @killcolor    Disables syntax coloring.
        @comment                Sets comment delimiters in external (derived) files.
        @language languagename  Sets language for syntax coloring and comments.
        @lineending lineending  Sets ending of lines in derived files.
        @others                 Inserts body text of all descendants except definition nodes. 
        @pagewidth n            Sets page width for justifying comments in doc parts.
        @path path              Sets prefix to use in relative file names in @file nodes, etc.
        @raw, @end_raw          Inhibits sections references in a range of text. (@file only.)
        @tabwidth n             Sets width of tabs (negative widths convert tabs to spaces.)
        @wrap, @nowrap          Controls wrapping of text in body pane.

3.  Doc parts start with the ‘@’ directive and continue until the end of the body text or until the ‘@c’ directive.
    Body text not in a doc part is in a code part. Here is an example of a doc part::

        @ This is a doc part. Doc parts may span many lines. Leo converts doc parts to comments.
        Leo reformats the doc part by justifying lines so they are no longer than the page width.
        @c

    Leo reformats doc parts by justifying the text into comment lines.
    The @pagewidth directive controls the length of these comment lines.
    The @language and @comment directives specify the comment delimiters used in doc parts.
.. @+node:ekr.20091107093823.6798: *5* Scripting Leo
The Execute Script command preprocesses the selected text of the presently
selected outline node, or the entire text of the node if there is no selected
text. See the section called Markup for Scripts for a discussion of how Leo
preprocesses scripts. That section also discusses how Leo organizes scripts
using outlines. Conversely, scripts can use outlines to organize their data. To
write such scripts you must understand at least the basics of Leo’s modules and
classes...
.. @+node:ekr.20091107093823.6799: *5* Leo’s modules and classes
Leo’s source code is organized as a collection of modules. The following
paragraphs describe five of the most important modules. See LeoPy.leo (Leo’s
full source code) for more details: scripts have full access to all of Leo’s
classes and data.

1.  The **leoGlobals** module contains utility functions.
    By convention, in Leo’s code g is always the leoGlobals module.

2.  The **leoApp** module defines a class representing the entire Leo application.
    **g.app** is the singleton object of this class: the application object.
    The instance variables (ivars) of the application object are Leo’s global variables.

3.  The leoCommands module defines the Commands class.
    A commander is an instance of this class.
    Commanders contain the operations that can be performed on a particular outline.
    Each open Leo outline has its own commander.
    By convention, in Leo’s code **c** is always a commander.

4.  The leoFrame module defines the base leoFrame class for objects that create and manage
    the visual appearance of Leo’s windows and panes.
    qtGui.py contains subclasses of the base classes in the leoFrame module.
    A frame (an instance of the leoFrame class, or a subclass)
    contains all the internal data needed to manage a Leo window.
    **c.frame** is the frame associated with commander c.
    If **f** is a frame, **f.c** is the frame’s commander, **f.body** is the frame’s body pane,
    **f.tree** is the frame’s outline pane, and **f.log** is the frame’s log pane.

5.  The leoNodes module defines several classes that implement Leo’s fundamental data structures.
    These classes are complex.
    Happily, scripts can and should ignore these complications by accessing nodes using
    high-level methods of the position class.

A **position** (an instance of the position class) is the state of some traversal of an outline. Equivalently, a position is a particular visual place in an outline. Cloned nodes may appear many times in an outline. Non-cloned nodes may also appear in many places: consider a non-cloned descendant of a cloned node. By convention, in Leo’s source code p is a position.
.. @+node:ekr.20091107093823.6800: *5* Predefined symbols in scripts
When executing scripts Leo predefines the following three symbols:
**c** is the commander of the outline in which the script is defined,
**g** is the leoGlobals module and
**p** is the position of the selected node in c’s outline, i.e., c.currentPosition().
.. @+node:ekr.20091107093823.6801: *5* Accessing data
Scripts should get and set data using high-level access methods. Here are some important getters::

    g.app                The application object. Its ivars are Leo’s global variables.
    g.app.windowList     The list of all open frames.
    c.currentPosition()  The position of the selected node.
    c.rootPosition()     The position of the first node in the outline.
    p.headString()       The headline of position p.
    p.bodyString()       The body text of position p.
    p.childIndex()       The number of siblings that precede p.
    p.numberOfChildren() The number of p’s children.
    p.level()            The number of p’s ancestors.
    p.hasChildren()      True if p has children.
    p.isAncestorOf(p2)   True if p2 is a child, grandchild, etc. of p.
    p.isCloned()         True if p is a clone.
    p.isDirty()          True if p’s contents have been changed.
    p.isExpanded()       True if p has children and p’s outline is expanded.
    p.isMarked()         True if p’s headline is marked.
    p.isVisible()        True if all of p’s ancestors are expanded.

And here are some important setters::

    p.setBodyStringOrPane(s) Set body text of p to s.
    p.setHeadString(s)       Set headline of p to s.
.. @+node:ekr.20091107093823.6802: *5* Traversing outlines
Scripts can visit some or all of the nodes of a Leo outline using the following iterators::

    c.allNodes_iter             # All positions in the outline, in outline order.
    p.children_iter()           # All children of p.
    p.parents_iter()            # All parents of p.
    p.siblings_iter()           # All siblings of p, including p.
    p.following_siblings_iter() # All siblings following p, not including p.

For example, the following prints all the nodes of an outline, properly indented::

    for p in c.allNodes_iter():
        print ' '*p.level(), p.headString()
.. @+node:ekr.20091107093823.6803: *5* Executing commands from scripts
Scripts may open other Leo outlines, or execute any of Leo’s commands.  Here are some examples::

    ok,frame = g.openWithFileName(path,c)	# Opens the .leo file found at path.
    c.deleteOutline()   # Deletes the selected node.
    c.insertHeadline()  # Inserts a new node after present position.

For more examples, see Scripting Leo with Python, in Leo’s Users Guide.
.. @+node:ekr.20091107093823.6804: *5* Bringing scripts to data
The scripting plugin creates two buttons in the icon area at the top of the Leo
window. The Run Script button executes the script in the selected node just
like the Execute Script command. The Script Button button creates a new
button whose headline is the headline of the presently selected node, call it
node N. Pressing this button executes the script in node N with p predefined as
c.currentPosition() at the time the script is executed. This clever trick
brings the script to the data in the selected outline.
.. @+node:ekr.20091107093823.6805: *5* Unit Testing with @test and @suite nodes
test.leo contains all of Leo’s unit tests. An @button node in test.leo
creates a blue Unit Test button in the icon area. This button is an
excellent example of bringing scripts to data. The Unit Test button executes
all the unit tests specified by @test and @suite nodes in the selected
outline. **Important**: @button, @test and @suite nodes require the
scripting plugin to be enabled.

@test nodes greatly simplify unit testing. The Unit Test button creates
a unit test from the body text of each @test node. In effect, the Unit
Test button automatically creates an instance of unittest.TestCase whose
run method is the body text of the @test node. There is no need to create
TestCase objects explicitly!

@suite nodes support legacy unit tests. When the Unit Test script button
finds an @suite node it executes the script in its body text. This script
should create a suite of unit tests and set::

    g.app.scriptDict['suite'] = suite

where suite is the created suite. The Unit Test button then runs that
created suite of unit tests.
.. @+node:ekr.20091107093823.6806: *5* Plugins and hooks
Plugins are Python (.py) files in Leo’s plugin subdirectory. It is easy to
create new plugins: Leo’s users have contributed dozens of plugins that extend
Leo’s capabilities in new ways. Leo imports all enabled plugins during startup.
The file pluginsManager.txt lists all enabled plugins. You can use the plugin
manager plugin to control plugins without updating pluginsManager.txt by hand.

Plugins can override any class, method or function in Leo’s core, the files in
Leo’s src subdirectory (the files derived from LeoPy.leo). Besides altering
Leo’s core, plugins can register functions called hooks that Leo calls at
various times during Leo’s execution. Events that trigger hooks include key
pressed events, screen drawing events, node selection events and many others.
When importing a plugin, Leo will call the top-level init() function if it
exists. This function should register the plugin’s hooks by calling
leoPlugins.registerHandler.

For full details about hooks and events see Customizing Leo, in
Leo’s Users Guide. The file leoPlugins.leo contains all plugins that are
presently distributed with Leo; studying these plugins is a good way of learning
to write your own plugins.
.. @+node:ekr.20091107093823.6807: *5* Contacts
- Leo’s home page:  google edreamleo or http://webpages.charter.net/edreamleo/front.html

- Edward K. Ream:  edreamleo@charter.net, 166 N. Prospect Ave., Madison WI 53726, (608) 231-0766
.. @+node:ekr.20101025080245.5542: ** Review of leo-editor
The following nodes contain links to important discussions on the leo-editor web
site.
.. @+node:ekr.20101025080245.5735: *3* 10/2010
.. @+node:ekr.20101025080245.5736: *4* FAQ: how to syntax color sql
use @language plsql 
.. @+node:ekr.20101025080245.5737: *4* @url Prezi: a good model for intros
http://groups.google.com/group/leo-editor/browse_thread/thread/a1734a5f7ae25444#
.. @+node:ekr.20101025080245.5787: *5* @url Prezi home page
http://prezi.com/your/
.. @+node:ekr.20101025080245.5738: *4* @url FAQ: how to use macros
http://groups.google.com/group/leo-editor/browse_thread/thread/866245f923f382a7#
.. @+node:ekr.20101025080245.5740: *3* 9/2010
.. @+node:ekr.20101025080245.5739: *4* @url Ville's server code
http://groups.google.com/group/leo-editor/browse_thread/thread/278aa85d7298a319#
.. @+node:ekr.20101025080245.5741: *4* @url FAQ: creating windows file associations
http://groups.google.com/group/leo-editor/browse_thread/thread/fec80438b9619c1c#
.. @+node:ekr.20101025080245.5742: *4* @url Google: window 7 file icons
http://www.winhelponline.com/blog/change-file-type-icon-windows-7-and-vista/
.. @+node:ekr.20101025080245.5743: *4* @url Google: window 7 file associations
http://vista.blorge.com/2009/10/26/how-to-change-file-type-associations-in-windows-7/
.. @+node:ekr.20101025080245.5744: *4* @url qt-tabs
http://groups.google.com/group/leo-editor/browse_thread/thread/2efdbc3b47846a15#
.. @+node:ekr.20101025080245.5745: *4* Slideshow stuff
.. @+node:ekr.20101025080245.5746: *5* @url slideshow will be a plugin
http://groups.google.com/group/leo-editor/browse_thread/thread/4da36f0d897a25e8#
.. @+node:ekr.20101025080245.5747: *5* @url callouts with inkscape
http://groups.google.com/group/leo-editor/browse_thread/thread/be5401b424a022a7#
.. @+node:ekr.20101025080245.5752: *5* @url more thougths about slides
http://groups.google.com/group/leo-editor/browse_thread/thread/c66f30b5d09d3411#
.. @+node:ekr.20101025080245.5758: *5* @url (Aug) Leo vrs Screenbook Maker and storyboarding
http://groups.google.com/group/leo-editor/browse_thread/thread/fd52e4187eec7bd0#
.. @+node:ekr.20101025080245.5759: *5* @url (Aug) S5 is not good enough
http://groups.google.com/group/leo-editor/browse_thread/thread/44eb904d6b32cdd8#
.. @+node:ekr.20101025080245.5760: *5* @url (Aug) Deconstructing screenbook maker
http://groups.google.com/group/leo-editor/browse_thread/thread/3da73f0c2da2c416#
.. @+node:ekr.20101025080245.5748: *4* @url DnD howto
http://groups.google.com/group/leo-editor/browse_thread/thread/7752d3e14b49ef35#
.. @+node:ekr.20101025080245.5750: *4* @url interact plugin (ileo)
http://groups.google.com/group/leo-editor/browse_thread/thread/d58333f2ebae2675#
.. @+node:ekr.20101025080245.5753: *3* 8/2010
.. @+node:ekr.20101025080245.5751: *4* @url leoscreen plugin
http://www.mail-archive.com/leo-editor@googlegroups.com/msg11439.html
.. @+node:ekr.20101025080245.5755: *4* @url simulating <<nodes>> in rst branches (design)
http://groups.google.com/group/leo-editor/browse_thread/thread/8842b4878975e3f1#
.. @+node:ekr.20101025080245.5756: *4* @url @auto import problems
http://groups.google.com/group/leo-editor/browse_thread/thread/cde63221041d9afc#
.. @+node:ekr.20101025080245.5757: *4* @url leo in a nutshell
http://groups.google.com/group/leo-editor/browse_thread/thread/e9c5f73d048597ae#
.. @+node:ekr.20101025080245.5761: *4* @url The curse of knowledge
http://groups.google.com/group/leo-editor/browse_thread/thread/3da73f0c2da2c416#
.. @+node:ekr.20101025080245.5762: *4* @url second draft of rst3 tutorial
http://groups.google.com/group/leo-editor/browse_thread/thread/c02a442bea48f233#
.. @+node:ekr.20101025080245.5763: *4* @url quickmove tutorial
http://groups.google.com/group/leo-editor/browse_thread/thread/8eaf13b6ebda0fcd#
.. @+node:ekr.20101025080245.5764: *4* @url ** sharing code in scripts
http://groups.google.com/group/leo-editor/browse_thread/thread/a108d70400b28dc9#
.. @+node:ekr.20101025080245.5765: *4* @url simplifying docs for rst3
http://groups.google.com/group/leo-editor/browse_thread/thread/5c1ef1abcc01ef50#
.. @+node:ekr.20101025080245.5766: *4* @url Leo screencast on utube
http://groups.google.com/group/leo-editor/browse_thread/thread/ce7353ce5614efca#
.. @+node:ekr.20101025080245.5768: *4* @url revising chapter 6 (design chapter)
http://groups.google.com/group/leo-editor/browse_thread/thread/e3c736bc9f545b7e#
.. @+node:ekr.20101025080245.5769: *4* @url ** p.deletePositionsInList
http://groups.google.com/group/leo-editor/browse_thread/thread/0aa8d9d17f6300b8#
.. @+node:ekr.20101025080245.5770: *3* 7/2010
.. @+node:ekr.20101025080245.5771: *4* @url Leo3k works with docutils
http://groups.google.com/group/leo-editor/browse_thread/thread/64dfc56394abcee8#
.. @+node:ekr.20101025080245.5772: *4* @url ** At last: deleting "resurrected nodes"
http://groups.google.com/group/leo-editor/browse_thread/thread/64dfc56394abcee8#
.. @+node:ekr.20101025080245.5773: *5* Note: Leo creates both resurrected nodes and recovered nodes
.. @+node:ekr.20101025080245.5774: *4* @url @auto now regularizes newlines
http://groups.google.com/group/leo-editor/browse_thread/thread/c351a5e3399fcf09#
.. @+node:ekr.20101025080245.5775: *4* @url new sentinels
http://groups.google.com/group/leo-editor/browse_thread/thread/ace3046ffb94805b#
.. @+node:ekr.20101025080245.5776: *4* @url complications re new sentinels (design)
http://groups.google.com/group/leo-editor/browse_thread/thread/76d12c9abd586b16#
.. @+node:ekr.20101025080245.5777: *4* @url how to avoid usernames in outlines
http://groups.google.com/group/leo-editor/browse_thread/thread/e21f8efa58c204e7#
.. @+node:ekr.20101025080245.5778: *3* 6/2010
.. @+node:ekr.20101025080245.5779: *4* @url @auto-rst issue
http://groups.google.com/group/leo-editor/browse_thread/thread/f1deadac39f8f8c5#
.. @+node:ekr.20101025080245.5780: *3* 5/2010
.. @+node:ekr.20101025080245.5781: *4* @url much simpler sentinels
http://groups.google.com/group/leo-editor/browse_thread/thread/8b659c96720afd53#
.. @+node:ekr.20101025080245.5786: *3* 4/2010
.. @+node:ekr.20101025080245.5782: *4* @url new-pylint is too slow
http://groups.google.com/group/leo-editor/browse_thread/thread/de7fc699752f7a39#
.. @+node:ekr.20101025080245.5783: *4* @url thoughts about autocompletion
http://groups.google.com/group/leo-editor/browse_thread/thread/3dd91b318f17a359#
.. @+node:ekr.20101025080245.5785: *3* 3/2010
.. @+node:ekr.20101025080245.5784: *4* @url @language pseudoplain?
http://groups.google.com/group/leo-editor/topics?start=360&sa=N
.. @+node:ekr.20101115152915.4937: ** wikipedia entry
@nocolor-node

{{Infobox software
| name = Leo: Leonine Editor with Outlines
| screenshot = [http://sourceforge.net/project/screenshots.php?group_id=3458&ssid=22298 Screenshots]
| caption =
| developer = Edward K. Ream
| latest_release_version = 4.8 release candidate 1
| latest_release_date = {{release date and age|2010|11|15}}
| operating_system = [[Cross-platform]]
| genre = [[Text editor]], [[Outliner]], [[Integrated development environment|IDE]]
| license = [[Python (programming language)|Python]] License
| website = http://webpages.charter.net/edreamleo/front.html
}}

'''Leo''' ('''L'''eonine '''E'''ditor with '''O'''utlines) is a [[text editor]]
that features [[outliner|outlines]] with clones as its central tool of
organization, navigation, customization and scripting.

==Language==

Leo is written in [[Python (programming language)|Python]] and uses the [[Qt
(toolkit)|Qt]]. It is fully scriptable using Python and can be extended with
plugins. In Leo, outlines are hierarchical data structures that people use to
work with and manage text files—including code.

==Trees, clones and views==

Leo is an [[outliner]]. Leo's outline pane shows a [[tree (data structure)]] of data nodes.
Nodes contain headlines, body text, and other information.
Headlines naturally serve as descriptions of the body text.
For example, @file nodes are nodes whose headline starts with @file.

Leo trees are in fact [[directed acyclic graph|directed acyclic graphs]];
nodes may have more than one parent.
Leo calls such nodes clones.
Clones appear in several places in the outline pane.

Views are simply nodes whose children contain clones. A single outline may contain
arbitrarily many views of the nodes contained therein.
Views and clones turn Leo into a supremely flexible filing cabinet: any node may be filed
in arbitrarily many places.
<ref>[http://webpages.charter.net/edreamleo/nutshell.html Leo documentation: Leo in a Nutshell]</ref>

==External files==

@file nodes represent external files, files on the computer's file system.
When saving an outline Leo automatically writes all changed @file
trees back to the external files.
Comments, called sentinel lines, in external files represent the outline structure.
When reading an outline, these comments allows Leo to recreate
@file trees using only the data in the external file.

@auto nodes represent external files without using sentinel comments.
When reading @auto nodes, Leo uses the program structure of the external file
to create the @auto tree.

==Scripting==

Leo's scripting environment takes full advantage of outline structure:

* The body text of any node may contain a Leo script, a Python script executed in the context of a Leo outline.

* A simple [[API]] <ref>[http://webpages.charter.net/edreamleo/scripting.html Leo documentation: Scripting Leo with Python]</ref> gives Leo scripts full access to all data in loaded outlines, as well as full access to Leo's own source code. The API includes Python [[iterators]] that allow scripts to traverse outlines easily.

* Scripts may be composed of any tree of nodes. A [[markup language]] similar to [[noweb]] <ref>[http://webpages.charter.net/edreamleo/intro.html#section-references Leo documentation: Tutorial]</ref> tells Leo how to create scripts from (parts of) an outline.

* Headlines naturally control and guide scripts.

** @test nodes represent unit tests. Leo can execute the body of an @test node as unit test, without the body having to create an explicit subclass of Python's UnitTest.TestCase class. <ref>[

** @button nodes contain scripts that can be applied to other nodes.  In effect, @button nodes create user-defined commands. <ref>

==External links==
{{Portal|Free software}}
*[http://webpages.charter.net/edreamleo/front.html Leo's homepage]
*[http://sourceforge.net/projects/leo/ Leo at SourceForge],[http://sourceforge.net/project/screenshots.php?group_id=3458&ssid=22298 screenshots]
*[http://groups.google.com/group/leo-editor leo-editor Google Group]
*{{cite web | title=Literate Programming and Leo | publisher = [[Slashdot]] | date=2002-08-28 | url=http://developers.slashdot.org/article.pl?sid=02/08/28/1655207 }}
*{{cite web |author=[[James Tauber]] |title=Using the Leo Outliner as a PIM | date=2004-05-15 |url=http://jtauber.com/blog/2004/05/15/using_the_leo_outliner_as_a_pim/ }}
*{{cite book | author = Vreda Pieterse, Derrick G. Kourie, Andrew Boake | title=ACM International Conference Proceeding Series; Vol. 75. Proceedings of the 2004 annual research conference of the South African institute of computer scientists and information technologists on IT research in developing countries | chapter=A case for contemporary literate programming | editor=[[Association for Computing Machinery|ACM]] | pages=2–9 | url=http://portal.acm.org/citation.cfm?id=1035054}} (cited in references)

==References==
<references/>

{{DEFAULTSORT:Leo (Text Editor)}}
[[Category:Free text editors]]
[[Category:Free software programmed in Python]]
[[Category:Outliners]]
.. @-all
.. @-leo
