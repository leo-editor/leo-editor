#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
#@+all
#@+node:ekr.20101127152442.5916: ** Testing
#@+node:ekr.20110601190157.19176: *3* Pylint
@nocolor-node

************* Module leo.core.leoCommands
WRONG: E1101:3443:Commands.rp_get_args: Instance of 'Commands' has no 'editCommands' member
#@+node:ekr.20101028131948.5858: *3* Pylint errors for minor plugins
@killcolor

************* Module leo.plugins.geotag
E1101: 64:geotag_Controller.__del__: Instance of 'geotag_Controller' has no 'handlers' member


************* Module leo.plugins.graphed
W0511:366: FIXME
W0511:377: FIXME no handlers?


************* Module leo.plugins.groupOperations
E0602: 77:init: Undefined variable 'sets'
W0601:192:initImages: Global variable 'groupOpPI' undefined at the module level
W0601:193:initImages: Global variable 'bullseyePI' undefined at the module level
W0601:194:initImages: Global variable 'copyPI' undefined at the module level
W0601:195:initImages: Global variable 'clonePI' undefined at the module level
W0601:196:initImages: Global variable 'movePI' undefined at the module level
W0601:197:initImages: Global variable 'move_arrowPI' undefined at the module level
W0601:198:initImages: Global variable 'copy_arrowPI' undefined at the module level
W0601:199:initImages: Global variable 'clone_arrowPI' undefined at the module level
W0601:200:initImages: Global variable 'markSpotPI' undefined at the module level
W0601:201:initImages: Global variable 'markForPI' undefined at the module level
W0601:202:initImages: Global variable 'operateOnMarkedPI' undefined at the module level
W0601:203:initImages: Global variable 'clearMarksPI' undefined at the module level
W0601:204:initImages: Global variable 'transferFromPI' undefined at the module level
W0611: 31: Unused import copy
W0611: 32: Unused import base64


************* Module leo.plugins.leoupdate
W0105: 61: String statement has no effect
E0602: 72:init: Undefined variable 'sets'
W0601: 96:onCreate: Global variable 'thePluginController' undefined at the module level
W0601:103:topLevelMenu: Global variable 'thePluginController' undefined at the module level
E1101:143:LeoUpdater.showManagerDialog.HandlerDialog.initLocalCollection: Instance of 'HandlerDialog' has no 'c' member
E1101:161:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'remote_plugin_list' member
E1101:162:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
E1101:166:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
E1101:170:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'plugin_list' member
E1101:171:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'plugin_list' member
E1101:173:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'remote_plugin_list' member
E1101:174:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
W0611: 30: Unused import glob
W0611: 29: Unused import sys
W0611: 28: Unused import re


************* Module leo.plugins.mod_labels
W0311:118: Bad indentation. Found 3 spaces, expected 4
W0311:119: Bad indentation. Found 6 spaces, expected 8
W0311:126: Bad indentation. Found 6 spaces, expected 8
W0311:128: Bad indentation. Found 3 spaces, expected 4
W0311:129: Bad indentation. Found 6 spaces, expected 8
W0311:133: Bad indentation. Found 3 spaces, expected 4
W0311:134: Bad indentation. Found 6 spaces, expected 8
W0311:135: Bad indentation. Found 6 spaces, expected 8
W0311:140: Bad indentation. Found 6 spaces, expected 8
W0311:142: Bad indentation. Found 3 spaces, expected 4
W0311:143: Bad indentation. Found 6 spaces, expected 8
W0311:206: Bad indentation. Found 20 spaces, expected 16
W0311:207: Bad indentation. Found 20 spaces, expected 16
W0311:208: Bad indentation. Found 20 spaces, expected 16
W0311:209: Bad indentation. Found 28 spaces, expected 20
W0311:210: Bad indentation. Found 20 spaces, expected 16
W0311:212: Bad indentation. Found 20 spaces, expected 16
W0311:226: Bad indentation. Found 20 spaces, expected 16
W0311:228: Bad indentation. Found 20 spaces, expected 16
W0311:236: Bad indentation. Found 20 spaces, expected 16
E1123:542:labelsController.label_to_subnode: Passing unexpected keyword argument 'p' in function call
E1120:542:labelsController.label_to_subnode: No value passed for parameter 'v' in function call
E1101:571:labelsController.subnode_to_label: Instance of 'labelsController' has no 'get_labellist_for_node' member
E0602:579:labelsController.subnode_to_label: Undefined variable 'v'
E0602:605:labelsController.subnode_to_label: Undefined variable 'labels'
E0602:606:labelsController.subnode_to_label: Undefined variable 'v'
E0602:606:labelsController.subnode_to_label: Undefined variable 'labels'
E0602:611:labelsController.subnode_to_label: Undefined variable 'v'
E1120:623:labelsController.subnodes_to_label: No value passed for parameter 'title' in function call
E0602:673:labelsController.subnodes_to_labels: Undefined variable 'v'
W0611: 39: Unused import leoAtFile
W0611: 40: Unused import leoCommands
W0611: 53: Unused import os


************* Module leo.plugins.newButtons
E1101:249:UIHelperClass.addWidgets: Instance of 'FlatOptionMenu' has no 'pack' member
E1111:362:HelperForm.formCommit: Assigning to function call which doesn't return


************* Module leo.plugins.nodeActions
W0312: 63: Found indentation with tabs instead of spaces
W0312: 64: Found indentation with tabs instead of spaces
W0312: 65: Found indentation with tabs instead of spaces
W0312: 66: Found indentation with tabs instead of spaces
W0312: 67: Found indentation with tabs instead of spaces
W0312: 68: Found indentation with tabs instead of spaces
W0311: 72: Bad indentation. Found 3 spaces, expected 4
W0311: 81: Bad indentation. Found 3 spaces, expected 4
W0311: 83: Bad indentation. Found 3 spaces, expected 4
W0311: 84: Bad indentation. Found 6 spaces, expected 8
W0311: 87: Bad indentation. Found 3 spaces, expected 4
W0311: 88: Bad indentation. Found 3 spaces, expected 4
W0311: 89: Bad indentation. Found 6 spaces, expected 8
W0311: 92: Bad indentation. Found 3 spaces, expected 4
W0311: 93: Bad indentation. Found 3 spaces, expected 4
W0311: 94: Bad indentation. Found 6 spaces, expected 8
W0311: 96: Bad indentation. Found 3 spaces, expected 4
W0311: 98: Bad indentation. Found 6 spaces, expected 8
W0311: 99: Bad indentation. Found 6 spaces, expected 8
W0311:101: Bad indentation. Found 6 spaces, expected 8
W0311:104: Bad indentation. Found 9 spaces, expected 12
W0311:105: Bad indentation. Found 12 spaces, expected 16
W0311:108: Bad indentation. Found 9 spaces, expected 12
W0311:109: Bad indentation. Found 12 spaces, expected 16
W0311:111: Bad indentation. Found 9 spaces, expected 12
W0311:112: Bad indentation. Found 9 spaces, expected 12
W0311:113: Bad indentation. Found 12 spaces, expected 16
W0311:116: Bad indentation. Found 9 spaces, expected 12
W0311:117: Bad indentation. Found 9 spaces, expected 12
W0311:118: Bad indentation. Found 12 spaces, expected 16
W0311:119: Bad indentation. Found 9 spaces, expected 12
W0311:120: Bad indentation. Found 12 spaces, expected 16
W0311:122: Bad indentation. Found 9 spaces, expected 12
W0311:123: Bad indentation. Found 9 spaces, expected 12
W0311:124: Bad indentation. Found 9 spaces, expected 12
W0311:125: Bad indentation. Found 12 spaces, expected 16
W0311:127: Bad indentation. Found 9 spaces, expected 12
W0311:128: Bad indentation. Found 9 spaces, expected 12
W0311:129: Bad indentation. Found 12 spaces, expected 16
W0311:133: Bad indentation. Found 9 spaces, expected 12
W0311:137: Bad indentation. Found 9 spaces, expected 12
W0311:138: Bad indentation. Found 9 spaces, expected 12
W0311:139: Bad indentation. Found 9 spaces, expected 12
W0311:141: Bad indentation. Found 12 spaces, expected 16
W0311:142: Bad indentation. Found 12 spaces, expected 16
W0311:143: Bad indentation. Found 15 spaces, expected 20
W0311:145: Bad indentation. Found 15 spaces, expected 20
W0311:146: Bad indentation. Found 15 spaces, expected 20
W0311:147: Bad indentation. Found 18 spaces, expected 24
W0311:151: Bad indentation. Found 9 spaces, expected 12
W0311:152: Bad indentation. Found 12 spaces, expected 16
W0311:153: Bad indentation. Found 9 spaces, expected 12
W0311:154: Bad indentation. Found 12 spaces, expected 16
W0311:155: Bad indentation. Found 9 spaces, expected 12
W0311:156: Bad indentation. Found 12 spaces, expected 16
W0311:157: Bad indentation. Found 15 spaces, expected 20
W0311:158: Bad indentation. Found 12 spaces, expected 16
W0311:159: Bad indentation. Found 15 spaces, expected 20
W0311:162: Bad indentation. Found 12 spaces, expected 16
W0311:163: Bad indentation. Found 15 spaces, expected 20
W0311:165: Bad indentation. Found 18 spaces, expected 24
W0311:166: Bad indentation. Found 18 spaces, expected 24
W0311:167: Bad indentation. Found 18 spaces, expected 24
W0311:168: Bad indentation. Found 18 spaces, expected 24
W0311:169: Bad indentation. Found 21 spaces, expected 28
W0311:171: Bad indentation. Found 12 spaces, expected 16
W0311:173: Bad indentation. Found 12 spaces, expected 16
W0311:175: Bad indentation. Found 12 spaces, expected 16
W0311:176: Bad indentation. Found 15 spaces, expected 20
W0311:177: Bad indentation. Found 9 spaces, expected 12
W0311:178: Bad indentation. Found 12 spaces, expected 16
W0311:179: Bad indentation. Found 15 spaces, expected 20
W0311:182: Bad indentation. Found 6 spaces, expected 8
W0311:184: Bad indentation. Found 9 spaces, expected 12
W0311:185: Bad indentation. Found 12 spaces, expected 16
W0311:186: Bad indentation. Found 9 spaces, expected 12
W0311:187: Bad indentation. Found 6 spaces, expected 8
W0311:189: Bad indentation. Found 9 spaces, expected 12
W0311:190: Bad indentation. Found 12 spaces, expected 16
W0311:191: Bad indentation. Found 9 spaces, expected 12
W0311:192: Bad indentation. Found 6 spaces, expected 8
W0311:194: Bad indentation. Found 9 spaces, expected 12
W0311:195: Bad indentation. Found 12 spaces, expected 16
W0311:196: Bad indentation. Found 9 spaces, expected 12
W0311:197: Bad indentation. Found 3 spaces, expected 4
W0311:199: Bad indentation. Found 6 spaces, expected 8
W0311:200: Bad indentation. Found 9 spaces, expected 12
W0311:201: Bad indentation. Found 6 spaces, expected 8
W0311:205: Bad indentation. Found 3 spaces, expected 4
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:208: Bad indentation. Found 7 spaces, expected 8
W0311:209: Bad indentation. Found 7 spaces, expected 8
W0311:210: Bad indentation. Found 7 spaces, expected 8
W0311:212: Bad indentation. Found 7 spaces, expected 8
W0311:213: Bad indentation. Found 11 spaces, expected 12
W0311:214: Bad indentation. Found 11 spaces, expected 12
W0311:215: Bad indentation. Found 7 spaces, expected 8
W0311:216: Bad indentation. Found 11 spaces, expected 12
W0311:222: Bad indentation. Found 11 spaces, expected 12
W0311:224: Bad indentation. Found 11 spaces, expected 12
W0311:225: Bad indentation. Found 15 spaces, expected 16
W0311:226: Bad indentation. Found 15 spaces, expected 16
W0311:227: Bad indentation. Found 7 spaces, expected 8
W0311:229: Bad indentation. Found 11 spaces, expected 12
W0311:230: Bad indentation. Found 15 spaces, expected 16
W0311:231: Bad indentation. Found 15 spaces, expected 16
W0311:232: Bad indentation. Found 11 spaces, expected 12
W0311:233: Bad indentation. Found 11 spaces, expected 12
W0311:235: Bad indentation. Found 7 spaces, expected 8


************* Module leo.plugins.pie_menus
E1101:104:PieMenu.drawString: Instance of 'PieMenu' has no 'l4' member
E1101:104:PieMenu.drawString: Instance of 'PieMenu' has no 'l4' member
E0602:134:PieMenu.construct: Undefined variable 'l1'
E0602:138:PieMenu.construct: Undefined variable 'l1'
E0602:142:PieMenu.construct: Undefined variable 'l1'
E0602:147:PieMenu.construct: Undefined variable 'l1'
E0602:151:PieMenu.construct: Undefined variable 'l1'
E0602:166:PieMenu.construct: Undefined variable 'l1'
E0602:179:PieMenu.construct: Undefined variable 'l3'
E0602:185:PieMenu.construct: Undefined variable 'l3'
E0602:192:PieMenu.construct: Undefined variable 'l3'
E0602:200:PieMenu.construct: Undefined variable 'l2'
E0602:206:PieMenu.construct: Undefined variable 'l2'
E0602:212:PieMenu.construct: Undefined variable 'l2'
E0602:219:PieMenu.construct: Undefined variable 'l2'
E0602:225:PieMenu.construct: Undefined variable 'l2'
E0602:233:PieMenu.construct: Undefined variable 'l4'
E0602:239:PieMenu.construct: Undefined variable 'l4'
E0602:246:PieMenu.construct: Undefined variable 'l4'
E0602:254:PieMenu.construct: Undefined variable 'l5'
E0602:262:PieMenu.construct: Undefined variable 'l6'
E0602:270:PieMenu.construct: Undefined variable 'l7'
E0602:276:PieMenu.construct: Undefined variable 'l7'
E0602:282:PieMenu.construct: Undefined variable 'l7'
E1101:381:PieMenu.clean: Instance of 'PieMenu' has no 'l1' member
E1101:382:PieMenu.clean: Instance of 'PieMenu' has no 'l2' member
E1101:383:PieMenu.clean: Instance of 'PieMenu' has no 'l3' member
E1101:384:PieMenu.clean: Instance of 'PieMenu' has no 'l4' member
E1101:385:PieMenu.clean: Instance of 'PieMenu' has no 'l5' member
E1101:386:PieMenu.clean: Instance of 'PieMenu' has no 'l6' member
E1101:387:PieMenu.clean: Instance of 'PieMenu' has no 'l7' member
E1101:433:PieMenu.draw: Instance of 'PieMenu' has no 'l1' member
E1101:434:PieMenu.draw: Instance of 'PieMenu' has no 'l3' member
E1101:435:PieMenu.draw: Instance of 'PieMenu' has no 'l2' member
E1101:436:PieMenu.draw: Instance of 'PieMenu' has no 'l4' member
E1101:437:PieMenu.draw: Instance of 'PieMenu' has no 'l5' member
E1101:438:PieMenu.draw: Instance of 'PieMenu' has no 'l6' member
E1101:439:PieMenu.draw: Instance of 'PieMenu' has no 'l7' member
E1101:440:PieMenu.draw: Instance of 'PieMenu' has no 'l1' member
E1101:441:PieMenu.draw: Instance of 'PieMenu' has no 'l3' member
E1101:442:PieMenu.draw: Instance of 'PieMenu' has no 'l2' member
E1101:443:PieMenu.draw: Instance of 'PieMenu' has no 'l4' member
E1101:444:PieMenu.draw: Instance of 'PieMenu' has no 'l5' member
E1101:445:PieMenu.draw: Instance of 'PieMenu' has no 'l6' member
E1101:446:PieMenu.draw: Instance of 'PieMenu' has no 'l7' member


************* Module leo.plugins.read_only_nodes
E0611: 73: No name 'parse' in module 'urllib'
E0602:201:FTPurl.read: Undefined variable 'sys'
E0602:235:FTPurl.write: Undefined variable 'sys'
E0213:239:FTPurl.seek: Method should have "self" as first argument
E0602:240:FTPurl.seek: Undefined variable 'self'
E0211:242:FTPurl.flush: Method has no argument
E0602:256:FTPurl.dir: Undefined variable 'sys'
W0601:290:enable_body: Global variable 'insertOnTime' undefined at the module level
W0601:290:enable_body: Global variable 'insertOffTime' undefined at the module level
W0601:300:disable_body: Global variable 'insertOnTime' undefined at the module level
W0601:300:disable_body: Global variable 'insertOffTime' undefined at the module level


************* Module leo.plugins.rClick
W0511:633: TODO:
E1101:958:pluginController.getButtonHandlers: Instance of 'pluginController' has no 'button_handlers' member
E1101:1587:pluginController.findButtonCommandClass.doCommand: Instance of 'findButtonCommandClass' has no 'data' member
W0611:662: Unused import ImageTk
W0611:661: Unused import Image


************* Module leo.plugins.searchbar
W0311:100: Bad indentation. Found 9 spaces, expected 8
W0107:125:onPreCreate: Unnecessary pass statement
E1101:205:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'bg' member
E1101:211:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'labelText' member
E1101:213:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'command' member
E1103:216:SearchbarEntryWidget.__init__: Instance of 'stringTextWidget' has no 'pack' member (but some types could not be inferred)
E1101:270:SearchbarEntryWidget.detachWidget: Instance of 'SearchbarEntryWidget' has no 'leoIconBar' member
E1101:275:SearchbarEntryWidget.detachWidget: Instance of 'SearchbarEntryWidget' has no 'leoIconBar' member
E1101:299:SearchbarEntryWidget.onTextChanged: Instance of 'SearchbarEntryWidget' has no 'slave' member
E1101:309:SearchbarEntryWidget.onRightClick: Instance of 'SearchbarEntryWidget' has no 'entry_menu' member
E1101:316:SearchbarEntryWidget.onReturn: Instance of 'SearchbarEntryWidget' has no 'command' member
W0107:460:pluginController.toggleSearchbarCommandClass.doCommand: Unnecessary pass statement
W0611: 48: Unused import sys
W0611: 56: Unused import ImageTk
W0611: 55: Unused import Image
W0611: 47: Unused import re
W0611: 49: Unused import os


************* Module leo.plugins.searchbox
E1101:245:QuickFind.__init__: Class 'leoTkinterFrame' has no 'leoTkTextWidget' member
E1103:280:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'mark_set' member (but some types could not be inferred)
E1103:282:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'toGuiIndex' member (but some types could not be inferred)
E1103:283:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'mark_set' member (but some types could not be inferred)


************* Module leo.plugins.templates
W0601:100:initImages: Global variable 'templatePI' undefined at the module level
W0601:101:initImages: Global variable 'tempwizPI' undefined at the module level
E0602:210:getTemplateDialog: Undefined variable 'bs'
E0602:211:getTemplateDialog: Undefined variable 'hs'


************* Module leo.plugins.toolbar
W0511:749: FIXME:
W0511:829: TODO: not ready yet
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'tkIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'nullIconBarClass' has no 'getButton' member (but some types could not be inferred)
W0221:491:ToolbarTkinterFrame.addIconWidget: Arguments number differs from overridden method
W0221:499:ToolbarTkinterFrame.clearIconBar: Arguments number differs from overridden method
E1101:503:ToolbarTkinterFrame.clearIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
W0221:505:ToolbarTkinterFrame.createIconBar: Arguments number differs from overridden method
E1101:519:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1101:525:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1101:528:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
W0221:540:ToolbarTkinterFrame.hideIconBar: Arguments number differs from overridden method
E1101:544:ToolbarTkinterFrame.hideIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'tkIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'nullIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1101:580:ToolbarTkinterFrame.getToolbarFrame: Instance of 'ToolbarTkinterFrame' has no 'toolBar' member
E1101:643:ToolbarIconWidgetFrame.detachWidget: Instance of 'ToolbarIconWidgetFrame' has no 'leoIconBar' member
E1101:648:ToolbarIconWidgetFrame.detachWidget: Instance of 'ToolbarIconWidgetFrame' has no 'leoIconBar' member
E1101:858:ToolbarIconButton.detachWidget: Instance of 'ToolbarIconButton' has no 'leoIconBar' member
E1101:863:ToolbarIconButton.detachWidget: Instance of 'ToolbarIconButton' has no 'leoIconBar' member
E1101:995:ToolbarIconButton.setCommand: Instance of 'ToolbarIconButton' has no 'config' member
E1101:1031:ToolbarScriptButton.__init__.<lambda>: Instance of 'ToolbarScriptButton' has no 'invoke' member
W0221:1253:ToolbarScriptingController.executeScriptFromButton: Arguments number differs from overridden method
W0221:1338:ToolbarScriptingController.createScriptButtonIconButton: Arguments number differs from overridden method
E1103:1360:ToolbarScriptingController.createScriptButtonIconButton: Instance of 'ToolbarScriptButton' has no 'configure' member (but some types could not be inferred)
W0221:1362:ToolbarScriptingController.addScriptButtonCommand: Arguments number differs from overridden method
W0221:1840:ToolbarTkIconBarClass.addWidget: Arguments number differs from overridden method
W0221:2016:ToolbarTkIconBarClass.pack: Arguments number differs from overridden method


============ xcc
W0312:233: Found indentation with tabs instead of spaces
W0312:406: Found indentation with tabs instead of spaces
W0312:408: Found indentation with tabs instead of spaces
W0312:409: Found indentation with tabs instead of spaces
W0312:410: Found indentation with tabs instead of spaces
W0312:412: Found indentation with tabs instead of spaces
W0312:413: Found indentation with tabs instead of spaces
W0312:417: Found indentation with tabs instead of spaces
W0312:418: Found indentation with tabs instead of spaces
W0312:423: Found indentation with tabs instead of spaces
W0312:424: Found indentation with tabs instead of spaces
W0312:425: Found indentation with tabs instead of spaces
W0312:469: Found indentation with tabs instead of spaces
W0312:471: Found indentation with tabs instead of spaces
W0312:473: Found indentation with tabs instead of spaces
W0312:474: Found indentation with tabs instead of spaces
W0312:475: Found indentation with tabs instead of spaces
W0312:478: Found indentation with tabs instead of spaces
W0312:479: Found indentation with tabs instead of spaces
W0312:494: Found indentation with tabs instead of spaces
W0312:495: Found indentation with tabs instead of spaces
W0312:496: Found indentation with tabs instead of spaces
W0312:498: Found indentation with tabs instead of spaces
W0312:499: Found indentation with tabs instead of spaces
W0312:503: Found indentation with tabs instead of spaces
W0312:504: Found indentation with tabs instead of spaces
W0312:505: Found indentation with tabs instead of spaces
W0312:506: Found indentation with tabs instead of spaces
W0312:507: Found indentation with tabs instead of spaces
W0312:508: Found indentation with tabs instead of spaces
W0312:512: Found indentation with tabs instead of spaces
W0312:513: Found indentation with tabs instead of spaces
W0312:514: Found indentation with tabs instead of spaces
W0312:515: Found indentation with tabs instead of spaces
W0312:517: Found indentation with tabs instead of spaces
W0312:521: Found indentation with tabs instead of spaces
W0312:525: Found indentation with tabs instead of spaces
W0312:526: Found indentation with tabs instead of spaces
W0312:527: Found indentation with tabs instead of spaces
W0312:528: Found indentation with tabs instead of spaces
W0312:532: Found indentation with tabs instead of spaces
W0312:533: Found indentation with tabs instead of spaces
W0312:536: Found indentation with tabs instead of spaces
W0312:537: Found indentation with tabs instead of spaces
W0312:538: Found indentation with tabs instead of spaces
W0312:539: Found indentation with tabs instead of spaces
W0312:540: Found indentation with tabs instead of spaces
W0312:542: Found indentation with tabs instead of spaces
W0312:556: Found indentation with tabs instead of spaces
W0312:557: Found indentation with tabs instead of spaces
W0511:169: XXX to XxxClass.
W0511:521: TODO: ","Add import code in ImportFiles function!")
W0511:3342: TODO: Support precompiled header auto creation/inclusion."""
W0511:3663: TODO: send a WATCHTASK if breaked
E0602:339:OnStart2: Undefined variable 'XCC_INITED'
E0602:341:OnStart2: Undefined variable 'InitXcc'
E1101:418:linPause: Module 'os' has no 'kill' member
E0601:423:AddText: Using variable 'c' before assignment
E0602:424:AddText: Undefined variable 'LeoBody'
E0602:425:AddText: Undefined variable 'LeoBody'
E0602:474:DecompressIcon: Undefined variable 'Excetion'
E0602:475:DecompressIcon: Undefined variable 'Traceback'
E0602:536:ReplaceVars: Undefined variable 'NAME'
E0602:537:ReplaceVars: Undefined variable 'EXT'
E0602:538:ReplaceVars: Undefined variable 'ABS_PATH'
E0602:539:ReplaceVars: Undefined variable 'REL_PATH'
E0602:540:ReplaceVars: Undefined variable 'SRC_EXT'
E1121:677:controllerClass.onIdle: Too many positional arguments for function call
E1121:730:controllerClass.onQuit: Too many positional arguments for function call
E0211:816:controllerClass.UpdateProcess: Method has no argument
E0601:818:controllerClass.UpdateProcess: Using variable 'cc' before assignment
E0602:820:controllerClass.UpdateProcess: Undefined variable 'self'
E0211:995:controllerClass.sGetExecInfo: Method has no argument
E0602:997:controllerClass.sGetExecInfo: Undefined variable 'self'
E0602:1023:controllerClass.sGoToError: Undefined variable 'CPL'
E1101:1181:controllerClass.sSetText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1181:controllerClass.sSetText: Undefined variable 'SELECTED_NODE'
E1101:1187:controllerClass.sAddText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1187:controllerClass.sAddText: Undefined variable 'SELECTED_NODE'
E1120:1252:controllerClass.aStop: No value passed for parameter 'pid' in function call
E0602:1268:controllerClass.aStepIn: Undefined variable 'DBG'
E0602:1283:controllerClass.aStepOver: Undefined variable 'DBG'
E0602:1298:controllerClass.aStepOut: Undefined variable 'DBG'
E1120:1311:controllerClass.aPause: No value passed for parameter 'pid' in function call
E1101:1345:controllerClass.aSetText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1345:controllerClass.aSetText: Undefined variable 'ACTIVE_NODE'
E1101:1351:controllerClass.aAddText: Instance of 'controllerClass' has no 'ACTIVE_NOD' member
E1101:1352:controllerClass.aAddText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1355:controllerClass.aAddText: Undefined variable 'LeoBodyText'
E1101:1382:controllerClass.Compile: Instance of 'controllerClass' has no 'ProcessClass' member
E1101:1389:controllerClass.Compile: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1404:controllerClass.CplCmd: Instance of 'controllerClass' has no 'ReplaceVars' member
E0602:1443:controllerClass.CplCmd: Undefined variable 'CPL'
E1101:1460:controllerClass.Debug: Instance of 'controllerClass' has no 'GetDebugInfo' member
E1101:1469:controllerClass.Debug: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1476:controllerClass.DbgCmd: Instance of 'controllerClass' has no 'ReplaceVars' member
E1121:1486:controllerClass.Execute: Too many positional arguments for function call
E1101:1498:controllerClass.Execute: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1510:controllerClass.CplStart: Instance of 'controllerClass' has no 'VProcessList' member
E1101:1590:controllerClass.DbgStart: Instance of 'controllerClass' has no 'ProcessList' member
E0602:1610:controllerClass.DbgStart: Undefined variable 'DBG'
E0602:1617:controllerClass.DbgStart: Undefined variable 'DBG'
E0213:1619:controllerClass.DbgOut: Method should have "self" as first argument
E0602:1623:controllerClass.DbgOut: Undefined variable 'self'
E0602:1628:controllerClass.DbgOut: Undefined variable 'OutBuff'
E1101:1707:controllerClass.ProgStart: Instance of 'controllerClass' has no 'ProcessList' member
E0602:1722:controllerClass.ProgOut: Undefined variable 'ExtractLines'
E0602:1722:controllerClass.ProgOut: Undefined variable 'OutBuff'
E0602:1739:controllerClass.ProgErr: Undefined variable 'ExtractLines'
E0602:1739:controllerClass.ProgErr: Undefined variable 'ErrBuff'
E0602:1775:DBGTASK.__init__: Undefined variable 'DBG_SD'
E0602:1777:DBGTASK.__init__: Undefined variable 'DBG_SD'
E1101:1783:DBGTASK.Send: Instance of 'DBGTASK' has no 'Command' member
E1101:1784:DBGTASK.Send: Instance of 'DBGTASK' has no 'aWrite' member
E1101:1784:DBGTASK.Send: Instance of 'DBGTASK' has no 'Command' member
E1101:1785:DBGTASK.Send: Instance of 'DBGTASK' has no 'DBG_SD' member
E0602:1861:BREAKTASK.__init__: Undefined variable 'aGet'
E0602:1863:BREAKTASK.__init__: Undefined variable 'DBG'
E0602:1865:BREAKTASK.__init__: Undefined variable 'Waning'
E0602:1870:BREAKTASK.__init__: Undefined variable 'DBG'
E0602:1884:BREAKTASK.Send: Undefined variable 'NAME'
E0602:1885:BREAKTASK.Send: Undefined variable 'aWrite'
E0602:1887:BREAKTASK.Send: Undefined variable 'DBG_SD'
E0602:1888:BREAKTASK.Send: Undefined variable 'DBG_RD'
E0602:1900:BREAKTASK.Receive: Undefined variable 'aAddText'
E0602:1952:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1954:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1958:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1959:WATCHTASK.__init__: Undefined variable 'ccWatcher'
E0602:1962:WATCHTASK.__init__: Undefined variable 'DBG_SD'
W0601:1972:WATCHTASK.Cancel: Global variable 'WATCH_TASK' undefined at the module level
E0602:1973:WATCHTASK.Cancel: Undefined variable 'DBG_SD'
E0602:1974:WATCHTASK.Cancel: Undefined variable 'DBG_SD'
E0602:1975:WATCHTASK.Cancel: Undefined variable 'DBG_RD'
E0602:1976:WATCHTASK.Cancel: Undefined variable 'DBG_RD'
E0602:1977:WATCHTASK.Cancel: Undefined variable 'PROMPT_RD'
E0602:1978:WATCHTASK.Cancel: Undefined variable 'PROMPT_RD'
E0602:1980:WATCHTASK.Cancel: Undefined variable 'Watcher'
E0602:1986:WATCHTASK.Send: Undefined variable 'Watcher'
E0602:1988:WATCHTASK.Send: Undefined variable 'aWrite'
E0602:1988:WATCHTASK.Send: Undefined variable 'DBG'
E0602:1989:WATCHTASK.Send: Undefined variable 'DBG_SD'
E0602:1990:WATCHTASK.Send: Undefined variable 'DBG_RD'
E0602:1991:WATCHTASK.Send: Undefined variable 'PROMPT_RD'
E0602:1996:WATCHTASK.Receive: Undefined variable 'DBG_PROMPT'
W0601:2000:WATCHTASK.OnPrompt: Global variable 'WATCH_TASK' undefined at the module level
E0602:2002:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2008:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2013:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2014:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2017:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2018:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2020:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2023:WATCHTASK.OnPrompt: Undefined variable 'DBG_SD'
E0602:2025:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2028:WATCHTASK.OnPrompt: Undefined variable 'PROMPT_RD'
E0602:2029:WATCHTASK.OnPrompt: Undefined variable 'DBG_RD'
E0602:2104:BREAKIDTASK.Send: Undefined variable 'aWrite'
E0602:2105:BREAKIDTASK.Send: Undefined variable 'DBG_SD'
E0602:2106:BREAKIDTASK.Send: Undefined variable 'DBG_RD'
E0602:2557:ConfigClass.CplPageClass.Browse: Undefined variable 'e'
E0602:2697:ConfigClass.DbgPageClass.Browse: Undefined variable 'e'
E0602:3538:ToolbarClass.SyncDisplayToError: Undefined variable 'BreakBar'
E0602:3539:ToolbarClass.SyncDisplayToError: Undefined variable 'BreakBar'
E0602:3544:ToolbarClass.SyncDisplayToError: Undefined variable 'INSERT'
E0602:3557:ToolbarClass.SyncDisplayToError: Undefined variable 'c'
W0601:3561:ToolbarClass.SetError: Global variable 'PARSE_ERROR' undefined at the module level
W0601:3561:ToolbarClass.SetError: Global variable 'PARSE_ERROR_NODE' undefined at the module level
E0602:3593:ToolbarClass.Refresh: Undefined variable 'ACTIVE_NODE'
E0602:3613:WatcherClass.__init__: Undefined variable 'c'
E0602:3634:WatcherClass.__init__: Undefined variable 'c'
E0602:3635:WatcherClass.__init__: Undefined variable 'c'
E0602:3636:WatcherClass.__init__: Undefined variable 'c'
E0602:3637:WatcherClass.__init__: Undefined variable 'c'
E0602:3687:WatcherClass.OnDelete: Undefined variable 'sGet'
W0221:3799:BreakbarClass.yview: Arguments number differs from overridden method
E0602:3849:BreakbarClass.OnCut: Undefined variable 'LeoFrame'
E0602:3853:BreakbarClass.OnPaste: Undefined variable 'LeoFrame'
E1101:3858:BreakbarClass.OnRightClick: Instance of 'BreakbarClass' has no 'c' member
E0602:3859:BreakbarClass.OnRightClick: Undefined variable 'Menu'
E0602:3876:BreakbarClass.OnLeftClick: Undefined variable 'cGet'
E0602:3878:BreakbarClass.OnLeftClick: Undefined variable 'CHILD_NODE'
E0602:3891:BreakbarClass.OnLeftClick: Undefined variable 'SEL'
E0602:3895:BreakbarClass.AddNodeBreak: Undefined variable 'cGet'
E0602:3898:BreakbarClass.DeleteNodeBreak: Undefined variable 'cGet'
E0602:3903:BreakbarClass.ClearNodeBreaks: Undefined variable 'cSet'
E0602:4013:BreakbarClass.BreaksFromTags: Undefined variable 'CHILD_EXT'
E0602:4013:BreakbarClass.BreaksFromTags: Undefined variable 'CHILD_LINE'
E0602:4019:BreakbarClass.AddBreak: Undefined variable 'sGet'
E0602:4060:BreakbarClass.DeleteNodeBreaks: Undefined variable 'cGet'
E0602:4064:BreakbarClass.DeleteNodeBreaks: Undefined variable 'CHILD_EXT'
E0602:4064:BreakbarClass.DeleteNodeBreaks: Undefined variable 'CHILD_LINE'
E1101:4066:BreakbarClass.DeleteNodeBreaks: Instance of 'BreakbarClass' has no 'DeleteDbgBreaks' member
E0602:4068:BreakbarClass.DeleteNodeBreaks: Undefined variable 'cSelect'
E0602:4360:CppParserClass.FUNCRULE.DeclareFunc: Undefined variable 'ToolBar'
E0602:4378:CppParserClass.FUNCRULE.DefineFunc: Undefined variable 'ToolBar'
E0602:4516:CppParserClass.CLASSRULE.OnMatch: Undefined variable 'ToolBar'
E1101:4706:CppParserClass.Docum: Instance of 'CppParserClass' has no 'CURRENT_DOC_LINE' member
E0602:4730:CppParserClass.SetRealBodyDestination: Undefined variable 'EXT'
E1101:4799:CppParserClass.CppParse: Instance of 'CppParserClass' has no 'cc' member
E1102:4826:CppParserClass.CppParse: self.OnStart is not callable
E0602:4833:CppParserClass.CppParse: Undefined variable 'NAME'
E1102:4839:CppParserClass.CppParse: self.OnEnd is not callable
E1101:4852:CppParserClass.ParseNode: Instance of 'CppParserClass' has no 'cc' member
E0602:4942:WriterClass.OnWriteStart: Undefined variable 'REL_PATH'
E0602:4943:WriterClass.OnWriteStart: Undefined variable 'REL_PATH'
E0602:4943:WriterClass.OnWriteStart: Undefined variable 'NAME'
E0602:4945:WriterClass.OnWriteStart: Undefined variable 'NAME'
E0602:4948:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4949:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4953:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4954:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4959:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4959:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4960:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4960:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4961:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4964:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4965:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:5011:BreakFinderClass.__init__: Undefined variable 'controllerSELECTED_NODE'
E0602:5011:BreakFinderClass.__init__: Undefined variable 'controllerEXT'
E0602:5027:BreakFinderClass.OnFindStart: Undefined variable 'sSet'
E0602:5028:BreakFinderClass.OnFindStart: Undefined variable 'sGet'
E0602:5034:BreakFinderClass.OnFindEnd: Undefined variable 'sSet'
E0602:5053:BreakFinderClass.BreakDef: Undefined variable 'SRC_EXT'
W0611:206: Unused import tkSimpleDialog
W0611:207: Unused import base64
W0611:203: Unused import beep


************* Module leo.plugins.active_path
W0108:122:attachToCommander.<lambda>: Lambda may not be necessary
E1101:397:openDir: Generator 'walk' has no 'next' member


************* Module leo.plugins.attrib_edit
W0311:817: Bad indentation. Found 3 spaces, expected 4
W0311:820: Bad indentation. Found 3 spaces, expected 4
W0311:823: Bad indentation. Found 3 spaces, expected 4
W0311:826: Bad indentation. Found 3 spaces, expected 4
W0311:829: Bad indentation. Found 3 spaces, expected 4
W0511:290: FIXME type_ = {True: '_view', False: '_edit'}[readonly]
W0511:305: FIXME self.attrPaths.add(tuple(ns))
E1101:666:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'recSearch' member
E1101:670:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'typeMap' member
E1101:672:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'typeMap' member
W0611:119: Unused import os
W0611:116: Unused import re


************* Module leo.plugins.backlink
W0511: 21: TODO
E1101:143:backlinkTkUI.updateTkTab: Instance of 'backlinkTkUI' has no 'c' member
E1101:148:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'c' member
E1123:159:backlinkTkUI.updateTkTabInt: Passing unexpected keyword argument 'optional' in function call
E1101:167:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'vnode' member
E1101:168:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'vnodePosition' member
E1101:169:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'c' member
E1123:177:backlinkTkUI.updateTkTabInt: Passing unexpected keyword argument 'optional' in function call
E1101:184:backlinkTkUI.updateTkTabInt.delLink: Instance of 'backlinkTkUI' has no 'deleteLink' member
E1103:647:backlinkController.showMenu: Instance of 'unitTestGui' has no 'killPopupMenu' member (but some types could not be inferred)
E1103:647:backlinkController.showMenu: Instance of 'nullGui' has no 'killPopupMenu' member (but some types could not be inferred)
E1103:709:backlinkController.showMenu: Instance of 'unitTestGui' has no 'postPopupMenu' member (but some types could not be inferred)
E1103:709:backlinkController.showMenu: Instance of 'nullGui' has no 'postPopupMenu' member (but some types could not be inferred)
W0101:785:backlinkController.vnodePosition: Unreachable code
E1101:788:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member
E1101:789:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member
E1101:803:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member


************* Module leo.plugins.cursesGui
W0311: 84: Bad indentation. Found 2 spaces, expected 4
W0311: 85: Bad indentation. Found 4 spaces, expected 8
W0311: 87: Bad indentation. Found 2 spaces, expected 4
W0311: 92: Bad indentation. Found 2 spaces, expected 4
W0311: 93: Bad indentation. Found 4 spaces, expected 8
W0311: 95: Bad indentation. Found 4 spaces, expected 8
W0311: 96: Bad indentation. Found 4 spaces, expected 8
W0311: 99: Bad indentation. Found 2 spaces, expected 4
W0311:103: Bad indentation. Found 6 spaces, expected 8
W0311:105: Bad indentation. Found 2 spaces, expected 4
W0311:106: Bad indentation. Found 4 spaces, expected 8
W0311:107: Bad indentation. Found 4 spaces, expected 8
W0311:108: Bad indentation. Found 4 spaces, expected 8
W0311:110: Bad indentation. Found 2 spaces, expected 4
W0311:111: Bad indentation. Found 4 spaces, expected 8
W0311:114: Bad indentation. Found 2 spaces, expected 4
W0311:115: Bad indentation. Found 4 spaces, expected 8
W0311:117: Bad indentation. Found 2 spaces, expected 4
W0311:118: Bad indentation. Found 4 spaces, expected 8
W0311:120: Bad indentation. Found 2 spaces, expected 4
W0311:122: Bad indentation. Found 6 spaces, expected 8
W0311:124: Bad indentation. Found 6 spaces, expected 8
W0311:126: Bad indentation. Found 2 spaces, expected 4
W0311:127: Bad indentation. Found 4 spaces, expected 8
W0311:129: Bad indentation. Found 2 spaces, expected 4
W0311:130: Bad indentation. Found 4 spaces, expected 8
W0311:132: Bad indentation. Found 2 spaces, expected 4
W0311:133: Bad indentation. Found 4 spaces, expected 8
W0311:135: Bad indentation. Found 4 spaces, expected 8
W0311:137: Bad indentation. Found 4 spaces, expected 8
W0311:138: Bad indentation. Found 4 spaces, expected 8
W0311:140: Bad indentation. Found 4 spaces, expected 8
W0311:142: Bad indentation. Found 4 spaces, expected 8
W0311:143: Bad indentation. Found 6 spaces, expected 12
W0311:144: Bad indentation. Found 4 spaces, expected 8
W0311:146: Bad indentation. Found 2 spaces, expected 4
W0311:147: Bad indentation. Found 4 spaces, expected 8
W0311:149: Bad indentation. Found 2 spaces, expected 4
W0311:150: Bad indentation. Found 4 spaces, expected 8
W0311:152: Bad indentation. Found 2 spaces, expected 4
W0311:153: Bad indentation. Found 4 spaces, expected 8
W0311:155: Bad indentation. Found 4 spaces, expected 8
W0311:156: Bad indentation. Found 4 spaces, expected 8
W0311:158: Bad indentation. Found 4 spaces, expected 8
W0311:161: Bad indentation. Found 6 spaces, expected 12
W0311:162: Bad indentation. Found 8 spaces, expected 16
W0311:163: Bad indentation. Found 6 spaces, expected 12
W0311:164: Bad indentation. Found 6 spaces, expected 12
W0311:167: Bad indentation. Found 6 spaces, expected 12
W0311:169: Bad indentation. Found 6 spaces, expected 12
W0311:170: Bad indentation. Found 8 spaces, expected 16
W0311:171: Bad indentation. Found 6 spaces, expected 12
W0311:172: Bad indentation. Found 10 spaces, expected 16
W0311:174: Bad indentation. Found 2 spaces, expected 4
W0311:176: Bad indentation. Found 4 spaces, expected 8
W0311:177: Bad indentation. Found 6 spaces, expected 12
W0311:178: Bad indentation. Found 4 spaces, expected 8
W0311:179: Bad indentation. Found 6 spaces, expected 12
W0311:180: Bad indentation. Found 4 spaces, expected 8
W0311:181: Bad indentation. Found 6 spaces, expected 12
W0311:182: Bad indentation. Found 4 spaces, expected 8
W0311:183: Bad indentation. Found 6 spaces, expected 12
W0311:184: Bad indentation. Found 8 spaces, expected 16
W0311:185: Bad indentation. Found 6 spaces, expected 12
W0311:186: Bad indentation. Found 6 spaces, expected 12
W0311:187: Bad indentation. Found 8 spaces, expected 16
W0311:188: Bad indentation. Found 6 spaces, expected 12
W0311:189: Bad indentation. Found 8 spaces, expected 16
W0311:190: Bad indentation. Found 6 spaces, expected 12
W0311:191: Bad indentation. Found 8 spaces, expected 16
W0311:192: Bad indentation. Found 4 spaces, expected 8
W0311:193: Bad indentation. Found 6 spaces, expected 12
W0311:194: Bad indentation. Found 4 spaces, expected 8
W0311:195: Bad indentation. Found 6 spaces, expected 12
W0311:197: Bad indentation. Found 2 spaces, expected 4
W0311:198: Bad indentation. Found 4 spaces, expected 8
W0311:199: Bad indentation. Found 6 spaces, expected 12
W0311:200: Bad indentation. Found 4 spaces, expected 8
W0311:206: Bad indentation. Found 2 spaces, expected 4
W0311:208: Bad indentation. Found 4 spaces, expected 8
W0311:210: Bad indentation. Found 4 spaces, expected 8
W0311:213: Bad indentation. Found 2 spaces, expected 4
W0311:215: Bad indentation. Found 4 spaces, expected 8
W0311:217: Bad indentation. Found 4 spaces, expected 8
W0311:218: Bad indentation. Found 4 spaces, expected 8
W0311:219: Bad indentation. Found 4 spaces, expected 8
W0311:221: Bad indentation. Found 4 spaces, expected 8
W0311:222: Bad indentation. Found 4 spaces, expected 8
W0311:223: Bad indentation. Found 4 spaces, expected 8
W0311:236: Bad indentation. Found 2 spaces, expected 4
W0311:237: Bad indentation. Found 2 spaces, expected 4
W0311:239: Bad indentation. Found 2 spaces, expected 4
W0311:240: Bad indentation. Found 6 spaces, expected 8
W0311:242: Bad indentation. Found 2 spaces, expected 4
W0311:243: Bad indentation. Found 4 spaces, expected 8
W0311:245: Bad indentation. Found 4 spaces, expected 8
W0311:246: Bad indentation. Found 4 spaces, expected 8
W0311:247: Bad indentation. Found 4 spaces, expected 8
W0311:248: Bad indentation. Found 4 spaces, expected 8
W0311:250: Bad indentation. Found 4 spaces, expected 8
W0311:251: Bad indentation. Found 6 spaces, expected 12
W0311:253: Bad indentation. Found 4 spaces, expected 8
W0311:254: Bad indentation. Found 4 spaces, expected 8
W0311:257: Bad indentation. Found 4 spaces, expected 8
W0311:260: Bad indentation. Found 4 spaces, expected 8
W0311:262: Bad indentation. Found 2 spaces, expected 4
W0311:264: Bad indentation. Found 2 spaces, expected 4
W0311:265: Bad indentation. Found 4 spaces, expected 8
W0311:267: Bad indentation. Found 2 spaces, expected 4
W0311:268: Bad indentation. Found 4 spaces, expected 8
W0311:270: Bad indentation. Found 2 spaces, expected 4
W0311:271: Bad indentation. Found 4 spaces, expected 8
W0311:273: Bad indentation. Found 4 spaces, expected 8
W0311:274: Bad indentation. Found 4 spaces, expected 8
W0311:276: Bad indentation. Found 4 spaces, expected 8
W0311:277: Bad indentation. Found 4 spaces, expected 8
W0311:279: Bad indentation. Found 4 spaces, expected 8
W0311:280: Bad indentation. Found 8 spaces, expected 12
W0311:281: Bad indentation. Found 12 spaces, expected 16
W0311:282: Bad indentation. Found 12 spaces, expected 16
W0311:283: Bad indentation. Found 12 spaces, expected 16
W0311:284: Bad indentation. Found 12 spaces, expected 16
W0311:285: Bad indentation. Found 12 spaces, expected 16
W0311:291: Bad indentation. Found 4 spaces, expected 8
W0311:292: Bad indentation. Found 4 spaces, expected 8
W0311:293: Bad indentation. Found 4 spaces, expected 8
W0311:295: Bad indentation. Found 4 spaces, expected 8
W0311:296: Bad indentation. Found 4 spaces, expected 8
W0311:298: Bad indentation. Found 2 spaces, expected 4
W0311:299: Bad indentation. Found 2 spaces, expected 4
W0311:305: Bad indentation. Found 2 spaces, expected 4
W0311:306: Bad indentation. Found 4 spaces, expected 8
W0311:308: Bad indentation. Found 4 spaces, expected 8
W0311:310: Bad indentation. Found 4 spaces, expected 8
W0311:311: Bad indentation. Found 4 spaces, expected 8
W0311:314: Bad indentation. Found 2 spaces, expected 4
W0311:317: Bad indentation. Found 4 spaces, expected 8
W0311:321: Bad indentation. Found 2 spaces, expected 4
W0311:322: Bad indentation. Found 2 spaces, expected 4
W0311:324: Bad indentation. Found 2 spaces, expected 4
W0311:326: Bad indentation. Found 4 spaces, expected 8
W0311:327: Bad indentation. Found 4 spaces, expected 8
W0311:328: Bad indentation. Found 4 spaces, expected 8
W0311:329: Bad indentation. Found 4 spaces, expected 8
W0311:333: Bad indentation. Found 2 spaces, expected 4
W0311:338: Bad indentation. Found 2 spaces, expected 4
W0311:339: Bad indentation. Found 4 spaces, expected 8
W0311:340: Bad indentation. Found 4 spaces, expected 8
W0311:341: Bad indentation. Found 4 spaces, expected 8
W0311:343: Bad indentation. Found 2 spaces, expected 4
W0311:344: Bad indentation. Found 4 spaces, expected 8
W0311:345: Bad indentation. Found 4 spaces, expected 8
W0311:346: Bad indentation. Found 6 spaces, expected 12
W0311:347: Bad indentation. Found 4 spaces, expected 8
W0311:353: Bad indentation. Found 2 spaces, expected 4
W0311:354: Bad indentation. Found 4 spaces, expected 8
W0311:355: Bad indentation. Found 4 spaces, expected 8
W0311:356: Bad indentation. Found 4 spaces, expected 8
W0311:357: Bad indentation. Found 4 spaces, expected 8
W0311:359: Bad indentation. Found 2 spaces, expected 4
W0311:360: Bad indentation. Found 4 spaces, expected 8
W0311:366: Bad indentation. Found 2 spaces, expected 4
W0311:367: Bad indentation. Found 4 spaces, expected 8
W0311:374: Bad indentation. Found 2 spaces, expected 4
W0311:377: Bad indentation. Found 6 spaces, expected 8
W0311:378: Bad indentation. Found 6 spaces, expected 8
W0311:381: Bad indentation. Found 6 spaces, expected 8
W0311:383: Bad indentation. Found 2 spaces, expected 4
W0311:385: Bad indentation. Found 4 spaces, expected 8
W0311:387: Bad indentation. Found 4 spaces, expected 8
W0311:389: Bad indentation. Found 4 spaces, expected 8
W0311:391: Bad indentation. Found 2 spaces, expected 4
W0311:393: Bad indentation. Found 4 spaces, expected 8
W0311:398: Bad indentation. Found 4 spaces, expected 8
W0311:399: Bad indentation. Found 4 spaces, expected 8
W0311:400: Bad indentation. Found 4 spaces, expected 8
W0311:402: Bad indentation. Found 2 spaces, expected 4
W0311:406: Bad indentation. Found 4 spaces, expected 8
W0311:407: Bad indentation. Found 8 spaces, expected 12
W0311:408: Bad indentation. Found 4 spaces, expected 8
W0311:412: Bad indentation. Found 2 spaces, expected 4
W0311:417: Bad indentation. Found 4 spaces, expected 8
W0311:421: Bad indentation. Found 4 spaces, expected 8
W0311:422: Bad indentation. Found 6 spaces, expected 12
W0311:424: Bad indentation. Found 4 spaces, expected 8
W0311:425: Bad indentation. Found 4 spaces, expected 8
W0311:426: Bad indentation. Found 4 spaces, expected 8
W0311:427: Bad indentation. Found 4 spaces, expected 8
W0311:430: Bad indentation. Found 4 spaces, expected 8
W0311:431: Bad indentation. Found 4 spaces, expected 8
W0311:433: Bad indentation. Found 2 spaces, expected 4
W0311:434: Bad indentation. Found 4 spaces, expected 8
W0311:436: Bad indentation. Found 2 spaces, expected 4
W0311:438: Bad indentation. Found 4 spaces, expected 8
W0311:440: Bad indentation. Found 2 spaces, expected 4
W0311:441: Bad indentation. Found 4 spaces, expected 8
W0311:443: Bad indentation. Found 4 spaces, expected 8
W0311:444: Bad indentation. Found 6 spaces, expected 12
W0311:446: Bad indentation. Found 6 spaces, expected 12
W0311:447: Bad indentation. Found 8 spaces, expected 16
W0311:448: Bad indentation. Found 6 spaces, expected 12
W0311:450: Bad indentation. Found 6 spaces, expected 12
W0311:451: Bad indentation. Found 6 spaces, expected 12
W0311:452: Bad indentation. Found 6 spaces, expected 12
W0311:454: Bad indentation. Found 6 spaces, expected 12
W0311:455: Bad indentation. Found 8 spaces, expected 16
W0311:456: Bad indentation. Found 6 spaces, expected 12
W0311:458: Bad indentation. Found 8 spaces, expected 16
W0311:459: Bad indentation. Found 8 spaces, expected 16
W0311:460: Bad indentation. Found 10 spaces, expected 20
W0311:461: Bad indentation. Found 14 spaces, expected 24
W0311:462: Bad indentation. Found 8 spaces, expected 16
W0311:464: Bad indentation. Found 6 spaces, expected 12
W0311:465: Bad indentation. Found 8 spaces, expected 16
W0311:466: Bad indentation. Found 6 spaces, expected 12
W0311:467: Bad indentation. Found 8 spaces, expected 16
W0311:469: Bad indentation. Found 6 spaces, expected 12
W0311:470: Bad indentation. Found 6 spaces, expected 12
W0311:471: Bad indentation. Found 8 spaces, expected 16
W0311:472: Bad indentation. Found 8 spaces, expected 16
W0311:473: Bad indentation. Found 6 spaces, expected 12
W0311:474: Bad indentation. Found 8 spaces, expected 16
W0311:475: Bad indentation. Found 6 spaces, expected 12
W0311:476: Bad indentation. Found 8 spaces, expected 16
W0311:483: Bad indentation. Found 2 spaces, expected 4
W0311:484: Bad indentation. Found 4 spaces, expected 8
W0311:486: Bad indentation. Found 2 spaces, expected 4
W0311:487: Bad indentation. Found 4 spaces, expected 8
W0311:489: Bad indentation. Found 2 spaces, expected 4
W0311:490: Bad indentation. Found 4 spaces, expected 8
W0311:493: Bad indentation. Found 2 spaces, expected 4
W0311:494: Bad indentation. Found 2 spaces, expected 4
W0311:496: Bad indentation. Found 2 spaces, expected 4
W0311:504: Bad indentation. Found 2 spaces, expected 4
W0311:505: Bad indentation. Found 4 spaces, expected 8
W0311:507: Bad indentation. Found 2 spaces, expected 4
W0311:508: Bad indentation. Found 4 spaces, expected 8
W0311:510: Bad indentation. Found 2 spaces, expected 4
W0311:511: Bad indentation. Found 4 spaces, expected 8
W0311:512: Bad indentation. Found 6 spaces, expected 12
W0311:514: Bad indentation. Found 2 spaces, expected 4
W0311:515: Bad indentation. Found 4 spaces, expected 8
W0311:517: Bad indentation. Found 2 spaces, expected 4
W0311:518: Bad indentation. Found 4 spaces, expected 8
W0311:519: Bad indentation. Found 6 spaces, expected 12
W0311:522: Bad indentation. Found 2 spaces, expected 4
W0311:524: Bad indentation. Found 4 spaces, expected 8
W0311:526: Bad indentation. Found 4 spaces, expected 8
W0311:528: Bad indentation. Found 2 spaces, expected 4
W0311:531: Bad indentation. Found 4 spaces, expected 8
W0311:532: Bad indentation. Found 4 spaces, expected 8
W0311:534: Bad indentation. Found 4 spaces, expected 8
W0311:538: Bad indentation. Found 4 spaces, expected 8
W0311:541: Bad indentation. Found 2 spaces, expected 4
W0311:542: Bad indentation. Found 4 spaces, expected 8
W0311:544: Bad indentation. Found 2 spaces, expected 4
W0311:545: Bad indentation. Found 4 spaces, expected 8
W0311:547: Bad indentation. Found 2 spaces, expected 4
W0311:550: Bad indentation. Found 4 spaces, expected 8
W0311:551: Bad indentation. Found 4 spaces, expected 8
W0311:553: Bad indentation. Found 2 spaces, expected 4
W0311:555: Bad indentation. Found 4 spaces, expected 8
W0311:557: Bad indentation. Found 6 spaces, expected 12
W0311:558: Bad indentation. Found 8 spaces, expected 16
W0311:559: Bad indentation. Found 6 spaces, expected 12
W0311:560: Bad indentation. Found 8 spaces, expected 16
W0311:562: Bad indentation. Found 6 spaces, expected 12
W0311:568: Bad indentation. Found 6 spaces, expected 12
W0311:570: Bad indentation. Found 6 spaces, expected 12
W0311:571: Bad indentation. Found 8 spaces, expected 16
W0511: 21: TODO >>
W0511: 22: TODO >>
W0511: 43: TODO >>
W0511: 97: TODO leoTkinterFrame finishCreate g.app.windowList.append(f) - use that?
W0511:319: TODO Tkinter onBodyChanged undo call and many others. =(
W0511:529: TODO Much more here: there's four hooks and all sorts of other things called in the TK version. 
W0221:267:textFrame.setTopGeometry: Arguments number differs from overridden method
W0221:391:textLeoMenu.new_menu: Arguments number differs from overridden method
W0221:412:textLeoMenu.add_command: Arguments number differs from overridden method
W0221:436:textLeoMenu.delete_range: Arguments number differs from overridden method
W0221:514:textTree.redraw: Arguments number differs from overridden method
W0221:517:textTree.redraw_now: Arguments number differs from overridden method
W0221:541:textTree.editLabel: Arguments number differs from overridden method


************* Module leo.plugins.dtest
W0611: 30: Unused import leoPlugins


************* Module leo.plugins.leo_interface
W0311: 42: Bad indentation. Found 3 spaces, expected 4
W0311: 43: Bad indentation. Found 6 spaces, expected 8
W0311: 47: Bad indentation. Found 3 spaces, expected 4
W0311: 48: Bad indentation. Found 6 spaces, expected 8
W0311: 59: Bad indentation. Found 3 spaces, expected 4
W0311: 66: Bad indentation. Found 3 spaces, expected 4
W0311: 67: Bad indentation. Found 7 spaces, expected 8
W0311: 70: Bad indentation. Found 3 spaces, expected 4
W0311: 71: Bad indentation. Found 7 spaces, expected 8
W0311: 72: Bad indentation. Found 7 spaces, expected 8
W0311: 75: Bad indentation. Found 3 spaces, expected 4
W0311: 76: Bad indentation. Found 7 spaces, expected 8
W0311: 79: Bad indentation. Found 3 spaces, expected 4
W0311: 80: Bad indentation. Found 7 spaces, expected 8
W0311: 81: Bad indentation. Found 11 spaces, expected 12
W0311: 84: Bad indentation. Found 3 spaces, expected 4
W0311: 85: Bad indentation. Found 7 spaces, expected 8
W0311: 86: Bad indentation. Found 7 spaces, expected 8
W0311: 87: Bad indentation. Found 11 spaces, expected 12
W0311: 88: Bad indentation. Found 7 spaces, expected 8
W0311: 89: Bad indentation. Found 7 spaces, expected 8
W0311: 92: Bad indentation. Found 3 spaces, expected 4
W0311: 93: Bad indentation. Found 7 spaces, expected 8
W0311: 94: Bad indentation. Found 7 spaces, expected 8
W0311: 95: Bad indentation. Found 7 spaces, expected 8
W0311: 96: Bad indentation. Found 7 spaces, expected 8
W0311: 97: Bad indentation. Found 7 spaces, expected 8
W0311: 98: Bad indentation. Found 11 spaces, expected 12
W0311: 99: Bad indentation. Found 7 spaces, expected 8
W0311:100: Bad indentation. Found 7 spaces, expected 8
W0311:101: Bad indentation. Found 11 spaces, expected 12
W0311:102: Bad indentation. Found 7 spaces, expected 8
W0311:103: Bad indentation. Found 7 spaces, expected 8
W0311:104: Bad indentation. Found 7 spaces, expected 8
W0311:105: Bad indentation. Found 11 spaces, expected 12
W0311:108: Bad indentation. Found 3 spaces, expected 4
W0311:109: Bad indentation. Found 7 spaces, expected 8
W0311:110: Bad indentation. Found 7 spaces, expected 8
W0311:111: Bad indentation. Found 7 spaces, expected 8
W0311:112: Bad indentation. Found 7 spaces, expected 8
W0311:113: Bad indentation. Found 7 spaces, expected 8
W0311:114: Bad indentation. Found 11 spaces, expected 12
W0311:115: Bad indentation. Found 7 spaces, expected 8
W0311:120: Bad indentation. Found 3 spaces, expected 4
W0311:121: Bad indentation. Found 5 spaces, expected 8
W0311:130: Bad indentation. Found 3 spaces, expected 4
W0311:135: Bad indentation. Found 3 spaces, expected 4
W0311:136: Bad indentation. Found 6 spaces, expected 8
W0311:140: Bad indentation. Found 3 spaces, expected 4
W0311:141: Bad indentation. Found 6 spaces, expected 8
W0311:145: Bad indentation. Found 3 spaces, expected 4
W0311:146: Bad indentation. Found 7 spaces, expected 8
W0311:149: Bad indentation. Found 3 spaces, expected 4
W0311:150: Bad indentation. Found 7 spaces, expected 8
W0311:151: Bad indentation. Found 7 spaces, expected 8
W0311:154: Bad indentation. Found 3 spaces, expected 4
W0311:155: Bad indentation. Found 7 spaces, expected 8
W0311:156: Bad indentation. Found 7 spaces, expected 8
W0311:157: Bad indentation. Found 7 spaces, expected 8
W0311:158: Bad indentation. Found 7 spaces, expected 8
W0311:161: Bad indentation. Found 3 spaces, expected 4
W0311:162: Bad indentation. Found 7 spaces, expected 8
W0311:165: Bad indentation. Found 7 spaces, expected 8
W0311:170: Bad indentation. Found 7 spaces, expected 8
W0311:171: Bad indentation. Found 7 spaces, expected 8
W0311:172: Bad indentation. Found 7 spaces, expected 8
W0311:173: Bad indentation. Found 10 spaces, expected 12
W0311:174: Bad indentation. Found 10 spaces, expected 12
W0311:175: Bad indentation. Found 7 spaces, expected 8
W0311:176: Bad indentation. Found 7 spaces, expected 8
W0311:179: Bad indentation. Found 3 spaces, expected 4
W0311:180: Bad indentation. Found 7 spaces, expected 8
W0311:181: Bad indentation. Found 11 spaces, expected 12
W0311:184: Bad indentation. Found 3 spaces, expected 4
W0311:185: Bad indentation. Found 6 spaces, expected 8
W0311:186: Bad indentation. Found 9 spaces, expected 12
W0311:187: Bad indentation. Found 9 spaces, expected 12
W0311:188: Bad indentation. Found 9 spaces, expected 12
W0311:189: Bad indentation. Found 6 spaces, expected 8
W0311:190: Bad indentation. Found 9 spaces, expected 12
W0311:194: Bad indentation. Found 3 spaces, expected 4
W0311:195: Bad indentation. Found 7 spaces, expected 8
W0311:202: Bad indentation. Found 3 spaces, expected 4
W0311:203: Bad indentation. Found 7 spaces, expected 8
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:210: Bad indentation. Found 3 spaces, expected 4
W0311:211: Bad indentation. Found 7 spaces, expected 8
W0311:214: Bad indentation. Found 3 spaces, expected 4
W0311:215: Bad indentation. Found 7 spaces, expected 8
W0311:224: Bad indentation. Found 3 spaces, expected 4
W0311:233: Bad indentation. Found 3 spaces, expected 4
W0311:234: Bad indentation. Found 3 spaces, expected 4
W0311:237: Bad indentation. Found 3 spaces, expected 4
W0311:238: Bad indentation. Found 7 spaces, expected 8
W0311:239: Bad indentation. Found 7 spaces, expected 8
W0311:240: Bad indentation. Found 7 spaces, expected 8
W0311:241: Bad indentation. Found 7 spaces, expected 8
W0311:242: Bad indentation. Found 7 spaces, expected 8
W0311:245: Bad indentation. Found 3 spaces, expected 4
W0311:246: Bad indentation. Found 7 spaces, expected 8
W0311:249: Bad indentation. Found 3 spaces, expected 4
W0311:250: Bad indentation. Found 7 spaces, expected 8
W0311:253: Bad indentation. Found 7 spaces, expected 8
W0311:254: Bad indentation. Found 11 spaces, expected 12
W0311:257: Bad indentation. Found 3 spaces, expected 4
W0311:258: Bad indentation. Found 7 spaces, expected 8
W0311:261: Bad indentation. Found 3 spaces, expected 4
W0311:262: Bad indentation. Found 6 spaces, expected 8
W0311:263: Bad indentation. Found 6 spaces, expected 8
W0311:264: Bad indentation. Found 9 spaces, expected 12
W0311:269: Bad indentation. Found 9 spaces, expected 12
W0311:270: Bad indentation. Found 9 spaces, expected 12
W0311:271: Bad indentation. Found 12 spaces, expected 16
W0311:272: Bad indentation. Found 12 spaces, expected 16
W0311:273: Bad indentation. Found 12 spaces, expected 16
W0311:274: Bad indentation. Found 12 spaces, expected 16
W0311:275: Bad indentation. Found 15 spaces, expected 20
W0311:276: Bad indentation. Found 12 spaces, expected 16
W0311:277: Bad indentation. Found 12 spaces, expected 16
W0311:278: Bad indentation. Found 9 spaces, expected 12
W0311:279: Bad indentation. Found 9 spaces, expected 12
W0311:280: Bad indentation. Found 9 spaces, expected 12
W0311:281: Bad indentation. Found 9 spaces, expected 12
W0311:282: Bad indentation. Found 6 spaces, expected 8
W0311:283: Bad indentation. Found 6 spaces, expected 8
W0311:284: Bad indentation. Found 9 spaces, expected 12
W0311:285: Bad indentation. Found 9 spaces, expected 12
W0311:288: Bad indentation. Found 3 spaces, expected 4
W0311:289: Bad indentation. Found 6 spaces, expected 8
W0311:290: Bad indentation. Found 6 spaces, expected 8
W0311:291: Bad indentation. Found 9 spaces, expected 12
W0311:294: Bad indentation. Found 3 spaces, expected 4
W0311:295: Bad indentation. Found 7 spaces, expected 8
W0311:298: Bad indentation. Found 3 spaces, expected 4
W0311:299: Bad indentation. Found 7 spaces, expected 8
W0311:302: Bad indentation. Found 3 spaces, expected 4
W0311:303: Bad indentation. Found 7 spaces, expected 8
W0311:306: Bad indentation. Found 3 spaces, expected 4
W0311:307: Bad indentation. Found 7 spaces, expected 8
W0311:311: Bad indentation. Found 3 spaces, expected 4
W0311:312: Bad indentation. Found 7 spaces, expected 8
W0311:315: Bad indentation. Found 3 spaces, expected 4
W0311:316: Bad indentation. Found 6 spaces, expected 8
W0311:322: Bad indentation. Found 3 spaces, expected 4
W0311:336: Bad indentation. Found 3 spaces, expected 4
W0311:337: Bad indentation. Found 6 spaces, expected 8
W0311:338: Bad indentation. Found 6 spaces, expected 8
W0311:342: Bad indentation. Found 3 spaces, expected 4
W0311:343: Bad indentation. Found 6 spaces, expected 8
W0311:350: Bad indentation. Found 3 spaces, expected 4
W0311:351: Bad indentation. Found 6 spaces, expected 8
W0601:173:leo_file.gen1: Global variable 'vnode_count' undefined at the module level
W0601:186:leo_file.gen_vnodes: Global variable 'allvnodes' undefined at the module level
W0601:186:leo_file.gen_vnodes: Global variable 'vnode_stack' undefined at the module level
W0105:268:leo_node.gen_vnodes: String statement has no effect
W0601:278:leo_node.gen_vnodes: Global variable 'vnode_count' undefined at the module level


************* Module leo.plugins.leo_pdf
E0602:322:Bunch.__setitem__: Undefined variable 'operator'
E0602:326:Bunch.__getitem__: Undefined variable 'operator'
W0105:344:Writer: String statement has no effect
W0105:372:Writer: String statement has no effect


************* Module leo.plugins.leoOPML
E1101:241:opmlFileCommandsClass.putOPMLHeader: Instance of 'opmlFileCommandsClass' has no 'opml_write_leo_globals_attributes' member
E1101:278:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_write_leo_details' member
E1101:294:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_write_body_text' member
E1101:295:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_use_outline_elements' member
E1101:373:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_write_ua_attributes' member
E1101:375:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_expand_ua_dictionary' member
E1101:377:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_skip_ua_dictionary_blanks' member
E1101:485:opmlController.createVnode: Module 'leo.core.leoNodes' has no 'tnode' member
E1101:489:opmlController.createVnode: Instance of 'vnode' has no 't' member
W0221:887:contentHandler.ignorableWhitespace: Arguments number differs from overridden method


************* Module leo.plugins.leoremote
W0611: 45: Unused import sys


************* Module leo.plugins.lineNumbers
E1121: 48:init.putLineNumberDirective: Too many positional arguments for function call


************* Module leo.plugins.macros
This is a real error.
E1103:130:paramClass.parameterize: Instance of 'unitTestGui' has no 'getInsertPoint' member (but some types could not be inferred)
E1103:130:paramClass.parameterize: Instance of 'nullGui' has no 'getInsertPoint' member (but some types could not be inferred)


************* Module leo.plugins.mod_autosave
W0311: 85: Bad indentation. Found 9 spaces, expected 8
W0611: 24: Unused import os


************* Module leo.plugins.mod_leo2ascd
E1120:133:GetAscFilename: No value passed for parameter 'vnode' in function call
E1120:353:WriteTreeOfCurrentNode: No value passed for parameter 'vnode' in function call
E1120:368:WriteAll: No value passed for parameter 'vnode' in function call
E1120:427: No value passed for parameter 'c' in function call


************* Module leo.plugins.mod_speedups
W0611: 30: Unused import leoPlugins
W0611: 52: Unused import leo


************* Module leo.plugins.nav_buttons
W0311:347: Bad indentation. Found 11 spaces, expected 12


************* Module leo.plugins.nodeActions
W0312: 63: Found indentation with tabs instead of spaces
W0312: 64: Found indentation with tabs instead of spaces
W0312: 65: Found indentation with tabs instead of spaces
W0312: 66: Found indentation with tabs instead of spaces
W0312: 67: Found indentation with tabs instead of spaces
W0312: 68: Found indentation with tabs instead of spaces
W0311: 72: Bad indentation. Found 3 spaces, expected 4
W0311: 81: Bad indentation. Found 3 spaces, expected 4
W0311: 83: Bad indentation. Found 3 spaces, expected 4
W0311: 84: Bad indentation. Found 6 spaces, expected 8
W0311: 87: Bad indentation. Found 3 spaces, expected 4
W0311: 88: Bad indentation. Found 3 spaces, expected 4
W0311: 89: Bad indentation. Found 6 spaces, expected 8
W0311: 92: Bad indentation. Found 3 spaces, expected 4
W0311: 93: Bad indentation. Found 3 spaces, expected 4
W0311: 94: Bad indentation. Found 6 spaces, expected 8
W0311: 96: Bad indentation. Found 3 spaces, expected 4
W0311: 98: Bad indentation. Found 6 spaces, expected 8
W0311: 99: Bad indentation. Found 6 spaces, expected 8
W0311:101: Bad indentation. Found 6 spaces, expected 8
W0311:104: Bad indentation. Found 9 spaces, expected 12
W0311:105: Bad indentation. Found 12 spaces, expected 16
W0311:108: Bad indentation. Found 9 spaces, expected 12
W0311:109: Bad indentation. Found 12 spaces, expected 16
W0311:111: Bad indentation. Found 9 spaces, expected 12
W0311:112: Bad indentation. Found 9 spaces, expected 12
W0311:113: Bad indentation. Found 12 spaces, expected 16
W0311:116: Bad indentation. Found 9 spaces, expected 12
W0311:117: Bad indentation. Found 9 spaces, expected 12
W0311:118: Bad indentation. Found 12 spaces, expected 16
W0311:119: Bad indentation. Found 9 spaces, expected 12
W0311:120: Bad indentation. Found 12 spaces, expected 16
W0311:122: Bad indentation. Found 9 spaces, expected 12
W0311:123: Bad indentation. Found 9 spaces, expected 12
W0311:124: Bad indentation. Found 9 spaces, expected 12
W0311:125: Bad indentation. Found 12 spaces, expected 16
W0311:127: Bad indentation. Found 9 spaces, expected 12
W0311:128: Bad indentation. Found 9 spaces, expected 12
W0311:129: Bad indentation. Found 12 spaces, expected 16
W0311:133: Bad indentation. Found 9 spaces, expected 12
W0311:137: Bad indentation. Found 9 spaces, expected 12
W0311:138: Bad indentation. Found 9 spaces, expected 12
W0311:139: Bad indentation. Found 9 spaces, expected 12
W0311:141: Bad indentation. Found 12 spaces, expected 16
W0311:142: Bad indentation. Found 12 spaces, expected 16
W0311:143: Bad indentation. Found 15 spaces, expected 20
W0311:145: Bad indentation. Found 15 spaces, expected 20
W0311:146: Bad indentation. Found 15 spaces, expected 20
W0311:147: Bad indentation. Found 18 spaces, expected 24
W0311:151: Bad indentation. Found 9 spaces, expected 12
W0311:152: Bad indentation. Found 12 spaces, expected 16
W0311:153: Bad indentation. Found 9 spaces, expected 12
W0311:154: Bad indentation. Found 12 spaces, expected 16
W0311:155: Bad indentation. Found 9 spaces, expected 12
W0311:156: Bad indentation. Found 12 spaces, expected 16
W0311:157: Bad indentation. Found 15 spaces, expected 20
W0311:158: Bad indentation. Found 12 spaces, expected 16
W0311:159: Bad indentation. Found 15 spaces, expected 20
W0311:162: Bad indentation. Found 12 spaces, expected 16
W0311:163: Bad indentation. Found 15 spaces, expected 20
W0311:165: Bad indentation. Found 18 spaces, expected 24
W0311:166: Bad indentation. Found 18 spaces, expected 24
W0311:167: Bad indentation. Found 18 spaces, expected 24
W0311:168: Bad indentation. Found 18 spaces, expected 24
W0311:169: Bad indentation. Found 21 spaces, expected 28
W0311:171: Bad indentation. Found 12 spaces, expected 16
W0311:173: Bad indentation. Found 12 spaces, expected 16
W0311:175: Bad indentation. Found 12 spaces, expected 16
W0311:176: Bad indentation. Found 15 spaces, expected 20
W0311:177: Bad indentation. Found 9 spaces, expected 12
W0311:178: Bad indentation. Found 12 spaces, expected 16
W0311:179: Bad indentation. Found 15 spaces, expected 20
W0311:182: Bad indentation. Found 6 spaces, expected 8
W0311:184: Bad indentation. Found 9 spaces, expected 12
W0311:185: Bad indentation. Found 12 spaces, expected 16
W0311:186: Bad indentation. Found 9 spaces, expected 12
W0311:187: Bad indentation. Found 6 spaces, expected 8
W0311:189: Bad indentation. Found 9 spaces, expected 12
W0311:190: Bad indentation. Found 12 spaces, expected 16
W0311:191: Bad indentation. Found 9 spaces, expected 12
W0311:192: Bad indentation. Found 6 spaces, expected 8
W0311:194: Bad indentation. Found 9 spaces, expected 12
W0311:195: Bad indentation. Found 12 spaces, expected 16
W0311:196: Bad indentation. Found 9 spaces, expected 12
W0311:197: Bad indentation. Found 3 spaces, expected 4
W0311:199: Bad indentation. Found 6 spaces, expected 8
W0311:200: Bad indentation. Found 9 spaces, expected 12
W0311:201: Bad indentation. Found 6 spaces, expected 8
W0311:205: Bad indentation. Found 3 spaces, expected 4
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:208: Bad indentation. Found 7 spaces, expected 8
W0311:209: Bad indentation. Found 7 spaces, expected 8
W0311:210: Bad indentation. Found 7 spaces, expected 8
W0311:212: Bad indentation. Found 7 spaces, expected 8
W0311:213: Bad indentation. Found 11 spaces, expected 12
W0311:214: Bad indentation. Found 11 spaces, expected 12
W0311:215: Bad indentation. Found 7 spaces, expected 8
W0311:216: Bad indentation. Found 11 spaces, expected 12
W0311:222: Bad indentation. Found 11 spaces, expected 12
W0311:224: Bad indentation. Found 11 spaces, expected 12
W0311:225: Bad indentation. Found 15 spaces, expected 16
W0311:226: Bad indentation. Found 15 spaces, expected 16
W0311:227: Bad indentation. Found 7 spaces, expected 8
W0311:229: Bad indentation. Found 11 spaces, expected 12
W0311:230: Bad indentation. Found 15 spaces, expected 16
W0311:231: Bad indentation. Found 15 spaces, expected 16
W0311:232: Bad indentation. Found 11 spaces, expected 12
W0311:233: Bad indentation. Found 11 spaces, expected 12
W0311:235: Bad indentation. Found 7 spaces, expected 8


************* Module leo.plugins.nodebar
W0601:183:initImages: Global variable 'clonePI' undefined at the module level
W0601:184:initImages: Global variable 'copyPI' undefined at the module level
W0601:185:initImages: Global variable 'cutPI' undefined at the module level
W0601:186:initImages: Global variable 'dehoistPI' undefined at the module level
W0601:187:initImages: Global variable 'deletePI' undefined at the module level
W0601:188:initImages: Global variable 'demotePI' undefined at the module level
W0601:189:initImages: Global variable 'hoistPI' undefined at the module level
W0601:190:initImages: Global variable 'insertPI' undefined at the module level
W0601:191:initImages: Global variable 'movedownPI' undefined at the module level
W0601:192:initImages: Global variable 'moveleftPI' undefined at the module level
W0601:193:initImages: Global variable 'moverightPI' undefined at the module level
W0601:194:initImages: Global variable 'moveupPI' undefined at the module level
W0601:195:initImages: Global variable 'nodedownPI' undefined at the module level
W0601:196:initImages: Global variable 'nodeleftPI' undefined at the module level
W0601:197:initImages: Global variable 'noderightPI' undefined at the module level
W0601:198:initImages: Global variable 'nodeupPI' undefined at the module level
W0601:199:initImages: Global variable 'pastePI' undefined at the module level
W0601:200:initImages: Global variable 'pasteclonePI' undefined at the module level
W0601:201:initImages: Global variable 'promotePI' undefined at the module level
W0601:202:initImages: Global variable 'questionPI' undefined at the module level
W0601:203:initImages: Global variable 'sortchildrenPI' undefined at the module level
W0601:204:initImages: Global variable 'sortsiblingsPI' undefined at the module level
W0611: 21: Unused import weakref


************* Module leo.plugins.pretty_print
W0233: 52:myPrettyPrinter.__init__: __init__ method from a non direct base class 'myPrettyPrinter' is called
E0602: 62:myPrettyPrinter.putNormalToken: Undefined variable 'token'
E0602:188:myPrettyPrinter.doOp: Undefined variable 'keyword'
E0602:223:myPrettyPrinter.doOp: Undefined variable 'string'
E0602:223:myPrettyPrinter.doOp: Undefined variable 'string'


************* Module leo.plugins.quickMove
W0311:220: Bad indentation. Found 16 spaces, expected 12
W0311:225: Bad indentation. Found 16 spaces, expected 12
E1101:220:quickMove.__init__: Module 'leo.core.leoGlobals' has no 'tree_popup_handlers' member
E1101:225:quickMove.__del__: Module 'leo.core.leoGlobals' has no 'tree_popup_handlers' member
W0611:106: Unused import types


************* Module leo.plugins.quicksearch
W0301:222: Unnecessary semicolon
W0301:240: Unnecessary semicolon
W0604: 73: Using the global statement at the module level
W0611: 42: Unused import QListWidget


************* Module leo.plugins.rClickBasePluginClasses
E1101:134:pluginCommandClass.preDoCommand: Instance of 'pluginCommandClass' has no 'doCommand' member
E1101:260:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandList' member
E1101:267:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandPrefix' member
E1101:272:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandPrefix' member
E1101:310:basePluginController.getCommandList: Instance of 'basePluginController' has no 'commandList' member
E1101:318:basePluginController.setDefaultContextMenus: Instance of 'basePluginController' has no 'defaultContextMenus' member


************* Module leo.plugins.run_nodes
E1120:210:OnQuit: No value passed for parameter 'c' in function call


************* Module leo.plugins.rst3
E1120:263:runUnitTests: No value passed for parameter 'headline' in function call
E1120:1017:rstClass.initOptionsFromSettings: No value passed for parameter 'tag' in function call


************* Module leo.plugins.todo
E1101: 58:init: Module 'leo.core.leoGlobals' has no 'tree_popup_handlers' member
E0102:260:todoController.addPopupMenu.func: function already defined line 251
E0213:307:todoController.redrawer: Method should have "self" as first argument
E1102:312:todoController.redrawer.new: fn is not callable
E0213:322:todoController.projectChanger: Method should have "self" as first argument
E1102:325:todoController.projectChanger.new: fn is not callable

************* Module leo.plugins.toolbar
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'tkIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'nullIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'tkIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'nullIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1103:1360:ToolbarScriptingController.createScriptButtonIconButton: Instance of 'ToolbarScriptButton' has no 'configure' member (but some types could not be inferred)


************* Module leo.external.ipy_leo
W0601: 30:init_ipython: Global variable 'ip' undefined at the module level
W0107: 90:es: Unnecessary pass statement
W0108:231:LeoNode.<lambda>: Lambda may not be necessary
W1001:398:LeoWorkbook: Use of "property" on an old style class
E1101:438:workbook_complete: Function 'dispatch' has no 'when_type' member
E1101:438:workbook_complete: Function 'complete_object' has no 'when_type' member
E1101:589:edit_macro: Function 'edit_object_in_leo' has no 'when_type' member
W0601:749:lleo_f: Global variable '_request_immediate_connect' undefined at the module level


************* Module leo.external.lproto
E1101:137:LProtoClient.__init__: Module 'socket' has no 'AF_UNIX' member
#@+node:ekr.20111103205308.9698: ** Unit tests
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

s1 = '''
<table id="1"> <table id="2">
<contents/>
</table>
</table>
'''

s2 = '''
<table id="1"> 
<table id="2">
<contents/>
</table>
</table>
'''

t1 = 
assert result == expected,'expected...\n%s\ngot...\n%s' % (
    repr(expected),repr(result))
#@+node:ekr.20100907115157.5905: *3* @ignore Ancient tests
#@+node:ekr.20100208095423.5940: *4* @test leoCache
import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()
#@+node:ekr.20100906165118.5915: *4* @test leoInkCommands
ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
#@+node:ekr.20111102123707.9629: *4* @ignore test of marked unit-test trees
#@+node:ekr.20111102123707.9630: *5* @test assert False
assert False
#@+node:ekr.20111102123707.9631: *5* @test assert True
assert True
#@+node:ekr.20111107092526.9799: *4* @test detection of external unit tests
# This test is redundant, and another test sets import_html_tags

# print('g.app.isExternalUnitTest',g.app.isExternalUnitTest)
if g.app.isExternalUnitTest:
    fn = c.shortFileName()
    assert fn.endswith('dynamicUnitTest.leo'),fn
    data = c.config.getData('import_html_tags')
    assert len(data) == 85 # length of data in leoSettings.leo.
else:
    data = c.config.getData('import_html_tags')
    assert len(data) == 85,len(data)
#@+node:ekr.20111107092526.9800: *5* doTests...
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    g.trace(g.app.isExternalUnitTest)
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20111107092526.9801: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20111107092526.9802: *7* __init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20111107092526.9803: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20111107092526.9804: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20111107092526.9805: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20111107092526.9806: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20111107092526.9807: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20111107092526.9808: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("makeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('makeTestSuite: exception creating test cases for %s' % p.h)
        g.es_exception()
        return None
#@+node:ekr.20111107092526.9809: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20111107092526.9810: *5* main & helpers (leoDynamicTest.py)
def main ():

    trace = False
    readSettings = True 
    tag = 'leoDynamicTests.leo'
    if trace: t1 = time.time()

    # Setting verbose=True prints messages that would be sent to the log pane.
    path,gui,silent = scanOptions()
    # print('(leoDynamicTest.py:main)','silent',silent)

    # Not loading plugins and not reading settings speeds things up considerably.
    bridge = leoBridge.controller(gui=gui,
        loadPlugins=False, # Must be False: plugins will fail when run externally.
        readSettings=True, # True adds about 0.3 seconds.  Is it useful?
        silent=True,
        verbose=False)

    if trace:
         t2 = time.time()
         print('%s open bridge:  %0.2fsec' % (tag,t2-t1))

    if bridge.isOpen():
        g = bridge.globals()
        g.app.silentMode = silent
        g.app.isExternalUnitTest = True
        path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
        c = bridge.openLeoFile(path)
        if trace:
            t3 = time.time()
            print('%s open file: %0.2fsec' % (tag,t3-t2))
        runUnitTests(c,g)
#@+node:ekr.20111107092526.9811: *6* runUnitTests
def runUnitTests (c,g):

    p = c.rootPosition()
    #g.es_print('running dynamic unit tests...')
    c.selectPosition(p)
    c.debugCommands.runAllUnitTestsLocally()
#@+node:ekr.20111107092526.9812: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--path',dest='path')
    parser.add_option('--gui',dest="gui")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- path
    # We can't finalize the path here, because g does not exist ye.
    path = options.path or 'dynamicUnitTest.leo'

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('qttabs','qt'):
        gui = 'nullGui'

    # --silent
    silent = options.silent

    return path,gui,silent
#@+node:ekr.20111116161118.10248: *3* Recent tests
#@+node:ekr.20111104132424.9909: *4* @test assert True
# It's useful to have this do-nothing test.

assert True
#@+node:ekr.20111107092526.9819: *4* @test cls
g.cls() # Clear the screen
#@+node:ekr.20111110085739.10265: *4* @test html string
s = '''\
<HTML>
<head>
    <title>Bodystring</title>
</head>
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
</html>
'''

html_tags = ('body','head','html','table',) # 'div',
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.app.unitTestDict ['expectedErrors'] = 0

showTree = True

c.importCommands.htmlUnitTest(p,s=s,showTree=showTree)

if showTree:
    # g.cls()
    for p in p.subtree():
        print('\n***** %s\n' %p.h)
        print(p.b)
#@+node:ekr.20120112100822.10003: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120112100822.10004: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120112100822.10005: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120112100822.10006: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120203153754.10033: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120203153754.10034: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120203153754.10035: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120203153754.10036: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120204061120.10061: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120204061120.10062: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120204061120.10063: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120204061120.10064: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20111109151106.9746: *4* @test htmlScanner.filterTokens
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)
strip = hs.stripTokens
dump  = hs.formatTokens

s1 = '''<table id="1"><table id="2">
<contents/>
</table>
</table>'''

s2 = '<table id="1"><table id="2"><contents/></table></table>'
    
t1 = hs.tokenize(s1)
t2 = hs.tokenize(s2)
f1 = hs.filterTokens(t1)
f2 = hs.filterTokens(t2)

assert strip(f1) == strip(f2),'f1...\n%s\nf2...\n%s' % (
    dump(f1),dump(f2))
    
if 0:
    print(dump(f1))
#@+node:ekr.20111110084957.10092: *4* @test import dataN.html
fn = r'c:\recent\data.html'

# fn = r'c:\recent\data-smaller.html'
# fn = r'c:\recent\data666.html'

# These all pass on data.html:
    # html_tags = ('html','head','body',)
    # html_tags = ('html','head','body','table',)
    # html_tags = ('html','head','body','table','div',)
    # html_tags = ('html','head','body','table','div','script',)
    # html_tags = ('html','head','body','table','div','script','link',)
    # html_tags = ('html','head','body','table','div','script','link','p',)

html_tags = ('html','head','body','table','div','script','p','td','tr',)

# Settings now work when run externally.
setting = 'import_html_tags'
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.cls()

c.importCommands.importFilesCommand(files=[fn], treeType='@file')
#@+node:ekr.20111109105907.9795: *4* @test unicode stuff
@first # -*- coding: utf-8 -*-

table = (
    'test',
    '  ',
    '   after', # fails with cp6501: after is duplicated.
)

print('*'*20)
print('isPython3: %s' % g.isPython3)

for s in table:
    if g.isPython3:
        s = s.encode('ascii','replace') # create bytes.
    g.es(repr(s))
    g.es(s)
    g.pr ('g.pr(s)       : %s' % s)
    g.pr ('g.pr(repr(s)) : %s' % repr(s))
    print('print(s)      : %s' % s)
    print('print(repr(s)): %s' % s)
#@+node:ekr.20111113064104.9841: *4* @test external text operations
assert g.app.isExternalUnitTest

body = c.frame.body
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl

w = body.bodyCtrl
w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111112131605.9789: *4* @test nullBody text operations
# print('isExternalUnitTest',g.app.isExternalUnitTest)

if g.app.isExternalUnitTest:
    body = c.frame.body
else:
    import leo.core.leoCommands as leoCommands
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    
    # Important: external unit tests should execute in this environment.
    nullGui   = leoGui.nullGui('null gui')
    nullFrame = leoFrame.nullFrame(title='nullFrame title',gui=nullGui)
    c2 = leoCommands.Commands(nullFrame,fileName='<empty fileName>')
    nullFrame.c = c2
    body = leoFrame.nullBody(frame=nullFrame,parentFrame=None)
    assert repr(body).startswith('<leo.core.leoFrame.nullBody')

# Now test some basic operations.
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl
w = body.bodyCtrl

w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111115155710.9835: *4* @test g.python_tokenize
# h = 'g.python_tokenize'
# p = p.firstChild()
# assert p.h == h
tokens = g.python_tokenize(p.b,line_numbers=False)

# tokens = [(kind,val) for (kind,val,line_number) in tokens]

# First, the basic check
tokens1 = [val for kind,val in tokens]
s = ''.join(tokens1)
assert p.b == s,repr(s)

if 0:
    for z in tokens:
        kind,val = z
        print('%6s %s' % (kind,repr(val)))
        
# Next, start filtering.
tokens = [(kind,g.choose(kind=='string','"S"',val)) for kind,val in tokens]

if 0: # Delete whitespace.
    tokens = [(kind,val) for (kind,val) in tokens if kind != 'ws']
    tokens = [(kind,g.choose(kind=='id',val+' ',val)) for (kind,val) in tokens]

# Last: stringize.
tokens = [val for kind,val in tokens if kind != 'comment']
# print(''.join(tokens))

if 1: # Print lines containing '='
    s = ''.join(tokens)
    for ch in '()[]{}<>.,:=+-/':
        s = s.replace(' '+ch,ch)
    aList = [z for z in g.splitLines(s)
        if z.find('=') > -1] # and not z.find('+=')>-1 and not z.find('-=')>-1]
    print(''.join(aList))
    
#@+node:ekr.20111204110514.10287: *4* @test p.moveToFirst/LastChild
def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

child = p.firstChild()
assert child
setup(child)
p2 = child.insertAfter()
p2.h = "test"
try:
    assert c.positionExists(p2),p2
    p2.moveToFirstChildOf(child)
    assert c.positionExists(p2),p2
    p2.moveToLastChildOf(child)
    assert c.positionExists(p2),p2
finally:
    if 1:
        setup(child)
    c.redraw(p)
#@+node:ekr.20111210100047.10306: *5* child
#@+node:ekr.20111116161118.10247: *3* Old lint tests
#@+node:ekr.20111116103733.9845: *4*  Naming tests
# http://docs.python.org/reference/executionmodel.html#naming-and-binding

if 0:
    def test():
        a = b
        b = 1 # UnboundLocalError
        
print('***')
          
def test():
    global g2
    g2 = 4
    def test2():
        print(g2)
    test2()
    g2 = 3
    print(g2)
    
g2 = 'g2'
print(g2)

test()
#@+node:ekr.20111116103733.9846: *5* << define s>>
s = '''



'''

s = g.adjustTripleString(s,-4)
#@+node:ekr.20111116103733.9839: *4* @test create lots of data structures
# A simple prototype of data-centric design.
# 0.023 sec to create 100,000 dicts.
# 0.230 sec to create 1,000,000 dicts.

import time

t1 = time.clock()
n = 1000000

d = {}
for z in range(n):
    d[n] = {'n':n,}

t2 = time.clock()
print('Created %s dicts in %2.3f sec.' % (n,t2-t1))
#@+node:ekr.20111116103733.9844: *4* @test dumper (to outNodes)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outNodes.txt'

outStream = open(out,'w')
u.AstDumper().dumpFileAsNodes(fn,outStream)
#@+node:ekr.20111116103733.9840: *4* @test dumper (to outString)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outString.txt'

outStream = open(out,'w')
u.AstDumper(brief=True).dumpFileAsString(fn,outStream)
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20111128103520.10237: *3* Tests of @shadow from unitTest.leo
#@+node:ekr.20111128103520.10238: *4* @@shadow ../test/unittest/at-shadow-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10239: *5* spam
def spam():
    pass
#@+node:ekr.20111128103520.10240: *5* eggs
def eggs():
    pass
#@+node:ekr.20111128103520.10241: *4* @@shadow unittest/at-shadow-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10242: *5* child
def child():
    pass
#@+node:ekr.20111128103520.10243: *4* @test @shadow: shape of tree
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow ../test/unittest/at-shadow-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert len(p2.h) == len(h2)
#@+node:ekr.20111128103520.10244: *4* @test goto-global-line @shadow
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow unittest/at-shadow-line-number-test.py'
    root1 = g.findNodeAnywhere(c,h)
    assert root1
    assert root1.isAnyAtFileNode()
    
    fileName,lines,n,root2 = c.goToLineNumber(c).setup_file(n=6,p=root1)
    assert fileName == h[8:],'fileName'
    assert root2 == root1
    
    if 0:
        print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
            root and root.h,isRaw,n,len(lines)))
#@+node:ekr.20111116103733.9818: *3* LeoInspect tests
#@+node:ekr.20111116103733.10672: *4* @test leoInspect with multiple files
import leo.core.leoInspect as inspect

import os

<< define old_s >>
<< define s >>

g.cls()

aList = (
    'leoAtFile.py',
    'leoEditCommands.py',
)
inspect.test(c,aList,print_stats=False,s=None,print_times=True)
#@+node:ekr.20111116103733.10451: *5* << define old_s >>
# import leo.core.leoGlobals
# import leo.core.leoGlobals as g
# from leo.core.leoGlobals import pr as pr2
# from leo.core.leoGlobals import trace

s_old = '''\
import sys

aGlobal = 5
# aGlobal2 is not explicitly defined.

c = [z for z in 'abc']

def myFunc():
    n1,n2,n3,junk,junk=sys.version_info
    a = self.b
    for z in a:
        print(z)
    with A() as a:
        print(a,b)
        
def test():
    a = b # UnboundLocalError.
    b = 1
    c = 2 # Any def will do at present.
    print(g)
    print(c.frame.body)
    print(c.frame.body.xxx.yyy)
    print(b.yyy) # no check will be made.
    print(xxx.yyy)
    for c in 'abc':
        print(c,b)
        print(g)


class myClass:
    
    def __init__(self,c):
        self.a = True
        self.b = None
        c.frame.xxxx
        
    def spam(self,a,b,c=5,*args,**keys):
        global aGlobal2
        aGlobal2 = 'abc'
        self.a = b
        self.a = x
        
    def no_self(a):
        pass
        
    def test_lambda(self):
        f = lambda a,b: a

    def test_comprehension(self):
        z2 = [z for z in 'abc']
        
aGlobal3 = 4 # This should be defined everywhere.

def test():
    # a = ','.join(['a','b'])
    p = 5
    # print(p.parent().h)
    # print(g.app.windowList[0])
    print(p)
    print(g)

'''

# import leo.core.leoCommands as leoCommands
#@+node:ekr.20111116103733.10452: *5* << define s >>
s = '''\

import leo.core.leoGlobals as g

def test(c):
    a = 5
    f = c.frame
    c.frame.body.bodyCtrl = w

'''

s = g.adjustTripleString(s,-4)
# print(s)
#@+node:ekr.20111116103733.10450: *5* test
def test(c,files,print_stats=True,s=None,print_times=True):
   
    t1 = time.clock()
    sd = SemanticData(controller=None)

    if s: # Use test string.
        fn = '<test file>'
        InspectTraverser(c,fn,sd,s).traverse(s)
    else:
        for fn in files:
            print(g.shortFileName(fn))
            s = LeoCoreFiles().get_source(fn)
            if s:
                InspectTraverser(c,fn,sd,s).traverse(s)
            else:
                print('file not found: %s' % (fn))
           
    sd.total_time = time.clock()-t1
    
    if print_times: sd.print_times()
    if print_stats: sd.print_stats()
#@+node:ekr.20111116103733.10449: *4* @test leoInspect.module.classes
import leo.core.leoInspect as inspect

dump_modules = False
print_modules = True
print_functions = False
print_stats = False
print_times = True

if dump_modules or print_stats:
    g.cls()

m = inspect.module(c,'leoEditCommands.py',sd=None,
    print_stats=print_stats,print_times=print_times)
    
for o in m.classes():
    if dump_modules:
        o.dump(verbose=False)
    if print_modules:
        print(o)
    if print_functions:
        for f in o.functions:
            print('  %s' % f)
#@+node:ekr.20111116161118.10212: *4* @test leoInspect.module.classes 2
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.classes():
    print(z)
#@+node:ekr.20111116161118.10218: *4* @test leoInspect.module.defs
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.defs():
    print(z)
#@+node:ekr.20111116161118.10181: *4* @test leoInspect.module.statements
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.statements():
    print(z)
#@+node:ekr.20111116161118.10230: *4* @test leoInspect (leoEditCommands.py)
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(fn='leoEditCommands.py')

def show(o):
    print('%-5s %s' % (o.line_number(),o.format()))

var = '.widget'
func = 'w.insert'

if 0:
    
    print('\nAssignments to %s...\n' % (var))
    for o in m.assignments_to(var):
        show(o)
        
    print('\nAssignments using %s...\n' % (var))
    for o in m.assignments_using(var):
        show(o)
        
    print('\nCalls to %s...\n' % (func))
    for o in m.calls_to(func):
        show(o)
        
    if 1:
        classes = m.classes()
        for d in classes[0].defs():
            print('')
            print(d)
            for z in d.statements():
                # print(z.tree())
                # print(z.sd.dump_ast(z.tree()))
                lines = g.splitLines(z.format())
                for line in lines:
                    print('  %s' % (line))
#@+node:ekr.20111127153202.10231: *4* @test speed of AstTraverser (all Leo core files)
import leo.core.leoGlobals as g
import leo.core.leoInspect as inspect
import ast
import time

read_time,parse_time,traverse_time = 0.0,0.0,0.0
t_start = time.clock()
count = 0
for fn in inspect.LeoCoreFiles().files:
    count += 1
    t2 = time.clock()
    s = open(fn,'r').read()
    t3 = time.clock()
    tree = ast.parse(s,filename=fn,mode='exec')
    t4 = time.clock()
    inspect.AstTraverser(fn).visit(tree)
    t5 = time.clock()
    read_time += t3-t2
    parse_time += t4-t3
    traverse_time += t5-t4
t_end = time.clock()
total_time = t_end-t_start
if 1:
    print('files:    %s' % (count))
    print('read:     %2.3f sec.' % (read_time))
    print('parse:    %2.3f sec.' % (parse_time))
    print('traverse: %2.3f sec.' % (traverse_time))
    print('total:    %2.3f sec.' % (total_time))
#@+node:ekr.20111127090852.10227: *4* @test leoInspect (all core files)
import leo.core.leoInspect as inspect
import time

sd = inspect.SemanticData()
start_time = time.clock()

count = 0
for fn in inspect.LeoCoreFiles().files:
    # print(fn)
    m = inspect.module(fn,sd=sd)
    count += 1

end_time = time.clock()
total_time = end_time-start_time

if 1:
    print('files: %s' % (count))
    print('total: %2.3f sec.' % (total_time))
if 1:
    sd.print_stats()
#@+node:ekr.20111117031039.10762: *4* @test leoInspect.module (s)
import leo.core.leoInspect as inspect

g.cls()

def show(o,indent):
    # print('\n%s\n' % o.sd.dump_ast(o.tree()))
    print('%s%s' % (' '*4*indent,o.format()))

<< define s >>
print('Input...\n%s\n' % (s.rstrip()))

m = inspect.module(s=s)

if 1:
    print(show(m,0))

print('\nAssignments to a...\n')
for o in m.assignments_to('a'):
    print(o.format())
    
print('\nAssignments using d...\n')
for o in m.assignments_using('d'):
    print(o.format())
    
print('\nCalls to f...\n')
for o in m.calls_to('f'):
    print(o.format())

if 1:
    for s in m.statements():
        show(s,0)
    
    for f in m.functions():
        show(f,0)
        for z in f.statements():
            show(z,1)
    
    for cls in m.classes():
        show(cls,0)
        for d in cls.defs():
            show(d,1)
            for z in d.statements():
                show(z,1)
#@+node:ekr.20111117031039.10763: *5* << define s >>
s = '''
x.y = b(arg1,arg2=5,*args,**args).c[1:2:3].d
a=b+c
f(a=1,b=2,*args,**keys)
'''


# def outer_function(a,b=99,c=88,*args,**keys):
    # print('hello')
    
# class myClass:
    # def method():
        # pass
    
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20120116073928.10114: *3* Unit tests for settings
#@+node:ekr.20120126050844.10386: *4* @ignore print dicts unit tests
#@+node:ekr.20120117095916.10124: *5* @test printMenusList
def printMenusList(aList,level=0):
    
    for z in aList:
        a,b,c = z
        print('*** kind',a)
        if type(b) in (type(()),type([])):
            for z2 in b:
                a1,b1,c1 = z2
                if a1.startswith('@menu') and type(b1) in (type(()),type([])):
                    print()
                    print('*** inner menu: %s' % (level+1))
                    print(a1)
                    for z3 in b1:
                        print(z3)
                    if c1: print(c1)
                else:
                    print(z2)
            if c: print(c)
        else:
            print(b)
        print()
        break #
        
printMenusList(c.config.getMenusList())
       
#@+node:ekr.20120117095916.10140: *5* @test printInverseBindingDict
print('\ninverseBindingDict...\n')

d = c.k.computeInverseBindingDict()

for key in sorted(list(d.keys())):

    if 1 == len(d.get(key)):
        print(key,d.get(key))
    else:
        print()
        print(key)
        print(d.get(key))
        print()
#@+node:ekr.20120123113111.10925: *5* @test printBindingsDict
import leo.core.leoConfig as leoConfig # for ShortcutInfo
    
partial = True

d = c.k.bindingsDict
    # Keys are shortcuts; values are *lists* leoConfig.ShortcutInfo objects.
    
print('\nk.bindingsDict%s...\n' % ' (partial)' if partial else '')
    
for key in list(sorted(d.keys())):
    aList = d.get(key,[])
    for b in aList:
        assert isinstance(b,leoConfig.ShortcutInfo)
        if not partial or b.kind != 'leosettings.leo':
            print(b)
#@+node:ekr.20120117095916.10141: *5* @test printMasterBindingsDict
partial = True

panes = ('all','body','button','log','tree','text',
    'command','insert','overwrite',)

d = c.k.masterBindingsDict
    # Keys are scope names (in panes) or mode names.
    # Values are dicts:
        # keys are strokes; values are leoConfig.ShortcutInfo objects.
        
print('\nk.masterBindingsDict%s...\n' % ' (partial)' if partial else '')

for pane in sorted(list(d.keys())):
    kind = 'pane' if pane in panes else 'mode'
    print('%s: %s...' % (kind,pane))
    d2 = d.get(pane)
    for stroke in sorted(list(d2.keys())):
        b = d2.get(stroke)
        if not partial or b.kind != 'leosettings.leo':
            print('%6s %25s %17s %s' % (b.pane,stroke,b.kind,b.commandName))
            assert b.pane == pane
            assert b.stroke == stroke
    print()
#@+node:ekr.20120119051917.10263: *5* @test printConfigDicts
# These dicts will only exist when unit tests run locally.

d = g.app.config.localOptionsDict.get(c.hash())
if d:
    fn = d.name()
    keys = list(d.keys())
    print('***** localOptionsDict...')
    for key in keys:
        si = d.get(key)
        assert si.tag == 'setting'
        if si.kind == 'shortcut':
            print() ; print(key) ; print(si)
                    
aList = g.app.config.localOptionsList
if aList:
    print() ; print('***** localOptionsList...')
    for d in aList:
        fn = d.name()
        print()
        print('local shortcuts for %s...' % fn)
        keys = sorted(list(d.keys()))
        for key in keys:
            if key.startswith('run'):
                si = d.get(key)
                if si.kind == 'shortcut':
                    print() ; print(key) ; print(si)
#@+node:ekr.20120126080450.10187: *4* @ignore passed
#@+node:ekr.20120120095156.10263: *5* @test findDictForFile
def findDictForFile(fn):
    
    '''Find the configuration dict correspoinding to fn.'''
    
    short_fn = g.shortFileName(fn).lower()

    for d in g.app.config.localOptionsList:
        h = g.shortFileName(d.name()).lower()
        if short_fn == h:
            return d
    else:
        g.trace('no options dict for: %s' % (fn))
        return {}
        
table = (c.fileName(),'myLeoSettings.leo','leoSettings.leo')

for fn in table:
    d = findDictForFile(fn)
    print('%20s %s' % (g.shortFileName(fn),d and len(list(d.keys())) or 0))
#@+node:ekr.20120126080450.10189: *5* @test mode-related info
@

g.app.config.modeCommandsDict
    Keys are command names: enter-x-mode.
    Values are inner dictionaries:
        Keys are command names, values are lists of ShortcutInfo nodes.
@c

d = g.app.config.modeCommandsDict
    
for key in sorted(d.keys()):
    print('*** mode ***',key)
    d2 = d.get(key)
    for key2 in sorted(d2.keys()):
        aList = d2.get(key2)
        print(key2)
        for si in aList:
            print('   ',si)
#@+node:ekr.20120120095156.10262: *5* @test types of contents of settings dicts
@
ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           list of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     inner masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:
(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) inner masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
@c

si_type = c.k.ShortcutInfo
disabled_func_type = None # Should be any bound method.
k = c.k

@others

test_dict_of_objects(c.commandsDict,type('s'),disabled_func_type,'commandsDict')
test_dict_of_objects(k.inverseCommandsDict,type('s'),type('s'),'inverseCommandsDict')
test_dict_of_lists(k.bindingsDict,si_type,'bindingsDict')
test_dict_of_dicts(k.masterBindingsDict,si_type,'masterBindingsDict')
test_dict_of_lists(k.masterGuiBindingsDict,None,'masterGuiBindingsDict')
test_dict_of_objects(k.settingsNameDict,type('s'),type('s'),'settingsNameDict')
test_dict_of_lists(k.computeInverseBindingDict(),type(tuple()),'inverseBindingDict')

# Test individual dicts separately.
d = g.app.config.modeCommandsDict
test_dict_of_dicts(d,None,'modeCommandsDict')
for key in sorted(d.keys()):
    d2 = d.get(key)
    test_dict_of_lists(d2,si_type,'inner modeCommandsDict')
        # This requires a hack to special-case the
        # '*entry-commands*' and '*command-prompt*' keys.
#@+node:ekr.20120126080450.10193: *6* test_dict_of_dicts
def test_dict_of_dicts(d,theType,tag):

    assert d,tag

    for key in d.keys():
        d2 = d.get(key)
        assert type(d2) == type({})
        for key in d2.keys():
            obj = d2.get(key)
            if theType:
                assert type(obj) == theType,repr(obj)
#@+node:ekr.20120126080450.10191: *6* test_dict_of_lists
def test_dict_of_lists(d,theType,tag):

    assert d,tag

    for key in d.keys():
        obj = d.get(key)
        if key in ('*entry-commands*','*command-prompt*'):
            # Special case for g.app.config.modeCommandsDict
            assert type(obj)==type([]),repr(obj)
        else:
            assert type(obj) == type([])
            # Don't check types of list elements if theType is None.
            if theType:
                for z in obj:
                    assert type(z)==theType,'key: %s obj: %s' % (key,repr(obj))
#@+node:ekr.20120126080450.10195: *6* test_dict_of_objects
def test_dict_of_objects(d,keyType,valueType,tag):

    assert d,tag

    for key in d.keys():
        assert type(key) == keyType,repr(key)
        obj = d.get(key)
        # Don't check type of obj if valueType is None.
        if valueType:
            assert type(obj) == valueType,'\nobj: %s\nvalueType: %s' % (repr(obj),valueType)
#@+node:ekr.20120126080450.10194: *6* Unused
# import types
# types.ListType does not exist in Python 3.x.
# assert isinstance(aList,list().__class__)
#@+node:ekr.20120127084215.10238: *5* @test make_settings_dicts
@others

# import os ; os.system('cls')
    
d1 = g.app.config.immutable_leo_settings_shortcuts_dict
d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
d3 = g.app.config.merge_settings_dicts(d1,d2)

if False:
    patterns = (
        'backward-find-character-extend-selection',
    )
    for pattern in patterns:
        print(dump_dict(d1,pattern,tag='d1'))
        print(dump_dict(d2,pattern,tag='d2'))
        print(dump_dict(d3,pattern,tag='d3'))

test(d1,d2,d3)
#@+node:ekr.20120127145909.10227: *6* dump & dump_dict (@test make_settings_dicts)
def dump(aList,pattern=None,tag=None):
    
    return '\n'.join([repr(z) for z in aList])
    

def dump_dict(d,pattern=None,tag=None):
    
    result = [] # '\ndump of %s...' % (tag)
    
    for key in d.keys():
        if pattern in (key,None):
            result.append(key)
            aList = d.get(key)
            for z in aList:
                result.append('    %s' % (z))
                
    return '\n'.join(result)
#@+node:ekr.20120127084215.10239: *6* test (@test make_settings_dicts)
def test(old_d,new_d,result_d):
    
    '''Test that result_d is the result of upating old_d with new_d.
    
    This test is tricky: only inverted dicts have ShortcutInfo nodes as keys.'''
    
    invert,uninvert = g.app.config.invert,g.app.config.uninvert

    # Compute the inversions of all the dicts.
    inv_old,inv_new,inv_res = invert(old_d),invert(new_d),invert(result_d)
    
    # Part 1: Ensure we test all keys.
    keys = list(inv_old.keys())
    keys.extend(list(inv_new.keys()))
    keys.extend(list(inv_res.keys()))
    keys = sorted(list(set(keys)))
    assert None not in keys
    for key in inv_old.keys(): assert key in keys,key
    for key in inv_new.keys(): assert key in keys,key
    for key in inv_res.keys(): assert key in keys,key
    
    # Part 2: Carefully test the inverted result.
    def si_name_key(si): return si.commandName or ''

    for key in keys:
        # Compute the *sorted* list of 
        res_list = sorted(inv_res.get(key,[]),key=si_name_key)
        old_list = sorted(inv_old.get(key,[]),key=si_name_key)
        new_list = sorted(inv_new.get(key,[]),key=si_name_key)
        assert res_list,'no res_list.get(%s)' % (key)
        # if new_list: print(key,dump(new_list))
        if new_list:
            assert new_list == res_list,'key %s\nnew:\n%s\nres:\n%s' % (
                key,dump(new_list),dump(res_list))
        else:
            assert old_list == res_list,'key %s\nold:\n%s\nres:\n%s' % (
                key,dump(old_list),dump(res_list))
    
    # Part 3: Test that result_d == uninvert(invert(result_d)).
    # A.  They must have the same keys.
    unv_res = uninvert(inv_res)
    assert sorted(list(result_d.keys())) == sorted(list(unv_res.keys()))

    # B. The values of for each key must match after being sorted.
    def si_stroke_key(si): return si.stroke or ''
        
    for key in sorted(result_d.keys()):
        res_list = sorted(result_d.get(key,[]),key=si_stroke_key)
        unv_list = sorted( unv_res.get(key,[]),key=si_stroke_key)
        assert res_list == unv_list,'key %s\nres:\n%s\nunv:\n%s' % (
            key,dump(res_list),dump(unv_list))
   
#@+node:ekr.20120203153754.10032: *5* @test KeyStroke
ks = c.k.KeyStroke

@others

a1 = ks('a')
a2 = ks('a')
b1 = ks('b')
assert a1 == a2
d = {}
d[a1] = a1.s
d[a2] = a2.s
d[b1] = b1.s

for key in sorted(d):
    print(key,d.get(key))
#@+node:ekr.20120205022040.17748: *5* @test g.TypedDict
d = g.TypedDictOfLists('ks',type('s'),type(9))
d.add('a',1)
d.add('a',2)
d.add('b',3)

print(d)
for s in sorted(d.keys()):
    print(s,d.get(s,[]))

print('after replace...')
d.replace('a',[8,9,10])

for s in sorted(d.keys()):
    print(s,d.get(s,[]))
#@+node:ekr.20110621074459.14908: ** 4.10
#@+node:ekr.20111113141805.10062: *3* Code
#@+node:ekr.20111109105907.9796: *4* Simplified g.pr
#@+node:ekr.20111023164430.16771: *4* Removed unused color tags
@nocolor-node

# 8 Leo-specific, not jEdit specific.
blank
docpart
leokeyword
link
name
nameBrackets
tab
url
#@+node:ekr.20110605121601.18569: *5* class jeditColorizer
# This is c.frame.body.colorizer.highlighter.colorer

class jEditColorizer:

    '''This class contains jEdit pattern matchers adapted
    for use with QSyntaxHighlighter.'''

    << about the line-oriented jEdit colorizer >>

    @others
#@+node:ekr.20110605121601.18570: *6* << about the line-oriented jEdit colorizer >>
@nocolor-node
@

The aha behind the line-oriented jEdit colorizer is that we can define one or
more *restarter* methods for each pattern matcher that could possibly match
across line boundaries. I say "one or more" because we need a separate restarter
method for all combinations of arguments that can be passed to the jEdit pattern
matchers. In effect, these restarters are lambda bindings for the generic
restarter methods.

In actuality, very few restarters are needed. For example, for Python, we need
restarters for continued strings, and both flavors of continued triple-quoted
strings. For python, these turn out to be three separate lambda bindings for
restart_match_span.

When a jEdit pattern matcher partially succeeds, it creates the lambda binding
for its restarter and calls setRestart to set the ending state of the present
line to an integer representing the bound restarter. setRestart calls
computeState to create a *string* representing the lambda binding of the
restarter. setRestart then calls stateNameToStateNumber to convert that string
to an integer state number that then gets passed to Qt's setCurrentBlockState.
The string is useful for debugging; Qt only uses the corresponding number.
#@+node:ekr.20110605121601.18571: *6*  Birth & init
#@+node:ekr.20110605121601.18572: *7* __init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    self.defaultState = 'default-state:' # The name of the default state.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False
        # True: trace all matching methods.
        # This isn't so useful now that colorRangeWithTag shows g.callers(2).
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.language_name = None # The name of the language for the current mode.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
    
        # To be removed...
    
            # Used only by the old colorizer.
            # 'bracketRange',
            # "comment",
            # "cwebName"
            # "keyword",
            # "latexBackground","latexKeyword","latexModeKeyword",
            # "pp",
            # "string",
            
            # Wiki styling.  These were never user options.
            # "bold","bolditalic","elide","italic",
            
            # Marked as Leo jEdit tags, but not used.
            # '@color', '@nocolor','doc_part', 'section_ref',
        
        # 8 Leo-specific tags.
        "blank",  # show_invisibles_space_color
        "docpart",
        "leokeyword",
        "link",
        "name",
        "namebrackets",
        "tab", # show_invisibles_space_color
        "url",
        
        # jEdit tags.
        'comment1','comment2','comment3','comment4',
        # default, # exists, but never generated.
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
#@+node:ekr.20110605121601.18573: *8* defineLeoKeywordsDict
def defineLeoKeywordsDict(self):

    self.leoKeywordsDict = {}

    for key in g.globalDirectiveList:
        self.leoKeywordsDict [key] = 'leokeyword'
#@+node:ekr.20110605121601.18574: *8* defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
    
        # Used in Leo rules...
    
        # tag name      :( option name,                  default color),
        'blank'         :('show_invisibles_space_color', '#E5E5E5'), # gray90
        'docpart'       :('doc_part_color',              'red'),
        'leokeyword'    :('leo_keyword_color',           'blue'),
        'link'          :('section_name_color',          'red'),
        'name'          :('undefined_section_name_color','red'),
        'namebrackets'  :('section_name_brackets_color', 'blue'),
        'tab'           :('show_invisibles_tab_color',   '#CCCCCC'), # gray80
        'url'           :('url_color',                   'purple'),
        
        # Used by the old colorizer: to be removed.
        
        # 'bracketRange'   :('bracket_range_color',     'orange'), # Forth.
        # 'comment'        :('comment_color',           'red'),
        # 'cwebName'       :('cweb_section_name_color', 'red'),
        # 'keyword'        :('keyword_color',           'blue'),
        # 'latexBackground':('latex_background_color',  'white'),
        # 'pp'             :('directive_color',         'blue'),
        # 'string'         :('string_color',            '#00aa00'), # Used by IDLE.

        # jEdit tags.
        # tag name  :( option name,     default color),
        'comment1'  :('comment1_color', 'red'),
        'comment2'  :('comment2_color', 'red'),
        'comment3'  :('comment3_color', 'red'),
        'comment4'  :('comment4_color', 'red'),
        'function'  :('function_color', 'black'),
        'keyword1'  :('keyword1_color', 'blue'),
        'keyword2'  :('keyword2_color', 'blue'),
        'keyword3'  :('keyword3_color', 'blue'),
        'keyword4'  :('keyword4_color', 'blue'),
        'keyword5'  :('keyword5_color', 'blue'),
        'label'     :('label_color',    'black'),
        'literal1'  :('literal1_color', '#00aa00'),
        'literal2'  :('literal2_color', '#00aa00'),
        'literal3'  :('literal3_color', '#00aa00'),
        'literal4'  :('literal4_color', '#00aa00'),
        'markup'    :('markup_color',   'red'),
        'null'      :('null_color',     None), #'black'),
        'operator'  :('operator_color', None), #'black'),
    }
#@+node:ekr.20110605121601.18575: *8* defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
    
        # Used in Leo rules...
        
            # tag name      : option name
            'blank'         :'show_invisibles_space_font', # 2011/10/24.
            'docpart'       :'doc_part_font',
            'leokeyword'    :'leo_keyword_font',
            'link'          :'section_name_font',
            'name'          :'undefined_section_name_font',
            'namebrackets'  :'section_name_brackets_font',
            'tab'           : 'show_invisibles_tab_font', # 2011/10/24.
            'url'           : 'url_font',
        
        # Used by old colorizer.
        
            # 'bracketRange'   :'bracketRange_font', # Forth.
            # 'comment'       :'comment_font',
            # 'cwebName'      :'cweb_section_name_font',
            # 'keyword'       :'keyword_font',
            # 'latexBackground':'latex_background_font',
            # 'pp'            :'directive_font',
            # 'string'        :'string_font',
    
         # jEdit tags.
         
             # tag name     : option name
            'comment1'      :'comment1_font',
            'comment2'      :'comment2_font',
            'comment3'      :'comment3_font',
            'comment4'      :'comment4_font',
            #'default'       :'default_font',
            'function'      :'function_font',
            'keyword1'      :'keyword1_font',
            'keyword2'      :'keyword2_font',
            'keyword3'      :'keyword3_font',
            'keyword4'      :'keyword4_font',
            'keyword5'      :'keyword5_font',
            'label'         :'label_font',
            'literal1'      :'literal1_font',
            'literal2'      :'literal2_font',
            'literal3'      :'literal3_font',
            'literal4'      :'literal4_font',
            'markup'        :'markup_font',
            # 'nocolor' This tag is used, but never generates code.
            'null'          :'null_font',
            'operator'      :'operator_font',
    }
#@+node:ekr.20110605121601.18576: *7* addImportedRules
def addImportedRules (self,mode,rulesDict,rulesetName):

    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''

    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets [rulesetName] = True

    names = hasattr(mode,'importDict') and mode.importDict.get(rulesetName,[]) or []

    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key,[])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        # g.trace([z.__name__ for z in rules])
                        aList.extend(rules)
                        self.rulesDict [key] = aList
        # g.trace('***** added rules for %s from %s' % (name,rulesetName))
        self.initModeFromBunch(savedBunch)
#@+node:ekr.20110605121601.18577: *7* addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_language, True), # 2011/01/17
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True),
        ('f',  self.match_url_f,        True),
        ('h',  self.match_url_h,       True),
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.

        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
#@+node:ekr.20111024091133.16702: *7* configure_hard_tab_width
def configure_hard_tab_width (self):
    
    # The stated default is 40, but apparently it must be set explicitly.
    
    trace = False and not g.unitTesting
    c,w = self.c,self.w
 
    if 0:
        # No longer used: c.config.getInt('qt-tab-width')
        hard_tab_width = abs(10*c.tab_width)
        if trace: g.trace('hard_tab_width',hard_tab_width,self.w)
    else:
        # For some reason, the size is not accurate.
        font = w.widget.currentFont()
        info = QtGui.QFontInfo(font)
        size = info.pointSizeF()
        pixels_per_point = 1.0 # 0.9
        hard_tab_width = abs(int(pixels_per_point*size*c.tab_width))
        
        if trace: g.trace(
            'family',font.family(),'point size',size,
            'tab_width',c.tab_width,
            'hard_tab_width',hard_tab_width) # ,self.w)
    
    w.widget.setTabStopWidth(hard_tab_width)
#@+node:ekr.20110605121601.18578: *7* configure_tags
def configure_tags (self):

    trace = False and not g.unitTesting
    traceColors = False
    traceFonts = False
    c = self.c ; w = self.w
    isQt = g.app.gui.guiName().startswith('qt')

    if trace: g.trace(self.colorizer.language)

    if w and hasattr(w,'start_tag_configure'):
        w.start_tag_configure()

    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont

    # Configure fonts.
    if trace and traceFonts: g.trace('*'*10,'configuring fonts')
    keys = list(self.default_font_dict.keys()) ; keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language,option_name),(option_name)):
            if trace and traceFonts: g.trace(name)
            font = self.fonts.get(name)
            if font:
                if trace and traceFonts:
                    g.trace('**found',name,id(font))
                w.tag_configure(key,font=font)
                break
            else:
                family = c.config.get(name + '_family','family')
                size   = c.config.get(name + '_size',  'size')   
                slant  = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight','weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size   = size or c.config.defaultBodyFontSize
                    slant  = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family,size,slant,weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    if trace and traceFonts:
                        g.trace('**found',key,name,family,size,slant,weight,id(font))
                    w.tag_configure(key,font=font)
                    break

        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                if trace and traceFonts:
                    g.trace('default',key,font)
                self.fonts[key] = font # 2010/02/19: Essential
                w.tag_configure(key,font=defaultBodyfont)
            else:
                if trace and traceFonts:
                    g.trace('no fonts')
                    
        if isQt and key == 'url' and font:
            font.setUnderline(True) # 2011/03/04

    if trace and traceColors: g.trace('*'*10,'configuring colors')
    keys = list(self.default_colors_dict.keys()) ; keys.sort()
    for name in keys:
        # if name == 'operator': g.pdb()
        option_name,default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language,option_name)) or
            c.config.getColor(option_name) or
            default_color
        )
        if trace and traceColors: g.trace(option_name,color)

        # Must use foreground, not fg.
        try:
            w.tag_configure(name, foreground=color)
        except: # Recover after a user error.
            g.es_exception()
            w.tag_configure(name, foreground=default_color)

    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        w.tag_configure("link",underline=1) # defined
        w.tag_configure("name",underline=0) # undefined
    else:
        w.tag_configure("link",underline=0)
        if self.underline_undefined:
            w.tag_configure("name",underline=1)
        else:
            w.tag_configure("name",underline=0)

    self.configure_variable_tags()

    try:
        w.end_tag_configure()
    except AttributeError:
        pass
#@+node:ekr.20110605121601.18579: *7* configure_variable_tags
def configure_variable_tags (self):

    c = self.c ; w = self.w

    # g.trace()

    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80"),
        ("elide", None,                                   "yellow"),
    ):
        if self.showInvisibles:
            color = option_name and c.config.getColor(option_name) or default_color
        else:
            option_name,default_color = self.default_colors_dict.get(name,(None,None),)
            color = option_name and c.config.getColor(option_name) or ''
        try:
            w.tag_configure(name,background=color)
        except: # A user error.
            w.tag_configure(name,background=default_color)

    # Special case:
    if not self.showInvisibles:
        w.tag_configure("elide",elide="1")
#@+node:ekr.20110605121601.18580: *7* init (jeditColorizer)
def init (self,p,s):

    trace = False and not g.unitTesting

    if p: self.p = p.copy()
    self.all_s = s or ''

    if trace: g.trace('='*20,
        'tabwidth',self.c.tab_width,
        self.colorizer.language) #,g.callers(4))

    # State info.
    self.all_s = s
    self.global_i,self.global_j = 0,0
    self.global_offset = 0

    # These *must* be recomputed.
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.restartDict = {}
    self.init_mode(self.colorizer.language)
    self.clearState()
    self.showInvisibles = self.colorizer.showInvisibles
        # The show/hide-invisible commands changes this.

    # Used by matchers.
    self.prev = None
    if self.last_language != self.colorizer.language:
        # Must be done to support per-language @font/@color settings.
        self.configure_tags()
        self.last_language = self.colorizer.language
        
    self.configure_hard_tab_width() # 2011/10/04
#@+node:ekr.20110605121601.18581: *7* init_mode & helpers
def init_mode (self,name):

    '''Name may be a language name or a delegate name.'''

    trace = False and not g.unitTesting
    if not name: return False
    h = self.highlighter
    language,rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if bunch.language == 'unknown-language':
            if trace: g.trace('found unknown language')
            return False
        else:
            if trace: g.trace('found',language,rulesetName)
            self.initModeFromBunch(bunch)
            self.language_name = language # 2011/05/30
            return True
    else:
        if trace: g.trace(language,rulesetName)
        path = g.os_path_join(g.app.loadDir,'..','modes')
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        fileName = g.os_path_join(path,'%s.py' % (language))
        if g.os_path_exists(fileName):
            mode = g.importFromPath (language,path)
        else: mode = None

        if mode:
            # A hack to give modes/forth.py access to c.
            if hasattr(mode,'pre_init_mode'):
                mode.pre_init_mode(self.c)
        else:
            # Create a dummy bunch to limit recursion.
            self.modes [rulesetName] = self.modeBunch = g.Bunch(
                attributesDict  = {},
                defaultColor    = None,
                keywordsDict    = {},
                language        = 'unknown-language',
                mode            = mode,
                properties      = {},
                rulesDict       = {},
                rulesetName     = rulesetName,
                word_chars      = self.word_chars, # 2011/05/21
            )
            if trace: g.trace('***** No colorizer file: %s.py' % language)
            self.rulesetName = rulesetName
            self.language_name = 'unknown-language'
            return False
        self.colorizer.language = language
        self.rulesetName = rulesetName
        self.properties = hasattr(mode,'properties') and mode.properties or {}
        self.keywordsDict = hasattr(mode,'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName,{}) or {}
        self.setKeywords()
        self.attributesDict = hasattr(mode,'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
        # if trace: g.trace(rulesetName,self.attributesDict)
        self.setModeAttributes()
        self.rulesDict = hasattr(mode,'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
        # if trace: g.trace(self.rulesDict)
        self.addLeoRules(self.rulesDict)
        self.defaultColor = 'null'
        self.mode = mode
        self.modes [rulesetName] = self.modeBunch = g.Bunch(
            attributesDict  = self.attributesDict,
            defaultColor    = self.defaultColor,
            keywordsDict    = self.keywordsDict,
            language        = self.colorizer.language,
            mode            = self.mode,
            properties      = self.properties,
            rulesDict       = self.rulesDict,
            rulesetName     = self.rulesetName,
            word_chars      = self.word_chars, # 2011/05/21
        )
        # Do this after 'officially' initing the mode, to limit recursion.
        self.addImportedRules(mode,self.rulesDict,rulesetName)
        self.updateDelimsTables()
        initialDelegate = self.properties.get('initialModeDelegate')
        if initialDelegate:
            if trace: g.trace('initialDelegate',initialDelegate)
            # Replace the original mode by the delegate mode.
            self.init_mode(initialDelegate)
            language2,rulesetName2 = self.nameToRulesetName(initialDelegate)
            self.modes[rulesetName] = self.modes.get(rulesetName2)
            self.language_name = language2  # 2011/05/30
        else:
            self.language_name = language  # 2011/05/30
        return True
#@+node:ekr.20110605121601.18582: *8* nameToRulesetName
def nameToRulesetName (self,name):

    '''Compute language and rulesetName from name, which is either a language or a delegate name.'''

    if not name: return ''

    i = name.find('::')
    if i == -1:
        language = name
        rulesetName = '%s_main' % (language)
    else:
        language = name[:i]
        delegate = name[i+2:]
        rulesetName = self.munge('%s_%s' % (language,delegate))

    # if rulesetName == 'php_main': rulesetName = 'php_php'

    # g.trace(name,language,rulesetName)
    return language,rulesetName
#@+node:ekr.20110605121601.18583: *8* setKeywords
def setKeywords (self):

    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.'''

    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d [key] = 'leokeyword'

    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]

    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))

    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)

    # g.trace(self.colorizer.language,[str(z) for z in chars])

    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
#@+node:ekr.20110605121601.18584: *8* setModeAttributes
def setModeAttributes (self):

    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''

    d = self.attributesDict
    aList = (
        ('default',         'null'),
	    ('digit_re',        ''),
        ('escape',          ''), # New in Leo 4.4.2.
	    ('highlight_digits',True),
	    ('ignore_case',     True),
	    ('no_word_sep',     ''),
    )

    # g.trace(d)

    for key, default in aList:
        val = d.get(key,default)
        if val in ('true','True'): val = True
        if val in ('false','False'): val = False
        setattr(self,key,val)
        # g.trace(key,val)
#@+node:ekr.20110605121601.18585: *8* initModeFromBunch
def initModeFromBunch (self,bunch):

    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor   = bunch.defaultColor
    self.keywordsDict   = bunch.keywordsDict
    self.colorizer.language = bunch.language
    self.mode           = bunch.mode
    self.properties     = bunch.properties
    self.rulesDict      = bunch.rulesDict
    self.rulesetName    = bunch.rulesetName
    self.word_chars     = bunch.word_chars # 2011/05/21
#@+node:ekr.20110605121601.18586: *8* updateDelimsTables
def updateDelimsTables (self):

    '''Update g.app.language_delims_dict if no entry for the language exists.'''

    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')

    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment,startComment,endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment,endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None

    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.colorizer.language):
            d [self.colorizer.language] = delims
            # g.trace(self.colorizer.language,'delims:',repr(delims))
#@+node:ekr.20110605121601.18587: *7* munge
def munge(self,s):

    '''Munge a mode name so that it is a valid python id.'''

    valid = string.ascii_letters + string.digits + '_'

    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
#@+node:ekr.20110605121601.18588: *7* setFontFromConfig
def setFontFromConfig (self):

    c = self.c

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.color_tags_list = []
#@+node:ekr.20110605121601.18589: *6*  Pattern matchers
#@+node:ekr.20110605121601.18590: *7*  About the pattern matchers
@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise. In most cases, these methods colorize all
the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by
                        the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively
                        by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
#@+node:ekr.20110605121601.18591: *7* dump
def dump (self,s):

    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
#@+node:ekr.20110605121601.18592: *7* Leo rule functions
#@+node:ekr.20110605121601.18593: *8* match_at_color
def match_at_color (self,s,i):

    if self.trace_leo_matches: g.trace()

    seq = '@color'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        self.colorizer.flag = True # Enable coloring.
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,'leokeyword')
        self.clearState()
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18594: *8* match_at_language
def match_at_language (self,s,i):

    trace = (False or self.trace_leo_matches) and not g.unitTesting
    if trace: g.trace(i,repr(s))

    seq = '@language'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        j = i + len(seq)
        j = g.skip_ws(s,j)
        k = g.skip_c_id(s,j)
        name = s[j:k]
        ok = self.init_mode(name)
        if trace: g.trace(ok,name)
        if ok:
            self.colorRangeWithTag(s,i,k,'leokeyword')
        self.clearState()
        return k - i
    else:
        return 0
#@+node:ekr.20110605121601.18595: *8* match_at_nocolor & restarter
def match_at_nocolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i == 0 and not g.match(s,i,'@nocolor-') and g.match_word(s,i,'@nocolor'):
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20110605121601.18596: *9* restartNoColor
def restartNoColor (self,s):

    if self.trace_leo_matches: g.trace(repr(s))

    if g.match_word(s,0,'@color'):
        self.clearState()
    else:
        self.setRestart(self.restartNoColor)

    return len(s) # Always match everything.
#@+node:ekr.20110605121601.18597: *8* match_at_killcolor & restarter
def match_at_killcolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@killcolor'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartKillColor)
        return len(s) # Match everything.
    else:
        return 0

#@+node:ekr.20110605121601.18598: *9* restartKillColor
def restartKillColor(self,s):

    self.setRestart(self.restartKillColor)
    return len(s)+1
#@+node:ekr.20110605121601.18599: *8* match_at_nocolor_node & restarter
def match_at_nocolor_node (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@nocolor-node'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartNoColorNode)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20110605121601.18600: *9* restartNoColorNode
def restartNoColorNode(self,s):

    self.setRestart(self.restartNoColorNode)
    return len(s)+1
#@+node:ekr.20110605121601.18601: *8* match_blanks
def match_blanks (self,s,i):

    if not self.showInvisibles:
        return 0

    j = i ; n = len(s)

    while j < n and s[j] == ' ':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'blank')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18602: *8* match_doc_part & restarter
def match_doc_part (self,s,i):

    # New in Leo 4.5: only matches at start of line.
    if i != 0:
        return 0
    elif g.match_word(s,i,'@doc'):
        j = i + 4
    elif g.match(s,i,'@') and (i+1 >= len(s) or s[i+1] in (' ','\t','\n')):
        j = i + 1
    else:
        return 0

    self.colorRangeWithTag(s,i,j,'leokeyword')
    self.colorRangeWithTag(s,j,len(s),'docpart')
    self.setRestart(self.restartDocPart)

    return len(s)
#@+node:ekr.20110605121601.18603: *9* restartDocPart
def restartDocPart (self,s):

    for tag in ('@c','@code'):
        if g.match_word(s,0,tag):
            j = len(tag)
            self.colorRangeWithTag(s,0,j,'leokeyword') # 'docpart')
            self.clearState()
            return j
    else:
        self.setRestart(self.restartDocPart)
        self.colorRangeWithTag(s,0,len(s),'docpart')

        return len(s)
#@+node:ekr.20110605121601.18604: *8* match_leo_keywords
def match_leo_keywords(self,s,i):

    '''Succeed if s[i:] is a Leo keyword.'''

    # g.trace(i,g.get_line(s,i))

    self.totalLeoKeywordsCalls += 1

    if s[i] != '@':
        return 0

    # fail if something besides whitespace precedes the word on the line.
    i2 = i-1
    while i2 >= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ','\t'):
            i2 -= 1
        else:
            # g.trace('not a word 1',repr(ch))
            return 0

    # Get the word as quickly as possible.
    j = i+1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i+1:j] # entries in leoKeywordsDict do not start with '@'.

    if j < len(s) and s[j] not in (' ','\t','\n'):
        # g.trace('not a word 2',repr(word))
        return 0 # Fail, but allow a rescan, as in objective_c.

    if self.leoKeywordsDict.get(word):
        kind = 'leokeyword'
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j-i+1 # Bug fix: skip the last character.
        self.trace_match(kind,s,i,j)
        # g.trace('*** match',repr(s))
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s,i,j,kind)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            # g.trace('found',word)
            return j-i
        else:
            # g.trace('fail',repr(word),repr(self.word_chars))
            return -(j-i+1) # An important optimization.
#@+node:ekr.20110605121601.18605: *8* match_section_ref
def match_section_ref (self,s,i):

    if self.trace_leo_matches: g.trace()
    c = self.c ; p = c.currentPosition()
    w = self.w

    if not g.match(s,i,'<<'):
        return 0
    k = g.find_on_line(s,i+2,'>>')
    if k is not None:
        j = k + 2
        self.colorRangeWithTag(s,i,i+2,'namebrackets')
        ref = g.findReference(c,s[i:j],p)
        if ref:
            if self.use_hyperlinks:
                << set the hyperlink >>
            else:
                self.colorRangeWithTag(s,i+2,k,'link')
        else:
            self.colorRangeWithTag(s,i+2,k,'name')
        self.colorRangeWithTag(s,k,j,'namebrackets')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18606: *9* << set the hyperlink >>
# Set the bindings to vnode callbacks.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
ref.tagName = tagName
#@+node:ekr.20110605121601.18607: *8* match_tabs
def match_tabs (self,s,i):

    if not self.showInvisibles:
        return 0

    if self.trace_leo_matches: g.trace()

    j = i ; n = len(s)

    while j < n and s[j] == '\t':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'tab')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18608: *8* match_url_any/f/h  (new)
url_regex_f = re.compile(r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex   = re.compile(r"""(file|ftp|http|https)://[^\s'"]+[\w=/]""")

def match_any_url(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):

def match_url_f(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_f)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
    
def match_url_h(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_h)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
#@+node:ekr.20110605121601.18609: *7* match_compiled_regexp (new)
def match_compiled_regexp (self,s,i,kind,regexp,delegate=''):

    '''Succeed if the compiled regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    # if at_line_start and i != 0 and s[i-1] != '\n': return 0
    # if at_whitespace_end and i != g.skip_ws(s,0): return 0
    # if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_compiled_regexp_helper(s,i,regexp)
    if n > 0:
        j = i + n
        assert (j-i == n)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18610: *8* match_compiled_regexp_helper
def match_compiled_regexp_helper (self,s,i,regex):
    
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = regex.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    start, end = mo.start(), mo.end()
    if start != i:
        return 0
    # if trace:
        # g.trace('pattern',pattern)
        # g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
        # g.trace('groups',mo.groups())
    return end - start
#@+node:ekr.20110605121601.18611: *7* match_eol_span
def match_eol_span (self,s,i,
    kind=None,seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if seq matches s[i:]'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        return 0

    if g.match(s,i,seq):
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j # (was j-1) With a delegate, this could clear state.
    else:
        return 0
#@+node:ekr.20110605121601.18612: *7* match_eol_span_regexp
def match_eol_span_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if the regular expression regex matches s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,regexp)
    if n > 0:
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18613: *7* match_everything
# def match_everything (self,s,i,kind=None,delegate='',exclude_match=False):

    # '''Match the entire rest of the string.'''

    # j = len(s)
    # self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    # return j
#@+node:ekr.20110605121601.18614: *7* match_keywords
# This is a time-critical method.
def match_keywords (self,s,i):

    '''Succeed if s[i:] is a keyword.'''

    # trace = False
    self.totalKeywordsCalls += 1

    # Important.  Return -len(word) for failure greatly reduces
    # the number of times this method is called.

    # We must be at the start of a word.
    if i > 0 and s[i-1] in self.word_chars:
        # if trace: g.trace('not at word start',s[i-1])
        return 0

    # Get the word as quickly as possible.
    j = i ; n = len(s) ; chars = self.word_chars
    while j < n and s[j] in chars:
        j += 1

    word = s[i:j]
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j - i
        # if trace: g.trace('success',word,kind,j-i)
        self.trace_match(kind,s,i,j)
        return result
    else:
        # if trace: g.trace('fail',word,kind)
        return -len(word) # An important new optimization.
#@+node:ekr.20110605121601.18615: *7* match_line
def match_line (self,s,i,kind=None,delegate='',exclude_match=False):

    '''Match the rest of the line.'''

    j = g.skip_to_end_of_line(s,i)

    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    return j-i
#@+node:ekr.20110605121601.18616: *7* match_mark_following & getNextToken
def match_mark_following (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    trace = (True or self.verbose) and not g.unitTesting
    if not self.allow_mark_prev: return 0

    # if trace: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 < len(s) and s[i+len(pattern)] in self.word_chars:
        return 0 # 7/5/2008

    if g.match(s,i,pattern):
        j = i + len(pattern)
        # self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s,j)
        # 2011/05/31: Do not match *anything* unless there is a token following.
        if k > j:
            self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,k,kind,exclude_match=False)
            j = k
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            return j - i
        else:
            return 0
    else:
        return 0
#@+node:ekr.20110605121601.18617: *8* getNextToken
def getNextToken (self,s,i):

    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''
    
    # 2011/05/31: Might we extend the concept of token?
    # If s[i] is not a word char, should we return just it?

    while i < len(s) and s[i] in self.word_chars:
        i += 1

    # 2011/05/31: was i+1
    return min(len(s),i)
#@+node:ekr.20110605121601.18618: *7* match_mark_previous
def match_mark_previous (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''

    # This match was causing most of the syntax-color problems.
    return 0 # 2009/6/23
#@+node:ekr.20110605121601.18619: *7* match_regexp_helper
def match_regexp_helper (self,s,i,pattern):

    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    trace = False and not g.unitTesting
    if trace: g.trace('%-10s %-20s %s' % (
        self.colorizer.language,pattern,s)) # g.callers(1)

    try:
        flags = re.MULTILINE
        if self.ignore_case: flags|= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        # Do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = re_obj.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        if trace:
            g.trace('pattern',pattern)
            g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
            g.trace('groups',mo.groups())
        return end - start
#@+node:ekr.20110605121601.18620: *7* match_seq
def match_seq (self,s,i,
    kind='',seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if s[:] mathces seq.'''

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:  # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s,i,seq):
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
    else:
        j = i
    return j - i
#@+node:ekr.20110605121601.18621: *7* match_seq_regexp
def match_seq_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if the regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_regexp_helper(s,i,regexp)
    j = i + n
    assert (j-i == n)
    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    self.prev = (i,j,kind)
    self.trace_match(kind,s,i,j)
    return j - i
#@+node:ekr.20110605121601.18622: *7* match_span & helper & restarter
def match_span (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False,no_word_break=False):

    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''

    trace = False and not g.unitTesting
    if i >= len(s): return 0

    # g.trace(begin,end,no_escape,no_line_break,no_word_break)

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:
        j = i
    elif at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        j = i
    elif not g.match(s,i,begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s,i+len(begin),end,
            no_escape,no_line_break,no_word_break=no_word_break)
        # g.trace('** helper returns',j,len(s))
        if j == -1:
            j = i # A real failure.
        else:
            # A match
            i2 = i + len(begin) ; j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(s,i,i2,kind,delegate=None,    exclude_match=exclude_match)
                self.colorRangeWithTag(s,i2,j,kind,delegate=delegate,exclude_match=exclude_match)
                self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
            j = j2
            self.prev = (i,j,kind)

    self.trace_match(kind,s,i,j)

    if j > len(s):
        j = len(s) + 1
        def boundRestartMatchSpan(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Continuing',kind,i,j,len(s))
    elif j != i:
        if trace: g.trace('***Ending',kind,i,j,s[i:j])
        self.clearState()

    return j - i # Correct, whatever j is.
#@+node:ekr.20110605121601.18623: *8* match_span_helper
def match_span_helper (self,s,i,pattern,no_escape,no_line_break,no_word_break):

    '''Return n >= 0 if s[i] ends with a non-escaped 'end' string.'''

    esc = self.escape

    while 1:
        j = s.find(pattern,i)
        # g.trace(no_line_break,j,len(s))
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s)+1
        elif no_word_break and j > 0 and s[j-1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i:j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == esc:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # Continue searching past the escaped pattern string.
                i = j + len(pattern) # Bug fix: 7/25/07.
                # g.trace('escapes',escapes,repr(s[i:]))
            else:
                return j
        else:
            return j
#@+node:ekr.20110605121601.18624: *8* restart_match_span
def restart_match_span (self,s,
    delegate,end,exclude_match,kind,
    no_escape,no_line_break,no_word_break):

    '''Remain in this state until 'end' is seen.'''

    trace = False and not g.unitTesting

    i = 0
    j = self.match_span_helper(s,i,end,no_escape,no_line_break,no_word_break)
    if j == -1:
        j2 = len(s)+1
    elif j > len(s):
        j2 = j
    else:
        j2 = j + len(end)

    if delegate:
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
    else: # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
    j = j2

    self.trace_match(kind,s,i,j)

    if j > len(s):
        def boundRestartMatchSpan(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Re-continuing',i,j,len(s),s,g.callers(5))
    else:
        if trace: g.trace('***ending',i,j,len(s),s)
        self.clearState()

    return j # Return the new i, *not* the length of the match.
#@+node:ekr.20110605121601.18625: *7* match_span_regexp
def match_span_regexp (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False, no_word_break=False,
):

    '''Succeed if s[i:] starts with 'begin' (a regular expression) and contains a following 'end'.'''

    if self.verbose: g.trace('begin',repr(begin),'end',repr(end),self.dump(s[i:]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n > 0:
        j = i + n
        j2 = s.find(end,j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == self.escape:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s,i,j,kind, delegate=None,     exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,i2,kind, delegate=delegate,exclude_match=False)
            self.colorRangeWithTag(s,i2,j2,kind,delegate=None,    exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j2)
        return j2 - i
    else: return 0
#@+node:ekr.20110605121601.18626: *7* match_word_and_regexp
def match_word_and_regexp (self,s,i,
    kind1='',word='',
    kind2='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    if not self.allow_mark_prev: return 0

    if (False or self.verbose): g.trace(i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0
    if at_word_start and i + len(word) + 1 < len(s) and s[i+len(word)] in self.word_chars:
        j = i

    if not g.match(s,i,word):
        return 0

    j = i + len(word)
    n = self.match_regexp_helper(s,j,pattern)
    if n == 0:
        return 0
    self.colorRangeWithTag(s,i,j,kind1,exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s,j,k,kind2,exclude_match=False)    
    self.prev = (j,k,kind2)
    self.trace_match(kind1,s,i,j)
    self.trace_match(kind2,s,j,k)
    return k - i
#@+node:ekr.20110605121601.18627: *7* skip_line
def skip_line (self,s,i):

    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i < len(s):
            j = g.skip_line(s,i)
            if not g.match(s,j-n,escape):
                return j
            # g.trace('escape',s[i:j])
            i = j
        return i
    else:
        return g.skip_line(s,i)
            # Include the newline so we don't get a flash at the end of the line.
#@+node:ekr.20110605121601.18628: *7* trace_match
def trace_match(self,kind,s,i,j):

    if j != i and self.trace_match_flag:
        g.trace(kind,i,j,g.callers(2),self.dump(s[i:j]))
#@+node:ekr.20110605121601.18629: *6*  State methods
#@+node:ekr.20110605121601.18630: *7* clearState
def clearState (self):

    self.setState(-1)
#@+node:ekr.20110605121601.18631: *7* computeState
def computeState (self,f,keys):

    '''Compute the state name associated with f and all the keys.

    Return a unique int n representing that state.'''

    # Abbreviate arg names.
    d = {
        'delegate':'del:',
        'end':'end',
        'at_line_start':'line-start',
        'at_whitespace_end':'ws-end',
        'exclude_match':'exc-match',
        'no_escape':'no-esc',
        'no_line_break':'no-brk',
        'no_word_break':'no-word-brk',
    }
    result = [
        f.__name__,
        self.colorizer.language,
        self.rulesetName]
    for key in keys:
        keyVal = keys.get(key)
        val = d.get(key)
        if val is None:
            val = keys.get(key)
            result.append('%s=%s' % (key,val))
        elif keyVal is True:
            result.append('%s' % val)
        elif keyVal is False:
            pass
        elif keyVal not in (None,''):
            result.append('%s=%s' % (key,keyVal))
    state = ';'.join(result)

    n = self.stateNameToStateNumber(f,state)
    return n
#@+node:ekr.20110605121601.18632: *7* currentState and prevState
def currentState(self):

    return self.highlighter.currentBlockState()

def prevState(self):

    return self.highlighter.previousBlockState()
#@+node:ekr.20110605121601.18633: *7* setRestart
def setRestart (self,f,**keys):

    n = self.computeState(f,keys)
    self.setState(n)
#@+node:ekr.20110605121601.18634: *7* setState
def setState (self,n):

    trace = False and not g.unitTesting

    self.highlighter.setCurrentBlockState(n)

    if trace:
        stateName = self.showState(n)
        g.trace(stateName,g.callers(4))
#@+node:ekr.20110605121601.18635: *7* showState & showCurrentState
def showState (self,n):

    if n == -1: 
        return 'default-state'
    else:
        return self.stateDict.get(n,'<no state>')

def showCurrentState(self):

    n = self.currentState()
    return self.showState(n)

def showPrevState(self):

    n = self.prevState()
    return self.showState(n)
#@+node:ekr.20110605121601.18636: *7* stateNameToStateNumber
def stateNameToStateNumber (self,f,stateName):

    # stateDict:     Keys are state numbers, values state names.
    # stateNameDict: Keys are state names, values are state numbers.
    # restartDict:   Keys are state numbers, values are restart functions

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.stateNameDict[stateName] = n
        self.stateDict[n] = stateName
        self.restartDict[n] = f
        self.nextState += 1
        # g.trace('========',n,stateName)

    return n
#@+node:ekr.20110605121601.18637: *6* colorRangeWithTag
def colorRangeWithTag (self,s,i,j,tag,delegate='',exclude_match=False):

    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''

    trace = False and not g.unitTesting
        # A superb trace: enable this first to see what gets colored.

    # Pattern matcher may set the .flag ivar.
    if self.colorizer.killColorFlag or not self.colorizer.flag:
        if trace: g.trace('disabled')
        return

    if delegate:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (delegate,tag)),i,j,s2,g.callers(2)))
        # self.setTag(tag,s,i,j) # 2011/05/31: Do the initial color.
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 <= i < j and i < len(s):
            progress = i
            assert j >= 0,j
            for f in self.rulesDict.get(s[i],[]):
                n = f(self,s,i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n > 0:
                    # if trace: g.trace('delegate',delegate,i,n,f.__name__,repr(s[i:i+n]))
                    i += n ; break
            else:
                # New in Leo 4.6: Use the default chars for everything else.
                # New in Leo 4.8 devel: use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                # g.trace(default_tag)
                self.setTag(default_tag or tag,s,i,i+1)
                i += 1
            assert i > progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (self.language_name,tag)),i,j,s2,g.callers(2)))
        self.setTag(tag,s,i,j)
        
    if tag != 'url':
        # Allow URL's *everywhere*.
        j = min(j,len(s))
        while i < j:
            if s[i].lower() in 'fh': # file|ftp|http|https
                n = self.match_any_url(s,i)
                i += max(1,n)
            else:
                i += 1
#@+node:ekr.20110605121601.18638: *6* mainLoop & restart
def mainLoop(self,n,s):

    '''Colorize a *single* line s, starting in state n.'''

    trace = False and not g.unitTesting
    traceMatch = True
    traceState = True
    verbose = False
    
    if trace:
        if traceState:
            g.trace('%-30s' % ('** start: %s' % self.showState(n)),repr(s))
        else:
            g.trace(self.language_name,repr(s))
                # Called from recolor.

    i = 0
    if n > -1:
        i = self.restart(n,s,trace and traceMatch)
    if i == 0:
        self.setState(self.prevState())
        
    if False and trace:
        aList = self.rulesDict.get('<')
        for f in aList:
            g.trace(f.__name__)
        
        
    while i < len(s):
        progress = i
        functions = self.rulesDict.get(s[i],[])
        for f in functions:
            n = f(self,s,i)
            if n is None:
                g.trace('Can not happen: n is None',repr(f))
                break
            elif n > 0: # Success.
                if trace and traceMatch and f.__name__!='match_blanks':
                    g.trace('%-30s' % ('   match: %s' % (f.__name__,)),
                        repr(s[i:i+n]))
                # The match has already been colored.
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                if trace and traceMatch and verbose:
                    g.trace('fail: %-30s %s' % (
                        f.__name__,repr(s[i:i+n])))
                i += -n
                break # Stop searching the functions.
            else: # Fail. Try the next function.
                pass # Do not break or change i!
        else:
            i += 1
        assert i > progress

    # Don't even *think* about clearing state here.
    # We remain in the starting state unless a match happens.
    if trace and traceState:
        g.trace('%-30s' % ('** end:   %s' % self.showCurrentState()),repr(s))
#@+node:ekr.20110605121601.18639: *7* restart
def restart (self,n,s,traceMatch):

    f = self.restartDict.get(n)
    if f:
        i = f(s)
        fname = f.__name__
        if traceMatch:
            if i > 0:
                g.trace('** restart match',fname,s[:i])
            else:
                g.trace('** restart fail',fname,s)
    else:
        g.trace('**** no restart f')
        i = 0

    return i
#@+node:ekr.20110605121601.18640: *6* recolor
def recolor (self,s):

    '''Recolor a *single* line, s.'''

    trace = False and not g.unitTesting
    callers = False ; line = True ; state = True

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    if self.colorizer.changingText:
        return
    if not self.colorizer.flag:
        return

    # Get the previous state.
    n = self.prevState() # The state at the end of the previous line.
    if trace:
        if line and state:
            g.trace('%2s %s %s' % (n,self.showState(n),repr(s)))
        elif line:
            g.trace('%2s %s' % (n,repr(s)))
        if callers:
            # Called from colorize:rehightlight,highlightBlock
            g.trace(g.callers())

    if s.strip() or self.showInvisibles:
        self.mainLoop(n,s)
    else:
        self.setState(n) # Required
#@+node:ekr.20110605121601.18641: *6* setTag
def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting

    if i == j:
        if trace: g.trace('empty range')
        return

    w = self.w # A leoQTextEditWidget
    tag = tag.lower() # 2011/10/28
    colorName = w.configDict.get(tag)

    # Munge the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return

    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName,g.callers())

    underline = w.configUnderlineDict.get(tag)

    format = QtGui.QTextCharFormat()

    font = self.fonts.get(tag)
    if font:
        format.setFont(font)

    if trace:
        self.tagCount += 1
        g.trace(
            '%3s %3s %3s %9s %7s' % (i,j,len(s),font and id(font) or '<no font>',colorName),
            '%-10s %-25s' % (tag,s[i:j]),g.callers(2))

    if tag in ('blank','tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setFontUnderline(True)
    else:
        format.setForeground(color)

    self.highlighter.setFormat (i,j-i,format)

#@+node:ekr.20110605121601.18575: *5* defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
    
        # Used in Leo rules...
        
            # tag name      : option name
            'blank'         :'show_invisibles_space_font', # 2011/10/24.
            'docpart'       :'doc_part_font',
            'leokeyword'    :'leo_keyword_font',
            'link'          :'section_name_font',
            'name'          :'undefined_section_name_font',
            'namebrackets'  :'section_name_brackets_font',
            'tab'           : 'show_invisibles_tab_font', # 2011/10/24.
            'url'           : 'url_font',
        
        # Used by old colorizer.
        
            # 'bracketRange'   :'bracketRange_font', # Forth.
            # 'comment'       :'comment_font',
            # 'cwebName'      :'cweb_section_name_font',
            # 'keyword'       :'keyword_font',
            # 'latexBackground':'latex_background_font',
            # 'pp'            :'directive_font',
            # 'string'        :'string_font',
    
         # jEdit tags.
         
             # tag name     : option name
            'comment1'      :'comment1_font',
            'comment2'      :'comment2_font',
            'comment3'      :'comment3_font',
            'comment4'      :'comment4_font',
            #'default'       :'default_font',
            'function'      :'function_font',
            'keyword1'      :'keyword1_font',
            'keyword2'      :'keyword2_font',
            'keyword3'      :'keyword3_font',
            'keyword4'      :'keyword4_font',
            'keyword5'      :'keyword5_font',
            'label'         :'label_font',
            'literal1'      :'literal1_font',
            'literal2'      :'literal2_font',
            'literal3'      :'literal3_font',
            'literal4'      :'literal4_font',
            'markup'        :'markup_font',
            # 'nocolor' This tag is used, but never generates code.
            'null'          :'null_font',
            'operator'      :'operator_font',
    }
#@+node:ekr.20110605121601.18574: *5* defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
    
        # Used in Leo rules...
    
        # tag name      :( option name,                  default color),
        'blank'         :('show_invisibles_space_color', '#E5E5E5'), # gray90
        'docpart'       :('doc_part_color',              'red'),
        'leokeyword'    :('leo_keyword_color',           'blue'),
        'link'          :('section_name_color',          'red'),
        'name'          :('undefined_section_name_color','red'),
        'namebrackets'  :('section_name_brackets_color', 'blue'),
        'tab'           :('show_invisibles_tab_color',   '#CCCCCC'), # gray80
        'url'           :('url_color',                   'purple'),
        
        # Used by the old colorizer: to be removed.
        
        # 'bracketRange'   :('bracket_range_color',     'orange'), # Forth.
        # 'comment'        :('comment_color',           'red'),
        # 'cwebName'       :('cweb_section_name_color', 'red'),
        # 'keyword'        :('keyword_color',           'blue'),
        # 'latexBackground':('latex_background_color',  'white'),
        # 'pp'             :('directive_color',         'blue'),
        # 'string'         :('string_color',            '#00aa00'), # Used by IDLE.

        # jEdit tags.
        # tag name  :( option name,     default color),
        'comment1'  :('comment1_color', 'red'),
        'comment2'  :('comment2_color', 'red'),
        'comment3'  :('comment3_color', 'red'),
        'comment4'  :('comment4_color', 'red'),
        'function'  :('function_color', 'black'),
        'keyword1'  :('keyword1_color', 'blue'),
        'keyword2'  :('keyword2_color', 'blue'),
        'keyword3'  :('keyword3_color', 'blue'),
        'keyword4'  :('keyword4_color', 'blue'),
        'keyword5'  :('keyword5_color', 'blue'),
        'label'     :('label_color',    'black'),
        'literal1'  :('literal1_color', '#00aa00'),
        'literal2'  :('literal2_color', '#00aa00'),
        'literal3'  :('literal3_color', '#00aa00'),
        'literal4'  :('literal4_color', '#00aa00'),
        'markup'    :('markup_color',   'red'),
        'null'      :('null_color',     None), #'black'),
        'operator'  :('operator_color', None), #'black'),
    }
#@+node:ekr.20111104132424.9670: *4* Used common code to discover unit tests
@nocolor-node

Created findAllUnitTestNodes, used by createOutline & doTests.
#@+node:ekr.20111113141805.10061: *4* Eliminated the low-level interface
@nocolor-node

Only the high-level interface (baseTextWidget) used the low-level interface.
#@+node:ekr.20111114013726.9967: *4* Removed unused cruft from high-level interface
@nocolor-node

Removed the following unused methods::
    
    bind                c.bind also removed.
    configure
    cget
    event_generate      g.app.gui.event_generate does exist.
    getWidth
    indexIsVisible      Also removed for leoEditCommands: scrollHelper and measure.
    mark_set
    onChar              Fortunately, never used anywhere
    pack                Used only in Tk code
    scrollLines
    set_width           Removed do-nothing calls in Leo's core.
    tag_add             Removed do-nothing calls in qt colorizer.
    tag_bind            Removed do-nothing calls in qt colorizer.
    tag_delete          Removed do-nothing calls in qt colorizer.
    tag_names
    tag_ranges
    tag_remove
    update
    update_idletasks
    xyToPythonIndex
    yview
#@+node:ekr.20111112131605.9787: *4* Most unit tests may now be run externally
@nocolor-node

What I did:
    
- The nullGui now uses a fully capable string-based body widget.
- The nullGui now uses the regular undoer.
#@+node:ekr.20111113064104.9856: *5* Fixes
#@+node:ekr.20111113064104.9850: *6* Fixed baseTextWidget/leoFind.delete
# leoFind.delete probably needs the same fix.
#@+node:ekr.20070105102419: *7* setters (leoFind)
def delete(self,i,j=None):
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    else: j = self.toPythonIndex(j)
    self.s = self.s[:i] + self.s[j:]
    # Bug fix: 2011/11/13: Significant in external tests.
    self.i = i
    self.sel = i,i

def insert(self,i,s):
    if not s: return
    i = self.toPythonIndex(i)
    self.s = self.s[:i] + s + self.s[i:]
    self.i = i
    self.sel = i,i

def setAllText (self,s,new_p=None):
    self.s = s
    self.i = 0
    self.sel = 0,0

def setInsertPoint (self,i):
    self.i = i

def setSelectionRange (self,i,j,insert=None):
    self.sel = self.toPythonIndex(i),self.toPythonIndex(j)
    if insert is not None:
        self.i = self.toPythonIndex(insert)
#@+node:ekr.20110605121601.18079: *7* delete (avoid call to setAllText) (leoQTextEditWidget)
def delete(self,i,j=None):

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    if trace: g.trace(self.getSelectionRange())

    i = self.toGuiIndex(i)
    if j is None: j = i+1
    j = self.toGuiIndex(j)
    if i > j: i,j = j,i

    if trace: g.trace(i,j)

    # Set a hook for the colorer.
    colorer.initFlag = True

    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()

    try:
        self.changingText = True # Disable onTextChanged

        old_i,old_j = self.getSelectionRange()
        if i == old_i and j == old_j:
            # Work around an apparent bug in cursor.movePosition.
            cursor.removeSelectedText()
        elif i == j:
            pass
        else:
            # g.trace('*** using dubious code')
            cursor.setPosition(i)
            moveCount = abs(j-i)
            cursor.movePosition(cursor.Right,cursor.KeepAnchor,moveCount)
            w.setTextCursor(cursor)  # Bug fix: 2010/01/27
            if trace:
                i,j = self.getSelectionRange()
                g.trace(i,j)
            cursor.removeSelectedText()
            if trace: g.trace(self.getSelectionRange())
    finally:
        self.changingText = False

    sb.setSliderPosition(pos)

    # g.trace('%s calls to recolor' % (colorer.recolorCount-n))
#@+node:ekr.20110605121601.18191: *7* High-level interface (qtBody)
# The required high-level interface.
def appendText (self,s):                return self.widget.appendText(s)
def clipboard_append(self,s):           return self.widget.clipboard_append(s)
def clipboard_clear(self):              return self.widget.clipboard_append()
def delete(self,i,j=None):              self.widget.delete(i,j)
def deleteTextSelection (self):         return self.widget.deleteTextSelection()
def flashCharacter(self,i,
    bg='white',fg='red',
    flashes=3,delay=75):                return self.widget(i,bg,fg,flashes,delay)
def get(self,i,j=None):                 return self.widget.get(i,j)
def getAllText (self):                  return self.widget.getAllText()
def getFocus (self):                    return self.widget.getFocus()
def getInsertPoint(self):               return self.widget.getInsertPoint()
def getSelectedText (self):             return self.widget.getSelectedText()
def getSelectionRange(self):            return self.widget.getSelectionRange()
def getYScrollPosition (self):          return self.widget.getYScrollPosition()
def hasSelection (self):                return self.widget.hasSelection()
def insert(self,i,s):                   return self.widget.insert(i,s)
def replace (self,i,j,s):               self.widget.replace (i,j,s)
def rowColToGuiIndex (self,s,row,col):  return self.widget.rowColToGuiIndex(s,row,col)
def see(self,index):                    return self.widget.see(index)
def seeInsertPoint(self):               return self.widget.seeInsertPoint()
def selectAllText (self,insert=None):   self.widget.selectAllText(insert)
def setAllText (self,s,new_p=None):     return self.widget.setAllText(s,new_p=new_p)
def setBackgroundColor (self,color):    return self.widget.setBackgroundColor(color)
def setFocus (self):                    return self.widget.setFocus()
def setForegroundColor (self,color):    return self.widget.setForegroundColor(color)
def setInsertPoint (self,pos):          return self.widget.setInsertPoint(pos)
def setSelectionRange (self,i,j,insert=None):
    self.widget.setSelectionRange(i,j,insert=insert)
def setYScrollPosition (self,i):        return self.widget.setYScrollPosition(i)
def tag_configure(self,colorName,**keys):pass
def toPythonIndex(self,index):          return self.widget.toPythonIndex(index)
def toPythonIndexRowCol(self,index):    return self.widget.toPythonIndexRowCol(index)

set_focus = setFocus
toGuiIndex = toPythonIndex
#@+node:ekr.20070228074312.13: *7* delete (baseTextWidget)
def delete(self,i,j=None):

    i = self.toPythonIndex(i)
    if j is None: j = i+ 1
    j = self.toPythonIndex(j)
    
    # 2011/11/13: This allows subclasses to use this base class method.
    if i > j: i,j = j,i

    # g.trace(i,j,len(s),repr(s[:20]))
    s = self.getAllText()
    self.setAllText(s[:i] + s[j:])
    
    # Bug fix: 2011/11/13: Significant in external tests.
    self.setSelectionRange(i,i,insert=i)
#@+node:ekr.20070228074312.14: *7* deleteTextSelection (baseTextWidget)
def deleteTextSelection (self):

    i,j = self.getSelectionRange()
    self.delete(i,j)
#@+node:ekr.20111113064104.9851: *6* Fixed end-of-line when run externally
#@+node:ekr.20100109094541.6231: *7* moveWithinLineHelper
def moveWithinLineHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    # g.trace(hasattr(w,'leoMoveCursorHelper'))

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        if g.app.trace_scroll: g.trace('seeInsertPoint',spot)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,j = g.getLine(s,ins)
        if spot == 'start-line':
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'end-line':
            # Bug fix: 2011/11/13: Significant in external tests.
            if g.match(s,j-1,'\n'): j -= 1
            self.moveToHelper(event,j,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@+node:ekr.20111113064104.9853: *6* Fixed findWordInLine
#@+node:ekr.20080408060320.1: *7* findWordHelper
def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            g.choose(oneLine,'in line ','')))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg ; w = self.w ; c = k.c
        if ch:
            i = w.getInsertPoint()
            s = w.getAllText()
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            else:
                end = len(s)

            while i < end:
                i = s.find(ch,i+1,end) # Ensure progress and i > 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break

        k.resetLabel()
        k.clearState()
#@+node:ekr.20111113064104.9855: *6* Fixed scrollHelper for external tests
#@+node:ekr.20060113082917: *7* scrollHelper (leoEditCommands)
def scrollHelper (self,event,direction,distance):

    '''Scroll the present pane up or down one page
    kind is in ('up/down-half-page/line/page)'''

    k = self.k ; c = k.c ; gui = g.app.gui
    w = event and event.w
    if not w: return

    if hasattr(w,'scrollDelegate'):
        kind = direction + '-' + distance
        w.scrollDelegate(kind)
#@+node:ekr.20111113064104.9857: *6* fixed nullFindTab problems
#@+node:ekr.20061212084717: *7* class leoFind
class leoFind:

    """The base class for Leo's Find commands."""

    @others
#@+node:ekr.20031218072017.3053: *8* leoFind.__init__ & helpers
def __init__ (self,c,title=None):

    self.c = c
    self.trace = False

    # g.trace('leoFind',c)

    # Spell checkers use this class, so we can't always compute a title.
    if title:
        self.title = title
    else:
        << compute self.title >>

    << init the gui-independent ivars >>

def init (self,c):
    self.oops()
#@+node:ekr.20041121145452: *9* << compute self.title >>
if not c.mFileName:
    s = "untitled"
else:
    path,s = g.os_path_split(c.mFileName)

self.title = "Find/Change for %s" %  s
#@+node:ekr.20031218072017.3054: *9* << init the gui-independent ivars >>
self.backwardAttempts = 0
self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False
self.re_obj = None

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated by update_ivars just before doing any find.
@c

<< do dummy initialization to keep Pychecker happy >>

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = searchWidget() # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@
Initializing a wrapped search is tricky. The search() method will fail
if p==wrapPosition and pos >= wrapPos. selectNextPosition() will fail
if p == wrapPosition. We set wrapPos on entry, before the first
search. We set wrapPosition in selectNextPosition after the first
search fails. We also set wrapPosition on exit if the first search
suceeds.

2011/06/13: wrapPosition must be reset when the find pattern changes.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
#@+node:ekr.20050123164539: *10* << do dummy initialization to keep Pychecker happy >>
if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.wrap = None
    self.whole_word = None

if 1:
    self.change_ctrl = None
    self.find_ctrl = None
    self.frame = None
    self.svarDict = {}
#@+node:ekr.20060123065756.1: *8* Top Level Buttons
#@+node:ekr.20031218072017.3057: *9* changeAllButton
# The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_change:
        self.doChangeAllScript()
    else:
        self.changeAll()
#@+node:ekr.20031218072017.3056: *9* changeButton
# The user has pushed the "Change" button from the find panel.

def changeButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
    else:
        self.change()
#@+node:ekr.20031218072017.3058: *9* changeThenFindButton
# The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
        if self.script_search:
            self.doFindScript()
        else:
            self.findNext()
    else:
        if self.script_search:
            self.change()
            self.doFindScript()
        else:
            self.changeThenFind()
#@+node:ekr.20031218072017.3060: *9* findAllButton
# The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    else:
        self.findAll()
#@+node:ekr.20031218072017.3059: *9* findButton
# The user has pushed the "Find" button from the find panel.

def findButton(self):

    self.setup_button()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
#@+node:ekr.20031218072017.3065: *9* setup_button
# Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

    c = self.c
    self.p = c.p

    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()

    self.update_ivars()
#@+node:ekr.20031218072017.3055: *8* Top Level Commands
#@+node:ekr.20031218072017.3061: *9* changeCommand
# The user has selected the "Replace" menu item.

def changeCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
    else:
        self.change()
#@+node:ekr.20031218072017.3062: *9* changeThenFindCommand
# The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
        self.doFindScript()
    else:
        self.changeThenFind()
#@+node:ekr.20051013084200.1: *9* dismiss: defined in subclass class
def dismiss (self):
    pass
#@+node:ekr.20031218072017.3063: *9* findNextCommand
# The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
#@+node:ekr.20031218072017.3064: *9* findPreviousCommand
# The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

    self.setup_command()

    self.reverse = not self.reverse

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()

    self.reverse = not self.reverse
#@+node:EKR.20040503070514: *9* handleUserClick
def handleUserClick (self,p):

    """Reset suboutline-only search when the user clicks a headline."""

    try:
        if self.c and self.suboutline_only:
            # g.trace(p)
            self.onlyPosition = p.copy()
    except: pass
#@+node:ekr.20031218072017.3066: *9* setup_command
# Initializes a search when a command is invoked from the menu.

def setup_command(self):

    # g.trace('leoFind')

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()

    self.update_ivars()
#@+node:ekr.20031218072017.3067: *8* Find/change utils
#@+node:ekr.20031218072017.2293: *9* batchChange (sets start of change-all group)
@ This routine performs a single batch change operation, updating the
head or body string of p and leaving the result in s_ctrl. We update
the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text
on exit. pos and pos2 indicate the selection. The selection will never
be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; w = self.s_ctrl
    # Replace the selection with self.change_text
    if pos1 > pos2: pos1,pos2=pos2,pos1
    s = w.getAllText()
    if pos1 != pos2: w.delete(pos1,pos2)
    w.insert(pos1,self.change_text)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+len(self.change_text))
    w.setSelectionRange(insert,insert)
    w.setInsertPoint(insert)
    # Update the node
    s = w.getAllText() # Used below.
    if self.in_headline:
        << change headline >>
    else:
        << change body >>
#@+node:ekr.20031218072017.2294: *10* << change headline >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.h:

    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Headline',undoData)
#@+node:ekr.20031218072017.2295: *10* << change body >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.b:

    undoData = u.beforeChangeNodeContents(p)

    c.setBodyString(p,s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Body',undoData)
#@+node:ekr.20031218072017.3068: *9* change
def change(self,event=None):

    if self.checkArgs():
        self.initInHeadline()
        self.changeSelection()
#@+node:ekr.20031218072017.3069: *9* changeAll (leoFind)
def changeAll(self):

    # g.trace('leoFind',g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.p
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    u.beforeChangeGroup(current,undoType)
    while 1:
        pos1, pos2 = self.findNextMatch()
        if pos1 is None: break
        count += 1
        self.batchChange(pos1,pos2)
        s = w.getAllText()
        i,j = g.getLine(s,pos1)
        line = s[i:j]
        # self.printLine(line,allFlag=True)
    p = c.p
    u.afterChangeGroup(p,undoType,reportFlag=True)
    g.es("changed:",count,"instances")
    c.redraw(p)
    self.restore(saveData)
#@+node:ekr.20031218072017.3070: *9* changeSelection
# Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p
    bodyCtrl = c.frame.body and c.frame.body.bodyCtrl
    w = g.choose(self.in_headline,c.edit_widget(p),bodyCtrl)
    if not w:
        self.in_headline = False
        w = bodyCtrl
    if not w: return

    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start > end: start,end = end,start
    if start == end:
        g.es("no text selected") ; return False

    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text

    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    if self.mark_changes:
        p.setMarked()
    if self.in_headline:
        c.frame.tree.onHeadChanged(p,'Change')
    else:
        c.frame.body.onBodyChanged('Change',oldSel=oldSel)

    c.frame.tree.drawIcon(p) # redraw only the icon.

    return True
#@+node:ekr.20060526201951: *10* makeRegexSubs
def makeRegexSubs(self,s,groups):

    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''

    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j < n:
        k = s.find('\\',j)
        if k == -1 or k + 1 >= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn < len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
#@+node:ekr.20031218072017.3071: *9* changeThenFind
def changeThenFind(self):

    if not self.checkArgs():
        return

    self.initInHeadline()
    if self.changeSelection():
        self.findNext(False) # don't reinitialize
#@+node:ekr.20031218072017.2417: *9* doChange...Script
def doChangeScript (self):

    g.app.searchDict["type"] = "change"
    self.runChangeScript()

def doChangeAllScript (self):

    """The user has just pressed the Change All button with script-change box checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "changeAll"
    while 1:
        self.runChangeScript()
        if not g.app.searchDict.get("continue"):
            break

def runChangeScript (self):

    try:
        assert(self.script_change)
        exec(self.change_text,{},{})
    except Exception:
        g.es("exception executing change script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
#@+node:ekr.20031218072017.3072: *9* doFind...Script
def doFindScript (self):

    g.app.searchDict["type"] = "find"
    self.runFindScript()

def doFindAllScript (self):

    """The user has just pressed the Find All button with script-find radio button checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "findAll"
    while 1:
        self.runFindScript()
        if not g.app.searchDict.get("continue"):
            break

def runFindScript (self):

    try:
        exec(self.find_text,{},{})
    except:
        g.es("exception executing find script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
#@+node:ekr.20031218072017.3073: *9* findAll & helper
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    skip = {} # Nodes that should be skipped.
        # Keys are vnodes, values not important.
    count,found = 0,None
    while 1:
        pos, newpos = self.findNextMatch() # sets self.p.
        if pos is None: break
        if self.clone_find_all and self.p.v in skip:
            continue
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if self.clone_find_all:
            if not skip:
                undoData = u.beforeInsertNode(c.p)
                found = self.createCloneFindAllNode()
            # Don't look at the node or it's descendants.
            for p2 in self.p.self_and_subtree():
                skip[p2.v] = True
            # Create a clone of self.p under the find node.
            p2 = self.p.clone()
            p2.moveToLastChildOf(found)
        else:
            self.printLine(line,allFlag=True)

    if self.clone_find_all and skip:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")
#@+node:ekr.20051113110735: *10* createCloneFindAllNode
def createCloneFindAllNode(self):
    
    c = self.c
    oldRoot = c.rootPosition()
    found = oldRoot.insertAfter()
    found.moveToRoot(oldRoot)
    c.setHeadString(found,'Found: ' + self.find_text)
    return found
#@+node:ekr.20031218072017.3074: *9* findNext
def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos is None:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found","'%s'" % (self.find_text))
        self.restore(data)
    else:
        self.showSuccess(pos,newpos)
#@+node:ekr.20031218072017.3075: *9* findNextMatch
# Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    trace = False and not g.unitTesting
    c = self.c ; p = self.p

    if trace: g.trace('entry','p',p and p.h,
        'search_headline',self.search_headline,
        'search_body',self.search_body)

    if not self.search_headline and not self.search_body:
        if trace: g.trace('nothing to search')
        return None, None

    if len(self.find_text) == 0:
        if trace: g.trace('no find text')
        return None, None

    self.errors = 0
    attempts = 0
    self.backwardAttempts = 0

    # New in Leo 4.4.8: precompute the regexp for regexHelper.
    if self.pattern_match:
        try: # Precompile the regexp.
            flags = re.MULTILINE
            if self.ignore_case: flags |= re.IGNORECASE
            # New in Leo 4.5: escape the search text.
            b,s = '\\b',self.find_text
            if self.whole_word:
                if not s.startswith(b): s = b + s
                if not s.endswith(b): s = s + b
            # g.trace(self.whole_word,repr(s))
                
            self.re_obj = re.compile(s,flags)
            # self.re_obj = re.compile(re.escape(self.find_text),flags)
        except Exception:
            g.es('invalid regular expression:',self.find_text,color='blue')
            self.errors += 1 # Abort the search.
            return None,None

    while p:
        pos, newpos = self.search()
        if trace: g.trace('attempt','pos',pos,'p',p.h,'in_headline',self.in_headline)
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            if trace: g.trace('success',pos,newpos)
            return pos, newpos
        elif self.errors:
            g.trace('find errors')
            return None,None # Abort the search.
        elif self.node_only:
            # Bug fix: 2009-5-31.
            # Attempt to switch from headline to body.
            if self.in_headline:
                self.in_headline = False
                self.initNextText()
            else: 
                if trace: g.trace('fail: node only')
                return None,None # We are only searching one node.
        else:
            if trace: g.trace('failed attempt',p)
            attempts += 1
            p = self.p = self.selectNextPosition()

    if trace: g.trace('attempts',attempts,'backwardAttempts',self.backwardAttempts)
    return None, None
#@+node:ekr.20031218072017.3076: *9* resetWrap
def resetWrap (self,event=None):

    self.wrapPosition = None
    self.onlyPosition = None
#@+node:ekr.20031218072017.3077: *9* search & helpers
def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.

    Returns (pos, newpos) or (None,None)."""

    trace = False and not g.unitTesting
    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()
    s = w.getAllText()

    if trace: g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)

    if trace: g.trace('pos,newpos',pos,newpos)
    if pos == -1:
        if trace: g.trace('** pos is -1',pos,newpos)
        return None,None
    << fail if we are passed the wrap point >>
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)

    if trace: g.trace('** returns',pos,newpos)
    return pos,newpos
#@+node:ekr.20060526140328: *10* << fail if we are passed the wrap point >>
if self.wrapping and self.wrapPos is not None and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos < self.wrapPos:
        if trace: g.trace("** reverse wrap done",pos,newpos)
        return None, None

    if not self.reverse and newpos > self.wrapPos:
        if trace: g.trace('** wrap done',pos,newpos)
        return None, None
#@+node:ekr.20060526081931: *10* searchHelper & allies
def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):

    trace = self.trace

    if swapij and backwards: i,j = j,i

    if trace: g.trace('back,nocase,regexp,word,',
        backwards,nocase,regexp,word,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        if trace: g.trace('empty',i,j,'len(s)',len(s),'pattern',pattern)
        return -1,-1

    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    if trace: g.trace('returns',pos,newpos)
    return pos,newpos
#@+node:ekr.20060526092203: *11* regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):

    re_obj = self.re_obj # Use the pre-compiled object
    if not re_obj:
        g.trace('can not happen: no re_obj')
        return -1,-1

    if backwards: # Scan to the last match.  We must use search here.
        last_mo = None ; i = 0
        while i < len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1 ; last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)

    if 0:
        g.trace('i',i,'j',j,'s[i:j]',repr(s[i:j]),
            'mo.start',mo and mo.start(),'mo.end',mo and mo.end())

    while mo and 0 <= i < len(s):
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 <= i < len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
#@+node:ekr.20060526140744: *11* backwardsHelper
debugIndices = []

@
rfind(sub [,start [,end]])

Return the highest index in the string where substring sub is found, such that
sub is contained within s[start,end]. Optional arguments start and end are
interpreted as in slice notation. Return -1 on failure.
@c

def backwardsHelper (self,s,i,j,pattern,nocase,word):

    debug = False
    if nocase:
        s = s.lower() ; pattern = pattern.lower() # Bug fix: 10/5/06: At last the bug is found!
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)

    if i < 0 or i > len(s) or j < 0 or j > len(s):
        g.trace('bad index: i = %s, j = %s' % (i,j))
        i = 0 ; j = len(s)

    if debug and (s and i == 0 and j == 0):
        g.trace('two zero indices')

    self.backwardAttempts += 1

    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        if debug:
            self.debugCount += 1
            if self.debugCount < 50:
                g.trace(i,j,'len(s)',len(s),self.p.h)
        return -1,-1

    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            if debug: g.trace('**word** %3s %3s %5s -> %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.h))
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        if debug: g.trace('%3s %3s %5s -> %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.h))
        if k == -1:
            return -1, -1
        else:
            return k,k+n
#@+node:ekr.20060526093531: *11* plainHelper
def plainHelper (self,s,i,j,pattern,nocase,word):

    trace = self.trace

    # if trace: g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if trace: g.trace(i,j,repr(s[i:i+20]))

    if nocase:
        s = s.lower() ; pattern = pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1:
                if trace: g.trace('no match word',i)
                return -1, -1
            elif self.matchWord(s,k,pattern):
                if trace: g.trace('match word',k)
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            if trace: g.trace('no match word',i)
            return -1, -1
        else:
            if trace: g.trace('match', k)
            return k, k + n
#@+node:ekr.20060526140744.1: *11* matchWord
def matchWord(self,s,i,pattern):

    trace = self.trace

    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        if trace: g.trace('empty')
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 <= i-1 < len(s) and s[i-1] or '.'
    ch2 = 0 <= i+n < len(s) and s[i+n] or '.'

    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)

    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))

    inWord = isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2
    if trace: g.trace('returns',not inWord)
    return not inWord

#@+node:ekr.20070105165924: *11* replaceBackSlashes
def replaceBackSlashes (self,s):

    '''Carefully replace backslashes in a search pattern.'''

    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.

    i = 0
    while i + 1 < len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1

    if self.trace: g.trace(repr(s))
    return s
#@+node:ekr.20031218072017.3081: *9* selectNextPosition
# Selects the next node to be searched.

def selectNextPosition(self):

    trace = False and not g.unitTesting
    c = self.c ; p = self.p

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        if trace: g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()

    # if trace: g.trace(p and p.h or 'None')

    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        if trace: g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
#@+node:ekr.20061212095134.1: *8* General utils
#@+node:ekr.20051020120306.26: *9* bringToFront (leoFind)
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; w = self.find_ctrl

    g.trace(g.callers(4))

    c.widgetWantsFocusNow(w)
    # g.app.gui.selectAllText(w)
    w.selectAllText()
    c.widgetWantsFocus(w)
#@+node:ekr.20061111084423.1: *9* oops (leoFind)
def oops(self):
    g.pr(("leoFind oops:",
        g.callers(10),"should be overridden in subclass"))
#@+node:ekr.20051020120306.27: *9* selectAllFindText (leoFind)
def selectAllFindText (self,event=None):

    # This is called only when the user presses ctrl-a in the find panel.

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        w.selectAllText()

    return # (for Tk) "break"
#@+node:ekr.20031218072017.3082: *8* Initing & finalizing
#@+node:ekr.20031218072017.3083: *9* checkArgs
def checkArgs (self):

    val = True
    if not self.search_headline and not self.search_body:
        g.es("not searching headline or body")
        val = False
    if len(self.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val
#@+node:ekr.20031218072017.3084: *9* initBatchCommands
# Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c
    self.in_headline = self.search_headline # Search headlines first.
    self.errors = 0

    # Select the first node.
    if self.suboutline_only or self.node_only:
        self.p = c.p
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p

    # Set the insert point.
    self.initBatchText()
#@+node:ekr.20031218072017.3085: *9* initBatchText, initNextText & init_s_ctrl
# Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self,ins=None):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.h, p.b)
    self.init_s_ctrl(s,ins)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self,ins=None):
    c,p = self.c,self.p
    s = g.choose(self.in_headline,p.h, p.b)
    if True:
        tree = c.frame and c.frame.tree
        if tree and hasattr(tree,'killEditing'):
            # g.trace('kill editing before find')
            tree.killEditing()
    self.init_s_ctrl(s,ins)

def init_s_ctrl (self,s,ins):

    w = self.s_ctrl
    w.setAllText(s)
    if ins is None:
        ins = g.choose(self.reverse,len(s),0)
        # print(g.choose(self.reverse,'.','*'),)
    else:
        pass # g.trace('ins',ins)
    w.setInsertPoint(ins)
#@+node:ekr.20031218072017.3086: *9* initInHeadline
# Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    trace = False
    c = self.c ; p = self.p

    # Do not change this without careful thought and extensive testing!
    if self.search_headline and self.search_body:
        # A temporary expedient.
        if self.reverse:
            self.in_headline = False
        else:
            editPosition = c.frame.tree.editPosition()
            focus = c.get_focus()
            # Search headline first.
            self.in_headline = (
                p == editPosition and
                focus != c.frame.body.bodyCtrl)
            if trace: g.trace(
                '** p: %s, editPosition: %s, focus: %s, bodyCtrl: %s' % (
                p and p.h,editPosition,focus, c.frame.body.bodyCtrl))
    else:
        self.in_headline = self.search_headline
#@+node:ekr.20031218072017.3087: *9* initInteractiveCommands
def initInteractiveCommands(self):

    c = self.c ; p = self.p
    bodyCtrl = c.frame.body and c.frame.body.bodyCtrl

    w = g.choose(self.in_headline,c.edit_widget(p),bodyCtrl)
    if not w:
        self.in_headline = False
        w = bodyCtrl
    if not w: return

    self.errors = 0

    # We only use the insert point, *never* the selection range.
    ins = w.getInsertPoint()
    # g.trace('ins',ins)
    self.debugCount = 0
    self.initNextText(ins=ins)
    c.widgetWantsFocus(w)

    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = ins
        # Do not set self.wrapPosition here: that must be done after the first search.
#@+node:ekr.20031218072017.3088: *9* printLine
def printLine (self,line,allFlag=False):

    both = self.search_body and self.search_headline
    context = self.batch # "batch" now indicates context

    if allFlag and both and context:
        g.es('','-' * 20,'',self.p.h)
        theType = g.choose(self.in_headline,"head: ","body: ")
        g.es('',theType + line)
    elif allFlag and context and not self.p.isVisited():
        # We only need to print the context once.
        g.es('','-' * 20,'',self.p.h)
        g.es('',line)
        self.p.setVisited()
    else:
        g.es('',line)
#@+node:ekr.20031218072017.3089: *9* restore
# Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data

    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    if p:
        c.selectPosition(p)
    else:
        c.selectPosition(c.rootPosition()) # New in Leo 4.5.

    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()

    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocus()
        c.k.showStateAndMode(c.frame.body.bodyCtrl)
    else:
        c.widgetWantsFocus(t)
#@+node:ekr.20031218072017.3090: *9* save (leoFind)
def save (self):

    c = self.c ; p = self.p

    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)

    if w:
        insert = w.getInsertPoint()
        sel = w.getSelectionRange()
        if len(sel) == 2:
            start,end = sel
        else:
            start,end = None,None
    else:
        insert,start,end = None,None,None

    return (self.in_headline,p,w,insert,start,end)
#@+node:ekr.20031218072017.3091: *9* showSuccess (leoFind)
def showSuccess(self,pos,newpos,showState=True):

    '''Display the result of a successful find operation.'''

    trace = False and not g.unitTesting
    c = self.c ; p = self.p
    if not p:
        return g.trace('can not happen: self.p is None')

    current = c.p
    c.frame.bringToFront() # Needed on the Mac

    # Expand ancestors and set redraw if a redraw is needed.
    redraw1 = not p.isVisible(c)
    if c.sparse_find:
        # Show only the 'sparse' tree when redrawing.
        for p2 in c.p.self_and_parents():
            if p2.isAncestorOf(p):
                break
            p2.contract()
            redraw1 = True # Important bug fix. Was redraw = True.

    redraw2 = c.expandAllAncestors(self.p)
    redraw = redraw1 or redraw2

    # Set state vars.
    # Ensure progress in backwards searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p

    if trace: g.trace('in_headline',self.in_headline)
    if self.in_headline:
        c.endEditing() # 2011/06/10: A major bug fix.
        selection = pos,newpos,insert
        c.redrawAndEdit(p,
            selection=selection,
            keepMinibuffer=True)
        w = c.edit_widget(p)
    else:
        w = c.frame.body.bodyCtrl
        # This is like the logic in c.selectPosition.
        if redraw:
            c.redraw(p)
        else:
            c.selectPosition(p)
            c.redraw_after_select(p)
        c.bodyWantsFocus()
        if showState:
            c.k.showStateAndMode(w)
        # g.trace(pos,newpos,insert)
        w.setSelectionRange(pos,newpos,insert=insert)
        w.seeInsertPoint()
        c.outerUpdate()
    return w # Support for isearch.
#@+node:ekr.20031218072017.1460: *9* update_ivars (leoFind)
# New in Leo 4.4.3: This is now gui-independent code.

def update_ivars (self):

    """Called just before doing a find to update ivars from the find panel."""

    trace = False and not g.unitTesting

    self.p = self.c.p
    self.v = self.p.v

    for key in self.intKeys:
        val = self.svarDict[key].get()
        # if trace: g.trace(self.svarDict.get(key),val)
        setattr(self, key, val) # No more _flag hack.

    # Set ivars from radio buttons. Convert these to 1 or 0.
    search_scope = self.svarDict["radio-search-scope"].get()
    # g.trace('radio-search-scope',search_scope)
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0)

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.getAllText()
    s = g.toUnicode(s)
    if trace: g.trace('find',repr(s),self.find_ctrl)
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
        
    # 2011/06/13: clear wrap_pos if the find_text changes.
    if s != self.find_text:
        # g.trace('clearing self.wrap_pos')
        self.wrapPosition = None
    self.find_text = s

    s = self.change_ctrl.getAllText()
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s)
    self.change_text = s
    if trace: g.trace('change',repr(s))
#@+node:ekr.20051020120306.6: *7* class findTab (leoFind)
class findTab (leoFind):

    '''An adapter class that implements Leo's Find tab.'''

    @others
#@+node:ekr.20051020120306.11: *8* __init__ & initGui
def __init__(self,c,parentFrame):

    # g.trace('findTab',c)

    # Init the base class...
    leoFind.__init__(self,c,title='Find Tab')

    self.c = c
    self.parentFrame = parentFrame
    self.frame = self.outerFrame = self.top = None

    self.optionsOnly = c.config.getBool('show_only_find_tab_options')

    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.initGui()
    self.createFrame(parentFrame)
    self.createBindings()
    self.init(c) # New in 4.3: init only once.
#@+node:ekr.20060221074900: *8* Callbacks
#@+node:ekr.20060221074900.1: *9* findButtonCallback
def findButtonCallback(self,event=None):

    self.findButton()
    return # (for Tk) 'break'
#@+node:ekr.20051020120306.25: *9* hideTab
def hideTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@+node:ekr.20051024192602: *8*  Top level
#@+node:ekr.20051024192642.3: *9* change/ThenFindCommand
def changeCommand (self,event=None):

    self.setup_command()
    self.change()

def changeThenFindCommand(self,event=None):

    self.setup_command()
    self.changeThenFind()
#@+node:ekr.20070105123638: *9* changeAllCommand
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
#@+node:ekr.20060128075225: *9* cloneFindAllCommand
def cloneFindAllCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@+node:ekr.20060204120158.1: *9* findAgainCommand
def findAgainCommand (self):

    s = self.find_ctrl.getAllText()

    if s and s != '<find pattern here>':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
#@+node:ekr.20060209064832: *9* findAllCommand
def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
#@+node:ekr.20051024192642.2: *9* findNext/PrefCommand
def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()

def findPrevCommand (self,event=None):

    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
#@+node:ekr.20061212092124: *8* Defined in subclasses
def createBindings (self):
    self.oops()

def createFrame (self,parent):
    self.oops()

def getOption (self,ivar):
    self.oops()

def init (self,c):
    self.oops()

def initGui (self):
    pass # Optional method.

def setOption (self,ivar,val):
    self.oops()

def toggleOption (self,ivar):
    self.oops()

# self.oops is defined in the leoFind class.
#@+node:ekr.20070302090616: *7* class nullFindTab class (findTab)
class nullFindTab (findTab):

    @others
#@+node:ekr.20070302090616.1: *8* Birth (nullFindTab)
#@+node:ekr.20070302090616.2: *9*  ctor (nullFindTab)
if 0: # Use the base class ctor.

    def __init__ (self,c,parentFrame):
    
        findTab.__init__(self,c,parentFrame)
        # Init the base class.
            # Calls initGui, createFrame, createBindings & init(c), in that order.
#@+node:ekr.20070302090616.3: *9* initGui (nullFindTab)
# Called from findTab.ctor.

def initGui (self):

    self.svarDict = {} # Keys are ivar names, values are svar objects.

    for key in self.intKeys:
        self.svarDict[key] = self.svar() # Was Tk.IntVar.

    for key in self.newStringKeys:
        self.svarDict[key] = self.svar() # Was Tk.StringVar.
        
    # Bug fix: 2011/11/13: significant for external unit tests.
    # Add the same hack as in the qtGui for the 'entire_outline' radio button.
    self.svarDict['entire-outline'] = self.svar()
#@+node:ekr.20070302090616.4: *9* init (nullFindTab)
# Called from findTab.ctor.

def init (self,c):

    # Separate c.ivars are much more convenient than a svarDict.
    for key in self.intKeys:
        # Get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0)
        svar = self.svarDict.get(key)
        if svar: svar.set(val)
        #g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
    << set checkboxes from ivars >>
#@+node:ekr.20070302090616.5: *10* << set find/change widgets >>
self.find_ctrl.delete(0,"end")
self.change_ctrl.delete(0,"end")

# Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@+node:ekr.20070302090616.6: *10* << set radio buttons from ivars >>
# In Tk, setting the var also sets the widget.
# Here, we do so explicitly.
d = self.widgetsDict
for ivar,key in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-find-type"].set(key)
        # w = d.get(key)
        # if w: w.set(True)
        break
else:
    self.svarDict["radio-find-type"].set("plain-search")

for ivar,key in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-search-scope"].set(key)
        break
else:
    key = ivar = 'entire-outline'
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-search-scope"].set(key)
    # self.svarDict["radio-search-scope"].set(key)
    # w = self.widgetsDict.get(key)
    # if w: w.set(True)
#@+node:ekr.20070302090616.7: *10* << set checkboxes from ivars >>
for ivar in (
    'ignore_case',
    'mark_changes',
    'mark_finds',
    'pattern_match',
    'reverse',
    'search_body',
    'search_headline',
    'whole_word',
    'wrap',
):
    # Bug fix: 2011/11/13: significant for external unit tests.
    svar = self.svarDict[ivar]
    if svar:
        svar.set(True)
        # w = self.widgetsDict.get(ivar)
        # if w: w.set(True)
#@+node:ekr.20070302090616.15: *9* createBindings
def createBindings (self):
    pass
#@+node:ekr.20070302090616.9: *9* createFrame
def createFrame (self,parentFrame):

    self.parentFrame = self.top = parentFrame

    self.createFindChangeAreas()
    self.createBoxes()
#@+node:ekr.20070302090616.10: *10* createFindChangeAreas
def createFindChangeAreas (self):

    c = self.c

    # A plainTextWidget must be a stringTextWidget
    plainTextWidget = g.app.gui.plainTextWidget

    import leo.core.leoFrame as leoFrame
    assert issubclass(plainTextWidget,leoFrame.stringTextWidget)

    self.find_ctrl   = plainTextWidget(c,name='find-text')
    self.change_ctrl = plainTextWidget(c,name='change-text')
#@+node:ekr.20070302090616.12: *10* createBoxes
def createBoxes (self):

    '''Create two columns of radio buttons & check boxes.'''

    c = self.c
    # f = self.parentFrame
    self.boxes = []
    self.widgetsDict = {} # Keys are ivars, values are checkboxes or radio buttons.

    data = ( # Leading star denotes a radio button.
        ('Whole &Word', 'whole_word',),
        ('&Ignore Case','ignore_case'),
        ('Wrap &Around','wrap'),
        ('&Reverse',    'reverse'),
        ('Rege&xp',     'pattern_match'),
        ('Mark &Finds', 'mark_finds'),
        ("*&Entire Outline","entire-outline"),
        ("*&Suboutline Only","suboutline-only"),  
        ("*&Node Only","node-only"),
        ('Search &Headline','search_headline'),
        ('Search &Body','search_body'),
        ('Mark &Changes','mark_changes'),
    )

    # Important: changing these controls merely changes entries in self.svarDict.
    # First, leoFind.update_ivars sets the find ivars from self.svarDict.
    # Second, self.init sets the values of widgets from the ivars.
    # inGroup = False
    for label,ivar in data:
        if label.startswith('*'):
            label = label[1:]
            w = self.buttonWidget(label)
            self.widgetsDict[ivar] = w
        else:
            w = self.buttonWidget(label)
            self.widgetsDict[ivar] = w
        self.boxes.append(w)
#@+node:ekr.20070302090616.14: *10* createButtons (not used)
def createButtons (self):

    '''Create two columns of buttons.'''
#@+node:ekr.20070302090616.8: *8* class svar (nullFindTab)
class svar:

    '''A class like Tk's IntVar and StringVar classes.'''

    def __init__(self):
        self.val = None
    def get (self):
        return self.val
    def set (self,val):
        self.val = val

    SetValue = set # SetValue is the wxWidgets spelling.
#@+node:ekr.20070302092907: *8* class buttonWidget (nullFindTab)
class buttonWidget:

    '''A class to simulate a Tk.Button.'''

    def __init__ (self,label):
        self.label = label
        self.val = False

    def __repr (self):
        return 'nullFindTab.buttonWidget: %s' % self.label

    def get (self):
        return self.val

    def set (self,val):
        self.val = val
#@+node:ekr.20070302090616.16: *8* Options
# This is the same as the Tk code because we simulate Tk svars.
#@+node:ekr.20070302090616.17: *9* getOption
def getOption (self,ivar):

    var = self.svarDict.get(ivar)

    if var:
        val = var.get()
        # g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
#@+node:ekr.20070302090616.18: *9* setOption
def setOption (self,ivar,val):

    trace = False and not g.unitTesting

    if ivar in self.intKeys:
        if val is not None:
            var = self.svarDict.get(ivar)
            var.set(val)
            if trace: g.trace('nullFindTab: %s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
#@+node:ekr.20070302090616.19: *9* toggleOption
def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
#@+node:ekr.20110605121601.18225: *7* class leoQtFindTab (findTab)
class leoQtFindTab (leoFind.findTab):

    '''A subclass of the findTab class containing all Qt Gui code.'''

    if 0: # We can use the base-class ctor.
        def __init__ (self,c,parentFrame):
            leoFind.findTab.__init__(self,c,parentFrame)
                # Init the base class.
                # Calls initGui, createFrame, createBindings & init(c), in that order.

    # Define these to suppress oops messages.
    def createBindings (self): pass
    def createFindTab (self,c,parentFrame): pass
    def createFrame (self,parentFrame): pass

    @others
#@+node:ekr.20110605121601.18226: *8*  Birth: called from leoFind ctor
# leoFind.__init__ calls initGui, createFrame, createBindings & init, in that order.
#@+node:ekr.20110605121601.18227: *9* initGui
def initGui (self):

    owner = self

    self.svarDict = {}
        # Keys are ivar names, values are svar objects.

    # Keys are option names; values are <svars>.
    for ivar in self.intKeys:
        self.svarDict[ivar] = self.svar(owner,ivar)
    
    # g.trace(self.svarDict)

    # Add a hack for 'entire_outline' radio button.
    ivar = 'entire_outline'
    self.svarDict[ivar] = self.svar(owner,ivar)

    for ivar in self.newStringKeys:
        # "radio-find-type", "radio-search-scope"
        self.svarDict[ivar] = self.svar(owner,ivar)
#@+node:ekr.20110605121601.18228: *9* init (qtFindTab) & helpers
def init (self,c):

    '''Init the widgets of the 'Find' tab.'''

    # g.trace('leoQtFindTab.init')

    self.createIvars()
    self.initIvars()
    self.initTextWidgets()
    self.initCheckBoxes()
    self.initRadioButtons()
#@+node:ekr.20110605121601.18229: *10* createIvars (qtFindTab)
def createIvars (self):

    c = self.c ; w = c.frame.top.leo_ui # A Window ui object.

    # Bind boxes to Window objects.
    self.widgetsDict = {} # Keys are ivars, values are Qt widgets.
    findWidget   = leoQLineEditWidget(w.findPattern,'find-widget',c)
    changeWidget = leoQLineEditWidget(w.findChange,'change-widget',c)
    data = (
        ('find_ctrl',       findWidget),
        ('change_ctrl',     changeWidget),
        ('whole_word',      w.checkBoxWholeWord),
        ('ignore_case',     w.checkBoxIgnoreCase),
        ('wrap',            w.checkBoxWrapAround),
        ## ('reverse',         w.checkBoxReverse),
        ('pattern_match',   w.checkBoxRegexp),
        ('mark_finds',      w.checkBoxMarkFinds),
        ('entire_outline',  w.checkBoxEntireOutline),
        ('suboutline_only', w.checkBoxSuboutlineOnly),  
        ('node_only',       w.checkBoxNodeOnly),
        ('search_headline', w.checkBoxSearchHeadline),
        ('search_body',     w.checkBoxSearchBody),
        ('mark_changes',    w.checkBoxMarkChanges),
        ('batch', None),
    )
    for ivar,widget in data:
        setattr(self,ivar,widget)
        self.widgetsDict[ivar] = widget
        # g.trace(ivar,widget)
#@+node:ekr.20110605121601.18230: *10* initIvars
def initIvars(self):

    c = self.c

    # Separate c.ivars are much more convenient than a svarDict.
    for ivar in self.intKeys:
        # Get ivars from @settings.
        val = c.config.getBool(ivar)
        setattr(self,ivar,val)
        val = g.choose(val,1,0)
        svar = self.svarDict.get(ivar)
        if svar:
            svar.set(val)

        # g.trace(ivar,val)
#@+node:ekr.20110605121601.18231: *10* initTextWidgets (qtFindTab)
def initTextWidgets(self):

    '''Init the find/change text areas.'''

    c = self.c

    table = (
        (self.find_ctrl,    "find_text",    '<find pattern here>'),
        (self.change_ctrl,  "change_text",  ''),
    )

    for w,setting,defaultText in table:
        # w is a textWrapper object
        w.setAllText(c.config.getString(setting) or defaultText)
#@+node:ekr.20110605121601.18232: *10* initCheckBoxes
def initCheckBoxes (self):

    for ivar,key in (
        ("pattern_match","pattern-search"),
    ):
        svar = self.svarDict[ivar].get()
        if svar:
            self.svarDict["radio-find-type"].set(key)
            w = self.widgetsDict.get(key)
            if w: w.setChecked(True)
            break
    else:
        self.svarDict["radio-find-type"].set("plain-search")

    aList = (
        'ignore_case','mark_changes','mark_finds',
        'pattern_match',
        # 'reverse',
        'search_body','search_headline',
        'whole_word','wrap',
        'node_only','suboutline_only','entire_outline',
    )

    for ivar in aList:
        svar = self.svarDict.get(ivar)
        if svar:
            # w is a QCheckBox or a QRadioButton.
            w = self.widgetsDict.get(ivar)
            if w:
                val = svar.get()
                svar.setWidget(w)
                svar.set(val)
                if isinstance(w,QtGui.QCheckBox):
                    def checkBoxCallback(val,svar=svar):
                        svar.set(val)
                    w.connect(w,
                        QtCore.SIGNAL("stateChanged(int)"),
                        checkBoxCallback)
                else:
                    def radioButtonCallback(val,svar=svar):
                        svar.set(val)
                    w.connect(w,
                        QtCore.SIGNAL("clicked(bool)"),
                        radioButtonCallback)
            else: g.trace('*** no w',ivar)
        else: g.trace('*** no svar',ivar)
#@+node:ekr.20110605121601.18233: *10* initRadioButtons
def initRadioButtons (self):

    scopeSvar = self.svarDict.get('radio-search-scope')

    table = (
        ("suboutline_only","suboutline-only"),
        ("node_only","node-only"))

    for ivar,key in table:
        svar = self.svarDict.get(ivar)
        if svar:
            val = svar.get()
            if val:
                scopeSvar.init(key)
                break
    else:
        scopeSvar.init('entire-outline')
        self.svarDict.get('entire_outline').init(True)

    w = self.widgetsDict.get(key)
    if w: w.setChecked(True)

    # g.trace(scopeSvar.get())
#@+node:ekr.20110605121601.18234: *8* class svar (qtFindTab)
class svar:
    '''A class like Tk's IntVar and StringVar classes.'''

    @others
#@+node:ekr.20110605121601.18235: *9* svar.ctor
def __init__(self,owner,ivar):

    self.ivar = ivar
    self.owner = owner
    self.radioButtons = ['node_only','suboutline_only','entire_outline']
    self.trace = False
    self.val = None
    self.w = None

def __repr__(self):
    return '<svar %s>' % self.ivar
#@+node:ekr.20110605121601.18236: *9* get
def get (self):

    trace = False and not g.unitTesting

    if self.w:
        val = self.w.isChecked()
        if trace:
            g.trace('qt svar %15s = %s' % (
                self.ivar,val),g.callers(5))        
    else:
        val = self.val
    return val
#@+node:ekr.20110605121601.18237: *9* init
def init (self,val):

    '''Init the svar, but do *not* init radio buttons.
    (This is called from initRadioButtons).'''

    trace = False and not g.unitTesting

    if val in (0,1):
        self.val = bool(val)
    else:
        self.val = val # Don't contain the scope values!

    if self.w:
        self.w.setChecked(bool(val))

    if trace: g.trace('qt svar %15s = %s' % (
        self.ivar,val),g.callers(5))
#@+node:ekr.20110605121601.18238: *9* set
def set (self,val):

    '''Init the svar and update the radio buttons.'''

    trace = False and not g.unitTesting
    if trace: g.trace(val)

    self.init(val)

    if self.ivar in self.radioButtons:
        self.owner.initRadioButtons()
    elif self.ivar == 'radio-search-scope':
        self.setRadioScope(val)


#@+node:ekr.20110605121601.18239: *9* setRadioScope
def setRadioScope (self,val):

    '''Update the svars corresponding to the scope value.'''

    table = (
        ("suboutline_only","suboutline-only"),
        ("node_only","node-only"),
        ("entire_outline","entire-outline"))

    for ivar,val2 in table:
        if val == val2:
            svar = self.owner.svarDict.get(ivar)
            val = svar.get()
            svar.init(True)
#@+node:ekr.20110605121601.18240: *9* setWidget
def setWidget(self,w):

    self.w = w
#@+node:ekr.20110605121601.18241: *8* Support for minibufferFind class (qtFindTab)
# This is the same as the Tk code because we simulate Tk svars.
#@+node:ekr.20110605121601.18242: *9* getOption
def getOption (self,ivar):

    var = self.svarDict.get(ivar)

    if var:
        val = var.get()
        # g.trace('ivar %s = %s' % (ivar,val))
        return val
    else:
        # g.trace('bad ivar name: %s' % ivar)
        return None
#@+node:ekr.20110605121601.18243: *9* setOption (findTab)
def setOption (self,ivar,val):

    trace = False and not g.unitTesting
    if trace: g.trace(ivar,val)

    if ivar in self.intKeys:
        if val is not None:
            svar = self.svarDict.get(ivar)
            svar.set(val)
            if trace: g.trace('qtFindTab: ivar %s = %s' % (
                ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
#@+node:ekr.20110605121601.18244: *9* toggleOption
def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
#@+node:ekr.20110605121601.18228: *7* init (qtFindTab) & helpers
def init (self,c):

    '''Init the widgets of the 'Find' tab.'''

    # g.trace('leoQtFindTab.init')

    self.createIvars()
    self.initIvars()
    self.initTextWidgets()
    self.initCheckBoxes()
    self.initRadioButtons()
#@+node:ekr.20110605121601.18229: *8* createIvars (qtFindTab)
def createIvars (self):

    c = self.c ; w = c.frame.top.leo_ui # A Window ui object.

    # Bind boxes to Window objects.
    self.widgetsDict = {} # Keys are ivars, values are Qt widgets.
    findWidget   = leoQLineEditWidget(w.findPattern,'find-widget',c)
    changeWidget = leoQLineEditWidget(w.findChange,'change-widget',c)
    data = (
        ('find_ctrl',       findWidget),
        ('change_ctrl',     changeWidget),
        ('whole_word',      w.checkBoxWholeWord),
        ('ignore_case',     w.checkBoxIgnoreCase),
        ('wrap',            w.checkBoxWrapAround),
        ## ('reverse',         w.checkBoxReverse),
        ('pattern_match',   w.checkBoxRegexp),
        ('mark_finds',      w.checkBoxMarkFinds),
        ('entire_outline',  w.checkBoxEntireOutline),
        ('suboutline_only', w.checkBoxSuboutlineOnly),  
        ('node_only',       w.checkBoxNodeOnly),
        ('search_headline', w.checkBoxSearchHeadline),
        ('search_body',     w.checkBoxSearchBody),
        ('mark_changes',    w.checkBoxMarkChanges),
        ('batch', None),
    )
    for ivar,widget in data:
        setattr(self,ivar,widget)
        self.widgetsDict[ivar] = widget
        # g.trace(ivar,widget)
#@+node:ekr.20110605121601.18230: *8* initIvars
def initIvars(self):

    c = self.c

    # Separate c.ivars are much more convenient than a svarDict.
    for ivar in self.intKeys:
        # Get ivars from @settings.
        val = c.config.getBool(ivar)
        setattr(self,ivar,val)
        val = g.choose(val,1,0)
        svar = self.svarDict.get(ivar)
        if svar:
            svar.set(val)

        # g.trace(ivar,val)
#@+node:ekr.20110605121601.18231: *8* initTextWidgets (qtFindTab)
def initTextWidgets(self):

    '''Init the find/change text areas.'''

    c = self.c

    table = (
        (self.find_ctrl,    "find_text",    '<find pattern here>'),
        (self.change_ctrl,  "change_text",  ''),
    )

    for w,setting,defaultText in table:
        # w is a textWrapper object
        w.setAllText(c.config.getString(setting) or defaultText)
#@+node:ekr.20110605121601.18232: *8* initCheckBoxes
def initCheckBoxes (self):

    for ivar,key in (
        ("pattern_match","pattern-search"),
    ):
        svar = self.svarDict[ivar].get()
        if svar:
            self.svarDict["radio-find-type"].set(key)
            w = self.widgetsDict.get(key)
            if w: w.setChecked(True)
            break
    else:
        self.svarDict["radio-find-type"].set("plain-search")

    aList = (
        'ignore_case','mark_changes','mark_finds',
        'pattern_match',
        # 'reverse',
        'search_body','search_headline',
        'whole_word','wrap',
        'node_only','suboutline_only','entire_outline',
    )

    for ivar in aList:
        svar = self.svarDict.get(ivar)
        if svar:
            # w is a QCheckBox or a QRadioButton.
            w = self.widgetsDict.get(ivar)
            if w:
                val = svar.get()
                svar.setWidget(w)
                svar.set(val)
                if isinstance(w,QtGui.QCheckBox):
                    def checkBoxCallback(val,svar=svar):
                        svar.set(val)
                    w.connect(w,
                        QtCore.SIGNAL("stateChanged(int)"),
                        checkBoxCallback)
                else:
                    def radioButtonCallback(val,svar=svar):
                        svar.set(val)
                    w.connect(w,
                        QtCore.SIGNAL("clicked(bool)"),
                        radioButtonCallback)
            else: g.trace('*** no w',ivar)
        else: g.trace('*** no svar',ivar)
#@+node:ekr.20110605121601.18233: *8* initRadioButtons
def initRadioButtons (self):

    scopeSvar = self.svarDict.get('radio-search-scope')

    table = (
        ("suboutline_only","suboutline-only"),
        ("node_only","node-only"))

    for ivar,key in table:
        svar = self.svarDict.get(ivar)
        if svar:
            val = svar.get()
            if val:
                scopeSvar.init(key)
                break
    else:
        scopeSvar.init('entire-outline')
        self.svarDict.get('entire_outline').init(True)

    w = self.widgetsDict.get(key)
    if w: w.setChecked(True)

    # g.trace(scopeSvar.get())
#@+node:ekr.20070302090616.4: *7* init (nullFindTab)
# Called from findTab.ctor.

def init (self,c):

    # Separate c.ivars are much more convenient than a svarDict.
    for key in self.intKeys:
        # Get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0)
        svar = self.svarDict.get(key)
        if svar: svar.set(val)
        #g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
    << set checkboxes from ivars >>
#@+node:ekr.20070302090616.5: *8* << set find/change widgets >>
self.find_ctrl.delete(0,"end")
self.change_ctrl.delete(0,"end")

# Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@+node:ekr.20070302090616.6: *8* << set radio buttons from ivars >>
# In Tk, setting the var also sets the widget.
# Here, we do so explicitly.
d = self.widgetsDict
for ivar,key in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-find-type"].set(key)
        # w = d.get(key)
        # if w: w.set(True)
        break
else:
    self.svarDict["radio-find-type"].set("plain-search")

for ivar,key in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-search-scope"].set(key)
        break
else:
    key = ivar = 'entire-outline'
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-search-scope"].set(key)
    # self.svarDict["radio-search-scope"].set(key)
    # w = self.widgetsDict.get(key)
    # if w: w.set(True)
#@+node:ekr.20070302090616.7: *8* << set checkboxes from ivars >>
for ivar in (
    'ignore_case',
    'mark_changes',
    'mark_finds',
    'pattern_match',
    'reverse',
    'search_body',
    'search_headline',
    'whole_word',
    'wrap',
):
    # Bug fix: 2011/11/13: significant for external unit tests.
    svar = self.svarDict[ivar]
    if svar:
        svar.set(True)
        # w = self.widgetsDict.get(ivar)
        # if w: w.set(True)
#@+node:ekr.20110605121601.18234: *7* class svar (qtFindTab)
class svar:
    '''A class like Tk's IntVar and StringVar classes.'''

    @others
#@+node:ekr.20110605121601.18235: *8* svar.ctor
def __init__(self,owner,ivar):

    self.ivar = ivar
    self.owner = owner
    self.radioButtons = ['node_only','suboutline_only','entire_outline']
    self.trace = False
    self.val = None
    self.w = None

def __repr__(self):
    return '<svar %s>' % self.ivar
#@+node:ekr.20110605121601.18236: *8* get
def get (self):

    trace = False and not g.unitTesting

    if self.w:
        val = self.w.isChecked()
        if trace:
            g.trace('qt svar %15s = %s' % (
                self.ivar,val),g.callers(5))        
    else:
        val = self.val
    return val
#@+node:ekr.20110605121601.18237: *8* init
def init (self,val):

    '''Init the svar, but do *not* init radio buttons.
    (This is called from initRadioButtons).'''

    trace = False and not g.unitTesting

    if val in (0,1):
        self.val = bool(val)
    else:
        self.val = val # Don't contain the scope values!

    if self.w:
        self.w.setChecked(bool(val))

    if trace: g.trace('qt svar %15s = %s' % (
        self.ivar,val),g.callers(5))
#@+node:ekr.20110605121601.18238: *8* set
def set (self,val):

    '''Init the svar and update the radio buttons.'''

    trace = False and not g.unitTesting
    if trace: g.trace(val)

    self.init(val)

    if self.ivar in self.radioButtons:
        self.owner.initRadioButtons()
    elif self.ivar == 'radio-search-scope':
        self.setRadioScope(val)


#@+node:ekr.20110605121601.18239: *8* setRadioScope
def setRadioScope (self,val):

    '''Update the svars corresponding to the scope value.'''

    table = (
        ("suboutline_only","suboutline-only"),
        ("node_only","node-only"),
        ("entire_outline","entire-outline"))

    for ivar,val2 in table:
        if val == val2:
            svar = self.owner.svarDict.get(ivar)
            val = svar.get()
            svar.init(True)
#@+node:ekr.20110605121601.18240: *8* setWidget
def setWidget(self,w):

    self.w = w
#@+node:ekr.20070302090616.8: *7* class svar (nullFindTab)
class svar:

    '''A class like Tk's IntVar and StringVar classes.'''

    def __init__(self):
        self.val = None
    def get (self):
        return self.val
    def set (self,val):
        self.val = val

    SetValue = set # SetValue is the wxWidgets spelling.
#@+node:ekr.20111114102224.9934: *4* Unified the high-level interface
@nocolor-node

Notes:

- leoQTextEditWidget overrides base toPythonIndex toPythonIndexRowCol.
  The override is much faster.
#@+node:ekr.20111114102224.9949: *5* Unified toPythonIndex
@nocolor-node

The versions that call  g.toPythonIndex are much slower than
leoQTextEditWidget.toPythonIndex.
#@+node:ekr.20110605121601.18100: *6* toPythonIndex (leoQTextEditWidget) (Fast)
def toPythonIndex (self,index):
    
    '''This is much faster than versions using g.toPythonIndex.'''

    w = self
    te = self.widget

    if index is None:
        return 0
    if type(index) == type(99):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return w.getLastPosition()
    else:
        doc = te.document()
        data = index.split('.')
        if len(data) == 2:
            row,col = data
            row,col = int(row),int(col)
            bl = doc.findBlockByNumber(row-1)
            return bl.position() + col
        else:
            g.trace('bad string index: %s' % index)
            return 0

toGuiIndex = toPythonIndex
#@+node:ekr.20111114102224.9943: *6* toPythonIndex (HighLevelInterface)
def toPythonIndex (self,index):
    
    s = self.getAllText()
    return g.toPythonIndex(s,index)

toGuiIndex = toPythonIndex
#@+node:ekr.20070228074312.7: *6* toPythonIndex (baseTextWidget)
def toPythonIndex (self,index):
    
    return g.toPythonIndex(self.s,index)

toGuiIndex = toPythonIndex
#@+node:ekr.20070105092022.4: *6* toPythonIndex (leoFind)
def toPythonIndex (self,i):
    
    return g.toPythonIndex(self.s,i)
#@+node:ekr.20110605121601.18034: *6* toPythonIndex (leoQtBaseTextWidget)
def toPythonIndex (self,index):
    
    s = self.getAllText()
    return g.toPythonIndex(s,index)

toGuiIndex = toPythonIndex
#@+node:ekr.20111114151846.9847: *6* g.toPythonIndex
def toPythonIndex (s,index):
    
    '''Convert index to a Python int.
    
    index may be a Tk index (x.y) or 'end'.
    '''
    
    if index is None:
        return 0
    elif type(index) == type(99):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return len(s)
    else:
        data = index.split('.')
        if len(data) == 2:
            row,col = data
            row,col = int(row),int(col)
            i = g.convertRowColToPythonIndex(s,row-1,col)
            return i
        else:
            g.trace('bad string index: %s' % index)
            return 0

toGuiIndex = toPythonIndex
#@+node:ekr.20111115090357.9805: *4* Create properties for logCtrl & bodyCtrl
@nocolor-node

This is an important addition to reliability.
It ensures that body/log.widget and body.bodyCtrl/log.logCtrl are always in synch.
#@+node:ekr.20111118190243.10193: *4* Added eventFilters to top-level frames
@nocolor-node

Added eventFilter in createFrame in SDI/TabbedFrameFactory classes
#@+node:ekr.20110605121601.18463: *5* createFrame (SDIFrameFactory)
def createFrame(self, leoFrame):

    c = leoFrame.c
    dw = DynamicWindow(c)    
    dw.construct()
    g.app.gui.attachLeoIcon(dw)
    dw.setWindowTitle(leoFrame.title)
    
    if 1:
        # g.trace('(TabbedFrameFactor) adding bindings')
        dw.ev_filter = leoQtEventFilter(c,w=dw,tag='sdi-frame')
        dw.installEventFilter(dw.ev_filter)

    if g.app.start_minimized:
        dw.showMinimized()
    elif g.app.start_maximized:
        dw.showMaximized()
    elif g.app.start_fullscreen:
        dw.showFullScreen()
    else:
        dw.show()

    return dw

def deleteFrame(self, wdg):
    pass

#@+node:ekr.20110605121601.18466: *5* createFrame (TabbedFrameFactory)
def createFrame(self, leoFrame):

    # g.trace('(TabbedFrameFactory)')

    c = leoFrame.c
    if self.masterFrame is None:
        self.createMaster()
    tabw = self.masterFrame
    dw = DynamicWindow(c,tabw)
    self.leoFrames[dw] = leoFrame

    # Shorten the title.
    fname = c.mFileName
    if fname:
        title = os.path.basename(fname)
    else:
        title = leoFrame.title
    tip = leoFrame.title

    dw.setWindowTitle(tip) # 2010/1/1
    idx = tabw.addTab(dw, title)
    if tip: tabw.setTabToolTip(idx, tip)

    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)
    
    if 1:
        # g.trace('(TabbedFrameFactor) adding bindings')
        dw.ev_filter = leoQtEventFilter(c,w=dw,tag='sdi-frame')
        dw.installEventFilter(dw.ev_filter)

    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(
        self.alwaysShowTabs or tabw.count() > 1)

    dw.show()
    tabw.show()
    return dw
#@+node:ekr.20111122080923.10183: *4* added log.orderedTabNames
#@+node:ekr.20120130135119.10212: *4* Always use brief=True in k.prettyPrintKey
#@+node:ekr.20110918184425.6915: *3* Features
#@+node:ekr.20110929165422.15464: *4* Supported auto-hide in viewrendered plugin
#@+node:ekr.20110918180029.15527: *4* set g.app.execute_script during script execution
@nocolor-node

This allows the following pattern to appear in Leo source files::

    class myClass:
        @others
        
    if g.app.testing:
        myClass(c).test()
        
This is better than enabling the test with "if 1:" because
c is not defined while importing the module, so the import
will fail if I forget to change "if 1:" to "if 0" when saving
the .leo file.
#@+node:ekr.20110916215321.6710: *4* Added select-to-matching-bracket command
#@+node:ekr.20110916215321.6708: *5* selectToMatchingBracket (leoEditCommands)
def selectToMatchingBracket (self,event):
    
    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return
    
    i = w.getInsertPoint()
    s = w.getAllText()
    
    allBrackets = self.openBracketsList + self.closeBracketsList
    
    if i < len(s) and s[i] in allBrackets:
        ch = s[i]
    elif i > 0 and s[i-1] in allBrackets:
        i -= 1
        ch = s[i]
    else:
        g.es('no bracket selected')
        return

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    
    # This should be generalized...
    language = g.findLanguageDirectives(c,c.p)
    if language in ('c','cpp','csharp'):
        j = g.skip_matching_c_delims(s,i,ch,delim2,reverse=reverse)
    else:
        j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    # g.trace(i,j,ch,delim2,reverse,language)
    if j not in (-1,i):
        if reverse:
            i += 1; j += 1
        w.setSelectionRange(i,j,insert=j)
            # 2011/11/21: Bug fix: was ins=j.
        w.see(j)
#@+node:ekr.20110916215321.6712: *5* g.skip_matching_c_delims
def skip_matching_c_delims(s,i,delim1,delim2,reverse=False):

    '''Skip from the opening delim to the matching delim2.

    Return the index of the matching ')', or -1'''

    level = 0
    assert(g.match(s,i,delim1))
    if reverse:
        # Reverse scanning is tricky.
        # This doesn't handle single-line comments properly.
        while i >= 0:
            progress = i
            ch = s[i]
            if ch == delim1:
                level += 1 ; i -= 1
            elif ch == delim2:
                level -= 1
                if level <= 0:  return i-1
                i -= 1
            elif ch in ('\'','"'):
                i -= 1
                while i >= 0:
                    if s[i] == ch and not s[i-1] == '\\':
                        i -= 1 ; break
                    else:
                        i -= 1
            elif g.match(s,i,'*/'):
                i += 2
                while i >= 0:
                    if g.match(s,i,'/*'):
                        i -= 2
                        break
                    else:
                        i -= 1
            else: i -= 1
            if i == progress:
                g.trace('oops: reverse')
                return -1
    else:
        while i < len(s):
            progress = i
            ch = s[i]
            # g.trace(i,repr(ch))
            if ch == delim1:
                level += 1 ; i += 1
            elif ch == delim2:
                level -= 1 ; i += 1
                if level <= 0:  return i
            elif ch in ('\'','"'):
                i += 1
                while i < len(s):
                    if s[i] == ch and not s[i-1] == '\\':
                        i += 1 ; break
                    else:
                        i += 1
            elif g.match(s,i,'//'):
                i = g.skip_to_end_of_line(s,i+2)
            elif g.match(s,i,'/*'):
                i += 2
                while i < len(s):
                    if g.match(s,i,'*/'):
                        i += 2
                        break
                    else:
                        i += 1
            else: i += 1
            if i == progress:
                g.trace('oops')
                return -1
    g.trace('not found')
    return -1
#@+node:ekr.20090724081340.5987: *4* Improved recursive import script
@nocolor-node

- Generates only @auto, does not do an actual import.
- Creates @path nodes so actual @auto nodes are short.
#@+node:ekr.20110917174948.6875: *4* Added beautify-c command
@nocolor-node

Added class CPrettyPrinter & beatifyCCode
#@+node:ekr.20110916215321.7767: *4* Added c-to-python command
#@+node:ekr.20110919184022.6900: *5* To do
@nocolor-node

* Simplify declaration code by using lookahead.

- change skip_to_matching bracket to skip_past_matching_braket.

- (Maybe) Put type decls as comments at end of line.
    Only decls in function bodies need to be munged, but that's not easy.

- (Maybe) Use @ and @c to delimit block comments.
#@+node:ekr.20110919184022.6901: *5* What I did
@nocolor-node

What I did:

- Wrapped the code in a class.

- Replaced all globals with ivars.

- Replaced listToString with ''.join(aList)
    
- Eliminated stringToList.
    The code never passes None where a sequence is expected.
    
- Get tab_width from @tabwidth directives.

- Get user data from::
    
    @data c-to-python-class-list
    @data c-to-python-type-list
    @data c-to-python-ivars-dict
        keys end in a colon
        all other lines contain comma-delimited values for the current key.
        
- Add extra parens for 'if' that span several lines.
- Fixed extra indentation.
- Changed ! to not except before =.
- Dedented C blocks, such as::
    
    {
        statement;
        statement;
    }
    
- Improved formatting of block comments.
#@+node:ekr.20110916215321.8003: *5* mungeAllFunctions
def mungeAllFunctions(self,aList):
    
    '''Scan for a '{' at the top level that is preceeded by ')' '''

    prevSemi = 0 # Previous semicolon: header contains all previous text
    i = 0
    firstOpen = None
    while i < len(aList):
        progress = i
        if self.is_string_or_comment(aList,i):
            j = self.skip_string_or_comment(aList,i)
            prevSemi = j
        elif self.match(aList,i,'('):
            if not firstOpen:
                firstOpen = i
            j = i + 1
        elif self.match(aList,i,'#'):
            # At this point, it is a preprocessor directive.
            j = self.skip_past_line(aList, i)
            prevSemi = j
        elif self.match(aList,i,';'):
            j = i + 1
            prevSemi = j
        elif self.match(aList,i,"{"):
            j = self.handlePossibleFunctionHeader(aList,i,prevSemi,firstOpen)
            prevSemi = j
            firstOpen = None # restart the scan
            # g.trace(repr(''.join(aList[prevSemi:prevSemi+20])))
        else:
            j = i + 1
        
        assert j > progress
        i = j
        
# elif self.match_word(aList, i, "@code"):
    # j = i + 5
    # prevSemi = j # restart the scan
# elif self.match_word(aList, i, "@c"):
    # j = i + 2 ; prevSemi = j # restart the scan
#@+node:ekr.20110916215321.8004: *6* handlePossibleFunctionHeader
# converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader (self,aList,i,prevSemi,firstOpen):

    trace = False
    assert(self.match(aList,i,"{"))

    prevSemi = self.skip_ws_and_nl(aList, prevSemi)
    close = self.prevNonWsOrNlChar(aList,i)

    if close < 0 or aList[close] != ')':
        # Should not increase *Python* indent.
        return 1 + self.skip_to_matching_bracket(aList,i)
        
    if not firstOpen:
        return 1 + self.skip_to_matching_bracket(aList,i)

    close2 = self.skip_to_matching_bracket(aList, firstOpen)
    if close2 != close:
        return 1 + self.skip_to_matching_bracket(aList,i)

    open_paren = firstOpen
    assert(aList[open_paren]=='(')
    head = aList[prevSemi:open_paren]

    # do nothing if the head starts with "if", "for" or "while"
    k = self.skip_ws(head,0)
    if k >= len(head) or not head[k].isalpha():
        return 1 + self.skip_to_matching_bracket(aList,i)

    kk = self.skip_past_word(head,k)
    if kk > k:
        headString = ''.join(head[k:kk])
        # C keywords that might be followed by '{'
        # print "headString:", headString
        if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
            return 1 + self.skip_to_matching_bracket(aList, i)

    args = aList[open_paren:close+1]
    k = 1 + self.skip_to_matching_bracket(aList,i)
    body = aList[close+1:k]
    
    if True and trace:
        g.trace('\nhead: %s\nargs: %s\nbody: %s' % (
            ''.join(head),''.join(args),''.join(body)))
    
    head = self.massageFunctionHead(head)
    args = self.massageFunctionArgs(args)
    body = self.massageFunctionBody(body)

    if False and trace:
        g.trace('\nhead2: %s\nargs2: %s\nbody2: %s' % (
            ''.join(head),''.join(args),''.join(body)))

    result = []
    if head: result.extend(head)
    if args: result.extend(args)
    if body: result.extend(body)

    aList[prevSemi:k] = result
    return prevSemi + len(result)
#@+node:ekr.20110916215321.8005: *6* massageFunctionArgs
def massageFunctionArgs (self,args):

    assert(args[0]=='(')
    assert(args[-1]==')')

    result = ['('] ; lastWord = []
    if self.class_name:
        for item in list("self,"): result.append(item) #can put extra comma

    i = 1
    while i < len(args):
        i = self.skip_ws_and_nl(args, i)
        c = args[i]
        if c.isalpha():
            j = self.skip_past_word(args,i)
            lastWord = args[i:j]
            i = j
        elif c == ',' or c == ')':
            for item in lastWord:
                result.append(item)
            if lastWord != [] and c == ',':
                result.append(',')
            lastWord = []
            i += 1
        else: i += 1
    if result[-1] == ',':
        del result[-1]
    result.append(')')
    result.append(':')
    # print "new args:", ''.join(result)
    return result
#@+node:ekr.20110916215321.8006: *6* massageFunctionHead (sets .class_name)
def massageFunctionHead (self,head):
    
    result = []
    prevWord = []
    self.class_name = ''
    i = 0
    # g.trace(repr(''.join(head)))
    while i < len(head):
        i = self.skip_ws_and_nl(head,i)
        if i < len(head) and head[i].isalpha():
            result = []
            j = self.skip_past_word(head,i)
            prevWord = head[i:j]
            i = j
            # look for ::word2
            i = self.skip_ws(head,i)
            if self.match(head,i,"::"):
                # Set the global to the class name.
                self.class_name = ''.join(prevWord)
                # print(class name:", self.class_name)
                i = self.skip_ws(head,i+2)
                if i < len(head) and (head[i]=='~' or head[i].isalpha()):
                    j = self.skip_past_word(head,i)
                    if head[i:j] == prevWord:
                        result.extend('__init__')
                    elif head[i]=='~' and head[i+1:j] == prevWord:
                        result.extend('__del__')
                    else:
                        # result.extend(list('::'))
                        result.extend(head[i:j])
                    i = j
            else:
                result.extend(prevWord)
        else: i += 1

    finalResult = list("def ")
    finalResult.extend(result)
    return finalResult
#@+node:ekr.20110916215321.8007: *6* massageFunctionBody & helpers
def massageFunctionBody (self,body):

    body = self.massageIvars(body)
    body = self.removeCasts(body)
    body = self.removeTypeNames(body)
    body = self.dedentBlocks(body)
    return body
#@+node:ekr.20110919224143.6928: *7* dedentBlocks
def dedentBlocks (self,body):
    
    '''Look for '{' preceded by '{' or '}' or ';'
    (with intervening whitespace and comments).
    '''
    
    i = 0
    while i < len(body):
        j = i
        ch = body[i]
        if self.is_string_or_comment(body,i):
            j = self.skip_string_or_comment(body,i)
        elif ch in '{};':
            # Look ahead ofr '{'
            j += 1
            while True:
                k = j
                j = self.skip_ws_and_nl(body,j)
                if self.is_string_or_comment(body,j):
                    j = self.skip_string_or_comment(body,j)
                if k == j: break
                assert k < j
            if self.match(body,j,'{'):
                k = j
                j = self.skip_to_matching_bracket(body,j)
                # g.trace('found block\n',''.join(body[k:j+1]))
                m = '# <Start dedented block>...'
                body[k:k+1] = list(m)
                j += len(m)
                while k < j:
                    progress = k
                    if body[k] == '\n':
                        k += 1
                        spaces = 0
                        while spaces < 4 and k < j:
                            if body[k] == ' ':
                                spaces += 1
                                k += 1
                            else:
                                break
                        if spaces > 0:
                            del body[k-spaces:k]
                            k -= spaces
                            j -= spaces
                    else:
                        k += 1
                    assert progress < k
                m = '    # <End dedented block>'
                body[j:j+1] = list(m)
                j += len(m)
        else:
            j = i + 1
        assert i < j
        i = j
                
    return body
#@+node:ekr.20110916215321.8008: *7* massageIvars
def massageIvars (self,body):

    if self.class_name and self.ivars_dict.has_key(self.class_name):
        ivars = self.ivars_dict.get(self.class_name)
    else:
        ivars = []

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif body[i].isalpha():
            j = self.skip_past_word(body,i)
            word = ''.join(body[i:j])
            # print "looking up:", word
            if word in ivars:
                # replace word by self.word
                # print "replacing", word, " by self.", word
                word = "self." + word
                word = list(word)
                body[i:j] = word
                delta = len(word)-(j-i)
                i = j + delta
            else: i = j
        else: i += 1
    return body
#@+node:ekr.20110916215321.8009: *7* removeCasts
def removeCasts (self,body):

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif self.match(body, i, '('):
            start = i
            i = self.skip_ws(body, i+1)
            if body[i].isalpha():
                j = self.skip_past_word(body,i)
                word = ''.join(body[i:j])
                i = j
                if word in self.class_list or word in self.type_list:
                    i = self.skip_ws(body, i)
                    while self.match(body,i,'*'):
                        i += 1
                    i = self.skip_ws(body, i)
                    if self.match(body,i,')'):
                        i += 1
                        # print "removing cast:", ''.join(body[start:i])
                        del body[start:i]
                        i = start
        else: i += 1
    return body
#@+node:ekr.20110916215321.8010: *7* removeTypeNames
# Do _not_ remove type names when preceeded by new.

def removeTypeNames (self,body):

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif self.match_word(body, i, "new"):
            i = self.skip_past_word(body,i)
            i = self.skip_ws(body,i)
            # don't remove what follows new.
            if body[i].isalpha():
                i = self.skip_past_word(body,i)
        elif body[i].isalpha():
            j = self.skip_past_word(body,i)
            word = ''.join(body[i:j])
            if word in self.class_list or word in self.type_list:
                j = self.skip_ws(body,j)
                while self.match(body,j,'*'):
                    j += 1
                # print "Deleting type name:", ''.join(body[i:j])
                j = self.skip_ws(body,j)
                del body[i:j]
            else:
                i = j
        else: i += 1
    return body
#@+node:ekr.20110920174648.6945: *5* mungeAllFunctions NEW
def mungeAllFunctions(self,aList):
    
    '''Scan for a '{' at the top level that is preceeded by ')' '''
    
    i,start_of_decl,paren_parts = 0,0,[]
    while i < len(aList):
        j = i
        ch = aList[i]
        if ch in '*[], \t\n':
            j += 1
        elif ch == '(':
            j = self.skip_parens(aList,i)
            paren_parts.append((i,j),)
        elif ch == ';':
            # A function declaration.
            j = self.munge_declaration(aList,start_of_decl,i,paren_parts)
            start_of_decl,paren_parts = j,[]
        elif ch == "{":
            # A function definition or enum/struct/union
            # depending on the word at aList[start_of_decl]...
            j1 = self.skip_parens(aList,i)
            j2 = self.munge_declaration(aList,start_of_decl,j1,paren_parts)
            j = self.munge_function_body(aList,i,j2)
            start_of_decl,paren_parts = j,[]
        elif ch == '=':
            # An initializer.
            j = self.skip_statement(aList,i)
            j = self.munge_declaration(aList,start_of_decl,j,paren_parts)
            start_of_decl,paren_parts = j,[]
        elif self.match(aList,i,'#'):
            # A preprocessor directive.
            j = self.skip_past_line(aList,i)
        elif ch in ('"',"'"):
            j = self.skip_string(aList,i)
        elif self.match(aList,i,'//'):
            j = self.skip_to_end_of_line(aList,i)
        elif self.match(aList,i,'/*'):
            j = self.skip_omment(aList,i)
        elif ch == '_' or ch.isalpha():
            j = g.skip_c_id(aList,i)
        elif ch.isdigit():
            j = g.skip_number(aList,i)
        else:
            g.trace('unexpected character in declaration:',repr(ch))
            j = i + 1
        
        assert j > i
        i = j
#@+node:ekr.20110920174648.6946: *6* handlePossibleFunctionHeader
# converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader (self,aList,i,prevSemi,firstOpen):

    trace = False
    assert(self.match(aList,i,"{"))

    prevSemi = self.skip_ws_and_nl(aList, prevSemi)
    close = self.prevNonWsOrNlChar(aList,i)

    if close < 0 or aList[close] != ')':
        # Should not increase *Python* indent.
        return 1 + self.skip_to_matching_bracket(aList,i)
        
    if not firstOpen:
        return 1 + self.skip_to_matching_bracket(aList,i)

    close2 = self.skip_to_matching_bracket(aList, firstOpen)
    if close2 != close:
        return 1 + self.skip_to_matching_bracket(aList,i)

    open_paren = firstOpen
    assert(aList[open_paren]=='(')
    head = aList[prevSemi:open_paren]

    # do nothing if the head starts with "if", "for" or "while"
    k = self.skip_ws(head,0)
    if k >= len(head) or not head[k].isalpha():
        return 1 + self.skip_to_matching_bracket(aList,i)

    kk = self.skip_past_word(head,k)
    if kk > k:
        headString = ''.join(head[k:kk])
        # C keywords that might be followed by '{'
        # print "headString:", headString
        if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
            return 1 + self.skip_to_matching_bracket(aList, i)

    args = aList[open_paren:close+1]
    k = 1 + self.skip_to_matching_bracket(aList,i)
    body = aList[close+1:k]
    
    if True and trace:
        g.trace('\nhead: %s\nargs: %s\nbody: %s' % (
            ''.join(head),''.join(args),''.join(body)))
    
    head = self.massageFunctionHead(head)
    args = self.massageFunctionArgs(args)
    body = self.massageFunctionBody(body)

    if False and trace:
        g.trace('\nhead2: %s\nargs2: %s\nbody2: %s' % (
            ''.join(head),''.join(args),''.join(body)))

    result = []
    if head: result.extend(head)
    if args: result.extend(args)
    if body: result.extend(body)

    aList[prevSemi:k] = result
    return prevSemi + len(result)
#@+node:ekr.20110920174648.6947: *6* massageFunctionArgs
def massageFunctionArgs (self,args):

    assert(args[0]=='(')
    assert(args[-1]==')')

    result = ['('] ; lastWord = []
    if self.class_name:
        for item in list("self,"): result.append(item) #can put extra comma

    i = 1
    while i < len(args):
        i = self.skip_ws_and_nl(args, i)
        c = args[i]
        if c.isalpha():
            j = self.skip_past_word(args,i)
            lastWord = args[i:j]
            i = j
        elif c == ',' or c == ')':
            for item in lastWord:
                result.append(item)
            if lastWord != [] and c == ',':
                result.append(',')
            lastWord = []
            i += 1
        else: i += 1
    if result[-1] == ',':
        del result[-1]
    result.append(')')
    result.append(':')
    # print "new args:", ''.join(result)
    return result
#@+node:ekr.20110920174648.6948: *6* massageFunctionHead (sets .class_name)
def massageFunctionHead (self,head):
    
    result = []
    prevWord = []
    self.class_name = ''
    i = 0
    # g.trace(repr(''.join(head)))
    while i < len(head):
        i = self.skip_ws_and_nl(head,i)
        if i < len(head) and head[i].isalpha():
            result = []
            j = self.skip_past_word(head,i)
            prevWord = head[i:j]
            i = j
            # look for ::word2
            i = self.skip_ws(head,i)
            if self.match(head,i,"::"):
                # Set the global to the class name.
                self.class_name = ''.join(prevWord)
                # print(class name:", self.class_name)
                i = self.skip_ws(head,i+2)
                if i < len(head) and (head[i]=='~' or head[i].isalpha()):
                    j = self.skip_past_word(head,i)
                    if head[i:j] == prevWord:
                        result.extend('__init__')
                    elif head[i]=='~' and head[i+1:j] == prevWord:
                        result.extend('__del__')
                    else:
                        # result.extend(list('::'))
                        result.extend(head[i:j])
                    i = j
            else:
                result.extend(prevWord)
        else: i += 1

    finalResult = list("def ")
    finalResult.extend(result)
    return finalResult
#@+node:ekr.20110920174648.6949: *6* massageFunctionBody & helpers
def massageFunctionBody (self,body):

    body = self.massageIvars(body)
    body = self.removeCasts(body)
    body = self.removeTypeNames(body)
    body = self.dedentBlocks(body)
    return body
#@+node:ekr.20110920174648.6950: *7* dedentBlocks
def dedentBlocks (self,body):
    
    '''Look for '{' preceded by '{' or '}' or ';'
    (with intervening whitespace and comments).
    '''
    
    i = 0
    while i < len(body):
        j = i
        ch = body[i]
        if self.is_string_or_comment(body,i):
            j = self.skip_string_or_comment(body,i)
        elif ch in '{};':
            # Look ahead ofr '{'
            j += 1
            while True:
                k = j
                j = self.skip_ws_and_nl(body,j)
                if self.is_string_or_comment(body,j):
                    j = self.skip_string_or_comment(body,j)
                if k == j: break
                assert k < j
            if self.match(body,j,'{'):
                k = j
                j = self.skip_to_matching_bracket(body,j)
                # g.trace('found block\n',''.join(body[k:j+1]))
                m = '# <Start dedented block>...'
                body[k:k+1] = list(m)
                j += len(m)
                while k < j:
                    progress = k
                    if body[k] == '\n':
                        k += 1
                        spaces = 0
                        while spaces < 4 and k < j:
                            if body[k] == ' ':
                                spaces += 1
                                k += 1
                            else:
                                break
                        if spaces > 0:
                            del body[k-spaces:k]
                            k -= spaces
                            j -= spaces
                    else:
                        k += 1
                    assert progress < k
                m = '    # <End dedented block>'
                body[j:j+1] = list(m)
                j += len(m)
        else:
            j = i + 1
        assert i < j
        i = j
                
    return body
#@+node:ekr.20110920174648.6951: *7* massageIvars
def massageIvars (self,body):

    if self.class_name and self.ivars_dict.has_key(self.class_name):
        ivars = self.ivars_dict.get(self.class_name)
    else:
        ivars = []

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif body[i].isalpha():
            j = self.skip_past_word(body,i)
            word = ''.join(body[i:j])
            # print "looking up:", word
            if word in ivars:
                # replace word by self.word
                # print "replacing", word, " by self.", word
                word = "self." + word
                word = list(word)
                body[i:j] = word
                delta = len(word)-(j-i)
                i = j + delta
            else: i = j
        else: i += 1
    return body
#@+node:ekr.20110920174648.6952: *7* removeCasts
def removeCasts (self,body):

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif self.match(body, i, '('):
            start = i
            i = self.skip_ws(body, i+1)
            if body[i].isalpha():
                j = self.skip_past_word(body,i)
                word = ''.join(body[i:j])
                i = j
                if word in self.class_list or word in self.type_list:
                    i = self.skip_ws(body, i)
                    while self.match(body,i,'*'):
                        i += 1
                    i = self.skip_ws(body, i)
                    if self.match(body,i,')'):
                        i += 1
                        # print "removing cast:", ''.join(body[start:i])
                        del body[start:i]
                        i = start
        else: i += 1
    return body
#@+node:ekr.20110920174648.6953: *7* removeTypeNames
# Do _not_ remove type names when preceeded by new.

def removeTypeNames (self,body):

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif self.match_word(body, i, "new"):
            i = self.skip_past_word(body,i)
            i = self.skip_ws(body,i)
            # don't remove what follows new.
            if body[i].isalpha():
                i = self.skip_past_word(body,i)
        elif body[i].isalpha():
            j = self.skip_past_word(body,i)
            word = ''.join(body[i:j])
            if word in self.class_list or word in self.type_list:
                j = self.skip_ws(body,j)
                while self.match(body,j,'*'):
                    j += 1
                # print "Deleting type name:", ''.join(body[i:j])
                j = self.skip_ws(body,j)
                del body[i:j]
            else:
                i = j
        else: i += 1
    return body
#@+node:ekr.20110929074744.15447: *4* removed scrolledmessage plugin
The viewrendered plugin does more.
#@+node:ekr.20110930075237.15469: *4* Added import-org-mode script
#@+node:ekr.20110929165422.15432: *5* import-org-mode (command, not used)
class ImportOrgMode:
    @others

def importOrgMode (self,event):
    c = self.c
    self.ImportOrgMode(c).go(c.p)
    c.bodyWantsFocus()

if False and g.app.inScript:
    print('='*40)
    ImportOrgMode(c).test()
    print('done')
#@+node:ekr.20110929185034.15461: *6* ctor
def __init__ (self,c):
    
    self.c = c
#@+node:ekr.20110929185034.15457: *6* go
def go (self,p):
    
    '''Prompt for a file and pass the contents to scan().'''
#@+node:ekr.20110929185034.15460: *6* scan
def scan (self,fn,p,s):

    self.c = c
    root = p.insertAsLastChild()
    root.h = fn
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        g.trace(repr(s))
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1
                level += 1
            if level > len(stack):
                g.trace('bad level',repr(s))
                last = None
            elif level == len(stack):
                last = stack[-1]
                last.b = ''.join(body)
            else:
                last = stack[-1]
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            p = parent.insertAsLastChild()
            p.h = s.strip()
            stack.append(p)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        parent = stack[-1]
        parent.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
#@+node:ekr.20110929185034.15459: *6* test
def test (self):
    
    s = '''
* A1
    a1.1
    a1.2
** B11
** B12
b12.1
*** C121
c121.1
    c121.2
c121.3
* A2
a2.1
** B21
*** C211
c211.1
*** C212
** B22
    b22.1
b22.1
* A3
* A4
a4.1
* A5
** B51
*** C511
**** D5111
***** E51111
** B52
*** C521
c521.1
'''

    tag = 'test-import-org-mode'
    p = g.findNodeAnywhere(c,tag)
    s = g.adjustTripleString(s,-4)
    if p:
        try:
            self.scan('test-file',p,s)
        except Exception:
            c.redraw(p)
    else:
        print('not found: %s' % tag)
#@+node:ekr.20110929185034.15578: *5* @@button import-org-mode
'''Import each file in the files list after the presently selected node.'''


files = (
    r'c:\Users\edreamleo\test\import-org-mode.txt',
    r'c:\Users\edreamleo\test\import-org-mode.txt',
)

@others

for fn in files:
    try:
        root = c.p.copy()
        f = open(fn)
        s = f.read()
        scan(c,fn,s)
        c.selectPosition(root)
    except IOError:
        print('can not open %s' % fn)
#@+node:ekr.20110929185034.15580: *6* scan
def scan (c,fn,s):

    last = root = c.p.insertAsLastChild()
    last.h = g.shortFileName(fn)
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1 ; level += 1
            if level > len(stack):
                g.trace('bad level',repr(s))
            elif level == len(stack):
                last.b = ''.join(body)
            else:
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            last = parent.insertAsLastChild()
            last.h = s.strip()
            stack.append(last)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        last.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
#@+node:ekr.20110929185034.15463: *5* test-import-org-mode
#@+node:ekr.20110930213637.15474: *4* The Find tab now scrolls
@nocolor-node

The change was to DynamicWindow.createLogPane.
#@+node:ekr.20111003130143.15562: *4* Removed Leo's old syntax coloring code
@nocolor-node

This was Tk code, and so can not possibly be useful now.

Also removed the settings specific to the Tk colorizer.
#@+node:ekr.20111006060936.15637: *4* Added p.positionAfterDeletedTree
@nocolor-node

This important new method allows scripts to traverse an outline, deleting nodes
during the traversal. The pattern is::

    p = c.rootPosition()
    while p:
    if <delete p?>:
        next = p.positionAfterDeletedTree()
        p.doDelete()
        p = next
    else:
        p.moveToThreadNext()
        
This method also allows scripts to *move* nodes during a traversal, **provided**
that nodes are moved to a "safe" spot so that moving a node does not change the
position of any other nodes.

For example, the move-marked-nodes command first creates a **move node**, called
'Clones of marked nodes'. All moved nodes become children of this node.
**Inserting** these nodes as children of the "move node" does not change the
positions of other nodes. **Deleting** these nodes *may* change the position of
nodes, but the pattern above handles this complication cleanly.
#@+node:ekr.20111005152227.15566: *5* p.positionAfterDeletedTree
def positionAfterDeletedTree (self):
    
    '''Return the position corresponding to p.nodeAfterTree() after this node is
    deleted. This will be p.nodeAfterTree() unless p.next() exists.
    
    This method allows scripts to traverse an outline, deleting nodes during the
    traversal. The pattern is::
        
        p = c.rootPosition()
        while p:
        if <delete p?>:
            next = p.positionAfterDeletedTree()
            p.doDelete()
            p = next
        else:
            p.moveToThreadNext()
            
    This method also allows scripts to *move* nodes during a traversal, **provided**
    that nodes are moved to a "safe" spot so that moving a node does not change the
    position of any other nodes.
    
    For example, the move-marked-nodes command first creates a **move node**, called
    'Clones of marked nodes'. All moved nodes become children of this move node.
    **Inserting** these nodes as children of the "move node" does not change the
    positions of other nodes. **Deleting** these nodes *may* change the position of
    nodes, but the pattern above handles this complication cleanly.
    '''
    
    p = self
    next = p.next()
    if next:
        # The new position will be the same as p, except for p.v.
        p = p.copy()
        p.v = next.v
        return p
    else:
        return p.nodeAfterTree()
#@+node:ekr.20111005081134.15541: *4* Added delete-marked-nodes and move-marked-nodes commands
# And rewrote clone-marked-nodes.
#@+node:ekr.20111005152227.15556: *5* Undo stuff
#@+node:ekr.20111005152227.15561: *6*  Reference
#@+node:ekr.20050318085432.4: *7* afterX...
#@+node:ekr.20050315134017.4: *8* afterChangeGroup
def afterChangeGroup (self,p,undoType,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

    bunch = u.beads[u.bead]
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:
        g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)

    # Set the types & helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = undoType

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newP = p.copy()
    bunch.newSel = w.getSelectionRange()

    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag

    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@+node:ekr.20050315134017.2: *8* afterChangeNodeContents
def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.b
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.h
    bunch.newMarked = p.isMarked()
    bunch.newSel = w.getSelectionRange()

    u.pushBead(bunch)
#@+node:ekr.20050315134017.3: *8* afterChangeTree
def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = w.getSelectionRange()
    bunch.newText = w.getAllText()
    bunch.newTree = u.saveTree(p)

    u.pushBead(bunch)
#@+node:ekr.20050424161505: *8* afterClearRecentFiles
def afterClearRecentFiles (self,bunch):

    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]

    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles

    u.pushBead(bunch)

    return bunch
#@+node:ekr.20111006060936.15639: *8* afterCloneMarkedNodes
def afterCloneMarkedNodes (self,p):

    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)
    
        # Sets
        # oldChanged = c.isChanged(),
        # oldDirty = p.isDirty(),
        # oldMarked = p.isMarked(),
        # oldSel = w and w.getSelectionRange() or None,
        # p = p.copy(),

    # Set types & helpers
    bunch.kind = 'clone-marked-nodes'
    bunch.undoType = 'clone-marked-nodes'

    # Set helpers
    bunch.undoHelper = u.undoCloneMarkedNodes
    bunch.redoHelper = u.redoCloneMarkedNodes

    bunch.newP = p.next()
    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@+node:ekr.20050411193627.5: *8* afterCloneNode
def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'clone'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@+node:ekr.20050411193627.6: *8* afterDehoist
def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    u.pushBead(bunch)
#@+node:ekr.20050411193627.8: *8* afterDeleteNode
def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'delete'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@+node:ekr.20111005152227.15555: *8* afterDeleteMarkedNodes
def afterDeleteMarkedNodes (self,data,p):

    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'delete-marked-nodes'
    bunch.undoType = 'delete-marked-nodes'

    # Set helpers
    bunch.undoHelper = u.undoDeleteMarkedNodes
    bunch.redoHelper = u.redoDeleteMarkedNodes

    bunch.newP = p.copy()
    bunch.deleteMarkedNodesData = data
    # bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@+node:ekr.20080425060424.8: *8* afterDemote
def afterDemote (self,p,followingSibs,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'demote'
    bunch.undoType = 'Demote'

    bunch.undoHelper = u.undoDemote
    bunch.redoHelper = u.redoDemote

    bunch.followingSibs = followingSibs

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@+node:ekr.20050411193627.7: *8* afterHoist
def afterHoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'hoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    u.pushBead(bunch)
#@+node:ekr.20050411193627.9: *8* afterInsertNode
def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())

    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            v = bunch2.v
            afterTree.append(
                g.Bunch(v=v,head=v.h[:],body=v.b[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)
#@+node:ekr.20050526124257: *8* afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node for mark and unmark commands.'''

    # 'command' unused, but present for compatibility with similar methods.

    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark

    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@+node:ekr.20111005152227.15562: *8* afterMoveMarkedNodes
def afterMoveMarkedNodes (self,data,p):

    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'move-marked-nodes'
    bunch.undoType = 'move-marked-nodes'

    # Set helpers
    bunch.undoHelper = u.undoMoveMarkedNodes
    bunch.redoHelper = u.redoMoveMarkedNodes

    bunch.newP = p.copy()
    bunch.deleteMarkedNodesData = data
    # bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@+node:ekr.20050410110343: *8* afterMoveNode
def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'move'
    bunch.undoType = command

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newN = p.childIndex()
    bunch.newParent_v = p._parentVnode()
    bunch.newP = p.copy()

    u.pushBead(bunch)
#@+node:ekr.20080425060424.12: *8* afterPromote
def afterPromote (self,p,children,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'promote'
    bunch.undoType = 'Promote'

    bunch.undoHelper = u.undoPromote
    bunch.redoHelper = u.redoPromote

    bunch.children = children

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@+node:ekr.20080425060424.2: *8* afterSort
def afterSort (self,p,bunch,dirtyVnodeList):

    '''Create an undo node for sort operations'''

    u = self ; c = self.c
    if u.redoing or u.undoing: return

    bunch.dirtyVnodeList = dirtyVnodeList

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@+node:ekr.20050318085432.3: *7* beforeX...
#@+node:ekr.20050315134017.7: *8* beforeChangeGroup
def beforeChangeGroup (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command

    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
#@+node:ekr.20050315133212.2: *8* beforeChangeNodeContents
def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):

    '''Return data that gets passed to afterChangeNode'''

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBody = oldBody or p.b
    bunch.oldHead = oldHead or p.h

    return bunch
#@+node:ekr.20050315134017.6: *8* beforeChangeTree
def beforeChangeTree (self,p):

    # g.trace(p.h)

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    bunch = u.createCommonBunch(p)
    bunch.oldSel = w.getSelectionRange()
    bunch.oldText = w.getAllText()
    bunch.oldTree = u.saveTree(p)

    return bunch
#@+node:ekr.20050424161505.1: *8* beforeClearRecentFiles
def beforeClearRecentFiles (self):

    u = self ; p = u.c.p

    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch
#@+node:ekr.20050412080354: *8* beforeCloneNode
def beforeCloneNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    return bunch
#@+node:ekr.20050411193627.3: *8* beforeDeleteNode
def beforeDeleteNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()

    return bunch
#@+node:ekr.20050411193627.4: *8* beforeInsertNode
def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):

    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone

    if pasteAsClone:
        # Save the list of bunched.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
#@+node:ekr.20050526131252: *8* beforeMark
def beforeMark (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command

    return bunch
#@+node:ekr.20050410110215: *8* beforeMoveNode
def beforeMoveNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldN = p.childIndex()
    bunch.oldParent_v = p._parentVnode()

    return bunch
#@+node:ekr.20080425060424.3: *8* beforeSort
def beforeSort (self,p,undoType,oldChildren,newChildren,sortChildren):

    '''Create an undo node for sort operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'sort'
    bunch.undoType = undoType

    bunch.undoHelper = u.undoSort
    bunch.redoHelper = u.redoSort

    bunch.oldChildren = oldChildren
    bunch.newChildren = newChildren
    bunch.sortChildren = sortChildren # A bool

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    return bunch
#@+node:ekr.20050318085432.2: *8* createCommonBunch
def createCommonBunch (self,p):

    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = w and w.getSelectionRange() or None,
        p = p.copy(),
    )
#@+node:ekr.20110519074734.6092: *7* redo helpers
#@+node:ekr.20050424170219: *8* redoClearRecentFiles
def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@+node:ekr.20111005152227.15558: *8* redoCloneMarkedNodes
def redoCloneMarkedNodes (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.cloneMarked()
    u.newP = c.p
    u.newChanged = c.isChanged()
#@+node:ekr.20050412083057: *8* redoCloneNode
def redoCloneNode (self):

    u = self ; c = u.c ; cc = c.chapterController

    if cc: cc.selectChapterByName('main')

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
#@+node:ekr.20111005152227.15559: *8* redoDeleteMarkedNodes
def redoDeleteMarkedNodes (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteMarked()
    c.selectPosition(u.newP)
    u.newChanged = c.isChanged()
#@+node:EKR.20040526072519.2: *8* redoDeleteNode
def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@+node:ekr.20080425060424.9: *8* redoDemote
def redoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = u.p.childIndex()

    # Move the demoted nodes from the old parent to the new parent.
    parent_v.children = parent_v.children[:n+1]
    u.p.v.children.extend(u.followingSibs)

    # Adjust the parent links of the moved nodes.
    # There is no need to adjust descendant links.
    for v in u.followingSibs:
        v.parents.remove(parent_v)
        v.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
#@+node:ekr.20050318085432.6: *8* redoGroup
def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                # g.trace(z.redoHelper)
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('new') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty()

    if not g.unitTesting:
        g.es("redo",count,"instances")

    c.selectPosition(p)
    if newSel:
        i,j = newSel
        c.frame.body.setSelectionRange(i,j)
#@+node:ekr.20050412085138.1: *8* redoHoistNode & redoDehoistNode
def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
#@+node:ekr.20050412084532: *8* redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c ; cc = c.chapterController

    if cc: cc.selectChapterByName('main')

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    if u.pasteAsClone:
        for bunch in u.afterTree:
            v = bunch.v
            if u.newP.v == v:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
            # g.trace(v,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@+node:ekr.20050526125801: *8* redoMark
def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty()

        c.selectPosition(u.p)
#@+node:ekr.20050411111847: *8* redoMove
def redoMove (self):

    u = self ; c = u.c ; cc = c.chapterController
    v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    if cc: cc.selectChapterByName('main')

    # Adjust the children arrays.
    assert u.oldParent_v.children[u.oldN] == v
    del u.oldParent_v.children[u.oldN]

    parent_v = u.newParent_v
    parent_v.children.insert(u.newN,v)
    v.parents.append(u.newParent_v)
    v.parents.remove(u.oldParent_v)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
#@+node:ekr.20050318085432.7: *8* redoNodeContents
def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setBodyString(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)

    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        i,j = u.newSel
        u.c.frame.body.setSelectionRange(i,j)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()
#@+node:ekr.20111005152227.15564: *8* redoMoveMarkedNodes
def redoMoveMarkedNodes (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.moveMarked()
    c.selectPosition(u.newP)
    u.newChanged = c.isChanged()
#@+node:ekr.20080425060424.13: *8* redoPromote
def redoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()

    # Add the children to parent_v's children.
    n = u.p.childIndex() + 1

    old_children = parent_v.children[:]
    parent_v.children = old_children[:n]
        # Add children up to the promoted nodes.
    parent_v.children.extend(u.children)
        # Add the promoted nodes.
    parent_v.children.extend(old_children[n:])
        # Add the children up to the promoted nodes.

    # Remove the old children.
    u.p.v.children = []

    # Adjust the parent links in the moved children.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(u.p.v)
        child.parents.append(parent_v)

    c.setCurrentPosition(u.p)
#@+node:ekr.20080425060424.4: *8* redoSort
def redoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.newChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
#@+node:ekr.20050318085432.8: *8* redoTree
def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        i,j = u.newSel
        c.frame.body.setSelectionRange(i,j)
#@+node:EKR.20040526075238.5: *8* redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    if u.newSel:
        c.bodyWantsFocus()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@+node:ekr.20110519074734.6093: *7* undo helpers
#@+node:ekr.20050424170219.1: *8* undoClearRecentFiles
def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@+node:ekr.20111005152227.15560: *8* undoCloneMarkedNodes
def undoCloneMarkedNodes (self):

    u = self
    
    next = u.p.next()
    assert next.h == 'Clones of marked nodes',repr(u.p,next.h)
    next.doDelete()

    u.p.setAllAncestorAtFileNodesDirty()
    u.c.selectPosition(u.p)
#@+node:ekr.20050412083057.1: *8* undoCloneNode
def undoCloneNode (self):

    u = self ; c = u.c ; cc = c.chapterController

    if cc: cc.selectChapterByName('main')

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6

    c.selectPosition(u.p)
#@+node:ekr.20111005152227.15557: *8* undoDeleteMarkedNodes
def undoDeleteMarkedNodes (self):

    u = self ; c = u.c
    
    # Undo the deletes in reverse order
    aList = u.deleteMarkedNodesData[:]
    aList.reverse()

    for p in aList:
        if p.stack:
            parent_v,junk = p.stack[-1]
        else:
            parent_v = c.hiddenRootNode
            
        p.v._addLink(p._childIndex,parent_v)

    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@+node:ekr.20050412084055: *8* undoDeleteNode
def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p._linkAfter(u.oldBack)
    elif u.oldParent:
        u.p._linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p._linkAsRoot(oldRoot)

    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@+node:ekr.20080425060424.10: *8* undoDemote
def undoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)

    # Remove the demoted nodes from p's children.
    u.p.v.children = u.p.v.children[:-n]

    # Add the demoted nodes to the parent's children.
    parent_v.children.extend(u.followingSibs)

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for sib in u.followingSibs:
        sib.parents.remove(u.p.v)
        sib.parents.append(parent_v)

    c.setCurrentPosition(u.p)
#@+node:ekr.20050318085713: *8* undoGroup
def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            # g.trace(z.undoHelper)
            if z.undoHelper:
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('old') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if not g.unitTesting:
        g.es("undo",count,"instances")

    c.selectPosition(p)
    if oldSel:
        i,j = oldSel
        c.frame.body.setSelectionRange(i,j)
#@+node:ekr.20050412083244: *8* undoHoistNode & undoDehoistNode
def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@+node:ekr.20050412085112: *8* undoInsertNode
def undoInsertNode (self):

    u = self ; c = u.c ; cc = c.chapterController

    if cc: cc.selectChapterByName('main')

    c.selectPosition(u.newP)

    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            v = bunch.v
            if u.p.v == v:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@+node:ekr.20050526124906: *8* undoMark
def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty() # Bug fix: Leo 4.4.6.

        c.selectPosition(u.p)
#@+node:ekr.20050411112033: *8* undoMove
def undoMove (self):

    u = self ; c = u.c ; cc = c.chapterController

    if cc: cc.selectChapterByName('main')

    v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.newParent_v.children[u.newN] == v
    del u.newParent_v.children[u.newN]
    u.oldParent_v.children.insert(u.oldN,v)

    # Recompute the parent links.
    v.parents.append(u.oldParent_v)
    v.parents.remove(u.newParent_v)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.p)
#@+node:ekr.20050318085713.1: *8* undoNodeContents
def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setBodyString(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)

    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        i,j = u.oldSel
        u.c.frame.body.setSelectionRange(i,j)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.
#@+node:ekr.20111005152227.15563: *8* undoMoveMarkedNodes
def undoMoveMarkedNodes (self):

    u = self ; c = u.c
    
    # Undo the moves in reverse order
    aList = u.deleteMarkedNodesData[:]
    aList.reverse()
    root = c.rootPosition()

    for p in aList:
        if p.stack:
            parent_v,junk = p.stack[-1]
        else:
            parent_v = c.hiddenRootNode
            
        p.v._addLink(p._childIndex,parent_v)
        
    # A shortcut. This deletes all the "extra copies of the nodes".
    root.doDelete()
    
    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@+node:ekr.20080425060424.14: *8* undoPromote
def undoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode() # The parent of the all the *promoted* nodes.

    # Remove the promoted nodes from parent_v's children.
    n = u.p.childIndex() + 1

    # Adjust the old parents children
    old_children = parent_v.children
    parent_v.children = old_children[:n]
        # Add the nodes before the promoted nodes.
    parent_v.children.extend(old_children[n+len(u.children):])
        # Add the nodes after the promoted nodes.

    # Add the demoted nodes to v's children.
    u.p.v.children = u.children[:]

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(parent_v)
        child.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
#@+node:ekr.20031218072017.1493: *8* undoRedoText
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    # newNewlines is unused, but it has symmetry.

    trace = False and not g.unitTesting

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setBodyString(result)
    w.setAllText(result)
    sel = g.choose(tag=='undo',u.oldSel,u.newSel)
    if trace: g.trace(sel)
    if sel:
        i,j = sel
        w.setSelectionRange(i,j,insert=j)
    c.frame.body.recolor(p,incremental=False)
    w.seeInsertPoint() # 2009/12/21
#@+node:ekr.20061106105812.1: *9* << Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.b
body = g.toUnicode(body)
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = '\n'.join(s)
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
#@+node:ekr.20050408100042: *8* undoRedoTree
def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.b)

    return p # Nothing really changes.
#@+node:ekr.20080425060424.5: *8* undoSort
def undoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.oldChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
#@+node:ekr.20050318085713.2: *8* undoTree
def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        i,j = u.oldSel
        c.frame.body.setSelectionRange(i,j)
#@+node:EKR.20040526090701.4: *8* undoTyping
def undoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if u.oldSel:
        c.bodyWantsFocus()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@+node:ekr.20050318085432.2: *7* createCommonBunch
def createCommonBunch (self,p):

    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = w and w.getSelectionRange() or None,
        p = p.copy(),
    )
#@+node:ekr.20111006060936.15639: *6* afterCloneMarkedNodes
def afterCloneMarkedNodes (self,p):

    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)
    
        # Sets
        # oldChanged = c.isChanged(),
        # oldDirty = p.isDirty(),
        # oldMarked = p.isMarked(),
        # oldSel = w and w.getSelectionRange() or None,
        # p = p.copy(),

    # Set types & helpers
    bunch.kind = 'clone-marked-nodes'
    bunch.undoType = 'clone-marked-nodes'

    # Set helpers
    bunch.undoHelper = u.undoCloneMarkedNodes
    bunch.redoHelper = u.redoCloneMarkedNodes

    bunch.newP = p.next()
    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@+node:ekr.20111005152227.15555: *6* afterDeleteMarkedNodes
def afterDeleteMarkedNodes (self,data,p):

    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'delete-marked-nodes'
    bunch.undoType = 'delete-marked-nodes'

    # Set helpers
    bunch.undoHelper = u.undoDeleteMarkedNodes
    bunch.redoHelper = u.redoDeleteMarkedNodes

    bunch.newP = p.copy()
    bunch.deleteMarkedNodesData = data
    # bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@+node:ekr.20111005152227.15562: *6* afterMoveMarkedNodes
def afterMoveMarkedNodes (self,data,p):

    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'move-marked-nodes'
    bunch.undoType = 'move-marked-nodes'

    # Set helpers
    bunch.undoHelper = u.undoMoveMarkedNodes
    bunch.redoHelper = u.redoMoveMarkedNodes

    bunch.newP = p.copy()
    bunch.deleteMarkedNodesData = data
    # bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@+node:ekr.20111005152227.15558: *6* redoCloneMarkedNodes
def redoCloneMarkedNodes (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.cloneMarked()
    u.newP = c.p
    u.newChanged = c.isChanged()
#@+node:ekr.20111005152227.15559: *6* redoDeleteMarkedNodes
def redoDeleteMarkedNodes (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteMarked()
    c.selectPosition(u.newP)
    u.newChanged = c.isChanged()
#@+node:ekr.20111005152227.15564: *6* redoMoveMarkedNodes
def redoMoveMarkedNodes (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.moveMarked()
    c.selectPosition(u.newP)
    u.newChanged = c.isChanged()
#@+node:ekr.20111005152227.15560: *6* undoCloneMarkedNodes
def undoCloneMarkedNodes (self):

    u = self
    
    next = u.p.next()
    assert next.h == 'Clones of marked nodes',repr(u.p,next.h)
    next.doDelete()

    u.p.setAllAncestorAtFileNodesDirty()
    u.c.selectPosition(u.p)
#@+node:ekr.20111005152227.15557: *6* undoDeleteMarkedNodes
def undoDeleteMarkedNodes (self):

    u = self ; c = u.c
    
    # Undo the deletes in reverse order
    aList = u.deleteMarkedNodesData[:]
    aList.reverse()

    for p in aList:
        if p.stack:
            parent_v,junk = p.stack[-1]
        else:
            parent_v = c.hiddenRootNode
            
        p.v._addLink(p._childIndex,parent_v)

    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@+node:ekr.20111005152227.15563: *6* undoMoveMarkedNodes
def undoMoveMarkedNodes (self):

    u = self ; c = u.c
    
    # Undo the moves in reverse order
    aList = u.deleteMarkedNodesData[:]
    aList.reverse()
    root = c.rootPosition()

    for p in aList:
        if p.stack:
            parent_v,junk = p.stack[-1]
        else:
            parent_v = c.hiddenRootNode
            
        p.v._addLink(p._childIndex,parent_v)
        
    # A shortcut. This deletes all the "extra copies of the nodes".
    root.doDelete()
    
    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@+node:ekr.20080427062528.9: *6* v.Low level methods
#@+node:ekr.20090706110836.6135: *7* v._addLink & helper
def _addLink (self,childIndex,parent_v,adjust=True):
    '''Adjust links after adding a link to v.'''

    trace = False and not g.unitTesting
    v = self

    # Update parent_v.children & v.parents.
    parent_v.children.insert(childIndex,v)
    v.parents.append(parent_v)
    if trace: g.trace('*** added parent',parent_v,'to',v,
        'len(parents)',len(v.parents))

    # Set zodb changed flags.
    v._p_changed = 1
    parent_v._p_changed = 1

    # If v has only one parent, we adjust all
    # the parents links in the descendant tree.
    # This handles clones properly when undoing a delete.
    if adjust:
        if len(v.parents) == 1:
            for child in v.children:
                child._addParentLinks(parent=v)
#@+node:ekr.20090804184658.6129: *8* v._addParentLinks
def _addParentLinks(self,parent): 

    trace = False and not g.unitTesting
    v = self

    v.parents.append(parent)
    if trace: g.trace(
        '*** added parent',parent,'to',v,'len(parents)',len(v.parents))

    if len(v.parents) == 1:
        for child in v.children:
            child._addParentLinks(parent=v)
#@+node:ekr.20090804184658.6128: *7* v._cutLink
def _cutLink (self,childIndex,parent_v):
    '''Adjust links after cutting a link to v.'''
    v = self

    assert parent_v.children[childIndex]==v
    del parent_v.children[childIndex]
    v.parents.remove(parent_v)
    v._p_changed = 1
    parent_v._p_changed = 1

    # If v has no more parents, we adjust all
    # the parent links in the descendant tree.
    # This handles clones properly when deleting a tree.
    if len(v.parents) == 0:
        for child in v.children:
            child._cutParentLinks(parent=v)
#@+node:ekr.20090804190529.6133: *8* v._cutParentLinks
def _cutParentLinks(self,parent):

    trace = False and not g.unitTesting
    v = self

    if trace: g.trace('parent',parent,'v',v)
    v.parents.remove(parent)

    if len(v.parents) == 0:
        for child in v.children:
            child._cutParentLinks(parent=v)
#@+node:ekr.20031218072017.3425: *7* v._linkAsNthChild (used by 4.x read logic)
def _linkAsNthChild (self,parent_v,n):

    """Links self as the n'th child of vnode pv"""

    v = self # The child node.
    v._addLink(n,parent_v)
#@+node:ekr.20090905110447.6098: *5* c.cloneMarked
def cloneMarked(self,event=None):

    """Clone all marked nodes as children of a new node."""

    c = self ; u = c.undoer ; p1 = c.p.copy()

    # Create a new node to hold clones.
    parent = p1.insertAfter()
    parent.h = 'Clones of marked nodes'

    moved,n,p = [],0,c.rootPosition()
    while p:
        # Careful: don't clone already-cloned nodes.
        if p == parent:
            p.moveToNodeAfterTree()
        elif p.isMarked() and not p.v in moved:
            moved.append(p.v)
            # Moving the clone leaves position p unchanged.
            p.clone().moveToLastChildOf(parent)
            p.moveToNodeAfterTree()
            n += 1
        else:
            p.moveToThreadNext()

    if n:
        c.setChanged(True)
        parent.expand()
        c.selectPosition(parent)
        u.afterCloneMarkedNodes(p1)
    else:
        parent.doDelete()
        c.selectPosition(p1)

    if not g.unitTesting:
        g.es('cloned %s nodes' % (n),color='blue')
    c.redraw()    
#@+node:ekr.20111005081134.15540: *5* c.deleteMarked
def deleteMarked (self,event=None):
    
    """Delete all marked nodes."""
    
    c = self ; u = c.undoer ; p1 = c.p.copy()
    
    undo_data,p = [],c.rootPosition()
    while p:
        if p.isMarked():
            undo_data.append(p.copy())
            next = p.positionAfterDeletedTree()
            p.doDelete()
            p = next
        else:
            p.moveToThreadNext()

    if undo_data:
        u.afterDeleteMarkedNodes(undo_data,p1)
        if not g.unitTesting:
            g.es('deleted %s nodes' % (len(undo_data)),color='blue')
        c.setChanged(True)

    # Don't even *think* about restoring the old position.
    c.contractAllHeadlines()
    c.selectPosition(c.rootPosition())
    c.redraw()    
#@+node:ekr.20111005081134.15539: *5* c.moveMarked & helper
def moveMarked (self,event=None):

    '''Move all marked nodes as children of parent position.'''
    
    c = self ; u = c.undoer ; p1 = c.p.copy()
    
    # Check for marks.
    for v in c.all_unique_nodes():
        if v.isMarked():
            break
    else:
        return g.es('no marked nodes',color='blue')

    # Create a new root node to hold the moved nodes.
    parent = c.createMoveMarkedNode()
    assert not parent.isMarked()

    undo_data,p = [],c.rootPosition()
    while p:
        assert parent == c.rootPosition()
        # Careful: don't move already-moved nodes.
        if p.isMarked() and not parent.isAncestorOf(p):
            undo_data.append(p.copy())
            next = p.positionAfterDeletedTree()
            p.moveToLastChildOf(parent)
            p = next
        else:
            p.moveToThreadNext()

    if undo_data:
        u.afterMoveMarkedNodes(undo_data,p1)
        if not g.unitTesting:
            g.es('moved %s nodes' % (len(undo_data)),color='blue')
        c.setChanged(True)
        
    # Don't even *think* about restoring the old position.
    c.contractAllHeadlines()
    c.selectPosition(parent)
    c.redraw()    
#@+node:ekr.20111005081134.15543: *6* createMoveMarkedNode
def createMoveMarkedNode(self):
    
    c = self
    oldRoot = c.rootPosition()
    p = oldRoot.insertAfter()
    p.moveToRoot(oldRoot)
    c.setHeadString(p,'Moved marked nodes')
    return p
#@+node:ekr.20111009101205.7134: *4* Open now shows all files
@nocolor-node

Surprisingly important: it is a not-so-subtle clue that *any* file may be
opened: non-Leo files are opened in @edit nodes. Soon: external files containing
Leo sentinels will be opened as @file nodes.
#@+node:ekr.20111009104133.7160: *4* Made open smarter
@nocolor-node

Create @file nodes (not @thin nodes) when opening an external file.

Changed g.openWrapperLeoFile to create @file instead of @edit when possible.

Changed c.open; minor changes to importDerivedFiles.
#@+node:ekr.20031218072017.1810: *5* importDerivedFiles
def importDerivedFiles (self,parent=None,paths=None,command='Import'):
    # Not a command.  It must *not* have an event arg.
    # command is None when this is called to import a file from the command lline.
    c = self.c ; u = c.undoer ; at = c.atFileCommands
    current = c.p or c.rootPosition()
    self.tab_width = self.getTabWidth()
    if not paths:
        return None
    # Initial open from command line is not undoable.
    if command: u.beforeChangeGroup(current,command)
    for fileName in paths:
        fileName = fileName.replace('\\','/') # 2011/10/09.
        g.setGlobalOpenDir(fileName)
        << set isThin if fileName is a thin derived file >>
        if command: undoData = u.beforeInsertNode(parent)
        p = parent.insertAfter()
        if isThin:
            # 2010/10/09: create @file node, not a deprecated @thin node.
            p.initHeadString("@file " + fileName)
            at.read(p)
        else:
            p.initHeadString("Imported @file " + fileName)
            at.read(p,importFileName=fileName)
        p.contract()
        p.setDirty() # 2011/10/09: tell why the file is dirty!
        if command: u.afterInsertNode(p,command,undoData)
    current.expand()
    c.setChanged(True)
    if command: u.afterChangeGroup(p,command)
    c.redraw(current)
    return p
#@+node:ekr.20040930135204: *6* << set isThin if fileName is a thin derived file >>
# 2011/10/09: g.os.path.normpath converts to *back* slashes!

# fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
#@+node:ekr.20031218072017.2821: *5* c.open & helper
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>
    table = [
        # 2010/10/09: Fix an interface blunder. Show all files by default.
        ("All files","*"),
        ("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()
    
    c.init_error_dialogs()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            ok, frame = g.openWithFileName(fileName,c)
            if ok:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if ok and closeFlag:
                g.app.destroyWindow(c.frame)
        elif c.looksLikeDerivedFile(fileName):
            # 2011/10/09: A smart open makes Leo lighter:
            # Create an @file node for files containing Leo sentinels.
            ok = c.importCommands.importDerivedFiles(parent=c.p,
                paths=[fileName],command='Open')
        else:
            # otherwise, create an @edit node.
            ok = c.createNodeFromExternalFile(fileName)
            
    c.raise_error_dialogs(kind='write')

    # openWithFileName sets focus if ok.
    if not ok:
        c.initialFocusHelper()
#@+node:ekr.20031218072017.2822: *6* << Set closeFlag if the only open window is empty >>
@
If this is the only open window was opened when the app started, and
the window has never been written to or saved, then we will
automatically close that window if this open command completes
successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfUntitledWindows == 1) # Only one untitled window has ever been opened
#@+node:ekr.20090212054250.9: *6* c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
#@+node:ekr.20111010154337.15586: *4* Improved create @auto nodes script
#@+node:ekr.20111010122531.15571: *4* Rewrote shell-command commands
#@+node:ekr.20050920084036.158: *5* shellCommand
def shellCommand (self,event):

    '''Execute a shell command.'''

    k = self.k ; state = k.getState('shell-command')

    if state == 0:
        k.setLabelBlue('shell-command: ',protect=True)
        k.getArg(event,'shell-command',1,self.shellCommand)
    else:
        command = k.arg
        k.commandName = 'shell-command: %s' % command
        k.clearState()
        self.executeSubprocess(event,command)
    
#@+node:ekr.20050930112126: *5* shellCommandOnRegion
def shellCommandOnRegion (self,event):

    '''Execute a command taken from the selected text in a separate process.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        command = w.getSelectedText()
        k.commandName = 'shell-command: %s' % command
        self.executeSubprocess(event,command)
    else:
        k.clearState()
        k.setLabelRed('No text selected')
#@+node:ekr.20050920084036.160: *5* executeSubprocess
def executeSubprocess (self,event,command):

    '''Execute a command in a separate process.'''

    k = self.k

    try:
        args = shlex.split(command)
        subprocess.Popen(args).wait()
        k.setLabelGrey('Done: %s' % command)
    except Exception:
        junk, x, junk = sys.exc_info()
        k.setLabelRed('Exception: %s' % repr(x))
#@+node:ekr.20111010122531.15572: *4* Added shell commands to Cmds menu
#@+node:ekr.20111011052729.15681: *4* Added quick edit/save mode
@nocolor-node

The idea is to allow Leo to be a drop-in replacement for SciTe.

Suppose you do::
    
    leo x.y
    
where y is not "leo".

1. If x.y exists, Leo should:
    
- Open an unnamed .leo file consisting of @edit x.y.

- If you execute the save command, or close the Leo window,
  Leo should save x.y if it has been changed, but *not* prompt
  you to save the "temporary" .leo file.
  
2. If x.y does *not* exist, leo should do exactly the same
   thing, except that @edit x.y will be empty.
   
However, there are two problems with using Leo as a replacement for SciTe:

1. Load time.  SciTe loads instantly, Leo does not.

2. Screen real estate: Leo is not at its best when presenting only a single
   @edit node: everything but the body pane is wasted space.
#@+node:ekr.20111011062533.15685: *5* Request
@language rest

https://bugs.launchpad.net/leo-editor/+bug/381527

Opens a new nameless leo file and adds somefile.foo as an @edit node.

This is good but...

Saving is a pain, because you have to give a name / location for the .leo file,
and in the quick edit use case you want to be able to just hit ctrl-S to save
somefile.foo.

=====

Ah, at last I see the problem. Saving the **.leo** file is too "heavy". This is
an interesting design problem. You could say that Leo could "throw away" the
temporary .leo file, provided it contains only the @edit node.

True, "quick" editing of a non-Leo file could be done in the workbook, but such
an approach would litter the workbook, and would make opening the workbook
slower and slower. That is, the workbook would get heavier and heavier.
#@+node:ekr.20111011062533.15684: *5* Checkin log
@nocolor-node

Rev 4577 adds an important new feature: "quick edit/save mode"

This fixes bug 381527 quick edit and save use of leo, and makes Leo considerably lighter.

**Important**: As you will see below, quite a few hacks were needed to make this work.  That doesn't bother me at all, because they are all hidden.  The *effect* of those hacks is easily understandable.

**However**, I may have missed something: I almost missed that I had to change the code that prompts for a save when closing an unsaved headline.  So please be on the lookout for any use cases that I missed.

From the checkin log:

QQQQQ

"leo somefile.foo" opens a nameless .leo file containing a single @edit node.

In quick edit/save mode, the user can change somefile.foo without saving the .leo file at all.

Leo *does* properly prompt for saves so that changes to somefile.foo will not be lost.

Quick edit/save mode changes Leo as follows:

1. The save command, and *only* the save command (not save-as or save-to), looks for an unsaved .leo file containing a single @edit node. This is the "quick save" case.

In this case, Leo does *not* prompt for a filename and does *not*, therefore, save the .leo file. However, Leo does save the @edit node if it is dirty.

2. In the quick edit/save case, atFile.writeOneAtEdit node does *not* prompt for so-called dangerous writes, because, in fact, the write is not dangerous :-)

3. In the quick edit/save case, leoFrame.promptForSave prompts for saving the @edit file, *not* the .leo file.

QQQQQ

I forgot to mention one detail.  There is no way to save the .leo file itself in quick edit/save mode.  If you want to do that, simply add any other node at the top level of the outline.  This ends quick edit/save mode.  When you save or close the outline, Leo will prompt you for the name of the .leo file as usual.

Edward
#@+node:ekr.20111012172344.9383: *5* Write logic...
#@+node:ekr.20111012172344.9387: *6* Changed...
#@+node:ekr.20031218072017.2834: *7* c.save
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)
    
    if g.unitTesting and g.app.unitTestDict.get('init_error_dialogs') is not None:
        # A kludge for unit testing:
        # indicated that c.init_error_dialogs and c.raise_error_dialogs
        # will be called below, *without* actually saving the .leo file.
        c.init_error_dialogs()
        c.raise_error_dialogs(kind='write')
        return
    
    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return
        
    c.init_error_dialogs()

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        root = c.rootPosition()
        if not root.next() and root.isAtEditNode():
            # There is only a single @edit node in the outline.
            # A hack to allow "quick edit" of non-Leo files.
            # See https://bugs.launchpad.net/leo-editor/+bug/381527
            fileName = None
            # Write the @edit node if needed.
            if root.isDirty():
                c.atFileCommands.writeOneAtEditNode(root,
                    toString=False,force=True)
            c.setChanged(False)
        else:
            fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
    
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            if g.app.qt_use_tabs and hasattr(c.frame,'top'):
                c.frame.top.leo_master.setTabName(c,c.mFileName)
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    # Done in fileCommands.save.
    # c.redraw_after_icons_changed()
    
    c.raise_error_dialogs(kind='write')

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocus()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocus()
#@+node:ekr.20090225080846.5: *7* at.writeOneAtEditNode
def writeOneAtEditNode(self,p,toString,force=False):

    '''Write one @edit node.'''

    at = self ; c = at.c
    root = p.copy()
    c.endEditing()
    c.init_error_dialogs()

    fn = p.atEditNodeName()
    if not fn and not toString: return False

    if p.hasChildren():
        g.es('@edit nodes must not have children',color='red')
        g.es('To save your work, convert @edit to @auto or @thin')
        return False

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fn = c.os_path_finalize_join(at.default_directory,fn)
    if not force and at.shouldPromptForDangerousWrite(fn,root):
        # Prompt if writing a new @edit node would overwrite the existing file.
        ok = self.promptForDangerousWrite(fn,kind='@edit')
        if ok:
            # Fix bug 889175: Remember the full fileName.
            at.rememberReadPath(fn,root)
        else:
            g.es("not written:",fn)
            return False

    at.targetFileName = fn
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True, atEdit=True,
        nosentinels=True,thinFile=False,
        scriptWrite=False,toString=toString)

    # Compute the file's contents.
    # Unlike the @nosent file logic it does not add a final newline.
    contents = ''.join([s for s in g.splitLines(p.b)
        if at.directiveKind4(s,0) == at.noDirective])

    if toString:
        at.stringOutput = contents
        return True

    ok = at.openFileForWriting(root,fileName=fn,toString=False)
    if ok:
        self.os(contents)
        at.closeWriteFile()
    if ok and at.errors == 0:
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
    else:
        g.es("not written:",at.targetFileName) # 2010/10/22
        root.setDirty()
        root.setOrphan() # 2010/10/22
        
    c.raise_error_dialogs(kind='write')

    return ok
#@+node:ekr.20041005105605.142: *7* at.openFileForWriting & helper
def openFileForWriting (self,root,fileName,toString):

    trace = False and not g.unitTesting
    at = self
    at.outputFile = None

    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "<string: %s>" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        ok = at.openFileForWritingHelper(fileName)

        # New in Leo 4.4.8: set dirty bit if there are errors.
        if not ok: at.outputFile = None
        
    if trace: g.trace('root',repr(root and root.h),'outputFile',repr(at.outputFile))

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()

    return at.outputFile is not None
#@+node:ekr.20041005105605.143: *8* at.openFileForWritingHelper & helper
def openFileForWritingHelper (self,fileName):

    '''Open the file and return True if all went well.'''

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        at.targetFileName = c.os_path_finalize_join(at.default_directory,fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return False
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return False

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not open: read only: " + at.targetFileName)
                return False
        except AttributeError:
            pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        kind,at.outputFile = self.openForWrite(at.outputFileName,'wb')
        if not at.outputFile:
            kind = g.choose(kind=='check',
                'did not overwrite','can not create')
            at.writeError("%s %s" % (kind,at.outputFileName))
            return False
    except Exception:
        at.exception("exception creating:" + at.outputFileName)
        return False

    return True
#@+node:bwmulder.20050101094804: *9* at.openForWrite
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    try:
        # 2011/10/11: in "quick edit/save" mode the .leo file may not have a name.
        if c.fileName():
            shadow_filename = x.shadowPathName(filename)
            self.writing_to_shadow_directory = os.path.exists(shadow_filename)
            open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
            self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)
        else:
            self.writing_to_shadow_directory = False
            open_file_name = filename

        if self.writing_to_shadow_directory:
            if trace: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
#@+node:ekr.20031218072017.3692: *7* promptForSave (leoFrame)
def promptForSave (self):

    """Prompt the user to save changes.

    Return True if the user vetos the quit or save operation."""

    c = self.c

    theType = g.choose(g.app.quitting, "quitting?", "closing?")
    
    # See if we are in quick edit/save mode.
    root = c.rootPosition()
    quick_save = not c.mFileName and not root.next() and root.isAtEditNode()
    
    if quick_save:
        name = g.shortFileName(root.atEditNodeName())
    else:
        name = g.choose(c.mFileName,c.mFileName,self.title)

    answer = g.app.gui.runAskYesNoCancelDialog(c,
        "Confirm",
        'Save changes to %s before %s' % (name,theType))

    # g.pr(answer)
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            root = c.rootPosition()
            if not root.next() and root.isAtEditNode():
                # There is only a single @edit node in the outline.
                # A hack to allow "quick edit" of non-Leo files.
                # See https://bugs.launchpad.net/leo-editor/+bug/381527
                fileName = None
                # Write the @edit node if needed.
                if root.isDirty():
                    c.atFileCommands.writeOneAtEditNode(root,
                        toString=False,force=True)
                return False # Don't save and don't veto.
            else:
                c.mFileName = g.app.gui.runSaveFileDialog(
                    initialfile = '',
                    title="Save",
                    filetypes=[("Leo files", "*.leo")],
                    defaultextension=".leo")
                
                c.bringToFront()

        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.
#@+node:ekr.20111012172344.9384: *5* Read logic...
#@+node:ekr.20111012172344.9385: *6* Changed
#@+node:ekr.20080921154026.1: *7* g.openWrapperLeoFile
def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''
    
    # Never open a non-existent file during unit testing.
    if g.unitTesting and not g.os_path_exists(fileName):
        return None
    
    # 2011/10/12: support quick edit-save mode.
    # We will create an @edit node below for non-existent files.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)
    assert c.rootPosition()

    # Needed for plugins.
    if 0: # This causes duplicate common buttons.
        g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    fileName = g.os_path_finalize(fileName)

    if not g.os_path_exists(fileName):
        # 2011/10/12: Create an empty @edit node.
        p = c.rootPosition()
        p.setHeadString('@edit %s' % fileName)
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fileName):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fileName],command=None) # Not undoable.
        if not p: return None
    else:
        # Create an @edit node.
        s,e = g.readFileIntoString(fileName)
        if s is None: return None
        p = c.rootPosition()
        if p:
            p.setHeadString('@edit %s' % fileName)
            p.setBodyString(s)
            c.selectPosition(p)

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(False)
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
#@+node:ekr.20041124083125: *7* completeFileName
def completeFileName (fileName):

    fileName = g.toUnicode(fileName)
    fileName = g.os_path_finalize(fileName)

    # 2011/10/12: don't add .leo to *any* file.
    return fileName
#@+node:ekr.20111012172344.9386: *6* Reference
#@+node:ekr.20031218072017.1624: *7* createFrame & helpers (runLeo.py)
def createFrame (fileName,options):

    """Create a LeoFrame during Leo's startup process."""
    
    # g.trace('(runLeo.py)',fileName)

    script = options.get('script')

    # Try to create a frame for the file.
    if fileName:
        ok, frame = g.openWithFileName(fileName,None)
        if ok and frame:
            c2 = frame.c
            select = options.get('select')
            windowSize = options.get('windowSize')
            if select: doSelect(c2,select)
            if windowSize: doWindowSize(c2,windowSize)
            return c2,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        initEditCommanders=True)

    if not script:
        g.app.writeWaitingLog(c) # 2009/12/22: fixes bug 448886

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False)
            # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@+node:ekr.20100913171604.5888: *8* doSelect
def doSelect (c,s):

    '''Select the node with key s.'''

    p = findNode(c,s)

    if p:
        c.selectPosition(p)
    else:
        g.es_print('--select: not found:',s)
#@+node:ekr.20100913171604.5885: *8* doWindowSize
def doWindowSize (c,windowSize):

    w = c.frame.top

    try:
        h,w2 = windowSize.split('x')
        h,w2 = int(h.strip()),int(w2.strip())
        w.resize(w2,h) # 2010/10/08.
        c.k.simulateCommand('equal-sized-panes')
        c.redraw()
        w.repaint() # Essential
    except Exception:
        print('doWindowSize:unexpected exception')
        g.es_exception()
#@+node:ekr.20100913171604.5889: *8* findNode
def findNode (c,s):

    s = s.strip()

    # First, assume s is a gnx.
    for p in c.all_unique_positions():
        if p.gnx.strip() == s:
            return p

    for p in c.all_unique_positions():
        # g.trace(p.h.strip())
        if p.h.strip() == s:
            return p

    return None
#@+node:ekr.20090520055433.5945: *7* g.openWithFileName & helpers
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists.

    returns ok,frame

    where frame.c is the commander of the newly-opened outline.
    """
    
    if not fileName: return False, None
    isLeo,fn,relFn = g.mungeFileName(fileName)
    
    # Return if the file is already open.
    c = g.findOpenFile(fn)
    if c: return True,c.frame

    # Open the file.
    app.setLog(None) # 2010/10/20
    app.lockLog()# 2010/10/20
    if isLeo:
        c,f = g.openWithFileNameHelper(old_c,gui,fn,relFn)
    else:
        c,f = g.openWrapperLeoFile(old_c,fn,gui),None

    app.unlockLog()# 2010/10/20
    if not c: return False,None

    # Init the open file.
    assert c.frame and c.frame.c == c
    c.frame.log.enable(enableLog)
    # Handle the open hooks and open the log for c.
    ok = g.handleOpenHooks(c,old_c,gui,fn,f,readAtFileNodesFlag)
    if not ok: return False,None
    g.app.writeWaitingLog(c)
    c.setLog() # 2010/10/20
    g.createMenu(c,fn)
    g.finishOpen(c)
    return True,c.frame
#@+node:ekr.20090520055433.5951: *8* g.createMenu
def createMenu(c,fileName=None):

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.

    if not g.doHook("menu1",c=c,p=c.p,v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        c.updateRecentFiles(fileName)
        g.doHook("menu2",c=c,p=c.p,v=c.p)
        g.doHook("after-create-leo-frame",c=c)
        g.doHook("after-create-leo-frame2",c=c)
#@+node:ekr.20090520055433.5948: *8* g.findOpenFile
def findOpenFile(fileName):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fileName)) == g.os_path_realpath(munge(c.mFileName)):
            frame.bringToFront()
            c.setLog()
            # 2011/11/21: selecting the new tab ensures focus is set.
            master = hasattr(frame.top,'leo_master') and frame.top.leo_master
            if master: # frame.top.leo_master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
#@+node:ekr.20090520055433.5952: *8* g.finishOpen
def finishOpen(c):

    k = c.k
    # New in Leo 4.6: provide an official way for very late initialization.

    # # 2011/11/21: selecting the new tab ensures focus is set.
    # master = hasattr(c.frame.top,'leo_master') and c.frame.top.leo_master
    # if master: # frame.top.leo_master is a TabbedTopLevel.
        # master.select(c)

    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    if k:
        k.setDefaultInputState()
    c.initialFocusHelper()
    if k:
        k.showStateAndMode()

    c.frame.initCompleteHint()
    return True
#@+node:ekr.20090520055433.5950: *8* g.handleOpenHooks
def handleOpenHooks(c,old_c,gui,fileName,theFile,readAtFileNodesFlag):

    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        if theFile:
            ok = c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            if not ok:
                g.app.closeLeoWindow(c.frame)
                return False
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)

    # Bug fix in 4.4.
    if not c.openDirectory:
        c.openDirectory = c.frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    return True
#@+node:ekr.20090520055433.5954: *8* g.mungeFileName
def mungeFileName(fileName):

    '''Create a full, normalized, Unicode path name, preserving case.'''

    relFn = g.os_path_normpath(fileName)
    fn = g.os_path_finalize(fileName)

    isZipped = fn and zipfile.is_zipfile(fn)
    isLeo = isZipped or fn.endswith('.leo')

    return isLeo,fn,relFn
#@+node:ekr.20090520055433.5946: *8* g.openWithFileNameHelper
def openWithFileNameHelper(old_c,gui,fileName,relativeFileName):

    if old_c: g.preRead(fileName)
    g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile:
        return None,None

    # This call will take 3/4 sec. to open a file from the leoBridge.
    # This is due to imports in c.__init__
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)

    c.isZipped = isZipped
    return c,theFile
#@+node:ekr.20090520055433.5949: *9* preRead
def preRead(fileName):

    '''Read the file for the first time,
    setting the setting for a later call to finishCreate.
    '''

    c = g.app.config.openSettingsFile(fileName)
    if c:
        g.app.config.updateSettings(c,localFlag=True)
#@+node:ekr.20080921154026.1: *8* g.openWrapperLeoFile
def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''
    
    # Never open a non-existent file during unit testing.
    if g.unitTesting and not g.os_path_exists(fileName):
        return None
    
    # 2011/10/12: support quick edit-save mode.
    # We will create an @edit node below for non-existent files.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)
    assert c.rootPosition()

    # Needed for plugins.
    if 0: # This causes duplicate common buttons.
        g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    fileName = g.os_path_finalize(fileName)

    if not g.os_path_exists(fileName):
        # 2011/10/12: Create an empty @edit node.
        p = c.rootPosition()
        p.setHeadString('@edit %s' % fileName)
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fileName):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fileName],command=None) # Not undoable.
        if not p: return None
    else:
        # Create an @edit node.
        s,e = g.readFileIntoString(fileName)
        if s is None: return None
        p = c.rootPosition()
        if p:
            p.setHeadString('@edit %s' % fileName)
            p.setBodyString(s)
            c.selectPosition(p)

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(False)
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
#@+node:ekr.20111011165246.15707: *4* Searches from Leo's web pages now work
Updating Sphinx and using new .js files did the trick.
#@+node:ekr.20110919113533.6818: *4* Added @button split-defs
#@+node:ekr.20111013104917.15659: *4* MacOS is no longer fully supported
@nocolor-node

Leo's home page no longer mentions MacOS and LeoDocs.leo and install.txt now
warn people that MacOS is difficult to install.
#@+node:ekr.20111015194452.15694: *4* Added support for tags in @button nodes
@nocolor-node

The mod_scripting plugin so that the name of the command created by an @button
nodes does not include any [<tag>] that immediately follows @button. Examples::

    @button [ekr] x
    @button [edit] y
    @button [important] z

These buttons create commands named x, y and z, and the name of the buttons are
x, y and z.

Note that the '[' must be the first non-blank after @button to be recognized and
removed.

The code is a straightforward addition to cleanButtonText in mod_scripting.py:
it is unlikely to have any impact whatsoever to existing @button nodes.

The intended use is for searches of the form @button [some tag].
#@+node:ekr.20111018104244.15929: *4* Reorganized @button & @command nodes.
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/bd6ed96c88fabb4e

The prefix "DingDing" signifies that this post is an answer to the
lament:

    "Wouldn't it be great if we all could remember what we,
    and others, have already done :-)"

Last night I had a forehead-slapping moment: the place to put @button
nodes is in myLeoSettings.leo.

This morning, I realized that using @command rather than @button
completes the Aha.

This organization has all benefits, and no drawbacks:

- I always know here scripts are.

- No need for duplicates.

- I can organize the scripts within myLeoSettings.leo as usual using
organizer nodes.  This organization can change as needed.

- Using @command rather than @button means that I never have to
disable scripts.  No more @@button.

- Using @command saves screen real estate.  In my experience, having
buttons be visible doesn't prevent them from being hidden in full
view.

- If I use common prefixes, like c_ (for command) or edit_ (for edit-
related scripts) or ekr_ (for personal scripts), the *typing
completion* will let me zero in on the script I want to use:

    <alt-x> c_<tab>
    <alt-x> c_import<tab>

etc.  Furthermore, Ctrl-P (repeat-complex-command) will allow me to
rerun the last script run.  This is a quite common case.

Summary
=======

This Aha substitutes an *already-existing* usage (typing completion)
for a whole set of memory-intensive retrieval problems.  I'm not
likely ever to forget typing completion, although I might forget the
specif prefixes used in @command nodes.  If that happens, I'll know
where to look.

This Aha takes full advantage of Leo's organization strengths and
*concentrates* those strengths by putting all the to-be-organized
material in one place.  This allows for easy reorganization:  changing
command-name prefixes, for instance, would be straightforward. 
#@+node:ekr.20111018104244.15930: *4* DingDing: big Aha's
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/9ebd0dd748f3011f

1. Today's work promises to *end* my confusion about scripts:

Scripts will typically be found in myLeoSettings.leo, or, for
"official" scripts, in other places, particularly leoSettings.leo.

The print-buttons command (maybe better called print-scripts) will
show the location of @button or @command nodes.

2. This is a huge breakthrough, because it makes hundreds of scripts
easily available.  This in turn makes *all* scripts more valuable.

3. As I was thinking about these happy developments, I realized that a
big new horizon is about to open up.

I shall not describe here my thought processes, but they were related
to what I have been thinking of as @link nodes. The idea behind @link
nodes was that they would be a link to a given node, specified by a
commander and a gnx.

However, scripts moot the need for @link nodes!  The phrase that
popped into my head was::

    Don't *link* to nodes, *search* for nodes!

That is, links, no matter how "good" they are, are breakable and
fragile; searches are more robust and more dynamic.  Bye bye link
nodes!

4.  Do you see what has just happened?  A search, in other words **a
script**, has eliminated the need for a major new core feature, that
is, link nodes.

This is a *huge* change in point of view!

5.  Here are some implications:

A.  Leo must have a check-doc-strings script that will verify that all
commands have non-trivial doc strings.

B. Leo must have a create-command-docs script that will create large
parts of Leo's documentation for individual commands by searching for
commands in all the proper places, including functions specified by
@g.command(name) and Leo's various commands dictionaries.

C. Leo must have a create-plugins-doc script that does the same for
plugins.  A prototype of this script exists somewhere.  Making it an
@command node will make it much more visible.

Conclusions
==========

1. "Smallish" changes (making scripts more visible via typing
completion) has greatly increased the convenience, and thus
application, of scripts.

Part of the Leo Aha is that Leo outlines are *much* easier to script
than flat files.  We are about to see an explosion in applicability of
scripts in Leo.

2. Searches, that is, scripts, are a *much* more powerful mechanism
than breakable links.  My throwaway response to many feature requests
has always been, "well, you can always write a script to do what you
want."

Now we can see the sense in which this is a proper, universal,
response.  In Leo's case, it has recently become clear that docstrings
are the natural *primary* location for data.  This makes the data
available for online help, such as the help-for-command command.

Now we can see that the *proper* way of creating large parts of Leo's
documentation tree (nodes for the rst3 command) will be via one or
more scripts that dynamically search Leo's source files looking for
data!

A great day for Leo.
#@+node:ekr.20111018163319.9412: *4* help-for-command now uses g.getDocStringFromFunction
#@+node:ekr.20111020120612.15897: *4* @ignore now prevents local @button/@command node definitions
@nocolor-node

A big improvement.  There is no longer any need for @@buton, etc.: just put under an @ignore node.

test.leo illustrates the new organization.
#@+node:ekr.20111003161039.15481: *4* Added support for solarized colors
@nocolor-node

http://ethanschoonover.com/solarized


- 

#@+node:ekr.20110605121601.18180: *5* class leoQtBody (leoBody)
class leoQtBody (leoFrame.leoBody):

    """A class that represents the body pane of a Qt window."""

    @others
#@+node:ekr.20110605121601.18181: *6*  Birth
#@+node:ekr.20110605121601.18182: *7*  ctor (qtBody)
def __init__ (self,frame,parentFrame):

    trace = False and not g.unitTesting

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c
    assert c.frame == frame and frame.c == c

    self.useScintilla = c.config.getBool('qt-use-scintilla')
    
    self.unselectedBackgroundColor = c.config.getColor(
        # 'unselected-background-color')
        'unselected_body_bg_color')
        
    # 2011/03/14
    self.unselectedForegroundColor = c.config.getColor(
        'unselected_body_fg_color')

    # Set the actual gui widget.
    if self.useScintilla:
        self.widget = w = leoQScintillaWidget(
            c.frame.top.textEdit,
            name='body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.
        self.colorizer = leoFrame.nullColorizer(c) # 2011/02/07
    else:
        top = c.frame.top
        sw = top.leo_ui.stackedWidget
        qtWidget = top.leo_ui.richTextEdit # A LeoQTextBrowser
        # g.trace('(qtBody)',qtWidget)
        sw.setCurrentIndex(1)
        self.widget = w = leoQTextEditWidget(
            qtWidget,name = 'body',c=c)
            # Sets w.widget = qtWidget.
        self.bodyCtrl = w # The widget as seen from Leo's core.

        # Hook up the QSyntaxHighlighter
        self.colorizer = leoQtColorizer(c,w.widget)
        qtWidget.setAcceptRichText(False)
        
        if 0: # xxx test: disable foreground color change for selected text.
            palette = qtWidget.palette()
            highlight_foreground_brush = palette.brush(palette.Active,palette.HighlightedText) # white.
            highlight_background_brush = palette.brush(palette.Active,palette.Highlight) # dark blue
            normal_brush = palette.brush(palette.Active,palette.Text)
            
            g.trace('foreground',highlight_foreground_brush.color().name())
            g.trace('background',highlight_background_brush.color().name())
            highlight_foreground_brush.setColor(QtGui.QColor('red'))
            g.trace('foreground',highlight_foreground_brush.color().name())
            palette.setBrush(palette.HighlightedText,highlight_foreground_brush)
            

    # Config stuff.
    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.setWrap(c.p)

    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1
    
    # For renderer panes.
    self.canvasRenderer = None
    self.canvasRendererLabel = None
    self.canvasRendererVisible = False
    self.textRenderer = None
    self.textRendererLabel = None
    self.textRendererVisible = False
    self.textRendererWrapper = None

    if trace: g.trace('(qtBody)',self.widget)
#@+node:ekr.20110605121601.18183: *8* setWrap (qtBody)
def setWrap (self,p):

    if not p: return
    if self.useScintilla: return

    c = self.c
    w = c.frame.body.widget.widget
    if 1:
        # Quicker, more self-contained.
        wrap = g.scanAllAtWrapDirectives(c,p)
    else:
        d = c.scanAllDirectives(p)
        if d is None: return
        wrap = d.get('wrap')
    w.setWordWrapMode(
        g.choose(wrap,
            QtGui.QTextOption.WordWrap,
            QtGui.QTextOption.NoWrap))
#@+node:ekr.20110605121601.18184: *8* createBindings (qtBody)
def createBindings (self,w=None):

    '''(qtBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
#@+node:ekr.20110605121601.18185: *8* get_name
def getName (self):

    return 'body-widget'
#@+node:ekr.20110605121601.18187: *6* setEditorColors (qtBody)
def setEditorColors (self,bg,fg):
    
    obj = self.bodyCtrl.widget # A QTextEditor or QTextBrowser.

    def check(color,kind,default):
        if not QtGui.QColor(color).isValid():
            if color in ( 'none','None',None):
                pass
            elif color not in self.badFocusColors:
                self.badFocusColors.append(color)
                g.es_print('invalid body %s color: %s' % (
                    kind,color),color='blue')
            color = default
        return color

    bg = check(bg,'background','white')
    fg = check(fg,'foreground','black')
    
    if hasattr(obj,'viewport'):
        obj = obj.viewport()

    sheet = 'background-color: %s; color: %s' % (bg,fg)
    g.app.gui.update_style_sheet(obj,'colors',sheet)
  
#@+node:ekr.20110605121601.18190: *6* oops (qtBody)
def oops (self):
    g.trace('qtBody',g.callers(3))
#@+node:ekr.20110605121601.18191: *6* High-level interface (qtBody)
# The required high-level interface.
def appendText (self,s):                return self.widget.appendText(s)
def clipboard_append(self,s):           return self.widget.clipboard_append(s)
def clipboard_clear(self):              return self.widget.clipboard_append()
def delete(self,i,j=None):              self.widget.delete(i,j)
def deleteTextSelection (self):         return self.widget.deleteTextSelection()
def flashCharacter(self,i,
    bg='white',fg='red',
    flashes=3,delay=75):                return self.widget(i,bg,fg,flashes,delay)
def get(self,i,j=None):                 return self.widget.get(i,j)
def getAllText (self):                  return self.widget.getAllText()
def getFocus (self):                    return self.widget.getFocus()
def getInsertPoint(self):               return self.widget.getInsertPoint()
def getSelectedText (self):             return self.widget.getSelectedText()
def getSelectionRange(self):            return self.widget.getSelectionRange()
def getYScrollPosition (self):          return self.widget.getYScrollPosition()
def hasSelection (self):                return self.widget.hasSelection()
def insert(self,i,s):                   return self.widget.insert(i,s)
def replace (self,i,j,s):               self.widget.replace (i,j,s)
def rowColToGuiIndex (self,s,row,col):  return self.widget.rowColToGuiIndex(s,row,col)
def see(self,index):                    return self.widget.see(index)
def seeInsertPoint(self):               return self.widget.seeInsertPoint()
def selectAllText (self,insert=None):   self.widget.selectAllText(insert)
def setAllText (self,s,new_p=None):     return self.widget.setAllText(s,new_p=new_p)
def setBackgroundColor (self,color):    return self.widget.setBackgroundColor(color)
def setFocus (self):                    return self.widget.setFocus()
def setForegroundColor (self,color):    return self.widget.setForegroundColor(color)
def setInsertPoint (self,pos):          return self.widget.setInsertPoint(pos)
def setSelectionRange (self,i,j,insert=None):
    self.widget.setSelectionRange(i,j,insert=insert)
def setYScrollPosition (self,i):        return self.widget.setYScrollPosition(i)
def tag_configure(self,colorName,**keys):pass
def toPythonIndex(self,index):          return self.widget.toPythonIndex(index)
def toPythonIndexRowCol(self,index):    return self.widget.toPythonIndexRowCol(index)

set_focus = setFocus
toGuiIndex = toPythonIndex
#@+node:ekr.20110605121601.18192: *6* hasFocus (qtBody)
def hasFocus(self):
    
    '''Return True if the body has focus.'''
    
    # Always returning True is good enough for leoMenu.updateEditMenu.
    return True
    
    # Doesn't work: the focus is already in the menu!
    # w = g.app.gui.get_focus()
    # g.trace(w,self.widget.widget)
    # return w == self.widget.widget
#@+node:ekr.20110605121601.18193: *6* Editors (qtBody)
#@+node:ekr.20110605121601.18194: *7* entries
#@+node:ekr.20110605121601.18195: *8* addEditor & helper (qtBody)
# An override of leoFrame.addEditor.

def addEditor (self,event=None):

    '''Add another editor to the body pane.'''

    trace = False and not g.unitTesting
    bodyCtrl = self.c.frame.body.bodyCtrl # A leoQTextEditWidget
    self.editorWidgets['1'] = bodyCtrl
    c = self.c ; p = c.p
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1

    if self.totalNumberOfEditors == 2:
        # Pack the original body editor.
        w = bodyCtrl.widget
        self.packLabel(w,n=1)

    name = '%d' % self.totalNumberOfEditors
    f,wrapper = self.createEditor(name)
    w = wrapper.widget
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w
    assert isinstance(f,QtGui.QFrame),f
    self.editorWidgets[name] = wrapper

    if trace: g.trace('name %s wrapper %s w %s' % (
        name,id(wrapper),id(w)))

    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        # The name of the last editor need not be '1'
        d = self.editorWidgets ; keys = list(d.keys())
        old_name = keys[0]
        old_wrapper = d.get(old_name)
        old_w = old_wrapper.widget
        self.injectIvars(f,old_name,p,old_wrapper)
        self.updateInjectedIvars (old_w,p)
        self.selectLabel(old_wrapper) # Immediately create the label in the old editor.

    # Switch editors.
    c.frame.body.bodyCtrl = wrapper
    self.selectLabel(wrapper)
    self.selectEditor(wrapper)
    self.updateEditors()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18196: *9* createEditor (qtBody)
def createEditor (self,name):

    c = self.c ; p = c.p
    f = c.frame.top.leo_ui.leo_body_inner_frame
        # Valid regardless of qtGui.useUI
    n = self.numberOfEditors

    # Step 1: create the editor.
    # w = QtGui.QTextBrowser(f)
    w = LeoQTextBrowser(f,c,self)
    w.setObjectName('richTextEdit') # Will be changed later.
    wrapper = leoQTextEditWidget(w,name='body',c=c)
    self.packLabel(w)

    # Step 2: inject ivars, set bindings, etc.
    self.injectIvars(f,name,p,wrapper)
    self.updateInjectedIvars(w,p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    self.createBindings(w=wrapper)
    c.k.completeAllBindingsForWidget(wrapper)
    self.recolorWidget(p,wrapper)

    return f,wrapper
#@+node:ekr.20110605121601.18197: *8* assignPositionToEditor
def assignPositionToEditor (self,p):

    '''Called *only* from tree.select to select the present body editor.'''

    c = self.c ; cc = c.chapterController
    wrapper = c.frame.body.bodyCtrl
    w = wrapper.widget

    self.updateInjectedIvars(w,p)
    self.selectLabel(wrapper)

    # g.trace('===',id(w),w.leo_chapter,w.leo_p.h)
#@+node:ekr.20110605121601.18198: *8* cycleEditorFocus (qtBody)
# Use the base class method.

# def cycleEditorFocus (self,event=None):

    # '''Cycle keyboard focus between the body text editors.'''

    # c = self.c ; d = self.editorWidgets
    # w = c.frame.body.bodyCtrl
    # values = list(d.values())
    # if len(values) > 1:
        # i = values.index(w) + 1
        # if i == len(values): i = 0
        # w2 = list(d.values())[i]
        # assert(w!=w2)
        # self.selectEditor(w2)
        # c.frame.body.bodyCtrl = w2
        
#@+node:ekr.20110605121601.18199: *8* deleteEditor (qtBody)
def deleteEditor (self,event=None):

    '''Delete the presently selected body text editor.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    wrapper = c.frame.body.bodyCtrl
    w = wrapper.widget
    name = w.leo_name
    assert name
    # This seems not to be a valid assertion.
    # assert wrapper == d.get(name),'wrong wrapper'
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if len(list(d.keys())) <= 1: return

    # At present, can not delete the first column.
    if name == '1':
        g.es('can not delete leftmost editor',color='blue')
        return

    # Actually delete the widget.
    if trace: g.trace('**delete name %s id(wrapper) %s id(w) %s' % (
        name,id(wrapper),id(w)))

    del d [name]
    f = c.frame.top.leo_ui.leo_body_inner_frame
    layout = f.layout()
    for z in (w,w.leo_label):
        if z: # 2011/11/12
            self.unpackWidget(layout,z)
    w.leo_label = None # 2011/11/12

    # Select another editor.
    new_wrapper = list(d.values())[0]
    if trace: g.trace(wrapper,new_wrapper)
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        if w.leo_label: # 2011/11/12
            self.unpackWidget(layout,w.leo_label)
            w.leo_label = None # 2011/11/12

    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18200: *8* findEditorForChapter (qtBody)
def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    values = list(d.values())

    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w,'leo_p') and w.leo_p and w.leo_p == p
            ):
                if trace: g.trace('***',id(w),'match chapter and p',p.h)
                return w

    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            if trace: g.trace('***',id(w),'match only chapter',p.h)
            return w

    # As a last resort, return the present editor widget.
    if trace: g.trace('***',id(self.bodyCtrl),'no match',p.h)
    return c.frame.body.bodyCtrl
#@+node:ekr.20110605121601.18201: *8* select/unselectLabel (qtBody)
def unselectLabel (self,wrapper):

    pass
    # self.createChapterIvar(wrapper)

def selectLabel (self,wrapper):

    c = self.c
    w = wrapper.widget
    lab = hasattr(w,'leo_label') and w.leo_label

    if lab:
        lab.setEnabled(True)
        lab.setText(c.p.h)
        lab.setEnabled(False)
#@+node:ekr.20110605121601.18202: *8* selectEditor & helpers
selectEditorLockout = False

def selectEditor(self,wrapper):

    '''Select editor w and node w.leo_p.'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; bodyCtrl = c.frame.body.bodyCtrl

    if not wrapper: return bodyCtrl
    if self.selectEditorLockout:
        if trace: g.trace('**busy')
        return

    w = wrapper.widget
    # g.trace('widget',w)
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    def report(s):
        g.trace('*** %9s wrapper %s w %s %s' % (
            s,id(wrapper),id(w),c.p.h))

    if wrapper and wrapper == bodyCtrl:
        self.deactivateEditors(wrapper)
        if hasattr(w,'leo_p') and w.leo_p and w.leo_p != c.p:
            if trace: report('select')
            c.selectPosition(w.leo_p)
            c.bodyWantsFocus()
        elif trace and verbose: report('no change')
        return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(wrapper)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.
#@+node:ekr.20110605121601.18203: *9* selectEditorHelper (qtBody)
def selectEditorHelper (self,wrapper):

    trace = False and not g.unitTesting
    c = self.c ; cc = c.chapterController
    d = self.editorWidgets
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    w = wrapper.widget
    assert isinstance(w,QtGui.QTextEdit),w

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget (w.leo_p,wrapper) # switches colorizers.
    # g.trace('c.frame.body',c.frame.body)
    # g.trace('c.frame.body.bodyCtrl',c.frame.body.bodyCtrl)
    # g.trace('wrapper',wrapper)
    c.frame.body.bodyCtrl = wrapper
    c.frame.body.widget = wrapper # Major bug fix: 2011/04/06
    w.leo_active = True

    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)

    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w,'leo_p') and w.leo_p):
        return g.trace('***** no w.leo_p',w)
        
    # if not (hasattr(w,'leo_chapter') and w.leo_chapter):
        # return g.trace('***** no w.leo_chapter',w)

    p = w.leo_p
    assert p,p

    if trace: g.trace('wrapper %s chapter %s old %s p %s' % (
        id(wrapper),w.leo_chapter,c.p.h,p.h))

    c.expandAllAncestors(p)
    c.selectPosition(p) # Calls assignPositionToEditor.
    c.redraw()
    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18204: *10* << restore the selection, insertion point and the scrollbar >> qtBody.selectEditorHelper
spot = hasattr(w,'leo_insertSpot') and w.leo_insertSpot or 0
wrapper.setInsertPoint(spot)

if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        wrapper.setSelectionRange(start,end)
    except Exception:
        pass

# Don't restore the scrollbar here.
#@+node:ekr.20110605121601.18205: *8* updateEditors (qtBody)
# Called from addEditor and assignPositionToEditor

def updateEditors (self):

    c = self.c ; p = c.p ; body = p.b
    d = self.editorWidgets
    if len(list(d.keys())) < 2: return # There is only the main widget

    w0 = c.frame.body.bodyCtrl
    i,j = w0.getSelectionRange()
    ins = w0.getInsertPoint()
    sb0 = w0.widget.verticalScrollBar()
    pos0 = sb0.sliderPosition()
    for key in d:
        wrapper = d.get(key)
        w = wrapper.widget
        v = hasattr(w,'leo_p') and w.leo_p.v
        if v and v == p.v and w != w0:
            sb = w.verticalScrollBar()
            pos = sb.sliderPosition()
            wrapper.setAllText(body)
            self.recolorWidget(p,wrapper)
            sb.setSliderPosition(pos)

    c.bodyWantsFocus()
    w0.setSelectionRange(i,j,insert=ins)
        # 2011/11/21: bug fix: was ins=ins
    sb0.setSliderPosition(pos0)
#@+node:ekr.20110605121601.18206: *7* utils
#@+node:ekr.20110605121601.18207: *8* computeLabel (qtBody)
def computeLabel (self,w):

    if hasattr(w,'leo_label') and w.leo_label: # 2011/11/12
        s = w.leo_label.text()
    else:
        s = ''

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter,s)

    return s
#@+node:ekr.20110605121601.18208: *8* createChapterIvar (qtBody)
def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        pass
    elif cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None
#@+node:ekr.20110605121601.18209: *8* deactivateEditors (qtBody)
def deactivateEditors(self,wrapper):

    '''Deactivate all editors except wrapper's editor.'''

    trace = False and not g.unitTesting
    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        wrapper2 = d.get(key)
        w2 = wrapper2.widget
        if hasattr(w2,'leo_active'):
            active = w2.leo_active
        else:
            active = True
        if wrapper2 != wrapper and active:
            w2.leo_active = False
            self.unselectLabel(wrapper2)
            w2.leo_scrollBarSpot = wrapper2.getYScrollPosition()
            w2.leo_insertSpot = wrapper2.getInsertPoint()
            w2.leo_selection = wrapper2.getSelectionRange()
            if trace: g.trace('**deactivate wrapper %s w %s' % (
                id(wrapper2),id(w2)))
            self.onFocusOut(w2)
#@+node:ekr.20110605121601.18210: *8* ensurePositionExists (qtBody)
def ensurePositionExists(self,w):

    '''Return True if w.leo_p exists or can be reconstituted.'''

    trace = False and not g.unitTesting
    c = self.c

    if c.positionExists(w.leo_p):
        return True
    else:
        if trace: g.trace('***** does not exist',w.leo_name)
        for p2 in c.all_unique_positions():
            if p2.v and p2.v == w.leo_p.v:
                if trace: g.trace(p2.h)
                w.leo_p = p2.copy()
                return True
        else:
            # This *can* happen when selecting a deleted node.
            w.leo_p = c.p.copy()
            return False
#@+node:ekr.20110605121601.18211: *8* injectIvars (qtBody)
def injectIvars (self,parentFrame,name,p,wrapper):

    trace = False and not g.unitTesting

    w = wrapper.widget
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if trace: g.trace(w)

    # Inject ivars
    if name == '1':
        w.leo_p = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()

    w.leo_active = True
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    # w.leo_colorizer = None # Set in leoQtColorizer ctor.
    w.leo_frame = parentFrame
    w.leo_insertSpot = None
    # w.leo_label = None # Injected by packLabel.
    w.leo_name = name
    # w.leo_on_focus_in = onFocusInCallback
    w.leo_scrollBarSpot = None
    w.leo_selection = None
    w.leo_wrapper = wrapper
#@+node:ekr.20110605121601.18212: *8* packLabel (qtBody)
def packLabel (self,w,n=None):

    trace = False and not g.unitTesting
    c = self.c
    f = c.frame.top.leo_ui.leo_body_inner_frame
        # Valid regardless of qtGui.useUI

    if n is None:n = self.numberOfEditors
    layout = f.layout()
    f.setObjectName('editorFrame')

    # Create the text: to do: use stylesheet to set font, height.
    lab = QtGui.QLineEdit(f)
    lab.setObjectName('editorLabel')
    lab.setText(c.p.h)

    # Pack the label and the text widget.
    # layout.setHorizontalSpacing(4)
    layout.addWidget(lab,0,max(0,n-1),QtCore.Qt.AlignVCenter)
    layout.addWidget(w,1,max(0,n-1))
    layout.setRowStretch(0,0)
    layout.setRowStretch(1,1) # Give row 1 as much as possible.

    w.leo_label = lab # Inject the ivar.
    if trace: g.trace('w.leo_label',w,lab)
#@+node:ekr.20110605121601.18213: *8* recolorWidget (qtBody)
def recolorWidget (self,p,wrapper):

    trace = False and not g.unitTesting
    c = self.c

    # Save.
    old_wrapper = c.frame.body.bodyCtrl
    c.frame.body.bodyCtrl = wrapper
    w = wrapper.widget

    if not hasattr(w,'leo_colorizer'):
        if trace: g.trace('*** creating colorizer for',w)
        leoQtColorizer(c,w) # injects w.leo_colorizer
        assert hasattr(w,'leo_colorizer'),w

    c.frame.body.colorizer = w.leo_colorizer
    if trace: g.trace(w,c.frame.body.colorizer)

    try:
        # c.recolor_now(interruptable=False) # Force a complete recoloring.
        c.frame.body.colorizer.colorize(p,incremental=False,interruptable=False)
    finally:
        # Restore.
        c.frame.body.bodyCtrl = old_wrapper
#@+node:ekr.20110605121601.18214: *8* switchToChapter (qtBody)
def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    trace = False and not g.unitTesting
    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            if trace: g.trace('***old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocus()
#@+node:ekr.20110605121601.18215: *8* updateInjectedIvars (qtBody)
def updateInjectedIvars (self,w,p):

    trace = False and not g.unitTesting
    if trace: g.trace('w %s len(p.b) %s %s' % (
        id(w),len(p.b),p.h),g.callers(5))

    c = self.c ; cc = c.chapterController
    assert isinstance(w,QtGui.QTextEdit),w

    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None

    w.leo_p = p.copy()
#@+node:ekr.20110605121601.18216: *8* unpackWidget (qtBody)
def unpackWidget (self,layout,w):

    trace = False and not g.unitTesting
    
    if trace: g.trace(w)

    index = layout.indexOf(w)
    item = layout.itemAt(index)
    item.setGeometry(QtCore.QRect(0,0,0,0))
    layout.removeItem(item)
    
    
#@+node:ekr.20110605121601.18217: *6* Renderer panes (qtBody)
#@+node:ekr.20110605121601.18218: *7* hideCanvasRenderer (qtBody)
def hideCanvasRenderer (self,event=None):

    '''Hide canvas pane.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    wrapper = c.frame.body.bodyCtrl
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name),'wrong wrapper'
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if len(list(d.keys())) <= 1: return

    # At present, can not delete the first column.
    if name == '1':
        g.es('can not delete leftmost editor',color='blue')
        return

    # Actually delete the widget.
    if trace: g.trace('**delete name %s id(wrapper) %s id(w) %s' % (
        name,id(wrapper),id(w)))

    del d [name]
    f = c.frame.top.leo_ui.leo_body_inner_frame
    layout = f.layout()
    for z in (w,w.leo_label):
        if z: # 2011/11/12
            self.unpackWidget(layout,z)
    w.leo_label = None # 2011/11/12

    # Select another editor.
    new_wrapper = list(d.values())[0]
    if trace: g.trace(wrapper,new_wrapper)
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        if w.leo_label: # 2011/11/12
            self.unpackWidget(layout,w.leo_label)
            w.leo_label = None # 2011/11/12

    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18219: *7* hideTextRenderer (qtBody)
def hideCanvas (self,event=None):

    '''Hide canvas pane.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    wrapper = c.frame.body.bodyCtrl
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name),'wrong wrapper'
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if len(list(d.keys())) <= 1: return

    # At present, can not delete the first column.
    if name == '1':
        g.es('can not delete leftmost editor',color='blue')
        return

    # Actually delete the widget.
    if trace: g.trace('**delete name %s id(wrapper) %s id(w) %s' % (
        name,id(wrapper),id(w)))

    del d [name]
    f = c.frame.top.leo_ui.leo_body_inner_frame
    layout = f.layout()
    for z in (w,w.leo_label):
        if z: # 2011/11/12
            self.unpackWidget(layout,z)
    w.leo_label = None  # 2011/11/12

    # Select another editor.
    new_wrapper = list(d.values())[0]
    if trace: g.trace(wrapper,new_wrapper)
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        if w.leo_label:  # 2011/11/12
            self.unpackWidget(layout,w.leo_label)
            w.leo_label = None # 2011/11/12

    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18220: *7* packRenderer (qtBody)
def packRenderer (self,f,name,w):

    c = self.c ; n = max(1,self.numberOfEditors)
    assert isinstance(f,QtGui.QFrame),f

    layout = f.layout()
    f.setObjectName('%s Frame' % name)

    # Create the text: to do: use stylesheet to set font, height.
    lab = QtGui.QLineEdit(f)
    lab.setObjectName('%s Label' % name)
    lab.setText(name)

    # Pack the label and the widget.
    layout.addWidget(lab,0,max(0,n-1),QtCore.Qt.AlignVCenter)
    layout.addWidget(w,1,max(0,n-1))
    layout.setRowStretch(0,0)
    layout.setRowStretch(1,1) # Give row 1 as much as possible.
    
    return lab

#@+node:ekr.20110605121601.18221: *7* showCanvasRenderer (qtBody)
# An override of leoFrame.addEditor.

def showCanvasRenderer (self,event=None):

    '''Show the canvas area in the body pane, creating it if necessary.'''

    trace = False and not g.unitTesting
    
    bodyCtrl = self.c.frame.body.bodyCtrl # A leoQTextEditWidget

    c = self.c
    f = c.frame.top.leo_ui.leo_body_inner_frame
    assert isinstance(f,QtGui.QFrame),f

    if not self.canvasRenderer:
        name = 'Graphics Renderer'
        self.canvasRenderer = w = QtGui.QGraphicsView(f)
        w.setObjectName(name)
    
    if not self.canvasRendererVisible:
        self.canvasRendererLabel = self.packRenderer(f,name,w)
        self.canvasRendererVisible = True
#@+node:ekr.20110605121601.18222: *7* showTextRenderer (qtBody)
# An override of leoFrame.addEditor.

def showTextRenderer (self,event=None):

    '''Show the canvas area in the body pane, creating it if necessary.'''

    c = self.c
    f = c.frame.top.leo_ui.leo_body_inner_frame
    assert isinstance(f,QtGui.QFrame),f

    if not self.textRenderer:
        name = 'Text Renderer'
        self.textRenderer = w = LeoQTextBrowser(f,c,self)
        w.setObjectName(name)
        self.textRendererWrapper = leoQTextEditWidget(
            w,name='text-renderer',c=c)
            
    if not self.textRendererVisible:
        self.textRendererLabel = self.packRenderer(f,name,w)
        self.textRendererVisible = True
#@+node:ekr.20110605121601.18223: *6* Event handlers (qtBody)
#@+node:ekr.20110930174206.15472: *7* onFocusIn (qtBody)
def onFocusIn (self,obj):

    '''Handle a focus-in event in the body pane.'''

    trace = False and not g.unitTesting

    c = self.c
    
    if trace: g.trace(str(obj.objectName()))

    # 2010/08/01: Update the history only on focus in events.
    # 2011/04/02: Update history only in leoframe.tree.select.
    # c.nodeHistory.update(c.p)
    
    if obj.objectName() == 'richTextEdit':
        wrapper = hasattr(obj,'leo_wrapper') and obj.leo_wrapper
        if wrapper and wrapper != self.bodyCtrl:
            self.selectEditor(wrapper)
        self.onFocusColorHelper('focus-in',obj)
        obj.setReadOnly(False)
        obj.setFocus() # Weird, but apparently necessary.
#@+node:ekr.20110930174206.15473: *7* onFocusOut (qtBody)
def onFocusOut (self,obj):

    '''Handle a focus-out event in the body pane.'''
    
    trace = False and not g.unitTesting

    if trace: g.trace(str(obj.objectName()))
    
    # Apparently benign.
    if obj.objectName() == 'richTextEdit':
        self.onFocusColorHelper('focus-out',obj)
        obj.setReadOnly(True)
    
#@+node:ekr.20110605121601.18224: *7* onFocusColorHelper (qtBody)
badFocusColors = []

def onFocusColorHelper(self,kind,obj):

    trace = False and not g.unitTesting
    
    c = self.c ; w = c.frame.body.bodyCtrl
    
    if trace: g.trace(kind)
    
    if kind == 'focus-in':
        # if trace: g.trace('%9s' % (kind),'calling c.k.showStateColors()')
        c.k.showStateColors(inOutline=False,w=self.widget)
    else:
        bg = self.unselectedBackgroundColor
        fg = self.unselectedForegroundColor
        c.frame.body.setEditorColors(bg,fg)

    w.widget.ensureCursorVisible()
        # 2011/10/02: Fix cursor-movement bug.
#@+node:ekr.20110605121601.18569: *5* class jeditColorizer
# This is c.frame.body.colorizer.highlighter.colorer

class jEditColorizer:

    '''This class contains jEdit pattern matchers adapted
    for use with QSyntaxHighlighter.'''

    << about the line-oriented jEdit colorizer >>

    @others
#@+node:ekr.20110605121601.18570: *6* << about the line-oriented jEdit colorizer >>
@nocolor-node
@

The aha behind the line-oriented jEdit colorizer is that we can define one or
more *restarter* methods for each pattern matcher that could possibly match
across line boundaries. I say "one or more" because we need a separate restarter
method for all combinations of arguments that can be passed to the jEdit pattern
matchers. In effect, these restarters are lambda bindings for the generic
restarter methods.

In actuality, very few restarters are needed. For example, for Python, we need
restarters for continued strings, and both flavors of continued triple-quoted
strings. For python, these turn out to be three separate lambda bindings for
restart_match_span.

When a jEdit pattern matcher partially succeeds, it creates the lambda binding
for its restarter and calls setRestart to set the ending state of the present
line to an integer representing the bound restarter. setRestart calls
computeState to create a *string* representing the lambda binding of the
restarter. setRestart then calls stateNameToStateNumber to convert that string
to an integer state number that then gets passed to Qt's setCurrentBlockState.
The string is useful for debugging; Qt only uses the corresponding number.
#@+node:ekr.20110605121601.18571: *6*  Birth & init
#@+node:ekr.20110605121601.18572: *7* __init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    self.defaultState = 'default-state:' # The name of the default state.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False
        # True: trace all matching methods.
        # This isn't so useful now that colorRangeWithTag shows g.callers(2).
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.language_name = None # The name of the language for the current mode.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
    
        # To be removed...
    
            # Used only by the old colorizer.
            # 'bracketRange',
            # "comment",
            # "cwebName"
            # "keyword",
            # "latexBackground","latexKeyword","latexModeKeyword",
            # "pp",
            # "string",
            
            # Wiki styling.  These were never user options.
            # "bold","bolditalic","elide","italic",
            
            # Marked as Leo jEdit tags, but not used.
            # '@color', '@nocolor','doc_part', 'section_ref',
        
        # 8 Leo-specific tags.
        "blank",  # show_invisibles_space_color
        "docpart",
        "leokeyword",
        "link",
        "name",
        "namebrackets",
        "tab", # show_invisibles_space_color
        "url",
        
        # jEdit tags.
        'comment1','comment2','comment3','comment4',
        # default, # exists, but never generated.
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
#@+node:ekr.20110605121601.18573: *8* defineLeoKeywordsDict
def defineLeoKeywordsDict(self):

    self.leoKeywordsDict = {}

    for key in g.globalDirectiveList:
        self.leoKeywordsDict [key] = 'leokeyword'
#@+node:ekr.20110605121601.18574: *8* defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
    
        # Used in Leo rules...
    
        # tag name      :( option name,                  default color),
        'blank'         :('show_invisibles_space_color', '#E5E5E5'), # gray90
        'docpart'       :('doc_part_color',              'red'),
        'leokeyword'    :('leo_keyword_color',           'blue'),
        'link'          :('section_name_color',          'red'),
        'name'          :('undefined_section_name_color','red'),
        'namebrackets'  :('section_name_brackets_color', 'blue'),
        'tab'           :('show_invisibles_tab_color',   '#CCCCCC'), # gray80
        'url'           :('url_color',                   'purple'),
        
        # Used by the old colorizer: to be removed.
        
        # 'bracketRange'   :('bracket_range_color',     'orange'), # Forth.
        # 'comment'        :('comment_color',           'red'),
        # 'cwebName'       :('cweb_section_name_color', 'red'),
        # 'keyword'        :('keyword_color',           'blue'),
        # 'latexBackground':('latex_background_color',  'white'),
        # 'pp'             :('directive_color',         'blue'),
        # 'string'         :('string_color',            '#00aa00'), # Used by IDLE.

        # jEdit tags.
        # tag name  :( option name,     default color),
        'comment1'  :('comment1_color', 'red'),
        'comment2'  :('comment2_color', 'red'),
        'comment3'  :('comment3_color', 'red'),
        'comment4'  :('comment4_color', 'red'),
        'function'  :('function_color', 'black'),
        'keyword1'  :('keyword1_color', 'blue'),
        'keyword2'  :('keyword2_color', 'blue'),
        'keyword3'  :('keyword3_color', 'blue'),
        'keyword4'  :('keyword4_color', 'blue'),
        'keyword5'  :('keyword5_color', 'blue'),
        'label'     :('label_color',    'black'),
        'literal1'  :('literal1_color', '#00aa00'),
        'literal2'  :('literal2_color', '#00aa00'),
        'literal3'  :('literal3_color', '#00aa00'),
        'literal4'  :('literal4_color', '#00aa00'),
        'markup'    :('markup_color',   'red'),
        'null'      :('null_color',     None), #'black'),
        'operator'  :('operator_color', None), #'black'),
    }
#@+node:ekr.20110605121601.18575: *8* defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
    
        # Used in Leo rules...
        
            # tag name      : option name
            'blank'         :'show_invisibles_space_font', # 2011/10/24.
            'docpart'       :'doc_part_font',
            'leokeyword'    :'leo_keyword_font',
            'link'          :'section_name_font',
            'name'          :'undefined_section_name_font',
            'namebrackets'  :'section_name_brackets_font',
            'tab'           : 'show_invisibles_tab_font', # 2011/10/24.
            'url'           : 'url_font',
        
        # Used by old colorizer.
        
            # 'bracketRange'   :'bracketRange_font', # Forth.
            # 'comment'       :'comment_font',
            # 'cwebName'      :'cweb_section_name_font',
            # 'keyword'       :'keyword_font',
            # 'latexBackground':'latex_background_font',
            # 'pp'            :'directive_font',
            # 'string'        :'string_font',
    
         # jEdit tags.
         
             # tag name     : option name
            'comment1'      :'comment1_font',
            'comment2'      :'comment2_font',
            'comment3'      :'comment3_font',
            'comment4'      :'comment4_font',
            #'default'       :'default_font',
            'function'      :'function_font',
            'keyword1'      :'keyword1_font',
            'keyword2'      :'keyword2_font',
            'keyword3'      :'keyword3_font',
            'keyword4'      :'keyword4_font',
            'keyword5'      :'keyword5_font',
            'label'         :'label_font',
            'literal1'      :'literal1_font',
            'literal2'      :'literal2_font',
            'literal3'      :'literal3_font',
            'literal4'      :'literal4_font',
            'markup'        :'markup_font',
            # 'nocolor' This tag is used, but never generates code.
            'null'          :'null_font',
            'operator'      :'operator_font',
    }
#@+node:ekr.20110605121601.18576: *7* addImportedRules
def addImportedRules (self,mode,rulesDict,rulesetName):

    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''

    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets [rulesetName] = True

    names = hasattr(mode,'importDict') and mode.importDict.get(rulesetName,[]) or []

    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key,[])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        # g.trace([z.__name__ for z in rules])
                        aList.extend(rules)
                        self.rulesDict [key] = aList
        # g.trace('***** added rules for %s from %s' % (name,rulesetName))
        self.initModeFromBunch(savedBunch)
#@+node:ekr.20110605121601.18577: *7* addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_language, True), # 2011/01/17
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True),
        ('f',  self.match_url_f,        True),
        ('h',  self.match_url_h,       True),
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.

        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
#@+node:ekr.20111024091133.16702: *7* configure_hard_tab_width
def configure_hard_tab_width (self):
    
    # The stated default is 40, but apparently it must be set explicitly.
    
    trace = False and not g.unitTesting
    c,w = self.c,self.w
 
    if 0:
        # No longer used: c.config.getInt('qt-tab-width')
        hard_tab_width = abs(10*c.tab_width)
        if trace: g.trace('hard_tab_width',hard_tab_width,self.w)
    else:
        # For some reason, the size is not accurate.
        font = w.widget.currentFont()
        info = QtGui.QFontInfo(font)
        size = info.pointSizeF()
        pixels_per_point = 1.0 # 0.9
        hard_tab_width = abs(int(pixels_per_point*size*c.tab_width))
        
        if trace: g.trace(
            'family',font.family(),'point size',size,
            'tab_width',c.tab_width,
            'hard_tab_width',hard_tab_width) # ,self.w)
    
    w.widget.setTabStopWidth(hard_tab_width)
#@+node:ekr.20110605121601.18578: *7* configure_tags
def configure_tags (self):

    trace = False and not g.unitTesting
    traceColors = False
    traceFonts = False
    c = self.c ; w = self.w
    isQt = g.app.gui.guiName().startswith('qt')

    if trace: g.trace(self.colorizer.language)

    if w and hasattr(w,'start_tag_configure'):
        w.start_tag_configure()

    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont

    # Configure fonts.
    if trace and traceFonts: g.trace('*'*10,'configuring fonts')
    keys = list(self.default_font_dict.keys()) ; keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language,option_name),(option_name)):
            if trace and traceFonts: g.trace(name)
            font = self.fonts.get(name)
            if font:
                if trace and traceFonts:
                    g.trace('**found',name,id(font))
                w.tag_configure(key,font=font)
                break
            else:
                family = c.config.get(name + '_family','family')
                size   = c.config.get(name + '_size',  'size')   
                slant  = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight','weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size   = size or c.config.defaultBodyFontSize
                    slant  = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family,size,slant,weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    if trace and traceFonts:
                        g.trace('**found',key,name,family,size,slant,weight,id(font))
                    w.tag_configure(key,font=font)
                    break

        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                if trace and traceFonts:
                    g.trace('default',key,font)
                self.fonts[key] = font # 2010/02/19: Essential
                w.tag_configure(key,font=defaultBodyfont)
            else:
                if trace and traceFonts:
                    g.trace('no fonts')
                    
        if isQt and key == 'url' and font:
            font.setUnderline(True) # 2011/03/04

    if trace and traceColors: g.trace('*'*10,'configuring colors')
    keys = list(self.default_colors_dict.keys()) ; keys.sort()
    for name in keys:
        # if name == 'operator': g.pdb()
        option_name,default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language,option_name)) or
            c.config.getColor(option_name) or
            default_color
        )
        if trace and traceColors: g.trace(option_name,color)

        # Must use foreground, not fg.
        try:
            w.tag_configure(name, foreground=color)
        except: # Recover after a user error.
            g.es_exception()
            w.tag_configure(name, foreground=default_color)

    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        w.tag_configure("link",underline=1) # defined
        w.tag_configure("name",underline=0) # undefined
    else:
        w.tag_configure("link",underline=0)
        if self.underline_undefined:
            w.tag_configure("name",underline=1)
        else:
            w.tag_configure("name",underline=0)

    self.configure_variable_tags()

    try:
        w.end_tag_configure()
    except AttributeError:
        pass
#@+node:ekr.20110605121601.18579: *7* configure_variable_tags
def configure_variable_tags (self):

    c = self.c ; w = self.w

    # g.trace()

    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80"),
        ("elide", None,                                   "yellow"),
    ):
        if self.showInvisibles:
            color = option_name and c.config.getColor(option_name) or default_color
        else:
            option_name,default_color = self.default_colors_dict.get(name,(None,None),)
            color = option_name and c.config.getColor(option_name) or ''
        try:
            w.tag_configure(name,background=color)
        except: # A user error.
            w.tag_configure(name,background=default_color)

    # Special case:
    if not self.showInvisibles:
        w.tag_configure("elide",elide="1")
#@+node:ekr.20110605121601.18580: *7* init (jeditColorizer)
def init (self,p,s):

    trace = False and not g.unitTesting

    if p: self.p = p.copy()
    self.all_s = s or ''

    if trace: g.trace('='*20,
        'tabwidth',self.c.tab_width,
        self.colorizer.language) #,g.callers(4))

    # State info.
    self.all_s = s
    self.global_i,self.global_j = 0,0
    self.global_offset = 0

    # These *must* be recomputed.
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.restartDict = {}
    self.init_mode(self.colorizer.language)
    self.clearState()
    self.showInvisibles = self.colorizer.showInvisibles
        # The show/hide-invisible commands changes this.

    # Used by matchers.
    self.prev = None
    if self.last_language != self.colorizer.language:
        # Must be done to support per-language @font/@color settings.
        self.configure_tags()
        self.last_language = self.colorizer.language
        
    self.configure_hard_tab_width() # 2011/10/04
#@+node:ekr.20110605121601.18581: *7* init_mode & helpers
def init_mode (self,name):

    '''Name may be a language name or a delegate name.'''

    trace = False and not g.unitTesting
    if not name: return False
    h = self.highlighter
    language,rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if bunch.language == 'unknown-language':
            if trace: g.trace('found unknown language')
            return False
        else:
            if trace: g.trace('found',language,rulesetName)
            self.initModeFromBunch(bunch)
            self.language_name = language # 2011/05/30
            return True
    else:
        if trace: g.trace(language,rulesetName)
        path = g.os_path_join(g.app.loadDir,'..','modes')
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        fileName = g.os_path_join(path,'%s.py' % (language))
        if g.os_path_exists(fileName):
            mode = g.importFromPath (language,path)
        else: mode = None

        if mode:
            # A hack to give modes/forth.py access to c.
            if hasattr(mode,'pre_init_mode'):
                mode.pre_init_mode(self.c)
        else:
            # Create a dummy bunch to limit recursion.
            self.modes [rulesetName] = self.modeBunch = g.Bunch(
                attributesDict  = {},
                defaultColor    = None,
                keywordsDict    = {},
                language        = 'unknown-language',
                mode            = mode,
                properties      = {},
                rulesDict       = {},
                rulesetName     = rulesetName,
                word_chars      = self.word_chars, # 2011/05/21
            )
            if trace: g.trace('***** No colorizer file: %s.py' % language)
            self.rulesetName = rulesetName
            self.language_name = 'unknown-language'
            return False
        self.colorizer.language = language
        self.rulesetName = rulesetName
        self.properties = hasattr(mode,'properties') and mode.properties or {}
        self.keywordsDict = hasattr(mode,'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName,{}) or {}
        self.setKeywords()
        self.attributesDict = hasattr(mode,'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
        # if trace: g.trace(rulesetName,self.attributesDict)
        self.setModeAttributes()
        self.rulesDict = hasattr(mode,'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
        # if trace: g.trace(self.rulesDict)
        self.addLeoRules(self.rulesDict)
        self.defaultColor = 'null'
        self.mode = mode
        self.modes [rulesetName] = self.modeBunch = g.Bunch(
            attributesDict  = self.attributesDict,
            defaultColor    = self.defaultColor,
            keywordsDict    = self.keywordsDict,
            language        = self.colorizer.language,
            mode            = self.mode,
            properties      = self.properties,
            rulesDict       = self.rulesDict,
            rulesetName     = self.rulesetName,
            word_chars      = self.word_chars, # 2011/05/21
        )
        # Do this after 'officially' initing the mode, to limit recursion.
        self.addImportedRules(mode,self.rulesDict,rulesetName)
        self.updateDelimsTables()
        initialDelegate = self.properties.get('initialModeDelegate')
        if initialDelegate:
            if trace: g.trace('initialDelegate',initialDelegate)
            # Replace the original mode by the delegate mode.
            self.init_mode(initialDelegate)
            language2,rulesetName2 = self.nameToRulesetName(initialDelegate)
            self.modes[rulesetName] = self.modes.get(rulesetName2)
            self.language_name = language2  # 2011/05/30
        else:
            self.language_name = language  # 2011/05/30
        return True
#@+node:ekr.20110605121601.18582: *8* nameToRulesetName
def nameToRulesetName (self,name):

    '''Compute language and rulesetName from name, which is either a language or a delegate name.'''

    if not name: return ''

    i = name.find('::')
    if i == -1:
        language = name
        rulesetName = '%s_main' % (language)
    else:
        language = name[:i]
        delegate = name[i+2:]
        rulesetName = self.munge('%s_%s' % (language,delegate))

    # if rulesetName == 'php_main': rulesetName = 'php_php'

    # g.trace(name,language,rulesetName)
    return language,rulesetName
#@+node:ekr.20110605121601.18583: *8* setKeywords
def setKeywords (self):

    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.'''

    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d [key] = 'leokeyword'

    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]

    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))

    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)

    # g.trace(self.colorizer.language,[str(z) for z in chars])

    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
#@+node:ekr.20110605121601.18584: *8* setModeAttributes
def setModeAttributes (self):

    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''

    d = self.attributesDict
    aList = (
        ('default',         'null'),
	    ('digit_re',        ''),
        ('escape',          ''), # New in Leo 4.4.2.
	    ('highlight_digits',True),
	    ('ignore_case',     True),
	    ('no_word_sep',     ''),
    )

    # g.trace(d)

    for key, default in aList:
        val = d.get(key,default)
        if val in ('true','True'): val = True
        if val in ('false','False'): val = False
        setattr(self,key,val)
        # g.trace(key,val)
#@+node:ekr.20110605121601.18585: *8* initModeFromBunch
def initModeFromBunch (self,bunch):

    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor   = bunch.defaultColor
    self.keywordsDict   = bunch.keywordsDict
    self.colorizer.language = bunch.language
    self.mode           = bunch.mode
    self.properties     = bunch.properties
    self.rulesDict      = bunch.rulesDict
    self.rulesetName    = bunch.rulesetName
    self.word_chars     = bunch.word_chars # 2011/05/21
#@+node:ekr.20110605121601.18586: *8* updateDelimsTables
def updateDelimsTables (self):

    '''Update g.app.language_delims_dict if no entry for the language exists.'''

    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')

    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment,startComment,endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment,endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None

    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.colorizer.language):
            d [self.colorizer.language] = delims
            # g.trace(self.colorizer.language,'delims:',repr(delims))
#@+node:ekr.20110605121601.18587: *7* munge
def munge(self,s):

    '''Munge a mode name so that it is a valid python id.'''

    valid = string.ascii_letters + string.digits + '_'

    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
#@+node:ekr.20110605121601.18588: *7* setFontFromConfig
def setFontFromConfig (self):

    c = self.c

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.color_tags_list = []
#@+node:ekr.20110605121601.18589: *6*  Pattern matchers
#@+node:ekr.20110605121601.18590: *7*  About the pattern matchers
@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise. In most cases, these methods colorize all
the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by
                        the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively
                        by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
#@+node:ekr.20110605121601.18591: *7* dump
def dump (self,s):

    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
#@+node:ekr.20110605121601.18592: *7* Leo rule functions
#@+node:ekr.20110605121601.18593: *8* match_at_color
def match_at_color (self,s,i):

    if self.trace_leo_matches: g.trace()

    seq = '@color'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        self.colorizer.flag = True # Enable coloring.
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,'leokeyword')
        self.clearState()
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18594: *8* match_at_language
def match_at_language (self,s,i):

    trace = (False or self.trace_leo_matches) and not g.unitTesting
    if trace: g.trace(i,repr(s))

    seq = '@language'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        j = i + len(seq)
        j = g.skip_ws(s,j)
        k = g.skip_c_id(s,j)
        name = s[j:k]
        ok = self.init_mode(name)
        if trace: g.trace(ok,name)
        if ok:
            self.colorRangeWithTag(s,i,k,'leokeyword')
        self.clearState()
        return k - i
    else:
        return 0
#@+node:ekr.20110605121601.18595: *8* match_at_nocolor & restarter
def match_at_nocolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i == 0 and not g.match(s,i,'@nocolor-') and g.match_word(s,i,'@nocolor'):
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20110605121601.18596: *9* restartNoColor
def restartNoColor (self,s):

    if self.trace_leo_matches: g.trace(repr(s))

    if g.match_word(s,0,'@color'):
        self.clearState()
    else:
        self.setRestart(self.restartNoColor)

    return len(s) # Always match everything.
#@+node:ekr.20110605121601.18597: *8* match_at_killcolor & restarter
def match_at_killcolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@killcolor'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartKillColor)
        return len(s) # Match everything.
    else:
        return 0

#@+node:ekr.20110605121601.18598: *9* restartKillColor
def restartKillColor(self,s):

    self.setRestart(self.restartKillColor)
    return len(s)+1
#@+node:ekr.20110605121601.18599: *8* match_at_nocolor_node & restarter
def match_at_nocolor_node (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@nocolor-node'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartNoColorNode)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20110605121601.18600: *9* restartNoColorNode
def restartNoColorNode(self,s):

    self.setRestart(self.restartNoColorNode)
    return len(s)+1
#@+node:ekr.20110605121601.18601: *8* match_blanks
def match_blanks (self,s,i):

    if not self.showInvisibles:
        return 0

    j = i ; n = len(s)

    while j < n and s[j] == ' ':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'blank')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18602: *8* match_doc_part & restarter
def match_doc_part (self,s,i):

    # New in Leo 4.5: only matches at start of line.
    if i != 0:
        return 0
    elif g.match_word(s,i,'@doc'):
        j = i + 4
    elif g.match(s,i,'@') and (i+1 >= len(s) or s[i+1] in (' ','\t','\n')):
        j = i + 1
    else:
        return 0

    self.colorRangeWithTag(s,i,j,'leokeyword')
    self.colorRangeWithTag(s,j,len(s),'docpart')
    self.setRestart(self.restartDocPart)

    return len(s)
#@+node:ekr.20110605121601.18603: *9* restartDocPart
def restartDocPart (self,s):

    for tag in ('@c','@code'):
        if g.match_word(s,0,tag):
            j = len(tag)
            self.colorRangeWithTag(s,0,j,'leokeyword') # 'docpart')
            self.clearState()
            return j
    else:
        self.setRestart(self.restartDocPart)
        self.colorRangeWithTag(s,0,len(s),'docpart')

        return len(s)
#@+node:ekr.20110605121601.18604: *8* match_leo_keywords
def match_leo_keywords(self,s,i):

    '''Succeed if s[i:] is a Leo keyword.'''

    # g.trace(i,g.get_line(s,i))

    self.totalLeoKeywordsCalls += 1

    if s[i] != '@':
        return 0

    # fail if something besides whitespace precedes the word on the line.
    i2 = i-1
    while i2 >= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ','\t'):
            i2 -= 1
        else:
            # g.trace('not a word 1',repr(ch))
            return 0

    # Get the word as quickly as possible.
    j = i+1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i+1:j] # entries in leoKeywordsDict do not start with '@'.

    if j < len(s) and s[j] not in (' ','\t','\n'):
        # g.trace('not a word 2',repr(word))
        return 0 # Fail, but allow a rescan, as in objective_c.

    if self.leoKeywordsDict.get(word):
        kind = 'leokeyword'
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j-i+1 # Bug fix: skip the last character.
        self.trace_match(kind,s,i,j)
        # g.trace('*** match',repr(s))
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s,i,j,kind)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            # g.trace('found',word)
            return j-i
        else:
            # g.trace('fail',repr(word),repr(self.word_chars))
            return -(j-i+1) # An important optimization.
#@+node:ekr.20110605121601.18605: *8* match_section_ref
def match_section_ref (self,s,i):

    if self.trace_leo_matches: g.trace()
    c = self.c ; p = c.currentPosition()
    w = self.w

    if not g.match(s,i,'<<'):
        return 0
    k = g.find_on_line(s,i+2,'>>')
    if k is not None:
        j = k + 2
        self.colorRangeWithTag(s,i,i+2,'namebrackets')
        ref = g.findReference(c,s[i:j],p)
        if ref:
            if self.use_hyperlinks:
                << set the hyperlink >>
            else:
                self.colorRangeWithTag(s,i+2,k,'link')
        else:
            self.colorRangeWithTag(s,i+2,k,'name')
        self.colorRangeWithTag(s,k,j,'namebrackets')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18606: *9* << set the hyperlink >>
# Set the bindings to vnode callbacks.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
ref.tagName = tagName
#@+node:ekr.20110605121601.18607: *8* match_tabs
def match_tabs (self,s,i):

    if not self.showInvisibles:
        return 0

    if self.trace_leo_matches: g.trace()

    j = i ; n = len(s)

    while j < n and s[j] == '\t':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'tab')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18608: *8* match_url_any/f/h  (new)
url_regex_f = re.compile(r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex   = re.compile(r"""(file|ftp|http|https)://[^\s'"]+[\w=/]""")

def match_any_url(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):

def match_url_f(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_f)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
    
def match_url_h(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_h)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
#@+node:ekr.20110605121601.18609: *7* match_compiled_regexp (new)
def match_compiled_regexp (self,s,i,kind,regexp,delegate=''):

    '''Succeed if the compiled regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    # if at_line_start and i != 0 and s[i-1] != '\n': return 0
    # if at_whitespace_end and i != g.skip_ws(s,0): return 0
    # if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_compiled_regexp_helper(s,i,regexp)
    if n > 0:
        j = i + n
        assert (j-i == n)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18610: *8* match_compiled_regexp_helper
def match_compiled_regexp_helper (self,s,i,regex):
    
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = regex.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    start, end = mo.start(), mo.end()
    if start != i:
        return 0
    # if trace:
        # g.trace('pattern',pattern)
        # g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
        # g.trace('groups',mo.groups())
    return end - start
#@+node:ekr.20110605121601.18611: *7* match_eol_span
def match_eol_span (self,s,i,
    kind=None,seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if seq matches s[i:]'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        return 0

    if g.match(s,i,seq):
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j # (was j-1) With a delegate, this could clear state.
    else:
        return 0
#@+node:ekr.20110605121601.18612: *7* match_eol_span_regexp
def match_eol_span_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if the regular expression regex matches s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,regexp)
    if n > 0:
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18613: *7* match_everything
# def match_everything (self,s,i,kind=None,delegate='',exclude_match=False):

    # '''Match the entire rest of the string.'''

    # j = len(s)
    # self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    # return j
#@+node:ekr.20110605121601.18614: *7* match_keywords
# This is a time-critical method.
def match_keywords (self,s,i):

    '''Succeed if s[i:] is a keyword.'''

    # trace = False
    self.totalKeywordsCalls += 1

    # Important.  Return -len(word) for failure greatly reduces
    # the number of times this method is called.

    # We must be at the start of a word.
    if i > 0 and s[i-1] in self.word_chars:
        # if trace: g.trace('not at word start',s[i-1])
        return 0

    # Get the word as quickly as possible.
    j = i ; n = len(s) ; chars = self.word_chars
    while j < n and s[j] in chars:
        j += 1

    word = s[i:j]
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j - i
        # if trace: g.trace('success',word,kind,j-i)
        self.trace_match(kind,s,i,j)
        return result
    else:
        # if trace: g.trace('fail',word,kind)
        return -len(word) # An important new optimization.
#@+node:ekr.20110605121601.18615: *7* match_line
def match_line (self,s,i,kind=None,delegate='',exclude_match=False):

    '''Match the rest of the line.'''

    j = g.skip_to_end_of_line(s,i)

    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    return j-i
#@+node:ekr.20110605121601.18616: *7* match_mark_following & getNextToken
def match_mark_following (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    trace = (True or self.verbose) and not g.unitTesting
    if not self.allow_mark_prev: return 0

    # if trace: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 < len(s) and s[i+len(pattern)] in self.word_chars:
        return 0 # 7/5/2008

    if g.match(s,i,pattern):
        j = i + len(pattern)
        # self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s,j)
        # 2011/05/31: Do not match *anything* unless there is a token following.
        if k > j:
            self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,k,kind,exclude_match=False)
            j = k
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            return j - i
        else:
            return 0
    else:
        return 0
#@+node:ekr.20110605121601.18617: *8* getNextToken
def getNextToken (self,s,i):

    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''
    
    # 2011/05/31: Might we extend the concept of token?
    # If s[i] is not a word char, should we return just it?

    while i < len(s) and s[i] in self.word_chars:
        i += 1

    # 2011/05/31: was i+1
    return min(len(s),i)
#@+node:ekr.20110605121601.18618: *7* match_mark_previous
def match_mark_previous (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''

    # This match was causing most of the syntax-color problems.
    return 0 # 2009/6/23
#@+node:ekr.20110605121601.18619: *7* match_regexp_helper
def match_regexp_helper (self,s,i,pattern):

    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    trace = False and not g.unitTesting
    if trace: g.trace('%-10s %-20s %s' % (
        self.colorizer.language,pattern,s)) # g.callers(1)

    try:
        flags = re.MULTILINE
        if self.ignore_case: flags|= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        # Do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = re_obj.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        if trace:
            g.trace('pattern',pattern)
            g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
            g.trace('groups',mo.groups())
        return end - start
#@+node:ekr.20110605121601.18620: *7* match_seq
def match_seq (self,s,i,
    kind='',seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if s[:] mathces seq.'''

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:  # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s,i,seq):
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
    else:
        j = i
    return j - i
#@+node:ekr.20110605121601.18621: *7* match_seq_regexp
def match_seq_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if the regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_regexp_helper(s,i,regexp)
    j = i + n
    assert (j-i == n)
    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    self.prev = (i,j,kind)
    self.trace_match(kind,s,i,j)
    return j - i
#@+node:ekr.20110605121601.18622: *7* match_span & helper & restarter
def match_span (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False,no_word_break=False):

    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''

    trace = False and not g.unitTesting
    if i >= len(s): return 0

    # g.trace(begin,end,no_escape,no_line_break,no_word_break)

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:
        j = i
    elif at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        j = i
    elif not g.match(s,i,begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s,i+len(begin),end,
            no_escape,no_line_break,no_word_break=no_word_break)
        # g.trace('** helper returns',j,len(s))
        if j == -1:
            j = i # A real failure.
        else:
            # A match
            i2 = i + len(begin) ; j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(s,i,i2,kind,delegate=None,    exclude_match=exclude_match)
                self.colorRangeWithTag(s,i2,j,kind,delegate=delegate,exclude_match=exclude_match)
                self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
            j = j2
            self.prev = (i,j,kind)

    self.trace_match(kind,s,i,j)

    if j > len(s):
        j = len(s) + 1
        def boundRestartMatchSpan(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Continuing',kind,i,j,len(s))
    elif j != i:
        if trace: g.trace('***Ending',kind,i,j,s[i:j])
        self.clearState()

    return j - i # Correct, whatever j is.
#@+node:ekr.20110605121601.18623: *8* match_span_helper
def match_span_helper (self,s,i,pattern,no_escape,no_line_break,no_word_break):

    '''Return n >= 0 if s[i] ends with a non-escaped 'end' string.'''

    esc = self.escape

    while 1:
        j = s.find(pattern,i)
        # g.trace(no_line_break,j,len(s))
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s)+1
        elif no_word_break and j > 0 and s[j-1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i:j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == esc:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # Continue searching past the escaped pattern string.
                i = j + len(pattern) # Bug fix: 7/25/07.
                # g.trace('escapes',escapes,repr(s[i:]))
            else:
                return j
        else:
            return j
#@+node:ekr.20110605121601.18624: *8* restart_match_span
def restart_match_span (self,s,
    delegate,end,exclude_match,kind,
    no_escape,no_line_break,no_word_break):

    '''Remain in this state until 'end' is seen.'''

    trace = False and not g.unitTesting

    i = 0
    j = self.match_span_helper(s,i,end,no_escape,no_line_break,no_word_break)
    if j == -1:
        j2 = len(s)+1
    elif j > len(s):
        j2 = j
    else:
        j2 = j + len(end)

    if delegate:
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
    else: # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
    j = j2

    self.trace_match(kind,s,i,j)

    if j > len(s):
        def boundRestartMatchSpan(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Re-continuing',i,j,len(s),s,g.callers(5))
    else:
        if trace: g.trace('***ending',i,j,len(s),s)
        self.clearState()

    return j # Return the new i, *not* the length of the match.
#@+node:ekr.20110605121601.18625: *7* match_span_regexp
def match_span_regexp (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False, no_word_break=False,
):

    '''Succeed if s[i:] starts with 'begin' (a regular expression) and contains a following 'end'.'''

    if self.verbose: g.trace('begin',repr(begin),'end',repr(end),self.dump(s[i:]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n > 0:
        j = i + n
        j2 = s.find(end,j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == self.escape:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s,i,j,kind, delegate=None,     exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,i2,kind, delegate=delegate,exclude_match=False)
            self.colorRangeWithTag(s,i2,j2,kind,delegate=None,    exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j2)
        return j2 - i
    else: return 0
#@+node:ekr.20110605121601.18626: *7* match_word_and_regexp
def match_word_and_regexp (self,s,i,
    kind1='',word='',
    kind2='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    if not self.allow_mark_prev: return 0

    if (False or self.verbose): g.trace(i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0
    if at_word_start and i + len(word) + 1 < len(s) and s[i+len(word)] in self.word_chars:
        j = i

    if not g.match(s,i,word):
        return 0

    j = i + len(word)
    n = self.match_regexp_helper(s,j,pattern)
    if n == 0:
        return 0
    self.colorRangeWithTag(s,i,j,kind1,exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s,j,k,kind2,exclude_match=False)    
    self.prev = (j,k,kind2)
    self.trace_match(kind1,s,i,j)
    self.trace_match(kind2,s,j,k)
    return k - i
#@+node:ekr.20110605121601.18627: *7* skip_line
def skip_line (self,s,i):

    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i < len(s):
            j = g.skip_line(s,i)
            if not g.match(s,j-n,escape):
                return j
            # g.trace('escape',s[i:j])
            i = j
        return i
    else:
        return g.skip_line(s,i)
            # Include the newline so we don't get a flash at the end of the line.
#@+node:ekr.20110605121601.18628: *7* trace_match
def trace_match(self,kind,s,i,j):

    if j != i and self.trace_match_flag:
        g.trace(kind,i,j,g.callers(2),self.dump(s[i:j]))
#@+node:ekr.20110605121601.18629: *6*  State methods
#@+node:ekr.20110605121601.18630: *7* clearState
def clearState (self):

    self.setState(-1)
#@+node:ekr.20110605121601.18631: *7* computeState
def computeState (self,f,keys):

    '''Compute the state name associated with f and all the keys.

    Return a unique int n representing that state.'''

    # Abbreviate arg names.
    d = {
        'delegate':'del:',
        'end':'end',
        'at_line_start':'line-start',
        'at_whitespace_end':'ws-end',
        'exclude_match':'exc-match',
        'no_escape':'no-esc',
        'no_line_break':'no-brk',
        'no_word_break':'no-word-brk',
    }
    result = [
        f.__name__,
        self.colorizer.language,
        self.rulesetName]
    for key in keys:
        keyVal = keys.get(key)
        val = d.get(key)
        if val is None:
            val = keys.get(key)
            result.append('%s=%s' % (key,val))
        elif keyVal is True:
            result.append('%s' % val)
        elif keyVal is False:
            pass
        elif keyVal not in (None,''):
            result.append('%s=%s' % (key,keyVal))
    state = ';'.join(result)

    n = self.stateNameToStateNumber(f,state)
    return n
#@+node:ekr.20110605121601.18632: *7* currentState and prevState
def currentState(self):

    return self.highlighter.currentBlockState()

def prevState(self):

    return self.highlighter.previousBlockState()
#@+node:ekr.20110605121601.18633: *7* setRestart
def setRestart (self,f,**keys):

    n = self.computeState(f,keys)
    self.setState(n)
#@+node:ekr.20110605121601.18634: *7* setState
def setState (self,n):

    trace = False and not g.unitTesting

    self.highlighter.setCurrentBlockState(n)

    if trace:
        stateName = self.showState(n)
        g.trace(stateName,g.callers(4))
#@+node:ekr.20110605121601.18635: *7* showState & showCurrentState
def showState (self,n):

    if n == -1: 
        return 'default-state'
    else:
        return self.stateDict.get(n,'<no state>')

def showCurrentState(self):

    n = self.currentState()
    return self.showState(n)

def showPrevState(self):

    n = self.prevState()
    return self.showState(n)
#@+node:ekr.20110605121601.18636: *7* stateNameToStateNumber
def stateNameToStateNumber (self,f,stateName):

    # stateDict:     Keys are state numbers, values state names.
    # stateNameDict: Keys are state names, values are state numbers.
    # restartDict:   Keys are state numbers, values are restart functions

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.stateNameDict[stateName] = n
        self.stateDict[n] = stateName
        self.restartDict[n] = f
        self.nextState += 1
        # g.trace('========',n,stateName)

    return n
#@+node:ekr.20110605121601.18637: *6* colorRangeWithTag
def colorRangeWithTag (self,s,i,j,tag,delegate='',exclude_match=False):

    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''

    trace = False and not g.unitTesting
        # A superb trace: enable this first to see what gets colored.

    # Pattern matcher may set the .flag ivar.
    if self.colorizer.killColorFlag or not self.colorizer.flag:
        if trace: g.trace('disabled')
        return

    if delegate:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (delegate,tag)),i,j,s2,g.callers(2)))
        # self.setTag(tag,s,i,j) # 2011/05/31: Do the initial color.
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 <= i < j and i < len(s):
            progress = i
            assert j >= 0,j
            for f in self.rulesDict.get(s[i],[]):
                n = f(self,s,i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n > 0:
                    # if trace: g.trace('delegate',delegate,i,n,f.__name__,repr(s[i:i+n]))
                    i += n ; break
            else:
                # New in Leo 4.6: Use the default chars for everything else.
                # New in Leo 4.8 devel: use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                # g.trace(default_tag)
                self.setTag(default_tag or tag,s,i,i+1)
                i += 1
            assert i > progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (self.language_name,tag)),i,j,s2,g.callers(2)))
        self.setTag(tag,s,i,j)
        
    if tag != 'url':
        # Allow URL's *everywhere*.
        j = min(j,len(s))
        while i < j:
            if s[i].lower() in 'fh': # file|ftp|http|https
                n = self.match_any_url(s,i)
                i += max(1,n)
            else:
                i += 1
#@+node:ekr.20110605121601.18638: *6* mainLoop & restart
def mainLoop(self,n,s):

    '''Colorize a *single* line s, starting in state n.'''

    trace = False and not g.unitTesting
    traceMatch = True
    traceState = True
    verbose = False
    
    if trace:
        if traceState:
            g.trace('%-30s' % ('** start: %s' % self.showState(n)),repr(s))
        else:
            g.trace(self.language_name,repr(s))
                # Called from recolor.

    i = 0
    if n > -1:
        i = self.restart(n,s,trace and traceMatch)
    if i == 0:
        self.setState(self.prevState())
        
    if False and trace:
        aList = self.rulesDict.get('<')
        for f in aList:
            g.trace(f.__name__)
        
        
    while i < len(s):
        progress = i
        functions = self.rulesDict.get(s[i],[])
        for f in functions:
            n = f(self,s,i)
            if n is None:
                g.trace('Can not happen: n is None',repr(f))
                break
            elif n > 0: # Success.
                if trace and traceMatch and f.__name__!='match_blanks':
                    g.trace('%-30s' % ('   match: %s' % (f.__name__,)),
                        repr(s[i:i+n]))
                # The match has already been colored.
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                if trace and traceMatch and verbose:
                    g.trace('fail: %-30s %s' % (
                        f.__name__,repr(s[i:i+n])))
                i += -n
                break # Stop searching the functions.
            else: # Fail. Try the next function.
                pass # Do not break or change i!
        else:
            i += 1
        assert i > progress

    # Don't even *think* about clearing state here.
    # We remain in the starting state unless a match happens.
    if trace and traceState:
        g.trace('%-30s' % ('** end:   %s' % self.showCurrentState()),repr(s))
#@+node:ekr.20110605121601.18639: *7* restart
def restart (self,n,s,traceMatch):

    f = self.restartDict.get(n)
    if f:
        i = f(s)
        fname = f.__name__
        if traceMatch:
            if i > 0:
                g.trace('** restart match',fname,s[:i])
            else:
                g.trace('** restart fail',fname,s)
    else:
        g.trace('**** no restart f')
        i = 0

    return i
#@+node:ekr.20110605121601.18640: *6* recolor
def recolor (self,s):

    '''Recolor a *single* line, s.'''

    trace = False and not g.unitTesting
    callers = False ; line = True ; state = True

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    if self.colorizer.changingText:
        return
    if not self.colorizer.flag:
        return

    # Get the previous state.
    n = self.prevState() # The state at the end of the previous line.
    if trace:
        if line and state:
            g.trace('%2s %s %s' % (n,self.showState(n),repr(s)))
        elif line:
            g.trace('%2s %s' % (n,repr(s)))
        if callers:
            # Called from colorize:rehightlight,highlightBlock
            g.trace(g.callers())

    if s.strip() or self.showInvisibles:
        self.mainLoop(n,s)
    else:
        self.setState(n) # Required
#@+node:ekr.20110605121601.18641: *6* setTag
def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting

    if i == j:
        if trace: g.trace('empty range')
        return

    w = self.w # A leoQTextEditWidget
    tag = tag.lower() # 2011/10/28
    colorName = w.configDict.get(tag)

    # Munge the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return

    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName,g.callers())

    underline = w.configUnderlineDict.get(tag)

    format = QtGui.QTextCharFormat()

    font = self.fonts.get(tag)
    if font:
        format.setFont(font)

    if trace:
        self.tagCount += 1
        g.trace(
            '%3s %3s %3s %9s %7s' % (i,j,len(s),font and id(font) or '<no font>',colorName),
            '%-10s %-25s' % (tag,s[i:j]),g.callers(2))

    if tag in ('blank','tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setFontUnderline(True)
    else:
        format.setForeground(color)

    self.highlighter.setFormat (i,j-i,format)

#@+node:ekr.20110605121601.18224: *5* onFocusColorHelper (qtBody)
badFocusColors = []

def onFocusColorHelper(self,kind,obj):

    trace = False and not g.unitTesting
    
    c = self.c ; w = c.frame.body.bodyCtrl
    
    if trace: g.trace(kind)
    
    if kind == 'focus-in':
        # if trace: g.trace('%9s' % (kind),'calling c.k.showStateColors()')
        c.k.showStateColors(inOutline=False,w=self.widget)
    else:
        bg = self.unselectedBackgroundColor
        fg = self.unselectedForegroundColor
        c.frame.body.setEditorColors(bg,fg)

    w.widget.ensureCursorVisible()
        # 2011/10/02: Fix cursor-movement bug.
#@+node:ekr.20110605121601.18126: *5* setEditorColors (leoQtHeadlineWidget) (no longer called)
def setEditorColors(self,bg,fg):
    
    obj = self.widget # A QLineEdit
    
    # g.trace('(leoQtHeadlineWidget)',bg,fg,g.callers())

    def check(color,kind,default):
        if not QtGui.QColor(color).isValid():
            if color not in self.badFocusColors:
                self.badFocusColors.append(color)
                g.es_print('invalid head %s color: %s' % (
                    kind,color),color='blue')
            color = default
        return color

    bg = check(bg,'background','white')
    fg = check(fg,'foreground','black')
    
    if hasattr(obj,'viewport'):
        obj = obj.viewport()
    
    obj.setStyleSheet('background-color:%s; color: %s' % (bg,fg))
#@+node:ekr.20110605121601.18187: *5* setEditorColors (qtBody)
def setEditorColors (self,bg,fg):
    
    obj = self.bodyCtrl.widget # A QTextEditor or QTextBrowser.

    def check(color,kind,default):
        if not QtGui.QColor(color).isValid():
            if color in ( 'none','None',None):
                pass
            elif color not in self.badFocusColors:
                self.badFocusColors.append(color)
                g.es_print('invalid body %s color: %s' % (
                    kind,color),color='blue')
            color = default
        return color

    bg = check(bg,'background','white')
    fg = check(fg,'foreground','black')
    
    if hasattr(obj,'viewport'):
        obj = obj.viewport()

    sheet = 'background-color: %s; color: %s' % (bg,fg)
    g.app.gui.update_style_sheet(obj,'colors',sheet)
  
#@+node:ekr.20111022215436.16684: *4* Added border around selected pane
@nocolor-node

Done: Made this optional, and configurable.
#@+node:ekr.20031218072017.2811: *5*  c.Birth & death
#@+node:ekr.20031218072017.2812: *6* c.__init__
def __init__(self,frame,fileName,relativeFileName=None):

    trace = False
    c = self ; tag = 'Commands.__init__'

    self.requestBringToFront = False
    self.requestedFocusWidget = None
    self.requestRedrawFlag = False
    self.requestedIconify = '' # 'iconify','deiconify'
    self.requestRecolorFlag = False

    if trace:
        print(tag)
        import time ; t1 = time.clock()
    self.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.

    # Init ivars with self.x instead of c.x to keep pylint happy

    # Debugging.
    self.command_count = 0
    self.scanAtPathDirectivesCount = 0
    self.trace_focus_count = 0

    # Data.
    self.chapterController = None
    self.db = {} # 2011/07/30: May be changed to a PickleShare instance later.
    self.frame = frame
    self.hiddenRootNode = leoNodes.vnode(context=c)
    self.hiddenRootNode.setHeadString('<hidden root vnode>')
    self.idle_callback = None # For c.idle_focus_helper.
    self.ignored_at_file_nodes = [] # List of nodes for error dialog.
    self.import_error_nodes = []
    self.in_qt_dialog = False # True when in a qt dialog.
    self.isZipped = False # May be set to True by g.openWithFileName.
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName
    
    # These ivars are set later by leoEditCommaands.createEditCommanders
    self.abbrevCommands  = None
    self.bufferCommands  = None
    self.editCommands    = None
    self.chapterCommands = None
    self.controlCommands = None
    self.debugCommands   = None
    self.editFileCommands = None
    self.helpCommands = None
    self.keyHandlerCommands = None
    self.killBufferCommands = None
    self.leoCommands = None
    self.macroCommands = None
    self.queryReplaceCommands = None
    self.rectangleCommands = None
    self.registerCommands = None
    self.searchCommands = None
    self.spellCommands = None

    self.initIvars()
    self.nodeHistory = nodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.

    # Break circular import dependencies by importing here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoCache as leoCache
    import leo.core.leoEditCommands as leoEditCommands
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoUndo as leoUndo

    if trace: t2 = g.printDiffTime('%s: after imports' % (tag),t1)

    self.shadowController = leoShadow.shadowController(c)
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.rstCommands    = leoRst.rstCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    
    if g.new_imports:
        self.editCommandsManager = leoEditCommands.EditCommandsManager(c)
        self.editCommandsManager.createEditCommanders()
    else:
        leoEditCommands.createEditCommanders(c)

    self.rstCommands = leoRst.rstCommands(c)

    c.cacher = leoCache.cacher(c)
    c.cacher.initFileDB(self.mFileName)

    if trace: t3 = g.printDiffTime('%s: after controllers created' % (tag),t2)

    self.undoer = leoUndo.undoer(self)
        
#@+node:ekr.20031218072017.2814: *6* c.__repr__ & __str__
def __repr__ (self):

    return "Commander %d: %s" % (id(self),repr(self.mFileName))

__str__ = __repr__
#@+node:ekr.20050920093543: *6* c.finishCreate & helper
def finishCreate (self,initEditCommanders=True):  # New in 4.4.

    '''Finish creating the commander after frame.finishCreate.

    Important: this is the last step in the startup process.'''

    c = self ; p = c.p
    c.miniBufferWidget = c.frame.miniBufferWidget
    # print('Commands.finishCreate',c.fileName())

    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = g.app.gui.createKeyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if initEditCommanders:
        # A 'real' .leo file.
        
        if g.new_imports:
            c.commandsDict = c.editCommandsManager.finishCreateEditCommanders()
        else:
            import leo.core.leoEditCommands as leoEditCommands
            c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)

        self.rstCommands.finishCreate()

        # copy global commands to this controller    

        for name,f in g.app.global_commands_dict.items():
            k.registerCommand(name,shortcut = None, func = f, pane='all',verbose=False)        

        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}
        
    if g.app.gui.guiName().lower().startswith('qt'):
        g.registerHandler('idle',c.idle_focus_helper)
        
    c.frame.menu.finishCreate()

    c.frame.log.finishCreate()
    c.bodyWantsFocus()
#@+node:ekr.20051007143620: *7* printCommandsDict
def printCommandsDict (self):

    c = self

    print('Commands...')
    for key in sorted(c.commandsDict):
        command = c.commandsDict.get(key)
        print('%30s = %s' % (
            key,g.choose(command,command.__name__,'<None>')))
    print('')
#@+node:ekr.20041130173135: *6* c.hash
def hash (self):

    c = self
    if c.mFileName:
        return c.os_path_finalize(c.mFileName).lower()
    else:
        return 0
#@+node:ekr.20110509064011.14563: *6* c.idle_focus_helper
idle_focus_count = 0

def idle_focus_helper (self,tag,keys):
    
    '''An idle-tme handler that ensures that focus is *somewhere*.'''
    
    trace = False and not g.unitTesting
    verbose = False # False: only print surprises.
    active = False # True: actually change the focus.
    
    c = self
    assert tag == 'idle'

    if g.app.unitTesting or keys.get('c') != c:
        return
        
    self.idle_focus_count += 1
        
    if c.in_qt_dialog:
        if trace and verbose: g.trace('in_qt_dialog')
        return
        
    if c.idle_callback:
        if trace: g.trace('calling c.idle_callback',c.idle_callback.__name__)
        c.idle_callback()
        c.idle_callback = None
        return

    w = g.app.gui.get_focus()

    if w:
        if trace and verbose:
            g.trace(self.idle_focus_count,w)
    elif g.app.gui.active: # Set by gui.onActivate/onDeactivate.
        if trace:
            g.trace('%s no focus -> body' % (self.idle_focus_count))
        if active:
            c.bodyWantsFocusNow()
#@+node:ekr.20081005065934.1: *6* c.initAfterLoad
def initAfterLoad (self):

    '''Provide an offical hook for late inits of the commander.'''

    pass
#@+node:ekr.20090213065933.6: *6* c.initConfigSettings
def initConfigSettings (self):

    '''Init all cached commander config settings.'''

    c = self
    c.autoindent_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    c.collapse_nodes_after_move = c.config.getBool('collapse_nodes_after_move')
        # Patch by nh2: 0004-Add-bool-collapse_nodes_after_move-option.patch
    c.collapse_on_lt_arrow  = c.config.getBool('collapse_on_lt_arrow',default=True)
        # 2011/11/09: An excellent, subliminal, improvement.
    c.contractVisitedNodes  = c.config.getBool('contractVisitedNodes')
    c.fixed                 = c.config.getBool('fixedWindow',default=False)
    c.fixedWindowPosition   = c.config.getData('fixedWindowPosition')
    c.focus_border_color    = c.config.getColor('focus_border_color') or 'red'
    c.focus_border_width    = c.config.getInt('focus_border_width') or 1 # pixels
    c.outlineHasInitialFocus= c.config.getBool('outline_pane_has_initial_focus')
    c.showMinibuffer        = c.config.getBool('useMinibuffer')
        # This option is a bad idea.
    c.putBitsFlag           = c.config.getBool('put_expansion_bits_in_leo_files',default=True)
    # g.trace('putBitsFlag',c.putBitsFlag,c.fileName())
    c.sparse_move           = c.config.getBool('sparse_move_outline_left')
    c.sparse_find           = c.config.getBool('collapse_nodes_during_finds')
    c.sparce_spell          = c.config.getBool('collapse_nodes_while_spelling')
    c.stayInTreeAfterSelect = c.config.getBool('stayInTreeAfterSelect')
    c.stayInTreeAfterEdit   = c.config.getBool('stayInTreeAfterEditHeadline')
    c.smart_tab             = c.config.getBool('smart_tab')
        # Note: there is also a smart_auto_indent setting.
    c.tab_width             = c.config.getInt('tab_width') or -4
    c.use_body_focus_border = c.config.getBool('use_body_focus_border',default=True)
    c.use_focus_border      = c.config.getBool('use_focus_border',default=True)
    c.write_script_file     = c.config.getBool('write_script_file')

    # g.trace('smart %s, tab_width %s' % (c.smart_tab, c.tab_width))
    # g.trace(c.sparse_move)
#@+node:ekr.20040731071037: *6* c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>

    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@+node:ekr.20031218072017.2813: *7* << initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
# self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.doubleClickFlag = False
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui
self.ipythonController = None # Set only by the ipython plugin.

# Interlock to prevent setting c.changed when switching chapters.
c.suppressHeadChanged = False

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.changed = False # True if any data has been changed since the last save.
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.hookFunction = None
self.ignoreChangedPaths = False # True: disable path changed message in at.WriteAllHelper.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.nodeConflictList = [] # List of nodes with conflicting read-time data.
self.nodeConflictFileName = None # The fileName for c.nodeConflictList.
self.openDirectory = None
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.
self.timeStampDict = {} # New in Leo 4.6.

# For tangle/untangle
self.tangle_errors = 0

# Global options: set later in initConfigSettings
self.fixed = False
self.page_width = 132
self.sparse_find = True # 2010/02/02: created ivar.
self.sparse_move = True # 2010/02/02: created ivar.
self.sparse_spell = True # 2010/02/02: created ivar.
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
self.use_focus_border = False
self.focus_border_color = 'white'
self.focus_border_width = 1 # pixels

# Default Tangle options
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = g.u('') # Must always be a string.
self.navTime = None
#@+node:ekr.20090213065933.7: *6* c.setWindowPosition
def setWindowPosition (self):

    c = self

    # g.trace(c.fixed,c.fixedWindowPosition)

    if c.fixedWindowPosition:
        try:
            w,h,l,t = self.fixedWindowPosition
            c.fixedWindowPosition = int(w),int(h),int(l),int(t)
        except Exception:
            g.es_print('bad @data fixedWindowPosition',
                repr(self.fixedWindowPosition),color='red')
    else:
        c.windowPosition = 500,700,50,50 # width,height,left,top.
#@+node:ekr.20111022215436.16685: *5* Borders (qtGui)
def add_border(self,c,w):
    
    name = g.app.gui.widget_name(w)
    
    if name == 'richTextEdit' and not c.use_body_focus_border:
        return

    if c.use_focus_border:
        if hasattr(w,'viewport'):
            w = w.viewport()

        sheet = "border: %spx solid %s" % (
            c.focus_border_width,c.focus_border_color)
        self.update_style_sheet(w,'border',sheet)

def remove_border(self,c,w):

    if c.use_focus_border:
        if hasattr(w,'viewport'):
            w = w.viewport()
        sheet = "border: %spx solid white" % (
            c.focus_border_width)
        self.update_style_sheet(w,'border',sheet)
#@+node:ekr.20110605121601.18540: *5* eventFilter
def eventFilter(self, obj, event):

    trace = (False or self.trace_masterKeyHandler) and not g.unitTesting
    verbose = True
    traceEvent = False # True: call self.traceEvent.
    traceKey = (True or self.trace_masterKeyHandler)
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    gui = g.app.gui
    aList = []

    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]

    # Hack: QLineEdit generates ev.KeyRelease only on Windows,Ubuntu
    lineEditKeyKinds = [ev.KeyPress,ev.KeyRelease]

    # Important:
    # QLineEdit: ignore all key events except keyRelease events.
    # QTextEdit: ignore all key events except keyPress events.
    if eventType in lineEditKeyKinds:
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        self.keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        self.keyIsActive = False

    if eventType == ev.WindowActivate:
        gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType == ev.WindowDeactivate:
        gui.onDeactivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])
        # g.trace('instate',k.inState(),'tkKey',tkKey,'ignore',ignore,'len(aList)',len(aList))
        if ignore:
            override = False
        # This is extremely bad.
        # At present, it is needed to handle tab properly.
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        else:
            override = len(aList) > 0
    else:
        override = False ; tkKey = '<no key>'
        if self.tag == 'body':
            if eventType == ev.FocusIn:
                g.app.gui.add_border(c,obj)
                c.frame.body.onFocusIn(obj)
            elif eventType == ev.FocusOut:
                g.app.gui.remove_border(c,obj)
                c.frame.body.onFocusOut(obj)
        if self.tag in ('tree','log'):
            if eventType == ev.FocusIn:
                g.app.gui.add_border(c,obj)
            elif eventType == ev.FocusOut:
                g.app.gui.remove_border(c,obj)

    if self.keyIsActive:
        shortcut = self.toStroke(tkKey,ch) #### ch is unused.

        if override:
            # Essentially *all* keys get passed to masterKeyHandler.
            if trace and traceKey:
                g.trace('ignore',ignore,'bound',repr(shortcut),repr(aList))
            w = self.w # Pass the wrapper class, not the wrapped widget.
            event = self.create_key_event(event,c,w,ch,tkKey,shortcut)
            ret = k.masterKeyHandler(event)
            c.outerUpdate()
        else:
            if trace and traceKey and verbose:
                g.trace(self.tag,'unbound',tkKey,shortcut)
        
        if trace and traceEvent:
            # Trace key events.
            self.traceEvent(obj,event,tkKey,override)

    elif trace and traceEvent:
        # Trace non-key events.
        self.traceEvent(obj,event,tkKey,override)

    return override
#@+node:ekr.20111024175001.16476: *4* Applied patch for bug 800399: Leo should have smart word jumps/deletes
@nocolor-node

Some editors, such as Eclipse, vim, this Webkit form I type in, and even Word,
allow to jump over, select and delete words, especially those containing or
surrounded by special characters, in a smarter way than just "going to the
beginning of the word before" (back-word) or "going to the end of the next word"
(forward-word).

E.g. in a line containing "i = ass" (note: multiple spaces) with the cursor at
the end, Ctrl-BackSpace would delete everything up to the "=", leaving "i =",
and if the cursor was right behind the "i", Ctrl-Right would position the cursor
right before the "=", instead of before the "ass", as Leo does now.

They also make deleting easy. Given a python method:

def fun():
    line1
    line2

Eclipse's and Webkit's Ctrl-BackSpace, beginning with the cursor behind "line2",
used multiple times, yield (turn by turn):

def fun():
    line1
    [4 spaces left of here]

def fun():
    line1
[emtpy line]

def fun():
    line1

def fun():
    [4 spaces left of here]

def fun():
[empty line]

def fun():

def fun

def [1 space left of here]

[empty line]

while Leo's backward-delete-word yields:

def fun():
    line1
   [3 spaces left of here ?!]

def fun():
   [3 spaces left of here ?!]

def

[empty line]

So to say, Leo's word-based commands jump, select and delete more than is useful
for possibly many users coming from other editors, leaving them only with
character-based commands.

I have attached two patches that add "-smart" equivalents of the jump, select
and delete commands.

Users wanting to use these commands can set in their myLeoSettings.leo:

  back-word-smart = Ctrl-LtArrow
  back-word-smart-extend-selection = Ctrl-Shift-LtArrow

  forward-word-smart = Ctrl-RtArrow
  forward-word-smart-extend-selection = Ctrl-Shift-RtArrow

  delete-word-smart = Ctrl-Delete
  backward-delete-word-smart = Ctrl-BackSpace

which overrides the default bindings.
#@+node:ekr.20111026101713.16510: *4* Support single-line nodes like <node/> xml import code
@nocolor-node

The single-line nodes should end in a newline. Otherwise the created node will
add a newline, and the checkers will complain.
#@+node:ekr.20071214072145.1: *5* class xmlScanner & htmlScanner(xmlScanner)
<< class xmlScanner (baseScannerClass) >>

<< class htmlScanner (xmlScanner) >>
#@+node:ekr.20111104032034.9866: *6* << class xmlScanner (baseScannerClass) >>
class xmlScanner (baseScannerClass):

    @others
#@+node:ekr.20071214072451: *7*  ctor_(xmlScanner)
def __init__ (self,importCommands,atAuto,tags_setting='import_xml_tags'):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='xml')
        # sets self.c

    # Set the parser delims.
    self.blockCommentDelim1 = '<!--'
    self.blockCommentDelim2 = '-->'
    self.blockDelim1 = None 
    self.blockDelim2 = None
    self.classTags = [] # Inited by import_xml_tags setting.
    self.extraIdChars = None
    self.functionTags = []
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = False
    self.sigHeadExtraTokens = []
    self.sigFailTokens = []

    # Overrides more attributes.
    self.atAutoWarnsAboutLeadingWhitespace = False
    self.caseInsensitive = True
    self.hasClasses = True
    self.hasDecls = False
    self.hasFunctions = False
    self.hasNestedClasses = True
    self.ignoreBlankLines = False # The tokenizer handles this.
    self.ignoreLeadingWs = True # A drastic step, but there seems to be no other way.
    self.strict = False
    self.tags_setting = tags_setting
    self.trace = False

    self.addTags()
#@+node:ekr.20071214131818: *7* addTags
def addTags (self):

    '''Add items to self.class/functionTags and from settings.'''

    trace = False # and not g.unitTesting
    c = self.c

    for ivar,setting in (
        ('classTags',self.tags_setting),
    ):
        aList = getattr(self,ivar)
        aList2 = c.config.getData(setting) or []
        aList2 = [z.lower() for z in aList2]
        aList.extend(aList2)
        setattr(self,ivar,aList)
        if trace: g.trace(ivar,aList)
#@+node:ekr.20111104032034.9868: *7* adjust_class_ref (xmlScanner)
def adjust_class_ref(self,s):

    '''Ensure that @others appears at the start of a line.'''
    

    trace = False and not g.unitTesting
    if trace: g.trace('old',repr(s))

    i = s.find('@others')
    if i > -1:
        j = i
        i -= 1
        while i >= 0 and s[i] in '\t ':
            i -= 1
        if i < j:
            # 2011/11/04: Never put lws before @others.
            s = s[:i+1] + s[j:]
        if i > 0 and s[i] != '\n':
            s = s[:i+1] + '\n' + s [i+1:]
    
    if trace: g.trace('new',repr(s))
    return s
#@+node:ekr.20111108111156.9922: *7* adjustTestLines (xmlScanner)
def adjustTestLines(self,lines):
    
    # This is a desparation measure to attempt reasonable comparisons.
    
    # self.ignoreBlankLines:
    lines = [z for z in lines if z.strip()]
        
    # if self.ignoreLeadingWs:
    lines = [z.lstrip() for z in lines]
    
    lines = [z.replace('@others','') for z in lines]
    
    # lines = [z.replace('>\n','>').replace('\n<','<') for z in lines]
    
    return lines
#@+node:ekr.20111108111156.9935: *7* filterTokens (xmlScanner)
def filterTokens (self,tokens):
    
    '''Filter tokens as needed for correct comparisons.
    
    For xml, this means:
        
    1. Removing newlines after opening elements.
    2. Removing newlines before closing elements.
    3. Converting sequences of whitespace to a single blank.
    '''
    
    trace = False
    
    if trace: g.trace(tokens)
    
    if 1: # Permissive code.

        return [(kind,val,line_number) for (kind,val,line_number) in tokens
            if kind not in ('nl','ws')]

    else: # Accurate code.

        # Pass 1. Insert newlines before and after elements.
        i,n,result = 0,len(tokens),[]
        while i < n:
            progress = i
            # Compute lookahead tokens.
            kind1,val1,n1 = tokens[i]
            kind2,val2,n2 = None,None,None
            kind3,val3,n3 = None,None,None
            kind4,val4,n4 = None,None,None
            if i + 1 < n: kind2,val2,n2 = tokens[i+1]
            if i + 2 < n: kind3,val3,n3 = tokens[i+2]
            if i + 3 < n: kind4,val4,n4 = tokens[i+3]
            
            # Always insert the present token.
            result.append((kind1,val1,n1),)
            i += 1
    
            if (
                kind1 == 'other' and val1 == '>' and
                kind2 != 'nl'
            ):
                # insert nl after >
                if trace: g.trace('** insert nl after >')
                result.append(('nl','\n',n1),)
            elif (
                kind1 != 'nl'    and
                kind2 == 'other' and val2 == '<' and
                kind3 == 'other' and val3 == '/' and
                kind4 == 'id'
            ):
                # Insert nl before </id
                if trace: g.trace('** insert nl before </%s' % (val4))
                result.append(('nl','\n',n1),)
            else:
                pass
    
            assert progress == i-1
            
        # Pass 2: collapse newlines and whitespace separately.
        tokens = result
        i,n,result = 0,len(tokens),[]
        while i < n:
            progress = i
            kind1,val1,n1 = tokens[i]
            if kind1 == 'nl':
                while i < n and tokens[i][0] == 'nl':
                    i += 1
                result.append(('nl','\n',n1),)
            elif kind1 == 'ws':
                while i < n and tokens[i][0] == 'ws':
                    i += 1
                result.append(('ws',' ',n1),)
            else:
                result.append((kind1,val1,n1),)
                i += 1
    
            assert progress < i

        return result
#@+node:ekr.20111103073536.16601: *7* isSpace (xmlScanner) (Use the base class now)
# def isSpace(self,s,i):
    
    # '''Return true if s[i] is a tokenizer space.'''

    # # Unlike the base-class method, xml space tokens include newlines.
    # return i < len(s) and s[i].isspace()
#@+node:ekr.20111103073536.16590: *7* skip...Token (xmlScanner overrides)
def skipCommentToken(self,s,i):
    
    '''Return comment lines with all leading/trailing whitespace removed.'''
    j = self.skipComment(s,i)
    lines = g.splitLines(s[i:j])
    lines = [z.strip() for z in lines]
    return j,'\n'.join(lines)
    
# skipIdToken: no change.

# skipNewlineToken: no change.

    # def skipNewlineToken(self,s,i):
        
        # assert g.match(s,i,'\n')
        # if i > 0 and s[i-1] == '>':
            # # Ignore newlines after an element.
            # return i+1,''
        # elif i+1 < len(s) and s[i+1] == '<':
            # # ignore newlines before an element.
            # return i+1,''
        # else:
            # return i+1,'\n'
    
# skipOtherToken: no change.
    
# skipStringToken: no change.

# skipWsToken: no change.

    # def skipWsToken(self,s,i):
        # '''Return a single blank for all runs of whitespace, *including* newlines.'''
        # j = i
        # while i < len(s) and s[i].isspace():
            # i += 1
        # return i,' '
        
#@+node:ekr.20091230062012.6238: *7* skipId (override base class) & helper
@  For characters valid in names see:
   www.w3.org/TR/2008/REC-xml-20081126/#NT-Name
@c

def skipId (self,s,i):

    # Fix bug 497332: @data import_xml_tags does not allow dashes in tag.
    chars = '.-:' # Allow : anywhere.
    n = len(s)
    while i < n and (self.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i
#@+node:ekr.20091230062012.6239: *8* isWordChar
@ From www.w3.org/TR/2008/REC-xml-20081126/#NT-Name

NameStartChar    ::= ":" | [A-Z] | "_" | [a-z] |
    [#xC0-#xD6]     | [#xD8-#xF6]     | [#xF8-#x2FF]    |
    [#x370-#x37D]   | [#x37F-#x1FFF]  | [#x200C-#x200D] |
    [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

NameChar    ::= NameStartChar | "-" | "." | [0-9] | #xB7 |
    [#x0300-#x036F] | [#x203F-#x2040]
@c

def isWordChar(self,ch):

    # At present, same as g.isWordChar.
    # This is not correct.
    return ch and (ch.isalnum() or ch == '_')
#@+node:ekr.20071214072924.4: *7* startsHelper & helpers (xmlScanner)
def startsHelper(self,s,i,kind,tags,tag=None):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = (False and kind == 'class') # and not g.unitTesting
    verbose = True
    self.codeEnd = self.sigEnd = self.sigId = None

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    if not g.match(s,i,'<'): return False
    self.sigStart = i
    i += 1
    sigIdStart = j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i].lower()
        # Set sigId ivar 'early' for error messages.
        # Bug fix: html case does not matter.
    if not theId: return False

    if theId not in tags:
        if trace and verbose:
            g.trace('**** %s theId: %s not in tags: %s' % (
                kind,theId,tags))
        return False

    if trace and verbose: g.trace(theId)
    classId = '' 
    sigId = theId

    # Complete the opening tag.
    i, ok, complete = self.skipToEndOfTag(s,i,start=sigIdStart)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # Bug fix: 2011/11/05.
    # For xml/html, make sure the signature includes any trailing whitespace.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        # sigEnd = g.skip_line(s,sigEnd)
        sigEnd = g.skip_ws(s,sigEnd)

    if not complete:
        i,ok = self.skipToMatchingTag(s,i,theId,tags,start=sigIdStart)
        if not ok:
            if trace and verbose: g.trace('no matching tag:',theId)
            return False

    # Success: set the ivars.
    # Not used in xml/html.
    # self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId
            
    # Scan to the start of the next tag.
    done = False
    while not done and i < len(s):
        progress = i
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif s[i] == '<':
            start = i
            i += 1
            if i < len(s) and s[i] == '/':
                i += 1
            j = g.skip_ws_and_nl(s,i)
            if self.startsId(s,j):
                i = self.skipId(s,j)
                word = s[j:i].lower()
                if word in tags:
                    self.codeEnd = start
                    done = True
                    break
            else:
                i = j
        else:
            i += 1
        
        assert done or progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    if trace: g.trace(repr(s[self.sigStart:self.codeEnd]))
    return True
#@+node:ekr.20071214072924.3: *8* skipToEndOfTag (xmlScanner)
def skipToEndOfTag(self,s,i,start):

    '''Skip to the end of an open tag.
    
    return i,ok,complete
    
    where complete is True if the tag of the form <name/>
    '''

    trace = False
    complete,ok = False,False
    while i < len(s): 
        progress = i
        if i == '"':
            i = self.skipString(s,i)
        elif g.match(s,i,'<!--'):
            i = self.skipComment(s,i)
        elif g.match(s,i,'<'):
            complete,ok = False,False ; break
        elif g.match(s,i,'/>'):
            i = g.skip_ws(s,i+2)
            complete,ok = True,True ; break
        elif g.match(s,i,'>'):
            i += 1
            complete,ok = False,True ; break
        else:
            i += 1
        assert progress < i

    if trace: g.trace('ok',ok,repr(s[start:i]))
    return i,ok,complete
#@+node:ekr.20071214075117: *8* skipToMatchingTag (xmlScanner)
def skipToMatchingTag (self,s,i,tag,tags,start):
    
    '''Skip the entire class definition. Return i,ok.
    '''

    trace = False
    found,level,target_tag = False,1,tag.lower()
    while i < len(s): 
        progress = i
        if s[i] == '"':
            i = self.skipString(s,i)
        elif g.match(s,i,'<!--'):
            i = self.skipComment(s,i)
        elif g.match(s,i,'</'):
            j = i+2
            i = self.skipId(s,j)
            tag2 = s[j:i].lower()
            i,ok,complete = self.skipToEndOfTag(s,i,start=j)
                # Sets complete if /> terminates the tag.
            if ok and tag2 == target_tag:
                level -= 1
                if level == 0:
                    found = True ; break
        elif g.match(s,i,'<'):
            # An open tag.
            j = g.skip_ws_and_nl(s,i+1)
            i = self.skipId(s,j)
            word = s[j:i].lower()
            i,ok,complete = self.skipToEndOfTag(s,i,start=j)
            # **Important**: only bump level for nested *target* tags.
            # This avoids problems when interior tags are not properly nested.
            if ok and word == target_tag and not complete:
                level += 1
        elif g.match(s,i,'/>'):
            # This is a syntax error.
            # This should have been eaten by skipToEndOfTag.
            i += 2
            g.trace('syntax error: unmatched "/>"')
        else:
            i += 1

        assert progress < i
        
    if trace: g.trace('%sfound:%s\n%s\n\n*****end %s\n' % (
        g.choose(found,'','not '),target_tag,s[start:i],target_tag))

    return i,found
#@+node:ekr.20111103073536.16595: *7* startsId (xmlScanner)
def startsId(self,s,i):
    
    if i < len(s):
        ch = s[i]
        # Recent bug fix: 2011/11/04:
        return self.isWordChar(ch) or ch in '.-:'
    else:
        return False

    # return g.is_c_id(s[i:i+1])
#@+node:ekr.20111104032034.9867: *6* << class htmlScanner (xmlScanner) >>
class htmlScanner (xmlScanner):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        xmlScanner.__init__(self,importCommands,atAuto,tags_setting='import_html_tags')
        
    @others
#@+node:ekr.20111019104425.15862: *4* Leo's home page now shows the latest postings from leo-editor.
@nocolor-node

Leo's home page now shows the latest postings on the leo-editor group.
#@+node:ekr.20111031083623.13746: *4* Support run-marked-unit-tests-locally/externally
@nocolor-node

The new command names and default bindings are::
    
    run-all-unit-tests-externally       = None
    run-all-unit-tests-locally          = None
    run-marked-unit-tests-externally    = None
    run-marked-unit-tests-locally       = None
    run-selected-unit-tests-externally  = None
    run-selected-unit-tests-locally     = Alt-4
#@+node:ekr.20060328121145: *5* runUnitTest commands
def runAllUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.
    Tests are run in the outline's process, so tests *can* change the outline.'''
    c = self.c
    leoTest.doTests(c,all=True)
    
def runMarkedUnitTestsLocally (self,event=None):
    '''Run marked unit tests in the outline.
    Tests are run in the outline's process, so tests *can* change the outline.'''
    c = self.c
    leoTest.doTests(c,all=True,marked=True)

def runSelectedUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.
    Tests are run in the outline's process, so tests *can* change the outline.'''
    c = self.c
    leoTest.doTests(c,all=False,marked=False)
    
# Externally run tests...

def runAllUnitTestsExternally (self,event=None):
    '''Run all unit tests contained in the entire outline.
    Tests are run in an external process, so tests *cannot* change the outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=True,marked=False)
    
def runMarkedUnitTestsExternally(self,event=None):
    '''Run all marked unit tests in the outline.
    Tests are run in an external process, so tests *cannot* change the outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=True,marked=True)

def runSelectedUnitTestsExternally(self,event=None):
    '''Run all unit tests contained in the presently selected outline
    Tests are run in an external process, so tests *cannot* change the outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=False,marked=False)
#@+node:ekr.20051104075904.4: *5* doTests & helpers
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20051104075904.5: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20051104075904.6: *7* __init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20051104075904.7: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20051104075904.9: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20051104075904.8: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20051104075904.10: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20051104075904.11: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20051104075904.12: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\nmakeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('\nmakeTestSuite: exception creating test cases for %s' % p.h)
        g.es_print_exception()
        return None
#@+node:ekr.20051104075904.13: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20070627140344: *5* class runTestExternallyHelperClass
class runTestExternallyHelperClass:

    '''A helper class to run tests externally.'''

    @others
#@+node:ekr.20070627140344.1: *6*  ctor: runTestExternallyHelperClass
def __init__(self,c,all,marked):

    self.c = c
    self.all = all
    self.marked = marked

    self.copyRoot = None # The root of copied tree.
    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
#@+node:ekr.20070627135336.10: *6* createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_finalize_join(g.app.loadDir,'..','test', self.fileName)

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path,silent=True)
    c2.close()
#@+node:ekr.20070627135336.9: *6* createOutline & helpers
def createOutline (self,c2):

    '''Create a unit test ouline containing

    - all children of any @mark-for-unit-tests node anywhere in the outline.
    - all @test and @suite nodes in p's outline.'''

    trace = False ; verbose = False
    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>

    if trace: g.trace('all',self.all)
    self.copyRoot.expand()
    for n,p,limit,lookForMark,lookForNodes in (
        (1,p1,limit1,lookForMark1,lookForNodes1),
        (2,p2,limit2,lookForMark2,lookForNodes2),
    ):
        if n == 2 and self.all: return
        if trace and verbose: g.trace(
            'pass %s: mark %s nodes %s root %s limit %s' % (
                n,lookForMark,lookForNodes,
                p and p.h or '<none>',
                limit and limit.h or '<none>'))
                
        aList = findAllUnitTestNodes(c,p,limit,self.all,self.marked,lookForMark,lookForNodes)
        for p2 in aList:
            self.addNode(p2)
        
#@+node:ekr.20070705065154: *7* << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.p
    if p.h.startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True
#@+node:ekr.20070705080413: *7* addMarkTree
def addMarkTree (self,p):

    # Add the entire @mark-for-unit-tests tree.
    self.addNode(p)
#@+node:ekr.20070705065154.1: *7* addNode
def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-tests tree as the last child of self.copyRoot.
    '''

    p2 = p.copyTreeAfter()
    p2.moveToLastChildOf(self.copyRoot)

    for p2 in p.self_and_subtree():
        self.seen.append(p2.v)
#@+node:ekr.20070705075604.3: *7* isUnitTestNode
def isUnitTestNode (self,p):
    
    h = p.h.lower()
    
    # Hidden tests nodes are an anti-pattern.

        # hidden = not h.startswith('<<') and test_pat.search(p.b)
        # if hidden:
            # print('Adding hidden test: %s' % (p.h))
            # return True

    for tag in self.tags:
        if h.startswith(tag):
            return True
    else:
        return False
#@+node:ekr.20070627140344.2: *6* runTests (runTestExternallyHelperClass)
def runTests (self):
    # 2010/09/09: removed the gui arg: there is no way to set it.

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo
    in a separate process.
    '''

    trace = False
    import time
    c = self.c ; p = c.p
    t1 = time.time()
    found = self.searchOutline(p.copy())
    if found:
        theGui = leoGui.nullGui("nullGui")
        old_silent_mode = g.app.silentMode
        g.app.silentMode = True
        c2 = c.new(gui=theGui)
        g.app.silentMode = old_silent_mode
        self.createOutline(c2)
        self.createFileFromOutline(c2)
        t2 = time.time()
        if trace:
            kind = g.choose(self.all,'all','selected')
            print('created %s unit tests in %0.2fsec in %s' % (
                kind,t2-t1,self.fileName))
            g.es('created %s unit tests' % (kind),color='blue')
        # 2010/09/09: allow a way to specify the gui.
        gui = g.app.unitTestGui or 'nullGui'
        runUnitTestLeoFile(gui=gui,
            path='dynamicUnitTest.leo',silent=True)
        c.selectPosition(p.copy())
    else:
        g.es_print('no %s@test or @suite nodes in %s outline' % (
            g.choose(self.marked,'marked',''),
            g.choose(self.all,'entire','selected')))
#@+node:ekr.20070627135336.8: *6* searchOutline
def searchOutline (self,p):

    c = self.c ; p = c.p
    iter = g.choose(self.all,c.all_unique_positions,p.self_and_subtree)

    # First, look down the tree.
    for p in iter():
        for s in self.tags:
            if p.h.startswith(s):
                self.root = c.p
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.p.parents():
            for s in self.tags:
                if p.h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    # Finally, look for all @mark-for-unit-test nodes.
    for p in c.all_unique_positions():
        if p.h.startswith('@mark-for-unit-test'):
            return True

    return False
#@+node:ekr.20111102052204.10012: *4* Support hidden unit tests externally
@nocolor-node

Changed runTestExternallyHelperClass.isUnitTestNode
#@+node:ekr.20111102065242.10014: *4* Disabled messages on external unit tests
@nocolor-node

1. Removing the signon message:

    This was nasty to find. They were created by the call to
    c.new (the non-testc!) in runTests.

    The trace in g.es was the key to discovering what was happening.
    
2. Moved the print statements from leoGlobals.py to writeWaitingLog.

    This allows g.app.silentMode to have effect.
    
3. fc.save now takes a 'silent' argument, set only by createFileFromOutline.

#@+node:ekr.20070627135336.10: *5* createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_finalize_join(g.app.loadDir,'..','test', self.fileName)

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path,silent=True)
    c2.close()
#@+node:ekr.20070627140344.2: *5* runTests (runTestExternallyHelperClass)
def runTests (self):
    # 2010/09/09: removed the gui arg: there is no way to set it.

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo
    in a separate process.
    '''

    trace = False
    import time
    c = self.c ; p = c.p
    t1 = time.time()
    found = self.searchOutline(p.copy())
    if found:
        theGui = leoGui.nullGui("nullGui")
        old_silent_mode = g.app.silentMode
        g.app.silentMode = True
        c2 = c.new(gui=theGui)
        g.app.silentMode = old_silent_mode
        self.createOutline(c2)
        self.createFileFromOutline(c2)
        t2 = time.time()
        if trace:
            kind = g.choose(self.all,'all','selected')
            print('created %s unit tests in %0.2fsec in %s' % (
                kind,t2-t1,self.fileName))
            g.es('created %s unit tests' % (kind),color='blue')
        # 2010/09/09: allow a way to specify the gui.
        gui = g.app.unitTestGui or 'nullGui'
        runUnitTestLeoFile(gui=gui,
            path='dynamicUnitTest.leo',silent=True)
        c.selectPosition(p.copy())
    else:
        g.es_print('no %s@test or @suite nodes in %s outline' % (
            g.choose(self.marked,'marked',''),
            g.choose(self.all,'entire','selected')))
#@+node:ekr.20031218072017.2619: *5* app.writeWaitingLog
def writeWaitingLog (self,c):

    trace = False
    app = self
    
    if trace:
        # Do not call g.es, g.es_print, g.pr or g.trace here!
        print('** writeWaitingLog','silent',app.silentMode,c.shortFileName())
        # print('writeWaitingLog',g.callers())
        # import sys ; print('writeWaitingLog: argv',sys.argv)

    if not c or not c.exists:
        return

    if g.unitTesting:
        app.printWaiting = []
        app.logWaiting = []
        g.app.setLog(None) # Prepare to requeue for other commanders.
        return

    table = [
        ('Leo Log Window','red'),
        (app.signon,'black'),
        (app.signon2,'black'),
    ]
    table.reverse()

    c.setLog() # 2010/10/20
    app.logInited = True # Prevent recursive call.
    
    if not app.signon_printed:
        app.signon_printed = True
        if not app.silentMode: # 2011/11/02:
            print('')
            print('** isPython3: %s' % g.isPython3)
            if not g.enableDB:
                print('** caching disabled')
            print(app.signon)
            print(app.signon2)
    if not app.silentMode: # 2011/11/02:
        for s in app.printWaiting:
            print(s)
    app.printWaiting = []

    if not app.silentMode:  # 2011/11/02:
        for s,color in table:
            app.logWaiting.insert(0,(s+'\n',color),)
        for s,color in app.logWaiting:
            g.es('',s,color=color,newline=0)
                # The caller must write the newlines.
    app.logWaiting = []

    # Essential when opening multiple files...
    
    g.app.setLog(None) 
#@+node:ekr.20111102093435.10018: *4* Unit tests now always have the sources available
#@+node:ekr.20031218072017.3138: *5* g.executeScript
def executeScript (name):

    """Execute a script whose short python file name is given.

    This is called only from the scripts_menu plugin."""

    mod_name,ext = g.os_path_splitext(name)
    theFile = None
    try:
        # This code is in effect an import or a reload.
        # This allows the user to modify scripts without leaving Leo.
        import imp
        theFile,filename,description = imp.find_module(mod_name)
        imp.load_module(mod_name,theFile,filename,description)
    except Exception:
        g.es("exception executing",name,color="red")
        g.es_exception()

    if theFile:
        theFile.close()
#@+node:ekr.20031218072017.2140: *5* c.executeScript & helpers
def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False,
    namespace=None):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        oldLog = g.app.log # 2011/01/19
        log = c.frame.log
        g.app.log = log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.p
                if p: c.setCurrentDirectoryFromContext(p)
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                d['script_args'] = args or []
                if namespace: d.update(namespace)
                # if args: sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                if c.write_script_file:
                    scriptFile = self.writeScriptFile(script)
                    
                    # 2011/10/31: make g.inScript a synonym for g.app.inScript.
                    g.inScript = g.app.inScript = True
                    try:
                        if g.isPython3:
                            exec(compile(script,scriptFile,'exec'),d)
                        else:
                            execfile(scriptFile,d)
                    finally:
                        g.inScript = g.app.inScript = False
                else:
                    g.app.inScript = True
                    try:
                        exec(script,d)
                    finally:
                        g.app.inScript = False
                if 0: # This message switches panes, and can be disruptive.
                    if not script1 and not silent:
                        # Careful: the script may have changed the log tab.
                        tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                        g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        g.app.log = oldLog # 2011/01/19
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143: *6* redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@+node:ekr.20110522121957.18230: *6* setCurrentDirectoryFromContext
def setCurrentDirectoryFromContext(self,p):
    
    trace = False and not g.unitTesting
    c = self
    
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    
    curDir = g.os_path_abspath(os.getcwd())

    # g.trace(p.h,'\npath  ',path,'\ncurDir',curDir)
    
    if path and path != curDir:
        if trace: g.trace('calling os.chdir(%s)' % (path))
        try:
            os.chdir(path)
        except Exception:
            pass
#@+node:EKR.20040627100424: *6* unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@+node:ekr.20070115135502: *5* c.writeScriptFile
def writeScriptFile (self,script):

    trace = False and not g.unitTesting
    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.homeLeoDir,'scriptFile.py')

    if trace: g.trace(path)                

    # Write the file.
    try:
        if g.isPython3:
            # Use the default encoding.
            f = open(path,encoding='utf-8',mode='w')
        else:
            f = open(path,'w')
        s = script
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,reportErrors=True)
        f.write(s)
        f.close()
    except Exception:
        g.es_exception()
        g.es("Failed to write script to %s" % path)
        # g.es("Check your configuration of script_file_path, currently %s" %
            # c.config.getString('script_file_path'))
        path = None

    return path
#@+node:ekr.20051104075904.4: *5* doTests & helpers
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20051104075904.5: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20051104075904.6: *7* __init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20051104075904.7: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20051104075904.9: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20051104075904.8: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20051104075904.10: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20051104075904.11: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20051104075904.12: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\nmakeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('\nmakeTestSuite: exception creating test cases for %s' % p.h)
        g.es_print_exception()
        return None
#@+node:ekr.20051104075904.13: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20051104075904.10: *5* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20051104075904.12: *5* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\nmakeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('\nmakeTestSuite: exception creating test cases for %s' % p.h)
        g.es_print_exception()
        return None
#@+node:ekr.20111102093435.10017: *4* Support marking an entire tree
#@+node:ekr.20070627135336.9: *5* createOutline & helpers
def createOutline (self,c2):

    '''Create a unit test ouline containing

    - all children of any @mark-for-unit-tests node anywhere in the outline.
    - all @test and @suite nodes in p's outline.'''

    trace = False ; verbose = False
    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>

    if trace: g.trace('all',self.all)
    self.copyRoot.expand()
    for n,p,limit,lookForMark,lookForNodes in (
        (1,p1,limit1,lookForMark1,lookForNodes1),
        (2,p2,limit2,lookForMark2,lookForNodes2),
    ):
        if n == 2 and self.all: return
        if trace and verbose: g.trace(
            'pass %s: mark %s nodes %s root %s limit %s' % (
                n,lookForMark,lookForNodes,
                p and p.h or '<none>',
                limit and limit.h or '<none>'))
                
        aList = findAllUnitTestNodes(c,p,limit,self.all,self.marked,lookForMark,lookForNodes)
        for p2 in aList:
            self.addNode(p2)
        
#@+node:ekr.20070705065154: *6* << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.p
    if p.h.startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True
#@+node:ekr.20070705080413: *6* addMarkTree
def addMarkTree (self,p):

    # Add the entire @mark-for-unit-tests tree.
    self.addNode(p)
#@+node:ekr.20070705065154.1: *6* addNode
def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-tests tree as the last child of self.copyRoot.
    '''

    p2 = p.copyTreeAfter()
    p2.moveToLastChildOf(self.copyRoot)

    for p2 in p.self_and_subtree():
        self.seen.append(p2.v)
#@+node:ekr.20070705075604.3: *6* isUnitTestNode
def isUnitTestNode (self,p):
    
    h = p.h.lower()
    
    # Hidden tests nodes are an anti-pattern.

        # hidden = not h.startswith('<<') and test_pat.search(p.b)
        # if hidden:
            # print('Adding hidden test: %s' % (p.h))
            # return True

    for tag in self.tags:
        if h.startswith(tag):
            return True
    else:
        return False
#@+node:ekr.20051104075904.4: *5* doTests & helpers
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20051104075904.5: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20051104075904.6: *7* __init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20051104075904.7: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20051104075904.9: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20051104075904.8: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20051104075904.10: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20051104075904.11: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20051104075904.12: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\nmakeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('\nmakeTestSuite: exception creating test cases for %s' % p.h)
        g.es_print_exception()
        return None
#@+node:ekr.20051104075904.13: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20111103073536.16582: *4* Added support for @bool use_body_focus_border
#@+node:ekr.20111022215436.16685: *5* Borders (qtGui)
def add_border(self,c,w):
    
    name = g.app.gui.widget_name(w)
    
    if name == 'richTextEdit' and not c.use_body_focus_border:
        return

    if c.use_focus_border:
        if hasattr(w,'viewport'):
            w = w.viewport()

        sheet = "border: %spx solid %s" % (
            c.focus_border_width,c.focus_border_color)
        self.update_style_sheet(w,'border',sheet)

def remove_border(self,c,w):

    if c.use_focus_border:
        if hasattr(w,'viewport'):
            w = w.viewport()
        sheet = "border: %spx solid white" % (
            c.focus_border_width)
        self.update_style_sheet(w,'border',sheet)
#@+node:ekr.20111104132424.9671: *4* Removed support for hidden unit tests
@nocolor-node

The are an anti-pattern in the new testing scheme.
#@+node:ekr.20111031075748.10003: *5* Added support for hidden unit tests
@nocolor-node

As of rev 4690, Leo supports "hidden" unit tests. This just may be the missing
piece of Leo's unit testing arsenal.

A hidden unit test is a node that is *not* a section-definition node and whose
body text contains one of the following guards at the start of a line::
    
    if g.unitTesting
    if g.app.unitTesting:
    if g.inScript:
    if g.app.inScript:
        
The typical usage pattern is::
    
    class myClass:
        ...
        
    if g.unitTesting:
        x = myClass()
        x.test()

For this reason, hidden unit tests could also be called "in place" unit tests:
they appear in the Leo source file, next to the code being tested.

Notes:

1. [Important]: Any one of the guards above will prevent the unit testing code
   from being executing when importing a file. Thus, you can insert a unit test
   just after the code you want to test.

2. [Spectacular]: The test tests the latest code *without* you having to reload
   Leo. The reason is simple: the code being tests (myClass, in the example
   above), is defined by either the unit tests or the execute-script command.

3. [Happy]: Within leoPy.leo I redefined alt-4 to mean
   run-all-unit-tests-locally, which is the most convenient way to run the test
   I am working on: running the other tests doesn't matter, and in fact is a
   good check.

4. Because hidden unit tests are not marked with @test, Leo always tells which
   hidden tests have been found.
#@+node:ekr.20111030155153.16705: *6* @@button find-hidden-tests
'''Run all hidden tests in this file.

Such tests have "if g.app.unitTesting:" or "if.g.app.inScript" in body text.
'''

import re

s = "^if(\s)+g(\.app)*\.(unitTesting|inScript):(\s)*$"

pat = re.compile(s,re.MULTILINE)

for p in c.all_unique_positions():
    if pat.search(p.b) and not p.h.startswith('<<'):
        print(p.h)
print('done')
#@+node:ekr.20111106070228.12432: *4* Call unselect1 hook only once
#@+node:ekr.20111106150728.9705: *5* Report/request
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/e2980a2b86af913e

Isee the following
- when a file is opened
  - one message listing the root node
  - 7 repeats of the message for the current node

- when the file is saved in a session with several tabs
  - a message is generated for each current node in each tab

- shifting focus from body to headline doesn't generate the message,
  shifting focus with <ctl-h> does

- switching from one tab to another doesn't generate the message 
#@+node:ekr.20070423101911: *5* selectHelper (leoTree)
# Do **not** try to "optimize" this by returning if p==c.p.
# 2011/11/06: *event handlers* are called only if p != c.p.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p
    
    call_event_handlers = p != old_p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace and (verbose or call_event_handlers):
        g.trace(p and p.h)
        # if old_p:
            # g.trace('old: %s %s new: %s %s' % (
                # len(old_p.b),old_p.h,len(p.b),p.h))
        # else:
            # g.trace('old: <none> new: %s %s' % (len(p.b),p.h))
            
            
    if 1: # 2011/11/06
        if call_event_handlers:
            unselect = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        else:
            unselect = True
        if unselect:
            << unselect the old node >>
        
    else: # Old code
        if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
            if old_p:
                << unselect the old node >>
    
    if call_event_handlers: # 2011/11/06
        g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        
    if call_event_handlers: # 2011/11/06
        if call_event_handlers:
            select = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        else:
            select = True
        if select:
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
    else: # old code
        if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
        
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    # if trace and (verbose or call_event_handlers):
        # g.trace('**** after old: %s new %s' % (
            # old_p and len(old_p.b),len(p.b)))

    # what UNL.py used to do
    c.frame.clearStatusLine()
    c.frame.putStatusLine(p.get_UNL())

    if call_event_handlers: # 2011/11/06
        g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return # (for Tk) 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129: *6* << unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
    
    # g.trace('set insert spot',insertSpot)
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p != p:
    # 2010/02/11: Don't change the *new* node's insert point!
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
    if g.app.trace_scroll: g.trace('old scroll: %s insert: %s' % (
        yview,insertSpot))
#@+node:ekr.20040803072955.130: *6* << select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@+node:ekr.20040803072955.133: *6* << set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

c.treeFocusHelper() # 2010/12/14
c.undoer.onSelect(old_p,p)
#@+node:ekr.20111107055809.9733: *4* Added g.app.isExternalUnitTest
Unit tests can test this ivar.
#@+node:ekr.20111107082312.9850: *4* External unit tests now *do* read settings
@nocolor-node

This adds about 0.35 seconds. This is not important with the new meaning of Alt-4.
#@+node:ekr.20111107082312.9851: *4* bridgeController.initLeo now kills events if plugins not loaded
@nocolor-node

The new code monkey-patches g.doHook to a do-nothing::
    
    if not self.loadPlugins:
        def dummyDoHook(tag,*args,**keys):
            pass
        g.doHook = dummyDoHook
#@+node:ekr.20111107092526.9784: *4* Added c.config.set
@nocolor-node

An useful convenience method now that external unit tests can use config settings.
#@+node:ekr.20111109083738.9799: *4* Alt-left-arrow collapses all children when selecting the parent
Under control of @bool collapse_on_lt_arrow option, default *True*.
#@+node:ekr.20031218072017.2920: *5* goToParent
def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.p

    # g.trace(p.parent())

    c.treeSelectHelper(p and p.parent())
#@+node:ekr.20090213065933.6: *5* c.initConfigSettings
def initConfigSettings (self):

    '''Init all cached commander config settings.'''

    c = self
    c.autoindent_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    c.collapse_nodes_after_move = c.config.getBool('collapse_nodes_after_move')
        # Patch by nh2: 0004-Add-bool-collapse_nodes_after_move-option.patch
    c.collapse_on_lt_arrow  = c.config.getBool('collapse_on_lt_arrow',default=True)
        # 2011/11/09: An excellent, subliminal, improvement.
    c.contractVisitedNodes  = c.config.getBool('contractVisitedNodes')
    c.fixed                 = c.config.getBool('fixedWindow',default=False)
    c.fixedWindowPosition   = c.config.getData('fixedWindowPosition')
    c.focus_border_color    = c.config.getColor('focus_border_color') or 'red'
    c.focus_border_width    = c.config.getInt('focus_border_width') or 1 # pixels
    c.outlineHasInitialFocus= c.config.getBool('outline_pane_has_initial_focus')
    c.showMinibuffer        = c.config.getBool('useMinibuffer')
        # This option is a bad idea.
    c.putBitsFlag           = c.config.getBool('put_expansion_bits_in_leo_files',default=True)
    # g.trace('putBitsFlag',c.putBitsFlag,c.fileName())
    c.sparse_move           = c.config.getBool('sparse_move_outline_left')
    c.sparse_find           = c.config.getBool('collapse_nodes_during_finds')
    c.sparce_spell          = c.config.getBool('collapse_nodes_while_spelling')
    c.stayInTreeAfterSelect = c.config.getBool('stayInTreeAfterSelect')
    c.stayInTreeAfterEdit   = c.config.getBool('stayInTreeAfterEditHeadline')
    c.smart_tab             = c.config.getBool('smart_tab')
        # Note: there is also a smart_auto_indent setting.
    c.tab_width             = c.config.getInt('tab_width') or -4
    c.use_body_focus_border = c.config.getBool('use_body_focus_border',default=True)
    c.use_focus_border      = c.config.getBool('use_focus_border',default=True)
    c.write_script_file     = c.config.getBool('write_script_file')

    # g.trace('smart %s, tab_width %s' % (c.smart_tab, c.tab_width))
    # g.trace(c.sparse_move)
#@+node:ekr.20040930064232: *5* contractNodeOrGoToParent
def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    
    parent = p.parent()
    redraw = False

    if p.hasChildren() and p.isExpanded():
        c.contractNode()
        
    elif parent and parent.isVisible(c):
        # New in Leo 4.9.1: contract all children first.
        if c.collapse_on_lt_arrow:
            for child in parent.children():
                if child.isExpanded():
                    child.contract()
                    redraw = True
        c.goToParent()
        
    # This is a bit off-putting.
    # elif not parent and not c.hoistStack:
        # p = c.rootPosition()
        # while p:
            # if p.isExpanded():
                # p.contract()
                # redraw = True
            # p.moveToNext()

    if redraw:
        c.redraw()
#@+node:ekr.20111112064924.9779: *4* Improved scannerUnitTest
@nocolor-node

The error message is now part of the failed assert.  Very helpful.
#@+node:ekr.20111115070256.9802: *4* External unit tests now always read config settings
@nocolor-node

The change was simply to set readSettings = True in
leoDynamicTest.py.main.

Experience show the extra time (0.3 sec) is very important
for some unit tests.
#@+node:ekr.20080730161153.6: *5* main & helpers (leoDynamicTest.py)
def main ():

    trace = False
    readSettings = True 
    tag = 'leoDynamicTests.leo'
    if trace: t1 = time.time()

    # Setting verbose=True prints messages that would be sent to the log pane.
    path,gui,readSettigns,silent = scanOptions()
    
    # print('(leoDynamicTest.py:main)','readSettings',readSettings)
    # print('(leoDynamicTest.py:main)','silent',silent)

    # Not loading plugins and not reading settings speeds things up considerably.
    bridge = leoBridge.controller(gui=gui,
        loadPlugins=False, # Must be False: plugins will fail when run externally.
        readSettings=True, # True: adds about 0.3 seconds.  Very useful for some tests.
        silent=True,
        verbose=False)

    if trace:
         t2 = time.time()
         print('%s open bridge:  %0.2fsec' % (tag,t2-t1))

    if bridge.isOpen():
        g = bridge.globals()
        g.app.silentMode = silent
        g.app.isExternalUnitTest = True
        path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
        c = bridge.openLeoFile(path)
        if trace:
            t3 = time.time()
            print('%s open file: %0.2fsec' % (tag,t3-t2))
        runUnitTests(c,g)
#@+node:ekr.20080730161153.7: *6* runUnitTests
def runUnitTests (c,g):

    p = c.rootPosition()
    #g.es_print('running dynamic unit tests...')
    c.selectPosition(p)
    c.debugCommands.runAllUnitTestsLocally()
#@+node:ekr.20090121164439.6176: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--path',dest='path')
    parser.add_option('--gui',dest="gui")
    parser.add_option('--read-settings',action="store_true",dest="read_settings")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- path
    # We can't finalize the path here, because g does not exist ye.
    path = options.path or 'dynamicUnitTest.leo'

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('qttabs','qt'):
        gui = 'nullGui'
        
    # --read-settings
    read_settings = options.read_settings

    # --silent
    silent = options.silent

    return path,gui,read_settings,silent
#@+node:ekr.20111114151846.9848: *4* Added @bool indent_added_comments setting
@nocolor-node

The default, True, is the legacy operation, which I recommend.

#@+node:ekr.20111115122621.9785: *4* Improved add/delete-comments
@nocolor-node

add-comments preserves trailing whitespace.
delete-comments now works whether or not blanks surround comments delims.
#@+node:ekr.20050312114529.1: *5* addComments
def addComments (self,event=None):
    
    << addComments docstring >>

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('no text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',' '+d3

    # Comment out non-blank lines.
    indent = c.config.getBool('indent_added_comments',default=True)
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            if indent:
                result.append(line[0:i]+openDelim+line[i:].replace('\n','')+closeDelim+'\n')
            else:
                result.append(openDelim+line.replace('\n','')+closeDelim+'\n')
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
#@+node:ekr.20111115111842.9789: *6* << addComments docstring >>
@pagewidth 50

'''
Converts all selected lines to comment lines using
the comment delimiters given by the applicable
 @language directive.

Inserts single-line comments if possible; inserts
block comments for languages like html that lack
single-line comments.

 @bool indent_added_comments

If True (the default), inserts opening comment
delimiters just before the first non-whitespace
character of each line. Otherwise, inserts opening
comment delimiters at the start of each line.

*See also*: delete-comments.
'''
#@+node:ekr.20050312114529.2: *5* deleteComments
def deleteComments (self,event=None):
    
    << deleteComments docstring >>

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('no text selected',color='blue')
        return

    if d1:
        # Remove the single-line comment delim in front of each line
        d1b = d1 + ' '
        n1,n1b = len(d1),len(d1b)
        for s in lines:
            i = g.skip_ws(s,0)
            if g.match(s,i,d1b):
                result.append(s[:i] + s[i+n1b:])
            elif g.match(s,i,d1):
                result.append(s[:i] + s[i+n1:])
            else:
                result.append(s)
    else:
        # Remove the block comment delimiters from each line.
        n2,n3 = len(d2),len(d3)
        for s in lines:
            i = g.skip_ws(s,0)
            j = s.find(d3,i+n2)
            if g.match(s,i,d2) and j > -1:
                first = i + n2
                if g.match(s,first,' '): first += 1
                last = j
                if g.match(s,last-1,' '): last -= 1
                result.append(s[:i] + s[first:last] + s[j+n3:])
            else:
                result.append(s)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
#@+node:ekr.20111115111842.9790: *6* << deleteComments docstring >>
@pagewidth 50

'''
Removes one level of comment delimiters from all
selected lines.  The applicable @language directive
determines the comment delimiters to be removed.

Removes single-line comments if possible; removes
block comments for languages like html that lack
single-line comments.

*See also*: add-comments.
'''
#@+node:ekr.20111118090912.12875: *4* Selected @test node always run
@nocolor-node

This is true regardless of command, marked status of the node, or @ignore nodes.  Doh!

Added special-case code to findAllUnitTestNodes.
#@+node:ekr.20111118093803.10159: *4* Improve print-bindings & print-commands.
@nocolor-node

print-bindings: Alt/Ctrl+Key+N now printed with plain Alt/Ctrl keys and shown as Alt/Ctrl+N.
print-commands: Alt/Ctrl+Key+N now printed as Alt/Ctrl+N.
#@+node:ekr.20111121084517.10187: *4* Added show-decoration-selected: 1 to
Added show-decoration-selected: 1 to QTreeWidget stylesheet.

This causes the entire headline row to be shown when select, a big improvement, imo.
#@+node:ekr.20111123095018.12910: *4* Added stylesheets for Log & Find tabs
#@+node:ekr.20111215193352.10219: *4* Warn when importing/reading/writing @ignored nodes
@nocolor-node

What I did:
    
Created c.init_error_dialogs & c.raise_error_dialogs.

These are called from the following methods:
    
c.importAnyFile
c.open
c.readAtAutoNodes
c.readAtFileNodes
at.readAll
c.save
c.saveAs
c.saveTo
fc.writeAtFileNodes
fc.writeAtShadowNodes
fc.writeDirtyAtFileNodes

2. Disabled log messages in several of the above methods during unit testing.

3. Disabled runOpenFileDialog and runSaveFileDialog during unit testing.
#@+node:ekr.20120130101219.10180: *4* Improved presentation of bindings
@nocolor-node

What I did:
 
- Improved autocompletion list:
    don't print 'all' in bindings.
    print bindings first
    pad bindings properly, as is done in print-commands/bindings.
    
- Improved print-commands & print-bindings: don't print 'all'

- Simplfied the code in various ways.
#@+node:ekr.20061031131434.119: *5* k.printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[S] leoSettings.leo
[ ] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] mode

'''

    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend,c.tab_width)
    data = []
    for stroke in sorted(d):
        assert k.isStroke(stroke),stroke
        aList = d.get(stroke,[])
        for si in aList:
            assert k.isShortcutInfo(si),si
            s1 = '' if si.pane=='all' else si.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = si.commandName
            s4 = si.kind or '<no hash>'
            data.append((s1,s2,s3,s4),)

    # Print keys by type:
    result = []
    result.append('\n'+legend)
    for prefix in (
        'Alt+Ctrl+Shift','Alt+Ctrl','Alt+Shift','Alt', # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift','Ctrl+Meta','Ctrl+Shift','Ctrl', # Ctrl+Key: done by Ctrl.
        'Meta+Key','Meta+Shift','Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1,s2,s3,s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append('***** %s...\n' % prefix)
        self.printBindingsHelper(result,data2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result,data,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
    return result # for unit test.
#@+node:ekr.20061031131434.120: *6* printBindingsHelper
def printBindingsHelper (self,result,data,prefix):
 
    data.sort(key=lambda x: x[1])

    data2,n = [],0
    for pane,key,commandName,kind in data:
        key = key.replace('+Key','')
        letter = self.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane+key # pane and shortcut fields
        n = max(n,len(left))
        data2.append((letter,left,commandName),)
        
    for z in data2:
        letter,left,commandName = z
        result.append('%s %*s %s\n' % (letter,-n,left,commandName))

    if data:
        result.append('\n')
#@+node:ekr.20120130101219.10182: *6* k.computeBindingLetter
def computeBindingLetter(self,kind):
    
    table = (
        ('M','myLeoSettings.leo'),
        ('S','leoSettings.leo'),
        ('F','.leo'),
    )
    
    for letter,kind2 in table:
        if kind.lower() == kind2.lower():
            return letter
    else:
        return ' ' if kind2.find('mode') == -1 else '@'
#@+node:ekr.20061031131434.121: *5* k.printCommands
def printCommands (self,event=None):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'

    c.frame.log.clearTab(tabName)

    inverseBindingDict = k.computeInverseBindingDict()
    data,n = [],0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName,[('',''),])
        for z in dataList:
            pane, key = z
            pane = '%s ' % (pane) if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key','')
            s1 = pane + key
            s2 = commandName
            n = max(n,len(s1))
            data.append((s1,s2),)

    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n,s1,s2) for s1,s2 in data]
    g.es('',''.join(lines),tabName=tabName)
#@+node:ekr.20061031131434.175: *5* k.computeCompletionList
# Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.
        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data,n = [],0
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1a = '%s ' % (pane) if pane != 'all:' else ''
                s1b = k.prettyPrintKey(key)
                s1 = s1a + s1b
                s2 = commandName
                data.append((s1,s2),)
                n = max(n,len(s1))
        aList = ['%*s %s' % (-n,s1,s2) for s1,s2 in data]
        g.es('','\n'.join(aList),tabName=tabName)
    c.bodyWantsFocus()
#@+node:ekr.20120201092039.10044: *4* Brian's new page up/down code
#@+node:btheado.20120129145543.8180: *5* pageUpDown
def pageUpDown (self, op, moveMode):

    '''The QTextEdit PageUp/PageDown functionality seems to be "baked-in"
       and not externally accessible.  Since Leo has its own keyhandling
       functionality, this code emulates the QTextEdit paging.  This is
       a straight port of the C++ code found in the pageUpDown method
       of gui/widgets/qtextedit.cpp'''

    control = self.widget
    cursor = control.textCursor()
    moved = False
    lastY = control.cursorRect(cursor).top()
    distance = 0
    # move using movePosition to keep the cursor's x
    while True:
        y = control.cursorRect(cursor).top()
        distance += abs(y - lastY)
        lastY = y
        moved = cursor.movePosition(op, moveMode)
        if (not moved or distance >= control.height()):
            break
    tc = QtGui.QTextCursor
    sb = control.verticalScrollBar()
    if moved:
        if (op == tc.Up):
            cursor.movePosition(tc.Down, moveMode)
            sb.triggerAction(QtGui.QAbstractSlider.SliderPageStepSub)
        else:
            cursor.movePosition(tc.Up, moveMode)
            sb.triggerAction(QtGui.QAbstractSlider.SliderPageStepAdd)
    control.setTextCursor(cursor)
#@+node:ekr.20110730093802.15135: *3* Investigations
#@+node:ekr.20110728093358.6703: *4* Over-riding bindings
#@+node:ekr.20061031131434.3: *5* << about key dicts >>
@nocolor
@

ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           lists of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     Interior masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:

(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) Interior masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
#@+node:ekr.20061031131434.146: *5* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event):

    '''This is the handler for almost all key bindings.'''
    
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True
    
    k,c = self,self.c ; gui = g.app.gui
    c.check_event(event)
    << define vars >>
    
    assert k.isStrokeOrNone(stroke)

    if char in special_keys:
        if trace and verbose: g.trace('char',char)
        return None
    
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'char:',
        repr(event and event.char),
        'ch:',repr(event and event.char),
        'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endMacro()
            return # (for Tk) 'break'
        else:
            return k.masterCommand(commandName='keyboard-quit',
                event=event,func=k.keyboardQuit,stroke=stroke)

    if k.inState():
        if trace: g.trace('   state %-10s %s' % (stroke,state))
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')
            
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            return k.handleUnboundKeys(event,char,stroke)

    # 2011/02/08: Use getPandBindings for *all* keys.
    si = k.getPaneBinding(stroke,w)
    if si:
        assert k.isShortcutInfo(si),si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke,si.func.__name__)
        return k.masterCommand(event=event,
            commandName=si.commandName,func=si.func,stroke=si.stroke)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        return k.handleUnboundKeys(event,char,stroke)
#@+node:ekr.20061031131434.147: *6* << define vars >>
w = event and event.widget
char = event and event.char or ''
stroke = event and event.stroke or None
w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@+node:ekr.20061031131434.108: *6* callStateFunction
def callStateFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; val = None 
    ch = event and event.char or ''
    stroke = event and event.stroke or ''

    if trace: g.trace(k.state.kind,'ch',ch,'stroke',stroke,
        'ignore_unbound_non_ascii_keys',k.ignore_unbound_non_ascii_keys)
        
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns',repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@+node:ekr.20091230094319.6244: *6* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns',repr(val))
        if val == 'do-standard-keys':
            return False,None # 2011/06/17.
        else:
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        assert k.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert k.isShortcutInfo(si),si
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=si.commandName,func=si.func,
                modeName=state,nextMode=si.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode()
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
#@+node:ekr.20091230094319.6240: *6* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction
    
    assert k.isStroke(stroke)

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert k.isShortcutInfo(si),si
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case',si.commandName)
                        pass
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(si.stroke),si.commandName))
                        return si

    return None
#@+node:ekr.20061031131434.152: *6* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
        
    assert k.isStroke(stroke)

    if state in ('getArg','full-command'):
        if stroke in ('\b','BackSpace','\r','Linefeed','\n','Return','\t','Tab','Escape',):
            return False
        if k.isFKey(stroke):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert k.isShortcutInfo(si),si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane),si.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName,event=event,func=si.func,stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@+node:ekr.20110209083917.16004: *6* isAutoCompleteChar
def isAutoCompleteChar (self,stroke):
    
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction
    
    assert k.isStrokeOrNone(stroke)
    
    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                    assert k.isShortcutInfo(si),si
                    if si.commandName == 'auto-complete':
                        return True
    return False
#@+node:ekr.20080510095819.1: *6* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,stroke):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    
    assert k.isStroke(stroke)

    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return None
        
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key',stroke)
        return None

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event=event,stroke=stroke)

    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char),repr(stroke))
        return None

    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char),repr(stroke))
        return None

    elif (
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return None

    else:
        if trace: g.trace('no func',repr(char),repr(stroke))
        return k.masterCommand(event=event,stroke=stroke)
#@+node:ekr.20061031131434.119: *5* k.printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[S] leoSettings.leo
[ ] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] mode

'''

    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend,c.tab_width)
    data = []
    for stroke in sorted(d):
        assert k.isStroke(stroke),stroke
        aList = d.get(stroke,[])
        for si in aList:
            assert k.isShortcutInfo(si),si
            s1 = '' if si.pane=='all' else si.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = si.commandName
            s4 = si.kind or '<no hash>'
            data.append((s1,s2,s3,s4),)

    # Print keys by type:
    result = []
    result.append('\n'+legend)
    for prefix in (
        'Alt+Ctrl+Shift','Alt+Ctrl','Alt+Shift','Alt', # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift','Ctrl+Meta','Ctrl+Shift','Ctrl', # Ctrl+Key: done by Ctrl.
        'Meta+Key','Meta+Shift','Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1,s2,s3,s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append('***** %s...\n' % prefix)
        self.printBindingsHelper(result,data2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result,data,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
    return result # for unit test.
#@+node:ekr.20061031131434.120: *6* printBindingsHelper
def printBindingsHelper (self,result,data,prefix):
 
    data.sort(key=lambda x: x[1])

    data2,n = [],0
    for pane,key,commandName,kind in data:
        key = key.replace('+Key','')
        letter = self.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane+key # pane and shortcut fields
        n = max(n,len(left))
        data2.append((letter,left,commandName),)
        
    for z in data2:
        letter,left,commandName = z
        result.append('%s %*s %s\n' % (letter,-n,left,commandName))

    if data:
        result.append('\n')
#@+node:ekr.20120130101219.10182: *6* k.computeBindingLetter
def computeBindingLetter(self,kind):
    
    table = (
        ('M','myLeoSettings.leo'),
        ('S','leoSettings.leo'),
        ('F','.leo'),
    )
    
    for letter,kind2 in table:
        if kind.lower() == kind2.lower():
            return letter
    else:
        return ' ' if kind2.find('mode') == -1 else '@'
#@+node:ekr.20041117062717.14: *5* getShortcut (g.app.config)
def getShortcut (self,c,commandName):

    '''Return rawKey,accel for shortcutName'''
    
    trace = False and not g.unitTesting # and commandName in ('new','print-bindings')

    key = c.frame.menu.canonicalizeMenuName(commandName)
    key = key.replace('&','') # Allow '&' in names.

    # New code: use the dicts created by make_settings_dict.
    table = (
        ('local',            c and self.localShortcutsDict.get(c.hash(),{})),
        ('myLeoSettings.leo',g.app.config.immutable_my_leo_settings_shortcuts_dict),
        ('leoSettings.leo',  g.app.config.immutable_leo_settings_shortcuts_dict),
    )
    aList = []
    for tag,d in table:
        if d:
            if trace: g.trace(tag,len(list(d.keys())))
            aList = d.get(commandName,[])
            if aList:
                for si in aList:
                    assert isinstance(si,leoKeys.ShortcutInfo),si
                break
                
    # It's very important to filter empty strokes here.
    aList = [si for si in aList
        if si.stroke and si.stroke.lower() != 'none']

    if trace: g.trace('getShortcut',tag,aList)

    return key,aList
#@+node:ekr.20041117083141: *5* get & allies (g.app.config)
def get (self,c,setting,kind):

    """Get the setting and make sure its type matches the expected type."""
    
    trace = False and not g.unitTesting

    isLeoSettings = c and c.shortFileName().endswith('leoSettings.leo')

    # New in Leo 4.6. Use settings in leoSettings.leo *last*.
    if c and not isLeoSettings:
        # For the local .leo file.
        d = self.localOptionsDict.get(c.hash(),{})
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                if trace: g.trace('**1',setting,val,d.name())
                return val

    for d in self.localOptionsList:
        # For myLeoSettings.leo and leoSettings.leo.
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            if trace: g.trace('**2',setting,val,d.name())
            return val

    for d in self.dictList:
        # For hard-coded options...
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            if trace: g.trace('**3',setting,val,d.name())
            return val

    # New in Leo 4.6. Use settings in leoSettings.leo *last*.
    if c and isLeoSettings:
        # For when leoSettings.leo is the local file.
        d = self.localOptionsDict.get(c.hash(),{})
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                if trace: g.trace('**4',setting,val,d.name())
                return val

    if trace:
        fn = c and c.shortFileName() or '<no file>'
        g.trace(setting,None,fn)
    return None
#@+node:ekr.20041121143823: *6* getValFromDict
def getValFromDict (self,d,setting,requestedType,warn=True):

    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    gs = d.get(self.munge(setting))
    if not gs: return None,False
    assert isinstance(gs,GeneralSetting)
    
    # g.trace(setting,requestedType,gs.toString())
    val = gs.val

    # 2011/10/24: test for an explicit None.
    if g.isPython3:
        isNone = val in ('None','none','') # ,None)
    else:
        isNone = val in (
            unicode('None'),unicode('none'),unicode(''),
            'None','none','') #,None)

    if not self.typesMatch(gs.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            g.es_print('warning: ignoring',gs.kind,'',setting,'is not',requestedType,color='red')
            g.es_print('there may be conflicting settings!',color='red')
        return None, False
    # elif val in (u'None',u'none','None','none','',None):
    elif isNone:
        return '', True
            # 2011/10/24: Exists, a *user-defined* empty value.
    else:
        # g.trace(setting,val)
        return val, True
#@+node:ekr.20051015093141: *6* typesMatch
def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything *except* shortcuts.
    - Shortcut matches shortcuts.
    '''

    # The shortcuts logic no longer uses the get/set code.
    shortcuts = ('shortcut','shortcuts',)
    if type1 in shortcuts or type2 in shortcuts:
        g.trace('oops: type in shortcuts')

    return (
        type1 == None or type2 == None or
        type1.startswith('string') and type2 not in shortcuts or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
#@+node:ekr.20110904102049.15417: *4* Relative path problems
#@+node:ekr.20101022172109.6108: *5* g.scanAtPathDirectives scanAllAtPathDirectives
def scanAtPathDirectives(c,aList):

    path = c.scanAtPathDirectives(aList)
    return path

def scanAllAtPathDirectives(c,p):

    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path
#@+node:ekr.20080828103146.15: *5* c.scanAtPathDirectives
def scanAtPathDirectives(self,aList):

    '''Scan aList for @path directives.
    Return a reasonable default if no @path directive is found.'''

    trace = False and not g.unitTesting
    verbose = True

    c = self
    c.scanAtPathDirectivesCount += 1 # An important statistic.
    if trace and verbose: g.trace('**entry',g.callers(4))

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose:
        g.trace('base   ',base)
        g.trace('loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        warning = d.get('@path_in_body')
        if trace and path:
            g.trace('**** d',d)
            g.trace('**** @path path',path)
        if path is not None: # retain empty paths for warnings.
            # Convert "path" or <path> to path.
            path = g.stripPathCruft(path)
            if path and not warning:
                paths.append(path)
            # We will silently ignore empty @path directives.

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose:
        g.printList(paths,tag='c.scanAtPathDirectives: raw paths')

    path = c.os_path_finalize_join(*paths)

    if trace and verbose: g.trace('joined path:',path)
    if trace: g.trace('returns',path)

    return path or g.getBaseDirectory(c)
        # 2010/10/22: A useful default.
#@+node:ekr.20080922124033.6: *5* os_path_expandExpression
def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    trace = False
    
    s1 = s
    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    if not s:
        if trace: g.trace('no s')
        return ''

    i = s.find('{{')
    j = s.find('}}')
    if -1 < i < j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.p
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
                if trace: g.trace(s1,s)
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

    return s
#@+node:ekr.20080921060401.14: *5* g.os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c = keys.get('c')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path)
    path = os.path.abspath(path)
    path = os.path.normpath(path)
    return path

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c = keys.get('c')

    if c:
        args = [g.os_path_expandExpression(z,**keys)
            for z in args if z]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@+node:ekr.20111020092529.15886: *4* Investigate bug: 877332: @file TEX files not reading correctly
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/877332

Not valid: this is a 4.9-final bug that was fixed long ago.

reading: @thin C:\Documents and Settings\Rob\Desktop\Dropbox\Templates\LaTex Templates\Exam2.tex
exception executing command
Traceback (most recent call last):
 File "C:\Program Files\Leo-4.9-final\leo\core\leoCommands.py", line 408, in doCommand
   val = command(event)
 File "C:\Program Files\Leo-4.9-final\leo\core\leoCommands.py", line 981, in importAnyFile
   ic.importDerivedFiles(parent=c.p,paths=derived)
 File "C:\Program Files\Leo-4.9-final\leo\core\leoImport.py", line 978, in importDerivedFiles
   at.read(p)
 File "C:\Program Files\Leo-4.9-final\leo\core\leoAtFile.py", line 586, in read
   c.cacher.writeFile(root,fileKey)
 File "C:\Program Files\Leo-4.9-final\leo\core\leoCache.py", line 412, in writeFile
   elif fileKey in self.db:
TypeError: argument of type 'NoneType' is not iterable
#@+node:ekr.20100208071151.5903: *5* writeFile (cacher)
# Was atFile.writeCachedTree

def writeFile(self,p,fileKey):

    trace = False and not g.unitTesting
    c = self.c

    # Bug fix: 2010/05/26: check g.enableDB before giving internal error.
    if not g.enableDB:
        if trace: g.trace('cache disabled')
    elif not fileKey:
        g.trace(g.callers(5))
        g.internalError('empty fileKey')
    elif self.db.get(fileKey):
        if trace: g.trace('already cached',fileKey)
    else:
        if trace: g.trace('caching ',p.h,fileKey)
        self.db[fileKey] = self.makeCacheList(p)
        
    # if trace: g.trace('* callers',g.callers(4))
#@+node:ekr.20111028111441.16583: *4* Investigated viewrendered problem: file not found
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/928b7222cebf1b7c

Short summary:  Not a Leo problem::
    
    os.path.abspath(r'N:\whatever') yields valid file name.
    os.path.abspath(r'\N:\watever') yields invalid file name.
#@+node:ekr.20111108174504.9791: *4* Investigated unicode problems with print
@nocolor-node

After so many years of confusion the problem is now apparent:
the Windows console uses code page 437: which is just extended ascii.

chcp 65001 is equivalent to utf-8, and it would be good to use,
but at present bzr goes nuts and changes to another code page!

So for the moment I'll have to live with what is, in effect, plain ascii.
#@+node:ekr.20110930075237.15471: *4* Investigated autocomplete popup bug
@nocolor-node

On Ubuntu only, the auto complete popup is system-wide modal, it should only be modal over Leo windows.

However, there does not seem to be any fix:
http://groups.google.com/group/leo-editor/browse_thread/thread/171aaf79e0bea256

All works well on Windows 7.  I do see the "system-wide" model
behavior on Ubuntu.

This appears to be a Ubuntu-specific bug.  Indeed, the popup is a
QListWidget.  Such widgets have a setWindowModality method::

    setWindowModality ( Qt::WindowModality windowModality )

The valid modalities are at: http://doc.qt.nokia.com/4.7-snapshot/qt.html#WindowModality-enum

NonModal: The window is not modal and does not block input to other
windows.

WindowModal: The window is modal to a single window hierarchy and
blocks input to its parent window, all grandparent windows, and all
siblings of its parent and grandparent windows.

ApplicationModal: The window is modal to the application and blocks
input to all windows.

None of these would appear to be a system-wide modality, and
furthermore, the default is supposed to be NonModal.

Anyway, calling setWindowModality(QtCore.Qt.NonModal) does not seem to
have much effect on Ubuntu, so I think I can safely say there is
nothing more I can do. 
#@+node:ekr.20111010082822.15543: *4* Investigated language detection for .tex files
# It works for me, but I simplified the code.
#@+node:ekr.20031218072017.368: *5* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "javascript"    : "// /* */", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "<%-- --%>", # EKR: 2011/11/25
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "matlab"        : "%", # EKR: 2011/10/21
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "javascript"    : "js", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "jsp", # EKR: 2011/11/25
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "matlab"        : "m", # EKR: 2011/10/21
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "js"    : "javascript", # EKR: 2011/11/12: For javascript import test.
    "jsp"   : "javaserverpage", # EKR: 2011/11/25: For @shadow.
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "m"     : "matlab", # EKR 2011/10/21
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
#@+node:ekr.20110605121601.18550: *5* Syntax coloring
#@+node:ekr.20110605121601.18551: *6* leoQtColorizer
# This is c.frame.body.colorizer

class leoQtColorizer:

    '''An adaptor class that interfaces Leo's core to two class:

    1. a subclass of QSyntaxHighlighter,

    2. the jEditColorizer class that contains the
       pattern-matchin code from the threading colorizer plugin.'''

    @others

#@+node:ekr.20110605121601.18552: *7*  ctor (leoQtColorizer)
def __init__ (self,c,w):

    # g.trace('(leoQtColorizer)',w)

    self.c = c
    self.w = w

    # Step 1: create the ivars.
    self.changingText = False
    self.count = 0 # For unit testing.
    self.enabled = c.config.getBool('use_syntax_coloring')
    self.error = False # Set if there is an error in jeditColorizer.recolor
    self.flag = True # Per-node enable/disable flag.
    self.killColorFlag = False
    self.language = 'python' # set by scanColorDirectives.
    self.languageList = [] # List of color directives in the node the determines it.
    self.max_chars_to_colorize = c.config.getInt('qt_max_colorized_chars') or 0
    self.oldLanguageList = []
    self.oldV = None
    self.showInvisibles = False # 2010/1/2

    # Step 2: create the highlighter.
    self.highlighter = leoQtSyntaxHighlighter(c,w,colorizer=self)
    self.colorer = self.highlighter.colorer
    w.leo_colorizer = self

    # Step 3: finish enabling.
    if self.enabled:
        self.enabled = hasattr(self.highlighter,'currentBlock')
#@+node:ekr.20110605121601.18553: *7* colorize (leoQtColorizer)
def colorize(self,p,incremental=False,interruptable=True):

    '''The main colorizer entry point.'''

    trace = False and not g.unitTesting ; verbose = False

    self.count += 1 # For unit testing.

    if len(p.b) > self.max_chars_to_colorize > 0:
        self.flag = False
    elif self.enabled:
        oldFlag = self.flag
        self.updateSyntaxColorer(p)
            # sets self.flag and self.language and self.languageList.
        if trace and verbose:
            g.trace('old: %s, new: %s, %s' % (
                self.oldLanguageList,self.languageList,repr(p.h)))
        if (oldFlag != self.flag or
            self.oldV != p.v or
            self.oldLanguageList != self.languageList or
            not incremental
        ):
            if trace: g.trace('** calling rehighlight **')
            self.oldLanguageList = self.languageList[:]
            self.oldV = p.v
            self.highlighter.rehighlight(p)

    return "ok" # For unit testing.
#@+node:ekr.20110605121601.18554: *7* enable/disable
def disable (self,p):

    g.trace(g.callers(4))

    if self.enabled:
        self.flag = False
        self.enabled = False
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

def enable (self,p):

    g.trace(g.callers(4))

    if not self.enabled:
        self.enabled = True
        self.flag = True
        # Do a full recolor, but only if we aren't changing nodes.
        if self.c.currentPosition() == p:
            self.highlighter.rehighlight(p)
#@+node:ekr.20110605121601.18555: *7* minor entry points
def interrupt(self):
    pass

def isSameColorState (self):
    return True # Disable some logic in leoTree.select.

def kill (self):
    pass
#@+node:ekr.20110605121601.18556: *7* scanColorDirectives (leoQtColorizer) & helper
def scanColorDirectives(self,p):
    
    '''Set self.language based on the directives in p's tree.'''

    trace = False and not g.unitTesting
    c = self.c
    if c == None: return None # self.c may be None for testing.
    
    root = p.copy()
    self.language = None
    self.rootMode = None # None, "code" or "doc"

    for p in root.self_and_parents():
        theDict = g.get_directives_dict(p)
        # if trace: g.trace(p.h,theDict)
        << Test for @language >>
        << Test for @root, @root-doc or @root-code >>
        
    # 2011/05/28: If no language, get the language from any @<file> node.
    if self.language:
        if trace: g.trace('found @language %s' % (self.language))
        return self.language
        
    #  Attempt to get the language from the nearest enclosing @<file> node.
    self.language = g.getLanguageFromAncestorAtFileNode(root)

    if not self.language:
        if trace: g.trace('using default',c.target_language)
        self.language = c.target_language

    return self.language # For use by external routines.
#@+node:ekr.20110605121601.18557: *8* << Test for @language >>
if 'language' in theDict:
    s = theDict["language"]
    i = g.skip_ws(s,0)
    j = g.skip_c_id(s,i)
    aList = self.findLanguageDirectives(p)
    # In the root node, we use the first (valid) @language directive,
    # no matter how many @language directives the root node contains.
    # In ancestor nodes, only unambiguous @language directives
    # set self.language.
    if p == root or len(aList) == 1:
        self.languageList = aList
        self.language = aList and aList[0] or []
        break
#@+node:ekr.20110605121601.18558: *8* << Test for @root, @root-doc or @root-code >>
if 'root' in theDict and not self.rootMode:

    s = theDict["root"]
    if g.match_word(s,0,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,0,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@+node:ekr.20110605121601.18559: *8* findLanguageDirectives
def findLanguageDirectives (self,p):

    '''Scan p's body text for *valid* @language directives.

    Return a list of languages.'''
    
    # Speed not very important: called only for nodes containing @language directives.
    trace = False and not g.unitTesting
    aList = []
    for s in g.splitLines(p.b):
        if g.match_word(s,0,'@language'):
            i = len('@language')
            i = g.skip_ws(s,i)
            j = g.skip_id(s,i)
            if j > i:
                word = s[i:j]
                if self.isValidLanguage(word):
                    aList.append(word)
                else:
                    if trace:g.trace('invalid',word)

    if trace: g.trace(aList)
    return aList
#@+node:ekr.20110605121601.18560: *8* isValidLanguage
def isValidLanguage (self,language):
    
    fn = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
    return g.os_path_exists(fn)
#@+node:ekr.20110605121601.18561: *7* setHighlighter
# Called *only* from leoTree.setBodyTextAfterSelect

def setHighlighter (self,p):

    trace = False and not g.unitTesting
    c = self.c

    if self.enabled:
        self.flag = self.updateSyntaxColorer(p)
        if self.flag:
            # Do a full recolor, but only if we aren't changing nodes.
            if self.c.currentPosition() == p:
                self.highlighter.rehighlight(p)
        else:
            self.highlighter.rehighlight(p) # Do a full recolor (to black)
    else:
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

    if trace: g.trace('enabled: %s flag: %s %s' % (
        self.enabled,self.flag,p.h),g.callers())
#@+node:ekr.20110605121601.18562: *7* updateSyntaxColorer
def updateSyntaxColorer (self,p):

    trace = False and not g.unitTesting
    p = p.copy()

    if len(p.b) > self.max_chars_to_colorize > 0:
        self.flag = False
    else:
        # self.flag is True unless an unambiguous @nocolor is seen.
        self.flag = self.useSyntaxColoring(p)
        self.scanColorDirectives(p) # Sets self.language

    if trace: g.trace(self.flag,len(p.b),self.language,p.h,g.callers(5))
    return self.flag
#@+node:ekr.20110605121601.18563: *7* useSyntaxColoring & helper
def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    trace = False and not g.unitTesting
    if not p:
        if trace: g.trace('no p',repr(p))
        return False

    p = p.copy()
    first = True ; kind = None ; val = True
    self.killColorFlag = False
    for p in p.self_and_parents():
        d = self.findColorDirectives(p)
        color,no_color = 'color' in d,'nocolor' in d
        # An @nocolor-node in the first node disabled coloring.
        if first and 'nocolor-node' in d:
            kind = '@nocolor-node'
            self.killColorFlag = True
            val = False ; break
        # A killcolor anywhere disables coloring.
        elif 'killcolor' in d:
            kind = '@killcolor %s' % p.h
            self.killColorFlag = True
            val = False ; break
        # A color anywhere in the target enables coloring.
        elif color and first:
            kind = 'color %s' % p.h
            val = True ; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            kind = '@nocolor %s' % p.h
            val = False ; break
        elif color and not no_color:
            kind = '@color %s' % p.h
            val = True ; break
        first = False

    if trace: g.trace(val,kind)
    return val
#@+node:ekr.20110605121601.18564: *8* findColorDirectives
color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    ,re.MULTILINE)

def findColorDirectives (self,p):

    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''

    trace = False and not g.unitTesting

    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word

    if trace: g.trace(d)
    return d
#@+node:ekr.20110605121601.18565: *6* leoQtSyntaxHighlighter
# This is c.frame.body.colorizer.highlighter

class leoQtSyntaxHighlighter(QtGui.QSyntaxHighlighter):

    '''A subclass of QSyntaxHighlighter that overrides
    the highlightBlock and rehighlight methods.

    All actual syntax coloring is done in the jeditColorer class.'''

    @others
#@+node:ekr.20110605121601.18566: *7* ctor (leoQtSyntaxHighlighter)
def __init__ (self,c,w,colorizer):

    self.c = c
    self.w = w

    # print('leoQtSyntaxHighlighter.__init__',w)

    # Not all versions of Qt have the crucial currentBlock method.
    self.hasCurrentBlock = hasattr(self,'currentBlock')

    # Init the base class.
    QtGui.QSyntaxHighlighter.__init__(self,w)

    self.colorizer = colorizer

    self.colorer = jEditColorizer(c,
        colorizer=colorizer,
        highlighter=self,
        w=c.frame.body.bodyCtrl)
#@+node:ekr.20110605121601.18567: *7* highlightBlock
def highlightBlock (self,s):
    """ Called by QSyntaxHiglighter """

    if self.hasCurrentBlock and not self.colorizer.killColorFlag:
        if g.isPython3:
            s = str(s)
        else:
            s = unicode(s)
        self.colorer.recolor(s)

#@+node:ekr.20110605121601.18568: *7* rehighlight
def rehighlight (self,p):

    '''Override base rehighlight method'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; tree = c.frame.tree
    self.w = c.frame.body.bodyCtrl.widget
    s = p.b
    self.colorer.init(p,s)
    n = self.colorer.recolorCount
    
    if trace: g.trace(p.h)

    # Call the base class method, but *only*
    # if the crucial 'currentBlock' method exists.
    if self.colorizer.enabled and self.hasCurrentBlock:
        # Lock out onTextChanged.
        old_selecting = c.frame.tree.selecting
        try:
            c.frame.tree.selecting = True
            QtGui.QSyntaxHighlighter.rehighlight(self)
        finally:
            c.frame.tree.selecting = old_selecting

    if trace and verbose:
        g.trace('%s %s calls to recolor' % (
            p.h,self.colorer.recolorCount-n))
#@+node:ekr.20110605121601.18569: *6* class jeditColorizer
# This is c.frame.body.colorizer.highlighter.colorer

class jEditColorizer:

    '''This class contains jEdit pattern matchers adapted
    for use with QSyntaxHighlighter.'''

    << about the line-oriented jEdit colorizer >>

    @others
#@+node:ekr.20110605121601.18570: *7* << about the line-oriented jEdit colorizer >>
@nocolor-node
@

The aha behind the line-oriented jEdit colorizer is that we can define one or
more *restarter* methods for each pattern matcher that could possibly match
across line boundaries. I say "one or more" because we need a separate restarter
method for all combinations of arguments that can be passed to the jEdit pattern
matchers. In effect, these restarters are lambda bindings for the generic
restarter methods.

In actuality, very few restarters are needed. For example, for Python, we need
restarters for continued strings, and both flavors of continued triple-quoted
strings. For python, these turn out to be three separate lambda bindings for
restart_match_span.

When a jEdit pattern matcher partially succeeds, it creates the lambda binding
for its restarter and calls setRestart to set the ending state of the present
line to an integer representing the bound restarter. setRestart calls
computeState to create a *string* representing the lambda binding of the
restarter. setRestart then calls stateNameToStateNumber to convert that string
to an integer state number that then gets passed to Qt's setCurrentBlockState.
The string is useful for debugging; Qt only uses the corresponding number.
#@+node:ekr.20110605121601.18571: *7*  Birth & init
#@+node:ekr.20110605121601.18572: *8* __init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    self.defaultState = 'default-state:' # The name of the default state.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False
        # True: trace all matching methods.
        # This isn't so useful now that colorRangeWithTag shows g.callers(2).
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.language_name = None # The name of the language for the current mode.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
    
        # To be removed...
    
            # Used only by the old colorizer.
            # 'bracketRange',
            # "comment",
            # "cwebName"
            # "keyword",
            # "latexBackground","latexKeyword","latexModeKeyword",
            # "pp",
            # "string",
            
            # Wiki styling.  These were never user options.
            # "bold","bolditalic","elide","italic",
            
            # Marked as Leo jEdit tags, but not used.
            # '@color', '@nocolor','doc_part', 'section_ref',
        
        # 8 Leo-specific tags.
        "blank",  # show_invisibles_space_color
        "docpart",
        "leokeyword",
        "link",
        "name",
        "namebrackets",
        "tab", # show_invisibles_space_color
        "url",
        
        # jEdit tags.
        'comment1','comment2','comment3','comment4',
        # default, # exists, but never generated.
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
#@+node:ekr.20110605121601.18573: *9* defineLeoKeywordsDict
def defineLeoKeywordsDict(self):

    self.leoKeywordsDict = {}

    for key in g.globalDirectiveList:
        self.leoKeywordsDict [key] = 'leokeyword'
#@+node:ekr.20110605121601.18574: *9* defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
    
        # Used in Leo rules...
    
        # tag name      :( option name,                  default color),
        'blank'         :('show_invisibles_space_color', '#E5E5E5'), # gray90
        'docpart'       :('doc_part_color',              'red'),
        'leokeyword'    :('leo_keyword_color',           'blue'),
        'link'          :('section_name_color',          'red'),
        'name'          :('undefined_section_name_color','red'),
        'namebrackets'  :('section_name_brackets_color', 'blue'),
        'tab'           :('show_invisibles_tab_color',   '#CCCCCC'), # gray80
        'url'           :('url_color',                   'purple'),
        
        # Used by the old colorizer: to be removed.
        
        # 'bracketRange'   :('bracket_range_color',     'orange'), # Forth.
        # 'comment'        :('comment_color',           'red'),
        # 'cwebName'       :('cweb_section_name_color', 'red'),
        # 'keyword'        :('keyword_color',           'blue'),
        # 'latexBackground':('latex_background_color',  'white'),
        # 'pp'             :('directive_color',         'blue'),
        # 'string'         :('string_color',            '#00aa00'), # Used by IDLE.

        # jEdit tags.
        # tag name  :( option name,     default color),
        'comment1'  :('comment1_color', 'red'),
        'comment2'  :('comment2_color', 'red'),
        'comment3'  :('comment3_color', 'red'),
        'comment4'  :('comment4_color', 'red'),
        'function'  :('function_color', 'black'),
        'keyword1'  :('keyword1_color', 'blue'),
        'keyword2'  :('keyword2_color', 'blue'),
        'keyword3'  :('keyword3_color', 'blue'),
        'keyword4'  :('keyword4_color', 'blue'),
        'keyword5'  :('keyword5_color', 'blue'),
        'label'     :('label_color',    'black'),
        'literal1'  :('literal1_color', '#00aa00'),
        'literal2'  :('literal2_color', '#00aa00'),
        'literal3'  :('literal3_color', '#00aa00'),
        'literal4'  :('literal4_color', '#00aa00'),
        'markup'    :('markup_color',   'red'),
        'null'      :('null_color',     None), #'black'),
        'operator'  :('operator_color', None), #'black'),
    }
#@+node:ekr.20110605121601.18575: *9* defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
    
        # Used in Leo rules...
        
            # tag name      : option name
            'blank'         :'show_invisibles_space_font', # 2011/10/24.
            'docpart'       :'doc_part_font',
            'leokeyword'    :'leo_keyword_font',
            'link'          :'section_name_font',
            'name'          :'undefined_section_name_font',
            'namebrackets'  :'section_name_brackets_font',
            'tab'           : 'show_invisibles_tab_font', # 2011/10/24.
            'url'           : 'url_font',
        
        # Used by old colorizer.
        
            # 'bracketRange'   :'bracketRange_font', # Forth.
            # 'comment'       :'comment_font',
            # 'cwebName'      :'cweb_section_name_font',
            # 'keyword'       :'keyword_font',
            # 'latexBackground':'latex_background_font',
            # 'pp'            :'directive_font',
            # 'string'        :'string_font',
    
         # jEdit tags.
         
             # tag name     : option name
            'comment1'      :'comment1_font',
            'comment2'      :'comment2_font',
            'comment3'      :'comment3_font',
            'comment4'      :'comment4_font',
            #'default'       :'default_font',
            'function'      :'function_font',
            'keyword1'      :'keyword1_font',
            'keyword2'      :'keyword2_font',
            'keyword3'      :'keyword3_font',
            'keyword4'      :'keyword4_font',
            'keyword5'      :'keyword5_font',
            'label'         :'label_font',
            'literal1'      :'literal1_font',
            'literal2'      :'literal2_font',
            'literal3'      :'literal3_font',
            'literal4'      :'literal4_font',
            'markup'        :'markup_font',
            # 'nocolor' This tag is used, but never generates code.
            'null'          :'null_font',
            'operator'      :'operator_font',
    }
#@+node:ekr.20110605121601.18576: *8* addImportedRules
def addImportedRules (self,mode,rulesDict,rulesetName):

    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''

    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets [rulesetName] = True

    names = hasattr(mode,'importDict') and mode.importDict.get(rulesetName,[]) or []

    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key,[])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        # g.trace([z.__name__ for z in rules])
                        aList.extend(rules)
                        self.rulesDict [key] = aList
        # g.trace('***** added rules for %s from %s' % (name,rulesetName))
        self.initModeFromBunch(savedBunch)
#@+node:ekr.20110605121601.18577: *8* addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_language, True), # 2011/01/17
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True),
        ('f',  self.match_url_f,        True),
        ('h',  self.match_url_h,       True),
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.

        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
#@+node:ekr.20111024091133.16702: *8* configure_hard_tab_width
def configure_hard_tab_width (self):
    
    # The stated default is 40, but apparently it must be set explicitly.
    
    trace = False and not g.unitTesting
    c,w = self.c,self.w
 
    if 0:
        # No longer used: c.config.getInt('qt-tab-width')
        hard_tab_width = abs(10*c.tab_width)
        if trace: g.trace('hard_tab_width',hard_tab_width,self.w)
    else:
        # For some reason, the size is not accurate.
        font = w.widget.currentFont()
        info = QtGui.QFontInfo(font)
        size = info.pointSizeF()
        pixels_per_point = 1.0 # 0.9
        hard_tab_width = abs(int(pixels_per_point*size*c.tab_width))
        
        if trace: g.trace(
            'family',font.family(),'point size',size,
            'tab_width',c.tab_width,
            'hard_tab_width',hard_tab_width) # ,self.w)
    
    w.widget.setTabStopWidth(hard_tab_width)
#@+node:ekr.20110605121601.18578: *8* configure_tags
def configure_tags (self):

    trace = False and not g.unitTesting
    traceColors = False
    traceFonts = False
    c = self.c ; w = self.w
    isQt = g.app.gui.guiName().startswith('qt')

    if trace: g.trace(self.colorizer.language)

    if w and hasattr(w,'start_tag_configure'):
        w.start_tag_configure()

    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont

    # Configure fonts.
    if trace and traceFonts: g.trace('*'*10,'configuring fonts')
    keys = list(self.default_font_dict.keys()) ; keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language,option_name),(option_name)):
            if trace and traceFonts: g.trace(name)
            font = self.fonts.get(name)
            if font:
                if trace and traceFonts:
                    g.trace('**found',name,id(font))
                w.tag_configure(key,font=font)
                break
            else:
                family = c.config.get(name + '_family','family')
                size   = c.config.get(name + '_size',  'size')   
                slant  = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight','weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size   = size or c.config.defaultBodyFontSize
                    slant  = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family,size,slant,weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    if trace and traceFonts:
                        g.trace('**found',key,name,family,size,slant,weight,id(font))
                    w.tag_configure(key,font=font)
                    break

        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                if trace and traceFonts:
                    g.trace('default',key,font)
                self.fonts[key] = font # 2010/02/19: Essential
                w.tag_configure(key,font=defaultBodyfont)
            else:
                if trace and traceFonts:
                    g.trace('no fonts')
                    
        if isQt and key == 'url' and font:
            font.setUnderline(True) # 2011/03/04

    if trace and traceColors: g.trace('*'*10,'configuring colors')
    keys = list(self.default_colors_dict.keys()) ; keys.sort()
    for name in keys:
        # if name == 'operator': g.pdb()
        option_name,default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language,option_name)) or
            c.config.getColor(option_name) or
            default_color
        )
        if trace and traceColors: g.trace(option_name,color)

        # Must use foreground, not fg.
        try:
            w.tag_configure(name, foreground=color)
        except: # Recover after a user error.
            g.es_exception()
            w.tag_configure(name, foreground=default_color)

    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        w.tag_configure("link",underline=1) # defined
        w.tag_configure("name",underline=0) # undefined
    else:
        w.tag_configure("link",underline=0)
        if self.underline_undefined:
            w.tag_configure("name",underline=1)
        else:
            w.tag_configure("name",underline=0)

    self.configure_variable_tags()

    try:
        w.end_tag_configure()
    except AttributeError:
        pass
#@+node:ekr.20110605121601.18579: *8* configure_variable_tags
def configure_variable_tags (self):

    c = self.c ; w = self.w

    # g.trace()

    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80"),
        ("elide", None,                                   "yellow"),
    ):
        if self.showInvisibles:
            color = option_name and c.config.getColor(option_name) or default_color
        else:
            option_name,default_color = self.default_colors_dict.get(name,(None,None),)
            color = option_name and c.config.getColor(option_name) or ''
        try:
            w.tag_configure(name,background=color)
        except: # A user error.
            w.tag_configure(name,background=default_color)

    # Special case:
    if not self.showInvisibles:
        w.tag_configure("elide",elide="1")
#@+node:ekr.20110605121601.18580: *8* init (jeditColorizer)
def init (self,p,s):

    trace = False and not g.unitTesting

    if p: self.p = p.copy()
    self.all_s = s or ''

    if trace: g.trace('='*20,
        'tabwidth',self.c.tab_width,
        self.colorizer.language) #,g.callers(4))

    # State info.
    self.all_s = s
    self.global_i,self.global_j = 0,0
    self.global_offset = 0

    # These *must* be recomputed.
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.restartDict = {}
    self.init_mode(self.colorizer.language)
    self.clearState()
    self.showInvisibles = self.colorizer.showInvisibles
        # The show/hide-invisible commands changes this.

    # Used by matchers.
    self.prev = None
    if self.last_language != self.colorizer.language:
        # Must be done to support per-language @font/@color settings.
        self.configure_tags()
        self.last_language = self.colorizer.language
        
    self.configure_hard_tab_width() # 2011/10/04
#@+node:ekr.20110605121601.18581: *8* init_mode & helpers
def init_mode (self,name):

    '''Name may be a language name or a delegate name.'''

    trace = False and not g.unitTesting
    if not name: return False
    h = self.highlighter
    language,rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if bunch.language == 'unknown-language':
            if trace: g.trace('found unknown language')
            return False
        else:
            if trace: g.trace('found',language,rulesetName)
            self.initModeFromBunch(bunch)
            self.language_name = language # 2011/05/30
            return True
    else:
        if trace: g.trace(language,rulesetName)
        path = g.os_path_join(g.app.loadDir,'..','modes')
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        fileName = g.os_path_join(path,'%s.py' % (language))
        if g.os_path_exists(fileName):
            mode = g.importFromPath (language,path)
        else: mode = None

        if mode:
            # A hack to give modes/forth.py access to c.
            if hasattr(mode,'pre_init_mode'):
                mode.pre_init_mode(self.c)
        else:
            # Create a dummy bunch to limit recursion.
            self.modes [rulesetName] = self.modeBunch = g.Bunch(
                attributesDict  = {},
                defaultColor    = None,
                keywordsDict    = {},
                language        = 'unknown-language',
                mode            = mode,
                properties      = {},
                rulesDict       = {},
                rulesetName     = rulesetName,
                word_chars      = self.word_chars, # 2011/05/21
            )
            if trace: g.trace('***** No colorizer file: %s.py' % language)
            self.rulesetName = rulesetName
            self.language_name = 'unknown-language'
            return False
        self.colorizer.language = language
        self.rulesetName = rulesetName
        self.properties = hasattr(mode,'properties') and mode.properties or {}
        self.keywordsDict = hasattr(mode,'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName,{}) or {}
        self.setKeywords()
        self.attributesDict = hasattr(mode,'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
        # if trace: g.trace(rulesetName,self.attributesDict)
        self.setModeAttributes()
        self.rulesDict = hasattr(mode,'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
        # if trace: g.trace(self.rulesDict)
        self.addLeoRules(self.rulesDict)
        self.defaultColor = 'null'
        self.mode = mode
        self.modes [rulesetName] = self.modeBunch = g.Bunch(
            attributesDict  = self.attributesDict,
            defaultColor    = self.defaultColor,
            keywordsDict    = self.keywordsDict,
            language        = self.colorizer.language,
            mode            = self.mode,
            properties      = self.properties,
            rulesDict       = self.rulesDict,
            rulesetName     = self.rulesetName,
            word_chars      = self.word_chars, # 2011/05/21
        )
        # Do this after 'officially' initing the mode, to limit recursion.
        self.addImportedRules(mode,self.rulesDict,rulesetName)
        self.updateDelimsTables()
        initialDelegate = self.properties.get('initialModeDelegate')
        if initialDelegate:
            if trace: g.trace('initialDelegate',initialDelegate)
            # Replace the original mode by the delegate mode.
            self.init_mode(initialDelegate)
            language2,rulesetName2 = self.nameToRulesetName(initialDelegate)
            self.modes[rulesetName] = self.modes.get(rulesetName2)
            self.language_name = language2  # 2011/05/30
        else:
            self.language_name = language  # 2011/05/30
        return True
#@+node:ekr.20110605121601.18582: *9* nameToRulesetName
def nameToRulesetName (self,name):

    '''Compute language and rulesetName from name, which is either a language or a delegate name.'''

    if not name: return ''

    i = name.find('::')
    if i == -1:
        language = name
        rulesetName = '%s_main' % (language)
    else:
        language = name[:i]
        delegate = name[i+2:]
        rulesetName = self.munge('%s_%s' % (language,delegate))

    # if rulesetName == 'php_main': rulesetName = 'php_php'

    # g.trace(name,language,rulesetName)
    return language,rulesetName
#@+node:ekr.20110605121601.18583: *9* setKeywords
def setKeywords (self):

    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.'''

    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d [key] = 'leokeyword'

    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]

    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))

    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)

    # g.trace(self.colorizer.language,[str(z) for z in chars])

    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
#@+node:ekr.20110605121601.18584: *9* setModeAttributes
def setModeAttributes (self):

    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''

    d = self.attributesDict
    aList = (
        ('default',         'null'),
	    ('digit_re',        ''),
        ('escape',          ''), # New in Leo 4.4.2.
	    ('highlight_digits',True),
	    ('ignore_case',     True),
	    ('no_word_sep',     ''),
    )

    # g.trace(d)

    for key, default in aList:
        val = d.get(key,default)
        if val in ('true','True'): val = True
        if val in ('false','False'): val = False
        setattr(self,key,val)
        # g.trace(key,val)
#@+node:ekr.20110605121601.18585: *9* initModeFromBunch
def initModeFromBunch (self,bunch):

    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor   = bunch.defaultColor
    self.keywordsDict   = bunch.keywordsDict
    self.colorizer.language = bunch.language
    self.mode           = bunch.mode
    self.properties     = bunch.properties
    self.rulesDict      = bunch.rulesDict
    self.rulesetName    = bunch.rulesetName
    self.word_chars     = bunch.word_chars # 2011/05/21
#@+node:ekr.20110605121601.18586: *9* updateDelimsTables
def updateDelimsTables (self):

    '''Update g.app.language_delims_dict if no entry for the language exists.'''

    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')

    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment,startComment,endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment,endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None

    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.colorizer.language):
            d [self.colorizer.language] = delims
            # g.trace(self.colorizer.language,'delims:',repr(delims))
#@+node:ekr.20110605121601.18587: *8* munge
def munge(self,s):

    '''Munge a mode name so that it is a valid python id.'''

    valid = string.ascii_letters + string.digits + '_'

    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
#@+node:ekr.20110605121601.18588: *8* setFontFromConfig
def setFontFromConfig (self):

    c = self.c

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.color_tags_list = []
#@+node:ekr.20110605121601.18589: *7*  Pattern matchers
#@+node:ekr.20110605121601.18590: *8*  About the pattern matchers
@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise. In most cases, these methods colorize all
the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by
                        the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively
                        by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
#@+node:ekr.20110605121601.18591: *8* dump
def dump (self,s):

    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
#@+node:ekr.20110605121601.18592: *8* Leo rule functions
#@+node:ekr.20110605121601.18593: *9* match_at_color
def match_at_color (self,s,i):

    if self.trace_leo_matches: g.trace()

    seq = '@color'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        self.colorizer.flag = True # Enable coloring.
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,'leokeyword')
        self.clearState()
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18594: *9* match_at_language
def match_at_language (self,s,i):

    trace = (False or self.trace_leo_matches) and not g.unitTesting
    if trace: g.trace(i,repr(s))

    seq = '@language'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        j = i + len(seq)
        j = g.skip_ws(s,j)
        k = g.skip_c_id(s,j)
        name = s[j:k]
        ok = self.init_mode(name)
        if trace: g.trace(ok,name)
        if ok:
            self.colorRangeWithTag(s,i,k,'leokeyword')
        self.clearState()
        return k - i
    else:
        return 0
#@+node:ekr.20110605121601.18595: *9* match_at_nocolor & restarter
def match_at_nocolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i == 0 and not g.match(s,i,'@nocolor-') and g.match_word(s,i,'@nocolor'):
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20110605121601.18596: *10* restartNoColor
def restartNoColor (self,s):

    if self.trace_leo_matches: g.trace(repr(s))

    if g.match_word(s,0,'@color'):
        self.clearState()
    else:
        self.setRestart(self.restartNoColor)

    return len(s) # Always match everything.
#@+node:ekr.20110605121601.18597: *9* match_at_killcolor & restarter
def match_at_killcolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@killcolor'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartKillColor)
        return len(s) # Match everything.
    else:
        return 0

#@+node:ekr.20110605121601.18598: *10* restartKillColor
def restartKillColor(self,s):

    self.setRestart(self.restartKillColor)
    return len(s)+1
#@+node:ekr.20110605121601.18599: *9* match_at_nocolor_node & restarter
def match_at_nocolor_node (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@nocolor-node'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartNoColorNode)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20110605121601.18600: *10* restartNoColorNode
def restartNoColorNode(self,s):

    self.setRestart(self.restartNoColorNode)
    return len(s)+1
#@+node:ekr.20110605121601.18601: *9* match_blanks
def match_blanks (self,s,i):

    if not self.showInvisibles:
        return 0

    j = i ; n = len(s)

    while j < n and s[j] == ' ':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'blank')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18602: *9* match_doc_part & restarter
def match_doc_part (self,s,i):

    # New in Leo 4.5: only matches at start of line.
    if i != 0:
        return 0
    elif g.match_word(s,i,'@doc'):
        j = i + 4
    elif g.match(s,i,'@') and (i+1 >= len(s) or s[i+1] in (' ','\t','\n')):
        j = i + 1
    else:
        return 0

    self.colorRangeWithTag(s,i,j,'leokeyword')
    self.colorRangeWithTag(s,j,len(s),'docpart')
    self.setRestart(self.restartDocPart)

    return len(s)
#@+node:ekr.20110605121601.18603: *10* restartDocPart
def restartDocPart (self,s):

    for tag in ('@c','@code'):
        if g.match_word(s,0,tag):
            j = len(tag)
            self.colorRangeWithTag(s,0,j,'leokeyword') # 'docpart')
            self.clearState()
            return j
    else:
        self.setRestart(self.restartDocPart)
        self.colorRangeWithTag(s,0,len(s),'docpart')

        return len(s)
#@+node:ekr.20110605121601.18604: *9* match_leo_keywords
def match_leo_keywords(self,s,i):

    '''Succeed if s[i:] is a Leo keyword.'''

    # g.trace(i,g.get_line(s,i))

    self.totalLeoKeywordsCalls += 1

    if s[i] != '@':
        return 0

    # fail if something besides whitespace precedes the word on the line.
    i2 = i-1
    while i2 >= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ','\t'):
            i2 -= 1
        else:
            # g.trace('not a word 1',repr(ch))
            return 0

    # Get the word as quickly as possible.
    j = i+1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i+1:j] # entries in leoKeywordsDict do not start with '@'.

    if j < len(s) and s[j] not in (' ','\t','\n'):
        # g.trace('not a word 2',repr(word))
        return 0 # Fail, but allow a rescan, as in objective_c.

    if self.leoKeywordsDict.get(word):
        kind = 'leokeyword'
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j-i+1 # Bug fix: skip the last character.
        self.trace_match(kind,s,i,j)
        # g.trace('*** match',repr(s))
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s,i,j,kind)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            # g.trace('found',word)
            return j-i
        else:
            # g.trace('fail',repr(word),repr(self.word_chars))
            return -(j-i+1) # An important optimization.
#@+node:ekr.20110605121601.18605: *9* match_section_ref
def match_section_ref (self,s,i):

    if self.trace_leo_matches: g.trace()
    c = self.c ; p = c.currentPosition()
    w = self.w

    if not g.match(s,i,'<<'):
        return 0
    k = g.find_on_line(s,i+2,'>>')
    if k is not None:
        j = k + 2
        self.colorRangeWithTag(s,i,i+2,'namebrackets')
        ref = g.findReference(c,s[i:j],p)
        if ref:
            if self.use_hyperlinks:
                << set the hyperlink >>
            else:
                self.colorRangeWithTag(s,i+2,k,'link')
        else:
            self.colorRangeWithTag(s,i+2,k,'name')
        self.colorRangeWithTag(s,k,j,'namebrackets')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18606: *10* << set the hyperlink >>
# Set the bindings to vnode callbacks.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
ref.tagName = tagName
#@+node:ekr.20110605121601.18607: *9* match_tabs
def match_tabs (self,s,i):

    if not self.showInvisibles:
        return 0

    if self.trace_leo_matches: g.trace()

    j = i ; n = len(s)

    while j < n and s[j] == '\t':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'tab')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18608: *9* match_url_any/f/h  (new)
url_regex_f = re.compile(r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex   = re.compile(r"""(file|ftp|http|https)://[^\s'"]+[\w=/]""")

def match_any_url(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):

def match_url_f(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_f)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
    
def match_url_h(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_h)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
#@+node:ekr.20110605121601.18609: *8* match_compiled_regexp (new)
def match_compiled_regexp (self,s,i,kind,regexp,delegate=''):

    '''Succeed if the compiled regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    # if at_line_start and i != 0 and s[i-1] != '\n': return 0
    # if at_whitespace_end and i != g.skip_ws(s,0): return 0
    # if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_compiled_regexp_helper(s,i,regexp)
    if n > 0:
        j = i + n
        assert (j-i == n)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18610: *9* match_compiled_regexp_helper
def match_compiled_regexp_helper (self,s,i,regex):
    
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = regex.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    start, end = mo.start(), mo.end()
    if start != i:
        return 0
    # if trace:
        # g.trace('pattern',pattern)
        # g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
        # g.trace('groups',mo.groups())
    return end - start
#@+node:ekr.20110605121601.18611: *8* match_eol_span
def match_eol_span (self,s,i,
    kind=None,seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if seq matches s[i:]'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        return 0

    if g.match(s,i,seq):
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j # (was j-1) With a delegate, this could clear state.
    else:
        return 0
#@+node:ekr.20110605121601.18612: *8* match_eol_span_regexp
def match_eol_span_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if the regular expression regex matches s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,regexp)
    if n > 0:
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18613: *8* match_everything
# def match_everything (self,s,i,kind=None,delegate='',exclude_match=False):

    # '''Match the entire rest of the string.'''

    # j = len(s)
    # self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    # return j
#@+node:ekr.20110605121601.18614: *8* match_keywords
# This is a time-critical method.
def match_keywords (self,s,i):

    '''Succeed if s[i:] is a keyword.'''

    # trace = False
    self.totalKeywordsCalls += 1

    # Important.  Return -len(word) for failure greatly reduces
    # the number of times this method is called.

    # We must be at the start of a word.
    if i > 0 and s[i-1] in self.word_chars:
        # if trace: g.trace('not at word start',s[i-1])
        return 0

    # Get the word as quickly as possible.
    j = i ; n = len(s) ; chars = self.word_chars
    while j < n and s[j] in chars:
        j += 1

    word = s[i:j]
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j - i
        # if trace: g.trace('success',word,kind,j-i)
        self.trace_match(kind,s,i,j)
        return result
    else:
        # if trace: g.trace('fail',word,kind)
        return -len(word) # An important new optimization.
#@+node:ekr.20110605121601.18615: *8* match_line
def match_line (self,s,i,kind=None,delegate='',exclude_match=False):

    '''Match the rest of the line.'''

    j = g.skip_to_end_of_line(s,i)

    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    return j-i
#@+node:ekr.20110605121601.18616: *8* match_mark_following & getNextToken
def match_mark_following (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    trace = (True or self.verbose) and not g.unitTesting
    if not self.allow_mark_prev: return 0

    # if trace: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 < len(s) and s[i+len(pattern)] in self.word_chars:
        return 0 # 7/5/2008

    if g.match(s,i,pattern):
        j = i + len(pattern)
        # self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s,j)
        # 2011/05/31: Do not match *anything* unless there is a token following.
        if k > j:
            self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,k,kind,exclude_match=False)
            j = k
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            return j - i
        else:
            return 0
    else:
        return 0
#@+node:ekr.20110605121601.18617: *9* getNextToken
def getNextToken (self,s,i):

    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''
    
    # 2011/05/31: Might we extend the concept of token?
    # If s[i] is not a word char, should we return just it?

    while i < len(s) and s[i] in self.word_chars:
        i += 1

    # 2011/05/31: was i+1
    return min(len(s),i)
#@+node:ekr.20110605121601.18618: *8* match_mark_previous
def match_mark_previous (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''

    # This match was causing most of the syntax-color problems.
    return 0 # 2009/6/23
#@+node:ekr.20110605121601.18619: *8* match_regexp_helper
def match_regexp_helper (self,s,i,pattern):

    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    trace = False and not g.unitTesting
    if trace: g.trace('%-10s %-20s %s' % (
        self.colorizer.language,pattern,s)) # g.callers(1)

    try:
        flags = re.MULTILINE
        if self.ignore_case: flags|= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        # Do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = re_obj.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        if trace:
            g.trace('pattern',pattern)
            g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
            g.trace('groups',mo.groups())
        return end - start
#@+node:ekr.20110605121601.18620: *8* match_seq
def match_seq (self,s,i,
    kind='',seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if s[:] mathces seq.'''

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:  # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s,i,seq):
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
    else:
        j = i
    return j - i
#@+node:ekr.20110605121601.18621: *8* match_seq_regexp
def match_seq_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if the regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_regexp_helper(s,i,regexp)
    j = i + n
    assert (j-i == n)
    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    self.prev = (i,j,kind)
    self.trace_match(kind,s,i,j)
    return j - i
#@+node:ekr.20110605121601.18622: *8* match_span & helper & restarter
def match_span (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False,no_word_break=False):

    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''

    trace = False and not g.unitTesting
    if i >= len(s): return 0

    # g.trace(begin,end,no_escape,no_line_break,no_word_break)

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:
        j = i
    elif at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        j = i
    elif not g.match(s,i,begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s,i+len(begin),end,
            no_escape,no_line_break,no_word_break=no_word_break)
        # g.trace('** helper returns',j,len(s))
        if j == -1:
            j = i # A real failure.
        else:
            # A match
            i2 = i + len(begin) ; j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(s,i,i2,kind,delegate=None,    exclude_match=exclude_match)
                self.colorRangeWithTag(s,i2,j,kind,delegate=delegate,exclude_match=exclude_match)
                self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
            j = j2
            self.prev = (i,j,kind)

    self.trace_match(kind,s,i,j)

    if j > len(s):
        j = len(s) + 1
        def boundRestartMatchSpan(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Continuing',kind,i,j,len(s))
    elif j != i:
        if trace: g.trace('***Ending',kind,i,j,s[i:j])
        self.clearState()

    return j - i # Correct, whatever j is.
#@+node:ekr.20110605121601.18623: *9* match_span_helper
def match_span_helper (self,s,i,pattern,no_escape,no_line_break,no_word_break):

    '''Return n >= 0 if s[i] ends with a non-escaped 'end' string.'''

    esc = self.escape

    while 1:
        j = s.find(pattern,i)
        # g.trace(no_line_break,j,len(s))
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s)+1
        elif no_word_break and j > 0 and s[j-1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i:j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == esc:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # Continue searching past the escaped pattern string.
                i = j + len(pattern) # Bug fix: 7/25/07.
                # g.trace('escapes',escapes,repr(s[i:]))
            else:
                return j
        else:
            return j
#@+node:ekr.20110605121601.18624: *9* restart_match_span
def restart_match_span (self,s,
    delegate,end,exclude_match,kind,
    no_escape,no_line_break,no_word_break):

    '''Remain in this state until 'end' is seen.'''

    trace = False and not g.unitTesting

    i = 0
    j = self.match_span_helper(s,i,end,no_escape,no_line_break,no_word_break)
    if j == -1:
        j2 = len(s)+1
    elif j > len(s):
        j2 = j
    else:
        j2 = j + len(end)

    if delegate:
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
    else: # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
    j = j2

    self.trace_match(kind,s,i,j)

    if j > len(s):
        def boundRestartMatchSpan(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Re-continuing',i,j,len(s),s,g.callers(5))
    else:
        if trace: g.trace('***ending',i,j,len(s),s)
        self.clearState()

    return j # Return the new i, *not* the length of the match.
#@+node:ekr.20110605121601.18625: *8* match_span_regexp
def match_span_regexp (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False, no_word_break=False,
):

    '''Succeed if s[i:] starts with 'begin' (a regular expression) and contains a following 'end'.'''

    if self.verbose: g.trace('begin',repr(begin),'end',repr(end),self.dump(s[i:]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n > 0:
        j = i + n
        j2 = s.find(end,j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == self.escape:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s,i,j,kind, delegate=None,     exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,i2,kind, delegate=delegate,exclude_match=False)
            self.colorRangeWithTag(s,i2,j2,kind,delegate=None,    exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j2)
        return j2 - i
    else: return 0
#@+node:ekr.20110605121601.18626: *8* match_word_and_regexp
def match_word_and_regexp (self,s,i,
    kind1='',word='',
    kind2='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    if not self.allow_mark_prev: return 0

    if (False or self.verbose): g.trace(i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0
    if at_word_start and i + len(word) + 1 < len(s) and s[i+len(word)] in self.word_chars:
        j = i

    if not g.match(s,i,word):
        return 0

    j = i + len(word)
    n = self.match_regexp_helper(s,j,pattern)
    if n == 0:
        return 0
    self.colorRangeWithTag(s,i,j,kind1,exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s,j,k,kind2,exclude_match=False)    
    self.prev = (j,k,kind2)
    self.trace_match(kind1,s,i,j)
    self.trace_match(kind2,s,j,k)
    return k - i
#@+node:ekr.20110605121601.18627: *8* skip_line
def skip_line (self,s,i):

    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i < len(s):
            j = g.skip_line(s,i)
            if not g.match(s,j-n,escape):
                return j
            # g.trace('escape',s[i:j])
            i = j
        return i
    else:
        return g.skip_line(s,i)
            # Include the newline so we don't get a flash at the end of the line.
#@+node:ekr.20110605121601.18628: *8* trace_match
def trace_match(self,kind,s,i,j):

    if j != i and self.trace_match_flag:
        g.trace(kind,i,j,g.callers(2),self.dump(s[i:j]))
#@+node:ekr.20110605121601.18629: *7*  State methods
#@+node:ekr.20110605121601.18630: *8* clearState
def clearState (self):

    self.setState(-1)
#@+node:ekr.20110605121601.18631: *8* computeState
def computeState (self,f,keys):

    '''Compute the state name associated with f and all the keys.

    Return a unique int n representing that state.'''

    # Abbreviate arg names.
    d = {
        'delegate':'del:',
        'end':'end',
        'at_line_start':'line-start',
        'at_whitespace_end':'ws-end',
        'exclude_match':'exc-match',
        'no_escape':'no-esc',
        'no_line_break':'no-brk',
        'no_word_break':'no-word-brk',
    }
    result = [
        f.__name__,
        self.colorizer.language,
        self.rulesetName]
    for key in keys:
        keyVal = keys.get(key)
        val = d.get(key)
        if val is None:
            val = keys.get(key)
            result.append('%s=%s' % (key,val))
        elif keyVal is True:
            result.append('%s' % val)
        elif keyVal is False:
            pass
        elif keyVal not in (None,''):
            result.append('%s=%s' % (key,keyVal))
    state = ';'.join(result)

    n = self.stateNameToStateNumber(f,state)
    return n
#@+node:ekr.20110605121601.18632: *8* currentState and prevState
def currentState(self):

    return self.highlighter.currentBlockState()

def prevState(self):

    return self.highlighter.previousBlockState()
#@+node:ekr.20110605121601.18633: *8* setRestart
def setRestart (self,f,**keys):

    n = self.computeState(f,keys)
    self.setState(n)
#@+node:ekr.20110605121601.18634: *8* setState
def setState (self,n):

    trace = False and not g.unitTesting

    self.highlighter.setCurrentBlockState(n)

    if trace:
        stateName = self.showState(n)
        g.trace(stateName,g.callers(4))
#@+node:ekr.20110605121601.18635: *8* showState & showCurrentState
def showState (self,n):

    if n == -1: 
        return 'default-state'
    else:
        return self.stateDict.get(n,'<no state>')

def showCurrentState(self):

    n = self.currentState()
    return self.showState(n)

def showPrevState(self):

    n = self.prevState()
    return self.showState(n)
#@+node:ekr.20110605121601.18636: *8* stateNameToStateNumber
def stateNameToStateNumber (self,f,stateName):

    # stateDict:     Keys are state numbers, values state names.
    # stateNameDict: Keys are state names, values are state numbers.
    # restartDict:   Keys are state numbers, values are restart functions

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.stateNameDict[stateName] = n
        self.stateDict[n] = stateName
        self.restartDict[n] = f
        self.nextState += 1
        # g.trace('========',n,stateName)

    return n
#@+node:ekr.20110605121601.18637: *7* colorRangeWithTag
def colorRangeWithTag (self,s,i,j,tag,delegate='',exclude_match=False):

    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''

    trace = False and not g.unitTesting
        # A superb trace: enable this first to see what gets colored.

    # Pattern matcher may set the .flag ivar.
    if self.colorizer.killColorFlag or not self.colorizer.flag:
        if trace: g.trace('disabled')
        return

    if delegate:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (delegate,tag)),i,j,s2,g.callers(2)))
        # self.setTag(tag,s,i,j) # 2011/05/31: Do the initial color.
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 <= i < j and i < len(s):
            progress = i
            assert j >= 0,j
            for f in self.rulesDict.get(s[i],[]):
                n = f(self,s,i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n > 0:
                    # if trace: g.trace('delegate',delegate,i,n,f.__name__,repr(s[i:i+n]))
                    i += n ; break
            else:
                # New in Leo 4.6: Use the default chars for everything else.
                # New in Leo 4.8 devel: use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                # g.trace(default_tag)
                self.setTag(default_tag or tag,s,i,i+1)
                i += 1
            assert i > progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (self.language_name,tag)),i,j,s2,g.callers(2)))
        self.setTag(tag,s,i,j)
        
    if tag != 'url':
        # Allow URL's *everywhere*.
        j = min(j,len(s))
        while i < j:
            if s[i].lower() in 'fh': # file|ftp|http|https
                n = self.match_any_url(s,i)
                i += max(1,n)
            else:
                i += 1
#@+node:ekr.20110605121601.18638: *7* mainLoop & restart
def mainLoop(self,n,s):

    '''Colorize a *single* line s, starting in state n.'''

    trace = False and not g.unitTesting
    traceMatch = True
    traceState = True
    verbose = False
    
    if trace:
        if traceState:
            g.trace('%-30s' % ('** start: %s' % self.showState(n)),repr(s))
        else:
            g.trace(self.language_name,repr(s))
                # Called from recolor.

    i = 0
    if n > -1:
        i = self.restart(n,s,trace and traceMatch)
    if i == 0:
        self.setState(self.prevState())
        
    if False and trace:
        aList = self.rulesDict.get('<')
        for f in aList:
            g.trace(f.__name__)
        
        
    while i < len(s):
        progress = i
        functions = self.rulesDict.get(s[i],[])
        for f in functions:
            n = f(self,s,i)
            if n is None:
                g.trace('Can not happen: n is None',repr(f))
                break
            elif n > 0: # Success.
                if trace and traceMatch and f.__name__!='match_blanks':
                    g.trace('%-30s' % ('   match: %s' % (f.__name__,)),
                        repr(s[i:i+n]))
                # The match has already been colored.
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                if trace and traceMatch and verbose:
                    g.trace('fail: %-30s %s' % (
                        f.__name__,repr(s[i:i+n])))
                i += -n
                break # Stop searching the functions.
            else: # Fail. Try the next function.
                pass # Do not break or change i!
        else:
            i += 1
        assert i > progress

    # Don't even *think* about clearing state here.
    # We remain in the starting state unless a match happens.
    if trace and traceState:
        g.trace('%-30s' % ('** end:   %s' % self.showCurrentState()),repr(s))
#@+node:ekr.20110605121601.18639: *8* restart
def restart (self,n,s,traceMatch):

    f = self.restartDict.get(n)
    if f:
        i = f(s)
        fname = f.__name__
        if traceMatch:
            if i > 0:
                g.trace('** restart match',fname,s[:i])
            else:
                g.trace('** restart fail',fname,s)
    else:
        g.trace('**** no restart f')
        i = 0

    return i
#@+node:ekr.20110605121601.18640: *7* recolor
def recolor (self,s):

    '''Recolor a *single* line, s.'''

    trace = False and not g.unitTesting
    callers = False ; line = True ; state = True

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    if self.colorizer.changingText:
        return
    if not self.colorizer.flag:
        return

    # Get the previous state.
    n = self.prevState() # The state at the end of the previous line.
    if trace:
        if line and state:
            g.trace('%2s %s %s' % (n,self.showState(n),repr(s)))
        elif line:
            g.trace('%2s %s' % (n,repr(s)))
        if callers:
            # Called from colorize:rehightlight,highlightBlock
            g.trace(g.callers())

    if s.strip() or self.showInvisibles:
        self.mainLoop(n,s)
    else:
        self.setState(n) # Required
#@+node:ekr.20110605121601.18641: *7* setTag
def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting

    if i == j:
        if trace: g.trace('empty range')
        return

    w = self.w # A leoQTextEditWidget
    tag = tag.lower() # 2011/10/28
    colorName = w.configDict.get(tag)

    # Munge the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return

    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName,g.callers())

    underline = w.configUnderlineDict.get(tag)

    format = QtGui.QTextCharFormat()

    font = self.fonts.get(tag)
    if font:
        format.setFont(font)

    if trace:
        self.tagCount += 1
        g.trace(
            '%3s %3s %3s %9s %7s' % (i,j,len(s),font and id(font) or '<no font>',colorName),
            '%-10s %-25s' % (tag,s[i:j]),g.callers(2))

    if tag in ('blank','tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setFontUnderline(True)
    else:
        format.setForeground(color)

    self.highlighter.setFormat (i,j-i,format)

#@+node:ekr.20110605121601.18556: *5* scanColorDirectives (leoQtColorizer) & helper
def scanColorDirectives(self,p):
    
    '''Set self.language based on the directives in p's tree.'''

    trace = False and not g.unitTesting
    c = self.c
    if c == None: return None # self.c may be None for testing.
    
    root = p.copy()
    self.language = None
    self.rootMode = None # None, "code" or "doc"

    for p in root.self_and_parents():
        theDict = g.get_directives_dict(p)
        # if trace: g.trace(p.h,theDict)
        << Test for @language >>
        << Test for @root, @root-doc or @root-code >>
        
    # 2011/05/28: If no language, get the language from any @<file> node.
    if self.language:
        if trace: g.trace('found @language %s' % (self.language))
        return self.language
        
    #  Attempt to get the language from the nearest enclosing @<file> node.
    self.language = g.getLanguageFromAncestorAtFileNode(root)

    if not self.language:
        if trace: g.trace('using default',c.target_language)
        self.language = c.target_language

    return self.language # For use by external routines.
#@+node:ekr.20110605121601.18557: *6* << Test for @language >>
if 'language' in theDict:
    s = theDict["language"]
    i = g.skip_ws(s,0)
    j = g.skip_c_id(s,i)
    aList = self.findLanguageDirectives(p)
    # In the root node, we use the first (valid) @language directive,
    # no matter how many @language directives the root node contains.
    # In ancestor nodes, only unambiguous @language directives
    # set self.language.
    if p == root or len(aList) == 1:
        self.languageList = aList
        self.language = aList and aList[0] or []
        break
#@+node:ekr.20110605121601.18558: *6* << Test for @root, @root-doc or @root-code >>
if 'root' in theDict and not self.rootMode:

    s = theDict["root"]
    if g.match_word(s,0,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,0,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@+node:ekr.20110605121601.18559: *6* findLanguageDirectives
def findLanguageDirectives (self,p):

    '''Scan p's body text for *valid* @language directives.

    Return a list of languages.'''
    
    # Speed not very important: called only for nodes containing @language directives.
    trace = False and not g.unitTesting
    aList = []
    for s in g.splitLines(p.b):
        if g.match_word(s,0,'@language'):
            i = len('@language')
            i = g.skip_ws(s,i)
            j = g.skip_id(s,i)
            if j > i:
                word = s[i:j]
                if self.isValidLanguage(word):
                    aList.append(word)
                else:
                    if trace:g.trace('invalid',word)

    if trace: g.trace(aList)
    return aList
#@+node:ekr.20110605121601.18560: *6* isValidLanguage
def isValidLanguage (self,language):
    
    fn = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
    return g.os_path_exists(fn)
#@+node:ekr.20111114085925.9932: *4* Why does the unittest/output folder contain empty files?
#@+node:ekr.20031218072017.1462: *5* ic.exportHeadlines
def exportHeadlines (self,fileName):

    c = self.c ; p = c.p
    nl = g.u(self.output_newline)
    
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    try:
        theFile = open(fileName,'w')
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return
    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel,useVerticalBar=True)
        s = head + nl
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
    theFile.close()
#@+node:ekr.20051104075904.78: *5* makeImportExportSuite
def makeImportExportSuite(c,parentHeadline,doImport):

    """Create an Import/Export test for every descendant of testParentHeadline.."""

    u = testUtils(c)
    parent = u.findNodeAnywhere(parentHeadline)
    assert parent,'node not found: %s' % (parentHeadline)
    temp = u.findNodeInTree(parent,"tempNode")
    assert temp,'node not found: tempNode'

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in parent.children():
        if p != temp:
            # 2009/10/02: avoid copy arg to iter
            p2 = p.copy()
            dialog = u.findNodeInTree(p2,"dialog")
            assert(dialog)
            test = importExportTestCase(c,p2,dialog,temp,doImport)
            suite.addTest(test)

    return suite
#@+node:ekr.20051104075904.79: *5* class importExportTestCase
class importExportTestCase(unittest.TestCase):

    """Data-driven unit tests for Leo's edit body commands."""

    @others
#@+node:ekr.20051104075904.80: *6* __init__
def __init__ (self,c,p,dialog,temp_p,doImport):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.dialog = dialog
    self.p = p.copy()
    self.temp_p = temp_p.copy()

    self.gui = None
    self.oldGui = None
    self.wasChanged = c.changed
    self.fileName = ""
    self.doImport = doImport

    self.old_p = c.p
#@+node:ekr.20051104075904.81: *6*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20051104075904.82: *6* importExport
def importExport (self):

    c = self.c ; p = self.p

    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    commandName = p.h
    command = getattr(c,commandName) # Will fail if command does not exist.
    command(event=None)

    failedMethod = g.app.unitTestDict.get("fail")
    self.failIf(failedMethod,failedMethod)
#@+node:ekr.20051104075904.83: *6* runTest
def runTest(self):

    # """Import Export Test Case"""

    self.importExport()
#@+node:ekr.20051104075904.84: *6* setUp
def setUp(self):

    trace = False
    c = self.c ; temp_p = self.temp_p
    d = self.dialog

    temp_p.setBodyString('')

    # Create a node under temp_p.
    child = temp_p.insertAsLastChild()
    assert(child)
    c.setHeadString(child,"import/export test: " + self.p.h)
    c.selectPosition(child)

    assert(d)
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    fileName = lines[1]

    # Replace '\\' by os.path.sep in fileName
    try:
        # os.path.sep does not exist in Python 2.2.x.
        sep = os.path.sep
        fileName = fileName.replace('\\',sep)
    except AttributeError:
        fileName = g.os_path_normpath(fileName)

    self.fileName = fileName = g.os_path_finalize_join(g.app.loadDir,"..",fileName)
    if trace: g.trace('(importExportTestCase',fileName)

    if self.doImport:
        theDict = {name: [fileName]}
    else:
        theDict = {name: fileName}

    self.oldGui = g.app.gui
    self.gui = leoGui.unitTestGui(theDict,trace=False)
#@+node:ekr.20051104075904.85: *6* shortDescription
def shortDescription (self):

    try:
        return "ImportExportTestCase: %s %s" % (self.p.h,self.fileName)
    except Exception:
        return "ImportExportTestCase"
#@+node:ekr.20051104075904.86: *6* tearDown
def tearDown (self):

    c = self.c ; temp_p = self.temp_p

    if self.gui:
        self.gui.destroySelf()
        self.gui = None

    temp_p.setBodyString("")
    temp_p.clearDirty()

    if not self.wasChanged:
        c.setChanged (False)

    if 1: # Delete all children of temp node.
        while temp_p.firstChild():
            temp_p.firstChild().doDelete()

    g.app.gui = self.oldGui
    c.selectPosition(self.old_p)
#@+node:ekr.20031218072017.2850: *5* c.exportHeadlines
def exportHeadlines (self,event=None):

    '''Export all headlines to an external file.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.exportHeadlines(fileName)
#@+node:ekr.20110730093802.15134: *3* Bugs
#@+node:ekr.20110621074459.14904: *4* Fixed ancient hanger in paste-retaining-clones
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/800157

In a new file containing only a "NewHeadline" and that being selected, execute:

copy-node
insert-child
<<enter>>
undo
paste-retaining-clones

Leo's UI freezes and loops forever with 100% CPU.

Note: If one does not undo, Leo prints "Invalid paste: nodes may not descend
from themselves". I guess the undo circumvents such a check. However, that
should not be the case, as paste-retaining-clones inserts the clones _after_ and
not as children of the selected node "NewHeadline".

I guess that the undo forgets to set the selection back to "NewHeadline", so
that Leo tries to insert the clones after the undone child node - therefore as
child of "NewHeadline".

====================

EKR: only getLeoOutlineFromClipboar calls checkPaste.
#@+node:ekr.20110705101348.14898: *4* Fixed bug in p.setAllAncestorAtFileNodesDirty
@nocolor-node


The code that marks descendant @<file> nodes dirty now tests
p2.isAnyAtFileNode().  The old code tested p2.isAtThinFileNode().
#@+node:ekr.20110717110529.14970: *4* Removed timer hack from double-click code
#@+node:ekr.20110726130504.15081: *4* Fixed double-click problem
@nocolor-node

CAUTION: new double click handling code

http://groups.google.com/group/leo-editor/browse_thread/thread/dbd63b9b38911906

The problem isn't single/double, but double click not stopping the
event processing.  It has the correct form:

if g.doHook('doubleClick1') is None:
   do-normal-double-click-stuff
g.doHook('doubleClick2')

but I think some other route through the code, or additional processing
of the event means that even thought the handler registered on
doubleClick1 returns non-None, the node goes into headline edit mode,
with focus.

This is bad, because the doubleClick1 on an @url node attempts to
select and raise a different commander (tab), so now you're looking at
one commander but focus is in another, so what you type trashes the
headline in the original commander.

The timer shouldn't be needed - a 'doubleClick1' hook which returns
non-None should stop the headline going into edit mode.  If you can
make that be the case, all is well.
#@+node:ekr.20110728112148.6735: *4* Fixed url focus issues
#@+node:ekr.20110728093358.6702: *4* Fixed p1 > p2
#@+node:ekr.20110730091449.15132: *4* Fixed cacher problem
@nocolor-node

- leoCommands.__init__ now sets self.db = {}
- initGlobalDB now returns {} instead of None if there is no cacher.
#@+node:ekr.20110908155830.6875: *4* Fixed encoding problem with @shadow
@nocolor-node

Important notes:
    
readOpenFile reads the private shadow file, detecting the encoding.
#@+node:ekr.20110917130105.6873: *4* Fixed a w.see botch.
@nocolor-node

The call to w.see(ins+5) in rp_reformat created a big problem.

Replacing this with w.see(ins) is much better.
#@+node:ekr.20111003135314.15480: *4* Fixed a major DnD bug
#@+node:ekr.20111008073427.15594: *4* Fixed macro crash
# A misspelling:
    
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 409, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 1967, in fullCommand
    c.macroCommands.startrecordingMacro(event)
AttributeError: macroCommandsClass instance has no attribute 'startrecordingMacro'
#@+node:ekr.20111009162434.7206: *4* Regularized slashes in @edit/@file
@nocolor-node

Examples:
    
    @edit C:/leo.repo/ipython-0.12/IPython/frontend/qt/console/pygments_highlighter.py
        # The filename comes from g.app.gui.runOpenFileDialog
    
    @file C:\leo.repo\ipython-0.12\IPython\frontend\qt\console\pygments_highlighter.py
        # Created by import.
        
The problem was the call to g.os_path_normpath in importDerived files:
    it converts slashes to backslashes on windows (!!)
#@+node:ekr.20111010082822.15544: *4* Made sure Leo's write code auto-detects file extension
@nocolor-node

- Added getLanguageFromAncestorAtFileNode.

- Revised code in at.scanAllDirectives & leoQtColorizer.scanColorDirectives.
#@+node:ekr.20111010154337.15599: *4* Fixed k.setLabelRed
#@+node:ekr.20111012162536.9380: *4* Fixed cycle-editor-focus bug
qtBody can use the leoBody code.
#@+node:ekr.20111012093116.9386: *4* Fix the body-text scrolling reversion
@nocolor-node

- Marked with ### 2011/09/30

- Alt-x resets the scrollbar position!
    The focus gets pulled away, but the scrollbar position does not get saved.
#@+node:ekr.20111014074810.15650: *4* Fixed recent createFrame crash
#@+node:ekr.20111015150822.9346: *4* Fixed Py3k crash in quicksearch.py
@nocolor-node
 
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 187, in returnPressed
    self.scon.doSearch(t)
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 289, in doSearch
    self.addBodyMatches(bm)
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 257, in addBodyMatches
    self.its[it] = (p, None)
TypeError: unhashable type: 'QListWidgetItem'
#@+node:ekr.20111015150822.13125: *4* Removed all references to scrolledmessage plugin
@nocolor-node

The scrolledmessage plugin no longer exists.

The runScrolledMessageDialog *does* still exist, but it now uses the
viewrendered plugin.
#@+node:ekr.20111016210000.15951: *4* Support @ignore when installing @command/@button nodes
@nocolor-node

Changed doButtons and doCommands kind handlers.

This allows us to put example nodes in leoSettings.leo.
#@+node:ekr.20111020113237.15895: *4* Fixed crasher in runScrolledMessageDialog
#@+node:ekr.20111017132257.15885: *4* Macro expansion now forces a full recolor
@nocolor-node

Could this be done as part of abbreviation expansion?
#@+node:ekr.20111021105253.9479: *4* Fixed serious atFile read bug
@nocolor-node

Changed at.readEndOthers and at.readEndRef so that they
always set at.inCode = True
#@+node:ekr.20111021105253.9480: *4* Fixed unicode bugs with @shadow
@nocolor-node

Fixed several encoding problems related to this thread: @shadow - @encoding windows-1250 - problem
http://groups.google.com/group/leo-editor/browse_thread/thread/a4ba80559447218a/9a37a4ed6c44d452

There were several real problems fixed.  The summary: @encoding directives were always required.

In detail:

1. at.initWriteIvars now checks for a Python # -*- coding: line.
   If present, it must be the very first line.
   If present, it will override any @encoding directives.

2. g.getPythonEncodingFromString now can deal with either of the following lines:

    @first # -*- coding: utf-8 -*-
    # -*- coding: utf-8 -*-

That is, g.getPythonEncodingFromString can strip the leading @first.

3. g.readlineForceUnixNewline and x.propagate_changes now catch UnicodeDecodeError.
   This is very important: previously decoding errors crashed Leo!.

All unit tests pass with both Python 2.x and 3.x.

#@+node:ekr.20111024091133.16699: *4* Recompute width of hard tabs depending on @tabwidth
@nocolor-node

Added configure_hard_tab_width method.
#@+node:ekr.20111024170505.16464: *4* Applied patch for Bug 800311: Undo: Word granularity should recognize cursor movements
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/800311

Having set undo to word granularity, I often change something, move to a
different line and continue editing there. When I want to undo my last change,
Leo also undoes the change in the other place, as word granularity currently
only recognises a new undo step when a new word is started, no matter if we
moved to a completely different position first.

The attached patch fixes the issue by remembering the previous cursor position.

Something else about the undo code:

- oldSel and newSel are never set to None in the constructor -> it's quite hard
  to know they are there without reading the whole code

- It would be cool if there could be some more comments in that section; e.g. to
  tell that oldSel and newSel from which old_row, old_col, new_row and new_col
  actually mean: old = "the position right before doing the change" and new =
  "the position right after doing the change" and that old != "the position
  after the change before" (which I added as prevSel) - it took me ages to
  discover this

- There are duplicate "The new and old characters are not contiguous." checks.
  Are they different/necessary?

- The "We have just inserted a line." section is not only entered on a new line
  (see other attached patch)
#@+node:ekr.20111024170505.16460: *4* Applied patch for Bug 800312: Collapsing node moves should be optional
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/800312
#@+node:ekr.20111025062953.16480: *4* Fixed Bug 880975: Binding Meta and print-bindings
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/880975

Bug: The Meta+Ctrl section [of print-bindings] is always empty and this makes it
misleading.

Fix: the prefix list in k.printBindings must be sure that if two prefixes have a
common leading part the longer prefix appears first in the lists.
#@+node:ekr.20111026091322.16493: *4* Fixed bug 823601: cascade-windows fails
exception executing command
Traceback (most recent call last):
  File "/home/bob/bzrWork/pluginPath/leo/core/leoCommands.py", line 408, in doCommand
    val = command(event)
  File "/home/bob/bzrWork/pluginPath/leo/plugins/qtGui.py", line 4965, in cascade
    w.setGeometry(x,y,r.width(),r.height())
TypeError: setGeometry() takes exactly 2 arguments (5 given)
#@+node:ekr.20111026115337.16527: *4* Generalized stylesheet handling
# A temporary fix while waiting for Terry's css work.
#@+node:ekr.20111026115337.16529: *5* Notes
@language rest

Here's how it works:  code that wants to set a particular part of a
widget's style sheet calls::

   g.app.gui.update_style_sheet(w,key,value)

where w is the widget whose stylesheet is to be changed, key is unique
to the method (or group of methods), and value is the new version of
the stylesheet **for the particular key** to be added.  Examples::

   # In setEditorColors.
   sheet = 'background-color: %s; color: %s' % (bg,fg)
   g.app.gui.update_style_sheet(obj,'colors',sheet)

   # In add_border.
   sheet = "border: %spx solid %s" % (
       c.focus_border_width,c.focus_border_color)
   self.update_style_sheet(w,'border',sheet)

   # In remove_border.
   sheet = "border: %spx solid white" % (c.focus_border_width)
   self.update_style_sheet(w,'border',sheet)

So add_border and remove_border work together because they use the
same 'border' key.

g.app.gui.update_style_sheet is straightforward: it injects a Python
dict called leo_stylesheet_dict into the widget, and computes the
total stylesheet as follows::

   # Step one: update the dict.
   d = hasattr(w,'leo_styles_dict') and w.leo_styles_dict or {}
   d[key] = value
   w.leo_styles_dict = d

   # Step two: update the stylesheet.
   aList = [d.get(key) for key in list(d.keys())]
   s = ';'.join(aList)
   w.setStyleSheet(s)
#@+node:ekr.20111026231721.16616: *4* Scrolling bug
@nocolor-node

An attempt at fixing the scrolling bug
http://groups.google.com/group/leo-editor/browse_thread/thread/de76f22b16ebc8f/7f6aa691002f1fca

Private email from Viktor
test-leo-rev-4506.leo

It looks like I can reproduce the scrolling problem with your file as follows:

- Select the last node: AM-Session
- Manually scroll down to the last line.
- Click at the end of text: the body pane scrolls.  Bug!


Downloaded leo-editor-snapshot-201110240253.zip and tried it out. Noticed that
when I added a dozen or so blank lines at the end of a body pane and moved the
mouse cursor to the last line and left-clicked the body pane jumped backwards
about 10 lines or so as though I had scrolled up. When I dragged the scroll
button to the end of the pane, the insertion point was still at the end of the
pane. This does not happen for all panes.
#@+node:ekr.20111123030145.10211: *5* Notes
@nocolor-node

Methods relating to this problem:

g.app.trace_scroll
w.see
w.seeInsertPoint
w.get/setYScrollPosition
p.restoreCursorAndScroll
v.restoreCursorAndScroll

leoKeyHandler:
    k.keykBoardQuit
    k.showStateAndMode
    k.setLabel
        ***** calls w.widget.ensureCursorVisible

leoQtBody:
    onFocusColorHelper
        ***** calls w.widget.ensureCursorVisible
        
leoQtBaseTextWidget:
    mouseReleaseEvent
        Added code that didn't work: now commented out.
        
leoEditCommands:
    updateAutoIndent
        ***** calls w.seeInsertPoint
        
    
#@+node:ekr.20111001155050.15480: *6* First attempt
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/de76f22b16ebc8f

As explained in detail in the thread, "dangerous" code is no longer executed immediately,
but instead executed at idle time using g.app.gui.runAtIdle.
#@+node:ekr.20111025062953.16477: *6* Added global tracing of scrolling-related code
g.app.trace_scroll
#@+node:ekr.20110930174206.15471: *5* Second attempt
@nocolor-node

The last time it happened:
    
- Search for something.
- Manually scroll the pane.
- Click scrolls the pane again.
#@+node:ekr.20110930174206.15474: *6* Changed
#@+node:ekr.20110605121601.18209: *7* deactivateEditors (qtBody)
def deactivateEditors(self,wrapper):

    '''Deactivate all editors except wrapper's editor.'''

    trace = False and not g.unitTesting
    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        wrapper2 = d.get(key)
        w2 = wrapper2.widget
        if hasattr(w2,'leo_active'):
            active = w2.leo_active
        else:
            active = True
        if wrapper2 != wrapper and active:
            w2.leo_active = False
            self.unselectLabel(wrapper2)
            w2.leo_scrollBarSpot = wrapper2.getYScrollPosition()
            w2.leo_insertSpot = wrapper2.getInsertPoint()
            w2.leo_selection = wrapper2.getSelectionRange()
            if trace: g.trace('**deactivate wrapper %s w %s' % (
                id(wrapper2),id(w2)))
            self.onFocusOut(w2)
#@+node:ekr.20070424080640: *7* deactivateActiveEditor (leoBody)
def deactivateActiveEditor(self,w):

    '''Inactivate the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.getYScrollPosition()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            return
#@+node:ekr.20110605121601.18027: *7* injectIvars (leoQtBaseTextWidget)
def injectIvars (self,name='1',parentFrame=None):

    w = self ; p = self.c.currentPosition()

    if name == '1':
        w.leo_p = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()

    w.leo_active = True

    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    w.leo_frame = None
    w.leo_name = name
    w.leo_label = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w
#@+node:ekr.20110605121601.18211: *7* injectIvars (qtBody)
def injectIvars (self,parentFrame,name,p,wrapper):

    trace = False and not g.unitTesting

    w = wrapper.widget
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if trace: g.trace(w)

    # Inject ivars
    if name == '1':
        w.leo_p = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()

    w.leo_active = True
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    # w.leo_colorizer = None # Set in leoQtColorizer ctor.
    w.leo_frame = parentFrame
    w.leo_insertSpot = None
    # w.leo_label = None # Injected by packLabel.
    w.leo_name = name
    # w.leo_on_focus_in = onFocusInCallback
    w.leo_scrollBarSpot = None
    w.leo_selection = None
    w.leo_wrapper = wrapper
#@+node:ekr.20070423102603: *7* selectEditorHelper (leoBody)
def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    trace = False

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return # (for Tk) 'break'

    if trace:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    self.deactivateActiveEditor(w)

    # The actual switch.
    c.frame.body.bodyCtrl = w
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return # (for Tk) 'break'

    if trace:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    # g.trace('expanding ancestors of ',w.leo_p.h,g.callers())
    c.redraw(w.leo_p)
    c.recolor()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocus()
    return # (for Tk) 'break'
#@+node:ekr.20061017083312.1: *8* << restore the selection, insertion point and the scrollbar >> selectEditorHelper leoBody.selectEditorBody
spot = hasattr(w,'leo_insertSpot') and w.leo_insertSpot or 0
w.setInsertPoint(0)
    
if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass

# Don't restore the scrollbar here.
#@+node:ekr.20110605121601.18203: *7* selectEditorHelper (qtBody)
def selectEditorHelper (self,wrapper):

    trace = False and not g.unitTesting
    c = self.c ; cc = c.chapterController
    d = self.editorWidgets
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    w = wrapper.widget
    assert isinstance(w,QtGui.QTextEdit),w

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget (w.leo_p,wrapper) # switches colorizers.
    # g.trace('c.frame.body',c.frame.body)
    # g.trace('c.frame.body.bodyCtrl',c.frame.body.bodyCtrl)
    # g.trace('wrapper',wrapper)
    c.frame.body.bodyCtrl = wrapper
    c.frame.body.widget = wrapper # Major bug fix: 2011/04/06
    w.leo_active = True

    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)

    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w,'leo_p') and w.leo_p):
        return g.trace('***** no w.leo_p',w)
        
    # if not (hasattr(w,'leo_chapter') and w.leo_chapter):
        # return g.trace('***** no w.leo_chapter',w)

    p = w.leo_p
    assert p,p

    if trace: g.trace('wrapper %s chapter %s old %s p %s' % (
        id(wrapper),w.leo_chapter,c.p.h,p.h))

    c.expandAllAncestors(p)
    c.selectPosition(p) # Calls assignPositionToEditor.
    c.redraw()
    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18204: *8* << restore the selection, insertion point and the scrollbar >> qtBody.selectEditorHelper
spot = hasattr(w,'leo_insertSpot') and w.leo_insertSpot or 0
wrapper.setInsertPoint(spot)

if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        wrapper.setSelectionRange(start,end)
    except Exception:
        pass

# Don't restore the scrollbar here.
#@+node:ekr.20070423101911: *7* selectHelper (leoTree)
# Do **not** try to "optimize" this by returning if p==c.p.
# 2011/11/06: *event handlers* are called only if p != c.p.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p
    
    call_event_handlers = p != old_p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace and (verbose or call_event_handlers):
        g.trace(p and p.h)
        # if old_p:
            # g.trace('old: %s %s new: %s %s' % (
                # len(old_p.b),old_p.h,len(p.b),p.h))
        # else:
            # g.trace('old: <none> new: %s %s' % (len(p.b),p.h))
            
            
    if 1: # 2011/11/06
        if call_event_handlers:
            unselect = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        else:
            unselect = True
        if unselect:
            << unselect the old node >>
        
    else: # Old code
        if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
            if old_p:
                << unselect the old node >>
    
    if call_event_handlers: # 2011/11/06
        g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        
    if call_event_handlers: # 2011/11/06
        if call_event_handlers:
            select = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        else:
            select = True
        if select:
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
    else: # old code
        if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
        
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    # if trace and (verbose or call_event_handlers):
        # g.trace('**** after old: %s new %s' % (
            # old_p and len(old_p.b),len(p.b)))

    # what UNL.py used to do
    c.frame.clearStatusLine()
    c.frame.putStatusLine(p.get_UNL())

    if call_event_handlers: # 2011/11/06
        g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return # (for Tk) 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129: *8* << unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
    
    # g.trace('set insert spot',insertSpot)
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p != p:
    # 2010/02/11: Don't change the *new* node's insert point!
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
    if g.app.trace_scroll: g.trace('old scroll: %s insert: %s' % (
        yview,insertSpot))
#@+node:ekr.20040803072955.130: *8* << select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@+node:ekr.20040803072955.133: *8* << set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

c.treeFocusHelper() # 2010/12/14
c.undoer.onSelect(old_p,p)
#@+node:ekr.20031218072017.3344: *7* v.__init
# To support ZODB, the code must set v._p_changed = 1 whenever
# v.unknownAttributes or any mutable vnode object changes.

def __init__ (self,context):

    # The primary data: headline and body text.
    self._headString = g.u('newHeadline')
    self._bodyString = g.u('')

    # Structure data...
    self.children = [] # Ordered list of all children of this node.
    self.parents = [] # Unordered list of all parents of this node.

    # Other essential data...
    self.fileIndex = g.app.nodeIndices.getNewIndex()
        # The immutable file index for this vnode.
        # New in Leo 4.6 b2: allocate gnx (fileIndex) immediately.
    self.iconVal = 0 # The present value of the node's icon.
    self.statusBits = 0 # status bits

    # v.t no longer exists.  All code must now be aware of the one-node world.
    # self.t = self # For compatibility with scripts and plugins.

    # Information that is never written to any file...
    self.context = context # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
#@+node:ekr.20100303074003.5636: *7* v.restoreCursorAndScroll
# Called only by setBodyTextAfterSelect.

def restoreCursorAndScroll (self,w):

    v = self
    spot = v and v.insertSpot or 0
    w.setInsertPoint(spot)
        
    # 2011/10/26: *only* restore the scrollbar setting.  Do not call see.
    if v and v.scrollBarSpot != None:
        pos = v.scrollBarSpot
        if g.app.trace_scroll: g.trace('(vnode)',pos)
        w.setYScrollPosition(pos)
        
    # Never call w.see here.

#@+node:ekr.20100303074003.5638: *7* v.saveCursorAndScroll(w)
def saveCursorAndScroll(self,w):

    v = self
    if not w: return
    
    try:
        v.scrollBarSpot = w.getYScrollPosition()
        v.insertSpot = w.getInsertPoint()
    except AttributeError:
        # 2011/03/21: w may not support the high-level interface.
        pass
#@+node:ekr.20111026231721.16619: *5* Third attempt, apparently successful
#@+node:ekr.20111026231721.16620: *6* Changed
#@+node:ekr.20100303074003.5636: *7* v.restoreCursorAndScroll
# Called only by setBodyTextAfterSelect.

def restoreCursorAndScroll (self,w):

    v = self
    spot = v and v.insertSpot or 0
    w.setInsertPoint(spot)
        
    # 2011/10/26: *only* restore the scrollbar setting.  Do not call see.
    if v and v.scrollBarSpot != None:
        pos = v.scrollBarSpot
        if g.app.trace_scroll: g.trace('(vnode)',pos)
        w.setYScrollPosition(pos)
        
    # Never call w.see here.

#@+node:ekr.20110605121601.18084: *7* getYScrollPosition (leoQTextEditWidget)
def getYScrollPosition(self):
    
    # **Important**: There is a Qt bug here: the scrollbar position
    # is valid only if cursor is visible.  Otherwise the *reported*
    # scrollbar position will be such that the cursor *is* visible.

    w = self.widget
    sb = w.verticalScrollBar()
    i = sb.sliderPosition()
    if g.app.trace_scroll: g.trace('(LeoQTextEditWidget)',i)
    return i
#@+node:ekr.20110605121601.18098: *7* setYScrollPosition (leoQTextEditWidget)
def setYScrollPosition(self,pos):
    
    # g.trace(pos)
    
    if 0: # 2011/12/21
        w = self.widget
        sb = w.verticalScrollBar()
        if g.app.trace_scroll: g.trace('(LeoQTextEditWidget)',pos)
        sb.setSliderPosition(pos)
#@+node:ekr.20061017083312.1: *7* << restore the selection, insertion point and the scrollbar >> selectEditorHelper leoBody.selectEditorBody
spot = hasattr(w,'leo_insertSpot') and w.leo_insertSpot or 0
w.setInsertPoint(0)
    
if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass

# Don't restore the scrollbar here.
#@+node:ekr.20110605121601.18204: *7* << restore the selection, insertion point and the scrollbar >> qtBody.selectEditorHelper
spot = hasattr(w,'leo_insertSpot') and w.leo_insertSpot or 0
wrapper.setInsertPoint(spot)

if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        wrapper.setSelectionRange(start,end)
    except Exception:
        pass

# Don't restore the scrollbar here.
#@+node:ekr.20070424080640: *7* deactivateActiveEditor (leoBody)
def deactivateActiveEditor(self,w):

    '''Inactivate the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.getYScrollPosition()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            return
#@+node:ekr.20111028111441.16588: *4* Fixed html colorizing by fixing a bad bug in g.importFromPath
@nocolor-node
    
g.importFromPath ('html','C:/leo.repo/trunk/leo/modes/html.py')
returned the standard Python html module!

#@+node:ekr.20111029055127.16635: *4* Allow lower case keywords in colorizer
# The fix was to use lowercase versions of docPart,leoKeyword,nameBrackets.
#@+node:ekr.20111102072143.10017: *4* Fixed recent problem in createMenuEntries
#@+node:ekr.20111103102153.9716: *4* Fixed rst3 pdf problem
@nocolor-node

Worked around docutils problem in writeToDocutils.
#@+node:ekr.20111104104831.9823: *4* Added unit test that all plugins have an init method
@nocolor-node

- The tests should not register the plugin.

- There should be a test that top-level code does not register the plugin.

Top-level calls to registerHandler:
    
    Fixed:
        examples/__overrideClasses.py
        examples/override_commands.py
        examples/redefine_put.py  (Tk)
        examples/chinese_menu.py
        examples/french_fm.py
    
        at_view.py
        test/failed_import.py
        scripts_menu.py
#@+node:ekr.20111105054152.9949: *4* Removed traceback when cancelling a write
not written: c:\recent\data3.html
exception removing: 
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 5280, in remove
    os.remove(fileName)
WindowsError: [Error 3] The system cannot find the path specified: ''
#@+node:ekr.20111105055134.9769: *4* Fixed removeBlankLinesTokens
@nocolor-node

There were two bugs:
    
- baseScannerClass.skipWsToken must not skip newlines!
- tokenize must add any remaining whitespace at the end of the loop.
#@+node:ekr.20111105110308.9717: *4* Fixed crasher in config.set
# The code didn't work for c == None.
#@+node:ekr.20111107055809.9704: *4* Fixed resize-to-screen and minimize-all
#@+node:ekr.20111029055127.16609: *4* Fixed html import problems
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/3c319daba37cd0ef

- Created a separate html importer, a very simple subclass of the xml scanner
  whose only difference is that it uses @data import_html_tags instead of @data
  import_xml_tags.

- The case of tags in @data import_html_tags and @data import_xml_tags no longer matters.

- checkTrialWrite now writes a file *with* sentinels, to handle @others correctly.
  It then removes the sentinels.
  
  This means that the import tests must use the correct @language directives.
  
- The import check now uses a token-based comparison.  
#@+node:ekr.20111109151106.9906: *4* Removed extra newlines in g.trace
@nocolor-node

The fix was in g.pr:
    
Restored the call to sys.stdout.write(s2) (instead of print)

sys.stdout.write(s2) writes no additional newline at the end of s2.

Aha!  At last I know how to unit test g.pr, g.trace, etc.: redirect stdout!  Doh!
#@+node:ekr.20111110091847.10070: *4* Fixed crash in compareTokens
@nocolor-node


 File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2074, in
scanAndCompare
   n1,n2,ok = self.compareTokens(tokens1,tokens2)
 File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2094, in
compareTokens
   else:      kind1,val1 = 'eof','',n1
ValueError: too many values to unpack
#@+node:ekr.20111109151106.9745: *4* Finished import work
@nocolor-node


- Created stand-alone unit tests from @test import dataN.html.
- All leoImport unit tests may now be run externally.
    The Python unit tests were failing because of intermixed tabs and blanks.
    This was fixed by putting @tabwidth -4 in all @test nodes for Python.
- Made sure lines are printed when unit tests fail unexpectedly.
- Added .js & javascript entries to global data structures for javascript unit tests.
- Completed xmlScanner.filterTokens.
- Don't create declaration nodes for html.
- Make sure html tags are as expected.
- Ignore case of html/xml tags.
#@+node:ekr.20111112064924.9777: *5* What I did
@language rest

Rev 4774.1.1:
=============

Fixed all known html-import problems in a clean way. Unit tests exists, but they
use external files. They will be converted soon.

Important changes:

1. Added hasNestedClasses ivar in the baseScannerClass, True only for xml/html scanners.

When True, scanHelper and skipDecls allocate a substring to be used for all further scanning.
This is the *only* way to limit Leo's scanners properly.

This was, in essence, the fix for duplicate code generation arising from unbalanced tags:
skipToEndOfTag and skipToMatchingTag can't match outside the present tag because
the 's' argument passed to those methods has already been truncated.

This is a simple, elegant solution, and in essence the *only* proper solution.
For example, it would not work to past an 'end' argument to skipToEndOfTag and skipToMatchingTag
because the scanners inside those methods do not understand an 'end' argument.

Thus, the simplest, most efficient solution is for scanHelper and skipDecls to truncate the
string to be scanned. That way, the truncation happens at most once per "class".

2. Added hasDecls in the baseScannerClass, False only for xml/html scanners.

Various methods call skipDecls only if this ivar is True.

Rev 4773:
=========

Fixed recent botch: both single and double quotes are allowed in html. 

Rev 4772:
=========

Solved "between element" problem by extending classes up to the next class.
data.html imports "correctly", but not perfectly due to tag mismatches in
skipToMatchingTag.
#@+node:ekr.20111112193858.9831: *4* Fixed hard crash when deleting body editor 3 times
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/421ebf4c3f2d5f59

Adding/deleting body editor 3 times hard-crashed Python

The changes were straightforward:
    
- set w.leo_label to None when calling unpackWidget.

- Test for w.leo_label before using it.

Added a minitest.  To test by hand, add the following @button nodes:
    
    @button add-ed
    w = c.frame.body.addEditor()
    
    @button del-ed
    w = c.frame.body.deleteEditor()
    
Click away in any order...

#@+node:ekr.20111111065410.12913: *4* Fixed add/delete html comments
@nocolor-node

The new add-comments command adds the comment character at the leftmost column.

The new delete-comments command will remove the comment characters inserted by
either the old or new version of the add-comments command.
#@+node:ekr.20050312114529: *5* c.insert/removeComments
#@+node:ekr.20050312114529.1: *6* addComments
def addComments (self,event=None):
    
    << addComments docstring >>

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('no text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',' '+d3

    # Comment out non-blank lines.
    indent = c.config.getBool('indent_added_comments',default=True)
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            if indent:
                result.append(line[0:i]+openDelim+line[i:].replace('\n','')+closeDelim+'\n')
            else:
                result.append(openDelim+line.replace('\n','')+closeDelim+'\n')
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
#@+node:ekr.20111115111842.9789: *7* << addComments docstring >>
@pagewidth 50

'''
Converts all selected lines to comment lines using
the comment delimiters given by the applicable
 @language directive.

Inserts single-line comments if possible; inserts
block comments for languages like html that lack
single-line comments.

 @bool indent_added_comments

If True (the default), inserts opening comment
delimiters just before the first non-whitespace
character of each line. Otherwise, inserts opening
comment delimiters at the start of each line.

*See also*: delete-comments.
'''
#@+node:ekr.20050312114529.2: *6* deleteComments
def deleteComments (self,event=None):
    
    << deleteComments docstring >>

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('no text selected',color='blue')
        return

    if d1:
        # Remove the single-line comment delim in front of each line
        d1b = d1 + ' '
        n1,n1b = len(d1),len(d1b)
        for s in lines:
            i = g.skip_ws(s,0)
            if g.match(s,i,d1b):
                result.append(s[:i] + s[i+n1b:])
            elif g.match(s,i,d1):
                result.append(s[:i] + s[i+n1:])
            else:
                result.append(s)
    else:
        # Remove the block comment delimiters from each line.
        n2,n3 = len(d2),len(d3)
        for s in lines:
            i = g.skip_ws(s,0)
            j = s.find(d3,i+n2)
            if g.match(s,i,d2) and j > -1:
                first = i + n2
                if g.match(s,first,' '): first += 1
                last = j
                if g.match(s,last-1,' '): last -= 1
                result.append(s[:i] + s[first:last] + s[j+n3:])
            else:
                result.append(s)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
#@+node:ekr.20111115111842.9790: *7* << deleteComments docstring >>
@pagewidth 50

'''
Removes one level of comment delimiters from all
selected lines.  The applicable @language directive
determines the comment delimiters to be removed.

Removes single-line comments if possible; removes
block comments for languages like html that lack
single-line comments.

*See also*: add-comments.
'''
#@+node:ekr.20111118090912.12874: *4* Fixed bug that prevented text bindings from working in log tabs
@nocolor-node

Example: ctrl-shift-home.

The fix was to set self.widget = contents in leoQtLog.selectTab.
#@+node:ekr.20111118190243.10170: *4* Fixed cycle-all-focus command
@nocolor-node

What I did:
    
- Added disabled code to inject event filter in TabbedFrameFactory.createFrame.

- Added cycle-tab-focus command.

- cycle-all-focus command uses cycleTabFocus as a helper: this greatly simplifies the code.
    
- Added binding for "Find" tab in leoQtLog.createTab.

- DynamicWindow.createFindTab injects leo_find_widget ivar for leoQtLog.createTab.

- Added isLogWidget to leoQtLog and nullLog classes.  They are helpers for cycleAllFocus.

- Revised leoQtLog.selectHelper: selecting a new tab does *not* change logCtrl (log.widget).
#@+node:ekr.20111120162254.10217: *5* Added bindings to Find tab
#@+node:ekr.20111121071940.10275: *5* Changed
#@+node:ekr.20110605121601.18166: *6* createFindTab (DynamicWindow)
def createFindTab (self,parent,tab_widget):

    c,dw = self.leo_c,self
    grid = self.createGrid(parent,'findGrid',margin=10,spacing=10)
    grid.setColumnStretch(0,100)
    grid.setColumnStretch(1,100)
    
    # Row 0: heading.
    lab1 = self.createLabel(parent,'findHeading','Find/Change Settings...')
    grid.addWidget(lab1,0,0,1,2,QtCore.Qt.AlignHCenter)
    
    # Rows 1, 2: the find/change boxes, now disabled.
    findPattern = self.createLineEdit(parent,'findPattern',disabled=True)
    findChange  = self.createLineEdit(parent,'findChange',disabled=True)
    lab2 = self.createLabel(parent,'findLabel','Find:')
    lab3 = self.createLabel(parent,'changeLabel','Change:')
    grid.addWidget(lab2,1,0)
    grid.addWidget(lab3,2,0)
    grid.addWidget(findPattern,1,1)
    grid.addWidget(findChange,2,1)
        
    # Check boxes and radio buttons.
    # Radio buttons are mutually exclusive because they have the same parent.
    def mungeName(name):
        # The value returned here is significant: it creates an ivar.
        return 'checkBox%s' % label.replace(' ','').replace('&','')

    # Rows 3 through 8...
    table = (
        ('box', 'Whole &Word',      2,0),
        ('rb',  '&Entire Outline',  2,1),
        ('box', '&Ignore Case',     3,0),
        ('rb',  '&Suboutline Only', 3,1),
        ('box', 'Wrap &Around',     4,0),
        ('rb',  '&Node Only',       4,1),
        # ('box', '&Reverse',       5,0),
        ('box', 'Search &Headline', 5,1),
        ('box', 'Rege&xp',          5,0), # was 6,0
        ('box', 'Search &Body',     6,1),
        ('box', 'Mark &Finds',      6,0), # was 7,0
        ('box', 'Mark &Changes',    7,0)) # was 7,1
        # a,b,c,e,f,h,i,n,rs,w

    for kind,label,row,col in table:
        name = mungeName(label)
        func = g.choose(kind=='box',
            self.createCheckBox,self.createRadioButton)
        w = func(parent,name,label)
        grid.addWidget(w,row+1,col)
        setattr(self,name,w)

    # Row 9: Widgets that take all additional vertical space.
    w = QtGui.QWidget()
    grid.addWidget(w,9,0)
    grid.addWidget(w,9,1)
    grid.setRowStretch(9,100)

    # Official ivars (in addition to setattr ivars).
    self.leo_find_widget = tab_widget # 2011/11/21: a scrollArea.
    self.findPattern = findPattern
    self.findChange = findChange
    # self.findLab = lab2
    # self.changeLab = lab3
#@+node:ekr.20110605121601.18466: *6* createFrame (TabbedFrameFactory)
def createFrame(self, leoFrame):

    # g.trace('(TabbedFrameFactory)')

    c = leoFrame.c
    if self.masterFrame is None:
        self.createMaster()
    tabw = self.masterFrame
    dw = DynamicWindow(c,tabw)
    self.leoFrames[dw] = leoFrame

    # Shorten the title.
    fname = c.mFileName
    if fname:
        title = os.path.basename(fname)
    else:
        title = leoFrame.title
    tip = leoFrame.title

    dw.setWindowTitle(tip) # 2010/1/1
    idx = tabw.addTab(dw, title)
    if tip: tabw.setTabToolTip(idx, tip)

    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)
    
    if 1:
        # g.trace('(TabbedFrameFactor) adding bindings')
        dw.ev_filter = leoQtEventFilter(c,w=dw,tag='sdi-frame')
        dw.installEventFilter(dw.ev_filter)

    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(
        self.alwaysShowTabs or tabw.count() > 1)

    dw.show()
    tabw.show()
    return dw
#@+node:ekr.20110605121601.18326: *6* createTab (leoQtLog)
def createTab (self,tabName,widget=None,wrap='none'):
    """ Create a new tab in tab widget

    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """

    trace = False and not g.unitTesting
    c = self.c
    
    if trace: g.trace(tabName,widget and g.app.gui.widget_name(widget) or '<no widget>')

    if widget is None:

        widget = LeoQTextBrowser(parent=None,c=c,wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = leoQTextEditWidget(widget=widget,name='log',c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
            
        if trace: g.trace('** creating',tabName,'self.widget',contents,'wrapper',widget)
        
        widget.setWordWrapMode(
            g.choose(self.wrap,
                QtGui.QTextOption.WordWrap,
                QtGui.QTextOption.NoWrap))

        widget.setReadOnly(False) # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.widget = contents # widget is an alias for logCtrl.
            widget.setObjectName('log-widget')

        if True: # 2011/05/28.
            # Set binding on all text widgets.
            theFilter = leoQtEventFilter(c,w=self,tag='log')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
            
        if True and tabName == 'Log':
    
            assert c.frame.top.__class__.__name__ == 'DynamicWindow'
            find_widget = c.frame.top.leo_find_widget
            
            # 2011/11/21: A hack: add an event filter.
            find_widget.leo_event_filter = leoQtEventFilter(c,w=widget,tag='find-widget')
            find_widget.installEventFilter(find_widget.leo_event_filter)
            if trace: g.trace('** Adding event filter for Find',find_widget)
            
            # 2011/11/21: A hack: make the find_widget an official log widget.
            self.contentsDict['Find']=find_widget
    
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget,tabName)
    else:
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        widget.leo_log_wrapper = contents
            # The leo_log_wrapper is the widget itself.
        if trace: g.trace('** using',tabName,widget)
        
        if 1: # Now seems to work.
            theFilter = leoQtEventFilter(c,w=contents,tag='tabWidget')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
    
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents,tabName)

    return contents
#@+node:ekr.20060613090701: *6* cycleAllFocus (editCommandsClass)
editWidgetCount = 0

def cycleAllFocus (self,event):

    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    trace = False and not g.unitTesting
    c = self.c ; k = c.k
    w = event and event.widget # Does **not** require a text widget.

    pane = None # The widget that will get the new focus.
    log = c.frame.log
    w_name = g.app.gui.widget_name
    
    if trace: g.trace('**before',w_name(w),'isLog',log.isLogWidget(w))

    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).startswith('body'):
        n = c.frame.body.numberOfEditors
        if n > 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.bodyCtrl
            elif self.editWidgetCount > n:
                self.editWidgetCount = 0
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event)
                pane = None
        else:
            self.editWidgetCount = 0
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl

    elif log.isLogWidget(w):
        log.cycleTabFocus()
        if log.tabName == 'Log':
            pane = c.frame.tree.canvas
        else:
            if trace:
                pane = log.logCtrl
                g.trace('**after cycleTabFocus',w_name(pane),pane)
            return

    else:
        # A safe default: go to the body.
        pane = c.frame.body.bodyCtrl
    
    if trace: g.trace('**after',w_name(pane),pane)

    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)
        k.showStateAndMode()
#@+node:ekr.20110605121601.18327: *6* cycleTabFocus (leoQtLog)
def cycleTabFocus (self,event=None):

    '''Cycle keyboard focus between the tabs in the log pane.'''
    
    trace = False and not g.unitTesting
    c = self.c
    w = self.tabWidget

    i = w.currentIndex()
    i += 1
    if i >= w.count():
        i = 0

    tabName = w.tabText(i)
    
    self.selectTab(tabName,createText=False)
    if trace: g.trace(i,tabName)

#@+node:ekr.20111120124732.10184: *6* isLogWidget (leoQtLog)
def isLogWidget(self,w):
    
    val = w == self or w in list(self.contentsDict.values())
    # g.trace(val,w)
    return val
#@+node:ekr.20111119145033.10186: *6* isLogWidget (nullLog)
def isLogWidget(self,w):
    return False
#@+node:ekr.20110605121601.18331: *6* selectTab & helper (leoQtLog)
def selectTab (self,tabName,createText=True,widget=None,wrap='none'):
    # createText is used by leoLog.selectTab.

    '''Create the tab if necessary and make it active.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.tabWidget
    
    if trace: g.trace(tabName,g.callers())

    # Step 1: See if the tab exits.
    ok = self.selectHelper(tabName)
    if ok: return

    # Step 2: create tab if necessary.
    self.createTab(tabName,widget=widget,wrap=wrap)
    self.selectHelper(tabName)
#@+node:ekr.20110605121601.18332: *7* selectHelper (leoQtLog)
def selectHelper (self,tabName):

    trace = False and not g.unitTesting
    c,w = self.c,self.tabWidget

    for i in range(w.count()):
        if tabName == w.tabText(i):
            w.setCurrentIndex(i)
            
            widget = w.widget(i)
            
            # 2011/11/21: Set the .widget ivar only if there is a wrapper.
            wrapper = hasattr(widget,'leo_log_wrapper') and widget.leo_log_wrapper
            if wrapper:
                self.widget = wrapper
            if trace: g.trace(tabName,'widget',widget,'wrapper',wrapper)
            
            # Do *not* set focus here!
                # c.widgetWantsFocus(tab_widget)

            if tabName == 'Spell':
                # the base class uses this as a flag to see if
                # the spell system needs initing
                self.frameDict['Spell'] = widget
                
            self.tabName = tabName # 2011/11/20
            return True
    else:
        self.tabName = None # 2011/11/20
        if trace: g.trace('** not found',tabName)
        return False
#@+node:ekr.20111121084517.10188: *4* Fixed crashers involving calls to w.setSelectionRange
#@+node:ekr.20110916215321.6708: *5* selectToMatchingBracket (leoEditCommands)
def selectToMatchingBracket (self,event):
    
    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return
    
    i = w.getInsertPoint()
    s = w.getAllText()
    
    allBrackets = self.openBracketsList + self.closeBracketsList
    
    if i < len(s) and s[i] in allBrackets:
        ch = s[i]
    elif i > 0 and s[i-1] in allBrackets:
        i -= 1
        ch = s[i]
    else:
        g.es('no bracket selected')
        return

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    
    # This should be generalized...
    language = g.findLanguageDirectives(c,c.p)
    if language in ('c','cpp','csharp'):
        j = g.skip_matching_c_delims(s,i,ch,delim2,reverse=reverse)
    else:
        j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    # g.trace(i,j,ch,delim2,reverse,language)
    if j not in (-1,i):
        if reverse:
            i += 1; j += 1
        w.setSelectionRange(i,j,insert=j)
            # 2011/11/21: Bug fix: was ins=j.
        w.see(j)
#@+node:ekr.20110605121601.18205: *5* updateEditors (qtBody)
# Called from addEditor and assignPositionToEditor

def updateEditors (self):

    c = self.c ; p = c.p ; body = p.b
    d = self.editorWidgets
    if len(list(d.keys())) < 2: return # There is only the main widget

    w0 = c.frame.body.bodyCtrl
    i,j = w0.getSelectionRange()
    ins = w0.getInsertPoint()
    sb0 = w0.widget.verticalScrollBar()
    pos0 = sb0.sliderPosition()
    for key in d:
        wrapper = d.get(key)
        w = wrapper.widget
        v = hasattr(w,'leo_p') and w.leo_p.v
        if v and v == p.v and w != w0:
            sb = w.verticalScrollBar()
            pos = sb.sliderPosition()
            wrapper.setAllText(body)
            self.recolorWidget(p,wrapper)
            sb.setSliderPosition(pos)

    c.bodyWantsFocus()
    w0.setSelectionRange(i,j,insert=ins)
        # 2011/11/21: bug fix: was ins=ins
    sb0.setSliderPosition(pos0)
#@+node:ekr.20111121222953.10973: *4* Fixed hang in cycleAllFocus
@nocolor-node

The safe default pane is the body pane.  It's also the simplest code.
#@+node:ekr.20111121222953.10974: *4* Fixed crasher in k.handleDefaultChar
@nocolor-node

The code must be careful that the log widget supports the HighLevelInterface.
#@+node:ekr.20111121210400.11142: *4* Fixed bug: Focus lost after opening or closing tab
#@+node:ekr.20111121214837.10184: *5* Changed
#@+node:ekr.20031218072017.2609: *6* app.closeLeoWindow
def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    # g.trace('frame',frame,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c)
        # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c)
        # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        master = hasattr(frame.top,'leo_master') and frame.top.leo_master
        if master: # 2011/11/21: selecting the new tab ensures focus is set.
            # frame.top.leo_master is a TabbedTopLevel.
            master.select(frame.c)
        frame.c.bodyWantsFocus()
        frame.c.outerUpdate()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@+node:ekr.20110605121601.18456: *6* select (leoTabbedTopLevel)
def select (self,c):

    '''Select the tab for c.'''
    
    dw = c.frame.top # A DynamicWindow
    i = self.indexOf(dw)
    self.setCurrentIndex(i)
    # g.trace(i,c)
#@+node:ekr.20090520055433.5948: *6* g.findOpenFile
def findOpenFile(fileName):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fileName)) == g.os_path_realpath(munge(c.mFileName)):
            frame.bringToFront()
            c.setLog()
            # 2011/11/21: selecting the new tab ensures focus is set.
            master = hasattr(frame.top,'leo_master') and frame.top.leo_master
            if master: # frame.top.leo_master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
#@+node:ekr.20090520055433.5952: *6* g.finishOpen
def finishOpen(c):

    k = c.k
    # New in Leo 4.6: provide an official way for very late initialization.

    # # 2011/11/21: selecting the new tab ensures focus is set.
    # master = hasattr(c.frame.top,'leo_master') and c.frame.top.leo_master
    # if master: # frame.top.leo_master is a TabbedTopLevel.
        # master.select(c)

    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    if k:
        k.setDefaultInputState()
    c.initialFocusHelper()
    if k:
        k.showStateAndMode()

    c.frame.initCompleteHint()
    return True
#@+node:ekr.20111122094453.10201: *4* Ignore unbound Alt/Ctrl keys, especially Alt/Ctrl-N
@nocolor-node

The bug was in k.handleDefaultChar.  No substantial change made to eventFilter.
#@+node:ekr.20111124082644.10919: *4* Fixed bug: ensure global @buttons work
@nocolor-node

What I did:
    
1. Fixed major bug in settingsTreeParser.visitNode.
   It now does p.copy() to protect the callers traverals.
   This could have significant impacts on people's settings.
   
2. Added g.app.unitTestDict for unit testing.

3. Leo now extends the list of @buttons and @commands, rather than replacing them.
   This is reasonable only because leoSettings.leo should never define *active*
   buttons or commands.
#@+node:ekr.20111204102027.10279: *4* Fixed bug in p.moveToFirstChild
#@+node:ekr.20040303175026.11: *5* p.moveToNthChildOf
def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self # Do NOT copy the position!

    parent._adjustPositionBeforeUnlink(p)
    p._unlink()
    p._linkAsNthChild(parent,n)

    return p
#@+node:ekr.20040306060312: *5* p.moveToFirst/LastChildOf
def moveToFirstChildOf (self,parent):
    """Move a position to the first child of parent."""
    
    p = self # Do NOT copy the position!
    return p.moveToNthChildOf (parent,0)  # Major bug fix: 2011/12/04

def moveToLastChildOf (self,parent):
    """Move a position to the last child of parent."""
    
    p = self # Do NOT copy the position!
    n = parent.numberOfChildren()
    if p.parent() == parent:
        n -= 1 # 2011/12/10: Another bug fix.
    return p.moveToNthChildOf (parent,n) # Major bug fix: 2011/12/04
#@+node:ekr.20111125072438.10203: *4* bug 804960: Refreshing unlinks clones, just reopening connects them again
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/804960

When we clone a node inside an @shadow (containing @others) node and then
refresh the @shadow node from file, the clone is unlinked and marked as changed.
If we now save, close the .leo file and open it again, the nodes are linked
again! (showing "cloned" symbol) User's thought: "How the heck can the file
change _between save and re-open_ when I changed nothing?"

I think what should be done about this is the check that Leo does when it opens
the file again, and that check should be done immediately after the "refresh
node from file" operation. Also, at this point, the "Recovered nodes" node
should appear (if file and node have both changed), not only after the next .leo
file close/reopen (as that happens quite infrequently, I guess, e.g. once a day
for me). Otherwise, the user can easily lose data.
#@+node:ekr.20111210131839.10311: *5* changed...
#@+node:ekr.20090218115025.5: *6* fc.initIvars
def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding

    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    # self.python23 = g.CheckVersion(version,'2.3')

    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentTnodeUaDictList = []
    self.descendentVnodeUaDictList = []
    self.ratio = 0.5

    self.currentVnode = None
    self.rootVnode = None

    # For writing
    self.read_only = False
    self.rootPosition = None
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    # self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.gnxDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are vnodes.
        # 2011/12/10: This dict is never re-inited.
    # g.trace('***clearing gnxDict',c)
        
    self.vnodesDict = {}
        # keys are gnx strings; values are ignored
#@+node:ekr.20031218072017.1559: *6* fc.getLeoOutlineFromClipboard & helpers
def getLeoOutlineFromClipboard (self,s,reassignIndices=True):

    '''Read a Leo outline from string s in clipboard format.'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; current = c.p ; check = not reassignIndices
    checkAfterRead = False or c.config.getBool('check_outline_after_read')

    self.initReadIvars() # 2010/02/05

    # Save the hidden root's children.
    children = c.hiddenRootNode.children

    # 2011/12/10: never recreate the gnxDict.
        # Always recreate the gnxDict
        # self.gnxDict = {}
    # g.trace('*** clearing gnxDict',g.callers())
    
    # 2011/12/12: save and clear gnxDict.
    # This ensures that new indices will be used for all nodes.
    if reassignIndices:
        oldGnxDict = self.gnxDict
        self.gnxDict = {}
    else:
        # Make sure all pasted nodes are entered into the gnxDict.
        x = g.app.nodeIndices
        for v in c.all_unique_nodes():
            index = x.toString(v.fileIndex)
            self.gnxDict[index] = v

    self.usingClipboard = True
    try:
        # This encoding must match the encoding used in putLeoOutline.
        s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
        if trace: g.trace(s)

        # readSaxFile modifies the hidden root.
        v = self.readSaxFile(
            theFile=None, fileName='<clipboard>',
            silent=True, # don't tell about stylesheet elements.
            inClipboard=True,reassignIndices=reassignIndices,s=s)
        if not v:
            return g.es("the clipboard is not valid ",color="blue")
    finally:
        self.usingClipboard = False

    # Restore the hidden root's children
    c.hiddenRootNode.children = children

    # Unlink v from the hidden root.
    v.parents.remove(c.hiddenRootNode)

    p = leoNodes.position(v)

    # Important: we must not adjust links when linking v
    # into the outline.  The read code has already done that.
    if current.hasChildren() and current.isExpanded():
        if check and not self.checkPaste(current,p):
            return None
        p._linkAsNthChild(current,0,adjust=False)
    else:
        if check and not self.checkPaste(current.parent(),p):
            return None
        p._linkAfter(current,adjust=False)

    if reassignIndices:
        self.gnxDict = oldGnxDict
            # 2011/12/12: restore gnxDict.
        for p2 in p.self_and_subtree():
            v = p2.v
            v.fileIndex = index = g.app.nodeIndices.getNewIndex()
            self.gnxDict[index] = v

    if trace and verbose:
        g.trace('**** dumping outline...')
        c.dumpOutline()

    if checkAfterRead:
        g.trace('checking outline after paste',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.selectPosition(p)
    self.initReadIvars() # 2010/02/05
    return p

getLeoOutline = getLeoOutlineFromClipboard # for compatibility
#@+node:ekr.20080410115129.1: *7* checkPaste
def checkPaste (self,parent,p):

    '''Return True if p may be pasted as a child of parent.'''

    if not parent: return True

    parents = [z.copy() for z in parent.self_and_parents()]

    for p in p.self_and_subtree():
        for z in parents:
            # g.trace(p.h,id(p.v),id(z.v))
            if p.v == z.v:
                g.es('Invalid paste: nodes may not descend from themselves',color="blue")
                return False

    return True
#@+node:ekr.20060919142200.1: *6* fc.initReadIvars
def initReadIvars (self):

    self.descendentTnodeUaDictList = []
    self.descendentVnodeUaDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
        # 2011/12/10: never re-init this dict.
        # self.gnxDict = {}
        # g.trace('*** clearing gnxDict',g.callers())
    self.c.nodeConflictList = [] # 2010/01/05
    self.c.nodeConflictFileName = None # 2010/01/05
#@+node:ekr.20111213092149.10324: *4* Fixed crasher in reportMismatch
@nocolor-node

>  File "/path/to/leo/core/leoImport.py", line 2070, in reportMismatch
>    line = repr(lines2[i])
> IndexError: list index out of range
#@+node:ekr.20111214093735.10286: *4* Disabled section-reference handling in @auto files
#@+node:ekr.20111214093735.10298: *5* Changed
#@+node:ekr.20070703122141.104: *6* checkTrialWrite
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.
    trace = False
    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        if self.isRst:
            outputFile = StringIO()
            c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
            s1,s2 = self.file_s,outputFile.getvalue()
        elif self.atAuto: # 2011/12/14: Special case for @auto.
            at.writeOneAtAutoNode(self.root,toString=True,force=True)
            s1,s2 = self.file_s,at.stringOutput
        else:
            # 2011/11/09: We must write sentinels in s2 to handle @others correctly.
            at.write(self.root,
                # nosentinels=True,thinFile=False,
                nosentinels=False,thinFile=True,
                scriptWrite=False,toString=True,
            )
            s1,s2 = self.file_s, at.stringOutput
            
            # Now remove sentinels from s2.
            line_delim = self.lineCommentDelim or self.lineCommentDelim2 or ''
            start_delim = self.blockCommentDelim1 or self.blockCommentDelim2 or ''
            # g.trace(self.language,line_delim,start_delim)
            assert line_delim or start_delim
            s2 = self.importCommands.removeSentinelLines(s2,
                line_delim,start_delim,unused_end_delim=None)

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True
    
    if self.ignoreBlankLines or self.ignoreLeadingWs:
        lines1 = g.splitLines(s1)
        lines2 = g.splitLines(s2)
        lines1 = self.adjustTestLines(lines1)
        lines2 = self.adjustTestLines(lines2)
        s1 = ''.join(lines1)
        s2 = ''.join(lines2)
        
    if 1: # Token-based comparison.
        bad_i1,bad_i2,ok = self.scanAndCompare(s1,s2)
        if ok: return ok
        
    else: # Line-based comparison: can not possibly work for html.
        n1,n2 = len(lines1), len(lines2)
        ok = True ; bad_i = 0
        for i in range(max(n1,n2)):
            ok = self.compareHelper(lines1,lines2,i,self.strict)
            if not ok:
                bad_i = i
                break

    # Unit tests do not generate errors unless the mismatch line does not match.
    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == bad_i1
            # was d.get('actualMismatchLine')
        if not ok: d['fail'] = g.callers()

    if trace or not ok:
        lines1 = g.splitLines(s1)
        lines2 = g.splitLines(s2)
        self.reportMismatch(lines1,lines2,bad_i1,bad_i2)

    return ok
#@+node:ekr.20070707072749: *6* run (baseScannerClass)
def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Use @verbatim to escape section references.
    # 2011/12/14: @auto never supports section references.
    if self.escapeSectionRefs and not self.atAuto: 
        s = self.escapeFalseSectionReferences(s)

    # Check for intermixed blanks and tabs.
    if self.strict or self.atAutoWarnsAboutLeadingWhitespace:
        if not self.isRst:
            self.checkBlanksAndTabs(s)

    # Regularize leading whitespace for strict languages only.
    if self.strict: s = self.regularizeWhitespace(s) 

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20071110105107: *7* checkBlanksAndTabs
def checkBlanksAndTabs(self,s):

    '''Check for intermixed blank & tabs.'''

    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0

    for line in g.splitLines(s):
        lws = line[0:g.skip_ws(line,0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')

    ok = blanks == 0 or tabs == 0

    if not ok:
        self.report('intermixed blanks and tabs')

    return ok
#@+node:ekr.20070808115837.1: *7* regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed:
        action = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
        message = 'inconsistent leading whitespace. %s' % action
        self.report(message)

    return ''.join(result)
#@+node:ekr.20041005105605.161: *6* at.putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    trace = False and not g.unitTesting
    at = self
    at_comment_seen,at_delims_seen,at_warning_given=False,False,False
        # 2011/05/25: warn if a node contains both @comment and @delims.

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.b)

    p.v.setVisited()
    if trace: g.trace('visit',p.h)
        # Make sure v is never expanded again.
        # Suppress orphans check.
    if not at.thinFile:
        p.v.setWriteBit() # Mark the vnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    at.raw = False # 2007/07/04: Bug fix exposed by new sentinels.
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert next_i > i,'putBody'
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()

    if not trailingNewlineFlag:
        if at.writeVersion5:
            if at.sentinels:
                pass # Never write @nonl
            elif at.atAuto and not at.atEdit:
                at.onl() # 2010/08/01: bug fix: ensure newline here.
        else:
            if at.sentinels:
                at.putSentinel("@nonl")
            elif at.atAuto and not at.atEdit:
                # Ensure all @auto nodes end in a newline!
                at.onl()
#@+node:ekr.20041005105605.162: *7* << Make sure all lines end in a newline >>
@ If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if not trailingNewlineFlag:
        if (at.sentinels or 
            (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
        ):
            # g.trace('Added newline',repr(s))
            s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@+node:ekr.20041005105605.163: *7* << handle line at s[i] >> (putBody)
if trace: g.trace(repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            if at.raw or at.atAuto: # 2011/12/14: Ignore references in @auto.
                at.putCodeLine(s,i)
            else:
                hasRef,n1,n2 = at.findSectionName(s,i)
                if hasRef:
                    at.putRefLine(s,i,n1,n2,p)
                else:
                    at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif at.raw:
    if kind == at.endRawDirective:
        at.raw = False
        at.putSentinel("@@end_raw")
        i = g.skip_line(s,i)
    else:
        # Fix bug 784920: @raw mode does not ignore directives 
        at.putCodeLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert not at.pending,'putBody at.pending'
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode:
            if p == self.root:
                at.putAtAllLine(s,i,p)
            else:
                at.error('@all not valid in: %s' % (p.h))
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    # Fix bug 784920: @raw mode does not ignore directives 
    at.error('unmatched @end_raw directive: %s' % p.h)
    # at.raw = False
    # at.putSentinel("@@end_raw")
    # i = g.skip_line(s,i)
elif kind == at.startVerbatim:
    # Fix bug 778204: @verbatim not a valid Leo directive.
    if g.unitTesting:
        # A hack: unit tests for @shadow use @verbatim as a kind of directive.
        pass
    else:
        g.trace(at.atShadow)
        at.error('@verbatim is not a Leo directive: %s' % p.h)
    if 0: # Old code.  This is wrong: @verbatim is not a directive!
        at.putSentinel("@verbatim")
        at.putIndent(at.indent)
        i = next_i
        next_i = g.skip_line(s,i)
        at.os(s[i:next_i])
elif kind == at.miscDirective:
    # Fix bug 583878: Leo should warn about @comment/@delims clashes.
    if g.match_word(s,i,'@comment'):
        at_comment_seen = True
    elif g.match_word(s,i,'@delims'):
        at_delims_seen = True
    if at_comment_seen and at_delims_seen and not at_warning_given:
        at_warning_given = True
        at.error('@comment and @delims in node %s' % p.h)
    at.putDirective(s,i)
else:
    at.error('putBody: can not happen: unknown directive kind: %s' % kind)
#@+node:ekr.20111109122014.9792: *4* Fix bug: Allow @all only in top-level @<file> nodes (test2.leo)
#@+node:ekr.20041005105605.161: *5* at.putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    trace = False and not g.unitTesting
    at = self
    at_comment_seen,at_delims_seen,at_warning_given=False,False,False
        # 2011/05/25: warn if a node contains both @comment and @delims.

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.b)

    p.v.setVisited()
    if trace: g.trace('visit',p.h)
        # Make sure v is never expanded again.
        # Suppress orphans check.
    if not at.thinFile:
        p.v.setWriteBit() # Mark the vnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    at.raw = False # 2007/07/04: Bug fix exposed by new sentinels.
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert next_i > i,'putBody'
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()

    if not trailingNewlineFlag:
        if at.writeVersion5:
            if at.sentinels:
                pass # Never write @nonl
            elif at.atAuto and not at.atEdit:
                at.onl() # 2010/08/01: bug fix: ensure newline here.
        else:
            if at.sentinels:
                at.putSentinel("@nonl")
            elif at.atAuto and not at.atEdit:
                # Ensure all @auto nodes end in a newline!
                at.onl()
#@+node:ekr.20041005105605.162: *6* << Make sure all lines end in a newline >>
@ If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if not trailingNewlineFlag:
        if (at.sentinels or 
            (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
        ):
            # g.trace('Added newline',repr(s))
            s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@+node:ekr.20041005105605.163: *6* << handle line at s[i] >> (putBody)
if trace: g.trace(repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            if at.raw or at.atAuto: # 2011/12/14: Ignore references in @auto.
                at.putCodeLine(s,i)
            else:
                hasRef,n1,n2 = at.findSectionName(s,i)
                if hasRef:
                    at.putRefLine(s,i,n1,n2,p)
                else:
                    at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif at.raw:
    if kind == at.endRawDirective:
        at.raw = False
        at.putSentinel("@@end_raw")
        i = g.skip_line(s,i)
    else:
        # Fix bug 784920: @raw mode does not ignore directives 
        at.putCodeLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert not at.pending,'putBody at.pending'
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode:
            if p == self.root:
                at.putAtAllLine(s,i,p)
            else:
                at.error('@all not valid in: %s' % (p.h))
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    # Fix bug 784920: @raw mode does not ignore directives 
    at.error('unmatched @end_raw directive: %s' % p.h)
    # at.raw = False
    # at.putSentinel("@@end_raw")
    # i = g.skip_line(s,i)
elif kind == at.startVerbatim:
    # Fix bug 778204: @verbatim not a valid Leo directive.
    if g.unitTesting:
        # A hack: unit tests for @shadow use @verbatim as a kind of directive.
        pass
    else:
        g.trace(at.atShadow)
        at.error('@verbatim is not a Leo directive: %s' % p.h)
    if 0: # Old code.  This is wrong: @verbatim is not a directive!
        at.putSentinel("@verbatim")
        at.putIndent(at.indent)
        i = next_i
        next_i = g.skip_line(s,i)
        at.os(s[i:next_i])
elif kind == at.miscDirective:
    # Fix bug 583878: Leo should warn about @comment/@delims clashes.
    if g.match_word(s,i,'@comment'):
        at_comment_seen = True
    elif g.match_word(s,i,'@delims'):
        at_delims_seen = True
    if at_comment_seen and at_delims_seen and not at_warning_given:
        at_warning_given = True
        at.error('@comment and @delims in node %s' % p.h)
    at.putDirective(s,i)
else:
    at.error('putBody: can not happen: unknown directive kind: %s' % kind)
#@+node:ekr.20111121084517.10189: *4* Remove all calls to w.see, w.seeInsertPoint, w.setYScrollPosition
# See "Scrolling bug" notes.
#@+node:ekr.20110605121601.18090: *5* see & seeInsertPoint (leoQTextEditWidget)
def see(self,i):

    if 0: # 2011/12/21
        self.widget.ensureCursorVisible()

def seeInsertPoint (self):

    if 0: # 2011/12/21
        self.widget.ensureCursorVisible()
#@+node:ekr.20111002125540.7021: *5* get/setYScrollPosition (LeoQTextBrowser)
def getYScrollPosition(self):

    w = self
    sb = w.verticalScrollBar()
    i = sb.sliderPosition()
    if g.app.trace_scroll: g.trace('(LeoQTextBrowser)',i)
    return i

def setYScrollPosition(self,pos):

    if 0: # 2011/12/21
        w = self
        sb = w.verticalScrollBar()
        if pos is None: pos = 0
        if g.app.trace_scroll: g.trace('(LeoQTextBrowser)',pos)
        sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18098: *5* setYScrollPosition (leoQTextEditWidget)
def setYScrollPosition(self,pos):
    
    # g.trace(pos)
    
    if 0: # 2011/12/21
        w = self.widget
        sb = w.verticalScrollBar()
        if g.app.trace_scroll: g.trace('(LeoQTextEditWidget)',pos)
        sb.setSliderPosition(pos)
#@+node:ekr.20120109111947.9962: *4* Fixed erroneous "file changed" message
@nocolor-node

has been modified outside of Leo. Overwrite this file?
http://groups.google.com/group/leo-editor/browse_thread/thread/daf581ace0de871e

Steps to reproduce:

- Create a node "@edit ~/aaa.txt" assuming aaa.txt does not exist
- Ctrl-S save outline, log reports creating ~/aaa.txt
- Edit text in body
- Ctrl-S save outline, pop-up pops-up erroneously.

The problem was that replaceTargetFileIfDifferent should set root.v.at_read.
Now it does.

Note: both replaceFileWithString methods are part of the @shadow logic,
so there is no need to set any at_read bit in those methods.
#@+node:ekr.20120110174009.9963: *4* Fixed bug 889175: Changing @auto paths overwrites files without warning
@nocolor-node

I loaded an outline with @auto nodes pointing to an out of date path. So body
texts were empty. I updated the paths in the node headlines and saved the file,
expecting to be prompted for overwriting the existing files (now the paths were
correct again), but they were over-written with the blank content without
warning. Damn.

Steps to reproduce in a simpler way below, but don't write the
below of as contrived, because the above is the real problem.

Create @auto /home/tbrown/text.txt

enter text, save file

Edit headline to @auto /home/tbrown/Desktop/text.txt

enter text, save file

Edit headline back to /home/tbrown/text.txt

-----

I now see this happens also if the path change is in a @path node ancestor of the @auto node.
#@+node:ekr.20120110174009.9965: *5* at.shouldPromptForDangerousWrite
def shouldPromptForDangerousWrite(self,fn,p):
    
    '''Return True if a prompt should be issued
    when writing p (an @<file> node) to fn.
    '''
    
    if not g.os_path_exists(fn):
        return False
            # No danger of overwriting fn.
    elif hasattr(p.v,'at_read'):
        return fn not in p.v.at_read
            # The path is new.
    else:
        return True
            # The file was never read.
#@+node:ekr.20120112084820.10001: *5* at.rememberReadPath
def rememberReadPath(self,fn,p):
    
    v = p.v
    
    if not hasattr(v,'at_read'):
        v.at_read = []
        
    if not fn in v.at_read:
        v.at_read.append(fn)
#@+node:ekr.20120110174009.9964: *5* Found: at_read
#@+node:ekr.20090225080846.5: *6* at.writeOneAtEditNode
def writeOneAtEditNode(self,p,toString,force=False):

    '''Write one @edit node.'''

    at = self ; c = at.c
    root = p.copy()
    c.endEditing()
    c.init_error_dialogs()

    fn = p.atEditNodeName()
    if not fn and not toString: return False

    if p.hasChildren():
        g.es('@edit nodes must not have children',color='red')
        g.es('To save your work, convert @edit to @auto or @thin')
        return False

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fn = c.os_path_finalize_join(at.default_directory,fn)
    if not force and at.shouldPromptForDangerousWrite(fn,root):
        # Prompt if writing a new @edit node would overwrite the existing file.
        ok = self.promptForDangerousWrite(fn,kind='@edit')
        if ok:
            # Fix bug 889175: Remember the full fileName.
            at.rememberReadPath(fn,root)
        else:
            g.es("not written:",fn)
            return False

    at.targetFileName = fn
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True, atEdit=True,
        nosentinels=True,thinFile=False,
        scriptWrite=False,toString=toString)

    # Compute the file's contents.
    # Unlike the @nosent file logic it does not add a final newline.
    contents = ''.join([s for s in g.splitLines(p.b)
        if at.directiveKind4(s,0) == at.noDirective])

    if toString:
        at.stringOutput = contents
        return True

    ok = at.openFileForWriting(root,fileName=fn,toString=False)
    if ok:
        self.os(contents)
        at.closeWriteFile()
    if ok and at.errors == 0:
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
    else:
        g.es("not written:",at.targetFileName) # 2010/10/22
        root.setDirty()
        root.setOrphan() # 2010/10/22
        
    c.raise_error_dialogs(kind='write')

    return ok
#@+node:ekr.20031218072017.3210: *6* createOutline (leoImport)
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    at = c.atFileCommands

    self.default_directory = g.setDefaultDirectory(c,parent,importing=False)
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    fileName = fileName.replace('\\','/') # 2011/11/25
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        if atShadow: kind = '@shadow '
        elif atAuto: kind = '@auto '
        else: kind = ''
        s,e = g.readFileIntoString(fileName,encoding=self.encoding,kind=kind)
        if s is None: return None
        if e: self.encoding = e

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        elif self.treeType is None:
            # 2010/09/29: by convention, we use the short file name.
            p.initHeadString(g.shortFileName(fileName))
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    if self.treeType == '@root': # 2010/09/29.
        self.rootLine = "@root-code "+self.fileName+'\n'
    else:
        self.rootLine = ''

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        s = s.replace('\r','')
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        s = s.replace('\r','')
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Fix bug 488894: unsettling dialog when saving Leo file
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName,p)

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
#@+node:ekr.20070807084545: *6* readOneAtAutoNode (leoImport)
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c ; at = c.atFileCommands
    
    fileName=p.atAutoNodeName()

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    self.createOutline(
        fileName=fileName,
        parent=p.copy(),
        atAuto=True)

    # 2010/01/15: Remember that we have read this file.
    # http://groups.google.com/group/leo-editor/browse_thread/thread/b77b5260854ffbf6
    # Important: createOutline usually sets the bit in the wrong node.
    
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName,p)

    # Force an update of the body pane.
    self.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
#@+node:ekr.20041005105605.21: *6* at.read & helpers
def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    trace = False and not g.unitTesting
    if trace: g.trace(root.h)
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    # Fix bug 760531: always mark the root as read, even if there was an error.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(at.fullPath(root),root)

    # Bug fix 2011/05/23: Restore orphan trees from the outline.
    if root.isOrphan():
        g.es("reading:",root.h)
        # g.warning('The outline contains an orphan node!\nRetaining the outline')
        g.es_print('orphan node in',root.h,color='red')
        g.es_print('retaining the data from the .leo file',color='blue')
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    at.fromString = fromString
    if at.errors:
        if trace: g.trace('Init error')
        return False

    fileName = at.openFileForReading(fromString=fromString)
        # For @shadow files, calls x.updatePublicAndPrivateFiles.
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    elif fromString: # 2010/09/02.
        pass
    else:
        if trace: g.trace('No inputFile')
        return False

    # Get the file from the cache if possible.
    if fromString:
        s,loaded,fileKey = fromString,False,None
    else:
        s,loaded,fileKey = c.cacher.readFile(fileName,root)
    # Never read an external file with file-like sentinels from the cache.
    isFileLike = loaded and at.isFileLike(s)
    if not loaded or isFileLike:
        # if trace: g.trace('file-like file',fileName)
        force = True # Disable caching.
    if loaded and not force:
        if trace: g.trace('in cache',fileName)
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    if isFileLike:
        if g.unitTesting:
            if 0: print("converting @file format in",root.h)
            g.app.unitTestDict['read-convert']=True
        else:
            g.es("converting @file format in",root.h,color='red')
    root.clearVisitedInTree()

    at.scanAllDirectives(root,importing=at.importing,reading=True)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding: **Important**: changed later
            #     by readOpenFile/at.scanHeader.
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width

    if trace: g.trace(repr(at.encoding),fileName)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
        # Calls at.scanHeader, which sets at.encoding.
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.deleteUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        at.copyAllTempBodyStringsToVnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if isFileLike and at.errors == 0: # Old-style sentinels.
        # 2010/02/24: Make the root @file node dirty so it will
        # be written automatically when saving the file.
        # Do *not* set the orphan bit here!
        root.clearOrphan()
        root.setDirty()
        c.setChanged(True) # Essential, to keep dirty bit set.
    elif at.errors > 0:
        # 2010/10/22: Dirty bits are *always* cleared.
        # Only the orphan bit is preserved.
        # root.setDirty() # 2011/06/17: Won't be preserved anyway
        root.setOrphan()
        # c.setChanged(True) # 2011/06/17.
    else:
        root.clearOrphan()
    if at.errors == 0 and not isFileLike and not fromString:
        c.cacher.writeFile(root,fileKey)

    if trace: g.trace('at.errors',at.errors)
    return at.errors == 0
#@+node:ekr.20041005105605.25: *7* at.deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
#@+node:ekr.20100122130101.6174: *7* at.deleteTnodeList
def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
#@+node:ekr.20071105164407: *7* at.deleteUnvisitedNodes & helpers
def deleteUnvisitedNodes (self,root):

    '''Delete unvisited nodes in root's subtree, not including root.

    Actually, instead of deleting the nodes, we move them to be children of the
    'Resurrected Nodes' r.
    '''

    at = self

    if not root.hasChildren():
        return

    # Carefully set up the arguments.
    aList = [z.copy() for z in root.subtree() if not z.isVisited()]
    if not aList: return

    r = at.createResurrectedNodesNode()
    assert r not in aList
    callback=at.defineResurrectedNodeCallback(r,root)

    # Now move the nodes.
    root.firstChild().deletePositionsInList(aList,callback)
#@+node:ekr.20100803073751.5817: *8* createResurrectedNodesNode
def createResurrectedNodesNode(self):

    '''Create a 'Resurrected Nodes' node as the last top-level node.'''

    at = self ; c = at.c ; tag = 'Resurrected Nodes'

    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()

    if last.h == tag:
        # The 'Resurrected Nodes' node already exists.
        p = last
    else:
        # Create the 'Resurrected Nodes' node after 'last'.
        p = last.insertAfter()
        p.setHeadString(tag)

    p.expand()
    return p
#@+node:ekr.20100803073751.5818: *8* defineResurrectedNodeCallback
def defineResurrectedNodeCallback (self,r,root):

    '''Define a callback that moves node p as r's last child.'''

    def callback(p,r=r.copy(),root=root):

        '''The resurrected nodes callback.'''

        child = r.insertAsLastChild()
        child.h = 'From %s' % root.h
        p.moveToLastChildOf(child)

        if g.unitTesting:
            # g.trace(p.h,r.h)
            pass 
        else:
            g.es('resurrected node:',p.h,color='red')
            g.es('in file:',root.h,color='blue')

    return callback


#@+node:ekr.20041005105605.22: *7* at.initFileName
def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "<string-file>"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName
#@+node:ekr.20100224050618.11547: *7* at.isFileLike
def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
#@+node:ekr.20041005105605.26: *6* at.readAll
def readAll(self,root,partialFlag=False):

    """Scan vnodes, looking for @<file> nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    force = partialFlag
    if partialFlag:
        # Capture the current headline only if
        # we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()

    scanned_tnodes = set()
    c.init_error_dialogs()

    if partialFlag: after = p.nodeAfterTree()    
    else: after = c.nullPosition()

    while p and p != after:
        gnx = p.gnx
        #skip clones
        if gnx in scanned_tnodes:
            p.moveToNodeAfterTree()
            continue
        scanned_tnodes.add(gnx)

        if not p.h.startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            if p.isAnyAtFileNode() :
                c.ignored_at_file_nodes.append(p.h)
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,force=force)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtEditNode():
            fileName = p.atEditNodeName()
            at.readOneAtEditNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p,force=force)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                # However, the dirty bit gets cleared.
                # p.setDirty() # 2011/06/17: won't be preserved anyway.
                    # Expensive, but it can't be helped.
                p.setOrphan() # 2010/10/22: the dirty bit gets cleared.
                # c.setChanged(True) # 2011/06/17
            p.moveToNodeAfterTree()
        else:
            if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
                at.rememberReadPath(at.fullPath(p),p)
            p.moveToThreadNext()

    # 2010/10/22: Preserve the orphan bits: the dirty bits will be cleared!
    #for v in c.all_unique_nodes():
    #    v.clearOrphan()

    if partialFlag and not anyRead and not g.unitTesting:
        g.es("no @<file> nodes in the selected tree")

    if use_tracer: tt.stop()
    
    c.raise_error_dialogs()  # 2011/12/17
#@+node:ekr.20070909100252: *6* at.readOneAtAutoNode
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # 2010/7/28: Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName,p)

    s,ok,fileKey = c.cacher.readFile(fileName,p)
    if ok:
        g.doHook('after-auto',c=c,p=p)
            # call after-auto callbacks
            # 2011/09/30: added call to g.doHook here.
        return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        c.cacher.writeFile(p,fileKey)
        g.doHook('after-auto',c=c,p=p)
            # call after-auto callbacks
            # 2011/09/30: add 'c' keyword arg.
#@+node:ekr.20090225080846.3: *6* at.readOneAtEditNode
def readOneAtEditNode (self,fn,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fn = c.os_path_finalize_join(at.default_directory,fn)
    junk,ext = g.os_path_splitext(fn)

    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn,p)

    if not g.unitTesting:
        g.es("reading @edit:", g.shortFileName(fn))

    s,e = g.readFileIntoString(fn,kind='@edit')
    if s is None: return
    encoding = g.choose(e is None,'utf-8',e)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    changed = c.isChanged()
    head = ''
    ext = ext.lower()
    if ext in ('.html','.htm'):   head = '@language html\n'
    elif ext in ('.txt','.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = '@language %s\n' % language
        else:
            head = '@nocolor\n'

    p.b = g.u(head) + g.toUnicode(s,encoding=encoding,reportErrors='True')

    if not changed: c.setChanged(False)
    g.doHook('after-edit',p=p)
#@+node:ekr.20080711093251.7: *6* at.readOneAtShadowNode
def readOneAtShadowNode (self,fn,p,force=False):

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn,p)

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fn = c.os_path_finalize_join(at.default_directory,fn)
    shadow_fn     = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
        
    if trace:
        g.trace('shadow_exists',shadow_exists,shadow_fn)

    if shadow_exists:
        at.read(p,atShadow=True,force=force)
    else:
        if not g.unitTesting: g.es("reading:",p.h)
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p,toString=False,force=True)
#@+node:ekr.20080712080505.1: *7* at.importAtShadowNode
def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True,atShadow=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
#@+node:ekr.20041005105605.27: *6* at.readOpenFile & helpers
def readOpenFile(self,root,theFile,fileName,deleteNodes=False):

    '''Read an open derived file.

    Leo 4.5 and later can only read 4.x derived files.'''

    trace = False and not g.unitTesting
    at = self

    firstLines,read_new,thinFile = at.scanHeader(theFile,fileName)
        # Important: this sets at.encoding, used by at.readLine.
    at.thinFile = thinFile
        # 2010/01/22: use *only* the header to set self.thinFile.

    if deleteNodes and at.shouldDeleteChildren(root,thinFile):
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName,root)
        while root.hasChildren():
            root.firstChild().doDelete()

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        firstLines = [] ; lastLines = []
        if at.atShadow:
            g.trace(g.callers())
            g.trace('invalid @shadow private file',fileName)
            at.error('invalid @shadow private file',fileName)
        else:
            at.error('can not read 3.x derived file',fileName)
            g.es('you may upgrade these file using Leo 4.0 through 4.4.x')
            g.trace('root',root and root.h,fileName)

    if root:
        root.v.setVisited() # Disable warning about set nodes.

    << handle first and last lines >>
    
    if trace: g.trace(at.encoding,fileName) # root.v.tempBodyString)

    return thinFile
#@+node:ekr.20041005105605.28: *7* << handle first and last lines >> (at.readOpenFile)
# The code below only deals with the root node!
# We terminate the root's body text if it exists.
# This is a hack to allow us to handle @first and @last.
v = root.v
tempString = hasattr(v,'tempBodyString') and v.tempBodyString or ''
tempList = hasattr(v,'tempBodyList') and ''.join(v.tempBodyList) or ''

if at.readVersion5:
    if hasattr(v,'tempBodyList'):
        body = tempList
        delattr(v,'tempBodyList') # So the change below "takes".
    elif hasattr(v,'tempBodyString'):
        body = tempString
        delattr(v,'tempBodyString')
    else:
        body = ''
else:
    body = tempString

lines = body.split('\n')

at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)

s = '\n'.join(lines).replace('\r', '')

# *Always* put the temp body text into at.v.tempBodyString.
v.tempBodyString = s
#@+node:ekr.20100122130101.6175: *7* at.shouldDeleteChildren
def shouldDeleteChildren (self,root,thinFile):

    '''Return True if we should delete all children before a read.'''

    # Delete all children except for old-style @file nodes

    if root.isAtNoSentFileNode():
        return False
    elif root.isAtFileNode() and not thinFile:
        return False
    else:
        return True
#@+node:ekr.20041005105605.117: *7* at.completeFirstDirective
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

    tag = "@first"
    foundAtFirstYet = 0
    outRange = range(len(out))
    j = 0
    for k in outRange:
        # skip leading whitespace lines
        if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @first directive
        i = 0
        if not g.match(out[k],i,tag): break
        foundAtFirstYet = 1
        # quit if no leading lines to apply
        if j >= len(firstLines): break
        # make the new @first directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
        leadingLine = " " + firstLines[j]
        out[k] = tag + leadingLine.rstrip() ; j += 1
#@+node:ekr.20041005105605.118: *7* at.completeLastDirectives
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

    tag = "@last"
    foundAtLastYet = 0
    outRange = range(-1,-len(out),-1)
    j = -1
    for k in outRange:
        # skip trailing whitespace lines
        if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @last directive
        i = 0
        if not g.match(out[k],i,tag): break
        foundAtLastYet = 1
        # quit if no trailing lines to apply
        if j < -len(lastLines): break
        # make the new @last directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
        trailingLine = " " + lastLines[j]
        out[k] = tag + trailingLine.rstrip() ; j -= 1
#@+node:ekr.20041005105605.154: *6* at.asisWrite
def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    c.init_error_dialogs()
    try:
        # Note: @asis always writes all nodes,
        # so there can be no orphan or ignored nodes.
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        # "look ahead" computation of eventual fileName.
        eventualFileName = c.os_path_finalize_join(
            at.default_directory,at.targetFileName)
        if at.shouldPromptForDangerousWrite(eventualFileName,root):
            # Prompt if writing a new @asis node would overwrite the existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind='@asis')
            if ok:
                # Fix bug 889175: Remember the full fileName.
                at.rememberReadPath(eventualFileName,root)
            else:
                g.es("not written:",eventualFileName)
                return
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            # openFileForWriting calls root.setDirty() if there are errors.
            return

        for p in root.self_and_subtree():
            << Write p's headline if it starts with @@ >>
            << Write p's body >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
        
    except Exception:
        at.writeException(root) # Sets dirty and orphan bits.

silentWrite = asisWrite # Compatibility with old scripts.
#@+node:ekr.20041005105605.155: *7* << Write p's headline if it starts with @@ >>
s = p.h

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) > 0:
        # at.outputFile is a fileLikeObject.
        s = g.toEncodedString(s,at.encoding,reportErrors=True)
        at.outputFile.write(s)
#@+node:ekr.20041005105605.156: *7* << Write p's body >>
s = p.b

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
#@+node:ekr.20041005105605.144: *6* at.write & helper
def write (self,root,
    kind = '@unknown', # Should not happen.
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
):
    """Write a 4.x derived file.
    root is the position of an @<file> node"""

    trace = False and not g.unitTesting
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString,
    )

    # "look ahead" computation of eventual fileName.
    eventualFileName = c.os_path_finalize_join(
        at.default_directory,at.targetFileName)

    if trace:
        g.trace('default_dir',
            g.os_path_exists(at.default_directory),
            at.default_directory)
        g.trace('eventual_fn',eventualFileName)

    if not scriptWrite and not toString:
        if at.shouldPromptForDangerousWrite(eventualFileName,root):
            # Prompt if writing a new @file or @thin node would
            # overwrite an existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind)
            if ok:
                at.rememberReadPath(eventualFileName,root)
            else:
                g.es("not written:",eventualFileName)
                << set dirty and orphan bits >> # 2010/10/21.
                return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        if trace: g.trace('open failed',eventualFileName)
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        assert root==at.root,'write'
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            if hasattr(self.root.v,'tnodeList'):
                delattr(self.root.v,'tnodeList')
            root.v._p_changed = True
        else:
            at.closeWriteFile()
            if at.errors > 0 or root.isOrphan():
                << set dirty and orphan bits >>
                g.es("not written:",at.outputFileName)
            else:
                # Fix bug 889175: Remember the full fileName.
                at.rememberReadPath(eventualFileName,root)
                at.replaceTargetFileIfDifferent(root)
                    # Sets/clears dirty and orphan bits.

    except Exception:
        if hasattr(self.root.v,'tnodeList'):
            delattr(self.root.v,'tnodeList')
        if toString:
            at.exception("exception preprocessing script")
            root.v._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145: *7* << set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
    if not at.targetFileName:
        # We have an @file node.
        at.targetFileName = root.atFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@+node:ekr.20041005105605.146: *7* << set dirty and orphan bits >>
# Setting the orphan and dirty flags tells Leo to write the tree..
root.setOrphan()
root.setDirty()
# Delete the temp file.
if at.outputFileName:
    self.remove(at.outputFileName) 

#@+node:ekr.20070806141607: *6* at.writeOneAtAutoNode
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName and not toString: return False

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    if not toString and at.shouldPromptForDangerousWrite(fileName,root):
        # Prompt if writing a new @auto node would overwrite the existing file.
        ok = self.promptForDangerousWrite(fileName,kind='@auto')
        if not ok:
            g.es("not written:",fileName)
            return

    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName,root)
    
    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)

    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    isAtAutoRst = root.isAtAutoRstNode()
    if ok:
        if isAtAutoRst:
            ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
            if not ok2: at.errors += 1
        else:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        # g.trace('at.errors',at.errors)
        if at.errors == 0:
            # g.trace('toString',toString,'force',force,'isAtAutoRst',isAtAutoRst)
            at.replaceTargetFileIfDifferent(root,ignoreBlankLines=isAtAutoRst)
                # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",fileName)
            root.setDirty() # New in Leo 4.4.8.
            root.setOrphan() # 2010/10/22.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        root.setOrphan() # 2010/10/22.
        g.es("not written:",fileName)

    return ok
#@+node:ekr.20080711093251.5: *6* at.writeOneAtShadowNode & helpers
def writeOneAtShadowNode(self,p,toString,force):

    '''Write p, an @shadow node.

    File indices *must* have already been assigned.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController
    root = p.copy() 

    fn = p.atShadowFileNodeName()
    if trace: g.trace(p.h,fn)
    if not fn:
        g.es_print('can not happen: not an @shadow node',p.h,color='red')
        return False

    # A hack to support unknown extensions.
    self.adjustTargetLanguage(fn) # May set c.target_language.

    fn = at.fullPath(p)
    at.default_directory = g.os_path_dirname(fn)

    # Bug fix 2010/01/18: Make sure we can compute the shadow directory.
    private_fn = x.shadowPathName(fn)
    if not private_fn:
        return False

    if not toString and at.shouldPromptForDangerousWrite(fn,root):
        # Prompt if writing a new @shadow node would overwrite the existing public file.
        ok = self.promptForDangerousWrite(fn,kind='@shadow')
        if ok:
            # Fix bug 889175: Remember the full fileName.
            at.rememberReadPath(fn,root)
        else:
            g.es("not written:",fn)
            return

    c.endEditing() # Capture the current headline.

    at.initWriteIvars(root,targetFileName=None, # Not used.
        atShadow=True,
        nosentinels=None, # set below.  Affects only error messages (sometimes).
        thinFile=True, # New in Leo 4.5 b2: private files are thin files.
        scriptWrite=False,
        toString=False, # True: create a fileLikeObject.  This is done below.
        forcePythonSentinels=True) # A hack to suppress an error message.
            # The actual sentinels will be set below.
            
    # g.trace('encoding',repr(at.encoding))

    # Bug fix: Leo 4.5.1: use x.markerFromFileName to force the delim to match
    #                     what is used in x.propegate changes.
    marker = x.markerFromFileName(fn)
    at.startSentinelComment,at.endSentinelComment=marker.getDelims()

    if g.app.unitTesting: ivars_dict = g.getIvarsDict(at)

    # Write the public and private files to public_s and private_s strings.
    data = []
    for sentinels in (False,True):
        # 2011/09/09: specify encoding explicitly.
        theFile = at.openStringFile(fn,encoding=at.encoding)
        at.sentinels = sentinels
        at.writeOpenFile(root,
            nosentinels=not sentinels,toString=False)
            # nosentinels only affects error messages, and then only if atAuto is True.
        s = at.closeStringFile(theFile)
        data.append(s)

    # Set these new ivars for unit tests.
    at.public_s, at.private_s = data

    if g.app.unitTesting:
        exceptions = ('public_s','private_s','sentinels','stringOutput')
        assert g.checkUnchangedIvars(at,ivars_dict,exceptions),'writeOneAtShadowNode'

    if at.errors == 0 and not toString:
        # Write the public and private files.
        if trace: g.trace('writing',fn)
        x.makeShadowDirectory(fn) # makeShadowDirectory takes a *public* file name.
        at.replaceFileWithString(private_fn,at.private_s)
        at.replaceFileWithString(fn,at.public_s)

    self.checkPythonCode(root,s=at.private_s,targetFn=fn)

    if at.errors == 0:
        root.clearOrphan()
        root.clearDirty()
    else:
        g.es("not written:",at.outputFileName,color='red')
        root.setDirty() # New in Leo 4.4.8.
        root.setOrphan() # 2010/10/22.

    return at.errors == 0
#@+node:ekr.20080819075811.13: *7* adjustTargetLanguage
def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
#@+node:ekr.20041005105605.212: *6* replaceTargetFileIfDifferent (atFile)
def replaceTargetFileIfDifferent (self,root,ignoreBlankLines=False):

    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.

    Return True if the original file was changed.
    '''

    trace = False and not g.unitTesting
    c = self.c ; at = c.atFileCommands

    assert(self.outputFile is None)

    if self.toString:
        # Do *not* change the actual file or set any dirty flag.
        self.fileChangedFlag = False
        return False

    if root:
        # The default: may be changed later.
        root.clearOrphan()
        root.clearDirty()

    if trace: g.trace(
        'ignoreBlankLines',ignoreBlankLines,
        'target exists',g.os_path_exists(self.targetFileName),
        self.outputFileName,self.targetFileName)

    if g.os_path_exists(self.targetFileName):
        if self.compareFiles(
            self.outputFileName,
            self.targetFileName,
            ignoreLineEndings=not self.explicitLineEnding,
            ignoreBlankLines=ignoreBlankLines):
            # Files are identical.
            ok = self.remove(self.outputFileName)
            if trace: g.trace('files are identical')
            if ok:
                g.es('unchanged:',self.shortFileName)
            else:
                g.es('error writing',self.shortFileName,color='red')
                g.es('not written:',self.shortFileName)
                if root:
                    root.setDirty() # New in 4.4.8.
                    root.setOrphan() # 2010/10/22.
            self.fileChangedFlag = False
            return False
        else:
            # A mismatch.
            self.checkPythonCode(root)
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                c.setFileTimeStamp(self.targetFileName)
                g.es('wrote:',self.shortFileName)
            else:
                g.es('error writing',self.shortFileName,color='red')
                g.es('not written:',self.shortFileName)
                if root:
                    root.setDirty() # New in 4.4.8.
                    root.setOrphan() # 2010/10/22.

            self.fileChangedFlag = ok
            return ok
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            c.setFileTimeStamp(self.targetFileName)
            g.es('created:',self.targetFileName)
            if root:
                # Fix bug 889175: Remember the full fileName.
                at.rememberReadPath(self.targetFileName,root)
        else:
            # self.rename gives the error.
            if root:
                root.setDirty() # New in 4.4.8.
                root.setOrphan() # 2010/10/22.

        # No original file to change. Return value tested by a unit test.
        self.fileChangedFlag = False 
        return False
#@+node:ekr.20041019090322: *7* << report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in:",self.targetFileName,color="blue")
#@+node:ekr.20120116060011.13558: *4* Fixed bug in DynamicWindow.setGeometry
@nocolor-node

DynamicWindow.setGeometry now does *not* change the window size when using the qttabs gui.

Added a comment to this effect in leoSettings.leo.
#@+node:ekr.20110605121601.18178: *5* setGeometry (DynamicWindow)
def setGeometry (self,rect):
    
    '''Set the window geometry, but only once when using the qttabs gui.'''

    # g.trace('(DynamicWindow)',rect,g.callers())
    
    if g.app.qt_use_tabs:
        m = self.leo_master
        assert self.leo_master
    
        # Only set the geometry once, even for new files.
        if not hasattr(m,'leo_geom_inited'):
            m.leo_geom_inited = True
            self.leo_master.setGeometry(rect)
            QtGui.QMainWindow.setGeometry(self,rect)
    else:
        QtGui.QMainWindow.setGeometry(self,rect)
#@+node:ekr.20111024170505.16459: *4* Fixed bug 87933: Redefining a key binding breaks menu items with same binding
@nocolor-node

What I did:
    
- Fixed the Shift-Tab buglet by adding lower-case entries in app.tkNamesList
    This matches what is done in k.settingsNameDict.
- Created << define global key dicts >> in leoApp.py.
- Changed si.val to si.stroke.
- Replaced g.bunch by GeneralSetting & ShortcutInfo.
- Replaced bunchList by aList.
- Removed dynamic_menus "compile-time" constant.
- onAboutToShow now recomputes the contents of menus whenever menus are invoked.
- leo_update_shortcut now shows all shortcuts for a command.
- Wrote and tested make_settings_dict
#@+node:ekr.20120128103510.13674: *5*  Report
@nocolor-node

Bug 879331: Redefining a key binding breaks menu items with same binding

https://bugs.launchpad.net/leo-editor/+bug/879331

> Now I understand.  If I override the shortcut associated with the menu
> item, in this case Alt-A, the menu breaks.

This is a serious bug!  The menu item now executes the command bound
to Alt-A!  Very bad.

=========

http://groups.google.com/group/leo-editor/browse_thread/thread/762e832909c3c530/d99d48eed45d1061

http://mail.google.com/mail/#inbox/1331909dd653f3c9

Redefining a binding, say for Alt-a, in x.leo will cause the sort-siblings menu
(bound to alt-a) to execute the command specified by the command bound to Alt-a!

https://bugs.launchpad.net/leo-editor/+bug/815564

This anomaly only occurs when all of the following conditions are true:

1) There is a global command name X that is the "same" as the root name of the
file containing a plugin Y. Here, "same" means equal after the command name is
converted to lower case and all underlines in the root name are replaced by
dashes.

2) A shortcut (a.k.a. keystroke) is bound to command name X.

When these conditions are true, then the Plugins dropdown menu shows the key
binding next to the plugin name and left-clicking the plugin name executes the
global command--and, there is no way to display the plugin's help.

Plugin Help Rendering: Plugin help is rendered by the viewrendered plugin, not
by the old scrolledmessage.py plugin.

Leo-editor revision: 4433
OS: Ubuntu 11.04 (natty)

Startup log pane:
Leo Log Window
Leo 4.9 final, build 4411, June 21, 2011
Python 2.7.1, qt version 4.7.2
linux2
#@+node:ekr.20120128103510.13676: *6* Bug 815564: Plugin Menu-Keystroke binding can prevent plugin help display
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/815564

===== Probably the same as bug 879331 =====

This anomaly only occurs when all of the following conditions are true:

1) There is a global command name X that is the "same" as the root name of the
file containing a plugin Y. Here, "same" means equal after the command name is
converted to lower case and all underlines in the root name are replaced by
dashes.

2) A shortcut (a.k.a. keystroke) is bound to command name X.

When these conditions are true, then the Plugins dropdown menu shows the key
binding next to the plugin name and left-clicking the plugin name executes the
global command--and, there is no way to display the plugin's help.

Plugin Help Rendering: Plugin help is rendered by the viewrendered plugin, not
by the old scrolledmessage.py plugin.

Leo-editor revision: 4433
OS: Ubuntu 11.04 (natty)

Startup log pane:
Leo Log Window
Leo 4.9 final, build 4411, June 21, 2011
Python 2.7.1, qt version 4.7.2
linux2
#@+node:ekr.20120129174505.10242: *5* New
#@+node:ekr.20120123143207.10223: *6* << GeneralSetting >> & isGeneralSetting
class GeneralSetting:
    
    '''A class representing any kind of setting except shortcuts.'''
    
    def __init__ (self,kind,encoding=None,ivar=None,setting=None,val=None,path=None,tag='setting'):
    
        self.encoding = encoding
        self.ivar = ivar
        self.kind = kind
        self.path = path
        self.setting = setting
        self.val = val
        self.tag = tag
        
    def __repr__ (self):
        
        result = ['GeneralSetting kind: %s' % (self.kind)]
        ivars = ('ivar','path','setting','val','tag')
        for ivar in ivars:
            if hasattr(self,ivar):
                val =  getattr(self,ivar)
                if val is not None:
                    result.append('%s: %s' % (ivar,val))
        return ','.join(result)
        
def isGeneralSetting(obj):
    return isinstance(obj,GeneralSetting)
#@+node:ekr.20120123115816.10209: *6* class ShortcutInfo
# bindKey:            ShortcutInfo(kind,commandName,func,pane)
# bindKeyToDict:      ShortcutInfo(kind,commandName,func,pane,stroke)
# createModeBindings: ShortcutInfo(kind,commandName,func,nextMode,stroke)

class ShortcutInfo:
    
    '''A class representing any kind of key binding line.
    
    This includes other information besides just the KeyStroke.'''
        
    @others
#@+node:ekr.20120129040823.10254: *7*  ctor (ShortcutInfo)
def __init__ (self,kind,commandName='',func=None,nextMode=None,pane=None,stroke=None):
    
    trace = False and commandName=='new' and not g.unitTesting

    if not (stroke is None or isinstance(stroke,KeyStroke)):
        g.trace('***** (ShortcutInfo) oops',repr(stroke))

    self.kind = kind
    self.commandName = commandName
    self.func = func
    self.nextMode = nextMode
    self.pane = pane
    self.stroke = stroke
        # The *caller* must canonicalize the shortcut.
        # Eventually, we might assert stroke is None or isinstance(stroke,KeyStroke)

    if trace: g.trace('(ShortcutInfo)',commandName,stroke,g.callers())
#@+node:ekr.20120203153754.10031: *7* __hash__ (ShortcutInfo)
def __hash__ (self):
    
    return self.stroke.__hash__() if self.stroke else 0
#@+node:ekr.20120125045244.10188: *7* __repr__ & ___str_& dump (ShortcutInfo)
def __repr__ (self):
    
    return self.dump()

__str__ = __repr__

def dump (self):
    si = self    
    result = ['ShortcutInfo %17s' % (si.kind)]
    # Print all existing ivars.
    table = ('commandName','func','nextMode','pane','stroke')
    for ivar in table:
        if hasattr(si,ivar):
            val =  getattr(si,ivar)
            if val not in (None,'none','None',''):
                if ivar == 'func': val = val.__name__
                s = '%s %s' % (ivar,val)
                result.append(s)
    return '[%s]' % ' '.join(result).strip()
#@+node:ekr.20120129040823.10226: *7* isModeBinding
def isModeBinding (self):
    
    return self.kind.startswith('*mode')
#@+node:ekr.20120124042346.12937: *6* define_enable_table
def define_enable_dict (self):
    
    c = self.c
    
    if not c.commandsDict:
        return # This is not an error: it happens during init.

    self.enable_dict = d = {
    
        # File menu...
            # 'revert':         True, # Revert is always enabled.               
        'open-with':            g.app.hasOpenWithMenu,
        
        # Edit menu...
        'undo':                 c.undoer.canUndo,
        'redo':                 c.undoer.canRedo,
        'extract-names':        c.canExtractSectionNames,
        'extract':              c.canExtract,
        'match-brackets':       c.canFindMatchingBracket,
        
        # Top-level Outline menu...
        'cut-node':             c.canCutOutline,
        'delete-node':          c.canDeleteHeadline,
        'paste-node':           c.canPasteOutline,
        'paste-retaining-clones':   c.canPasteOutline,
        'clone-node':           c.canClone,
        'sort-siblings':        c.canSortSiblings,
        'hoist':                c.canHoist,
        'de-hoist':             c.canDehoist,
        
        # Outline:Expand/Contract menu...
        'contract-parent':      c.canContractParent,
        'contract-node':        lambda: c.p.hasChildren() and c.p.isExpanded(),
        'contract-or-go-left':  lambda: c.p.hasChildren() and c.p.isExpanded() or c.p.hasParent(),
        'expand-node':          lambda: c.p.hasChildren() and not c.p.isExpanded(),
        'expand-prev-level':    lambda: c.p.hasChildren() and c.p.isExpanded(),
        'expand-next-level':    lambda: c.p.hasChildren(),
        'expand-to-level-1':    lambda: c.p.hasChildren() and c.p.isExpanded(),
        'expand-or-go-right':   lambda: c.p.hasChildren(),
        
        # Outline:Move menu...
        'move-outline-down':    lambda: c.canMoveOutlineDown(),
        'move-outline-left':    lambda: c.canMoveOutlineLeft(),
        'move-outline-right':   lambda: c.canMoveOutlineRight(),
        'move-outline-up':      lambda: c.canMoveOutlineUp(),
        'promote':              lambda: c.canPromote(),
        'demote':               lambda: c.canDemote(),
        
        # Outline:Go To menu...
        'goto-prev-history-node':   lambda: c.nodeHistory.canGoToPrevVisited(),
        'goto-next-history-node':   lambda: c.nodeHistory.canGoToNextVisited(),
        'goto-prev-visible':        lambda: c.canSelectVisBack(),
        'goto-next-visible':        lambda: c.canSelectVisNext(),
        # These are too slow...
            # 'go-to-next-marked':  c.canGoToNextMarkedHeadline,
            # 'go-to-next-changed': c.canGoToNextDirtyHeadline,
        'goto-next-clone':          lambda: c.p.isCloned(),
        'goto-prev-node':           lambda: c.canSelectThreadBack(),
        'goto-next-node':           lambda: c.canSelectThreadNext(),
        'goto-parent':              lambda: c.p.hasParent(),
        'goto-prev-sibling':        lambda: c.p.hasBack(),
        'goto-next-sibling':        lambda: c.p.hasNext(),
        
        # Outline:Mark menu...
        'mark-subheads':            lambda: c.p.hasChildren(),
        # too slow...
            # 'mark-changed-items':   c.canMarkChangedHeadlines,
    }
    
    for i in range(1,9):
        d ['expand-to-level-%s' % (i)] = lambda: c.p.hasChildren()

    if 0: # Initial testing.
        commandKeys = list(c.commandsDict.keys())
        for key in sorted(d.keys()):
            if key not in commandKeys:
                g.trace('*** bad entry for %s' % (key))
#@+node:ekr.20120122070219.10162: *6* make_shortcuts_dicts (g.app.config) & helpers
def make_shortcuts_dicts (self,c,d,localFlag):
    
    '''Make all settings dicts related to c and d.
    
    return the newly-made local dict or None.'''
    
    trace = False and not g.unitTesting
    fn = c.shortFileName().lower()
    result = {} # The newly-made local dict, or {} for non-local files.
    test_result = [] # For unit tests.
    
    def message(d,name):
        return '%4s keys %s' % (len(list(d.keys())),name)

    # g.trace('self',self)
    # g.trace('c',c)
    # g.trace('c.config',c.config)
    # g.trace('make_shortcuts_dict',len(list(d.keys())),g.callers())

    if fn == 'leosettings.leo':
        if not g.app.config.immutable_leo_settings_shortcuts_dict:
            if trace: g.trace(message(d,'immutable_leo_settings_shortcuts_dict'))
            g.app.config.immutable_leo_settings_shortcuts_dict = d
    elif fn == 'myleosettings.leo':
        if not g.app.config.immutable_my_leo_settings_shortcuts_dict:
            if trace: g.trace(message(d,'immutable_my_leo_settings_shortcuts_dict'))
            g.app.config.immutable_my_leo_settings_shortcuts_dict = d
        if localFlag:
            if trace: message(d,'settingsDict: %s' % (fn))
            d1 = g.app.config.immutable_leo_settings_shortcuts_dict
            d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
            d3 = self.settingsDict = self.merge_settings_dicts(d1,d2)
            result = d3
            if trace: g.trace(message(d3,'result: %s' % (fn)))
            test_result = (d1,d2,d3,'myLeoSettings.leo')
    else:
        if trace: g.trace(message(d,'settingsDict: %s' % (fn)))
        d1 = g.app.config.immutable_leo_settings_shortcuts_dict
        d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
        d3 = self.merge_settings_dicts(d1,d2)
        d4 = self.settingsDict = self.merge_settings_dicts(d3,d)
        result = d4
        test_result = ((d1,d2,d3,'local 1'),(d3,d,d4,'local 2'),)
        
    g.app.unitTestDict['make_shortcuts_dicts'] = test_result
    return result
#@+node:ekr.20120122070219.10163: *7* merge_settings_dicts (g.app.config)
def merge_settings_dicts (self,old_d,new_d):
    
    '''Create a new dict by overriding all settings in old_d by setting in new_d.
    
    Both old_d and new_d remain unchanged.'''
    
    trace = False and not g.unitTesting
    
    if not old_d: return new_d
    if not new_d: return old_d
    
    if trace:
        new_n,old_n = len(list(new_d.keys())),len(list(old_d.keys()))
        g.trace('new %4s %s %s' % (new_n,id(new_d),new_d.name()))
        g.trace('old %4s %s %s' % (old_n,id(old_d),old_d.name()))

    inverted_old_d = self.invert(old_d)
    inverted_new_d = self.invert(new_d)
    inverted_old_d.update(inverted_new_d) # Updates inverted_old_d in place.
    result = self.uninvert(inverted_old_d)
    return result
#@+node:ekr.20120125045244.10186: *7* invert (g.app.config)
def invert (self,d):
    
    '''Invert a shortcut dict whose keys are command names,
    returning a dict whose keys are strokes.'''
    
    trace = False and not g.unitTesting ; verbose = True
    if trace: g.trace('*'*40,d.name())
    
    result = g.TypedDictOfLists(
        name='inverted %s' % d.name(),
        keyType = leoKeys.KeyStroke,
        valType = leoKeys.ShortcutInfo)

    for commandName in d.keys():
        for si in d.get(commandName,[]):
            # This assert can fail if there is an exception in the ShortcutInfo ctor.
            assert isinstance(si,leoKeys.ShortcutInfo),si

            stroke = si.stroke # This is canonicalized.
            si.commandName = commandName # Add info.
            assert stroke
            if trace and verbose:
                g.trace('%40s %s' % (commandName,stroke))
            result.add(stroke,si)

    if trace: g.trace('returns  %4s %s %s' % (
        len(list(result.keys())),id(d),result.name()))
    return result
#@+node:ekr.20120125045244.10187: *7* uninvert (g.app.config)
def uninvert (self,d):
    
    '''Uninvert an inverted shortcut dict whose keys are strokes,
    returning a dict whose keys are command names.'''
    
    trace = False and not g.unitTesting ; verbose = True
    if trace and verbose: g.trace('*'*40)

    assert d.keyType == leoKeys.KeyStroke,d.keyType
    result = g.TypedDictOfLists(
        name='uninverted %s' % d.name(),
        keyType = type('commandName'),
        valType = leoKeys.ShortcutInfo)
    
    for stroke in d.keys():
        for si in d.get(stroke,[]):
            assert isinstance(si,leoKeys.ShortcutInfo),si
            commandName = si.commandName
            if trace and verbose:
                g.trace('uninvert %20s %s' % (stroke,commandName))
            assert commandName
            result.add(commandName,si)

    if trace: g.trace('returns %4s %s %s' % (
        len(list(result.keys())),id(d),result.name()))
    return result
#@+node:ekr.20120124103240.10250: *5* Changed
#@+node:ekr.20061031131434.3: *6* << about key dicts >>
@nocolor
@

ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           lists of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     Interior masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:

(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) Interior masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
#@+node:ekr.20031218072017.1723: *6* createMenuEntries (leoMenu) & helpers
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    c = self.c ; k = c.k
    if g.app.unitTesting: return
    if not menu: return
    
    self.traceMenuTable(table)

    for data in table:
        label,command,done = self.getMenuEntryInfo(data,menu)
        if done: continue
        commandName = self.getMenuEntryBindings(command,dynamicMenu,label)
        if not commandName: continue
            
        masterMenuCallback = self.createMasterMenuCallback(
            dynamicMenu,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")

        # c.add_command ensures that c.outerUpdate is called.
        c.add_command(menu,label=realLabel,
            accelerator='', # The accelerator is now computed dynamically.
            command=masterMenuCallback,
            commandName=commandName,
            underline=amp_index)
#@+node:ekr.20111102072143.10016: *7* createMasterMenuCallback
def createMasterMenuCallback(self,dynamicMenu,command,commandName):
    
    trace = False and not g.unitTesting
    c = self.c
    
    def setWidget():
        w = c.frame.getFocus()
        if w and sys.platform.startswith('darwin'):
             # 2012/01/11: redirect (MacOS only).
            wname = c.widget_name(w) or ''
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        return w

    if dynamicMenu:
        if command:
            def masterDynamicMenuCallback (c=c,command=command):
                # 2012/01/07: set w here.
                w = setWidget()
                if trace: g.trace(command.__name__,w) 
                event = g.app.gui.create_key_event(c,None,None,w)
                return c.k.masterCommand(func=command,event=event)
            return masterDynamicMenuCallback
        else:
            g.internalError('no callback for dynamic menu item.')
            def dummyMasterMenuCallback():
                pass
            return dummyMasterMenuCallback
    else:
        def masterStaticMenuCallback (c=c,commandName=commandName):
            # 2011/10/28: Use only the command name to dispatch the command.
            # 2012/01/07: Bug fix: set w here.
            w = setWidget()
            if trace: g.trace(commandName,w)
            event = g.app.gui.create_key_event(c,None,None,w)
            return c.k.masterCommand(commandName=commandName,event=event)
        return masterStaticMenuCallback
#@+node:ekr.20111028060955.16568: *7* getMenuEntryBindings
def getMenuEntryBindings(self,command,dynamicMenu,label):
    
    '''Compute commandName from command.'''

    trace = False and not g.unitTesting
    c = self.c

    if type(command) == type(''):
        # Command is really a command name.
        commandName = command 
    else:
        # First, get the old-style name.
        commandName = self.computeOldStyleShortcutKey(label)
        
    command = c.commandsDict.get(commandName)
        
    if trace and not command and not dynamicMenu:
        # This may come from a plugin that normally isn't enabled.
        g.trace('No inverse for %s' % commandName)
        
    return commandName
#@+node:ekr.20111028060955.16565: *7* getMenuEntryInfo
def getMenuEntryInfo (self,data,menu):
    
    done = False

    if g.isString(data):
        # A single string is both the label and the command.
        s = data
        removeHyphens = s and s[0]=='*'
        if removeHyphens: s = s[1:]
        label = self.capitalizeMinibufferMenuName(s,removeHyphens)
        command = s.replace('&','').lower()
        if label == '-':
            self.add_separator(menu)
            done = True # That's all.
    else:
        ok = type(data) in (type(()), type([])) and len(data) in (2,3)
        if ok:
            if len(data) == 2:
                # Command can be a minibuffer-command name.
                label,command = data
            else:
                # Ignore shortcuts bound in menu tables.
                label,junk,command = data
    
            if label in (None,'-'):
                self.add_separator(menu)
                done = True # That's all.
        else:
            g.trace('bad data in menu table: %s' % repr(data))
            done = True # Ignore bad data
            
    return label,command,done
#@+node:ekr.20111028060955.16563: *7* traceMenuTable
def traceMenuTable (self,table):
    
    trace = False and not g.unitTesting
    
    if not trace: return
    format = '%40s %s'
    g.trace('*'*40,g.callers())
    for data in table:
        if type(data) in (type(()), type([])):
            n = len(data)
            if n == 2:
                print(format % (data[0],data[1]))
            elif n == 3:
                name,junk,func = data
                print(format % (name,func and func.__name__ or '<NO FUNC>'))
        else:
            print(format % (data,''))
#@+node:ekr.20041117062717.14: *6* getShortcut (g.app.config)
def getShortcut (self,c,commandName):

    '''Return rawKey,accel for shortcutName'''
    
    trace = False and not g.unitTesting # and commandName in ('new','print-bindings')

    key = c.frame.menu.canonicalizeMenuName(commandName)
    key = key.replace('&','') # Allow '&' in names.

    # New code: use the dicts created by make_settings_dict.
    table = (
        ('local',            c and self.localShortcutsDict.get(c.hash(),{})),
        ('myLeoSettings.leo',g.app.config.immutable_my_leo_settings_shortcuts_dict),
        ('leoSettings.leo',  g.app.config.immutable_leo_settings_shortcuts_dict),
    )
    aList = []
    for tag,d in table:
        if d:
            if trace: g.trace(tag,len(list(d.keys())))
            aList = d.get(commandName,[])
            if aList:
                for si in aList:
                    assert isinstance(si,leoKeys.ShortcutInfo),si
                break
                
    # It's very important to filter empty strokes here.
    aList = [si for si in aList
        if si.stroke and si.stroke.lower() != 'none']

    if trace: g.trace('getShortcut',tag,aList)

    return key,aList
#@+node:ekr.20041227063801.2: *6* initDicts
def initDicts (self):

    # Only the settings parser needs to search all dicts.
    self.dictList = [self.defaultsDict]

    for key,kind,val in self.defaultsData:
        self.defaultsDict[self.munge(key)] = GeneralSetting(
            kind,setting=key,val=val,tag='defaults')

    for key,kind,val in self.ivarsData:
        self.ivarsDict[self.munge(key)] = GeneralSetting(
            kind,ivar=key,val=val,tag='ivars')

    for key,kind,val in self.encodingIvarsData:
        self.encodingIvarsDict[self.munge(key)] = GeneralSetting(
            kind,encoding=val,ivar=key,tag='encoding')
#@+node:ekr.20061031131434.89: *6* k.bindKey & helpers
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False,tag=None):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    tag gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    if not k.check_bind_key(pane,shortcut):
        return False

    aList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %17s %s' % (pane,shortcut,tag,commandName))
    try:
        if not shortcut:
            stroke = None
        elif k.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s,stroke
        else:
            stroke = k.strokeFromSetting(shortcut)

        si = k.ShortcutInfo(kind=tag,pane=pane,
            func=callback,commandName=commandName,stroke=stroke)
    
        if shortcut: #####
            k.bindKeyToDict(pane,shortcut,si)
        if not modeFlag:
            if shortcut:
                k.remove_conflicting_definitions(aList,pane,shortcut)
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict [stroke] = aList
            if trace: g.trace(shortcut,aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20120130074511.10228: *7* k.check_bind_key
def check_bind_key(self,pane,shortcut):
    
    if not shortcut:
        return False

    k = self
    assert k.isStroke(shortcut)

    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter','leave'):
        if shortcut.lower().find(s) > -1:
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return False

    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    else:
        return True
#@+node:ekr.20120130074511.10227: *7* k.kill_one_shortcut
def kill_one_shortcut (self,stroke):
    
    '''Update the dicts so that c.config.getShortcut(name) will return None
    for all names *presently* bound to the stroke.'''
    
    k = self ; c = k.c
    
    # A crucial shortcut: inverting and uninverting dictionaries is slow.
    # Important: the comparison is valid regardless of the type of stroke.
    if stroke in (None,'None','none'):
        return
        
    assert k.isStroke(stroke),stroke
    
    # g.trace(stroke)

    d = g.app.config.localShortcutsDict.get(c.hash())
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=k.ShortcutInfo)

    inv_d = g.app.config.invert(d)
    aList = inv_d.get(stroke,[])
    inv_d[stroke] = []
    g.app.config.localShortcutsDict[c.hash()] = g.app.config.uninvert(inv_d)
#@+node:ekr.20061031131434.92: *7* k.remove_conflicting_definitions
def remove_conflicting_definitions (self,aList,pane,shortcut):
    
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert k.isShortcutInfo(si),si
        if pane in ('button','all',si.pane):
            if trace: g.trace('removing %s' % (si.dump()))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    aList = result
    
    # aList = [si for si in aList if pane not in ('button','all',si.pane)]
#@+node:ekr.20061031131434.93: *7* k.bindKeyToDict
def bindKeyToDict (self,pane,stroke,si):
    
    '''Update k.masterBindingsDict for the stroke.'''

    trace = False and not g.unitTesting
        # and stroke.lower().find('tab') != -1 
    k = self
    
    assert k.isStroke(stroke),stroke
    
    # New in Leo 4.4.1: Allow redefintions.
    d = k.masterBindingsDict.get(pane,{})
    d[stroke] = si
    k.masterBindingsDict [pane] = d
    
    if trace: g.trace(pane,stroke,commandName)
#@+node:ekr.20061031131434.94: *7* k.bindOpenWith
def bindOpenWith (self,shortcut,name,data):

    '''Register an open-with command.'''

    k = self ; c = k.c
    
    # g.trace(shortcut,name)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
#@+node:ekr.20120120095156.10260: *6* leo_update_shortcut
def leo_update_shortcut(self,action,commandName):
    
    trace = False and not g.unitTesting
    c = self.c ; k = c.k
    
    if action:
        s = action.text()
        parts = s.split('\t')
        if len(parts) >= 2: s = parts[0]
        key,aList = c.config.getShortcut(commandName)
        if aList:
            result = []
            for si in aList:
                assert k.isShortcutInfo(si),si
                # Don't show mode-related bindings.
                if not si.isModeBinding():
                    accel = k.prettyPrintKey(si.stroke)
                    if trace: g.trace('%20s %s' % (accel,si.dump()))
                    result.append(accel)
                    # Break here if we want to show only one accerator.
            action.setText('%s\t%s' % (s,', '.join(result)))
        else:
            action.setText(s)
    else:
        g.trace('can not happen: no action for %s' % (commandName))
#@+node:ekr.20110605121601.18460: *6* onAboutToShow & helpers (qtMenuWrapper)
def onAboutToShow(self,*args,**keys):
    
    trace = False and not g.unitTesting ; verbose = True
    name = self.leo_menu_label
    if not name: return

    for action in self.actions():
        commandName = hasattr(action,'leo_command_name') and action.leo_command_name
        if commandName:
            if trace: g.trace(commandName)
            self.leo_update_shortcut(action,commandName)
            self.leo_enable_menu_item(action,commandName)
            self.leo_update_menu_label(action,commandName)
   
#@+node:ekr.20120120095156.10261: *7* leo_enable_menu_item
def leo_enable_menu_item (self,action,commandName):

    func = self.c.frame.menu.enable_dict.get(commandName)

    if action and func:
        val = func()
        # g.trace('%5s %20s %s' % (val,commandName,val))
        action.setEnabled(bool(val))
        
#@+node:ekr.20120124115444.10190: *7* leo_update_menu_label
def leo_update_menu_label(self,action,commandName):
    
    c = self.c
    
    if action and commandName == 'mark':
        action.setText('UnMark' if c.p.isMarked() else 'Mark')
        self.leo_update_shortcut(action,commandName)
            # Set the proper shortcut.
#@+node:ekr.20120120095156.10260: *7* leo_update_shortcut
def leo_update_shortcut(self,action,commandName):
    
    trace = False and not g.unitTesting
    c = self.c ; k = c.k
    
    if action:
        s = action.text()
        parts = s.split('\t')
        if len(parts) >= 2: s = parts[0]
        key,aList = c.config.getShortcut(commandName)
        if aList:
            result = []
            for si in aList:
                assert k.isShortcutInfo(si),si
                # Don't show mode-related bindings.
                if not si.isModeBinding():
                    accel = k.prettyPrintKey(si.stroke)
                    if trace: g.trace('%20s %s' % (accel,si.dump()))
                    result.append(accel)
                    # Break here if we want to show only one accerator.
            action.setText('%s\t%s' % (s,', '.join(result)))
        else:
            action.setText(s)
    else:
        g.trace('can not happen: no action for %s' % (commandName))
#@+node:ekr.20041120112043: *6* parseShortcutLine (ParserBaseClass)
def parseShortcutLine (self,kind,s):

    '''Parse a shortcut line.  Valid forms:

    --> entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name --> mode-name = binding
    command-name --> same = binding
    '''

    trace = False and not g.unitTesting # and kind == '*mode-setting*'
    c,k = self.c,self.c.k
    assert c
    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)

    if g.match(s,i,'-->'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        if trace: g.trace('-->',entryCommandName)
        return None,k.ShortcutInfo('*entry-command*',commandName=entryCommandName)

    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name:
        if trace: g.trace('no name',repr(s))
        return None,None

    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'->'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]

    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]

    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    stroke = k.strokeFromSetting(val)
    assert k.isStrokeOrNone(stroke),stroke
    # g.trace('stroke',stroke)
    si = k.ShortcutInfo(kind=kind,nextMode=nextMode,pane=pane,stroke=stroke)
    if trace: g.trace('%25s %s' % (name,si))
    return name,si
#@+node:ekr.20041120094940.9: *6* set (ParserBaseClass)
def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    trace = False and not g.unitTesting
    if trace: g.trace(kind,name,val)

    c = self.c

    # Note: when kind is 'shortcut', name is a command name.
    key = self.munge(name)

    # if kind and kind.startswith('setting'): g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    gs = d.get(key)
    if gs:
        assert isinstance(gs,GeneralSetting),gs
        path = gs.path
        if c.os_path_finalize(c.mFileName) != c.os_path_finalize(path):
            g.es("over-riding setting:",name,"from",path)

    # Important: we can't use c here: it may be destroyed!
    d [key] = GeneralSetting(kind,path=c.mFileName,val=val,tag='setting')
#@+node:ekr.20120128103510.13670: *5* Updating dependent dicts
@nocolor-node


k.computeInversBinding() called by print-commands and for auto-completion.

k.bindKey sets k.bindingsDict.

k.bindKeyToDict sets k.masterBindingDict.
#@+node:ekr.20061031131434.98: *6* k.makeAllBindings
def makeAllBindings (self):

    k = self ; c = k.c

    # g.trace(c.shortFileName())

    k.bindingsDict = {}
    if g.new_modes:
        k.modeController.addModeCommands()
    else:
        k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    if c.frame.statusLine: c.frame.statusLine.setBindings()
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
#@+node:ekr.20061031131434.93: *6* k.bindKeyToDict
def bindKeyToDict (self,pane,stroke,si):
    
    '''Update k.masterBindingsDict for the stroke.'''

    trace = False and not g.unitTesting
        # and stroke.lower().find('tab') != -1 
    k = self
    
    assert k.isStroke(stroke),stroke
    
    # New in Leo 4.4.1: Allow redefintions.
    d = k.masterBindingsDict.get(pane,{})
    d[stroke] = si
    k.masterBindingsDict [pane] = d
    
    if trace: g.trace(pane,stroke,commandName)
#@+node:ekr.20050922104731: *6* finishCreateEditCommanders (leoEditCommands module)
def finishCreateEditCommanders (c):

    '''Finish creating edit classes in the commander.

    Return the commands dictionary for all the classes.'''
    
    # g.trace(c,g.callers())

    global classesList

    d = {}

    for name, theClass in classesList:
        theInstance = getattr(c,name)
        theInstance.finishCreate()
        theInstance.init()
        d2 = theInstance.getPublicCommands()
        if d2:
            d.update(d2)
            if 0:
                g.pr('----- %s' % name)
                for key in sorted(d2): g.pr(key)

    return d
#@+node:ekr.20061031131434.176: *6* k.computeInverseBindingDict
def computeInverseBindingDict (self):

    k = self ; d = {}

    # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict.keys():
        assert k.isStroke(stroke),repr(stroke)
        aList = k.bindingsDict.get(stroke,[])
        for si in aList:
            assert k.isShortcutInfo(si),si
            shortcutList = d.get(si.commandName,[])
            
            # The shortcutList consists of tuples (pane,stroke).
            # k.inverseBindingDict has values consisting of these tuples.
            aList = k.bindingsDict.get(stroke,k.ShortcutInfo(kind='dummy',pane='all'))
                    # Important: only si.pane is required below.
            for si in aList:
                assert k.isShortcutInfo(si),si
                pane = '%s:' % (si.pane)
                data = (pane,stroke)
                if data not in shortcutList:
                    shortcutList.append(data)

            d [si.commandName] = shortcutList

    return d
#@+node:ekr.20061031131434.80: *6* k.finishCreate & helpers
def finishCreate (self):

    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    # g.trace('(leoKeys)',g.callers())

    k = self ; c = k.c
    # g.trace('keyHandler')
    k.createInverseCommandsDict()

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'

    k.command_mode_bg_color = c.config.getColor('command_mode_bg_color') or bg
    k.command_mode_fg_color = c.config.getColor('command_mode_fg_color') or fg
    k.insert_mode_bg_color = c.config.getColor('insert_mode_bg_color') or bg
    k.insert_mode_fg_color = c.config.getColor('insert_mode_fg_color') or fg
    k.overwrite_mode_bg_color = c.config.getColor('overwrite_mode_bg_color') or bg
    k.overwrite_mode_fg_color = c.config.getColor('overwrite_mode_fg_color') or fg
    k.unselected_body_bg_color = c.config.getColor('unselected_body_bg_color') or bg
    k.unselected_body_fg_color = c.config.getColor('unselected_body_fg_color') or bg    

    # g.trace(k.insert_mode_bg_color,k.insert_mode_fg_color)

    self.inited = True

    k.setDefaultInputState()
    k.resetLabel()
#@+node:ekr.20061031131434.81: *7* createInverseCommandsDict
def createInverseCommandsDict (self):

    '''Add entries to k.inverseCommandsDict using c.commandDict.

    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict:
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))

        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())
#@+node:ekr.20061031131434.131: *6* k.registerCommand
def registerCommand (self,commandName,shortcut,func,
    pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)
    f = c.commandsDict.get(commandName)

    if f and f.__name__ != 'dummyCallback' and trace and verbose:
        g.es_print('redefining',commandName, color='red')
        
    assert not k.isStroke(shortcut)

    c.commandsDict [commandName] = func
    fname = func.__name__
    k.inverseCommandsDict [fname] = commandName
    if trace and fname != 'minibufferCallback':
        g.trace('leoCommands %24s = %s' % (fname,commandName))

    if shortcut:
        stroke = k.strokeFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk,aList = c.config.getShortcut(commandName)
        for si in aList:
            assert k.isShortcutInfo(si),si
            assert k.isStrokeOrNone(si.stroke)
            if si.stroke and not si.pane.endswith('-mode'):
                stroke = si.stroke
                break

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName)
        ok = k.bindKey (pane,stroke,func,commandName,tag='register-command') # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if trace and verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif trace and verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@+node:ekr.20120129174505.10243: *5* The missing settings bug (c.hash)
#@+node:ekr.20041130173135: *6* c.hash
def hash (self):

    c = self
    if c.mFileName:
        return c.os_path_finalize(c.mFileName).lower()
    else:
        return 0
#@+node:ekr.20120130074511.10226: *4* Fixed bug: @button @key=x does not override x
@nocolor-node

Created k.kill_one_shortcut, called from k.remove_conflicting_definitions.
#@+node:ekr.20061031131434.89: *5* k.bindKey & helpers
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False,tag=None):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    tag gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    if not k.check_bind_key(pane,shortcut):
        return False

    aList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %17s %s' % (pane,shortcut,tag,commandName))
    try:
        if not shortcut:
            stroke = None
        elif k.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s,stroke
        else:
            stroke = k.strokeFromSetting(shortcut)

        si = k.ShortcutInfo(kind=tag,pane=pane,
            func=callback,commandName=commandName,stroke=stroke)
    
        if shortcut: #####
            k.bindKeyToDict(pane,shortcut,si)
        if not modeFlag:
            if shortcut:
                k.remove_conflicting_definitions(aList,pane,shortcut)
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict [stroke] = aList
            if trace: g.trace(shortcut,aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20120130074511.10228: *6* k.check_bind_key
def check_bind_key(self,pane,shortcut):
    
    if not shortcut:
        return False

    k = self
    assert k.isStroke(shortcut)

    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter','leave'):
        if shortcut.lower().find(s) > -1:
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return False

    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    else:
        return True
#@+node:ekr.20120130074511.10227: *6* k.kill_one_shortcut
def kill_one_shortcut (self,stroke):
    
    '''Update the dicts so that c.config.getShortcut(name) will return None
    for all names *presently* bound to the stroke.'''
    
    k = self ; c = k.c
    
    # A crucial shortcut: inverting and uninverting dictionaries is slow.
    # Important: the comparison is valid regardless of the type of stroke.
    if stroke in (None,'None','none'):
        return
        
    assert k.isStroke(stroke),stroke
    
    # g.trace(stroke)

    d = g.app.config.localShortcutsDict.get(c.hash())
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=k.ShortcutInfo)

    inv_d = g.app.config.invert(d)
    aList = inv_d.get(stroke,[])
    inv_d[stroke] = []
    g.app.config.localShortcutsDict[c.hash()] = g.app.config.uninvert(inv_d)
#@+node:ekr.20061031131434.92: *6* k.remove_conflicting_definitions
def remove_conflicting_definitions (self,aList,pane,shortcut):
    
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert k.isShortcutInfo(si),si
        if pane in ('button','all',si.pane):
            if trace: g.trace('removing %s' % (si.dump()))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    aList = result
    
    # aList = [si for si in aList if pane not in ('button','all',si.pane)]
#@+node:ekr.20061031131434.93: *6* k.bindKeyToDict
def bindKeyToDict (self,pane,stroke,si):
    
    '''Update k.masterBindingsDict for the stroke.'''

    trace = False and not g.unitTesting
        # and stroke.lower().find('tab') != -1 
    k = self
    
    assert k.isStroke(stroke),stroke
    
    # New in Leo 4.4.1: Allow redefintions.
    d = k.masterBindingsDict.get(pane,{})
    d[stroke] = si
    k.masterBindingsDict [pane] = d
    
    if trace: g.trace(pane,stroke,commandName)
#@+node:ekr.20061031131434.94: *6* k.bindOpenWith
def bindOpenWith (self,shortcut,name,data):

    '''Register an open-with command.'''

    k = self ; c = k.c
    
    # g.trace(shortcut,name)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
#@+node:ekr.20120201084932.10043: ** Properly link shortcuts nodes
#@+node:ekr.20041122094813: *3* << configClass class data >> (g.app.config)
@others

dictList = [ivarsDict,encodingIvarsDict,defaultsDict]
    # List of dictionaries to search for hard-coded values.
    # Order not too important.
immutable_leo_settings_shortcuts_dict = {}
    # The initial shortcut settings in leoSettings.leo.
    # New in Leo 4.10.
immutable_my_leo_settings_shortcuts_dict = {}
    # The initial shortcut settings in myLeoSettings.leo.
    # New in Leo 4.10.
localOptionsDict = {}
    # Keys are commanders.  Values are optionsDicts.
localShortcutsDict = {}
    # Keys are commanders.  Values are settings dicts created by make_shortcuts_dicts.
    # New in Leo 4.10.
localOptionsList = []

warningsDict = {}
    # Keys are setting names, values are type names.
    # Used by get() or allies.
#@+node:ekr.20041117062717.1: *4* defaultsDict (g.app.config)
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultMenuFontSize = g.choose(sys.platform=="win32",9,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = g.TypedDict(
    name='g.app.config.defaultsDict',
    keyType=type('key'),valType=GeneralSetting)

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    # ("default_target_language","language","python"),
    ("target_language","language","python"), # Bug fix: 6/20,2005.
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","string","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    # ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
#@+node:ekr.20041118062709: *4* define encodingIvarsDict (g.app.config)
encodingIvarsDict = g.TypedDict(
    name='g.app.config.encodingIvarsDict',
    keyType=type('key'),valType=GeneralSetting)

encodingIvarsData = (
    ("default_at_auto_file_encoding","string","utf-8"),
    ("default_derived_file_encoding","string","utf-8"),
    ("new_leo_file_encoding","string","UTF-8"),
        # Upper case for compatibility with previous versions.
    ("defaultEncoding","string",None),
        # Defaults to None so it doesn't override better defaults.
)
#@+node:ekr.20041117072055: *4* ivarsDict (g.app.config)
# Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settings class inits the corresponding commander ivar.

ivarsDict = g.TypedDict(
    name='g.app.config.ivarsDict',
    keyType=type('key'),valType=GeneralSetting)

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("target_language","language","python"), # Bug fix: added: 6/20/2005.
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@+node:ekr.20041118195812: *3* Setters... (c.configSettings)
def set (self,setting,kind,val):
    
    '''Not used during startup: useful for unit tests.'''

    g.app.config.set(self.c,setting,kind,val)

def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    g.app.config.appendToRecentFiles(files)
    
def make_shortcuts_dicts (self,d,localFlag):
    
    return g.app.config.make_shortcuts_dicts(self.c,d,localFlag)
#@+node:ekr.20120122070219.10162: *3* make_shortcuts_dicts (g.app.config) & helpers
def make_shortcuts_dicts (self,c,d,localFlag):
    
    '''Make all settings dicts related to c and d.
    
    return the newly-made local dict or None.'''
    
    trace = False and not g.unitTesting
    fn = c.shortFileName().lower()
    result = {} # The newly-made local dict, or {} for non-local files.
    test_result = [] # For unit tests.
    
    def message(d,name):
        return '%4s keys %s' % (len(list(d.keys())),name)

    # g.trace('self',self)
    # g.trace('c',c)
    # g.trace('c.config',c.config)
    # g.trace('make_shortcuts_dict',len(list(d.keys())),g.callers())

    if fn == 'leosettings.leo':
        if not g.app.config.immutable_leo_settings_shortcuts_dict:
            if trace: g.trace(message(d,'immutable_leo_settings_shortcuts_dict'))
            g.app.config.immutable_leo_settings_shortcuts_dict = d
    elif fn == 'myleosettings.leo':
        if not g.app.config.immutable_my_leo_settings_shortcuts_dict:
            if trace: g.trace(message(d,'immutable_my_leo_settings_shortcuts_dict'))
            g.app.config.immutable_my_leo_settings_shortcuts_dict = d
        if localFlag:
            if trace: message(d,'settingsDict: %s' % (fn))
            d1 = g.app.config.immutable_leo_settings_shortcuts_dict
            d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
            d3 = self.settingsDict = self.merge_settings_dicts(d1,d2)
            result = d3
            if trace: g.trace(message(d3,'result: %s' % (fn)))
            test_result = (d1,d2,d3,'myLeoSettings.leo')
    else:
        if trace: g.trace(message(d,'settingsDict: %s' % (fn)))
        d1 = g.app.config.immutable_leo_settings_shortcuts_dict
        d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
        d3 = self.merge_settings_dicts(d1,d2)
        d4 = self.settingsDict = self.merge_settings_dicts(d3,d)
        result = d4
        test_result = ((d1,d2,d3,'local 1'),(d3,d,d4,'local 2'),)
        
    g.app.unitTestDict['make_shortcuts_dicts'] = test_result
    return result
#@+node:ekr.20120122070219.10163: *4* merge_settings_dicts (g.app.config)
def merge_settings_dicts (self,old_d,new_d):
    
    '''Create a new dict by overriding all settings in old_d by setting in new_d.
    
    Both old_d and new_d remain unchanged.'''
    
    trace = False and not g.unitTesting
    
    if not old_d: return new_d
    if not new_d: return old_d
    
    if trace:
        new_n,old_n = len(list(new_d.keys())),len(list(old_d.keys()))
        g.trace('new %4s %s %s' % (new_n,id(new_d),new_d.name()))
        g.trace('old %4s %s %s' % (old_n,id(old_d),old_d.name()))

    inverted_old_d = self.invert(old_d)
    inverted_new_d = self.invert(new_d)
    inverted_old_d.update(inverted_new_d) # Updates inverted_old_d in place.
    result = self.uninvert(inverted_old_d)
    return result
#@+node:ekr.20120125045244.10186: *4* invert (g.app.config)
def invert (self,d):
    
    '''Invert a shortcut dict whose keys are command names,
    returning a dict whose keys are strokes.'''
    
    trace = False and not g.unitTesting ; verbose = True
    if trace: g.trace('*'*40,d.name())
    
    result = g.TypedDictOfLists(
        name='inverted %s' % d.name(),
        keyType = leoKeys.KeyStroke,
        valType = leoKeys.ShortcutInfo)

    for commandName in d.keys():
        for si in d.get(commandName,[]):
            # This assert can fail if there is an exception in the ShortcutInfo ctor.
            assert isinstance(si,leoKeys.ShortcutInfo),si

            stroke = si.stroke # This is canonicalized.
            si.commandName = commandName # Add info.
            assert stroke
            if trace and verbose:
                g.trace('%40s %s' % (commandName,stroke))
            result.add(stroke,si)

    if trace: g.trace('returns  %4s %s %s' % (
        len(list(result.keys())),id(d),result.name()))
    return result
#@+node:ekr.20120125045244.10187: *4* uninvert (g.app.config)
def uninvert (self,d):
    
    '''Uninvert an inverted shortcut dict whose keys are strokes,
    returning a dict whose keys are command names.'''
    
    trace = False and not g.unitTesting ; verbose = True
    if trace and verbose: g.trace('*'*40)

    assert d.keyType == leoKeys.KeyStroke,d.keyType
    result = g.TypedDictOfLists(
        name='uninverted %s' % d.name(),
        keyType = type('commandName'),
        valType = leoKeys.ShortcutInfo)
    
    for stroke in d.keys():
        for si in d.get(stroke,[]):
            assert isinstance(si,leoKeys.ShortcutInfo),si
            commandName = si.commandName
            if trace and verbose:
                g.trace('uninvert %20s %s' % (stroke,commandName))
            assert commandName
            result.add(commandName,si)

    if trace: g.trace('returns %4s %s %s' % (
        len(list(result.keys())),id(d),result.name()))
    return result
#@+node:ekr.20041117062717.14: *3* getShortcut (g.app.config)
def getShortcut (self,c,commandName):

    '''Return rawKey,accel for shortcutName'''
    
    trace = False and not g.unitTesting # and commandName in ('new','print-bindings')

    key = c.frame.menu.canonicalizeMenuName(commandName)
    key = key.replace('&','') # Allow '&' in names.

    # New code: use the dicts created by make_settings_dict.
    table = (
        ('local',            c and self.localShortcutsDict.get(c.hash(),{})),
        ('myLeoSettings.leo',g.app.config.immutable_my_leo_settings_shortcuts_dict),
        ('leoSettings.leo',  g.app.config.immutable_leo_settings_shortcuts_dict),
    )
    aList = []
    for tag,d in table:
        if d:
            if trace: g.trace(tag,len(list(d.keys())))
            aList = d.get(commandName,[])
            if aList:
                for si in aList:
                    assert isinstance(si,leoKeys.ShortcutInfo),si
                break
                
    # It's very important to filter empty strokes here.
    aList = [si for si in aList
        if si.stroke and si.stroke.lower() != 'none']

    if trace: g.trace('getShortcut',tag,aList)

    return key,aList
#@+node:ekr.20041117083141: *3* get & allies (g.app.config)
def get (self,c,setting,kind):

    """Get the setting and make sure its type matches the expected type."""
    
    trace = False and not g.unitTesting

    isLeoSettings = c and c.shortFileName().endswith('leoSettings.leo')

    # New in Leo 4.6. Use settings in leoSettings.leo *last*.
    if c and not isLeoSettings:
        # For the local .leo file.
        d = self.localOptionsDict.get(c.hash(),{})
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                if trace: g.trace('**1',setting,val,d.name())
                return val

    for d in self.localOptionsList:
        # For myLeoSettings.leo and leoSettings.leo.
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            if trace: g.trace('**2',setting,val,d.name())
            return val

    for d in self.dictList:
        # For hard-coded options...
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            if trace: g.trace('**3',setting,val,d.name())
            return val

    # New in Leo 4.6. Use settings in leoSettings.leo *last*.
    if c and isLeoSettings:
        # For when leoSettings.leo is the local file.
        d = self.localOptionsDict.get(c.hash(),{})
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                if trace: g.trace('**4',setting,val,d.name())
                return val

    if trace:
        fn = c and c.shortFileName() or '<no file>'
        g.trace(setting,None,fn)
    return None
#@+node:ekr.20041121143823: *4* getValFromDict
def getValFromDict (self,d,setting,requestedType,warn=True):

    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    gs = d.get(self.munge(setting))
    if not gs: return None,False
    assert isinstance(gs,GeneralSetting)
    
    # g.trace(setting,requestedType,gs.toString())
    val = gs.val

    # 2011/10/24: test for an explicit None.
    if g.isPython3:
        isNone = val in ('None','none','') # ,None)
    else:
        isNone = val in (
            unicode('None'),unicode('none'),unicode(''),
            'None','none','') #,None)

    if not self.typesMatch(gs.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            g.es_print('warning: ignoring',gs.kind,'',setting,'is not',requestedType,color='red')
            g.es_print('there may be conflicting settings!',color='red')
        return None, False
    # elif val in (u'None',u'none','None','none','',None):
    elif isNone:
        return '', True
            # 2011/10/24: Exists, a *user-defined* empty value.
    else:
        # g.trace(setting,val)
        return val, True
#@+node:ekr.20051015093141: *4* typesMatch
def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything *except* shortcuts.
    - Shortcut matches shortcuts.
    '''

    # The shortcuts logic no longer uses the get/set code.
    shortcuts = ('shortcut','shortcuts',)
    if type1 in shortcuts or type2 in shortcuts:
        g.trace('oops: type in shortcuts')

    return (
        type1 == None or type2 == None or
        type1.startswith('string') and type2 not in shortcuts or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
#@+node:ekr.20041119204700.1: *3* traverse (ParserBaseClass)
def traverse (self):

    c,k = self.c,self.c.k

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return {},{}

    self.settingsDict = g.TypedDict(
        name='settingsDict for %s' % (c.shortFileName()),
        keyType=type('settingName'),valType=GeneralSetting)
    
    self.shortcutsDict = g.TypedDictOfLists(
        name='shortcutsDict for %s' % (c.shortFileName()),
        keyType=type('s'), valType=k.ShortcutInfo)
        
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        if result == "skip":
            # g.es_print('skipping settings in',p.h,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    shortcutsDict = c.config.make_shortcuts_dicts(self.shortcutsDict,self.localFlag)

    return shortcutsDict,self.settingsDict
#@+node:ekr.20051013161232: *3* updateSettings (g.app.config)
def updateSettings (self,c,localFlag):

    parser = SettingsTreeParser(c,localFlag)
    shortcutsDict,settingsDict = parser.traverse()
    
    d = settingsDict
    if d:
        if localFlag:
            self.localOptionsDict[c.hash()] = d
        else:
            self.localOptionsList.insert(0,d)
            
    if shortcutsDict and localFlag:
        self.localShortcutsDict[c.hash()] = shortcutsDict
#@+node:ekr.20120130074511.10227: *3* k.kill_one_shortcut
def kill_one_shortcut (self,stroke):
    
    '''Update the dicts so that c.config.getShortcut(name) will return None
    for all names *presently* bound to the stroke.'''
    
    k = self ; c = k.c
    
    # A crucial shortcut: inverting and uninverting dictionaries is slow.
    # Important: the comparison is valid regardless of the type of stroke.
    if stroke in (None,'None','none'):
        return
        
    assert k.isStroke(stroke),stroke
    
    # g.trace(stroke)

    d = g.app.config.localShortcutsDict.get(c.hash())
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=k.ShortcutInfo)

    inv_d = g.app.config.invert(d)
    aList = inv_d.get(stroke,[])
    inv_d[stroke] = []
    g.app.config.localShortcutsDict[c.hash()] = g.app.config.uninvert(inv_d)
#@-all

# Put this @language after the @all as a kind of permanent unit test.

#@@language python # Override the default .txt coloring.
#@-leo
