.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @+all
.. @+node:ekr.20170325085902.1: ** 5.6
.. @+node:ekr.20170326052206.1: *3* bugs
.. @+node:ekr.20170403181726.1: *4* #385: Leo doesn't remember new headlines after saves
https://github.com/leo-editor/leo-editor/issues/385
.. @+node:ekr.20170324115046.1: *4* #386: colorize markdown properly
https://github.com/leo-editor/leo-editor/issues/386
All changes made to leo/modes/md.py
.. @+node:ekr.20170315103331.1: *4* #438: Tree abbreviation placeholders in headlines...
https://github.com/leo-editor/leo-editor/issues/438
.. @+node:ekr.20170411191726.1: *4* #449 & #470: Spontaneous node generation
https://github.com/leo-editor/leo-editor/issues/470

See also:
https://github.com/leo-editor/leo-editor/issues/449
The original fix was in i.run in linescanner.py.
.. @+node:ekr.20170330024242.1: *4* #451: refresh-from-disk selects wrong node
https://github.com/leo-editor/leo-editor/issues/451
refresh-from-disk doesn't always restore focus to the correct node

- at.readOneAtAutoNode returns the *new* position.
- c.refreshFromDisk selects that position.
.. @+node:ekr.20170401202930.1: *4* #453: Focus jumps to body when expanding abbrev in a headline
https://github.com/leo-editor/leo-editor/issues/453
Focus jumps to de body pane when expanding an abbreviation in a headline.

The fix was in find_place_holder. It should not set focus if no placeholder found.
.. @+node:ekr.20170402034115.1: *4* #456: replace-all is very slow
Made several changes to find.batchChange.
.. @+node:ekr.20170402035751.1: *4* #458: Chapters drop-down list is not automatically resized
https://github.com/leo-editor/leo-editor/issues/458
Set a Qt flag in tt.createControl.
.. @+node:ekr.20170428063311.1: *4* #466: Moving a node can cause temporary coloring issues
https://github.com/leo-editor/leo-editor/issues/466

- Added LeoHighlighter.force_rehighlight.
- Rewrote 'recolor' command (c.force_recolor).
- Rewrote c.recolor_now.
- Added calls to c.recolor_now to c.moveOutline*.
.. @+node:ekr.20170411072038.1: *4* #471: UnicodeDecodeError in writeRecentFilesFileHelper
UnicodeDecodeError in writeRecentFilesFileHelper
https://github.com/leo-editor/leo-editor/issues/471

The fix was in rf.writeRecentFilesFileHelper.
.. @+node:ekr.20170411072045.1: *4* #472: @clean nodes stopped updating
https://github.com/leo-editor/leo-editor/issues/472

Solved: the checks are made only if @bool check_for_changed_external_files = True

Changed code in efc.on_idle and efc.idle_check_commander.
.. @+node:ekr.20170425070312.1: *4* #476: (error in cacher.fileKey)
https://github.com/leo-editor/leo-editor/issues/476
.. @+node:ekr.20170428144545.1: *4* #487: g.IdleTime docstring
https://github.com/leo-editor/leo-editor/issues/487
.. @+node:ekr.20170528061812.1: *4* Ensure that .leo/.leoRecentFiles.txt is closed
https://github.com/leo-editor/leo-editor/pull/497

Rewrote rf.createRecentFiles, rf.readRecentFilesFile and rf.writeRecentFilesFileHelper.
.. @+node:ekr.20170608072053.84: *4* Ensure that .leo/.leoRecentFiles.txt is closed.
https://github.com/leo-editor/leo-editor/pull/497

Rewrote rf.createRecentFiles, rf.readRecentFilesFile and rf.writeRecentFilesFileHelper.
.. @+node:ekr.20170326054533.1: *4* Fixed bug in k.computeInverseBindingDict
The bug gave way too many bindings for the move-lines commands.
.. @+node:ekr.20170326113032.1: *4* Fixed bug in tab completion
ga.show_tab_list wasn't showing commands without any shortcuts!
.. @+node:ekr.20170406091617.1: *4* Fixed bugs re plugins registration
Fixed plugins.registerOneHandler and plugins.registerOneExclusiveHandler
.. @+node:ekr.20170427164915.1: *4* Fixed html import problem
The unit test "@test xml non-ascii tags" failed on Python 2, but not Python 3.

The fix was in xml_i.scan_tag & helper
.. @+node:ekr.20170406095247.1: *4* Fixed serious bug in c.checkFileTimeStamp
It must return True if g.app.externalFilesController is None.
.. @+node:ekr.20170401132710.1: *4* Fixed several problems with goto-global-line
.. @+node:ekr.20170608072053.88: *4* #498: --session-restore option fails if no leo.session exists
https://github.com/leo-editor/leo-editor/issues/498

With a new installation of Leo there is no leo.session file. It is apparently created only after using the --session-save command line option.

If the --session-restore option is also used before that file is created, then Leo fails to open (splash screen displays, then nothing else happens).
.. @+node:ekr.20170416063625.1: *4* Revised xml/html importers
The new code is simpler and handles dubious html syntax.
.. @+node:ekr.20170329145930.1: *4* The pylint command now warns if pylint has not been installed
The change was to pylint.run_pylint.

This removes a major source of confusion.
.. @+node:ekr.20170617113038.1: *4* #479: Preserve brython indentation...
https://github.com/leo-editor/leo-editor/issues/479
Preserve brython indentation when importing .html files
.. @+node:ekr.20170618015241.1: *4* #481: The python importer optionally puts method decorators in headlines
https://github.com/leo-editor/leo-editor/issues/481
.. @+node:ekr.20170325085907.1: *3* code
.. @+node:ekr.20170325085939.1: *4* Added better checks in v.setBodyString & v.setHeadString
.. @+node:ekr.20170331043509.1: *4* Improved @auto write code
- Removed the allow_at_auto_section switch in leoAtFile.py.

- When writing @auto files << handle line at s[i] >> in at.putBody now expands section references in @auto files *if* they are defined. Otherwise, lines containing undefined section references are written as plain code lines.
.. @+node:ekr.20170331043931.1: *4* Added gen_refs keyword arg to Importer ctor
This makes explicit which importers actually generate section reference. At present, only the javascript importer sets this arg.
.. @+node:ekr.20170403182514.1: *4* Updated docs re #464
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/464

**Warning**: The p.b and p.h setters and p.setDirty() are *very* expensive:

- p.b = s calls c.setBodyString(p, s) which will recolor body text and update the node's icon.
- p.h = s calls c.setHeadString(p, s) which calls p.setDirty().
- p.setDirty() changes the icons of all ancestor @file nodes.

In contrast, the corresponding p.v.b and p.v.b setters and p.v.setDirty() are extremely fast.

Usually, code *should* use the p.b and p.h setters and p.setDirty(), despite their cost, because they update Leo's outline pane properly. Calling c.redraw() is *not* enough.

These performance gotchas become important for repetitive commands, like cff, replace-all and recursive import. In such situations, code should use p.v.b and p.v.h setters instead of p.b and p.h setters.
.. @+node:ekr.20170404032504.1: *4* Added 'recursive' keyword arg to recursive import API
Added 'recursive' keyword arg to c.recursiveImport and RecursiveImportController ctor.
Recursive is *not* the same as not one_file.
.. @+node:ekr.20170406092043.1: *4* Removed atAuto from atFile class
Ding dong, the switch is dead, the wicked old switch is dead.
.. @+node:ekr.20170412055006.1: *4* Added g.Git functions
leoGlobals.py the following functions and their helpers in the .Git subtree:

- branch, commit = g.gitInfo(path = None)
- date, build = g.jsonCommitInfo()
- branch = g.gitBranchName(path = None)
- commit = g.getCommitNumber(path = None)

The path should be a folder containing a .git subfolder. If the path is None, the leo-editor folder is used.

Leo's cacher code will soon use the branch name returned by g.gitInfo() to ensure that switching git branches works properly.

As a happy side effect, these methods completely collapse the complexity of leoVersion.py. 
.. @+node:ekr.20170427171721.1: *4* Added traces to c.doCommand to detect multiple redraws
These traces detected nothing unusual and have been disabled.
.. @+node:ekr.20170608072053.74: *4* Use 'with' statement to simplify code
Improved g.SherlockTracer.do_line, g.gitInfo, g.is_binary_external_file, g.log, g.readFileToUnicodeString.
.. @+node:ekr.20170403190659.1: *3* docs
.. @+node:ekr.20170325090029.1: *3* features
.. @+node:ekr.20170325045838.1: *4* #448: Add abbreviations for commands
https://github.com/leo-editor/leo-editor/issues/448

If the expansion of an abbrevitiation is a command name, that command will be executed. Alas, this isn't very useful: typing destroys selection ranges.

This took only a few lines of code in abbrev.expandAbbrev.
.. @+node:ekr.20170509091900.1: *4* #484: improve menus
https://github.com/leo-editor/leo-editor/issues/484

Added submenus to Windows menu. This significantly simplifies and clarifies the Windows menu.
.. @+node:ekr.20170608071935.1: *4* #488: Created a curses/npyscreen front end for Leo
https://github.com/leo-editor/leo-editor/issues/488
.. @+node:ekr.20170614051052.1: *4* Added "yes/no to all" buttons for externally changed file dialog
Rev 9c94fec36d adds Yes / no to all on external file changes.

If you answer yes to all or no to all Leo remembers that
answer for 3 seconds. As a result, another set of external
changes will show the pop up again.
.. @+node:ekr.20170411191401.1: *4* Added  git branch name to backed-up files
.. @+node:ekr.20170328143013.1: *4* Added --trace-focus command-line argument
.. @+node:ekr.20170411092513.1: *4* Added goto-any-clone command
Searches from c.p for *any* clone, not just a clone of c.p.  Useful for eliminating all clones from a .leo file.

This command is different from goto-next-clone as follows:

- goto-any-clone goes to the next clone, regardless of whether c.p is a clone.
- goto-any-clone does not wrap. It prints a message when no clones remain.
.. @+node:ekr.20170430033223.1: *4* Added log listener commands
@language rest
@wrap

The log-listen (aka listen-to-log) and kill-log-listen (aka, listen-log-kill) commands implement this logging cookbook recipe:
https://docs.python.org/2/howto/logging-cookbook.html#sending-and-receiving-logging-events-across-a-network

The log-listen command creates a logging listener whose output goes to Leo's console. The listener runs in a separate process so that Leo doesn't hang.

Start the listener first, then start another process in another console. All logging output from the second process will be captured and displayed by the listener, provided that the second process includes a call to `rootLogger.addHandler(socketHandler)`.

leo/external/log_broadcast.py contains example code. leo/plugins/cursesGui2.py uses this pattern to broadcast g.trace.



.. @+node:ekr.20170325090032.1: *4* Added show-color-names command
.. @+node:ekr.20170427173032.1: *4* clone-find commands report number of matches in root node
Changed find.createCloneFindAllNodes and c.cloneFindMarkedHelper.
.. @+node:ekr.20170327052423.1: *4* Improved "Write Existing File?" dialog
at.promptForDangerousWrite puts up a dialog with a clearer cancel button.
All tests pass.

- It says "Cancel (No To All)".
- Added cancelMessage keyword arg to x.promptForDangerousWrite.
- Use keyword args in LeoFrame.promptForSave and ns_do_context.
.. @+node:ekr.20170414103904.1: *4* Improved caching
Rev b32259 transitions to a new caching scheme:

1. All hashes now use the full path to the external file.  Previously, the headline of @file nodes was typically used instead. Surely this might have caused silent problems.

2. Leo's hasher now includes the name of the present git branch in the hash. When switching git branches, this in essence disables hashing for all files changed in the previous branch.
.. @+node:ekr.20170326091637.1: *4* Improved indent-region and unindent-region commands
https://groups.google.com/d/msg/leo-editor/SUnqs1_YbeI/DIv0EbtFCgAJ

The indent-region and unindent-region just move the insert point if there is no text selected.
.. @+node:ekr.20170326052408.1: *4* Improved move-lines-up/down commands
These commands (bound to ctrl-up/down by default) now work at the top or bottom of the body pane. The move-lines-up command inserts a new line below the moved line/lines when the lines are at the top of the body text.  Similarly, the move-lines-down command inserts a line before the moved lines when at the bottom of the body text. Imo, this is a natural and useful.
.. @+node:ekr.20170530023214.1: *4* Restored importer;; abbreviation
55b2037ac3a: 2016-11-22 06:33:17 Removed importer;; abbreviation(!!)


Restored the abbreviation from f10fa02b8cb681, the previous commit.
.. @+node:ekr.20170616100339.1: *4* Added tcl importer
.. @+node:ekr.20170618083013.1: *4* Added toggle-auto-edit command
https://github.com/leo-editor/leo-editor/issues/482

This command is surprisingly useful.  It toggles between a flattened view (@edit) and an outline view (@auto) of an external file containing no sentinels.

This command preserves the presently selected line when flattening/un-flattening the outline. You can run this command from any descendant of an @auto node.
.. @+node:ekr.20170618083013.2: *5* efc.toggleAtAutoAtEdit & helpers
@cmd('toggle-at-auto-at-edit')
def toggleAtAutoAtEdit(self, event):
    '''Toggle between @auto and @edit, preserving insert point, etc.'''
    p = self.c.p
    if p.isAtEditNode():
        self.toAtAuto(p)
        return
    for p in p.self_and_parents():
        if p.isAtAutoNode():
            self.toAtEdit(p)
            return
    g.es_print('Not in an @auto or @edit tree.', color='blue')
.. @+node:ekr.20170618083013.3: *6* efc.toAtAuto
def toAtAuto(self, p):
    '''Convert p from @edit to @auto.'''
    c = self.c
    # Change the headline.
    p.h = '@auto' + p.h[5:]
    # Compute the position of the present line within the file.
    w = c.frame.body.wrapper
    ins = w.getInsertPoint()
    row, col = g.convertPythonIndexToRowCol(p.b, ins)
    # Ignore *preceding* directive lines.
    directives = [z for z in g.splitLines(c.p.b)[:row] if g.isDirective(z)]
    row -= len(directives)
    row = max(0, row)
    # Reload the file, creating new nodes.
    c.selectPosition(p, enableRedrawFlag=False)
    c.refreshFromDisk()
    # Restore the line in the proper node.
    c.gotoCommands.find_file_line(row+1)
    p.setDirty()
    c.setChanged()
    c.redraw()
    c.bodyWantsFocus()
.. @+node:ekr.20170618083013.4: *6* efc.toAtEdit
def toAtEdit(self, p):
    '''Convert p from @auto to @edit.'''
    c = self.c
    w = c.frame.body.wrapper
    p.h = '@edit' + p.h[5:]
    # Compute the position of the present line within the *selected* node c.p
    ins = w.getInsertPoint()
    row, col = g.convertPythonIndexToRowCol(c.p.b, ins)
    # Ignore directive lines.
    directives = [z for z in g.splitLines(c.p.b)[:row] if g.isDirective(z)]
    row -= len(directives)
    row = max(0, row)
    # Count preceding lines from p to c.p, again ignoring directives.
    for p2 in p.self_and_subtree():
        if p2 == c.p:
            break
        lines = [z for z in g.splitLines(p2.b) if not g.isDirective(z)]
        row += len(lines)
    # Reload the file into a single node.
    c.selectPosition(p, enableRedrawFlag=False)
    c.refreshFromDisk()
    # Restore the line in the proper node.
    ins = g.convertRowColToPythonIndex(p.b, row+1, 0)
    w.setInsertPoint(ins)
    p.setDirty()
    c.setChanged()
    c.redraw()
    c.bodyWantsFocus()
.. @+node:ekr.20170619155533.1: *4* Improved operation of command history
The first UP-arrow to gives the presvious command, the next up-arrow gives the next command, etc.
.. @+node:ekr.20170403192311.1: *3* plugins
.. @+node:ekr.20170403192317.1: *4* screen_capture.py now enabled by default
.. @+node:ekr.20170331043621.1: *3* settings
.. @+node:ekr.20170328043328.1: *4* Added ctrl-shift < and > bindings
@language rest
@wrap

These are bound to indent/unindent-region and can be used when no text is selected.
.. @+node:ekr.20170427110630.1: *4* Restored default: @bool check_for_changed_external_files = True
.. @+node:ekr.20170330083957.1: *4* Retired @bool allow_section_references_in_at_auto
The disabled setting now contains this comment:

    **Note**: This setting has been retired for the following reasons:
    
    1. The new javascript importer *always* generate section references
    for non-trivial programs. As a result, the legacy value for this
    setting would cause the javascript importer to fail.
    
    2. The new @auto write code writes expands section references if
    they exist. Otherwise, the write code writes the line as is,
    without any complaint. As a result, there should be no problem if
    an imported code contains something that looks like a section
    reference but isn't.
.. @+node:ekr.20170619154105.1: *3* Branch: tree-gen
@language rest
@wrap

Adds c.frame.tree.generation count.
- Update count in v._addLink and v._cutlink.
- Use the count in LeoValues to avoid unnecessary recalcularion.
.. @+node:ekr.20031218072017.3341: *4* class VNode
@nobeautify

class VNodeBase(object):
    << VNode constants >>
    @others

if use_zodb and ZODB:

    class VNode(ZODB.Persistence.Persistent, VNodeBase):
        pass

else:
    VNode = VNodeBase

vnode = VNode # compatibility.

@beautify
.. @+node:ekr.20031218072017.951: *5* << VNode constants >>
# Define the meaning of status bits in new vnodes.
# Archived...
clonedBit = 0x01 # True: VNode has clone mark.
# unused      0x02
expandedBit = 0x04 # True: VNode is expanded.
markedBit = 0x08 # True: VNode is marked
# unused    = 0x10 # (was orphanBit)
selectedBit = 0x20 # True: VNode is current VNode.
topBit = 0x40 # True: VNode was top VNode when saved.
# Not archived...
richTextBit = 0x080 # Determines whether we use <bt> or <btr> tags.
visitedBit = 0x100
dirtyBit = 0x200
writeBit = 0x400
orphanBit = 0x800 # True: error in @<file> tree prevented it from being written.
.. @+node:ekr.20031218072017.3342: *5* v.Birth & death
.. @+node:ekr.20031218072017.3344: *6* v.__init
def __init__(self, context, gnx=None):
    '''
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    '''
    # The primary data: headline and body text.
    self._headString = g.u('newHeadline')
    self._bodyString = g.u('')
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
.. @+node:ekr.20031218072017.3345: *6* v.__repr__ & v.__str__
def __repr__(self):
    return "<VNode %7x %s>" % (id(self), self.cleanHeadString())

__str__ = __repr__
.. @+node:ekr.20040312145256: *6* v.dump
def dumpLink(self, link):
    return link if link else "<none>"

def dump(self, label=""):
    v = self
    print('%s %s %s' % ('-' * 10, label, v))
    print('len(parents) %s' % len(v.parents))
    print('len(children) %s' % len(v.children))
    print('parents %s' % g.listToString(v.parents))
    print('children%s' % g.listToString(v.children))
.. @+node:ekr.20060910100316: *6* v.__hash__ (only for zodb)
if use_zodb and ZODB:

    def __hash__(self):
        return self.__hash__()
.. @+node:ekr.20031218072017.3346: *5* v.Comparisons
.. @+node:ekr.20040705201018: *6* v.findAtFileName
def findAtFileName(self, names, h=''):
    '''Return the name following one of the names in nameList or ""'''
    # Allow h argument for unit testing.
    if not h: h = self.headString()
    # if h.startswith('@auto-test'): g.trace(h,'@auto-test' in names)
    if not g.match(h, 0, '@'):
        return ""
    i = g.skip_id(h, 1, '-')
    word = h[: i]
    if word in names and g.match_word(h, 0, word):
        name = h[i:].strip()
        # g.trace(repr(word),repr(name))
        return name
    else:
        return ""
.. @+node:ekr.20031218072017.3350: *6* v.anyAtFileNodeName
def anyAtFileNodeName(self):
    """Return the file name following an @file node or an empty string."""
    return (
        self.findAtFileName(g.app.atAutoNames) or
        self.findAtFileName(g.app.atFileNames))
.. @+node:ekr.20031218072017.3348: *6* v.at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName(self, h=None):
    return self.findAtFileName(g.app.atAutoNames, h=h)
# Retain this special case as part of the "escape hatch".
# That is, we fall back on code in leoRst.py if no
# importer or writer for reStructuredText exists.

def atAutoRstNodeName(self, h=None):
    names = ("@auto-rst",)
    return self.findAtFileName(names, h=h)

def atCleanNodeName(self):
    names = ("@clean",)
    return self.findAtFileName(names)

def atEditNodeName(self):
    names = ("@edit",)
    return self.findAtFileName(names)

def atFileNodeName(self):
    names = ("@file", "@thin")
        # Fix #403.
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName(self):
    names = ("@nosent", "@file-nosent",)
    return self.findAtFileName(names)

def atRstFileNodeName(self):
    names = ("@rst",)
    return self.findAtFileName(names)

def atShadowFileNodeName(self):
    names = ("@shadow",)
    return self.findAtFileName(names)

def atSilentFileNodeName(self):
    names = ("@asis", "@file-asis",)
    return self.findAtFileName(names)

def atThinFileNodeName(self):
    names = ("@thin", "@file-thin",)
    return self.findAtFileName(names)
# New names, less confusing

atNoSentFileNodeName = atNoSentinelsFileNodeName
atAsisFileNodeName = atSilentFileNodeName
.. @+node:EKR.20040430152000: *6* v.isAtAllNode
def isAtAllNode(self):
    """Returns True if the receiver contains @others in its body at the start of a line."""
    flag, i = g.is_special(self._bodyString, 0, "@all")
    return flag
.. @+node:ekr.20040326031436: *6* v.isAnyAtFileNode
def isAnyAtFileNode(self):
    """Return True if v is any kind of @file or related node."""
    # This routine should be as fast as possible.
    # It is called once for every VNode when writing a file.
    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
.. @+node:ekr.20040325073709: *6* v.isAt...FileNode
def isAtAutoNode(self):
    return bool(self.atAutoNodeName())

def isAtAutoRstNode(self):
    return bool(self.atAutoRstNodeName())

def isAtCleanNode(self):
    return bool(self.atCleanNodeName())

def isAtEditNode(self):
    return bool(self.atEditNodeName())

def isAtFileNode(self):
    return bool(self.atFileNodeName())

def isAtRstFileNode(self):
    return bool(self.atRstFileNodeName())

def isAtNoSentinelsFileNode(self):
    return bool(self.atNoSentinelsFileNodeName())

def isAtSilentFileNode(self): # @file-asis
    return bool(self.atSilentFileNodeName())

def isAtShadowFileNode(self):
    return bool(self.atShadowFileNodeName())

def isAtThinFileNode(self):
    return bool(self.atThinFileNodeName())
# New names, less confusing:

isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtAsisFileNode = isAtSilentFileNode
.. @+node:ekr.20031218072017.3351: *6* v.isAtIgnoreNode
def isAtIgnoreNode(self):
    """Returns True if the receiver contains @ignore in its body at the start of a line.

    or if the headline starts with @ignore."""
    # v = self
    # 2011/10/08: honor @ignore in headlines.  Sheesh.
    if g.match_word(self._headString, 0, '@ignore'):
        return True
    else:
        flag, i = g.is_special(self._bodyString, 0, "@ignore")
        return flag
.. @+node:ekr.20031218072017.3352: *6* v.isAtOthersNode
def isAtOthersNode(self):
    """Returns True if the receiver contains @others in its body at the start of a line."""
    flag, i = g.is_special(self._bodyString, 0, "@others")
    return flag
.. @+node:ekr.20031218072017.3353: *6* v.matchHeadline
def matchHeadline(self, pattern):
    """Returns True if the headline matches the pattern ignoring whitespace and case.

    The headline may contain characters following the successfully matched pattern."""
    v = self
    h = g.toUnicode(v.headString())
    h = h.lower().replace(' ', '').replace('\t', '')
    h = h.lstrip('.') # 2013/04/05. Allow leading period before section names.
    pattern = g.toUnicode(pattern)
    pattern = pattern.lower().replace(' ', '').replace('\t', '')
    return h.startswith(pattern)
.. @+node:ekr.20160502100151.1: *5* v.copyTree
def copyTree(self, copyMarked=False):
    '''
    Return an all-new tree of vnodes that are copies of self and all its
    descendants.

    **Important**: the v.parents ivar must be [] for all nodes.
    v._addParentLinks will set all parents.
    '''
    v = self
    # Allocate a new vnode and gnx with empty children & parents.
    v2 = VNode(context=v.context, gnx=None)
    assert v2.parents == [], v2.parents
    assert v2.gnx
    assert v.gnx != v2.gnx
    # Copy vnode fields. Do **not** set v2.parents.
    v2._headString = g.toUnicode(v._headString, reportErrors=True) # 2017/01/24
    v2._bodyString = g.toUnicode(v._bodyString, reportErrors=True) # 2017/01/24
    v2.u = copy.deepcopy(v.u)
    if copyMarked and v.isMarked():
        v2.setMarked()
    # Recursively copy all descendant vnodes.
    for child in v.children:
        v2.children.append(child.copyTree(copyMarked))
    return v2
.. @+node:ekr.20031218072017.3359: *5* v.Getters
.. @+node:ekr.20031218072017.3378: *6* v.bodyString
body_unicode_warning = False

def bodyString(self):
    # This message should never be printed and we want to avoid crashing here!
    if g.isUnicode(self._bodyString):
        return self._bodyString
    else:
        if not self.body_unicode_warning:
            self.body_unicode_warning = True
            g.internalError('not unicode:', repr(self._bodyString))
        return g.toUnicode(self._bodyString)

getBody = bodyString
    # Deprecated, but here for compatibility.
.. @+node:ekr.20031218072017.3360: *6* v.Children
.. @+node:ekr.20031218072017.3362: *7* v.firstChild
def firstChild(self):
    v = self
    return v.children and v.children[0]
.. @+node:ekr.20040307085922: *7* v.hasChildren & hasFirstChild
def hasChildren(self):
    v = self
    return len(v.children) > 0

hasFirstChild = hasChildren
.. @+node:ekr.20031218072017.3364: *7* v.lastChild
def lastChild(self):
    v = self
    return v.children[-1] if v.children else None
.. @+node:ekr.20031218072017.3365: *7* v.nthChild
# childIndex and nthChild are zero-based.

def nthChild(self, n):
    v = self
    if 0 <= n < len(v.children):
        return v.children[n]
    else:
        return None
.. @+node:ekr.20031218072017.3366: *7* v.numberOfChildren
def numberOfChildren(self):
    v = self
    return len(v.children)
.. @+node:ekr.20040323100443: *6* v.directParents
def directParents(self):
    """(New in 4.2) Return a list of all direct parent vnodes of a VNode.

    This is NOT the same as the list of ancestors of the VNode."""
    v = self
    return v.parents
.. @+node:ekr.20080429053831.6: *6* v.hasBody
def hasBody(self):
    '''Return True if this VNode contains body text.'''
    s = self._bodyString
    return s and len(s) > 0
.. @+node:ekr.20031218072017.1581: *6* v.headString & v.cleanHeadString
head_unicode_warning = False

def headString(self):
    """Return the headline string."""
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self._headString):
        if not self.head_unicode_warning:
            self.head_unicode_warning = True
            g.internalError('not unicode', repr(self._headString))
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self._headString)

def cleanHeadString(self):
    s = self._headString
    if g.isPython3:
        return s
    else:
        return g.toEncodedString(s, "ascii") # Replaces non-ascii characters by '?'
.. @+node:ekr.20131223064351.16351: *6* v.isNthChildOf
def isNthChildOf(self, n, parent_v):
    '''Return True if v is the n'th child of parent_v.'''
    v = self
    children = parent_v and parent_v.children
    return children and 0 <= n < len(children) and children[n] == v
.. @+node:ekr.20031218072017.3367: *6* v.Status Bits
.. @+node:ekr.20031218072017.3368: *7* v.isCloned
def isCloned(self):
    return len(self.parents) > 1
.. @+node:ekr.20031218072017.3369: *7* v.isDirty
def isDirty(self):
    return (self.statusBits & self.dirtyBit) != 0
.. @+node:ekr.20031218072017.3371: *7* v.isMarked
def isMarked(self):
    return (self.statusBits & VNode.markedBit) != 0
.. @+node:ekr.20031218072017.3372: *7* v.isOrphan
def isOrphan(self):
    return (self.statusBits & VNode.orphanBit) != 0
.. @+node:ekr.20031218072017.3373: *7* v.isSelected
def isSelected(self):
    return (self.statusBits & VNode.selectedBit) != 0
.. @+node:ekr.20031218072017.3374: *7* v.isTopBitSet
def isTopBitSet(self):
    return (self.statusBits & self.topBit) != 0
.. @+node:ekr.20031218072017.3376: *7* v.isVisited
def isVisited(self):
    return (self.statusBits & VNode.visitedBit) != 0
.. @+node:ekr.20080429053831.10: *7* v.isWriteBit
def isWriteBit(self):
    v = self
    return (v.statusBits & v.writeBit) != 0
.. @+node:ekr.20031218072017.3377: *7* v.status
def status(self):
    return self.statusBits
.. @+node:ekr.20031218072017.3384: *5* v.Setters
.. @+node:ekr.20090830051712.6151: *6*  v.Dirty bits
.. @+node:ekr.20031218072017.3390: *7* v.clearDirty
def clearDirty(self):
    '''Clear the vnode dirty bit.'''
    v = self
    # g.trace(v.h,g.callers())
    v.statusBits &= ~v.dirtyBit
.. @+node:ekr.20090830051712.6153: *7* v.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):
    trace = False and not g.unitTesting
    v = self; c = v.context
    # Set the starting nodes.
    nodes = []
    newNodes = [v]
    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]
    # Remove the hidden VNode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root', c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)
    if trace: g.trace(nodes)
    return nodes
.. @+node:ekr.20090830051712.6157: *7* v.setAllAncestorAtFileNodesDirty
# Unlike p.setAllAncestorAtFileNodesDirty,
# there is no setDescendentsDirty arg.

def setAllAncestorAtFileNodesDirty(self):
    trace = False and not g.unitTesting
    verbose = False
    v = self
    dirtyVnodeList = []
    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = v.findAllPotentiallyDirtyNodes()
    if trace and verbose:
        for v in nodes:
            print(v.isDirty(), v.isAnyAtFileNode(), v)
    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]
    for v in dirtyVnodeList:
        v.setDirty() # Do not call p.setDirty here!
    if trace: g.trace(dirtyVnodeList)
    return dirtyVnodeList
.. @+node:ekr.20080429053831.12: *7* v.setDirty
def setDirty(self):
    '''Set the vnode dirty bit.'''
    # if self.h.startswith('@auto'):
    # g.trace('(v) %5s %30s' % (self.isDirty(),self.h),g.callers())
    self.statusBits |= self.dirtyBit
.. @+node:ekr.20031218072017.3386: *6*  v.Status bits
.. @+node:ekr.20031218072017.3389: *7* v.clearClonedBit
def clearClonedBit(self):
    self.statusBits &= ~self.clonedBit
.. @+node:ekr.20031218072017.3391: *7* v.clearMarked
def clearMarked(self):
    self.statusBits &= ~self.markedBit
.. @+node:ekr.20080429053831.8: *7* v.clearWriteBit
def clearWriteBit(self):
    self.statusBits &= ~self.writeBit
.. @+node:ekr.20031218072017.3392: *7* v.clearOrphan
def clearOrphan(self):
    # if self.h.startswith('@file'): g.trace(self.h,g.callers())
    self.statusBits &= ~self.orphanBit
.. @+node:ekr.20031218072017.3393: *7* v.clearVisited
def clearVisited(self):
    self.statusBits &= ~self.visitedBit
.. @+node:ekr.20031218072017.3395: *7* v.contract/expand/initExpandedBit/isExpanded
def contract(self):
    '''Contract the node.'''
    self.statusBits &= ~self.expandedBit

def expand(self):
    '''Expand the node.'''
    self.statusBits |= self.expandedBit

def initExpandedBit(self):
    '''Init self.statusBits.'''
    self.statusBits |= self.expandedBit

def isExpanded(self):
    '''Return True if the VNode expansion bit is set.'''
    return (self.statusBits & self.expandedBit) != 0
.. @+node:ekr.20031218072017.3396: *7* v.initStatus
def initStatus(self, status):
    self.statusBits = status
.. @+node:ekr.20031218072017.3397: *7* v.setClonedBit & initClonedBit
def setClonedBit(self):
    self.statusBits |= self.clonedBit

def initClonedBit(self, val):
    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~self.clonedBit
.. @+node:ekr.20031218072017.3398: *7* v.setMarked & initMarkedBit
def setMarked(self):
    self.statusBits |= self.markedBit

def initMarkedBit(self):
    self.statusBits |= self.markedBit
.. @+node:ekr.20031218072017.3399: *7* v.setOrphan
def setOrphan(self):
    '''Set the vnode's orphan bit.'''
    trace = (False or g.app.debug) and not g.unitTesting
    if trace and self.h.startswith('@file'):
        g.trace(self.h, g.callers())
    self.statusBits |= self.orphanBit
.. @+node:ekr.20031218072017.3400: *7* v.setSelected
# This only sets the selected bit.

def setSelected(self):
    self.statusBits |= self.selectedBit
.. @+node:ekr.20031218072017.3401: *7* v.setVisited
# Compatibility routine for scripts

def setVisited(self):
    self.statusBits |= self.visitedBit
.. @+node:ekr.20080429053831.9: *7* v.setWriteBit
def setWriteBit(self):
    self.statusBits |= self.writeBit
.. @+node:ekr.20031218072017.3385: *6* v.computeIcon & setIcon
def computeIcon(self):
    val = 0; v = self
    if v.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val

def setIcon(self):
    pass # Compatibility routine for old scripts
.. @+node:ekr.20100303074003.5636: *6* v.restoreCursorAndScroll
# Called only by LeoTree.selectHelper.

def restoreCursorAndScroll(self):
    '''Restore the cursor position and scroll so it is visible.'''
    trace = (False or g.trace_scroll) and not g.unitTesting
    traceTime = False and not g.unitTesting
    v = self
    ins = v.insertSpot
    # start, n = v.selectionStart, v.selectionLength
    spot = v.scrollBarSpot
    body = self.context.frame.body
    w = body.wrapper
    # Fix bug 981849: incorrect body content shown.
    if ins is None: ins = 0
    # This is very expensive for large text.
    if traceTime: t1 = time.time()
    if hasattr(body.wrapper, 'setInsertPoint'):
        if trace and ins: g.trace('ins', ins, 'spot', spot)
        w.setInsertPoint(ins)
    if traceTime:
        delta_t = time.time() - t1
        if delta_t > 0.1: g.trace('%2.3f sec' % (delta_t))
    # Override any changes to the scrollbar setting that might
    # have been done above by w.setSelectionRange or w.setInsertPoint.
    if spot is not None:
        w.setYScrollPosition(spot)
        v.scrollBarSpot = spot
    # Never call w.see here.
.. @+node:ekr.20100303074003.5638: *6* v.saveCursorAndScroll
def saveCursorAndScroll(self):
    trace = (False or g.trace_scroll) and not g.unitTesting
    v = self; c = v.context
    w = c.frame.body
    if not w: return
    try:
        v.scrollBarSpot = w.getYScrollPosition()
        v.insertSpot = w.getInsertPoint()
        if trace: g.trace(v.scrollBarSpot, v.insertSpot)
    except AttributeError:
        # 2011/03/21: w may not support the high-level interface.
        pass
.. @+node:ekr.20040315032144: *6* v.setBodyString & v.setHeadString
unicode_warning_given = False

def setBodyString(self, s):
    v = self
    if g.isUnicode(s):
        v._bodyString = s
    else:
        try:
            v._bodyString = g.toUnicode(s, reportErrors=True)
        except Exception:
            if not self.unicode_warning_given:
                self.unicode_warning_given = True
                g.internalError(s)
                g.es_exception()

def setHeadString(self, s):
    # Fix bug: https://bugs.launchpad.net/leo-editor/+bug/1245535
    # API allows headlines to contain newlines.
    v = self
    if g.isUnicode(s):
        v._headString = s.replace('\n','')
    else:
        try:
            s = g.toUnicode(s, reportErrors=True)
            v._headString = s.replace('\n','')
        except Exception:
            if not self.unicode_warning_given:
                self.unicode_warning_given = True
                g.internalError(s)
                g.es_exception()

initBodyString = setBodyString
initHeadString = setHeadString
setHeadText = setHeadString
setTnodeText = setBodyString
.. @+node:ekr.20031218072017.3402: *6* v.setSelection
def setSelection(self, start, length):
    v = self
    v.selectionStart = start
    v.selectionLength = length
.. @+node:ville.20120502221057.7498: *6* v.contentModified
def contentModified(self):
    g.contentModifiedSet.add(self)
.. @+node:ville.20120502221057.7499: *6* v.childrenModified
def childrenModified(self):
    g.childrenModifiedSet.add(self)
.. @+node:ekr.20130524063409.10700: *5* v.Inserting & cloning
def cloneAsNthChild(self, parent_v, n):
    # Does not check for illegal clones!
    v = self
    v._linkAsNthChild(parent_v, n)
    return v

def insertAsFirstChild(self):
    v = self
    return v.insertAsNthChild(0)

def insertAsLastChild(self):
    v = self
    return v.insertAsNthChild(len(v.children))

def insertAsNthChild(self, n):
    v = self
    assert 0 <= n <= len(v.children)
    v2 = VNode(v.context)
    v2._linkAsNthChild(v, n)
    assert v.children[n] == v2
    return v2
.. @+node:ekr.20080427062528.9: *5* v.Low level methods
.. @+node:ekr.20090706110836.6135: *6* v._addLink & helper
def _addLink(self, childIndex, parent_v, adjust=True):
    '''Adjust links after adding a link to v.'''
    trace = False and not g.unitTesting
    v = self
    # g.trace(v.context.frame.tree)
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()
    # Update parent_v.children & v.parents.
    parent_v.children.insert(childIndex, v)
    v.parents.append(parent_v)
    if trace:
        g.trace('*** added parent', parent_v, 'to', v,
                'len(parents)', len(v.parents))
    # Set zodb changed flags.
    v._p_changed = 1
    parent_v._p_changed = 1
    # If v has only one parent, we adjust all
    # the parents links in the descendant tree.
    # This handles clones properly when undoing a delete.
    if adjust:
        if len(v.parents) == 1:
            for child in v.children:
                child._addParentLinks(parent=v)
.. @+node:ekr.20090804184658.6129: *7* v._addParentLinks
def _addParentLinks(self, parent):
    trace = False and not g.unitTesting
    v = self
    v.parents.append(parent)
    if trace:
        g.trace('v', v.h, 'parent', parent.h, g.callers())
        # '*** added parent', parent, 'to', v, 'len(parents)', len(v.parents))
    if len(v.parents) == 1:
        for child in v.children:
            child._addParentLinks(parent=v)
.. @+node:ekr.20090804184658.6128: *6* v._cutLink
def _cutLink(self, childIndex, parent_v):
    '''Adjust links after cutting a link to v.'''
    v = self
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()
    assert parent_v.children[childIndex] == v
    del parent_v.children[childIndex]
    if parent_v in v.parents:
        v.parents.remove(parent_v)
    v._p_changed = 1
    parent_v._p_changed = 1
    # If v has no more parents, we adjust all
    # the parent links in the descendant tree.
    # This handles clones properly when deleting a tree.
    if not v.parents:
        for child in v.children:
            child._cutParentLinks(parent=v)
.. @+node:ekr.20090804190529.6133: *7* v._cutParentLinks
def _cutParentLinks(self, parent):
    trace = False and not g.unitTesting
    v = self
    if trace: g.trace('parent', parent, 'v', v)
    v.parents.remove(parent)
    if not v.parents:
        for child in v.children:
            child._cutParentLinks(parent=v)
.. @+node:ekr.20031218072017.3425: *6* v._linkAsNthChild (used by 4.x read logic)
def _linkAsNthChild(self, parent_v, n):
    """Links self as the n'th child of VNode pv"""
    v = self # The child node.
    v._addLink(n, parent_v)
.. @+node:ekr.20090130065000.1: *5* v.Properties
.. @+node:ekr.20090130114732.5: *6* v.b Property
def __get_b(self):
    v = self
    return v.bodyString()

def __set_b(self, val):
    v = self
    v.setBodyString(val)

b = property(
    __get_b, __set_b,
    doc="VNode body string property")
.. @+node:ekr.20090130125002.1: *6* v.h property
def __get_h(self):
    v = self
    return v.headString()

def __set_h(self, val):
    v = self
    v.setHeadString(val)

h = property(
    __get_h, __set_h,
    doc="VNode headline string property")
.. @+node:ekr.20090130114732.6: *6* v.u Property
def __get_u(self):
    v = self
    # Wrong: return getattr(v, 'unknownAttributes', {})
    # It is does not set v.unknownAttributes, which can cause problems.
    if not hasattr(v, 'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self, val):
    v = self
    if val is None:
        if hasattr(v, 'unknownAttributes'):
            delattr(v, 'unknownAttributes')
    elif isinstance(val, dict):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc="VNode u property")
.. @+node:ekr.20090215165030.1: *6* v.gnx Property
def __get_gnx(self):
    v = self
    return v.fileIndex

gnx = property(
    __get_gnx, # __set_gnx,
    doc="VNode gnx property")
.. @+node:ekr.20170619165453.1: *3* Branch: string-gui
Attempt to run all unit tests without using Qt gui code.
All gui-related code will be simulated with the StringTextWrapper class.
.. @+node:ekr.20100208071151.5910: ** cacher.createOutlineFromCacheList & helpers
def createOutlineFromCacheList(self, parent_v, aList, fileName, top=True):
    '''
    Create outline structure from recursive aList built by makeCacheList.
    '''
    trace = False and not g.unitTesting
    c = self.c
    if not c:
        g.internalError('no c')
    if top:
        if trace: g.trace(g.shortFileName(fileName))
        c.cacheListFileName = fileName
    if not aList:
        if trace: g.trace('no list')
        return
    h, b, gnx, children = aList
    if h is not None:
        v = parent_v
        v._headString = g.toUnicode(h)
        v._bodyString = g.toUnicode(b)
    for child_tuple in children:
        h, b, gnx, grandChildren = child_tuple
        if trace:
            g.trace('%9s %3s %s' % (gnx, len(grandChildren), h.strip()))
        isClone, child_v = self.fastAddLastChild(fileName, gnx, parent_v)
        if isClone:
            self.checkForChangedNodes(child_tuple, fileName, parent_v)
        else:
            self.createOutlineFromCacheList(child_v, child_tuple, fileName, top=False)
.. @+node:ekr.20100208071151.5911: *3* cashe.fastAddLastChild
# Similar to createThinChild4

def fastAddLastChild(self, fileName, gnxString, parent_v):
    '''
    Create new VNode as last child of the receiver.
    If the gnx exists already, create a clone instead of new VNode.
    '''
    trace = False and not g.unitTesting
    c = self.c
    gnxString = g.toUnicode(gnxString)
    gnxDict = c.fileCommands.gnxDict
    if gnxString is None: v = None
    else: v = gnxDict.get(gnxString)
    is_clone = v is not None
    if trace: g.trace(
        'clone', '%-5s' % (is_clone),
        'parent_v', parent_v, 'gnx', gnxString, 'v', repr(v))
    if is_clone:
        pass
    else:
        if gnxString:
            assert g.isUnicode(gnxString)
            v = leoNodes.VNode(context=c, gnx=gnxString)
            if g.trace_gnxDict: g.trace(c.shortFileName(), gnxString, v)
        else:
            v = leoNodes.VNode(context=c)
            # This is not an error: it can happen with @auto nodes.
            # g.trace('**** no gnx for',v,parent_v)
        # Indicate that this node came from an external file.
        v.tempRoots = set()
        v.tempRoots.add(fileName)
    child_v = v
    child_v._linkAsNthChild(parent_v, parent_v.numberOfChildren())
    child_v.setVisited() # Supress warning/deletion of unvisited nodes.
    return is_clone, child_v
.. @+node:ekr.20100705083838.5740: *3* casher.reportChangedNode
def reportChangedNode(self, child_tuple, child_v, fileName, parent_v):
    '''
    Report changes in a node child_v.
    
    Nodes can be out-of-synch with other nodes in two ways:
    
    Common: When switching git branches.
    Rare:   When external files have been changed outside Leo.
    
    It is only essential to warn of the rare case.
    '''
    trace = (False or g.app.debug) and not g.unitTesting
    always_warn = True # True always warn about changed nodes.
    c = self.c
    h, b, gnx, grandChildren = child_tuple
    old_b, new_b = child_v.b, b
    old_h, new_h = child_v.h, h
    # Leo 5.6: test headlines.
    same_head = old_h == new_h
    same_body = (
        old_b == new_b or
        new_b.endswith('\n') and old_b == new_b[: -1] or
        old_b.endswith('\n') and new_b == old_b[: -1]
    )
    if same_head and same_body:
        return
    if trace:
        g.trace(repr(old_h), repr(new_h))
        g.trace('old %4s new %s %s' % (len(old_b), len(new_b), h))
    must_warn = hasattr(child_v, 'tempRoots') or not child_v.isCloned()
    if not hasattr(child_v, 'tempRoots'):
        child_v.tempRoots = set()
    child_v.tempRoots.add(fileName)
    if must_warn:
        self.warning('Warning: out-of-synch node: %s' % (h))
        g.es_print('Retaining node in %s' % (fileName))
    if always_warn or must_warn:
        c.nodeConflictList.append(g.bunch(
            tag='(cached)',
            fileName=fileName,
            gnx=gnx,
            b_old=child_v.b,
            h_old=child_v.h,
            b_new=b,
            h_new=h,
            root_v=parent_v,
        ))
    # Always update the node.
    child_v.h, child_v.b = h, b
    child_v.setDirty()
    c.changed = True # Tell getLeoFile to propegate dirty nodes.
.. @+node:ekr.20170622112151.1: *3* cacher.checkForChangedNodes
update_warning_given = False

def checkForChangedNodes(self, child_tuple, fileName, parent_v):
    '''
    Update the outline described by child_tuple, including all descendants.
    '''
    junk_h, junk_b, gnx, grand_children = child_tuple
    child_v = self.c.fileCommands.gnxDict.get(gnx)
    if child_v:
        self.reportChangedNode(child_tuple, child_v, fileName, parent_v)
        for grand_child in grand_children:
            self.checkForChangedNodes(grand_child, fileName, child_v)
    elif not self.update_warning_given:
        self.update_warning_given = True
        g.internalError('no vnode', child_tuple)
.. @-all
.. @@nosearch
.. @@killbeautify
.. @@language rest
.. @@wrap
.. @@pagewidth 60
.. @-leo
