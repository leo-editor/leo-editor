.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @+all
.. @+node:ekr.20170325085902.1: ** 5.6
.. @+node:ekr.20170326052206.1: *3* bugs
.. @+node:ekr.20170403181726.1: *4* #385: Leo doesn't remember new headlines after saves
https://github.com/leo-editor/leo-editor/issues/385
.. @+node:ekr.20170324115046.1: *4* #386: colorize markdown properly
https://github.com/leo-editor/leo-editor/issues/386
All changes made to leo/modes/md.py
.. @+node:ekr.20170315103331.1: *4* #438: Tree abbreviation placeholders in headlines...
https://github.com/leo-editor/leo-editor/issues/438
.. @+node:ekr.20170411191726.1: *4* #449 & #470: Spontaneous node generation
https://github.com/leo-editor/leo-editor/issues/470

See also:
https://github.com/leo-editor/leo-editor/issues/449
The original fix was in i.run in linescanner.py.
.. @+node:ekr.20170330024242.1: *4* #451: refresh-from-disk selects wrong node
https://github.com/leo-editor/leo-editor/issues/451
refresh-from-disk doesn't always restore focus to the correct node

- at.readOneAtAutoNode returns the *new* position.
- c.refreshFromDisk selects that position.
.. @+node:ekr.20170401202930.1: *4* #453: Focus jumps to body when expanding abbrev in a headline
https://github.com/leo-editor/leo-editor/issues/453
Focus jumps to de body pane when expanding an abbreviation in a headline.

The fix was in find_place_holder. It should not set focus if no placeholder found.
.. @+node:ekr.20170402034115.1: *4* #456: replace-all is very slow
Made several changes to find.batchChange.
.. @+node:ekr.20170402035751.1: *4* #458: Chapters drop-down list is not automatically resized
https://github.com/leo-editor/leo-editor/issues/458
Set a Qt flag in tt.createControl.
.. @+node:ekr.20170428063311.1: *4* #466: Moving a node can cause temporary coloring issues
https://github.com/leo-editor/leo-editor/issues/466

- Added LeoHighlighter.force_rehighlight.
- Rewrote 'recolor' command (c.force_recolor).
- Rewrote c.recolor_now.
- Added calls to c.recolor_now to c.moveOutline*.
.. @+node:ekr.20170411072038.1: *4* #471: UnicodeDecodeError in writeRecentFilesFileHelper
UnicodeDecodeError in writeRecentFilesFileHelper
https://github.com/leo-editor/leo-editor/issues/471

The fix was in rf.writeRecentFilesFileHelper.
.. @+node:ekr.20170411072045.1: *4* #472: @clean nodes stopped updating
https://github.com/leo-editor/leo-editor/issues/472

Solved: the checks are made only if @bool check_for_changed_external_files = True

Changed code in efc.on_idle and efc.idle_check_commander.
.. @+node:ekr.20170425070312.1: *4* #476: (error in cacher.fileKey)
https://github.com/leo-editor/leo-editor/issues/476
.. @+node:ekr.20170428144545.1: *4* #487: g.IdleTime docstring
https://github.com/leo-editor/leo-editor/issues/487
.. @+node:ekr.20170528061812.1: *4* Ensure that .leo/.leoRecentFiles.txt is closed
https://github.com/leo-editor/leo-editor/pull/497

Rewrote rf.createRecentFiles, rf.readRecentFilesFile and rf.writeRecentFilesFileHelper.
.. @+node:ekr.20170608072053.84: *4* Ensure that .leo/.leoRecentFiles.txt is closed.
https://github.com/leo-editor/leo-editor/pull/497

Rewrote rf.createRecentFiles, rf.readRecentFilesFile and rf.writeRecentFilesFileHelper.
.. @+node:ekr.20170326054533.1: *4* Fixed bug in k.computeInverseBindingDict
The bug gave way too many bindings for the move-lines commands.
.. @+node:ekr.20170326113032.1: *4* Fixed bug in tab completion
ga.show_tab_list wasn't showing commands without any shortcuts!
.. @+node:ekr.20170406091617.1: *4* Fixed bugs re plugins registration
Fixed plugins.registerOneHandler and plugins.registerOneExclusiveHandler
.. @+node:ekr.20170427164915.1: *4* Fixed html import problem
The unit test "@test xml non-ascii tags" failed on Python 2, but not Python 3.

The fix was in xml_i.scan_tag & helper
.. @+node:ekr.20170406095247.1: *4* Fixed serious bug in c.checkFileTimeStamp
It must return True if g.app.externalFilesController is None.
.. @+node:ekr.20170401132710.1: *4* Fixed several problems with goto-global-line
.. @+node:ekr.20170608072053.88: *4* #498: --session-restore option fails if no leo.session exists
https://github.com/leo-editor/leo-editor/issues/498

With a new installation of Leo there is no leo.session file. It is apparently created only after using the --session-save command line option.

If the --session-restore option is also used before that file is created, then Leo fails to open (splash screen displays, then nothing else happens).
.. @+node:ekr.20170416063625.1: *4* Revised xml/html importers
The new code is simpler and handles dubious html syntax.
.. @+node:ekr.20170329145930.1: *4* The pylint command now warns if pylint has not been installed
The change was to pylint.run_pylint.

This removes a major source of confusion.
.. @+node:ekr.20170617113038.1: *4* #479: Preserve brython indentation...
https://github.com/leo-editor/leo-editor/issues/479
Preserve brython indentation when importing .html files
.. @+node:ekr.20170618015241.1: *4* #481: The python importer optionally puts method decorators in headlines
https://github.com/leo-editor/leo-editor/issues/481
.. @+node:ekr.20170325085907.1: *3* code
.. @+node:ekr.20170325085939.1: *4* Added better checks in v.setBodyString & v.setHeadString
.. @+node:ekr.20170331043509.1: *4* Improved @auto write code
- Removed the allow_at_auto_section switch in leoAtFile.py.

- When writing @auto files << handle line at s[i] >> in at.putBody now expands section references in @auto files *if* they are defined. Otherwise, lines containing undefined section references are written as plain code lines.
.. @+node:ekr.20170331043931.1: *4* Added gen_refs keyword arg to Importer ctor
This makes explicit which importers actually generate section reference. At present, only the javascript importer sets this arg.
.. @+node:ekr.20170403182514.1: *4* Updated docs re #464
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/464

**Warning**: The p.b and p.h setters and p.setDirty() are *very* expensive:

- p.b = s calls c.setBodyString(p, s) which will recolor body text and update the node's icon.
- p.h = s calls c.setHeadString(p, s) which calls p.setDirty().
- p.setDirty() changes the icons of all ancestor @file nodes.

In contrast, the corresponding p.v.b and p.v.b setters and p.v.setDirty() are extremely fast.

Usually, code *should* use the p.b and p.h setters and p.setDirty(), despite their cost, because they update Leo's outline pane properly. Calling c.redraw() is *not* enough.

These performance gotchas become important for repetitive commands, like cff, replace-all and recursive import. In such situations, code should use p.v.b and p.v.h setters instead of p.b and p.h setters.
.. @+node:ekr.20170404032504.1: *4* Added 'recursive' keyword arg to recursive import API
Added 'recursive' keyword arg to c.recursiveImport and RecursiveImportController ctor.
Recursive is *not* the same as not one_file.
.. @+node:ekr.20170406092043.1: *4* Removed atAuto from atFile class
Ding dong, the switch is dead, the wicked old switch is dead.
.. @+node:ekr.20170412055006.1: *4* Added g.Git functions
leoGlobals.py the following functions and their helpers in the .Git subtree:

- branch, commit = g.gitInfo(path = None)
- date, build = g.jsonCommitInfo()
- branch = g.gitBranchName(path = None)
- commit = g.getCommitNumber(path = None)

The path should be a folder containing a .git subfolder. If the path is None, the leo-editor folder is used.

Leo's cacher code will soon use the branch name returned by g.gitInfo() to ensure that switching git branches works properly.

As a happy side effect, these methods completely collapse the complexity of leoVersion.py. 
.. @+node:ekr.20170427171721.1: *4* Added traces to c.doCommand to detect multiple redraws
These traces detected nothing unusual and have been disabled.
.. @+node:ekr.20170608072053.74: *4* Use 'with' statement to simplify code
Improved g.SherlockTracer.do_line, g.gitInfo, g.is_binary_external_file, g.log, g.readFileToUnicodeString.
.. @+node:ekr.20170403190659.1: *3* docs
.. @+node:ekr.20170325090029.1: *3* features
.. @+node:ekr.20170325045838.1: *4* #448: Add abbreviations for commands
https://github.com/leo-editor/leo-editor/issues/448

If the expansion of an abbrevitiation is a command name, that command will be executed. Alas, this isn't very useful: typing destroys selection ranges.

This took only a few lines of code in abbrev.expandAbbrev.
.. @+node:ekr.20170509091900.1: *4* #484: improve menus
https://github.com/leo-editor/leo-editor/issues/484

Added submenus to Windows menu. This significantly simplifies and clarifies the Windows menu.
.. @+node:ekr.20170608071935.1: *4* #488: Created a curses/npyscreen front end for Leo
https://github.com/leo-editor/leo-editor/issues/488
.. @+node:ekr.20170614051052.1: *4* Added "yes/no to all" buttons for externally changed file dialog
Rev 9c94fec36d adds Yes / no to all on external file changes.

If you answer yes to all or no to all Leo remembers that
answer for 3 seconds. As a result, another set of external
changes will show the pop up again.
.. @+node:ekr.20170411191401.1: *4* Added  git branch name to backed-up files
.. @+node:ekr.20170328143013.1: *4* Added --trace-focus command-line argument
.. @+node:ekr.20170411092513.1: *4* Added goto-any-clone command
Searches from c.p for *any* clone, not just a clone of c.p.  Useful for eliminating all clones from a .leo file.

This command is different from goto-next-clone as follows:

- goto-any-clone goes to the next clone, regardless of whether c.p is a clone.
- goto-any-clone does not wrap. It prints a message when no clones remain.
.. @+node:ekr.20170430033223.1: *4* Added log listener commands
@language rest
@wrap

The log-listen (aka listen-to-log) and kill-log-listen (aka, listen-log-kill) commands implement this logging cookbook recipe:
https://docs.python.org/2/howto/logging-cookbook.html#sending-and-receiving-logging-events-across-a-network

The log-listen command creates a logging listener whose output goes to Leo's console. The listener runs in a separate process so that Leo doesn't hang.

Start the listener first, then start another process in another console. All logging output from the second process will be captured and displayed by the listener, provided that the second process includes a call to `rootLogger.addHandler(socketHandler)`.

leo/external/log_broadcast.py contains example code. leo/plugins/cursesGui2.py uses this pattern to broadcast g.trace.



.. @+node:ekr.20170325090032.1: *4* Added show-color-names command
.. @+node:ekr.20170427173032.1: *4* clone-find commands report number of matches in root node
Changed find.createCloneFindAllNodes and c.cloneFindMarkedHelper.
.. @+node:ekr.20170327052423.1: *4* Improved "Write Existing File?" dialog
at.promptForDangerousWrite puts up a dialog with a clearer cancel button.
All tests pass.

- It says "Cancel (No To All)".
- Added cancelMessage keyword arg to x.promptForDangerousWrite.
- Use keyword args in LeoFrame.promptForSave and ns_do_context.
.. @+node:ekr.20170414103904.1: *4* Improved caching
Rev b32259 transitions to a new caching scheme:

1. All hashes now use the full path to the external file.  Previously, the headline of @file nodes was typically used instead. Surely this might have caused silent problems.

2. Leo's hasher now includes the name of the present git branch in the hash. When switching git branches, this in essence disables hashing for all files changed in the previous branch.
.. @+node:ekr.20170326091637.1: *4* Improved indent-region and unindent-region commands
https://groups.google.com/d/msg/leo-editor/SUnqs1_YbeI/DIv0EbtFCgAJ

The indent-region and unindent-region just move the insert point if there is no text selected.
.. @+node:ekr.20170326052408.1: *4* Improved move-lines-up/down commands
These commands (bound to ctrl-up/down by default) now work at the top or bottom of the body pane. The move-lines-up command inserts a new line below the moved line/lines when the lines are at the top of the body text.  Similarly, the move-lines-down command inserts a line before the moved lines when at the bottom of the body text. Imo, this is a natural and useful.
.. @+node:ekr.20170530023214.1: *4* Restored importer;; abbreviation
55b2037ac3a: 2016-11-22 06:33:17 Removed importer;; abbreviation(!!)


Restored the abbreviation from f10fa02b8cb681, the previous commit.
.. @+node:ekr.20170616100339.1: *4* Added tcl importer
.. @+node:ekr.20170618083013.1: *4* Added toggle-auto-edit command
https://github.com/leo-editor/leo-editor/issues/482

This command is surprisingly useful.  It toggles between a flattened view (@edit) and an outline view (@auto) of an external file containing no sentinels.

This command preserves the presently selected line when flattening/un-flattening the outline. You can run this command from any descendant of an @auto node.
.. @+node:ekr.20170618083013.2: *5* efc.toggleAtAutoAtEdit & helpers
@cmd('toggle-at-auto-at-edit')
def toggleAtAutoAtEdit(self, event):
    '''Toggle between @auto and @edit, preserving insert point, etc.'''
    p = self.c.p
    if p.isAtEditNode():
        self.toAtAuto(p)
        return
    for p in p.self_and_parents():
        if p.isAtAutoNode():
            self.toAtEdit(p)
            return
    g.es_print('Not in an @auto or @edit tree.', color='blue')
.. @+node:ekr.20170618083013.3: *6* efc.toAtAuto
def toAtAuto(self, p):
    '''Convert p from @edit to @auto.'''
    c = self.c
    # Change the headline.
    p.h = '@auto' + p.h[5:]
    # Compute the position of the present line within the file.
    w = c.frame.body.wrapper
    ins = w.getInsertPoint()
    row, col = g.convertPythonIndexToRowCol(p.b, ins)
    # Ignore *preceding* directive lines.
    directives = [z for z in g.splitLines(c.p.b)[:row] if g.isDirective(z)]
    row -= len(directives)
    row = max(0, row)
    # Reload the file, creating new nodes.
    c.selectPosition(p, enableRedrawFlag=False)
    c.refreshFromDisk()
    # Restore the line in the proper node.
    c.gotoCommands.find_file_line(row+1)
    p.setDirty()
    c.setChanged()
    c.redraw()
    c.bodyWantsFocus()
.. @+node:ekr.20170618083013.4: *6* efc.toAtEdit
def toAtEdit(self, p):
    '''Convert p from @auto to @edit.'''
    c = self.c
    w = c.frame.body.wrapper
    p.h = '@edit' + p.h[5:]
    # Compute the position of the present line within the *selected* node c.p
    ins = w.getInsertPoint()
    row, col = g.convertPythonIndexToRowCol(c.p.b, ins)
    # Ignore directive lines.
    directives = [z for z in g.splitLines(c.p.b)[:row] if g.isDirective(z)]
    row -= len(directives)
    row = max(0, row)
    # Count preceding lines from p to c.p, again ignoring directives.
    for p2 in p.self_and_subtree():
        if p2 == c.p:
            break
        lines = [z for z in g.splitLines(p2.b) if not g.isDirective(z)]
        row += len(lines)
    # Reload the file into a single node.
    c.selectPosition(p, enableRedrawFlag=False)
    c.refreshFromDisk()
    # Restore the line in the proper node.
    ins = g.convertRowColToPythonIndex(p.b, row+1, 0)
    w.setInsertPoint(ins)
    p.setDirty()
    c.setChanged()
    c.redraw()
    c.bodyWantsFocus()
.. @+node:ekr.20170619155533.1: *4* Improved operation of command history
The first UP-arrow to gives the presvious command, the next up-arrow gives the next command, etc.
.. @+node:ekr.20170403192311.1: *3* plugins
.. @+node:ekr.20170403192317.1: *4* screen_capture.py now enabled by default
.. @+node:ekr.20170331043621.1: *3* settings
.. @+node:ekr.20170328043328.1: *4* Added ctrl-shift < and > bindings
@language rest
@wrap

These are bound to indent/unindent-region and can be used when no text is selected.
.. @+node:ekr.20170427110630.1: *4* Restored default: @bool check_for_changed_external_files = True
.. @+node:ekr.20170330083957.1: *4* Retired @bool allow_section_references_in_at_auto
The disabled setting now contains this comment:

    **Note**: This setting has been retired for the following reasons:
    
    1. The new javascript importer *always* generate section references
    for non-trivial programs. As a result, the legacy value for this
    setting would cause the javascript importer to fail.
    
    2. The new @auto write code writes expands section references if
    they exist. Otherwise, the write code writes the line as is,
    without any complaint. As a result, there should be no problem if
    an imported code contains something that looks like a section
    reference but isn't.
.. @+node:ekr.20170619154105.1: *3* Branch: tree-gen
@language rest
@wrap

Adds c.frame.tree.generation count.
- Update count in v._addLink and v._cutlink.
- Use the count in LeoValues to avoid unnecessary recalcularion.
.. @+node:ekr.20031218072017.3341: *4* class VNode
@nobeautify

class VNodeBase(object):
    << VNode constants >>
    @others

if use_zodb and ZODB:

    class VNode(ZODB.Persistence.Persistent, VNodeBase):
        pass

else:
    VNode = VNodeBase

vnode = VNode # compatibility.

@beautify
.. @+node:ekr.20031218072017.951: *5* << VNode constants >>
# Define the meaning of status bits in new vnodes.
# Archived...
clonedBit = 0x01 # True: VNode has clone mark.
# unused      0x02
expandedBit = 0x04 # True: VNode is expanded.
markedBit = 0x08 # True: VNode is marked
# unused    = 0x10 # (was orphanBit)
selectedBit = 0x20 # True: VNode is current VNode.
topBit = 0x40 # True: VNode was top VNode when saved.
# Not archived...
richTextBit = 0x080 # Determines whether we use <bt> or <btr> tags.
visitedBit = 0x100
dirtyBit = 0x200
writeBit = 0x400
orphanBit = 0x800 # True: error in @<file> tree prevented it from being written.
.. @+node:ekr.20031218072017.3342: *5* v.Birth & death
.. @+node:ekr.20031218072017.3344: *6* v.__init
def __init__(self, context, gnx=None):
    '''
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    '''
    # The primary data: headline and body text.
    self._headString = g.u('newHeadline')
    self._bodyString = g.u('')
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
.. @+node:ekr.20031218072017.3345: *6* v.__repr__ & v.__str__
def __repr__(self):
    return "<VNode %7x %s>" % (id(self), self.cleanHeadString())

__str__ = __repr__
.. @+node:ekr.20040312145256: *6* v.dump
def dumpLink(self, link):
    return link if link else "<none>"

def dump(self, label=""):
    v = self
    print('%s %s %s' % ('-' * 10, label, v))
    print('len(parents) %s' % len(v.parents))
    print('len(children) %s' % len(v.children))
    print('parents %s' % g.listToString(v.parents))
    print('children%s' % g.listToString(v.children))
.. @+node:ekr.20060910100316: *6* v.__hash__ (only for zodb)
if use_zodb and ZODB:

    def __hash__(self):
        return self.__hash__()
.. @+node:ekr.20031218072017.3346: *5* v.Comparisons
.. @+node:ekr.20040705201018: *6* v.findAtFileName
def findAtFileName(self, names, h=''):
    '''Return the name following one of the names in nameList or ""'''
    # Allow h argument for unit testing.
    if not h: h = self.headString()
    # if h.startswith('@auto-test'): g.trace(h,'@auto-test' in names)
    if not g.match(h, 0, '@'):
        return ""
    i = g.skip_id(h, 1, '-')
    word = h[: i]
    if word in names and g.match_word(h, 0, word):
        name = h[i:].strip()
        # g.trace(repr(word),repr(name))
        return name
    else:
        return ""
.. @+node:ekr.20031218072017.3350: *6* v.anyAtFileNodeName
def anyAtFileNodeName(self):
    """Return the file name following an @file node or an empty string."""
    return (
        self.findAtFileName(g.app.atAutoNames) or
        self.findAtFileName(g.app.atFileNames))
.. @+node:ekr.20031218072017.3348: *6* v.at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName(self, h=None):
    return self.findAtFileName(g.app.atAutoNames, h=h)
# Retain this special case as part of the "escape hatch".
# That is, we fall back on code in leoRst.py if no
# importer or writer for reStructuredText exists.

def atAutoRstNodeName(self, h=None):
    names = ("@auto-rst",)
    return self.findAtFileName(names, h=h)

def atCleanNodeName(self):
    names = ("@clean",)
    return self.findAtFileName(names)

def atEditNodeName(self):
    names = ("@edit",)
    return self.findAtFileName(names)

def atFileNodeName(self):
    names = ("@file", "@thin")
        # Fix #403.
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName(self):
    names = ("@nosent", "@file-nosent",)
    return self.findAtFileName(names)

def atRstFileNodeName(self):
    names = ("@rst",)
    return self.findAtFileName(names)

def atShadowFileNodeName(self):
    names = ("@shadow",)
    return self.findAtFileName(names)

def atSilentFileNodeName(self):
    names = ("@asis", "@file-asis",)
    return self.findAtFileName(names)

def atThinFileNodeName(self):
    names = ("@thin", "@file-thin",)
    return self.findAtFileName(names)
# New names, less confusing

atNoSentFileNodeName = atNoSentinelsFileNodeName
atAsisFileNodeName = atSilentFileNodeName
.. @+node:EKR.20040430152000: *6* v.isAtAllNode
def isAtAllNode(self):
    """Returns True if the receiver contains @others in its body at the start of a line."""
    flag, i = g.is_special(self._bodyString, 0, "@all")
    return flag
.. @+node:ekr.20040326031436: *6* v.isAnyAtFileNode
def isAnyAtFileNode(self):
    """Return True if v is any kind of @file or related node."""
    # This routine should be as fast as possible.
    # It is called once for every VNode when writing a file.
    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
.. @+node:ekr.20040325073709: *6* v.isAt...FileNode
def isAtAutoNode(self):
    return bool(self.atAutoNodeName())

def isAtAutoRstNode(self):
    return bool(self.atAutoRstNodeName())

def isAtCleanNode(self):
    return bool(self.atCleanNodeName())

def isAtEditNode(self):
    return bool(self.atEditNodeName())

def isAtFileNode(self):
    return bool(self.atFileNodeName())

def isAtRstFileNode(self):
    return bool(self.atRstFileNodeName())

def isAtNoSentinelsFileNode(self):
    return bool(self.atNoSentinelsFileNodeName())

def isAtSilentFileNode(self): # @file-asis
    return bool(self.atSilentFileNodeName())

def isAtShadowFileNode(self):
    return bool(self.atShadowFileNodeName())

def isAtThinFileNode(self):
    return bool(self.atThinFileNodeName())
# New names, less confusing:

isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtAsisFileNode = isAtSilentFileNode
.. @+node:ekr.20031218072017.3351: *6* v.isAtIgnoreNode
def isAtIgnoreNode(self):
    """Returns True if the receiver contains @ignore in its body at the start of a line.

    or if the headline starts with @ignore."""
    # v = self
    # 2011/10/08: honor @ignore in headlines.  Sheesh.
    if g.match_word(self._headString, 0, '@ignore'):
        return True
    else:
        flag, i = g.is_special(self._bodyString, 0, "@ignore")
        return flag
.. @+node:ekr.20031218072017.3352: *6* v.isAtOthersNode
def isAtOthersNode(self):
    """Returns True if the receiver contains @others in its body at the start of a line."""
    flag, i = g.is_special(self._bodyString, 0, "@others")
    return flag
.. @+node:ekr.20031218072017.3353: *6* v.matchHeadline
def matchHeadline(self, pattern):
    """Returns True if the headline matches the pattern ignoring whitespace and case.

    The headline may contain characters following the successfully matched pattern."""
    v = self
    h = g.toUnicode(v.headString())
    h = h.lower().replace(' ', '').replace('\t', '')
    h = h.lstrip('.') # 2013/04/05. Allow leading period before section names.
    pattern = g.toUnicode(pattern)
    pattern = pattern.lower().replace(' ', '').replace('\t', '')
    return h.startswith(pattern)
.. @+node:ekr.20160502100151.1: *5* v.copyTree
def copyTree(self, copyMarked=False):
    '''
    Return an all-new tree of vnodes that are copies of self and all its
    descendants.

    **Important**: the v.parents ivar must be [] for all nodes.
    v._addParentLinks will set all parents.
    '''
    v = self
    # Allocate a new vnode and gnx with empty children & parents.
    v2 = VNode(context=v.context, gnx=None)
    assert v2.parents == [], v2.parents
    assert v2.gnx
    assert v.gnx != v2.gnx
    # Copy vnode fields. Do **not** set v2.parents.
    v2._headString = g.toUnicode(v._headString, reportErrors=True) # 2017/01/24
    v2._bodyString = g.toUnicode(v._bodyString, reportErrors=True) # 2017/01/24
    v2.u = copy.deepcopy(v.u)
    if copyMarked and v.isMarked():
        v2.setMarked()
    # Recursively copy all descendant vnodes.
    for child in v.children:
        v2.children.append(child.copyTree(copyMarked))
    return v2
.. @+node:ekr.20031218072017.3359: *5* v.Getters
.. @+node:ekr.20031218072017.3378: *6* v.bodyString
body_unicode_warning = False

def bodyString(self):
    # This message should never be printed and we want to avoid crashing here!
    if g.isUnicode(self._bodyString):
        return self._bodyString
    else:
        if not self.body_unicode_warning:
            self.body_unicode_warning = True
            g.internalError('not unicode:', repr(self._bodyString))
        return g.toUnicode(self._bodyString)

getBody = bodyString
    # Deprecated, but here for compatibility.
.. @+node:ekr.20031218072017.3360: *6* v.Children
.. @+node:ekr.20031218072017.3362: *7* v.firstChild
def firstChild(self):
    v = self
    return v.children and v.children[0]
.. @+node:ekr.20040307085922: *7* v.hasChildren & hasFirstChild
def hasChildren(self):
    v = self
    return len(v.children) > 0

hasFirstChild = hasChildren
.. @+node:ekr.20031218072017.3364: *7* v.lastChild
def lastChild(self):
    v = self
    return v.children[-1] if v.children else None
.. @+node:ekr.20031218072017.3365: *7* v.nthChild
# childIndex and nthChild are zero-based.

def nthChild(self, n):
    v = self
    if 0 <= n < len(v.children):
        return v.children[n]
    else:
        return None
.. @+node:ekr.20031218072017.3366: *7* v.numberOfChildren
def numberOfChildren(self):
    v = self
    return len(v.children)
.. @+node:ekr.20040323100443: *6* v.directParents
def directParents(self):
    """(New in 4.2) Return a list of all direct parent vnodes of a VNode.

    This is NOT the same as the list of ancestors of the VNode."""
    v = self
    return v.parents
.. @+node:ekr.20080429053831.6: *6* v.hasBody
def hasBody(self):
    '''Return True if this VNode contains body text.'''
    s = self._bodyString
    return s and len(s) > 0
.. @+node:ekr.20031218072017.1581: *6* v.headString & v.cleanHeadString
head_unicode_warning = False

def headString(self):
    """Return the headline string."""
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self._headString):
        if not self.head_unicode_warning:
            self.head_unicode_warning = True
            g.internalError('not unicode', repr(self._headString))
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self._headString)

def cleanHeadString(self):
    s = self._headString
    if g.isPython3:
        return s
    else:
        return g.toEncodedString(s, "ascii") # Replaces non-ascii characters by '?'
.. @+node:ekr.20131223064351.16351: *6* v.isNthChildOf
def isNthChildOf(self, n, parent_v):
    '''Return True if v is the n'th child of parent_v.'''
    v = self
    children = parent_v and parent_v.children
    return children and 0 <= n < len(children) and children[n] == v
.. @+node:ekr.20031218072017.3367: *6* v.Status Bits
.. @+node:ekr.20031218072017.3368: *7* v.isCloned
def isCloned(self):
    return len(self.parents) > 1
.. @+node:ekr.20031218072017.3369: *7* v.isDirty
def isDirty(self):
    return (self.statusBits & self.dirtyBit) != 0
.. @+node:ekr.20031218072017.3371: *7* v.isMarked
def isMarked(self):
    return (self.statusBits & VNode.markedBit) != 0
.. @+node:ekr.20031218072017.3372: *7* v.isOrphan
def isOrphan(self):
    return (self.statusBits & VNode.orphanBit) != 0
.. @+node:ekr.20031218072017.3373: *7* v.isSelected
def isSelected(self):
    return (self.statusBits & VNode.selectedBit) != 0
.. @+node:ekr.20031218072017.3374: *7* v.isTopBitSet
def isTopBitSet(self):
    return (self.statusBits & self.topBit) != 0
.. @+node:ekr.20031218072017.3376: *7* v.isVisited
def isVisited(self):
    return (self.statusBits & VNode.visitedBit) != 0
.. @+node:ekr.20080429053831.10: *7* v.isWriteBit
def isWriteBit(self):
    v = self
    return (v.statusBits & v.writeBit) != 0
.. @+node:ekr.20031218072017.3377: *7* v.status
def status(self):
    return self.statusBits
.. @+node:ekr.20031218072017.3384: *5* v.Setters
.. @+node:ekr.20090830051712.6151: *6*  v.Dirty bits
.. @+node:ekr.20031218072017.3390: *7* v.clearDirty
def clearDirty(self):
    '''Clear the vnode dirty bit.'''
    v = self
    # g.trace(v.h,g.callers())
    v.statusBits &= ~v.dirtyBit
.. @+node:ekr.20090830051712.6153: *7* v.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):
    trace = False and not g.unitTesting
    v = self; c = v.context
    # Set the starting nodes.
    nodes = []
    newNodes = [v]
    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]
    # Remove the hidden VNode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root', c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)
    if trace: g.trace(nodes)
    return nodes
.. @+node:ekr.20090830051712.6157: *7* v.setAllAncestorAtFileNodesDirty
# Unlike p.setAllAncestorAtFileNodesDirty,
# there is no setDescendentsDirty arg.

def setAllAncestorAtFileNodesDirty(self):
    trace = False and not g.unitTesting
    verbose = False
    v = self
    dirtyVnodeList = []
    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = v.findAllPotentiallyDirtyNodes()
    if trace and verbose:
        for v in nodes:
            print(v.isDirty(), v.isAnyAtFileNode(), v)
    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]
    for v in dirtyVnodeList:
        v.setDirty() # Do not call p.setDirty here!
    if trace: g.trace(dirtyVnodeList)
    return dirtyVnodeList
.. @+node:ekr.20080429053831.12: *7* v.setDirty
def setDirty(self):
    '''Set the vnode dirty bit.'''
    # if self.h.startswith('@auto'):
    # g.trace('(v) %5s %30s' % (self.isDirty(),self.h),g.callers())
    self.statusBits |= self.dirtyBit
.. @+node:ekr.20031218072017.3386: *6*  v.Status bits
.. @+node:ekr.20031218072017.3389: *7* v.clearClonedBit
def clearClonedBit(self):
    self.statusBits &= ~self.clonedBit
.. @+node:ekr.20031218072017.3391: *7* v.clearMarked
def clearMarked(self):
    self.statusBits &= ~self.markedBit
.. @+node:ekr.20080429053831.8: *7* v.clearWriteBit
def clearWriteBit(self):
    self.statusBits &= ~self.writeBit
.. @+node:ekr.20031218072017.3392: *7* v.clearOrphan
def clearOrphan(self):
    # if self.h.startswith('@file'): g.trace(self.h,g.callers())
    self.statusBits &= ~self.orphanBit
.. @+node:ekr.20031218072017.3393: *7* v.clearVisited
def clearVisited(self):
    self.statusBits &= ~self.visitedBit
.. @+node:ekr.20031218072017.3395: *7* v.contract/expand/initExpandedBit/isExpanded
def contract(self):
    '''Contract the node.'''
    self.statusBits &= ~self.expandedBit

def expand(self):
    '''Expand the node.'''
    self.statusBits |= self.expandedBit

def initExpandedBit(self):
    '''Init self.statusBits.'''
    self.statusBits |= self.expandedBit

def isExpanded(self):
    '''Return True if the VNode expansion bit is set.'''
    return (self.statusBits & self.expandedBit) != 0
.. @+node:ekr.20031218072017.3396: *7* v.initStatus
def initStatus(self, status):
    self.statusBits = status
.. @+node:ekr.20031218072017.3397: *7* v.setClonedBit & initClonedBit
def setClonedBit(self):
    self.statusBits |= self.clonedBit

def initClonedBit(self, val):
    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~self.clonedBit
.. @+node:ekr.20031218072017.3398: *7* v.setMarked & initMarkedBit
def setMarked(self):
    self.statusBits |= self.markedBit

def initMarkedBit(self):
    self.statusBits |= self.markedBit
.. @+node:ekr.20031218072017.3399: *7* v.setOrphan
def setOrphan(self):
    '''Set the vnode's orphan bit.'''
    trace = (False or g.app.debug) and not g.unitTesting
    if trace and self.h.startswith('@file'):
        g.trace(self.h, g.callers())
    self.statusBits |= self.orphanBit
.. @+node:ekr.20031218072017.3400: *7* v.setSelected
# This only sets the selected bit.

def setSelected(self):
    self.statusBits |= self.selectedBit
.. @+node:ekr.20031218072017.3401: *7* v.setVisited
# Compatibility routine for scripts

def setVisited(self):
    self.statusBits |= self.visitedBit
.. @+node:ekr.20080429053831.9: *7* v.setWriteBit
def setWriteBit(self):
    self.statusBits |= self.writeBit
.. @+node:ekr.20031218072017.3385: *6* v.computeIcon & setIcon
def computeIcon(self):
    val = 0; v = self
    if v.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val

def setIcon(self):
    pass # Compatibility routine for old scripts
.. @+node:ekr.20100303074003.5636: *6* v.restoreCursorAndScroll
# Called only by LeoTree.selectHelper.

def restoreCursorAndScroll(self):
    '''Restore the cursor position and scroll so it is visible.'''
    trace = (False or g.trace_scroll) and not g.unitTesting
    traceTime = False and not g.unitTesting
    v = self
    ins = v.insertSpot
    # start, n = v.selectionStart, v.selectionLength
    spot = v.scrollBarSpot
    body = self.context.frame.body
    w = body.wrapper
    # Fix bug 981849: incorrect body content shown.
    if ins is None: ins = 0
    # This is very expensive for large text.
    if traceTime: t1 = time.time()
    if hasattr(body.wrapper, 'setInsertPoint'):
        if trace and ins: g.trace('ins', ins, 'spot', spot)
        w.setInsertPoint(ins)
    if traceTime:
        delta_t = time.time() - t1
        if delta_t > 0.1: g.trace('%2.3f sec' % (delta_t))
    # Override any changes to the scrollbar setting that might
    # have been done above by w.setSelectionRange or w.setInsertPoint.
    if spot is not None:
        w.setYScrollPosition(spot)
        v.scrollBarSpot = spot
    # Never call w.see here.
.. @+node:ekr.20100303074003.5638: *6* v.saveCursorAndScroll
def saveCursorAndScroll(self):
    trace = (False or g.trace_scroll) and not g.unitTesting
    v = self; c = v.context
    w = c.frame.body
    if not w: return
    try:
        v.scrollBarSpot = w.getYScrollPosition()
        v.insertSpot = w.getInsertPoint()
        if trace: g.trace(v.scrollBarSpot, v.insertSpot)
    except AttributeError:
        # 2011/03/21: w may not support the high-level interface.
        pass
.. @+node:ekr.20040315032144: *6* v.setBodyString & v.setHeadString
unicode_warning_given = False

def setBodyString(self, s):
    v = self
    if g.isUnicode(s):
        v._bodyString = s
    else:
        try:
            v._bodyString = g.toUnicode(s, reportErrors=True)
        except Exception:
            if not self.unicode_warning_given:
                self.unicode_warning_given = True
                g.internalError(s)
                g.es_exception()

def setHeadString(self, s):
    # Fix bug: https://bugs.launchpad.net/leo-editor/+bug/1245535
    # API allows headlines to contain newlines.
    v = self
    if g.isUnicode(s):
        v._headString = s.replace('\n','')
    else:
        try:
            s = g.toUnicode(s, reportErrors=True)
            v._headString = s.replace('\n','')
        except Exception:
            if not self.unicode_warning_given:
                self.unicode_warning_given = True
                g.internalError(s)
                g.es_exception()

initBodyString = setBodyString
initHeadString = setHeadString
setHeadText = setHeadString
setTnodeText = setBodyString
.. @+node:ekr.20031218072017.3402: *6* v.setSelection
def setSelection(self, start, length):
    v = self
    v.selectionStart = start
    v.selectionLength = length
.. @+node:ville.20120502221057.7498: *6* v.contentModified
def contentModified(self):
    g.contentModifiedSet.add(self)
.. @+node:ville.20120502221057.7499: *6* v.childrenModified
def childrenModified(self):
    g.childrenModifiedSet.add(self)
.. @+node:ekr.20130524063409.10700: *5* v.Inserting & cloning
def cloneAsNthChild(self, parent_v, n):
    # Does not check for illegal clones!
    v = self
    v._linkAsNthChild(parent_v, n)
    return v

def insertAsFirstChild(self):
    v = self
    return v.insertAsNthChild(0)

def insertAsLastChild(self):
    v = self
    return v.insertAsNthChild(len(v.children))

def insertAsNthChild(self, n):
    v = self
    assert 0 <= n <= len(v.children)
    v2 = VNode(v.context)
    v2._linkAsNthChild(v, n)
    assert v.children[n] == v2
    return v2
.. @+node:ekr.20080427062528.9: *5* v.Low level methods
.. @+node:ekr.20090706110836.6135: *6* v._addLink & helper
def _addLink(self, childIndex, parent_v, adjust=True):
    '''Adjust links after adding a link to v.'''
    trace = False and not g.unitTesting
    v = self
    # g.trace(v.context.frame.tree)
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()
    # Update parent_v.children & v.parents.
    parent_v.children.insert(childIndex, v)
    v.parents.append(parent_v)
    if trace:
        g.trace('*** added parent', parent_v, 'to', v,
                'len(parents)', len(v.parents))
    # Set zodb changed flags.
    v._p_changed = 1
    parent_v._p_changed = 1
    # If v has only one parent, we adjust all
    # the parents links in the descendant tree.
    # This handles clones properly when undoing a delete.
    if adjust:
        if len(v.parents) == 1:
            for child in v.children:
                child._addParentLinks(parent=v)
.. @+node:ekr.20090804184658.6129: *7* v._addParentLinks
def _addParentLinks(self, parent):
    trace = False and not g.unitTesting
    v = self
    v.parents.append(parent)
    if trace:
        g.trace('v', v.h, 'parent', parent.h, g.callers())
        # '*** added parent', parent, 'to', v, 'len(parents)', len(v.parents))
    if len(v.parents) == 1:
        for child in v.children:
            child._addParentLinks(parent=v)
.. @+node:ekr.20090804184658.6128: *6* v._cutLink
def _cutLink(self, childIndex, parent_v):
    '''Adjust links after cutting a link to v.'''
    v = self
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()
    assert parent_v.children[childIndex] == v
    del parent_v.children[childIndex]
    if parent_v in v.parents:
        v.parents.remove(parent_v)
    v._p_changed = 1
    parent_v._p_changed = 1
    # If v has no more parents, we adjust all
    # the parent links in the descendant tree.
    # This handles clones properly when deleting a tree.
    if not v.parents:
        for child in v.children:
            child._cutParentLinks(parent=v)
.. @+node:ekr.20090804190529.6133: *7* v._cutParentLinks
def _cutParentLinks(self, parent):
    trace = False and not g.unitTesting
    v = self
    if trace: g.trace('parent', parent, 'v', v)
    v.parents.remove(parent)
    if not v.parents:
        for child in v.children:
            child._cutParentLinks(parent=v)
.. @+node:ekr.20031218072017.3425: *6* v._linkAsNthChild (used by 4.x read logic)
def _linkAsNthChild(self, parent_v, n):
    """Links self as the n'th child of VNode pv"""
    v = self # The child node.
    v._addLink(n, parent_v)
.. @+node:ekr.20090130065000.1: *5* v.Properties
.. @+node:ekr.20090130114732.5: *6* v.b Property
def __get_b(self):
    v = self
    return v.bodyString()

def __set_b(self, val):
    v = self
    v.setBodyString(val)

b = property(
    __get_b, __set_b,
    doc="VNode body string property")
.. @+node:ekr.20090130125002.1: *6* v.h property
def __get_h(self):
    v = self
    return v.headString()

def __set_h(self, val):
    v = self
    v.setHeadString(val)

h = property(
    __get_h, __set_h,
    doc="VNode headline string property")
.. @+node:ekr.20090130114732.6: *6* v.u Property
def __get_u(self):
    v = self
    # Wrong: return getattr(v, 'unknownAttributes', {})
    # It is does not set v.unknownAttributes, which can cause problems.
    if not hasattr(v, 'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self, val):
    v = self
    if val is None:
        if hasattr(v, 'unknownAttributes'):
            delattr(v, 'unknownAttributes')
    elif isinstance(val, dict):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc="VNode u property")
.. @+node:ekr.20090215165030.1: *6* v.gnx Property
def __get_gnx(self):
    v = self
    return v.fileIndex

gnx = property(
    __get_gnx, # __set_gnx,
    doc="VNode gnx property")
.. @+node:ekr.20170619165453.1: *3* Branch: string-gui
Attempt to run all unit tests without using Qt gui code.
All gui-related code will be simulated with the StringTextWrapper class.
.. @+node:ekr.20170624151245.1: ** Stash
.. @+node:ekr.20170624151245.2: *3* Recent code
.. @+node:ekr.20170624151245.3: *4* Completed
.. @+node:ekr.20170624151245.5123: *5* match_word
def match_word(s, i, pattern):
    if 0:
        # Doesn't work (yet).
        pattern = re.compile('\b' + pattern + '\b')
        return pattern.match(s, i)
    else:
        if pattern is None:
            return False
        if i > 0 and g.isWordChar(s[i-1]): # Bug fix: 2017/06/01.
            return False
        j = len(pattern)
        if j == 0:
            return False
        if s.find(pattern, i, i + j) != i:
            return False
        if i + j >= len(s):
            return True
        ch = s[i + j]
        return not g.isWordChar(ch)
.. @+node:ekr.20170624151245.5: *5* re: quit dialog
.. @+node:ekr.20170624151245.6: *6* app.onQuit
@cmd('exit-leo')
def onQuit(self, event=None):
    '''Exit Leo, prompting to save unsaved outlines first.'''
    g.app.quitting = True
    # if trace: print('onQuit',g.app.save_session,g.app.sessionManager)
    if g.app.save_session and g.app.sessionManager:
        g.app.sessionManager.save_snapshot()
    while g.app.windowList:
        w = g.app.windowList[0]
        if not g.app.closeLeoWindow(w):
            break
    if g.app.windowList:
        g.app.quitting = False # If we get here the quit has been disabled.
.. @+node:ekr.20170624151245.7: *6* app.closeLeoWindow
def closeLeoWindow(self, frame, new_c=None, finish_quit=True):
    """
    Attempt to close a Leo window.

    Return False if the user veto's the close.

    finish_quit - usually True, close Leo when last file closes, but
                  False when closing an already-open-elsewhere file
                  during initial load, so UI remains for files
                  further along the command line.
    """
    trace = self.trace_shutdown and not g.unitTesting
    if trace: print('closeLeoWindow: %s' % frame.c.shortFileName())
    c = frame.c
    c.endEditing() # Commit any open edits.
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False
    g.app.recentFilesManager.writeRecentFilesFile(c)
        # Make sure .leoRecentFiles.txt is written.
    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False
    g.app.setLog(None) # no log until we reactive a window.
    g.doHook("close-frame", c=c)
        # This may remove frame from the window list.
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
        g.app.windowList.remove(frame)
    else:
        # Fix bug https://github.com/leo-editor/leo-editor/issues/69
        g.app.forgetOpenFile(fn=c.fileName(), force=True)
    if g.app.windowList:
        c2 = new_c or g.app.windowList[0].c
        g.app.selectLeoWindow(c2)
    elif finish_quit and not g.app.unitTesting:
        g.app.finishQuit()
    return True # The window has been closed.
.. @+node:ekr.20170624151245.8: *6* LeoFrame.promptForSave
def promptForSave(self):
    '''
    Prompt the user to save changes.
    Return True if the user vetos the quit or save operation.
    '''
    c = self.c
    # if g.app.gui.guiName() == 'curses':
        # g.trace('Saves disabled for curses gui')
        # return False
    theType = "quitting?" if g.app.quitting else "closing?"
    # See if we are in quick edit/save mode.
    root = c.rootPosition()
    quick_save = not c.mFileName and not root.next() and root.isAtEditNode()
    if quick_save:
        name = g.shortFileName(root.atEditNodeName())
    else:
        name = c.mFileName if c.mFileName else self.title
    answer = g.app.gui.runAskYesNoCancelDialog(c,
        title="Confirm",
        message='Save changes to %s before %s' % (
            g.splitLongFileName(name), theType))
    if answer == "cancel":
        return True # Veto.
    if answer == "no":
        return False # Don't save and don't veto.
    if not c.mFileName:
        root = c.rootPosition()
        if not root.next() and root.isAtEditNode():
            # There is only a single @edit node in the outline.
            # A hack to allow "quick edit" of non-Leo files.
            # See https://bugs.launchpad.net/leo-editor/+bug/381527
            # Write the @edit node if needed.
            if root.isDirty():
                c.atFileCommands.writeOneAtEditNode(root,
                    toString=False, force=True)
            return False # Don't save and don't veto.
        else:
            c.mFileName = g.app.gui.runSaveFileDialog(c,
                initialfile='',
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()
    if c.mFileName:
        if g.app.gui.guiName() == 'curses':
            g.pr('Saving: %s' % c.mFileName)
        ok = c.fileCommands.save(c.mFileName)
        return not ok # New in 4.2: Veto if the save did not succeed.
    else:
        return True # Veto.
.. @+node:ekr.20170624151245.9: *5* re: Revert bad fixes to #466
@language rest
@wrap

d4f481 on â€‹2017-04-28 06:34:10.

leoColorizer.py:
- Inserted force_rehighlight

leoCommands.py:
- Replaced c.updateSyntaxColor(p) with c.recolor_now(p) in 4 move commands.
- Lines 4629, 4661, 4689, 4759, etc.

** gco rev file

http://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git
** ga -p file

@language python

.. @+node:ekr.20170624151245.10: *6* leo_h.force_rehighlight
if 0:
    # Part of the failed fix for #466.
    
    def force_rehighlight(self, p):
        '''Force a complete rehighlighting of p.b.'''
        if hasattr(self, 'currentBlock') and self.colorizer.enabled:
            QtGui.QSyntaxHighlighter.rehighlight(self)
.. @+node:ekr.20170624151245.5135: *5* g.execGitCommand
def execGitCommand(command, directory):
    '''Execute the given git command in the given directory.'''
    git_dir = g.os_path_finalize_join(directory, '.git')
    if not g.os_path_exists(git_dir):
        g.trace('not found:', git_dir)
        return
    if '\n' in command:
        g.trace('removing newline from', command)
        command = command.replace('\n','')
    os.chdir(directory)
    p = subprocess.Popen(
        shlex.split(command),
        stdout=subprocess.PIPE,
        stderr=None, # Shows error traces.
        shell=False,
    )
    out, err = p.communicate()
    lines = [g.toUnicode(z) for z in g.splitLines(out or [])]
    return lines
.. @+node:ekr.20170624151245.12: *5* gcm.config_iter
def config_iter(self, c):
    '''Letters:
      leoSettings.leo
    D default settings
    F loaded .leo File
    M myLeoSettings.leo
    @ @button, @command, @mode.
    '''
    lm = g.app.loadManager
    suppressKind = ('shortcut', 'shortcuts', 'openwithtable')
    suppressKeys = (None, 'shortcut')
    d = c.config.settingsDict if c else lm.globalSettingsDict
    for key in sorted(list(d.keys())):
        if key not in suppressKeys:
            gs = d.get(key)
            assert g.isGeneralSetting(gs), gs
            if gs and gs.kind not in suppressKind:
                letter = lm.computeBindingLetter(gs.path)
                # g.trace('%3s %40s %s' % (letter,key,gs.val))
                yield key, gs.val, c, letter
.. @+node:ekr.20170624151245.13: *5* efc.toggleAtAutoAtEdit & helpers
@cmd('toggle-at-auto-at-edit')
def toggleAtAutoAtEdit(self, event):
    '''Toggle between @auto and @edit, preserving insert point, etc.'''
    p = self.c.p
    if p.isAtEditNode():
        self.toAtAuto(p)
        return
    for p in p.self_and_parents():
        if p.isAtAutoNode():
            self.toAtEdit(p)
            return
    g.es_print('Not in an @auto or @edit tree.', color='blue')
.. @+node:ekr.20170624151245.16: *6* efc.toAtAuto
def toAtAuto(self, p):
    '''Convert p from @edit to @auto.'''
    c = self.c
    # Change the headline.
    p.h = '@auto' + p.h[5:]
    # Compute the position of the present line within the file.
    w = c.frame.body.wrapper
    ins = w.getInsertPoint()
    row, col = g.convertPythonIndexToRowCol(p.b, ins)
    # Ignore *preceding* directive lines.
    directives = [z for z in g.splitLines(c.p.b)[:row] if g.isDirective(z)]
    row -= len(directives)
    row = max(0, row)
    # Reload the file, creating new nodes.
    c.selectPosition(p, enableRedrawFlag=False)
    c.refreshFromDisk()
    # Restore the line in the proper node.
    c.gotoCommands.find_file_line(row+1)
    p.setDirty()
    c.setChanged()
    c.redraw()
    c.bodyWantsFocus()
.. @+node:ekr.20170624151245.17: *6* efc.toAtEdit
def toAtEdit(self, p):
    '''Convert p from @auto to @edit.'''
    c = self.c
    w = c.frame.body.wrapper
    p.h = '@edit' + p.h[5:]
    # Compute the position of the present line within the *selected* node c.p
    ins = w.getInsertPoint()
    row, col = g.convertPythonIndexToRowCol(c.p.b, ins)
    # Ignore directive lines.
    directives = [z for z in g.splitLines(c.p.b)[:row] if g.isDirective(z)]
    row -= len(directives)
    row = max(0, row)
    # Count preceding lines from p to c.p, again ignoring directives.
    for p2 in p.self_and_subtree():
        if p2 == c.p:
            break
        lines = [z for z in g.splitLines(p2.b) if not g.isDirective(z)]
        row += len(lines)
    # Reload the file into a single node.
    c.selectPosition(p, enableRedrawFlag=False)
    c.refreshFromDisk()
    # Restore the line in the proper node.
    ins = g.convertRowColToPythonIndex(p.b, row+1, 0)
    w.setInsertPoint(ins)
    p.setDirty()
    c.setChanged()
    c.redraw()
    c.bodyWantsFocus()
.. @+node:ekr.20170624151245.16: *6* efc.toAtAuto
def toAtAuto(self, p):
    '''Convert p from @edit to @auto.'''
    c = self.c
    # Change the headline.
    p.h = '@auto' + p.h[5:]
    # Compute the position of the present line within the file.
    w = c.frame.body.wrapper
    ins = w.getInsertPoint()
    row, col = g.convertPythonIndexToRowCol(p.b, ins)
    # Ignore *preceding* directive lines.
    directives = [z for z in g.splitLines(c.p.b)[:row] if g.isDirective(z)]
    row -= len(directives)
    row = max(0, row)
    # Reload the file, creating new nodes.
    c.selectPosition(p, enableRedrawFlag=False)
    c.refreshFromDisk()
    # Restore the line in the proper node.
    c.gotoCommands.find_file_line(row+1)
    p.setDirty()
    c.setChanged()
    c.redraw()
    c.bodyWantsFocus()
.. @+node:ekr.20170624151245.17: *6* efc.toAtEdit
def toAtEdit(self, p):
    '''Convert p from @auto to @edit.'''
    c = self.c
    w = c.frame.body.wrapper
    p.h = '@edit' + p.h[5:]
    # Compute the position of the present line within the *selected* node c.p
    ins = w.getInsertPoint()
    row, col = g.convertPythonIndexToRowCol(c.p.b, ins)
    # Ignore directive lines.
    directives = [z for z in g.splitLines(c.p.b)[:row] if g.isDirective(z)]
    row -= len(directives)
    row = max(0, row)
    # Count preceding lines from p to c.p, again ignoring directives.
    for p2 in p.self_and_subtree():
        if p2 == c.p:
            break
        lines = [z for z in g.splitLines(p2.b) if not g.isDirective(z)]
        row += len(lines)
    # Reload the file into a single node.
    c.selectPosition(p, enableRedrawFlag=False)
    c.refreshFromDisk()
    # Restore the line in the proper node.
    ins = g.convertRowColToPythonIndex(p.b, row+1, 0)
    w.setInsertPoint(ins)
    p.setDirty()
    c.setChanged()
    c.redraw()
    c.bodyWantsFocus()
.. @+node:ekr.20170624151245.18: *4* re: #501: Create outline-oriented git diff
.. @+node:ekr.20170624151245.5572: *5* fc.handleNodeConflicts
def handleNodeConflicts(self):
    '''Create a 'Recovered Nodes' node for each entry in c.nodeConflictList.'''
    c = self.c
    if not c.nodeConflictList:
        return
    if not c.make_node_conflicts_node:
        g.es_print('suppressed node conflicts', color='red')
        return None
    # Create the 'Recovered Nodes' node.
    last = c.lastTopLevel()
    root = last.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()
    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn = bunch.get('fileName') or ''
        b1, h1 = bunch.get('b_old'), bunch.get('h_old')
        b2, h2 = bunch.get('b_new'), bunch.get('h_new')
        root_v = bunch.get('root_v') or ''
        child = root.insertAsLastChild()
        h = 'Recovered node "%s" from %s' % (h1, g.shortFileName(fn))
        child.setHeadString(h)
        if b1 == b2:
            lines = [
                'Headline changed...'
                '%s gnx: %s root: %r' % (tag, gnx, root_v and root.v),
                'old headline: %s' % (h1),
                'new headline: %s' % (h2),
            ]
            child.setBodyString('\n'.join(lines))
        else:
            line1 = '%s gnx: %s root: %r\nDiff...\n' % (tag, gnx, root_v and root.v)
            d = difflib.Differ().compare(g.splitLines(b1), g.splitLines(b2))
                # 2017/06/19: reverse comparison order.
            diffLines = [z for z in d]
            lines = [line1]
            lines.extend(diffLines)
            # There is less need to show trailing newlines because
            # we don't report changes involving only trailing newlines.
            child.setBodyString(''.join(lines))
            n1 = child.insertAsNthChild(0)
            n2 = child.insertAsNthChild(1)
            n1.setHeadString('old:' + h1)
            n1.setBodyString(b1)
            n2.setHeadString('new:' + h2)
            n2.setBodyString(b2)
    return root
.. @+node:ekr.20170624151245.20: *5* Found:indicateNodeChanged
# flattened, word, ignore-case, head, body

# found 3 nodes
.. @+node:ekr.20170624151245.5579: *6* at.indicateNodeChanged (To do)
def indicateNodeChanged(self, old, new, postPass, v):
    '''
    Add an entry to c.nodeConflictList.
    Called only from at.terminateBody.
    '''
    at, c = self, self.c
    debug = False # Debug perfect import.
    if at.perfectImportRoot:
        if not postPass:
            at.correctedLines += 1
            if debug:
                at.reportCorrection(old, new, v)
            v.setDirty()
                # Just mark the vnode dirty.
                # Ancestors will be marked dirty later.
            c.setChanged(True)
    else:
        # Do nothing if only trailing whitespace is involved.
        if new.endswith('\n') and old == new[: -1]: return
        if old.endswith('\n') and new == old[: -1]: return
        c.nodeConflictList.append(g.bunch(
            tag='(uncached)',
            gnx=v.gnx,
            fileName=at.root.h,
            b_old=old,
            b_new=new,
            h_old=v._headString,
            h_new=v._headString,
            root_v = at.root and at.root.v,
        ))
        v.setDirty()
            # Just set the dirty bit. Ancestors will be marked dirty later.
        c.changed = True
            # Important: the dirty bits won't stick unless we set c.changed here.
            # Do *not* call c.setChanged(True) here: that would be too slow.
.. @+node:ekr.20170624151245.5580: *6* at.terminateBody (test)
def terminateBody(self, v, postPass=False):
    '''Terminate scanning of body text for node v. Set v.b.'''
    trace = False and not g.unitTesting
    at = self
    if at.readVersion5:
        new = ''.join(v.tempBodyList) if hasattr(v, 'tempBodyList') else ''
    else:
        new = ''.join(at.out)
    new = g.toUnicode(new)
    if new_read:
        # at.createThinChild4 creates v.tempRoots.
        # *Do* allow changes to the root node.
        if hasattr(v, 'tempRoots'):
            pass
            ###
                # g.trace('=====', list(v.tempRoots))
                # old = v.bodyString()
                # at.indicateNodeChanged(old, new, postPass, v)
        else:
            # No other @file node has set this node.
            # Just replace the body string
            v.tempRoots = set()
            v.setBodyString(new)
        v.tempRoots.add(self.root.h)
    else:
        old = v.bodyString()
        # Warn if the body text has changed. Don't warn about the root node.
        if v != at.root.v and at.bodyIsInited(v) and new != old:
            at.indicateNodeChanged(old, new, postPass, v)
        v.setBodyString(new)
    at.bodySetInited(v)
        # Note: the sax code also sets this, so we can't use
        # this "bit" in place of v.tempRoots.
    if trace:
        g.trace('%25s old %3s new %3s' % (v.gnx, len(old), len(new)), v.h)
.. @+node:ekr.20170624151245.23: *5* Found:diff
# flattened, word, ignore-case, head, body

# found 18 nodes
.. @+node:ekr.20170624151245.24: *6* diff-marked-nodes
@cmd('diff-marked-nodes')
def diffMarkedNodes(self, event):
    '''
    This command does nothing unless exactly two nodes, say p1 and p2, are marked.

    When two nodes *are* marked, this command does the following:

    1. Creates a **diff node** as the last top-level node. The body of the
       diff node shows the diffs between the two marked nodes, that is,
       difflib.Differ().compare(p1.b, p2.b)

    2. Move *clones* of p1 and p2 to be children of the diff node,
       and unmarks all nodes. This is usually what is wanted.

    To rerun the command, just mark two nodes again.
    '''
    c = self.c
    aList = [z for z in c.all_unique_positions() if z.isMarked()]
    if len(aList) == 2:
        p1, p2 = aList[0], aList[1]
        lines1 = g.splitLines(p1.b.rstrip()+'\n')
        lines2 = g.splitLines(p2.b.rstrip()+'\n')
        diffLines = difflib.Differ().compare(lines1, lines2)
        s = ''.join(list(diffLines))
        p = c.lastTopLevel().insertAfter()
        p.h = 'Compare: %s, %s' % (g.truncate(p1.h, 22), g.truncate(p2.h, 22))
        p.b = '1: %s\n2: %s\n%s' % (p1.h, p2.h, s)
        for p2 in aList:
            p3 = p2.clone()
            p3.moveToLastChildOf(p)
        p.expand()
        c.unmarkAll()
        c.selectPosition(p)
        c.redraw()
    else:
        g.es_print('%s nodes marked instead of 2' % len(aList))
.. @+node:ekr.20170624151245.25: *6* efc.compareAnyTwoFiles & helpers
@cmd('file-compare-leo-files')
def compareAnyTwoFiles(self, event):
    '''Compare two files.'''
    trace = False and not g.unitTesting
    c = c1 = self.c
    w = c.frame.body.wrapper
    commanders = g.app.commanders()
    if g.app.diff:
        if len(commanders) == 2:
            c1, c2 = commanders
            fn1 = g.shortFileName(c1.wrappedFileName) or c1.shortFileName()
            fn2 = g.shortFileName(c2.wrappedFileName) or c2.shortFileName()
            g.es('--diff auto compare', color='red')
            g.es(fn1)
            g.es(fn2)
        else:
            g.es('expecting two .leo files')
            return
    else:
        # Prompt for the file to be compared with the present outline.
        filetypes = [("Leo files", "*.leo"), ("All files", "*"),]
        fileName = g.app.gui.runOpenFileDialog(c,
            title="Compare .leo Files", filetypes=filetypes, defaultextension='.leo')
        if not fileName: return
        # Read the file into the hidden commander.
        c2 = self.createHiddenCommander(fileName)
        if not c2: return
    # Compute the inserted, deleted and changed dicts.
    d1 = self.createFileDict(c1)
    d2 = self.createFileDict(c2)
    inserted, deleted, changed = self.computeChangeDicts(d1, d2)
    if trace: self.dumpCompareNodes(fileName, c1.mFileName, inserted, deleted, changed)
    # Create clones of all inserted, deleted and changed dicts.
    self.createAllCompareClones(c1, c2, inserted, deleted, changed)
    # Fix bug 1231656: File-Compare-Leo-Files leaves other file open-count incremented.
    if not g.app.diff:
        g.app.forgetOpenFile(fn=c2.fileName(), force=True)
        c2.frame.destroySelf()
        g.app.gui.set_focus(c, w)
.. @+node:ekr.20170624151245.33: *7* efc.computeChangeDicts
def computeChangeDicts(self, d1, d2):
    '''
    Compute inserted, deleted, changed dictionaries.

    New in Leo 4.11: show the nodes in the *invisible* file, d2, if possible.
    '''
    inserted = {}
    for key in d2:
        if not d1.get(key):
            inserted[key] = d2.get(key)
    deleted = {}
    for key in d1:
        if not d2.get(key):
            deleted[key] = d1.get(key)
    changed = {}
    for key in d1:
        if d2.get(key):
            p1 = d1.get(key)
            p2 = d2.get(key)
            if p1.h != p2.h or p1.b != p2.b:
                changed[key] = p2 # Show the node in the *other* file.
    return inserted, deleted, changed
.. @+node:ekr.20170624151245.34: *7* efc.createAllCompareClones & helper
def createAllCompareClones(self, c1, c2, inserted, deleted, changed):
    '''Create the comparison trees.'''
    c = self.c # Always use the visible commander
    assert c == c1
    # Create parent node at the start of the outline.
    u, undoType = c.undoer, 'Compare Two Files'
    u.beforeChangeGroup(c.p, undoType)
    undoData = u.beforeInsertNode(c.p)
    parent = c.p.insertAfter()
    parent.setHeadString(undoType)
    u.afterInsertNode(parent, undoType, undoData, dirtyVnodeList=[])
    # Use the wrapped file name if possible.
    fn1 = g.shortFileName(c1.wrappedFileName) or c1.shortFileName()
    fn2 = g.shortFileName(c2.wrappedFileName) or c2.shortFileName()
    for d, kind in (
        (deleted, 'not in %s' % fn2),
        (inserted, 'not in %s' % fn1),
        (changed, 'changed: as in %s' % fn2),
    ):
        self.createCompareClones(d, kind, parent)
    c.selectPosition(parent)
    u.afterChangeGroup(parent, undoType, reportFlag=True)
    c.redraw()
.. @+node:ekr.20170624151245.36: *8* efc.createCompareClones
def createCompareClones(self, d, kind, parent):
    if d:
        c = self.c # Use the visible commander.
        parent = parent.insertAsLastChild()
        parent.setHeadString(kind)
        for key in d:
            p = d.get(key)
            if not kind.endswith('.leo') and p.isAnyAtFileNode():
                # Don't make clones of @<file> nodes for wrapped files.
                pass
            elif p.v.context == c:
                clone = p.clone()
                clone.moveToLastChildOf(parent)
            else:
                # Fix bug 1160660: File-Compare-Leo-Files creates "other file" clones.
                copy = p.copyTreeAfter()
                copy.moveToLastChildOf(parent)
                for p2 in copy.self_and_subtree():
                    p2.v.context = c
.. @+node:ekr.20170624151245.36: *8* efc.createCompareClones
def createCompareClones(self, d, kind, parent):
    if d:
        c = self.c # Use the visible commander.
        parent = parent.insertAsLastChild()
        parent.setHeadString(kind)
        for key in d:
            p = d.get(key)
            if not kind.endswith('.leo') and p.isAnyAtFileNode():
                # Don't make clones of @<file> nodes for wrapped files.
                pass
            elif p.v.context == c:
                clone = p.clone()
                clone.moveToLastChildOf(parent)
            else:
                # Fix bug 1160660: File-Compare-Leo-Files creates "other file" clones.
                copy = p.copyTreeAfter()
                copy.moveToLastChildOf(parent)
                for p2 in copy.self_and_subtree():
                    p2.v.context = c
.. @+node:ekr.20170624151245.37: *7* efc.createHiddenCommander
def createHiddenCommander(self, fn):
    '''Read the file into a hidden commander (Similar to g.openWithFileName).'''
    import leo.core.leoCommands as leoCommands
    lm = g.app.loadManager
    c2 = leoCommands.Commands(fn, gui=g.app.nullGui)
    theFile = lm.openLeoOrZipFile(fn)
    if theFile:
        c2.fileCommands.openLeoFile(theFile, fn, readAtFileNodesFlag=True, silent=True)
        return c2
    else:
        return None
.. @+node:ekr.20170624151245.38: *7* efc.createFileDict
def createFileDict(self, c):
    '''Create a dictionary of all relevant positions in commander c.'''
    d = {}
    for p in c.all_positions():
        d[p.v.fileIndex] = p.copy()
    return d
.. @+node:ekr.20170624151245.39: *7* efc.dumpCompareNodes
def dumpCompareNodes(self, fileName1, fileName2, inserted, deleted, changed):
    for d, kind in (
        (inserted, 'inserted (only in %s)' % (fileName1)),
        (deleted, 'deleted  (only in %s)' % (fileName2)),
        (changed, 'changed'),
    ):
        g.pr('\n', kind)
        for key in d:
            p = d.get(key)
            if g.isPython3:
                g.pr('%-32s %s' % (key, p.h))
            else:
                g.pr('%-32s %s' % (key, g.toEncodedString(p.h, 'ascii')))
.. @+node:ekr.20170624151245.33: *7* efc.computeChangeDicts
def computeChangeDicts(self, d1, d2):
    '''
    Compute inserted, deleted, changed dictionaries.

    New in Leo 4.11: show the nodes in the *invisible* file, d2, if possible.
    '''
    inserted = {}
    for key in d2:
        if not d1.get(key):
            inserted[key] = d2.get(key)
    deleted = {}
    for key in d1:
        if not d2.get(key):
            deleted[key] = d1.get(key)
    changed = {}
    for key in d1:
        if d2.get(key):
            p1 = d1.get(key)
            p2 = d2.get(key)
            if p1.h != p2.h or p1.b != p2.b:
                changed[key] = p2 # Show the node in the *other* file.
    return inserted, deleted, changed
.. @+node:ekr.20170624151245.34: *7* efc.createAllCompareClones & helper
def createAllCompareClones(self, c1, c2, inserted, deleted, changed):
    '''Create the comparison trees.'''
    c = self.c # Always use the visible commander
    assert c == c1
    # Create parent node at the start of the outline.
    u, undoType = c.undoer, 'Compare Two Files'
    u.beforeChangeGroup(c.p, undoType)
    undoData = u.beforeInsertNode(c.p)
    parent = c.p.insertAfter()
    parent.setHeadString(undoType)
    u.afterInsertNode(parent, undoType, undoData, dirtyVnodeList=[])
    # Use the wrapped file name if possible.
    fn1 = g.shortFileName(c1.wrappedFileName) or c1.shortFileName()
    fn2 = g.shortFileName(c2.wrappedFileName) or c2.shortFileName()
    for d, kind in (
        (deleted, 'not in %s' % fn2),
        (inserted, 'not in %s' % fn1),
        (changed, 'changed: as in %s' % fn2),
    ):
        self.createCompareClones(d, kind, parent)
    c.selectPosition(parent)
    u.afterChangeGroup(parent, undoType, reportFlag=True)
    c.redraw()
.. @+node:ekr.20170624151245.36: *8* efc.createCompareClones
def createCompareClones(self, d, kind, parent):
    if d:
        c = self.c # Use the visible commander.
        parent = parent.insertAsLastChild()
        parent.setHeadString(kind)
        for key in d:
            p = d.get(key)
            if not kind.endswith('.leo') and p.isAnyAtFileNode():
                # Don't make clones of @<file> nodes for wrapped files.
                pass
            elif p.v.context == c:
                clone = p.clone()
                clone.moveToLastChildOf(parent)
            else:
                # Fix bug 1160660: File-Compare-Leo-Files creates "other file" clones.
                copy = p.copyTreeAfter()
                copy.moveToLastChildOf(parent)
                for p2 in copy.self_and_subtree():
                    p2.v.context = c
.. @+node:ekr.20170624151245.36: *8* efc.createCompareClones
def createCompareClones(self, d, kind, parent):
    if d:
        c = self.c # Use the visible commander.
        parent = parent.insertAsLastChild()
        parent.setHeadString(kind)
        for key in d:
            p = d.get(key)
            if not kind.endswith('.leo') and p.isAnyAtFileNode():
                # Don't make clones of @<file> nodes for wrapped files.
                pass
            elif p.v.context == c:
                clone = p.clone()
                clone.moveToLastChildOf(parent)
            else:
                # Fix bug 1160660: File-Compare-Leo-Files creates "other file" clones.
                copy = p.copyTreeAfter()
                copy.moveToLastChildOf(parent)
                for p2 in copy.self_and_subtree():
                    p2.v.context = c
.. @+node:ekr.20170624151245.37: *7* efc.createHiddenCommander
def createHiddenCommander(self, fn):
    '''Read the file into a hidden commander (Similar to g.openWithFileName).'''
    import leo.core.leoCommands as leoCommands
    lm = g.app.loadManager
    c2 = leoCommands.Commands(fn, gui=g.app.nullGui)
    theFile = lm.openLeoOrZipFile(fn)
    if theFile:
        c2.fileCommands.openLeoFile(theFile, fn, readAtFileNodesFlag=True, silent=True)
        return c2
    else:
        return None
.. @+node:ekr.20170624151245.38: *7* efc.createFileDict
def createFileDict(self, c):
    '''Create a dictionary of all relevant positions in commander c.'''
    d = {}
    for p in c.all_positions():
        d[p.v.fileIndex] = p.copy()
    return d
.. @+node:ekr.20170624151245.39: *7* efc.dumpCompareNodes
def dumpCompareNodes(self, fileName1, fileName2, inserted, deleted, changed):
    for d, kind in (
        (inserted, 'inserted (only in %s)' % (fileName1)),
        (deleted, 'deleted  (only in %s)' % (fileName2)),
        (changed, 'changed'),
    ):
        g.pr('\n', kind)
        for key in d:
            p = d.get(key)
            if g.isPython3:
                g.pr('%-32s %s' % (key, p.h))
            else:
                g.pr('%-32s %s' % (key, g.toEncodedString(p.h, 'ascii')))
.. @+node:ekr.20170624151245.40: *6* efc.diff
@cmd('file-diff-files')
def diff(self, event=None):
    '''Creates a node and puts the diff between 2 files into it.'''
    c = self.c
    fn = self.getReadableTextFile()
    if not fn: return
    fn2 = self.getReadableTextFile()
    if not fn2: return
    s1, e = g.readFileIntoString(fn)
    if s1 is None: return
    s2, e = g.readFileIntoString(fn2)
    if s2 is None: return
    lines1, lines2 = g.splitLines(s1), g.splitLines(s2)
    aList = difflib.ndiff(lines1, lines2)
    p = c.p.insertAfter()
    p.h = 'diff'
    p.b = ''.join(aList)
    c.redraw()
.. @+node:ekr.20170624151245.174: *6* LM.doDiff
def doDiff(self):
    '''Support --diff option after loading Leo.'''
    if len(self.old_argv[2:]) == 2:
        pass # c.editFileCommands.compareAnyTwoFiles gives a message.
    else:
        # This is an unusual situation.
        g.es('--diff mode. sys.argv[2:]...', color='red')
        for z in self.old_argv[2:]:
            g.es(g.shortFileName(z) if z else repr(z), color='blue')
    commanders = g.app.commanders()
    if len(commanders) == 2:
        c = commanders[0]
        c.editFileCommands.compareAnyTwoFiles(event=None)
.. @+node:ekr.20170624151245.42: *6* LM.load & helpers
def load(self, fileName=None, pymacs=None):
    '''Load the indicated file'''
    lm = self
    # Phase 1: before loading plugins.
    # Scan options, set directories and read settings.
    if not lm.isValidPython(): return
    lm.doPrePluginsInit(fileName, pymacs)
        # sets lm.options and lm.files
    if lm.options.get('version'):
        print(g.app.signon)
        return
    if not g.app.gui:
        return
    # Phase 2: load plugins: the gui has already been set.
    g.doHook("start1")
    if g.app.killed: return
    g.app.idleTimeManager.start()
    # Phase 3: after loading plugins. Create one or more frames.
    ok = lm.doPostPluginsInit()
    if ok and g.app.diff:
        lm.doDiff()
    if ok:
        g.es('') # Clears horizontal scrolling in the log pane.
        g.app.gui.runMainLoop()
        # For scripts, the gui is a nullGui.
        # and the gui.setScript has already been called.
.. @+node:ekr.20170624151245.174: *7* LM.doDiff
def doDiff(self):
    '''Support --diff option after loading Leo.'''
    if len(self.old_argv[2:]) == 2:
        pass # c.editFileCommands.compareAnyTwoFiles gives a message.
    else:
        # This is an unusual situation.
        g.es('--diff mode. sys.argv[2:]...', color='red')
        for z in self.old_argv[2:]:
            g.es(g.shortFileName(z) if z else repr(z), color='blue')
    commanders = g.app.commanders()
    if len(commanders) == 2:
        c = commanders[0]
        c.editFileCommands.compareAnyTwoFiles(event=None)
.. @+node:ekr.20170624151245.175: *7* LM.doPrePluginsInit & helpers
def doPrePluginsInit(self, fileName, pymacs):
    ''' Scan options, set directories and read settings.'''
    # trace = False
    lm = self
    lm.computeStandardDirectories()
    lm.adjustSysPath()
        # A do-nothing.
    # Scan the options as early as possible.
    lm.options = options = lm.scanOptions(fileName, pymacs)
        # also sets lm.files.
    if options.get('version'):
        g.app.computeSignon()
        return
    script = options.get('script')
    verbose = script is None
    # Init the app.
    lm.initApp(verbose)
    lm.reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    lm.readGlobalSettingsFiles()
        # reads only standard settings files, using a null gui.
        # uses lm.files[0] to compute the local directory
        # that might contain myLeoSettings.leo.
    # Read the recent files file.
    localConfigFile = lm.files[0] if lm.files else None
    g.app.recentFilesManager.readRecentFiles(localConfigFile)
    g.app.setGlobalDb()
    # Create the gui after reading options and settings.
    lm.createGui(pymacs)
    # We can't print the signon until we know the gui.
    g.app.computeSignon() # Set app.signon/signon2 for commanders.
.. @+node:ekr.20170624151245.204: *8* LM.createAllImporetersData & helpers (new)
def createAllImporetersData(self):
    '''
    New in Leo 5.5:

    Create global data structures describing importers and writers.
    '''
    assert g.app.loadDir
        # This is the only data required.
    self.createWritersData()
        # Was an AtFile method.
    self.createImporterData()
        # Was a LeoImportCommands method.
.. @+node:ekr.20170624151245.211: *9* LM.createImporterData & helper
def createImporterData(self):
    '''Create the data structures describing importer plugins.'''
    trace = False and not g.unitTesting
    trace_exception = False
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[: -3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        'leo.plugins.importers.%s' % module_name)
                    self.parse_importer_dict(sfn, m)
                except Exception:
                    if trace and trace_exception:
                        g.es_exception()
                    g.warning('can not import leo.plugins.importers.%s' % (
                        module_name))
    if trace:
        g.trace('g.app.atAutoDict')
        g.printDict(g.app.atAutoDict)
        g.trace('g.app.classDispatchDict')
        g.printDict(g.app.classDispatchDict)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.214: *9* LM.createWritersData & helper
def createWritersData(self):
    '''Create the data structures describing writer plugins.'''
    trace = False # and not g.unitTesting
    trace = trace and 'createWritersData' not in g.app.debug_dict
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module('leo.plugins.writers.%s' % sfn[: -3])
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning('can not import leo.plugins.writers.%s' % sfn)
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: https://github.com/leo-editor/leo-editor/issues/40
 
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.211: *9* LM.createImporterData & helper
def createImporterData(self):
    '''Create the data structures describing importer plugins.'''
    trace = False and not g.unitTesting
    trace_exception = False
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[: -3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        'leo.plugins.importers.%s' % module_name)
                    self.parse_importer_dict(sfn, m)
                except Exception:
                    if trace and trace_exception:
                        g.es_exception()
                    g.warning('can not import leo.plugins.importers.%s' % (
                        module_name))
    if trace:
        g.trace('g.app.atAutoDict')
        g.printDict(g.app.atAutoDict)
        g.trace('g.app.classDispatchDict')
        g.printDict(g.app.classDispatchDict)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.214: *9* LM.createWritersData & helper
def createWritersData(self):
    '''Create the data structures describing writer plugins.'''
    trace = False # and not g.unitTesting
    trace = trace and 'createWritersData' not in g.app.debug_dict
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module('leo.plugins.writers.%s' % sfn[: -3])
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning('can not import leo.plugins.writers.%s' % sfn)
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: https://github.com/leo-editor/leo-editor/issues/40
 
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.217: *8* LM.createGui
def createGui(self, pymacs):
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug()
    lm = self
    gui_option = lm.options.get('gui')
    windowFlag = lm.options.get('windowFlag')
    script = lm.options.get('script')
    if g.app.gui:
        if g.app.gui == g.app.nullGui:
            g.app.gui = None # Enable g.app.createDefaultGui
            g.app.createDefaultGui(__file__)
        else:
            # This can happen when launching Leo from IPython.
            g.trace('g.app.gui', g.app.gui, g.callers())
    elif gui_option is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        lm.createSpecialGui(gui_option, pymacs, script, windowFlag)
.. @+node:ekr.20170624151245.218: *8* LM.createSpecialGui
def createSpecialGui(self, gui, pymacs, script, windowFlag):
    # lm = self
    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        # assert g.app.guiArgName
        g.app.createDefaultGui()
.. @+node:ekr.20170624151245.219: *8* LM.adjustSysPath
def adjustSysPath(self):
    '''Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:

        1. g.importModule will import from the
           'external' or 'extensions' folders as needed
           without altering sys.path.

        2.  Plugins now do fully qualified imports.
    '''
    pass
.. @+node:ekr.20170624151245.220: *8* LM.getDefaultFile
def getDefaultFile(self):
    # Get the name of the workbook.
    fn = g.app.config.getString('default_leo_file')
    fn = g.os_path_finalize(fn)
    if not fn: return
    # g.trace(g.os_path_exists(fn),fn)
    if g.os_path_exists(fn):
        return fn
    elif g.os_path_isabs(fn):
        # Create the file.
        g.error('Using default leo file name:\n%s' % (fn))
        return fn
    else:
        # It's too risky to open a default file if it is relative.
        return None
.. @+node:ekr.20170624151245.221: *8* LM.initApp
def initApp(self, verbose):
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug()
    self.createAllImporetersData()
        # Can be done early. Uses only g.app.loadDir
    assert g.app.loadManager
    import leo.core.leoBackground as leoBackground
    import leo.core.leoConfig as leoConfig
    import leo.core.leoNodes as leoNodes
    import leo.core.leoPlugins as leoPlugins
    import leo.core.leoSessions as leoSessions
    # Import leoIPython only if requested.  The import is quite slow.
    self.setStdStreams()
    if g.app.useIpython:
        import leo.core.leoIPython as leoIPython
            # This launches the IPython Qt Console.  It *is* required.
        assert leoIPython # suppress pyflakes/flake8 warning.
    # Make sure we call the new leoPlugins.init top-level function.
    leoPlugins.init()
    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    # Create early classes *after* doing plugins.init()
    g.app.idleTimeManager = IdleTimeManager()
    g.app.backgroundProcessManager = leoBackground.BackgroundProcessManager()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController()
    g.app.recentFilesManager = RecentFilesManager()
    g.app.config = leoConfig.GlobalConfigManager()
    g.app.nodeIndices = leoNodes.NodeIndices(g.app.leoID)
    g.app.sessionManager = leoSessions.SessionManager()
    # Complete the plugins class last.
    g.app.pluginsController.finishCreate()
.. @+node:ekr.20170624151245.222: *8* LM.scanOptions & helper
def scanOptions(self, fileName, pymacs):
    '''Handle all options, remove them from sys.argv and set lm.options.'''
    trace = False
    lm = self
    # print('scanOptions',sys.argv)
    lm.old_argv = sys.argv[:]
    # Note: this automatically implements the --help option.
    usage = "usage: launchLeo.py [options] file1, file2, ..."
    parser = optparse.OptionParser(usage=usage)
    add = parser.add_option
    add('--debug', action='store_true',
        help='enable debug mode')
    add('--diff', action='store_true', dest='diff',
        help='use Leo as an external git diff')
    add('--fullscreen', action='store_true',
        help='start fullscreen')
    add('--ipython', action='store_true', dest='use_ipython',
        help='enable ipython support')
    add('--fail-fast', action='store_true', dest='fail_fast',
        help='stop unit tests after the first failure')
    add('--gui',
        help='gui to use (qt/qttabs/console/null)')
    add('--load-type', dest='load_type',
        help='@<file> type for loading non-outlines from command line')
    add('--maximized', action='store_true',
        help='start maximized')
    add('--minimized', action='store_true',
        help='start minimized')
    add('--no-cache', action='store_true', dest='no_cache',
        help='disable reading of cached files')
    add('--no-plugins', action='store_true', dest='no_plugins',
        help='disable all plugins')
    add('--no-splash', action='store_true', dest='no_splash_screen',
        help='disable the splash screen')
    add('--screen-shot', dest='screenshot_fn',
        help='take a screen shot and then exit')
    add('--script', dest='script',
        help='execute a script and then exit')
    add('--script-window', dest='script_window',
        help='open a window for scripts')
    add('--select', dest='select',
        help='headline or gnx of node to select')
    add('--session-restore', action='store_true', dest='session_restore',
        help='restore previously saved session tabs at startup')
    add('--session-save', action='store_true', dest='session_save',
        help='save session tabs on exit')
    add('--silent', action='store_true', dest='silent',
        help='disable all log messages')
    add('--trace-focus', action='store_true', dest='trace_focus',
        help='trace changes of focus')
    add('--trace-plugins', action='store_true', dest='trace_plugins',
        help='trace imports of plugins')
    add('-v', '--version', action='store_true', dest='version',
        help='print version number and exit')
    add('--window-size', dest='window_size',
        help='initial window size (height x width)')
    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]; sys.argv.extend(args)
    if trace:
        # print('scanOptions:',sys.argv)
        g.trace('options', options)
    # Handle the args...
    # --debug
    g.app.debug = options.debug
    # if g.app.debug: g.trace_startup = True
    # --fail-fast
    if options.fail_fast:
        g.app.failFast = True
    # --git-diff
    if options.diff:
        g.app.diff = options.diff
    # --gui
    gui = options.gui
    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            g.app.qt_use_tabs = True
        elif gui in ('console', 'curses', 'text', 'qt', 'null'):
                # text: cursesGui.py, curses: cursesGui2.py.
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s.  Using qt gui' % gui)
            gui = 'qt'
            g.app.qt_use_tabs = False
    elif sys.platform == 'darwin':
        gui = 'qt'
        g.app.qt_use_tabs = False
    else:
        gui = 'qttabs'
        g.app.qt_use_tabs = True
    assert gui
    g.app.guiArgName = gui
    # --load-type
    load_type = options.load_type
    if load_type:
        load_type = load_type.lower()
    else:
        load_type = 'edit'
    load_type = '@' + load_type
    # --ipython
    g.app.useIpython = options.use_ipython
    if trace: g.trace('g.app.useIpython', g.app.useIpython)
    # --fullscreen
    # --minimized
    # --maximized
    g.app.start_fullscreen = options.fullscreen
    g.app.start_maximized = options.maximized
    g.app.start_minimized = options.minimized
    # --no-cache
    if options.no_cache:
        if trace: print('scanOptions: disabling caching')
        g.enableDB = False
    # --no-plugins
    if options.no_plugins:
        if trace: print('scanOptions: disabling plugins')
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = (
        not options.no_splash_screen and
        not options.minimized)
    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn', screenshot_fn)
    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error('--script and script-window are mutually exclusive')
    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir, script_name)
        script, e = g.readFileIntoString(script_name, kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')
    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select', repr(select))
    # --session-restore & --session-save
    g.app.restore_session = bool(options.session_restore)
    g.app.save_session = bool(options.session_save)
    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)
    # --trace-focus
    g.app.trace_focus = options.trace_focus
    # --trace-plugins
    g.app.trace_plugins = options.trace_plugins
    # --version: print the version and exit.
    versionFlag = options.version
    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize', repr(windowSize))
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:', windowSize)
    # Compute lm.files
    lm.files = lm.computeFilesList(fileName)
    # if options.debug:
    #    g.es_debug('lm.files',lm.files)
    # Post-process the options.
    if pymacs:
        script = None
        windowFlag = None
    # Compute the return values.
    windowFlag = script and script_path_w
    d = {
        'gui': gui,
        'load_type': load_type,
        'screenshot_fn': screenshot_fn,
        'script': script,
        'select': select,
        'version': versionFlag,
        'windowFlag': windowFlag,
        'windowSize': windowSize,
    }
    if trace: g.trace(d)
    return d
.. @+node:ekr.20170624151245.224: *9* LM.computeFilesList
def computeFilesList(self, fileName):
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = glob.glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return result
.. @+node:ekr.20170624151245.224: *9* LM.computeFilesList
def computeFilesList(self, fileName):
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = glob.glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return result
.. @+node:ekr.20170624151245.225: *8* LM.setStdStreams
def setStdStreams(self):
    '''
    Make sure that stdout and stderr exist.
    This is an issue when running Leo with pythonw.exe.
    '''
    # pdb requires sys.stdin, which doesn't exist when using pythonw.exe.
    # import pdb ; pdb.set_trace()
    import sys
    import leo.core.leoGlobals as g
    
    # Define class LeoStdOut
    @others

    if not sys.stdout:
        sys.stdout = sys.__stdout__ = LeoStdOut('stdout')
    if not sys.stderr:
        sys.stderr = sys.__stderr__ = LeoStdOut('stderr')
.. @+node:ekr.20170624151245.229: *9* class LeoStdOut
class LeoStdOut:
    '''A class to put stderr & stdout to Leo's log pane.'''

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
        
    @others
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.229: *9* class LeoStdOut
class LeoStdOut:
    '''A class to put stderr & stdout to Leo's log pane.'''

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
        
    @others
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.204: *8* LM.createAllImporetersData & helpers (new)
def createAllImporetersData(self):
    '''
    New in Leo 5.5:

    Create global data structures describing importers and writers.
    '''
    assert g.app.loadDir
        # This is the only data required.
    self.createWritersData()
        # Was an AtFile method.
    self.createImporterData()
        # Was a LeoImportCommands method.
.. @+node:ekr.20170624151245.211: *9* LM.createImporterData & helper
def createImporterData(self):
    '''Create the data structures describing importer plugins.'''
    trace = False and not g.unitTesting
    trace_exception = False
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[: -3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        'leo.plugins.importers.%s' % module_name)
                    self.parse_importer_dict(sfn, m)
                except Exception:
                    if trace and trace_exception:
                        g.es_exception()
                    g.warning('can not import leo.plugins.importers.%s' % (
                        module_name))
    if trace:
        g.trace('g.app.atAutoDict')
        g.printDict(g.app.atAutoDict)
        g.trace('g.app.classDispatchDict')
        g.printDict(g.app.classDispatchDict)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.214: *9* LM.createWritersData & helper
def createWritersData(self):
    '''Create the data structures describing writer plugins.'''
    trace = False # and not g.unitTesting
    trace = trace and 'createWritersData' not in g.app.debug_dict
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module('leo.plugins.writers.%s' % sfn[: -3])
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning('can not import leo.plugins.writers.%s' % sfn)
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: https://github.com/leo-editor/leo-editor/issues/40
 
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.211: *9* LM.createImporterData & helper
def createImporterData(self):
    '''Create the data structures describing importer plugins.'''
    trace = False and not g.unitTesting
    trace_exception = False
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[: -3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        'leo.plugins.importers.%s' % module_name)
                    self.parse_importer_dict(sfn, m)
                except Exception:
                    if trace and trace_exception:
                        g.es_exception()
                    g.warning('can not import leo.plugins.importers.%s' % (
                        module_name))
    if trace:
        g.trace('g.app.atAutoDict')
        g.printDict(g.app.atAutoDict)
        g.trace('g.app.classDispatchDict')
        g.printDict(g.app.classDispatchDict)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.214: *9* LM.createWritersData & helper
def createWritersData(self):
    '''Create the data structures describing writer plugins.'''
    trace = False # and not g.unitTesting
    trace = trace and 'createWritersData' not in g.app.debug_dict
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module('leo.plugins.writers.%s' % sfn[: -3])
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning('can not import leo.plugins.writers.%s' % sfn)
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: https://github.com/leo-editor/leo-editor/issues/40
 
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.217: *8* LM.createGui
def createGui(self, pymacs):
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug()
    lm = self
    gui_option = lm.options.get('gui')
    windowFlag = lm.options.get('windowFlag')
    script = lm.options.get('script')
    if g.app.gui:
        if g.app.gui == g.app.nullGui:
            g.app.gui = None # Enable g.app.createDefaultGui
            g.app.createDefaultGui(__file__)
        else:
            # This can happen when launching Leo from IPython.
            g.trace('g.app.gui', g.app.gui, g.callers())
    elif gui_option is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        lm.createSpecialGui(gui_option, pymacs, script, windowFlag)
.. @+node:ekr.20170624151245.218: *8* LM.createSpecialGui
def createSpecialGui(self, gui, pymacs, script, windowFlag):
    # lm = self
    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        # assert g.app.guiArgName
        g.app.createDefaultGui()
.. @+node:ekr.20170624151245.219: *8* LM.adjustSysPath
def adjustSysPath(self):
    '''Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:

        1. g.importModule will import from the
           'external' or 'extensions' folders as needed
           without altering sys.path.

        2.  Plugins now do fully qualified imports.
    '''
    pass
.. @+node:ekr.20170624151245.220: *8* LM.getDefaultFile
def getDefaultFile(self):
    # Get the name of the workbook.
    fn = g.app.config.getString('default_leo_file')
    fn = g.os_path_finalize(fn)
    if not fn: return
    # g.trace(g.os_path_exists(fn),fn)
    if g.os_path_exists(fn):
        return fn
    elif g.os_path_isabs(fn):
        # Create the file.
        g.error('Using default leo file name:\n%s' % (fn))
        return fn
    else:
        # It's too risky to open a default file if it is relative.
        return None
.. @+node:ekr.20170624151245.221: *8* LM.initApp
def initApp(self, verbose):
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug()
    self.createAllImporetersData()
        # Can be done early. Uses only g.app.loadDir
    assert g.app.loadManager
    import leo.core.leoBackground as leoBackground
    import leo.core.leoConfig as leoConfig
    import leo.core.leoNodes as leoNodes
    import leo.core.leoPlugins as leoPlugins
    import leo.core.leoSessions as leoSessions
    # Import leoIPython only if requested.  The import is quite slow.
    self.setStdStreams()
    if g.app.useIpython:
        import leo.core.leoIPython as leoIPython
            # This launches the IPython Qt Console.  It *is* required.
        assert leoIPython # suppress pyflakes/flake8 warning.
    # Make sure we call the new leoPlugins.init top-level function.
    leoPlugins.init()
    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    # Create early classes *after* doing plugins.init()
    g.app.idleTimeManager = IdleTimeManager()
    g.app.backgroundProcessManager = leoBackground.BackgroundProcessManager()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController()
    g.app.recentFilesManager = RecentFilesManager()
    g.app.config = leoConfig.GlobalConfigManager()
    g.app.nodeIndices = leoNodes.NodeIndices(g.app.leoID)
    g.app.sessionManager = leoSessions.SessionManager()
    # Complete the plugins class last.
    g.app.pluginsController.finishCreate()
.. @+node:ekr.20170624151245.222: *8* LM.scanOptions & helper
def scanOptions(self, fileName, pymacs):
    '''Handle all options, remove them from sys.argv and set lm.options.'''
    trace = False
    lm = self
    # print('scanOptions',sys.argv)
    lm.old_argv = sys.argv[:]
    # Note: this automatically implements the --help option.
    usage = "usage: launchLeo.py [options] file1, file2, ..."
    parser = optparse.OptionParser(usage=usage)
    add = parser.add_option
    add('--debug', action='store_true',
        help='enable debug mode')
    add('--diff', action='store_true', dest='diff',
        help='use Leo as an external git diff')
    add('--fullscreen', action='store_true',
        help='start fullscreen')
    add('--ipython', action='store_true', dest='use_ipython',
        help='enable ipython support')
    add('--fail-fast', action='store_true', dest='fail_fast',
        help='stop unit tests after the first failure')
    add('--gui',
        help='gui to use (qt/qttabs/console/null)')
    add('--load-type', dest='load_type',
        help='@<file> type for loading non-outlines from command line')
    add('--maximized', action='store_true',
        help='start maximized')
    add('--minimized', action='store_true',
        help='start minimized')
    add('--no-cache', action='store_true', dest='no_cache',
        help='disable reading of cached files')
    add('--no-plugins', action='store_true', dest='no_plugins',
        help='disable all plugins')
    add('--no-splash', action='store_true', dest='no_splash_screen',
        help='disable the splash screen')
    add('--screen-shot', dest='screenshot_fn',
        help='take a screen shot and then exit')
    add('--script', dest='script',
        help='execute a script and then exit')
    add('--script-window', dest='script_window',
        help='open a window for scripts')
    add('--select', dest='select',
        help='headline or gnx of node to select')
    add('--session-restore', action='store_true', dest='session_restore',
        help='restore previously saved session tabs at startup')
    add('--session-save', action='store_true', dest='session_save',
        help='save session tabs on exit')
    add('--silent', action='store_true', dest='silent',
        help='disable all log messages')
    add('--trace-focus', action='store_true', dest='trace_focus',
        help='trace changes of focus')
    add('--trace-plugins', action='store_true', dest='trace_plugins',
        help='trace imports of plugins')
    add('-v', '--version', action='store_true', dest='version',
        help='print version number and exit')
    add('--window-size', dest='window_size',
        help='initial window size (height x width)')
    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]; sys.argv.extend(args)
    if trace:
        # print('scanOptions:',sys.argv)
        g.trace('options', options)
    # Handle the args...
    # --debug
    g.app.debug = options.debug
    # if g.app.debug: g.trace_startup = True
    # --fail-fast
    if options.fail_fast:
        g.app.failFast = True
    # --git-diff
    if options.diff:
        g.app.diff = options.diff
    # --gui
    gui = options.gui
    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            g.app.qt_use_tabs = True
        elif gui in ('console', 'curses', 'text', 'qt', 'null'):
                # text: cursesGui.py, curses: cursesGui2.py.
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s.  Using qt gui' % gui)
            gui = 'qt'
            g.app.qt_use_tabs = False
    elif sys.platform == 'darwin':
        gui = 'qt'
        g.app.qt_use_tabs = False
    else:
        gui = 'qttabs'
        g.app.qt_use_tabs = True
    assert gui
    g.app.guiArgName = gui
    # --load-type
    load_type = options.load_type
    if load_type:
        load_type = load_type.lower()
    else:
        load_type = 'edit'
    load_type = '@' + load_type
    # --ipython
    g.app.useIpython = options.use_ipython
    if trace: g.trace('g.app.useIpython', g.app.useIpython)
    # --fullscreen
    # --minimized
    # --maximized
    g.app.start_fullscreen = options.fullscreen
    g.app.start_maximized = options.maximized
    g.app.start_minimized = options.minimized
    # --no-cache
    if options.no_cache:
        if trace: print('scanOptions: disabling caching')
        g.enableDB = False
    # --no-plugins
    if options.no_plugins:
        if trace: print('scanOptions: disabling plugins')
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = (
        not options.no_splash_screen and
        not options.minimized)
    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn', screenshot_fn)
    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error('--script and script-window are mutually exclusive')
    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir, script_name)
        script, e = g.readFileIntoString(script_name, kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')
    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select', repr(select))
    # --session-restore & --session-save
    g.app.restore_session = bool(options.session_restore)
    g.app.save_session = bool(options.session_save)
    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)
    # --trace-focus
    g.app.trace_focus = options.trace_focus
    # --trace-plugins
    g.app.trace_plugins = options.trace_plugins
    # --version: print the version and exit.
    versionFlag = options.version
    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize', repr(windowSize))
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:', windowSize)
    # Compute lm.files
    lm.files = lm.computeFilesList(fileName)
    # if options.debug:
    #    g.es_debug('lm.files',lm.files)
    # Post-process the options.
    if pymacs:
        script = None
        windowFlag = None
    # Compute the return values.
    windowFlag = script and script_path_w
    d = {
        'gui': gui,
        'load_type': load_type,
        'screenshot_fn': screenshot_fn,
        'script': script,
        'select': select,
        'version': versionFlag,
        'windowFlag': windowFlag,
        'windowSize': windowSize,
    }
    if trace: g.trace(d)
    return d
.. @+node:ekr.20170624151245.224: *9* LM.computeFilesList
def computeFilesList(self, fileName):
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = glob.glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return result
.. @+node:ekr.20170624151245.224: *9* LM.computeFilesList
def computeFilesList(self, fileName):
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = glob.glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return result
.. @+node:ekr.20170624151245.225: *8* LM.setStdStreams
def setStdStreams(self):
    '''
    Make sure that stdout and stderr exist.
    This is an issue when running Leo with pythonw.exe.
    '''
    # pdb requires sys.stdin, which doesn't exist when using pythonw.exe.
    # import pdb ; pdb.set_trace()
    import sys
    import leo.core.leoGlobals as g
    
    # Define class LeoStdOut
    @others

    if not sys.stdout:
        sys.stdout = sys.__stdout__ = LeoStdOut('stdout')
    if not sys.stderr:
        sys.stderr = sys.__stderr__ = LeoStdOut('stderr')
.. @+node:ekr.20170624151245.229: *9* class LeoStdOut
class LeoStdOut:
    '''A class to put stderr & stdout to Leo's log pane.'''

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
        
    @others
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.229: *9* class LeoStdOut
class LeoStdOut:
    '''A class to put stderr & stdout to Leo's log pane.'''

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
        
    @others
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.232: *7* LM.doPostPluginsInit & helpers
def doPostPluginsInit(self):
    '''Create a Leo window for each file in the lm.files list.'''
    # Clear g.app.initing _before_ creating commanders.
    lm = self
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c = c1 = None
    if lm.files:
        for n, fn in enumerate(lm.files):
            lm.more_cmdline_files = n < len(lm.files) - 1
            c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
                # Returns None if the file is open in another instance of Leo.
            if not c1: c1 = c
    if g.app.restore_session:
        m = g.app.sessionManager
        if m:
            aList = m.load_snapshot()
            if aList:
                m.load_session(c1, aList)
                c = c1 = g.app.windowList[0].c
    if not c1 or not g.app.windowList:
        c1 = lm.openEmptyWorkBook()
    # Fix bug #199.
    g.app.runAlreadyOpenDialog(c1)
    # Put the focus in the first-opened file.
    fileName = lm.files[0] if lm.files else None
    c = c1
    # For qttabs gui, select the first-loaded tab.
    if hasattr(g.app.gui, 'frameFactory'):
        factory = g.app.gui.frameFactory
        if factory and hasattr(factory, 'setTabForCommander'):
            factory.setTabForCommander(c)
    if not c:
        return False # Force an immediate exit.
    # Fix bug 844953: tell Unity which menu to use.
    if c: c.enableMenuBar()
    # Do the final inits.
    g.app.logInited = True
    g.app.initComplete = True
    if c: c.setLog()
    # print('doPostPluginsInit: ***** set log')
    p = c.p if c else None
    g.doHook("start2", c=c, p=p, v=p, fileName=fileName)
    if c: lm.initFocusAndDraw(c, fileName)
    screenshot_fn = lm.options.get('screenshot_fn')
    if screenshot_fn:
        lm.make_screen_shot(screenshot_fn)
        return False # Force an immediate exit.
    else:
        return True
.. @+node:ekr.20170624151245.236: *8* LM.initFocusAndDraw
def initFocusAndDraw(self, c, fileName):

    def init_focus_handler(timer, c=c, p=c.p):
        '''Idle-time handler for initFocusAndDraw'''
        c.initialFocusHelper()
        c.outerUpdate()
        timer.stop()

    # This must happen after the code in getLeoFile.
    timer = g.IdleTime(init_focus_handler, delay=0.1, tag='getLeoFile')
    if timer:
        timer.start()
    else:
        # Default code.
        c.selectPosition(c.p)
        c.initialFocusHelper()
        c.k.showStateAndMode()
        c.outerUpdate()
.. @+node:ekr.20170624151245.237: *8* LM.make_screen_shot
def make_screen_shot(self, fn):
    '''Create a screenshot of the present Leo outline and save it to path.'''
    # g.trace('runLeo.py',fn)
    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
.. @+node:ekr.20170624151245.238: *8* LM.openEmptyWorkBook
def openEmptyWorkBook(self):
    '''Open an empty frame and paste the contents of CheatSheet.leo into it.'''
    lm = self
    # Create an empty frame.
    fn = lm.computeWorkbookFileName()
    c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
    # Open the cheatsheet, but not in batch mode.
    if not g.app.batchMode and not g.os_path_exists(fn):
        # Paste the contents of CheetSheet.leo into c.
        c2 = c.openCheatSheet(redraw=False)
        if c2:
            for p2 in c2.rootPosition().self_and_siblings():
                c2.selectPosition(p2)
                c2.copyOutline()
                p = c.pasteOutline()
                c.selectPosition(p)
                p.contract()
                p.clearDirty()
            c2.close(new_c=c)
            root = c.rootPosition()
            if root.h == g.shortFileName(fn):
                root.doDelete(newNode=root.next())
            p = g.findNodeAnywhere(c, "Leo's cheat sheet")
            if p:
                c.selectPosition(p, enableRedrawFlag=False)
                p.expand()
            c.target_language = 'rest'
                # Settings not parsed the first time.
            c.setChanged(False)
            c.redraw()
    return c
.. @+node:ekr.20170624151245.236: *8* LM.initFocusAndDraw
def initFocusAndDraw(self, c, fileName):

    def init_focus_handler(timer, c=c, p=c.p):
        '''Idle-time handler for initFocusAndDraw'''
        c.initialFocusHelper()
        c.outerUpdate()
        timer.stop()

    # This must happen after the code in getLeoFile.
    timer = g.IdleTime(init_focus_handler, delay=0.1, tag='getLeoFile')
    if timer:
        timer.start()
    else:
        # Default code.
        c.selectPosition(c.p)
        c.initialFocusHelper()
        c.k.showStateAndMode()
        c.outerUpdate()
.. @+node:ekr.20170624151245.237: *8* LM.make_screen_shot
def make_screen_shot(self, fn):
    '''Create a screenshot of the present Leo outline and save it to path.'''
    # g.trace('runLeo.py',fn)
    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
.. @+node:ekr.20170624151245.238: *8* LM.openEmptyWorkBook
def openEmptyWorkBook(self):
    '''Open an empty frame and paste the contents of CheatSheet.leo into it.'''
    lm = self
    # Create an empty frame.
    fn = lm.computeWorkbookFileName()
    c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
    # Open the cheatsheet, but not in batch mode.
    if not g.app.batchMode and not g.os_path_exists(fn):
        # Paste the contents of CheetSheet.leo into c.
        c2 = c.openCheatSheet(redraw=False)
        if c2:
            for p2 in c2.rootPosition().self_and_siblings():
                c2.selectPosition(p2)
                c2.copyOutline()
                p = c.pasteOutline()
                c.selectPosition(p)
                p.contract()
                p.clearDirty()
            c2.close(new_c=c)
            root = c.rootPosition()
            if root.h == g.shortFileName(fn):
                root.doDelete(newNode=root.next())
            p = g.findNodeAnywhere(c, "Leo's cheat sheet")
            if p:
                c.selectPosition(p, enableRedrawFlag=False)
                p.expand()
            c.target_language = 'rest'
                # Settings not parsed the first time.
            c.setChanged(False)
            c.redraw()
    return c
.. @+node:ekr.20170624151245.239: *7* LM.isValidPython & emergency (Tk) dialog class
def isValidPython(self):
    if sys.platform == 'cli':
        return True
    minimum_python_version = '2.6'
    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0, 1, 2)])
        ok = g.CheckVersion(version, minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = EmergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
.. @+node:ekr.20170624151245.253: *8* << define emergency dialog class >>
class EmergencyDialog(object):
    """A class that creates an Tkinter dialog with a single OK button."""
    @others
.. @+node:ekr.20170624151245.260: *9* __init__ (emergencyDialog)
def __init__(self, title, message):
    """Constructor for the leoTkinterDialog class."""
    self.answer = None # Value returned from run()
    self.title = title
    self.message = message
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.
    self.createTopFrame()
    buttons = {"text": "OK", "command": self.okButton, "default": True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
.. @+node:ekr.20170624151245.261: *9* createButtons
def createButtons(self, buttons):
    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top", padx=30)
    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text", "<missing button name>")
        isDefault = d.get("default", False)
        underline = d.get("underline", 0)
        command = d.get("command", None)
        bd = 4 if isDefault else 2
        b = Tk.Button(f, width=6, text=text, bd=bd,
            underline=underline, command=command)
        b.pack(side="left", padx=5, pady=10)
        buttonList.append(b)
        if isDefault and command:
            self.defaultButtonCommand = command
    return buttonList
.. @+node:ekr.20170624151245.262: *9* createTopFrame
def createTopFrame(self):
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=message, bg='white')
    label.pack(pady=10)
.. @+node:ekr.20170624151245.263: *9* okButton
def okButton(self):
    """Do default click action in ok button."""
    self.top.destroy()
    self.top = None
.. @+node:ekr.20170624151245.264: *9* onKey
def onKey(self, event):
    """Handle Key events in askOk dialogs."""
    self.okButton()
    return # (for Tk) "break"
.. @+node:ekr.20170624151245.265: *9* run
def run(self):
    """Run the modal emergency dialog."""
    self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
    self.top.lift()
    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
.. @+node:ekr.20170624151245.260: *9* __init__ (emergencyDialog)
def __init__(self, title, message):
    """Constructor for the leoTkinterDialog class."""
    self.answer = None # Value returned from run()
    self.title = title
    self.message = message
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.
    self.createTopFrame()
    buttons = {"text": "OK", "command": self.okButton, "default": True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
.. @+node:ekr.20170624151245.261: *9* createButtons
def createButtons(self, buttons):
    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top", padx=30)
    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text", "<missing button name>")
        isDefault = d.get("default", False)
        underline = d.get("underline", 0)
        command = d.get("command", None)
        bd = 4 if isDefault else 2
        b = Tk.Button(f, width=6, text=text, bd=bd,
            underline=underline, command=command)
        b.pack(side="left", padx=5, pady=10)
        buttonList.append(b)
        if isDefault and command:
            self.defaultButtonCommand = command
    return buttonList
.. @+node:ekr.20170624151245.262: *9* createTopFrame
def createTopFrame(self):
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=message, bg='white')
    label.pack(pady=10)
.. @+node:ekr.20170624151245.263: *9* okButton
def okButton(self):
    """Do default click action in ok button."""
    self.top.destroy()
    self.top = None
.. @+node:ekr.20170624151245.264: *9* onKey
def onKey(self, event):
    """Handle Key events in askOk dialogs."""
    self.okButton()
    return # (for Tk) "break"
.. @+node:ekr.20170624151245.265: *9* run
def run(self):
    """Run the modal emergency dialog."""
    self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
    self.top.lift()
    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
.. @+node:ekr.20170624151245.253: *8* << define emergency dialog class >>
class EmergencyDialog(object):
    """A class that creates an Tkinter dialog with a single OK button."""
    @others
.. @+node:ekr.20170624151245.260: *9* __init__ (emergencyDialog)
def __init__(self, title, message):
    """Constructor for the leoTkinterDialog class."""
    self.answer = None # Value returned from run()
    self.title = title
    self.message = message
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.
    self.createTopFrame()
    buttons = {"text": "OK", "command": self.okButton, "default": True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
.. @+node:ekr.20170624151245.261: *9* createButtons
def createButtons(self, buttons):
    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top", padx=30)
    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text", "<missing button name>")
        isDefault = d.get("default", False)
        underline = d.get("underline", 0)
        command = d.get("command", None)
        bd = 4 if isDefault else 2
        b = Tk.Button(f, width=6, text=text, bd=bd,
            underline=underline, command=command)
        b.pack(side="left", padx=5, pady=10)
        buttonList.append(b)
        if isDefault and command:
            self.defaultButtonCommand = command
    return buttonList
.. @+node:ekr.20170624151245.262: *9* createTopFrame
def createTopFrame(self):
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=message, bg='white')
    label.pack(pady=10)
.. @+node:ekr.20170624151245.263: *9* okButton
def okButton(self):
    """Do default click action in ok button."""
    self.top.destroy()
    self.top = None
.. @+node:ekr.20170624151245.264: *9* onKey
def onKey(self, event):
    """Handle Key events in askOk dialogs."""
    self.okButton()
    return # (for Tk) "break"
.. @+node:ekr.20170624151245.265: *9* run
def run(self):
    """Run the modal emergency dialog."""
    self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
    self.top.lift()
    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
.. @+node:ekr.20170624151245.260: *9* __init__ (emergencyDialog)
def __init__(self, title, message):
    """Constructor for the leoTkinterDialog class."""
    self.answer = None # Value returned from run()
    self.title = title
    self.message = message
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.
    self.createTopFrame()
    buttons = {"text": "OK", "command": self.okButton, "default": True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
.. @+node:ekr.20170624151245.261: *9* createButtons
def createButtons(self, buttons):
    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top", padx=30)
    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text", "<missing button name>")
        isDefault = d.get("default", False)
        underline = d.get("underline", 0)
        command = d.get("command", None)
        bd = 4 if isDefault else 2
        b = Tk.Button(f, width=6, text=text, bd=bd,
            underline=underline, command=command)
        b.pack(side="left", padx=5, pady=10)
        buttonList.append(b)
        if isDefault and command:
            self.defaultButtonCommand = command
    return buttonList
.. @+node:ekr.20170624151245.262: *9* createTopFrame
def createTopFrame(self):
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=message, bg='white')
    label.pack(pady=10)
.. @+node:ekr.20170624151245.263: *9* okButton
def okButton(self):
    """Do default click action in ok button."""
    self.top.destroy()
    self.top = None
.. @+node:ekr.20170624151245.264: *9* onKey
def onKey(self, event):
    """Handle Key events in askOk dialogs."""
    self.okButton()
    return # (for Tk) "break"
.. @+node:ekr.20170624151245.265: *9* run
def run(self):
    """Run the modal emergency dialog."""
    self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
    self.top.lift()
    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
.. @+node:ekr.20170624151245.266: *7* LM.loadLocalFile & helper
def loadLocalFile(self, fn, gui, old_c):
    '''Completely read a file, creating the corresonding outline.

    1. If fn is an existing .leo file (possibly zipped), read it twice:
    the first time with a NullGui to discover settings,
    the second time with the requested gui to create the outline.

    2. If fn is an external file:
    get settings from the leoSettings.leo and myLeoSetting.leo, then
    create a "wrapper" outline continain an @file node for the external file.

    3. If fn is empty:
    get settings from the leoSettings.leo and myLeoSetting.leo or default settings,
    or open an empty outline.
    '''
    trace = (False or g.trace_startup or g.app.debug) and not g.unitTesting
    if trace: g.es_debug(fn)
    lm = self
    # Step 0: Return if the file is already open.
    fn = g.os_path_finalize(fn)
    if fn:
        c = lm.findOpenFile(fn)
        if c:
            if trace: g.trace('Already open: %s' % (fn))
            return c
    # Step 1: get the previous settings.
    # For .leo files (and zipped .leo files) this pre-reads the file in a null gui.
    # Otherwise, get settings from leoSettings.leo, myLeoSettings.leo, or default settings.
    previousSettings = lm.getPreviousSettings(fn)
    # Step 2: open the outline in the requested gui.
    # For .leo files (and zipped .leo file) this opens the file a second time.
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
    return c
.. @+node:ekr.20170624151245.286: *8* LM.openFileByName & helpers
def openFileByName(self, fn, gui, old_c, previousSettings):
    '''Read the local file whose full path is fn using the given gui.
    fn may be a Leo file (including .leo or zipped file) or an external file.

    This is not a pre-read: the previousSettings always exist and
    the commander created here persists until the user closes the outline.

    Reads the entire outline if fn exists and is a .leo file or zipped file.
    Creates an empty outline if fn is a non-existent Leo file.
    Creates an wrapper outline if fn is an external file, existing or not.
    '''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug(g.shortFileName(fn))
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    # Important.  The settings don't matter for pre-reads!
    # For second read, the settings for the file are *exactly* previousSettings.
    c = g.app.newCommander(fileName=fn, gui=gui,
        previousSettings=previousSettings)
    assert c
    # Open the file, if possible.
    g.doHook('open0')
    theFile = lm.openLeoOrZipFile(fn)
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Phase 2: Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        readAtFileNodesFlag = bool(previousSettings)
        # The log is not set properly here.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
            # Call c.fileCommands.openLeoFile to read the .leo file.
        if not ok: return None
    else:
        # Create a wrapper .leo file if:
        # a) fn is a .leo file that does not exist or
        # b) fn is an external file, existing or not.
        lm.initWrapperLeoFile(c, fn)
    g.doHook("open2", old_c=None, c=c, new_c=c, fileName=fn)
    # Phase 3: Complete the initialization.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
.. @+node:ekr.20170624151245.296: *9* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
        c.enableMenuBar()
.. @+node:ekr.20170624151245.297: *9* LM.findOpenFile
def findOpenFile(self, fn):
    # lm = self

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # don't frame.bringToFront(), it breaks --minimize
            c.setLog()
            # 2011/11/21: selecting the new tab ensures focus is set.
            master = hasattr(frame.top, 'leo_master') and frame.top.leo_master
            if master: # frame.top.leo_master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
.. @+node:ekr.20170624151245.298: *9* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # Honor focus requests.
        # This fixes bug 181: Focus remains in previous file
        # https://github.com/leo-editor/leo-editor/issues/181
.. @+node:ekr.20170624151245.299: *9* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    '''
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    '''
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None) # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString('%s %s' % (load_type,fn))
            c.refreshFromDisk()
            c.selectPosition(p)
                
    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else '%s.leo' % (fn)
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.setChanged(False)
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
.. @+node:ekr.20170624151245.300: *9* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (zipfile.is_zipfile(fn) or fn.endswith('.leo'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
.. @+node:ekr.20170624151245.301: *9* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
.. @+node:ekr.20170624151245.302: *9* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.303: *9* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        if g.isPython3: s = g.ue(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.304: *9* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = c.os_path_finalize(g.os_path_dirname(fn))
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=self.more_cmdline_files is False)
    return ok
.. @+node:ekr.20170624151245.296: *9* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
        c.enableMenuBar()
.. @+node:ekr.20170624151245.297: *9* LM.findOpenFile
def findOpenFile(self, fn):
    # lm = self

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # don't frame.bringToFront(), it breaks --minimize
            c.setLog()
            # 2011/11/21: selecting the new tab ensures focus is set.
            master = hasattr(frame.top, 'leo_master') and frame.top.leo_master
            if master: # frame.top.leo_master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
.. @+node:ekr.20170624151245.298: *9* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # Honor focus requests.
        # This fixes bug 181: Focus remains in previous file
        # https://github.com/leo-editor/leo-editor/issues/181
.. @+node:ekr.20170624151245.299: *9* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    '''
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    '''
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None) # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString('%s %s' % (load_type,fn))
            c.refreshFromDisk()
            c.selectPosition(p)
                
    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else '%s.leo' % (fn)
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.setChanged(False)
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
.. @+node:ekr.20170624151245.300: *9* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (zipfile.is_zipfile(fn) or fn.endswith('.leo'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
.. @+node:ekr.20170624151245.301: *9* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
.. @+node:ekr.20170624151245.302: *9* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.303: *9* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        if g.isPython3: s = g.ue(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.304: *9* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = c.os_path_finalize(g.os_path_dirname(fn))
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=self.more_cmdline_files is False)
    return ok
.. @+node:ekr.20170624151245.286: *8* LM.openFileByName & helpers
def openFileByName(self, fn, gui, old_c, previousSettings):
    '''Read the local file whose full path is fn using the given gui.
    fn may be a Leo file (including .leo or zipped file) or an external file.

    This is not a pre-read: the previousSettings always exist and
    the commander created here persists until the user closes the outline.

    Reads the entire outline if fn exists and is a .leo file or zipped file.
    Creates an empty outline if fn is a non-existent Leo file.
    Creates an wrapper outline if fn is an external file, existing or not.
    '''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug(g.shortFileName(fn))
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    # Important.  The settings don't matter for pre-reads!
    # For second read, the settings for the file are *exactly* previousSettings.
    c = g.app.newCommander(fileName=fn, gui=gui,
        previousSettings=previousSettings)
    assert c
    # Open the file, if possible.
    g.doHook('open0')
    theFile = lm.openLeoOrZipFile(fn)
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Phase 2: Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        readAtFileNodesFlag = bool(previousSettings)
        # The log is not set properly here.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
            # Call c.fileCommands.openLeoFile to read the .leo file.
        if not ok: return None
    else:
        # Create a wrapper .leo file if:
        # a) fn is a .leo file that does not exist or
        # b) fn is an external file, existing or not.
        lm.initWrapperLeoFile(c, fn)
    g.doHook("open2", old_c=None, c=c, new_c=c, fileName=fn)
    # Phase 3: Complete the initialization.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
.. @+node:ekr.20170624151245.296: *9* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
        c.enableMenuBar()
.. @+node:ekr.20170624151245.297: *9* LM.findOpenFile
def findOpenFile(self, fn):
    # lm = self

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # don't frame.bringToFront(), it breaks --minimize
            c.setLog()
            # 2011/11/21: selecting the new tab ensures focus is set.
            master = hasattr(frame.top, 'leo_master') and frame.top.leo_master
            if master: # frame.top.leo_master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
.. @+node:ekr.20170624151245.298: *9* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # Honor focus requests.
        # This fixes bug 181: Focus remains in previous file
        # https://github.com/leo-editor/leo-editor/issues/181
.. @+node:ekr.20170624151245.299: *9* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    '''
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    '''
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None) # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString('%s %s' % (load_type,fn))
            c.refreshFromDisk()
            c.selectPosition(p)
                
    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else '%s.leo' % (fn)
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.setChanged(False)
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
.. @+node:ekr.20170624151245.300: *9* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (zipfile.is_zipfile(fn) or fn.endswith('.leo'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
.. @+node:ekr.20170624151245.301: *9* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
.. @+node:ekr.20170624151245.302: *9* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.303: *9* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        if g.isPython3: s = g.ue(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.304: *9* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = c.os_path_finalize(g.os_path_dirname(fn))
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=self.more_cmdline_files is False)
    return ok
.. @+node:ekr.20170624151245.296: *9* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
        c.enableMenuBar()
.. @+node:ekr.20170624151245.297: *9* LM.findOpenFile
def findOpenFile(self, fn):
    # lm = self

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # don't frame.bringToFront(), it breaks --minimize
            c.setLog()
            # 2011/11/21: selecting the new tab ensures focus is set.
            master = hasattr(frame.top, 'leo_master') and frame.top.leo_master
            if master: # frame.top.leo_master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
.. @+node:ekr.20170624151245.298: *9* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # Honor focus requests.
        # This fixes bug 181: Focus remains in previous file
        # https://github.com/leo-editor/leo-editor/issues/181
.. @+node:ekr.20170624151245.299: *9* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    '''
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    '''
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None) # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString('%s %s' % (load_type,fn))
            c.refreshFromDisk()
            c.selectPosition(p)
                
    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else '%s.leo' % (fn)
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.setChanged(False)
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
.. @+node:ekr.20170624151245.300: *9* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (zipfile.is_zipfile(fn) or fn.endswith('.leo'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
.. @+node:ekr.20170624151245.301: *9* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
.. @+node:ekr.20170624151245.302: *9* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.303: *9* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        if g.isPython3: s = g.ue(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.304: *9* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = c.os_path_finalize(g.os_path_dirname(fn))
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=self.more_cmdline_files is False)
    return ok
.. @+node:ekr.20170624151245.174: *7* LM.doDiff
def doDiff(self):
    '''Support --diff option after loading Leo.'''
    if len(self.old_argv[2:]) == 2:
        pass # c.editFileCommands.compareAnyTwoFiles gives a message.
    else:
        # This is an unusual situation.
        g.es('--diff mode. sys.argv[2:]...', color='red')
        for z in self.old_argv[2:]:
            g.es(g.shortFileName(z) if z else repr(z), color='blue')
    commanders = g.app.commanders()
    if len(commanders) == 2:
        c = commanders[0]
        c.editFileCommands.compareAnyTwoFiles(event=None)
.. @+node:ekr.20170624151245.175: *7* LM.doPrePluginsInit & helpers
def doPrePluginsInit(self, fileName, pymacs):
    ''' Scan options, set directories and read settings.'''
    # trace = False
    lm = self
    lm.computeStandardDirectories()
    lm.adjustSysPath()
        # A do-nothing.
    # Scan the options as early as possible.
    lm.options = options = lm.scanOptions(fileName, pymacs)
        # also sets lm.files.
    if options.get('version'):
        g.app.computeSignon()
        return
    script = options.get('script')
    verbose = script is None
    # Init the app.
    lm.initApp(verbose)
    lm.reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    lm.readGlobalSettingsFiles()
        # reads only standard settings files, using a null gui.
        # uses lm.files[0] to compute the local directory
        # that might contain myLeoSettings.leo.
    # Read the recent files file.
    localConfigFile = lm.files[0] if lm.files else None
    g.app.recentFilesManager.readRecentFiles(localConfigFile)
    g.app.setGlobalDb()
    # Create the gui after reading options and settings.
    lm.createGui(pymacs)
    # We can't print the signon until we know the gui.
    g.app.computeSignon() # Set app.signon/signon2 for commanders.
.. @+node:ekr.20170624151245.204: *8* LM.createAllImporetersData & helpers (new)
def createAllImporetersData(self):
    '''
    New in Leo 5.5:

    Create global data structures describing importers and writers.
    '''
    assert g.app.loadDir
        # This is the only data required.
    self.createWritersData()
        # Was an AtFile method.
    self.createImporterData()
        # Was a LeoImportCommands method.
.. @+node:ekr.20170624151245.211: *9* LM.createImporterData & helper
def createImporterData(self):
    '''Create the data structures describing importer plugins.'''
    trace = False and not g.unitTesting
    trace_exception = False
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[: -3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        'leo.plugins.importers.%s' % module_name)
                    self.parse_importer_dict(sfn, m)
                except Exception:
                    if trace and trace_exception:
                        g.es_exception()
                    g.warning('can not import leo.plugins.importers.%s' % (
                        module_name))
    if trace:
        g.trace('g.app.atAutoDict')
        g.printDict(g.app.atAutoDict)
        g.trace('g.app.classDispatchDict')
        g.printDict(g.app.classDispatchDict)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.214: *9* LM.createWritersData & helper
def createWritersData(self):
    '''Create the data structures describing writer plugins.'''
    trace = False # and not g.unitTesting
    trace = trace and 'createWritersData' not in g.app.debug_dict
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module('leo.plugins.writers.%s' % sfn[: -3])
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning('can not import leo.plugins.writers.%s' % sfn)
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: https://github.com/leo-editor/leo-editor/issues/40
 
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.211: *9* LM.createImporterData & helper
def createImporterData(self):
    '''Create the data structures describing importer plugins.'''
    trace = False and not g.unitTesting
    trace_exception = False
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[: -3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        'leo.plugins.importers.%s' % module_name)
                    self.parse_importer_dict(sfn, m)
                except Exception:
                    if trace and trace_exception:
                        g.es_exception()
                    g.warning('can not import leo.plugins.importers.%s' % (
                        module_name))
    if trace:
        g.trace('g.app.atAutoDict')
        g.printDict(g.app.atAutoDict)
        g.trace('g.app.classDispatchDict')
        g.printDict(g.app.classDispatchDict)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.214: *9* LM.createWritersData & helper
def createWritersData(self):
    '''Create the data structures describing writer plugins.'''
    trace = False # and not g.unitTesting
    trace = trace and 'createWritersData' not in g.app.debug_dict
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module('leo.plugins.writers.%s' % sfn[: -3])
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning('can not import leo.plugins.writers.%s' % sfn)
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: https://github.com/leo-editor/leo-editor/issues/40
 
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.217: *8* LM.createGui
def createGui(self, pymacs):
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug()
    lm = self
    gui_option = lm.options.get('gui')
    windowFlag = lm.options.get('windowFlag')
    script = lm.options.get('script')
    if g.app.gui:
        if g.app.gui == g.app.nullGui:
            g.app.gui = None # Enable g.app.createDefaultGui
            g.app.createDefaultGui(__file__)
        else:
            # This can happen when launching Leo from IPython.
            g.trace('g.app.gui', g.app.gui, g.callers())
    elif gui_option is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        lm.createSpecialGui(gui_option, pymacs, script, windowFlag)
.. @+node:ekr.20170624151245.218: *8* LM.createSpecialGui
def createSpecialGui(self, gui, pymacs, script, windowFlag):
    # lm = self
    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        # assert g.app.guiArgName
        g.app.createDefaultGui()
.. @+node:ekr.20170624151245.219: *8* LM.adjustSysPath
def adjustSysPath(self):
    '''Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:

        1. g.importModule will import from the
           'external' or 'extensions' folders as needed
           without altering sys.path.

        2.  Plugins now do fully qualified imports.
    '''
    pass
.. @+node:ekr.20170624151245.220: *8* LM.getDefaultFile
def getDefaultFile(self):
    # Get the name of the workbook.
    fn = g.app.config.getString('default_leo_file')
    fn = g.os_path_finalize(fn)
    if not fn: return
    # g.trace(g.os_path_exists(fn),fn)
    if g.os_path_exists(fn):
        return fn
    elif g.os_path_isabs(fn):
        # Create the file.
        g.error('Using default leo file name:\n%s' % (fn))
        return fn
    else:
        # It's too risky to open a default file if it is relative.
        return None
.. @+node:ekr.20170624151245.221: *8* LM.initApp
def initApp(self, verbose):
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug()
    self.createAllImporetersData()
        # Can be done early. Uses only g.app.loadDir
    assert g.app.loadManager
    import leo.core.leoBackground as leoBackground
    import leo.core.leoConfig as leoConfig
    import leo.core.leoNodes as leoNodes
    import leo.core.leoPlugins as leoPlugins
    import leo.core.leoSessions as leoSessions
    # Import leoIPython only if requested.  The import is quite slow.
    self.setStdStreams()
    if g.app.useIpython:
        import leo.core.leoIPython as leoIPython
            # This launches the IPython Qt Console.  It *is* required.
        assert leoIPython # suppress pyflakes/flake8 warning.
    # Make sure we call the new leoPlugins.init top-level function.
    leoPlugins.init()
    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    # Create early classes *after* doing plugins.init()
    g.app.idleTimeManager = IdleTimeManager()
    g.app.backgroundProcessManager = leoBackground.BackgroundProcessManager()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController()
    g.app.recentFilesManager = RecentFilesManager()
    g.app.config = leoConfig.GlobalConfigManager()
    g.app.nodeIndices = leoNodes.NodeIndices(g.app.leoID)
    g.app.sessionManager = leoSessions.SessionManager()
    # Complete the plugins class last.
    g.app.pluginsController.finishCreate()
.. @+node:ekr.20170624151245.222: *8* LM.scanOptions & helper
def scanOptions(self, fileName, pymacs):
    '''Handle all options, remove them from sys.argv and set lm.options.'''
    trace = False
    lm = self
    # print('scanOptions',sys.argv)
    lm.old_argv = sys.argv[:]
    # Note: this automatically implements the --help option.
    usage = "usage: launchLeo.py [options] file1, file2, ..."
    parser = optparse.OptionParser(usage=usage)
    add = parser.add_option
    add('--debug', action='store_true',
        help='enable debug mode')
    add('--diff', action='store_true', dest='diff',
        help='use Leo as an external git diff')
    add('--fullscreen', action='store_true',
        help='start fullscreen')
    add('--ipython', action='store_true', dest='use_ipython',
        help='enable ipython support')
    add('--fail-fast', action='store_true', dest='fail_fast',
        help='stop unit tests after the first failure')
    add('--gui',
        help='gui to use (qt/qttabs/console/null)')
    add('--load-type', dest='load_type',
        help='@<file> type for loading non-outlines from command line')
    add('--maximized', action='store_true',
        help='start maximized')
    add('--minimized', action='store_true',
        help='start minimized')
    add('--no-cache', action='store_true', dest='no_cache',
        help='disable reading of cached files')
    add('--no-plugins', action='store_true', dest='no_plugins',
        help='disable all plugins')
    add('--no-splash', action='store_true', dest='no_splash_screen',
        help='disable the splash screen')
    add('--screen-shot', dest='screenshot_fn',
        help='take a screen shot and then exit')
    add('--script', dest='script',
        help='execute a script and then exit')
    add('--script-window', dest='script_window',
        help='open a window for scripts')
    add('--select', dest='select',
        help='headline or gnx of node to select')
    add('--session-restore', action='store_true', dest='session_restore',
        help='restore previously saved session tabs at startup')
    add('--session-save', action='store_true', dest='session_save',
        help='save session tabs on exit')
    add('--silent', action='store_true', dest='silent',
        help='disable all log messages')
    add('--trace-focus', action='store_true', dest='trace_focus',
        help='trace changes of focus')
    add('--trace-plugins', action='store_true', dest='trace_plugins',
        help='trace imports of plugins')
    add('-v', '--version', action='store_true', dest='version',
        help='print version number and exit')
    add('--window-size', dest='window_size',
        help='initial window size (height x width)')
    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]; sys.argv.extend(args)
    if trace:
        # print('scanOptions:',sys.argv)
        g.trace('options', options)
    # Handle the args...
    # --debug
    g.app.debug = options.debug
    # if g.app.debug: g.trace_startup = True
    # --fail-fast
    if options.fail_fast:
        g.app.failFast = True
    # --git-diff
    if options.diff:
        g.app.diff = options.diff
    # --gui
    gui = options.gui
    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            g.app.qt_use_tabs = True
        elif gui in ('console', 'curses', 'text', 'qt', 'null'):
                # text: cursesGui.py, curses: cursesGui2.py.
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s.  Using qt gui' % gui)
            gui = 'qt'
            g.app.qt_use_tabs = False
    elif sys.platform == 'darwin':
        gui = 'qt'
        g.app.qt_use_tabs = False
    else:
        gui = 'qttabs'
        g.app.qt_use_tabs = True
    assert gui
    g.app.guiArgName = gui
    # --load-type
    load_type = options.load_type
    if load_type:
        load_type = load_type.lower()
    else:
        load_type = 'edit'
    load_type = '@' + load_type
    # --ipython
    g.app.useIpython = options.use_ipython
    if trace: g.trace('g.app.useIpython', g.app.useIpython)
    # --fullscreen
    # --minimized
    # --maximized
    g.app.start_fullscreen = options.fullscreen
    g.app.start_maximized = options.maximized
    g.app.start_minimized = options.minimized
    # --no-cache
    if options.no_cache:
        if trace: print('scanOptions: disabling caching')
        g.enableDB = False
    # --no-plugins
    if options.no_plugins:
        if trace: print('scanOptions: disabling plugins')
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = (
        not options.no_splash_screen and
        not options.minimized)
    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn', screenshot_fn)
    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error('--script and script-window are mutually exclusive')
    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir, script_name)
        script, e = g.readFileIntoString(script_name, kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')
    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select', repr(select))
    # --session-restore & --session-save
    g.app.restore_session = bool(options.session_restore)
    g.app.save_session = bool(options.session_save)
    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)
    # --trace-focus
    g.app.trace_focus = options.trace_focus
    # --trace-plugins
    g.app.trace_plugins = options.trace_plugins
    # --version: print the version and exit.
    versionFlag = options.version
    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize', repr(windowSize))
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:', windowSize)
    # Compute lm.files
    lm.files = lm.computeFilesList(fileName)
    # if options.debug:
    #    g.es_debug('lm.files',lm.files)
    # Post-process the options.
    if pymacs:
        script = None
        windowFlag = None
    # Compute the return values.
    windowFlag = script and script_path_w
    d = {
        'gui': gui,
        'load_type': load_type,
        'screenshot_fn': screenshot_fn,
        'script': script,
        'select': select,
        'version': versionFlag,
        'windowFlag': windowFlag,
        'windowSize': windowSize,
    }
    if trace: g.trace(d)
    return d
.. @+node:ekr.20170624151245.224: *9* LM.computeFilesList
def computeFilesList(self, fileName):
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = glob.glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return result
.. @+node:ekr.20170624151245.224: *9* LM.computeFilesList
def computeFilesList(self, fileName):
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = glob.glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return result
.. @+node:ekr.20170624151245.225: *8* LM.setStdStreams
def setStdStreams(self):
    '''
    Make sure that stdout and stderr exist.
    This is an issue when running Leo with pythonw.exe.
    '''
    # pdb requires sys.stdin, which doesn't exist when using pythonw.exe.
    # import pdb ; pdb.set_trace()
    import sys
    import leo.core.leoGlobals as g
    
    # Define class LeoStdOut
    @others

    if not sys.stdout:
        sys.stdout = sys.__stdout__ = LeoStdOut('stdout')
    if not sys.stderr:
        sys.stderr = sys.__stderr__ = LeoStdOut('stderr')
.. @+node:ekr.20170624151245.229: *9* class LeoStdOut
class LeoStdOut:
    '''A class to put stderr & stdout to Leo's log pane.'''

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
        
    @others
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.229: *9* class LeoStdOut
class LeoStdOut:
    '''A class to put stderr & stdout to Leo's log pane.'''

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
        
    @others
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.204: *8* LM.createAllImporetersData & helpers (new)
def createAllImporetersData(self):
    '''
    New in Leo 5.5:

    Create global data structures describing importers and writers.
    '''
    assert g.app.loadDir
        # This is the only data required.
    self.createWritersData()
        # Was an AtFile method.
    self.createImporterData()
        # Was a LeoImportCommands method.
.. @+node:ekr.20170624151245.211: *9* LM.createImporterData & helper
def createImporterData(self):
    '''Create the data structures describing importer plugins.'''
    trace = False and not g.unitTesting
    trace_exception = False
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[: -3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        'leo.plugins.importers.%s' % module_name)
                    self.parse_importer_dict(sfn, m)
                except Exception:
                    if trace and trace_exception:
                        g.es_exception()
                    g.warning('can not import leo.plugins.importers.%s' % (
                        module_name))
    if trace:
        g.trace('g.app.atAutoDict')
        g.printDict(g.app.atAutoDict)
        g.trace('g.app.classDispatchDict')
        g.printDict(g.app.classDispatchDict)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.214: *9* LM.createWritersData & helper
def createWritersData(self):
    '''Create the data structures describing writer plugins.'''
    trace = False # and not g.unitTesting
    trace = trace and 'createWritersData' not in g.app.debug_dict
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module('leo.plugins.writers.%s' % sfn[: -3])
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning('can not import leo.plugins.writers.%s' % sfn)
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: https://github.com/leo-editor/leo-editor/issues/40
 
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.211: *9* LM.createImporterData & helper
def createImporterData(self):
    '''Create the data structures describing importer plugins.'''
    trace = False and not g.unitTesting
    trace_exception = False
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[: -3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        'leo.plugins.importers.%s' % module_name)
                    self.parse_importer_dict(sfn, m)
                except Exception:
                    if trace and trace_exception:
                        g.es_exception()
                    g.warning('can not import leo.plugins.importers.%s' % (
                        module_name))
    if trace:
        g.trace('g.app.atAutoDict')
        g.printDict(g.app.atAutoDict)
        g.trace('g.app.classDispatchDict')
        g.printDict(g.app.classDispatchDict)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.213: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20170624151245.214: *9* LM.createWritersData & helper
def createWritersData(self):
    '''Create the data structures describing writer plugins.'''
    trace = False # and not g.unitTesting
    trace = trace and 'createWritersData' not in g.app.debug_dict
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in glob.glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module('leo.plugins.writers.%s' % sfn[: -3])
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning('can not import leo.plugins.writers.%s' % sfn)
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: https://github.com/leo-editor/leo-editor/issues/40
 
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.216: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20170624151245.217: *8* LM.createGui
def createGui(self, pymacs):
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug()
    lm = self
    gui_option = lm.options.get('gui')
    windowFlag = lm.options.get('windowFlag')
    script = lm.options.get('script')
    if g.app.gui:
        if g.app.gui == g.app.nullGui:
            g.app.gui = None # Enable g.app.createDefaultGui
            g.app.createDefaultGui(__file__)
        else:
            # This can happen when launching Leo from IPython.
            g.trace('g.app.gui', g.app.gui, g.callers())
    elif gui_option is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        lm.createSpecialGui(gui_option, pymacs, script, windowFlag)
.. @+node:ekr.20170624151245.218: *8* LM.createSpecialGui
def createSpecialGui(self, gui, pymacs, script, windowFlag):
    # lm = self
    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        # assert g.app.guiArgName
        g.app.createDefaultGui()
.. @+node:ekr.20170624151245.219: *8* LM.adjustSysPath
def adjustSysPath(self):
    '''Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:

        1. g.importModule will import from the
           'external' or 'extensions' folders as needed
           without altering sys.path.

        2.  Plugins now do fully qualified imports.
    '''
    pass
.. @+node:ekr.20170624151245.220: *8* LM.getDefaultFile
def getDefaultFile(self):
    # Get the name of the workbook.
    fn = g.app.config.getString('default_leo_file')
    fn = g.os_path_finalize(fn)
    if not fn: return
    # g.trace(g.os_path_exists(fn),fn)
    if g.os_path_exists(fn):
        return fn
    elif g.os_path_isabs(fn):
        # Create the file.
        g.error('Using default leo file name:\n%s' % (fn))
        return fn
    else:
        # It's too risky to open a default file if it is relative.
        return None
.. @+node:ekr.20170624151245.221: *8* LM.initApp
def initApp(self, verbose):
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug()
    self.createAllImporetersData()
        # Can be done early. Uses only g.app.loadDir
    assert g.app.loadManager
    import leo.core.leoBackground as leoBackground
    import leo.core.leoConfig as leoConfig
    import leo.core.leoNodes as leoNodes
    import leo.core.leoPlugins as leoPlugins
    import leo.core.leoSessions as leoSessions
    # Import leoIPython only if requested.  The import is quite slow.
    self.setStdStreams()
    if g.app.useIpython:
        import leo.core.leoIPython as leoIPython
            # This launches the IPython Qt Console.  It *is* required.
        assert leoIPython # suppress pyflakes/flake8 warning.
    # Make sure we call the new leoPlugins.init top-level function.
    leoPlugins.init()
    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    # Create early classes *after* doing plugins.init()
    g.app.idleTimeManager = IdleTimeManager()
    g.app.backgroundProcessManager = leoBackground.BackgroundProcessManager()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController()
    g.app.recentFilesManager = RecentFilesManager()
    g.app.config = leoConfig.GlobalConfigManager()
    g.app.nodeIndices = leoNodes.NodeIndices(g.app.leoID)
    g.app.sessionManager = leoSessions.SessionManager()
    # Complete the plugins class last.
    g.app.pluginsController.finishCreate()
.. @+node:ekr.20170624151245.222: *8* LM.scanOptions & helper
def scanOptions(self, fileName, pymacs):
    '''Handle all options, remove them from sys.argv and set lm.options.'''
    trace = False
    lm = self
    # print('scanOptions',sys.argv)
    lm.old_argv = sys.argv[:]
    # Note: this automatically implements the --help option.
    usage = "usage: launchLeo.py [options] file1, file2, ..."
    parser = optparse.OptionParser(usage=usage)
    add = parser.add_option
    add('--debug', action='store_true',
        help='enable debug mode')
    add('--diff', action='store_true', dest='diff',
        help='use Leo as an external git diff')
    add('--fullscreen', action='store_true',
        help='start fullscreen')
    add('--ipython', action='store_true', dest='use_ipython',
        help='enable ipython support')
    add('--fail-fast', action='store_true', dest='fail_fast',
        help='stop unit tests after the first failure')
    add('--gui',
        help='gui to use (qt/qttabs/console/null)')
    add('--load-type', dest='load_type',
        help='@<file> type for loading non-outlines from command line')
    add('--maximized', action='store_true',
        help='start maximized')
    add('--minimized', action='store_true',
        help='start minimized')
    add('--no-cache', action='store_true', dest='no_cache',
        help='disable reading of cached files')
    add('--no-plugins', action='store_true', dest='no_plugins',
        help='disable all plugins')
    add('--no-splash', action='store_true', dest='no_splash_screen',
        help='disable the splash screen')
    add('--screen-shot', dest='screenshot_fn',
        help='take a screen shot and then exit')
    add('--script', dest='script',
        help='execute a script and then exit')
    add('--script-window', dest='script_window',
        help='open a window for scripts')
    add('--select', dest='select',
        help='headline or gnx of node to select')
    add('--session-restore', action='store_true', dest='session_restore',
        help='restore previously saved session tabs at startup')
    add('--session-save', action='store_true', dest='session_save',
        help='save session tabs on exit')
    add('--silent', action='store_true', dest='silent',
        help='disable all log messages')
    add('--trace-focus', action='store_true', dest='trace_focus',
        help='trace changes of focus')
    add('--trace-plugins', action='store_true', dest='trace_plugins',
        help='trace imports of plugins')
    add('-v', '--version', action='store_true', dest='version',
        help='print version number and exit')
    add('--window-size', dest='window_size',
        help='initial window size (height x width)')
    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]; sys.argv.extend(args)
    if trace:
        # print('scanOptions:',sys.argv)
        g.trace('options', options)
    # Handle the args...
    # --debug
    g.app.debug = options.debug
    # if g.app.debug: g.trace_startup = True
    # --fail-fast
    if options.fail_fast:
        g.app.failFast = True
    # --git-diff
    if options.diff:
        g.app.diff = options.diff
    # --gui
    gui = options.gui
    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            g.app.qt_use_tabs = True
        elif gui in ('console', 'curses', 'text', 'qt', 'null'):
                # text: cursesGui.py, curses: cursesGui2.py.
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s.  Using qt gui' % gui)
            gui = 'qt'
            g.app.qt_use_tabs = False
    elif sys.platform == 'darwin':
        gui = 'qt'
        g.app.qt_use_tabs = False
    else:
        gui = 'qttabs'
        g.app.qt_use_tabs = True
    assert gui
    g.app.guiArgName = gui
    # --load-type
    load_type = options.load_type
    if load_type:
        load_type = load_type.lower()
    else:
        load_type = 'edit'
    load_type = '@' + load_type
    # --ipython
    g.app.useIpython = options.use_ipython
    if trace: g.trace('g.app.useIpython', g.app.useIpython)
    # --fullscreen
    # --minimized
    # --maximized
    g.app.start_fullscreen = options.fullscreen
    g.app.start_maximized = options.maximized
    g.app.start_minimized = options.minimized
    # --no-cache
    if options.no_cache:
        if trace: print('scanOptions: disabling caching')
        g.enableDB = False
    # --no-plugins
    if options.no_plugins:
        if trace: print('scanOptions: disabling plugins')
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = (
        not options.no_splash_screen and
        not options.minimized)
    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn', screenshot_fn)
    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error('--script and script-window are mutually exclusive')
    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir, script_name)
        script, e = g.readFileIntoString(script_name, kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')
    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select', repr(select))
    # --session-restore & --session-save
    g.app.restore_session = bool(options.session_restore)
    g.app.save_session = bool(options.session_save)
    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)
    # --trace-focus
    g.app.trace_focus = options.trace_focus
    # --trace-plugins
    g.app.trace_plugins = options.trace_plugins
    # --version: print the version and exit.
    versionFlag = options.version
    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize', repr(windowSize))
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:', windowSize)
    # Compute lm.files
    lm.files = lm.computeFilesList(fileName)
    # if options.debug:
    #    g.es_debug('lm.files',lm.files)
    # Post-process the options.
    if pymacs:
        script = None
        windowFlag = None
    # Compute the return values.
    windowFlag = script and script_path_w
    d = {
        'gui': gui,
        'load_type': load_type,
        'screenshot_fn': screenshot_fn,
        'script': script,
        'select': select,
        'version': versionFlag,
        'windowFlag': windowFlag,
        'windowSize': windowSize,
    }
    if trace: g.trace(d)
    return d
.. @+node:ekr.20170624151245.224: *9* LM.computeFilesList
def computeFilesList(self, fileName):
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = glob.glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return result
.. @+node:ekr.20170624151245.224: *9* LM.computeFilesList
def computeFilesList(self, fileName):
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = glob.glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return result
.. @+node:ekr.20170624151245.225: *8* LM.setStdStreams
def setStdStreams(self):
    '''
    Make sure that stdout and stderr exist.
    This is an issue when running Leo with pythonw.exe.
    '''
    # pdb requires sys.stdin, which doesn't exist when using pythonw.exe.
    # import pdb ; pdb.set_trace()
    import sys
    import leo.core.leoGlobals as g
    
    # Define class LeoStdOut
    @others

    if not sys.stdout:
        sys.stdout = sys.__stdout__ = LeoStdOut('stdout')
    if not sys.stderr:
        sys.stderr = sys.__stderr__ = LeoStdOut('stderr')
.. @+node:ekr.20170624151245.229: *9* class LeoStdOut
class LeoStdOut:
    '''A class to put stderr & stdout to Leo's log pane.'''

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
        
    @others
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.229: *9* class LeoStdOut
class LeoStdOut:
    '''A class to put stderr & stdout to Leo's log pane.'''

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
        
    @others
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.231: *10* LeoStdOut.write
def write(self, *args, **keys):
    '''Put all non-keyword args to the log pane, as in g.es.'''
    trace = False
        # Tracing will lead to unbounded recursion unless
        # sys.stderr has been redirected on the command line.
    if trace:
        for z in args:
            sys.stderr.write('arg: %r\n' % z)
        for z in keys:
            sys.stderr.write('key: %r\n' % z)
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20170624151245.232: *7* LM.doPostPluginsInit & helpers
def doPostPluginsInit(self):
    '''Create a Leo window for each file in the lm.files list.'''
    # Clear g.app.initing _before_ creating commanders.
    lm = self
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c = c1 = None
    if lm.files:
        for n, fn in enumerate(lm.files):
            lm.more_cmdline_files = n < len(lm.files) - 1
            c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
                # Returns None if the file is open in another instance of Leo.
            if not c1: c1 = c
    if g.app.restore_session:
        m = g.app.sessionManager
        if m:
            aList = m.load_snapshot()
            if aList:
                m.load_session(c1, aList)
                c = c1 = g.app.windowList[0].c
    if not c1 or not g.app.windowList:
        c1 = lm.openEmptyWorkBook()
    # Fix bug #199.
    g.app.runAlreadyOpenDialog(c1)
    # Put the focus in the first-opened file.
    fileName = lm.files[0] if lm.files else None
    c = c1
    # For qttabs gui, select the first-loaded tab.
    if hasattr(g.app.gui, 'frameFactory'):
        factory = g.app.gui.frameFactory
        if factory and hasattr(factory, 'setTabForCommander'):
            factory.setTabForCommander(c)
    if not c:
        return False # Force an immediate exit.
    # Fix bug 844953: tell Unity which menu to use.
    if c: c.enableMenuBar()
    # Do the final inits.
    g.app.logInited = True
    g.app.initComplete = True
    if c: c.setLog()
    # print('doPostPluginsInit: ***** set log')
    p = c.p if c else None
    g.doHook("start2", c=c, p=p, v=p, fileName=fileName)
    if c: lm.initFocusAndDraw(c, fileName)
    screenshot_fn = lm.options.get('screenshot_fn')
    if screenshot_fn:
        lm.make_screen_shot(screenshot_fn)
        return False # Force an immediate exit.
    else:
        return True
.. @+node:ekr.20170624151245.236: *8* LM.initFocusAndDraw
def initFocusAndDraw(self, c, fileName):

    def init_focus_handler(timer, c=c, p=c.p):
        '''Idle-time handler for initFocusAndDraw'''
        c.initialFocusHelper()
        c.outerUpdate()
        timer.stop()

    # This must happen after the code in getLeoFile.
    timer = g.IdleTime(init_focus_handler, delay=0.1, tag='getLeoFile')
    if timer:
        timer.start()
    else:
        # Default code.
        c.selectPosition(c.p)
        c.initialFocusHelper()
        c.k.showStateAndMode()
        c.outerUpdate()
.. @+node:ekr.20170624151245.237: *8* LM.make_screen_shot
def make_screen_shot(self, fn):
    '''Create a screenshot of the present Leo outline and save it to path.'''
    # g.trace('runLeo.py',fn)
    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
.. @+node:ekr.20170624151245.238: *8* LM.openEmptyWorkBook
def openEmptyWorkBook(self):
    '''Open an empty frame and paste the contents of CheatSheet.leo into it.'''
    lm = self
    # Create an empty frame.
    fn = lm.computeWorkbookFileName()
    c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
    # Open the cheatsheet, but not in batch mode.
    if not g.app.batchMode and not g.os_path_exists(fn):
        # Paste the contents of CheetSheet.leo into c.
        c2 = c.openCheatSheet(redraw=False)
        if c2:
            for p2 in c2.rootPosition().self_and_siblings():
                c2.selectPosition(p2)
                c2.copyOutline()
                p = c.pasteOutline()
                c.selectPosition(p)
                p.contract()
                p.clearDirty()
            c2.close(new_c=c)
            root = c.rootPosition()
            if root.h == g.shortFileName(fn):
                root.doDelete(newNode=root.next())
            p = g.findNodeAnywhere(c, "Leo's cheat sheet")
            if p:
                c.selectPosition(p, enableRedrawFlag=False)
                p.expand()
            c.target_language = 'rest'
                # Settings not parsed the first time.
            c.setChanged(False)
            c.redraw()
    return c
.. @+node:ekr.20170624151245.236: *8* LM.initFocusAndDraw
def initFocusAndDraw(self, c, fileName):

    def init_focus_handler(timer, c=c, p=c.p):
        '''Idle-time handler for initFocusAndDraw'''
        c.initialFocusHelper()
        c.outerUpdate()
        timer.stop()

    # This must happen after the code in getLeoFile.
    timer = g.IdleTime(init_focus_handler, delay=0.1, tag='getLeoFile')
    if timer:
        timer.start()
    else:
        # Default code.
        c.selectPosition(c.p)
        c.initialFocusHelper()
        c.k.showStateAndMode()
        c.outerUpdate()
.. @+node:ekr.20170624151245.237: *8* LM.make_screen_shot
def make_screen_shot(self, fn):
    '''Create a screenshot of the present Leo outline and save it to path.'''
    # g.trace('runLeo.py',fn)
    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
.. @+node:ekr.20170624151245.238: *8* LM.openEmptyWorkBook
def openEmptyWorkBook(self):
    '''Open an empty frame and paste the contents of CheatSheet.leo into it.'''
    lm = self
    # Create an empty frame.
    fn = lm.computeWorkbookFileName()
    c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
    # Open the cheatsheet, but not in batch mode.
    if not g.app.batchMode and not g.os_path_exists(fn):
        # Paste the contents of CheetSheet.leo into c.
        c2 = c.openCheatSheet(redraw=False)
        if c2:
            for p2 in c2.rootPosition().self_and_siblings():
                c2.selectPosition(p2)
                c2.copyOutline()
                p = c.pasteOutline()
                c.selectPosition(p)
                p.contract()
                p.clearDirty()
            c2.close(new_c=c)
            root = c.rootPosition()
            if root.h == g.shortFileName(fn):
                root.doDelete(newNode=root.next())
            p = g.findNodeAnywhere(c, "Leo's cheat sheet")
            if p:
                c.selectPosition(p, enableRedrawFlag=False)
                p.expand()
            c.target_language = 'rest'
                # Settings not parsed the first time.
            c.setChanged(False)
            c.redraw()
    return c
.. @+node:ekr.20170624151245.239: *7* LM.isValidPython & emergency (Tk) dialog class
def isValidPython(self):
    if sys.platform == 'cli':
        return True
    minimum_python_version = '2.6'
    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0, 1, 2)])
        ok = g.CheckVersion(version, minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = EmergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
.. @+node:ekr.20170624151245.253: *8* << define emergency dialog class >>
class EmergencyDialog(object):
    """A class that creates an Tkinter dialog with a single OK button."""
    @others
.. @+node:ekr.20170624151245.260: *9* __init__ (emergencyDialog)
def __init__(self, title, message):
    """Constructor for the leoTkinterDialog class."""
    self.answer = None # Value returned from run()
    self.title = title
    self.message = message
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.
    self.createTopFrame()
    buttons = {"text": "OK", "command": self.okButton, "default": True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
.. @+node:ekr.20170624151245.261: *9* createButtons
def createButtons(self, buttons):
    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top", padx=30)
    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text", "<missing button name>")
        isDefault = d.get("default", False)
        underline = d.get("underline", 0)
        command = d.get("command", None)
        bd = 4 if isDefault else 2
        b = Tk.Button(f, width=6, text=text, bd=bd,
            underline=underline, command=command)
        b.pack(side="left", padx=5, pady=10)
        buttonList.append(b)
        if isDefault and command:
            self.defaultButtonCommand = command
    return buttonList
.. @+node:ekr.20170624151245.262: *9* createTopFrame
def createTopFrame(self):
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=message, bg='white')
    label.pack(pady=10)
.. @+node:ekr.20170624151245.263: *9* okButton
def okButton(self):
    """Do default click action in ok button."""
    self.top.destroy()
    self.top = None
.. @+node:ekr.20170624151245.264: *9* onKey
def onKey(self, event):
    """Handle Key events in askOk dialogs."""
    self.okButton()
    return # (for Tk) "break"
.. @+node:ekr.20170624151245.265: *9* run
def run(self):
    """Run the modal emergency dialog."""
    self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
    self.top.lift()
    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
.. @+node:ekr.20170624151245.260: *9* __init__ (emergencyDialog)
def __init__(self, title, message):
    """Constructor for the leoTkinterDialog class."""
    self.answer = None # Value returned from run()
    self.title = title
    self.message = message
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.
    self.createTopFrame()
    buttons = {"text": "OK", "command": self.okButton, "default": True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
.. @+node:ekr.20170624151245.261: *9* createButtons
def createButtons(self, buttons):
    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top", padx=30)
    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text", "<missing button name>")
        isDefault = d.get("default", False)
        underline = d.get("underline", 0)
        command = d.get("command", None)
        bd = 4 if isDefault else 2
        b = Tk.Button(f, width=6, text=text, bd=bd,
            underline=underline, command=command)
        b.pack(side="left", padx=5, pady=10)
        buttonList.append(b)
        if isDefault and command:
            self.defaultButtonCommand = command
    return buttonList
.. @+node:ekr.20170624151245.262: *9* createTopFrame
def createTopFrame(self):
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=message, bg='white')
    label.pack(pady=10)
.. @+node:ekr.20170624151245.263: *9* okButton
def okButton(self):
    """Do default click action in ok button."""
    self.top.destroy()
    self.top = None
.. @+node:ekr.20170624151245.264: *9* onKey
def onKey(self, event):
    """Handle Key events in askOk dialogs."""
    self.okButton()
    return # (for Tk) "break"
.. @+node:ekr.20170624151245.265: *9* run
def run(self):
    """Run the modal emergency dialog."""
    self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
    self.top.lift()
    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
.. @+node:ekr.20170624151245.253: *8* << define emergency dialog class >>
class EmergencyDialog(object):
    """A class that creates an Tkinter dialog with a single OK button."""
    @others
.. @+node:ekr.20170624151245.260: *9* __init__ (emergencyDialog)
def __init__(self, title, message):
    """Constructor for the leoTkinterDialog class."""
    self.answer = None # Value returned from run()
    self.title = title
    self.message = message
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.
    self.createTopFrame()
    buttons = {"text": "OK", "command": self.okButton, "default": True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
.. @+node:ekr.20170624151245.261: *9* createButtons
def createButtons(self, buttons):
    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top", padx=30)
    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text", "<missing button name>")
        isDefault = d.get("default", False)
        underline = d.get("underline", 0)
        command = d.get("command", None)
        bd = 4 if isDefault else 2
        b = Tk.Button(f, width=6, text=text, bd=bd,
            underline=underline, command=command)
        b.pack(side="left", padx=5, pady=10)
        buttonList.append(b)
        if isDefault and command:
            self.defaultButtonCommand = command
    return buttonList
.. @+node:ekr.20170624151245.262: *9* createTopFrame
def createTopFrame(self):
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=message, bg='white')
    label.pack(pady=10)
.. @+node:ekr.20170624151245.263: *9* okButton
def okButton(self):
    """Do default click action in ok button."""
    self.top.destroy()
    self.top = None
.. @+node:ekr.20170624151245.264: *9* onKey
def onKey(self, event):
    """Handle Key events in askOk dialogs."""
    self.okButton()
    return # (for Tk) "break"
.. @+node:ekr.20170624151245.265: *9* run
def run(self):
    """Run the modal emergency dialog."""
    self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
    self.top.lift()
    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
.. @+node:ekr.20170624151245.260: *9* __init__ (emergencyDialog)
def __init__(self, title, message):
    """Constructor for the leoTkinterDialog class."""
    self.answer = None # Value returned from run()
    self.title = title
    self.message = message
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.
    self.createTopFrame()
    buttons = {"text": "OK", "command": self.okButton, "default": True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
.. @+node:ekr.20170624151245.261: *9* createButtons
def createButtons(self, buttons):
    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top", padx=30)
    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text", "<missing button name>")
        isDefault = d.get("default", False)
        underline = d.get("underline", 0)
        command = d.get("command", None)
        bd = 4 if isDefault else 2
        b = Tk.Button(f, width=6, text=text, bd=bd,
            underline=underline, command=command)
        b.pack(side="left", padx=5, pady=10)
        buttonList.append(b)
        if isDefault and command:
            self.defaultButtonCommand = command
    return buttonList
.. @+node:ekr.20170624151245.262: *9* createTopFrame
def createTopFrame(self):
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=message, bg='white')
    label.pack(pady=10)
.. @+node:ekr.20170624151245.263: *9* okButton
def okButton(self):
    """Do default click action in ok button."""
    self.top.destroy()
    self.top = None
.. @+node:ekr.20170624151245.264: *9* onKey
def onKey(self, event):
    """Handle Key events in askOk dialogs."""
    self.okButton()
    return # (for Tk) "break"
.. @+node:ekr.20170624151245.265: *9* run
def run(self):
    """Run the modal emergency dialog."""
    self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
    self.top.lift()
    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
.. @+node:ekr.20170624151245.266: *7* LM.loadLocalFile & helper
def loadLocalFile(self, fn, gui, old_c):
    '''Completely read a file, creating the corresonding outline.

    1. If fn is an existing .leo file (possibly zipped), read it twice:
    the first time with a NullGui to discover settings,
    the second time with the requested gui to create the outline.

    2. If fn is an external file:
    get settings from the leoSettings.leo and myLeoSetting.leo, then
    create a "wrapper" outline continain an @file node for the external file.

    3. If fn is empty:
    get settings from the leoSettings.leo and myLeoSetting.leo or default settings,
    or open an empty outline.
    '''
    trace = (False or g.trace_startup or g.app.debug) and not g.unitTesting
    if trace: g.es_debug(fn)
    lm = self
    # Step 0: Return if the file is already open.
    fn = g.os_path_finalize(fn)
    if fn:
        c = lm.findOpenFile(fn)
        if c:
            if trace: g.trace('Already open: %s' % (fn))
            return c
    # Step 1: get the previous settings.
    # For .leo files (and zipped .leo files) this pre-reads the file in a null gui.
    # Otherwise, get settings from leoSettings.leo, myLeoSettings.leo, or default settings.
    previousSettings = lm.getPreviousSettings(fn)
    # Step 2: open the outline in the requested gui.
    # For .leo files (and zipped .leo file) this opens the file a second time.
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
    return c
.. @+node:ekr.20170624151245.286: *8* LM.openFileByName & helpers
def openFileByName(self, fn, gui, old_c, previousSettings):
    '''Read the local file whose full path is fn using the given gui.
    fn may be a Leo file (including .leo or zipped file) or an external file.

    This is not a pre-read: the previousSettings always exist and
    the commander created here persists until the user closes the outline.

    Reads the entire outline if fn exists and is a .leo file or zipped file.
    Creates an empty outline if fn is a non-existent Leo file.
    Creates an wrapper outline if fn is an external file, existing or not.
    '''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug(g.shortFileName(fn))
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    # Important.  The settings don't matter for pre-reads!
    # For second read, the settings for the file are *exactly* previousSettings.
    c = g.app.newCommander(fileName=fn, gui=gui,
        previousSettings=previousSettings)
    assert c
    # Open the file, if possible.
    g.doHook('open0')
    theFile = lm.openLeoOrZipFile(fn)
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Phase 2: Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        readAtFileNodesFlag = bool(previousSettings)
        # The log is not set properly here.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
            # Call c.fileCommands.openLeoFile to read the .leo file.
        if not ok: return None
    else:
        # Create a wrapper .leo file if:
        # a) fn is a .leo file that does not exist or
        # b) fn is an external file, existing or not.
        lm.initWrapperLeoFile(c, fn)
    g.doHook("open2", old_c=None, c=c, new_c=c, fileName=fn)
    # Phase 3: Complete the initialization.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
.. @+node:ekr.20170624151245.296: *9* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
        c.enableMenuBar()
.. @+node:ekr.20170624151245.297: *9* LM.findOpenFile
def findOpenFile(self, fn):
    # lm = self

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # don't frame.bringToFront(), it breaks --minimize
            c.setLog()
            # 2011/11/21: selecting the new tab ensures focus is set.
            master = hasattr(frame.top, 'leo_master') and frame.top.leo_master
            if master: # frame.top.leo_master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
.. @+node:ekr.20170624151245.298: *9* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # Honor focus requests.
        # This fixes bug 181: Focus remains in previous file
        # https://github.com/leo-editor/leo-editor/issues/181
.. @+node:ekr.20170624151245.299: *9* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    '''
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    '''
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None) # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString('%s %s' % (load_type,fn))
            c.refreshFromDisk()
            c.selectPosition(p)
                
    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else '%s.leo' % (fn)
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.setChanged(False)
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
.. @+node:ekr.20170624151245.300: *9* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (zipfile.is_zipfile(fn) or fn.endswith('.leo'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
.. @+node:ekr.20170624151245.301: *9* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
.. @+node:ekr.20170624151245.302: *9* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.303: *9* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        if g.isPython3: s = g.ue(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.304: *9* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = c.os_path_finalize(g.os_path_dirname(fn))
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=self.more_cmdline_files is False)
    return ok
.. @+node:ekr.20170624151245.296: *9* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
        c.enableMenuBar()
.. @+node:ekr.20170624151245.297: *9* LM.findOpenFile
def findOpenFile(self, fn):
    # lm = self

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # don't frame.bringToFront(), it breaks --minimize
            c.setLog()
            # 2011/11/21: selecting the new tab ensures focus is set.
            master = hasattr(frame.top, 'leo_master') and frame.top.leo_master
            if master: # frame.top.leo_master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
.. @+node:ekr.20170624151245.298: *9* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # Honor focus requests.
        # This fixes bug 181: Focus remains in previous file
        # https://github.com/leo-editor/leo-editor/issues/181
.. @+node:ekr.20170624151245.299: *9* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    '''
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    '''
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None) # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString('%s %s' % (load_type,fn))
            c.refreshFromDisk()
            c.selectPosition(p)
                
    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else '%s.leo' % (fn)
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.setChanged(False)
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
.. @+node:ekr.20170624151245.300: *9* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (zipfile.is_zipfile(fn) or fn.endswith('.leo'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
.. @+node:ekr.20170624151245.301: *9* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
.. @+node:ekr.20170624151245.302: *9* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.303: *9* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        if g.isPython3: s = g.ue(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.304: *9* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = c.os_path_finalize(g.os_path_dirname(fn))
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=self.more_cmdline_files is False)
    return ok
.. @+node:ekr.20170624151245.286: *8* LM.openFileByName & helpers
def openFileByName(self, fn, gui, old_c, previousSettings):
    '''Read the local file whose full path is fn using the given gui.
    fn may be a Leo file (including .leo or zipped file) or an external file.

    This is not a pre-read: the previousSettings always exist and
    the commander created here persists until the user closes the outline.

    Reads the entire outline if fn exists and is a .leo file or zipped file.
    Creates an empty outline if fn is a non-existent Leo file.
    Creates an wrapper outline if fn is an external file, existing or not.
    '''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug(g.shortFileName(fn))
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    # Important.  The settings don't matter for pre-reads!
    # For second read, the settings for the file are *exactly* previousSettings.
    c = g.app.newCommander(fileName=fn, gui=gui,
        previousSettings=previousSettings)
    assert c
    # Open the file, if possible.
    g.doHook('open0')
    theFile = lm.openLeoOrZipFile(fn)
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Phase 2: Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        readAtFileNodesFlag = bool(previousSettings)
        # The log is not set properly here.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
            # Call c.fileCommands.openLeoFile to read the .leo file.
        if not ok: return None
    else:
        # Create a wrapper .leo file if:
        # a) fn is a .leo file that does not exist or
        # b) fn is an external file, existing or not.
        lm.initWrapperLeoFile(c, fn)
    g.doHook("open2", old_c=None, c=c, new_c=c, fileName=fn)
    # Phase 3: Complete the initialization.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
.. @+node:ekr.20170624151245.296: *9* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
        c.enableMenuBar()
.. @+node:ekr.20170624151245.297: *9* LM.findOpenFile
def findOpenFile(self, fn):
    # lm = self

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # don't frame.bringToFront(), it breaks --minimize
            c.setLog()
            # 2011/11/21: selecting the new tab ensures focus is set.
            master = hasattr(frame.top, 'leo_master') and frame.top.leo_master
            if master: # frame.top.leo_master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
.. @+node:ekr.20170624151245.298: *9* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # Honor focus requests.
        # This fixes bug 181: Focus remains in previous file
        # https://github.com/leo-editor/leo-editor/issues/181
.. @+node:ekr.20170624151245.299: *9* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    '''
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    '''
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None) # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString('%s %s' % (load_type,fn))
            c.refreshFromDisk()
            c.selectPosition(p)
                
    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else '%s.leo' % (fn)
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.setChanged(False)
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
.. @+node:ekr.20170624151245.300: *9* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (zipfile.is_zipfile(fn) or fn.endswith('.leo'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
.. @+node:ekr.20170624151245.301: *9* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
.. @+node:ekr.20170624151245.302: *9* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.303: *9* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        if g.isPython3: s = g.ue(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.304: *9* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = c.os_path_finalize(g.os_path_dirname(fn))
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=self.more_cmdline_files is False)
    return ok
.. @+node:ekr.20170624151245.296: *9* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
        c.enableMenuBar()
.. @+node:ekr.20170624151245.297: *9* LM.findOpenFile
def findOpenFile(self, fn):
    # lm = self

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # don't frame.bringToFront(), it breaks --minimize
            c.setLog()
            # 2011/11/21: selecting the new tab ensures focus is set.
            master = hasattr(frame.top, 'leo_master') and frame.top.leo_master
            if master: # frame.top.leo_master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
.. @+node:ekr.20170624151245.298: *9* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # Honor focus requests.
        # This fixes bug 181: Focus remains in previous file
        # https://github.com/leo-editor/leo-editor/issues/181
.. @+node:ekr.20170624151245.299: *9* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    '''
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    '''
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None) # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString('%s %s' % (load_type,fn))
            c.refreshFromDisk()
            c.selectPosition(p)
                
    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else '%s.leo' % (fn)
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.setChanged(False)
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
.. @+node:ekr.20170624151245.300: *9* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (zipfile.is_zipfile(fn) or fn.endswith('.leo'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
.. @+node:ekr.20170624151245.301: *9* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
.. @+node:ekr.20170624151245.302: *9* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.303: *9* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        if g.isPython3: s = g.ue(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
.. @+node:ekr.20170624151245.304: *9* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = c.os_path_finalize(g.os_path_dirname(fn))
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=self.more_cmdline_files is False)
    return ok
.. @+node:ekr.20170624151245.305: *5* Terry's diff code
"""
Select two nodes - click the first then ctrl-click the second.  Then run
this code.  It ignores differences in the two top nodes, but recursively
lists differences in their descendant trees.

The result tree is tagged with @bookmarks and has UNL links to the different
nodes so double clicking nodes in the result tree jumps you to the original
nodes.

A bug seems to be %20 escaping the text of differing nodes.
"""
from leo.core.leoNodes import vnode

pos0, pos1 = c.getSelectedPositions()[:2]
vf = pos0.v
vt = pos1.v
nd = c.rootPosition().insertAfter()
nd.copy().back().moveAfter(nd)
nd.h = 'diff @bookmarks'
@others
parent = c.vnode2position(vt).parent()
path = []
while parent:
    path = [parent.h] + path
    parent = parent.parent()
path = ['TOP'] + path
v = diff_trees(vf, vt, path)
if v:
    nd.v.children.extend(v.children)  # snip off <hidden root node>
c.bringToFront()
c.redraw()
.. @+node:ekr.20170624151245.306: *6* text_match & gnx_match
def text_match(a, b):
    return (a.h == b.h, 
            a.h == b.h and a.b == b.b)

def text_match(a, b):
    return (a.h == b.h, 
            a.h == b.h and ' '.join(a.b.split()) == ' '.join(b.b.split()))

def gnx_match(a, b):
    return (a.h == b.h and a.gnx == b.gnx, 
            a.h == b.h and a.b == b.b and a.gnx == b.gnx)
.. @+node:ekr.20170624151245.307: *6* diff_trees
def diff_trees(vf, vt, path):
    fonly = []  # nodes only in from tree
    tonly = []  # nodes only in to tree
    diffs = []  # nodes which occur in both but have different descendants
    # count number of times each headline occurs as a child of
    # each node being compared
    count_f = {}
    for cf in vf.children:
        count_f[cf.h] = count_f.get(cf.h, 0) + 1
    count_t = {}
    for ct in vt.children:
        count_t[ct.h] = count_t.get(ct.h, 0) + 1
    for cf in vf.children:
        for ct in vt.children:
            if count_f[cf.h] == 1 and count_t[ct.h] == 1:
                equal = text_match
            else:
                equal = gnx_match
            head_eq, body_eq = equal(cf, ct)
            if body_eq:
                diffs.append(diff_trees(cf, ct, path+[vf.h]))
                break
            elif head_eq:
                d = diff_trees(cf, ct, path+[vf.h])
                if d:
                    d.h = '!v '+d.h
                else:
                    d = vnode(nd.v.context)
                    d.h = '!v '+cf.h
                d.b = "#%s\n\n%s" % (
                    '-->'.join((path+[vf.h]+[cf.h])[1:]),
                    cf.b
                )
                diffs.append(d)
                d = vnode(nd.v.context)
                d.h = '!^ '+cf.h
                d.b = "#%s\n\n%s" % (
                    '-->'.join((path+[vt.h]+[ct.h])[1:]),
                    ct.b
                )
                d.b = d.b.replace(' ', '%20')
                diffs.append(d)
                break
        else:
            fonly.append(cf)
    for ct in vt.children:
        for cf in vf.children:
            if count_f[cf.h] == 1 and count_t[ct.h] == 1:
                equal = text_match
            else:
                equal = gnx_match
            head_eq, body_eq = equal(cf, ct)
            if head_eq or body_eq:
                # no need to recurse matches again
                break
        else:
            tonly.append(ct)
    if not any(diffs) and not fonly and not tonly:
        return None
    vd = vnode(nd.v.context)
    vd.h = vf.h
    for d in diffs:
        if d:
            vd.children.append(d)
    for f in fonly:
        n = vd.insertAsLastChild()
        n.h = '- '+f.h
        n.b = "#%s" % ('-->'.join((path+[vf.h]+[f.h])[1:]))
        n.b = n.b.replace(' ', '%20')
    for t in tonly:
        n = vd.insertAsLastChild()
        n.h = '+ '+t.h
        n.b = "#%s" % ('-->'.join((path+[vf.h]+[t.h])[1:]))
        n.b = n.b.replace(' ', '%20')
    return vd
.. @+node:ekr.20170624151245.308: *4* ----- re #488: create a curses gui plugin
https://github.com/leo-editor/leo-editor/issues/488

Without redraws: 34.5 sec.
With redraws: 58.7 sec.
.. @+node:ekr.20170624151245.309: *5*  ---- npyscreen
.. @+node:ekr.20170624151245.310: *6* @@file ../external/npyscreen/fm_form_edit_loop.py
#!/usr/bin/env python
# encoding: utf-8
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.311: *7* Declarations
"""
form_edit_loop.py

Created by Nicholas Cole on 2008-03-31.
Copyright (c) 2008 __MyCompanyName__. All rights reserved.
"""

# import sys
# import os
import weakref

.. @+node:ekr.20170624151245.312: *7* class FormNewEditLoop
class FormNewEditLoop(object):
    "Edit Fields .editing = False"
    @others
.. @+node:ekr.20170624151245.313: *8* pre_edit_loop
def pre_edit_loop(self):
    pass
.. @+node:ekr.20170624151245.314: *8* post_edit_loop
def post_edit_loop(self):
    pass
.. @+node:ekr.20170624151245.315: *8* _during_edit_loop
def _during_edit_loop(self):
    pass

.. @+node:ekr.20170624151245.316: *8* FormNewEditLoop.edit_loop
def edit_loop(self):
    
    # g.trace('FormNewEditLoop')
    self.editing = True
    self.display()
    while not (self._widgets__[self.editw].editable and not self._widgets__[self.editw].hidden):
        self.editw += 1
        if self.editw > len(self._widgets__)-1: 
            self.editing = False
            return False
    
    while self.editing:
        if not self.ALL_SHOWN: self.on_screen()
        self.while_editing(weakref.proxy(self._widgets__[self.editw]))
        self._during_edit_loop()
        if not self.editing:
            break
        self._widgets__[self.editw].edit()
        self._widgets__[self.editw].display()

        self.handle_exiting_widgets(self._widgets__[self.editw].how_exited)

        if self.editw > len(self._widgets__)-1: self.editw = len(self._widgets__)-1
    
.. @+node:ekr.20170624151245.317: *8* edit
def edit(self):
    self.pre_edit_loop()
    self.edit_loop()
    self.post_edit_loop()

.. @+node:ekr.20170624151245.318: *7* class FormDefaultEditLoop
class FormDefaultEditLoop(object):
    @others
.. @+node:ekr.20170624151245.319: *8* FormDefaultEditLoop.edit
def edit(self):
    """Edit the fields until the user selects the ok button added in the lower right corner. Button will
    be removed when editing finishes"""
    
    # g.trace('FormDefaultEditLoop')
    # Add ok button. Will remove later
    tmp_rely, tmp_relx = self.nextrely, self.nextrelx
    my, mx = self.curses_pad.getmaxyx()
    ok_button_text = self.__class__.OK_BUTTON_TEXT
    my -= self.__class__.OK_BUTTON_BR_OFFSET[0]
    mx -= len(ok_button_text)+self.__class__.OK_BUTTON_BR_OFFSET[1]
    self.ok_button = self.add_widget(self.__class__.OKBUTTON_TYPE, name=ok_button_text, rely=my, relx=mx, use_max_space=True)
    ok_button_postion = len(self._widgets__)-1
    self.ok_button.update()
    # End add buttons 
    self.editing=True
    if self.editw < 0: self.editw=0
    if self.editw > len(self._widgets__)-1:
        self.editw = len(self._widgets__)-1
    if not self.preserve_selected_widget:
        self.editw = 0
    if not self._widgets__[self.editw].editable: self.find_next_editable()


    self.display()

    while not (self._widgets__[self.editw].editable and not self._widgets__[self.editw].hidden):
        self.editw += 1
        if self.editw > len(self._widgets__)-1: 
            self.editing = False
            return False

    while self.editing:
        if not self.ALL_SHOWN: self.on_screen()
        self.while_editing(weakref.proxy(self._widgets__[self.editw]))
        if not self.editing:
            break
        self._widgets__[self.editw].edit()
        self._widgets__[self.editw].display()

        self.handle_exiting_widgets(self._widgets__[self.editw].how_exited)

        if self.editw > len(self._widgets__)-1: self.editw = len(self._widgets__)-1
        if self.ok_button.value:
            self.editing = False

    self.ok_button.destroy()
    del self._widgets__[ok_button_postion]
    del self.ok_button
    self.nextrely, self.nextrelx = tmp_rely, tmp_relx
    self.display()
    
    #try:
    #    self.parentApp._FORM_VISIT_LIST.pop()
    #except Exception:
    #    pass
    

    self.editing = False
    self.erase()

.. @+node:ekr.20170624151245.320: *8* move_ok_button
def move_ok_button(self):
    if hasattr(self, 'ok_button'):
        my, mx = self.curses_pad.getmaxyx()
        my -= self.__class__.OK_BUTTON_BR_OFFSET[0]
        mx -= len(self.__class__.OK_BUTTON_TEXT)+self.__class__.OK_BUTTON_BR_OFFSET[1]
        self.ok_button.relx = mx
        self.ok_button.rely = my



.. @+node:ekr.20170624151245.321: *6* @file ../external/npyscreen/__init__.py
#!/usr/bin/python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.322: *7* Declarations
from .globals                   import DEBUG, DISABLE_RESIZE_SYSTEM

from .wgwidget                  import TEST_SETTINGS, ExhaustedTestInput, add_test_input_from_iterable, add_test_input_ch

from .npyssafewrapper           import wrapper, wrapper_basic

from   .npysThemeManagers       import ThemeManager, disableColor, enableColor
from   . import npysThemes      as     Themes 
from   .apNPSApplication        import NPSApp
from   .apNPSApplicationManaged import NPSAppManaged
from   .proto_fm_screen_area    import setTheme
from   .fmForm                  import FormBaseNew, Form, TitleForm, TitleFooterForm, SplitForm, FormExpanded, FormBaseNewExpanded, blank_terminal
from   .fmActionForm            import ActionForm, ActionFormExpanded
from   .fmActionFormV2          import ActionFormV2, ActionFormExpandedV2, ActionFormMinimal
from   .fmFormWithMenus         import FormWithMenus, ActionFormWithMenus, \
                                       FormBaseNewWithMenus, SplitFormWithMenus, \
                                       ActionFormV2WithMenus
from   .fmPopup                 import Popup, MessagePopup, ActionPopup, PopupWide, ActionPopupWide
from   .fmFormMutt              import FormMutt, FormMuttWithMenus
from   .fmFileSelector          import FileSelector, selectFile

from .fmFormMuttActive          import ActionControllerSimple, TextCommandBox, \
                                       FormMuttActive, FormMuttActiveWithMenus
from .fmFormMuttActive          import FormMuttActiveTraditional, FormMuttActiveTraditionalWithMenus


from .fmFormMultiPage           import FormMultiPage, FormMultiPageAction,\
                                       FormMultiPageActionWithMenus, FormMultiPageWithMenus

from .npysNPSFilteredData       import NPSFilteredDataBase, NPSFilteredDataList

from .wgbutton                  import MiniButton
from .wgbutton                  import MiniButtonPress
from .wgbutton                  import MiniButton      as Button
from .wgbutton                  import MiniButtonPress as ButtonPress

from .wgtextbox                 import Textfield, FixedText
from .wgtitlefield              import TitleText, TitleFixedText
from .wgpassword                import PasswordEntry, TitlePassword
from .wgannotatetextbox         import AnnotateTextboxBase
from .wgannotatetextbox         import AnnotateTextboxBaseRight

from .wgslider                  import Slider, TitleSlider
from .wgslider                  import SliderNoLabel, TitleSliderNoLabel
from .wgslider                  import SliderPercent, TitleSliderPercent

from .wgwidget                  import DummyWidget, NotEnoughSpaceForWidget
from . import wgwidget as widget

from .wgmultiline               import MultiLine, Pager, TitleMultiLine, TitlePager, MultiLineAction, BufferPager, TitleBufferPager
from .wgmultiselect             import MultiSelect, TitleMultiSelect, MultiSelectFixed, \
                                       TitleMultiSelectFixed, MultiSelectAction
from .wgeditmultiline           import MultiLineEdit
from .wgcombobox                import ComboBox, TitleCombo
from .wgcheckbox                import Checkbox, RoundCheckBox, CheckBoxMultiline, RoundCheckBoxMultiline, CheckBox, CheckboxBare
from .wgFormControlCheckbox     import FormControlCheckbox
from .wgautocomplete            import TitleFilename, Filename, Autocomplete
from .muMenu                    import Menu
from .wgselectone               import SelectOne, TitleSelectOne
from .wgdatecombo               import DateCombo, TitleDateCombo

from .npysTree import TreeData
from .wgmultilinetree           import MLTree, MLTreeAnnotated, MLTreeAction, MLTreeAnnotatedAction
from .wgmultilinetreeselectable import MLTreeMultiSelect, TreeLineSelectable
from .wgmultilinetreeselectable import MLTreeMultiSelectAnnotated, TreeLineSelectableAnnotated


# The following are maintained for compatibility with old code only. ##########################################

from .compatibility_code.oldtreeclasses import MultiLineTree, SelectOneTree
from .compatibility_code.oldtreeclasses import MultiLineTreeNew, MultiLineTreeNewAction, TreeLine, TreeLineAnnotated # Experimental
from .compatibility_code.oldtreeclasses import MultiLineTreeNewAnnotatedAction, MultiLineTreeNewAnnotated # Experimental
from .compatibility_code.npysNPSTree import NPSTreeData

# End compatibility. ###########################################################################################

from .wgfilenamecombo           import FilenameCombo, TitleFilenameCombo
from .wgboxwidget               import BoxBasic, BoxTitle
from .wgmultiline               import MultiLineActionWithShortcuts
from .wgmultilineeditable       import MultiLineEditable, MultiLineEditableTitle, MultiLineEditableBoxed

from .wgmonthbox                import MonthBox
from .wggrid                    import SimpleGrid
from .wggridcoltitles           import GridColTitles

from .muNewMenu                 import NewMenu, MenuItem
from .wgNMenuDisplay            import MenuDisplay, MenuDisplayScreen

from .npyspmfuncs               import CallSubShell

from .utilNotify                 import notify, notify_confirm, notify_wait, notify_ok_cancel, notify_yes_no

# Base classes for overriding:

# Standard Forms:
from . import stdfmemail

# Experimental Only
from .wgtextboxunicode import TextfieldUnicode
from .wgtexttokens     import TextTokens, TitleTextTokens

# Very experimental. Don't use for anything serious
from .apOptions import SimpleOptionForm
from .apOptions import OptionListDisplay, OptionChanger, OptionList, OptionLimitedChoices, OptionListDisplayLine
from .apOptions import OptionFreeText, OptionSingleChoice, OptionMultiChoice, OptionMultiFreeList, \
                       OptionBoolean, OptionFilename, OptionDate, OptionMultiFreeText


# This really is about as experimental as it gets
from .apNPSApplicationEvents import StandardApp
from .eveventhandler import Event


.. @+node:ekr.20170624151245.323: *6* @file ../external/npyscreen/apNPSApplication.py
#!/usr/bin/env python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.324: *7* Declarations
import curses
# import locale
# import _curses

from . import npyssafewrapper


.. @+node:ekr.20170624151245.325: *7* class AlreadyOver
class AlreadyOver(Exception):
    pass

.. @+node:ekr.20170624151245.326: *7* class NPSApp
class NPSApp(object):
    _run_called = 0
    @others
.. @+node:ekr.20170624151245.327: *8* main
def main(self):
    """Overload this method to create your application"""

.. @+node:ekr.20170624151245.328: *8* resize
def resize(self):
    pass

.. @+node:ekr.20170624151245.329: *8* __remove_argument_call_main
def __remove_argument_call_main(self, screen, enable_mouse=True):
    # screen disgarded.
    if enable_mouse:
        curses.mousemask(curses.ALL_MOUSE_EVENTS)
    del screen
    return self.main()

.. @+node:ekr.20170624151245.330: *8* run
def run(self, fork=None):
    """Run application.  Calls Mainloop wrapped properly."""
    if fork is None:
        return npyssafewrapper.wrapper(self.__remove_argument_call_main)
    else:
        return npyssafewrapper.wrapper(self.__remove_argument_call_main, fork=fork)
.. @+node:ekr.20170624151245.331: *6* @file ../external/npyscreen/apNPSApplicationAdvanced.py
#!/usr/bin/env python
# encoding: utf-8
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.332: *7* Declarations
from . import apNPSApplicationManaged
# from . import fmForm
# import weakref

.. @+node:ekr.20170624151245.333: *7* class NPSAppAdvanced
class NPSAppAdvanced(apNPSApplicationManaged.NPSAppManaged):
    """EXPERIMENTAL and NOT for use.  This class of application will eventually replace the 
    standard method of user input handling and deal with everything at the application level."""
    
    @others
.. @+node:ekr.20170624151245.334: *8* _main_loop
def _main_loop(self):
    pass
.. @+node:ekr.20170624151245.335: *6* @file ../external/npyscreen/apNPSApplicationEvents.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.336: *7* Declarations
import collections
import weakref
from .apNPSApplicationManaged import NPSAppManaged
from .eveventhandler import EventHandler

.. @+node:ekr.20170624151245.337: *7* class NPSEventQueue
class NPSEventQueue(object):
    @others
.. @+node:ekr.20170624151245.338: *8* __init__
def __init__(self):
    self.interal_queue = collections.deque()

.. @+node:ekr.20170624151245.339: *8* get
def get(self, maximum=None):
    if maximum is None:
        maximum = -1
    counter = 1
    while counter != maximum:
        try:
            yield self.interal_queue.pop()
        except IndexError:
            raise StopIteration
        counter += 1

.. @+node:ekr.20170624151245.340: *8* put
def put(self, event):
    self.interal_queue.append(event)
    
.. @+node:ekr.20170624151245.341: *7* class StandardApp
class StandardApp(NPSAppManaged, EventHandler):
    MAINQUEUE_TYPE = NPSEventQueue
    keypress_timeout_default = 2
    max_events_per_queue = 50
    """This class adds event queue functionality to the existing NPSAppManaged.  The name reflects the fact that future applications
    are expected to use this class as standard.  However, it is currently an experimental class.  The API is unlikely to change, but
    no promises are made at this time.
    """
    @others
.. @+node:ekr.20170624151245.342: *8* __init__
def __init__(self):
    super(StandardApp, self).__init__()
    self.event_directory = {}
    self.event_queues = {}
    self.initalize_application_event_queues()
    self.initialize_event_handling()

.. @+node:ekr.20170624151245.343: *8* _internal_while_waiting
def _internal_while_waiting(self):
    # Parent NPSAppManaged does not define this, so no need to call.
    self.process_event_queues(max_events_per_queue=self.max_events_per_queue)

    
.. @+node:ekr.20170624151245.344: *8* initalize_application_event_queues
def initalize_application_event_queues(self):
    # in the standard application the event queue is not threaded so...
    main_queue = self.MAINQUEUE_TYPE()
    self.event_queues['MAINQUEUE'] = main_queue

.. @+node:ekr.20170624151245.345: *8* process_event_queues
def process_event_queues(self, max_events_per_queue=None):
    for queue in self.event_queues.values():
        for event in queue.get(maximum=max_events_per_queue):
            self.process_event(event)

.. @+node:ekr.20170624151245.346: *8* register_for_event
def register_for_event(self, registering_object, event_name):
    if event_name not in self.event_directory:
        self.event_directory[event_name] = weakref.WeakSet()
    self.event_directory[event_name].add(registering_object)
    
.. @+node:ekr.20170624151245.347: *8* queue_event
def queue_event(self, event, queue='MAINQUEUE'):
    self.event_queues[queue].put(event)
    
.. @+node:ekr.20170624151245.348: *8* process_event
def process_event(self, event):
    discard_list = []
    if event.name not in self.event_directory:
        return True
    if not self.event_directory[event.name]:
        del self.event_directory[event.name]
        return True
    for registered_object in self.event_directory[event.name]:
        result = registered_object.handle_event(event)
        if result is False:
            discard_list.append(registered_object)
            
    for registered_object in discard_list:
        self.event_directory[event.name].discard(registered_object)
.. @+node:ekr.20170624151245.349: *6* @file ../external/npyscreen/apNPSApplicationManaged.py
#!/usr/bin/env python
# encoding: utf-8
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.350: *7* Declarations
"""
NPSAppManaged.py
"""
from . import apNPSApplication
# from . import fmForm
import weakref

.. @+node:ekr.20170624151245.351: *7* class NPSAppManaged
class NPSAppManaged(apNPSApplication.NPSApp):
    """This class is intended to make it easier to program applications with many screens:
    
    1. The programmer should not now select which 'Form' to display himself.  Instead, he should set the NEXT_ACTIVE_FORM class variable.  
       See the registerForm method for details.
       
       Doing this will avoid accidentally exceeding the maximum recursion depth.  Forms themselves should be placed under the management
       of the class using the 'addForm' or 'addFormClass' method.
       
       NB.  * Applications should therefore use this mechanism in preference to calling the .edit() method of any form. *
       
    2. Forms that are managed by this class can access a proxy to the parent application through their ".parentApp" attribute, which is
       created by this class.
       
    3. a Optionally, Forms managed by this class may be given an .activate method, which will be called instead of their .edit loop
       
       b If not given an .activate method, any .afterEditing method which a form possesses will be called after .edit() has exited.  
         3b is the preferred method to change NEXT_ACTIVE_FORM
         
    4. The method onInMainLoop is called after each screen has exited. This can be overridden. 
    
    5. This method should be able to see which screen was last active using the self._LAST_NEXT_ACTIVE_FORM attribute, which is only set
       just before each screen is displayed.
       
    6. Unless you override the attribute STARTING_FORM, the first form to be called should be named 'MAIN'
    
    7. Do override the onStart and onCleanExit functions if you wish.
    
    """

    STARTING_FORM = "MAIN"

    @others
.. @+node:ekr.20170624151245.352: *8* __init__
def __init__(self):
    super(NPSAppManaged, self).__init__()    
    self._FORM_VISIT_LIST = []
    self.NEXT_ACTIVE_FORM = self.__class__.STARTING_FORM
    self._LAST_NEXT_ACTIVE_FORM = None
    self._Forms = {}

.. @+node:ekr.20170624151245.353: *8* addFormClass
def addFormClass(self, f_id, FormClass, *args, **keywords):
    self._Forms[f_id] = [FormClass, args, keywords]

.. @+node:ekr.20170624151245.354: *8* addForm
def addForm(self, f_id, FormClass, *args, **keywords):
    """Create a form of the given class. f_id should be a string which will uniquely identify the form. *args will be passed to the Form constructor.
    Forms created in this way are handled entirely by the NPSAppManaged class."""
    fm = FormClass( parentApp=self, *args, **keywords)
    self.registerForm(f_id, fm)
    return weakref.proxy(fm)
    
.. @+node:ekr.20170624151245.355: *8* registerForm
def registerForm(self, f_id, fm):
    """f_id should be a string which should uniquely identify the form.  fm should be a Form."""
    fm.parentApp = weakref.proxy(self)
    self._Forms[f_id] = fm
    
.. @+node:ekr.20170624151245.356: *8* removeForm
def removeForm(self, f_id):
    del self._Forms[f_id].parentApp
    del self._Forms[f_id]

.. @+node:ekr.20170624151245.357: *8* getForm
def getForm(self, name):
    f = self._Forms[name]
    try:
        return weakref.proxy(f)
    except Exception:
        return f

.. @+node:ekr.20170624151245.358: *8* setNextForm
def setNextForm(self, fmid):
    """Set the form that will be selected when the current one exits."""
    self.NEXT_ACTIVE_FORM = fmid

.. @+node:ekr.20170624151245.359: *8* switchForm
def switchForm(self, fmid):
    """Immediately switch to the form specified by fmid."""
    self._THISFORM.editing = False
    self.setNextForm(fmid)
    self.switchFormNow()
    
.. @+node:ekr.20170624151245.360: *8* switchFormNow
def switchFormNow(self):
    self._THISFORM.editing = False
    try:
        self._THISFORM._widgets__[self._THISFORM.editw].editing = False
    except (AttributeError, IndexError):
        pass
    # Following is necessary to stop two keypresses being needed for titlefields
    try:
        self._THISFORM._widgets__[self._THISFORM.editw].entry_widget.editing = False
    except (AttributeError, IndexError):
        pass

.. @+node:ekr.20170624151245.361: *8* removeLastFormFromHistory
def removeLastFormFromHistory(self):
    self._FORM_VISIT_LIST.pop()
    self._FORM_VISIT_LIST.pop()
        
.. @+node:ekr.20170624151245.362: *8* switchFormPrevious
def switchFormPrevious(self, backup=STARTING_FORM):
    self.setNextFormPrevious()
    self.switchFormNow()
    
.. @+node:ekr.20170624151245.363: *8* setNextFormPrevious
def setNextFormPrevious(self, backup=STARTING_FORM):
    try:
        if self._THISFORM.FORM_NAME == self._FORM_VISIT_LIST[-1]:
            self._FORM_VISIT_LIST.pop() # Remove the current form. if it is at the end of the list
        if self._THISFORM.FORM_NAME == self.NEXT_ACTIVE_FORM:
            #take no action if it looks as if someone has already set the next form.
            self.setNextForm(self._FORM_VISIT_LIST.pop()) # Switch to the previous form if one exists
    except IndexError:
        self.setNextForm(backup)
        
.. @+node:ekr.20170624151245.364: *8* getHistory
def getHistory(self):
    return self._FORM_VISIT_LIST
    

.. @+node:ekr.20170624151245.365: *8* resetHistory
def resetHistory(self):
    self._FORM_VISIT_LIST = []
        


.. @+node:ekr.20170624151245.366: *8* main
def main(self):
    """
    This function starts the application. It is usually called indirectly through the function .run().  
    You should not override this function, but override the onInMainLoop, onStart and
    onCleanExit methods instead, if you need to modify the application's behaviour. 

    When this method is called, it will activate the form named by the class variable STARTING_FORM.  By default this Form will be called
    'MAIN'.  

    When that form exits (user selecting an ok button or the like), the form named by object variable NEXT_ACTIVE_FORM will be activated.

    If NEXT_ACTIVE_FORM is None, the main() loop will exit.
    
    The form selected will be edited using it's .edit() method UNLESS it has been provided with an .activate() method,
    in which case that method will be called instead.  This is done so that the same class of form can be made 
    NPSAppManaged aware and have the normal non-NPSAppManaged edit loop.
    
    After a Form has been edited, if it has an .afterEditing method, this will be called, unless it was invoked with the activate() method.
    A similar .beforeEditing method will be called if it exists before editing the form.  Again, the presence of a .activate method
    will override this behaviour.
    
    Note that NEXT_ACTIVE_FORM is a string that is the name of the form that was specified when .addForm or .registerForm was called.
    """
    
    self.onStart()
    while self.NEXT_ACTIVE_FORM != "" and self.NEXT_ACTIVE_FORM != None:
        self._LAST_NEXT_ACTIVE_FORM = self._Forms[self.NEXT_ACTIVE_FORM]
        self.LAST_ACTIVE_FORM_NAME = self.NEXT_ACTIVE_FORM
        try:
            Fm, a, k = self._Forms[self.NEXT_ACTIVE_FORM]
            self._THISFORM = Fm( parentApp = self, *a, **k )
        except TypeError:    
            self._THISFORM = self._Forms[self.NEXT_ACTIVE_FORM]
        self._THISFORM.FORM_NAME = self.NEXT_ACTIVE_FORM
        self.ACTIVE_FORM_NAME = self.NEXT_ACTIVE_FORM
        if len(self._FORM_VISIT_LIST) > 0:
            if self._FORM_VISIT_LIST[-1] != self.NEXT_ACTIVE_FORM:
                self._FORM_VISIT_LIST.append(self.NEXT_ACTIVE_FORM)
        else:
            self._FORM_VISIT_LIST.append(self.NEXT_ACTIVE_FORM)
        #self._THISFORM._resize()
        if hasattr(self._THISFORM, "activate"):
            self._THISFORM._resize()
            self._THISFORM.activate()
        else:
            if hasattr(self._THISFORM, "beforeEditing"):
                self._THISFORM.beforeEditing()
            self._THISFORM._resize()
            self._THISFORM.edit()
            if hasattr(self._THISFORM, "afterEditing"):
                self._THISFORM.afterEditing()
        
        self.onInMainLoop()
    self.onCleanExit()
    
.. @+node:ekr.20170624151245.367: *8* onInMainLoop
def onInMainLoop(self):
    """Called between each screen while the application is running. Not called before the first screen. Override at will"""
    
.. @+node:ekr.20170624151245.368: *8* onStart
def onStart(self):
    """Override this method to perform any initialisation."""
    pass
            
.. @+node:ekr.20170624151245.369: *8* onCleanExit
def onCleanExit(self):
    """Override this method to perform any cleanup when application is exiting without error."""


.. @+node:ekr.20170624151245.370: *6* @file ../external/npyscreen/apOptions.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.371: *7* Declarations
import weakref
# import textwrap
import datetime

from . import fmForm
from . import fmPopup
from . import wgtitlefield
from . import wgannotatetextbox
from . import wgmultiline
from . import wgselectone
from . import wgmultiselect
from . import wgeditmultiline
from . import wgcheckbox
from . import wgfilenamecombo
from . import wgdatecombo

.. @+node:ekr.20170624151245.372: *7* class SimpleOptionForm
class SimpleOptionForm(fmForm.Form):
    @others
.. @+node:ekr.20170624151245.373: *8* create
def create(self,):
    self.wOptionList = self.add(OptionListDisplay, )

.. @+node:ekr.20170624151245.374: *8* beforeEditing
def beforeEditing(self, ):
    try:
        self.wOptionList.values = self.value.options
    except AttributeError:
        pass

.. @+node:ekr.20170624151245.375: *8* afterEditing
def afterEditing(self):
    if self.value.filename:
        self.value.write_to_file()
    self.parentApp.switchFormPrevious()

.. @+node:ekr.20170624151245.376: *7* class OptionListDisplayLine
class OptionListDisplayLine(wgannotatetextbox.AnnotateTextboxBase):
    ANNOTATE_WIDTH = 25   
    @others
.. @+node:ekr.20170624151245.377: *8* getAnnotationAndColor
def getAnnotationAndColor(self):
    return (self.value.get_name_user(), 'LABEL')

.. @+node:ekr.20170624151245.378: *8* display_value
def display_value(self, vl):
    return vl.get_for_single_line_display()
    
.. @+node:ekr.20170624151245.379: *7* class OptionListDisplay
class OptionListDisplay(wgmultiline.MultiLineAction):
    _contained_widgets = OptionListDisplayLine
    @others
.. @+node:ekr.20170624151245.380: *8* actionHighlighted
def actionHighlighted(self, act_on_this, key_press):
    rtn = act_on_this.change_option()
    self.display()
    return rtn

.. @+node:ekr.20170624151245.381: *8* display_value
def display_value(self, vl):
    return vl

.. @+node:ekr.20170624151245.382: *7* class OptionChanger
class OptionChanger(fmPopup.ActionPopupWide):
    @others
.. @+node:ekr.20170624151245.383: *8* on_ok
def on_ok(self,):
    self.OPTION_TO_CHANGE.set_from_widget_value(self.OPTION_WIDGET.value)

.. @+node:ekr.20170624151245.384: *7* class OptionList
class OptionList(object):
    @others
.. @+node:ekr.20170624151245.385: *8* __init__
def __init__(self, filename=None):
    self.options  = []
    self.filename = filename
    self.define_serialize_functions()

.. @+node:ekr.20170624151245.386: *8* define_serialize_functions
def define_serialize_functions(self):
    self.SERIALIZE_FUNCTIONS = {
        OptionFreeText:         self.save_text,
        OptionSingleChoice:     self.save_text,
        OptionMultiChoice:      self.save_multi_text,
        OptionMultiFreeText:    self.save_text,
        OptionBoolean:          self.save_bool,
        OptionFilename:         self.save_text,
        OptionDate:             self.save_date,
        OptionMultiFreeList:    self.save_list,
    }

    self.UNSERIALIZE_FUNCTIONS = {
        OptionFreeText:         self.reload_text,
        OptionSingleChoice:     self.reload_text,
        OptionMultiChoice:      self.load_multi_text,
        OptionMultiFreeText:    self.reload_text,
        OptionBoolean:          self.load_bool,
        OptionFilename:         self.reload_text,
        OptionDate:             self.load_date,
        OptionMultiFreeList:    self.load_list,
    }

.. @+node:ekr.20170624151245.387: *8* get
def get(self, name):
    for o in self.options:
        if o.get_real_name() == name:
            return o



.. @+node:ekr.20170624151245.388: *8* write_to_file
def write_to_file(self, fn=None, exclude_defaults=True):
    fn = fn or self.filename
    if not fn:
        raise ValueError("Must specify a filename.")
    with open(fn, 'w', encoding="utf-8") as f:
        for opt in self.options:
            if opt.default != opt.get():
                f.write('%s=%s\n' % (opt.get_real_name(), self.serialize_option_value(opt)))

.. @+node:ekr.20170624151245.389: *8* reload_from_file
def reload_from_file(self, fn=None):
    fn = fn or self.filename
    with open(fn, 'r', encoding="utf-8") as f:
        for line in f.readlines():
             line = line.strip()
             name, value = line.split("=", maxsplit=1)
             for option in self.options:
                 if option.get_real_name() == name:
                     option.set(self.deserialize_option_value(option, value.encode('ascii')))

.. @+node:ekr.20170624151245.390: *8* serialize_option_value
def serialize_option_value(self, option):
    return self.SERIALIZE_FUNCTIONS[option.__class__](option)

.. @+node:ekr.20170624151245.391: *8* deserialize_option_value
def deserialize_option_value(self, option, serialized):
    return self.UNSERIALIZE_FUNCTIONS[option.__class__](serialized)

.. @+node:ekr.20170624151245.392: *8* _encode_text_for_saving
def _encode_text_for_saving(self, txt):
    return txt.encode('unicode-escape').decode('ascii')

.. @+node:ekr.20170624151245.393: *8* _decode_text_from_saved
def _decode_text_from_saved(self, txt):
    return txt.decode('unicode-escape')
    
.. @+node:ekr.20170624151245.394: *8* save_text
def save_text(self, option):
    s = option.get()
    if not s:
        s = ''
    return self._encode_text_for_saving(s)

.. @+node:ekr.20170624151245.395: *8* reload_text
def reload_text(self, txt):
    return self._decode_text_from_saved(txt)

.. @+node:ekr.20170624151245.396: *8* save_bool
def save_bool(self, option):
    if option.get():
        return 'True'
    else:
        return 'False'
        
.. @+node:ekr.20170624151245.397: *8* load_bool
def load_bool(self, txt):
    txt = txt.decode()
    if txt in ('True', ):
        return True
    elif txt in ('False', ):
        return False
    else:
        raise ValueError("Could not decode %s" % txt)

.. @+node:ekr.20170624151245.398: *8* save_multi_text
def save_multi_text(self, option):
    line = []
    opt = option.get()
    if not opt:
        return ''
    for text_part in opt:
        line.append(text_part.encode('unicode-escape').decode('ascii'))
    return "\t".join(line)

.. @+node:ekr.20170624151245.399: *8* load_multi_text
def load_multi_text(self, text):
    parts = text.decode('ascii').split("\t")
    rtn = []
    for p in parts:
        rtn.append(p.encode('ascii').decode('unicode-escape'))
    return rtn
    
.. @+node:ekr.20170624151245.400: *8* save_list
def save_list(self, lst):
    pts_to_save = []
    for p in lst.get():
        pts_to_save.append(self._encode_text_for_saving(p))
    return "\t".join(pts_to_save)

.. @+node:ekr.20170624151245.401: *8* load_list
def load_list(self, text):
    parts = text.decode('ascii').split("\t")
    parts_to_return = []
    for p in parts:
        parts_to_return.append(self._decode_text_from_saved(p.encode('ascii')))
    return parts_to_return

.. @+node:ekr.20170624151245.402: *8* save_date
def save_date(self, option):
    if option.get():
        return option.get().ctime()
    else:
        return None

.. @+node:ekr.20170624151245.403: *8* load_date
def load_date(self, txt):
    if txt:
        return datetime.datetime.strptime(txt.decode(), "%a %b %d %H:%M:%S %Y")
    else:
        return None


        
.. @+node:ekr.20170624151245.404: *7* class Option
class Option(object):
    DEFAULT = ''
    @others
.. @+node:ekr.20170624151245.405: *8* __init__
def __init__(self, name, 
                value=None, 
                documentation=None, 
                short_explanation=None,
                option_widget_keywords = None,
                default = None,
                ):
    self.name = name
    self.default = default or self.DEFAULT
    self.set(value or self.default)
    self.documentation = documentation
    self.short_explanation = short_explanation
    self.option_widget_keywords = option_widget_keywords or {}
    self.default = default or self.DEFAULT

.. @+node:ekr.20170624151245.406: *8* when_set
def when_set(self):
    pass

.. @+node:ekr.20170624151245.407: *8* get
def get(self,):
    return self.value

.. @+node:ekr.20170624151245.408: *8* get_for_single_line_display
def get_for_single_line_display(self):
    return repr(self.value)

.. @+node:ekr.20170624151245.409: *8* set_from_widget_value
def set_from_widget_value(self, vl):
    self.set(vl)

.. @+node:ekr.20170624151245.410: *8* set
def set(self, value):
    self.value = value
    self.when_set()

.. @+node:ekr.20170624151245.411: *8* get_real_name
def get_real_name(self):
    # This might be for internal use
    return self.name

.. @+node:ekr.20170624151245.412: *8* get_name_user
def get_name_user(self):
    # You could do translation here.
    return self.name

.. @+node:ekr.20170624151245.413: *8* _set_up_widget_values
def _set_up_widget_values(self, option_form, main_option_widget):
    main_option_widget.value = self.value

.. @+node:ekr.20170624151245.414: *8* change_option
def change_option(self):
    option_changing_form = OptionChanger()
    option_changing_form.OPTION_TO_CHANGE = weakref.proxy(self)
    if self.documentation:
        explanation_widget = option_changing_form.add(wgmultiline.Pager, 
                                                    editable=False, value=None,
                                                    max_height=(option_changing_form.lines - 3) // 2,
                                                    autowrap=True,
                                                    )
        option_changing_form.nextrely += 1
        explanation_widget.values = self.documentation
        
    
    option_widget = option_changing_form.add(self.WIDGET_TO_USE, 
                                                name=self.get_name_user(),
                                                **self.option_widget_keywords 
                                            )
    option_changing_form.OPTION_WIDGET = option_widget
    self._set_up_widget_values(option_changing_form, option_widget)        
    option_changing_form.edit()


.. @+node:ekr.20170624151245.415: *7* class OptionLimitedChoices
class OptionLimitedChoices(Option):
    @others
.. @+node:ekr.20170624151245.416: *8* __init__
def __init__(self, name, choices=None, *args, **keywords):
    super(OptionLimitedChoices, self).__init__(name, *args, **keywords)
    choices = choices or []
    self.setChoices(choices)

.. @+node:ekr.20170624151245.417: *8* setChoices
def setChoices(self, choices):
    self.choices = choices

.. @+node:ekr.20170624151245.418: *8* getChoices
def getChoices(self,):
    return self.choices

.. @+node:ekr.20170624151245.419: *8* _set_up_widget_values
def _set_up_widget_values(self, option_form, main_option_widget):
    main_option_widget.value  = []
    main_option_widget.values = self.getChoices()
    for x in range(len(main_option_widget.values)):
        if self.value and main_option_widget.values[x] in self.value:
            main_option_widget.value.append(x)

.. @+node:ekr.20170624151245.420: *8* set_from_widget_value
def set_from_widget_value(self, vl):
    value = []
    for v in vl:
        value.append(self.choices[v])
    self.set(value)
    
.. @+node:ekr.20170624151245.421: *7* class OptionFreeText
class OptionFreeText(Option):
    WIDGET_TO_USE = wgtitlefield.TitleText

.. @+node:ekr.20170624151245.422: *7* class OptionSingleChoice
class OptionSingleChoice(OptionLimitedChoices):
    WIDGET_TO_USE = wgselectone.TitleSelectOne

.. @+node:ekr.20170624151245.423: *7* class OptionMultiChoice
class OptionMultiChoice(OptionLimitedChoices):
    DEFAULT = []
    WIDGET_TO_USE = wgmultiselect.TitleMultiSelect

.. @+node:ekr.20170624151245.424: *7* class OptionMultiFreeText
class OptionMultiFreeText(Option):
    WIDGET_TO_USE = wgeditmultiline.MultiLineEdit

.. @+node:ekr.20170624151245.425: *7* class OptionMultiFreeList
class OptionMultiFreeList(Option):
    WIDGET_TO_USE = wgeditmultiline.MultiLineEdit
    DEFAULT = []
    @others
.. @+node:ekr.20170624151245.426: *8* _set_up_widget_values
def _set_up_widget_values(self, option_form, main_option_widget):
    main_option_widget.value = "\n".join(self.get())

.. @+node:ekr.20170624151245.427: *8* set_from_widget_value
def set_from_widget_value(self, vl):
    self.set(vl.split("\n"))

.. @+node:ekr.20170624151245.428: *7* class OptionBoolean
class OptionBoolean(Option):
    WIDGET_TO_USE = wgcheckbox.Checkbox

.. @+node:ekr.20170624151245.429: *7* class OptionFilename
class OptionFilename(Option):
    DEFAULT = ''
    WIDGET_TO_USE = wgfilenamecombo.FilenameCombo
    
.. @+node:ekr.20170624151245.430: *7* class OptionDate
class OptionDate(Option):
    DEFAULT = None
    WIDGET_TO_USE = wgdatecombo.DateCombo
.. @+node:ekr.20170624151245.431: *6* @file ../external/npyscreen/eveventhandler.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.432: *7* Declarations
import weakref

.. @+node:ekr.20170624151245.433: *7* class Event
class Event(object):
    # a basic event class
    @others
.. @+node:ekr.20170624151245.434: *8* __init__
def __init__(self, name, payload=None):
    self.name = name
    self.payload = payload


.. @+node:ekr.20170624151245.435: *7* class EventHandler
class EventHandler(object):
    # This partial base class provides the framework to handle events.
    
    @others
.. @+node:ekr.20170624151245.436: *8* initialize_event_handling
def initialize_event_handling(self):
    self.event_handlers = {}
    
.. @+node:ekr.20170624151245.437: *8* add_event_hander
def add_event_hander(self, event_name, handler):
    if not event_name in self.event_handlers:
        self.event_handlers[event_name] = set()
            # weakref.WeakSet() #Why doesn't the WeakSet work?
    self.event_handlers[event_name].add(handler)
    
    parent_app = self.find_parent_app()
    if parent_app:
        parent_app.register_for_event(self, event_name)
    else:
        # Probably are the parent App!
        # but could be a form outside a proper application environment
        try:
            self.register_for_event(self, event_name)
        except AttributeError:
            pass
            
.. @+node:ekr.20170624151245.438: *8* remove_event_handler
def remove_event_handler(self, event_name, handler):
    if event_name in self.event_handlers:
        self.event_handlers[event_name].remove(handler)
    if not self.event_handlers[event_name]:
        self.event_handlers.pop({})
        

.. @+node:ekr.20170624151245.439: *8* handle_event
def handle_event(self, event):
    "return True if the event was handled.  Return False if the application should stop sending this event."
    if event.name not in self.event_handlers:
        return False
    else:
        remove_list = []
        for handler in self.event_handlers[event.name]:
            try:
                handler(event)
            except weakref.ReferenceError:
                remove_list.append(handler)
        for dead_handler in remove_list:
            self.event_handlers[event.name].remove(handler)
        return True

.. @+node:ekr.20170624151245.440: *8* find_parent_app
def find_parent_app(self):
    if hasattr(self, "parentApp"):
        return self.parentApp
    elif hasattr(self, "parent") and hasattr(self.parent, "parentApp"):
        return self.parent.parentApp
    else:
        return None
        
.. @+node:ekr.20170624151245.441: *6* @file ../external/npyscreen/fmActionForm.py
#!/usr/bin/python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.442: *7* Declarations
import weakref
from . import fmForm
from . import wgwidget as widget
.. @+node:ekr.20170624151245.443: *7* class ActionForm
class ActionForm(fmForm.Form):
    """A form with OK and Cancel buttons.  Users should override the on_ok and on_cancel methods."""
    CANCEL_BUTTON_BR_OFFSET = (2, 12)
    OK_BUTTON_TEXT          = "OK"
    CANCEL_BUTTON_TEXT      = "Cancel"

    @others
.. @+node:ekr.20170624151245.444: *8* set_up_exit_condition_handlers
def set_up_exit_condition_handlers(self):
    super(ActionForm, self).set_up_exit_condition_handlers()
    self.how_exited_handers.update({
        widget.EXITED_ESCAPE:   self.find_cancel_button
    })

.. @+node:ekr.20170624151245.445: *8* find_cancel_button
def find_cancel_button(self):
    self.editw = len(self._widgets__)-2
    
.. @+node:ekr.20170624151245.446: *8* ActionForm.edit
def edit(self):
    # Add ok and cancel buttons. Will remove later
    tmp_rely, tmp_relx = self.nextrely, self.nextrelx
    
    c_button_text = self.CANCEL_BUTTON_TEXT
    cmy, cmx = self.curses_pad.getmaxyx()
    cmy -= self.__class__.CANCEL_BUTTON_BR_OFFSET[0]
    cmx -= len(c_button_text)+self.__class__.CANCEL_BUTTON_BR_OFFSET[1]
    self.c_button = self.add_widget(self.__class__.OKBUTTON_TYPE, name=c_button_text, rely=cmy, relx=cmx, use_max_space=True)
    c_button_postion = len(self._widgets__)-1
    self.c_button.update()
    
    my, mx = self.curses_pad.getmaxyx()
    ok_button_text = self.OK_BUTTON_TEXT
    my -= self.__class__.OK_BUTTON_BR_OFFSET[0]
    mx -= len(ok_button_text)+self.__class__.OK_BUTTON_BR_OFFSET[1]
    self.ok_button = self.add_widget(self.__class__.OKBUTTON_TYPE, name=ok_button_text, rely=my, relx=mx, use_max_space=True)
    ok_button_postion = len(self._widgets__)-1
    # End add buttons
    
    self.editing=True
    if self.editw < 0: self.editw=0
    if self.editw > len(self._widgets__)-1:
        self.editw = len(self._widgets__)-1
    if not self.preserve_selected_widget:
        self.editw = 0


    if not self._widgets__[self.editw].editable: self.find_next_editable()
    self.ok_button.update()

    self.display()

    while not self._widgets__[self.editw].editable:
        self.editw += 1
        if self.editw > len(self._widgets__)-2: 
            self.editing = False
            return False
    
    self.edit_return_value = None
    while self.editing:
        if not self.ALL_SHOWN: self.on_screen()
        try:
            self.while_editing(weakref.proxy(self._widgets__[self.editw]))
        except TypeError:
            self.while_editing()
        self._widgets__[self.editw].edit()
        self._widgets__[self.editw].display()
        
        self.handle_exiting_widgets(self._widgets__[self.editw].how_exited)
        
        if self.editw > len(self._widgets__)-1: self.editw = len(self._widgets__)-1
        if self.ok_button.value or self.c_button.value:
            self.editing = False
    
        if self.ok_button.value:
            self.ok_button.value = False
            self.edit_return_value = self.on_ok()
        elif self.c_button.value:
            self.c_button.value = False
            self.edit_return_value = self.on_cancel()
    
    self.ok_button.destroy()
    self.c_button.destroy()
    del self._widgets__[ok_button_postion]
    del self.ok_button
    del self._widgets__[c_button_postion]
    del self.c_button
    self.nextrely, self.nextrelx = tmp_rely, tmp_relx
    self.display()
    self.editing = False
    
    return self.edit_return_value

.. @+node:ekr.20170624151245.447: *8* on_cancel
def on_cancel(self):
    pass

.. @+node:ekr.20170624151245.448: *8* on_ok
def on_ok(self):
    pass

.. @+node:ekr.20170624151245.449: *8* move_ok_button
def move_ok_button(self):
    super(ActionForm, self).move_ok_button()
    if hasattr(self, 'c_button'):
        c_button_text = self.CANCEL_BUTTON_TEXT
        cmy, cmx = self.curses_pad.getmaxyx()
        cmy -= self.__class__.CANCEL_BUTTON_BR_OFFSET[0]
        cmx -= len(c_button_text)+self.__class__.CANCEL_BUTTON_BR_OFFSET[1]
        self.c_button.rely = cmy
        self.c_button.relx = cmx
    
    
    
.. @+node:ekr.20170624151245.450: *7* class ActionFormExpanded
class ActionFormExpanded(ActionForm):
    BLANK_LINES_BASE   = 1
    OK_BUTTON_BR_OFFSET = (1,6)
    CANCEL_BUTTON_BR_OFFSET = (1, 12)
    
    
.. @+node:ekr.20170624151245.451: *6* @file ../external/npyscreen/fmActionFormV2.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.452: *7* Declarations
import operator
# import weakref
from . import wgwidget as widget
from . import wgbutton
from . import fmForm

.. @+node:ekr.20170624151245.453: *7* class ActionFormV2
class ActionFormV2(fmForm.FormBaseNew):
    @others
.. @+node:ekr.20170624151245.454: *8* class OK_Button
class OK_Button(wgbutton.MiniButtonPress):
    @others
.. @+node:ekr.20170624151245.455: *9* whenPressed
def whenPressed(self):
    return self.parent._on_ok()
    
.. @+node:ekr.20170624151245.456: *8* class Cancel_Button
class Cancel_Button(wgbutton.MiniButtonPress):
    @others
OKBUTTON_TYPE = OK_Button
CANCELBUTTON_TYPE = Cancel_Button
CANCEL_BUTTON_BR_OFFSET = (2, 12)
OK_BUTTON_TEXT          = "OK"
CANCEL_BUTTON_TEXT      = "Cancel"
.. @+node:ekr.20170624151245.457: *9* whenPressed
def whenPressed(self):
    return self.parent._on_cancel()
    
.. @+node:ekr.20170624151245.458: *8* __init__
def __init__(self, *args, **keywords):
    super(ActionFormV2, self).__init__(*args, **keywords)
    self._added_buttons = {}
    self.create_control_buttons()


.. @+node:ekr.20170624151245.459: *8* create_control_buttons
def create_control_buttons(self):
    self._add_button('ok_button', 
                    self.__class__.OKBUTTON_TYPE, 
                    self.__class__.OK_BUTTON_TEXT,
                    0 - self.__class__.OK_BUTTON_BR_OFFSET[0],
                    0 - self.__class__.OK_BUTTON_BR_OFFSET[1] - len(self.__class__.OK_BUTTON_TEXT),
                    None
                    )
                    
    self._add_button('cancel_button', 
                    self.__class__.CANCELBUTTON_TYPE, 
                    self.__class__.CANCEL_BUTTON_TEXT,
                    0 - self.__class__.CANCEL_BUTTON_BR_OFFSET[0],
                    0 - self.__class__.CANCEL_BUTTON_BR_OFFSET[1] - len(self.__class__.CANCEL_BUTTON_TEXT),
                    None
                    )

.. @+node:ekr.20170624151245.460: *8* on_cancel
def on_cancel(self):
    pass

.. @+node:ekr.20170624151245.461: *8* on_ok
def on_ok(self):
    pass

.. @+node:ekr.20170624151245.462: *8* _on_ok
def _on_ok(self):
    self.editing = self.on_ok()

.. @+node:ekr.20170624151245.463: *8* _on_cancel
def _on_cancel(self):
    self.editing = self.on_cancel() 

.. @+node:ekr.20170624151245.464: *8* set_up_exit_condition_handlers
def set_up_exit_condition_handlers(self):
    super(ActionFormV2, self).set_up_exit_condition_handlers()
    self.how_exited_handers.update({
        widget.EXITED_ESCAPE:   self.find_cancel_button
    })

.. @+node:ekr.20170624151245.465: *8* find_cancel_button
def find_cancel_button(self):
    self.editw = len(self._widgets__)-2

.. @+node:ekr.20170624151245.466: *8* _add_button
def _add_button(self, button_name, button_type, button_text, button_rely, button_relx, button_function):
    tmp_rely, tmp_relx = self.nextrely, self.nextrelx
    this_button = self.add_widget(
                    button_type, 
                    name=button_text, 
                    rely=button_rely,
                    relx=button_relx,
                    when_pressed_function = button_function,
                    use_max_space=True,
                    )
    self._added_buttons[button_name] = this_button
    self.nextrely, self.nextrelx = tmp_rely, tmp_relx


.. @+node:ekr.20170624151245.467: *8* pre_edit_loop
def pre_edit_loop(self):
    self._widgets__.sort(key=operator.attrgetter('relx'))
    self._widgets__.sort(key=operator.attrgetter('rely'))
    if not self.preserve_selected_widget:
        self.editw = 0
    if not self._widgets__[self.editw].editable: 
        self.find_next_editable()
    
.. @+node:ekr.20170624151245.468: *8* post_edit_loop
def post_edit_loop(self):
    pass        

.. @+node:ekr.20170624151245.469: *8* _during_edit_loop
def _during_edit_loop(self):
    pass

.. @+node:ekr.20170624151245.470: *7* class ActionFormExpandedV2
class ActionFormExpandedV2(ActionFormV2):
    BLANK_LINES_BASE   = 1
    OK_BUTTON_BR_OFFSET = (1,6)
    CANCEL_BUTTON_BR_OFFSET = (1, 12)

.. @+node:ekr.20170624151245.471: *7* class ActionFormMinimal
class ActionFormMinimal(ActionFormV2):
        @others
.. @+node:ekr.20170624151245.472: *8* create_control_buttons
def create_control_buttons(self):
    self._add_button('ok_button',
                self.__class__.OKBUTTON_TYPE,
                self.__class__.OK_BUTTON_TEXT,
                0 - self.__class__.OK_BUTTON_BR_OFFSET[0],
                0 - self.__class__.OK_BUTTON_BR_OFFSET[1] - len(self.__class__.OK_BUTTON_TEXT),
                None
                )

.. @+node:ekr.20170624151245.473: *6* @file ../external/npyscreen/fmFileSelector.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.474: *7* Declarations
from . import fmFormMutt
# from . import wgmultiline
from . import wggrid
from . import wgautocomplete
from . import utilNotify

import curses
import os
import os.path
# import operator

.. @+node:ekr.20170624151245.475: *7* class FileCommand
class FileCommand(wgautocomplete.Filename):
    @others
.. @+node:ekr.20170624151245.476: *8* set_up_handlers
def set_up_handlers(self):
    '''FileCommand.set_up_handlers.'''
    super(FileCommand, self).set_up_handlers()
    self.handlers.update ({
        curses.ascii.NL:    self.h_select_file,
        curses.ascii.CR:    self.h_select_file,
        "^W":               self.h_up_level,
    })
    
.. @+node:ekr.20170624151245.477: *8* h_select_file
def h_select_file(self, *args, **keywords):
    self.h_exit_down(None)
    self.parent.try_exit()

.. @+node:ekr.20170624151245.478: *8* h_up_level
def h_up_level(self, *args, **keywords):
    self.value = os.path.split(self.value)[0]
    self.cursor_position = len(self.value)

.. @+node:ekr.20170624151245.479: *8* auto_complete
def auto_complete(self, input):
    self.value = os.path.expanduser(self.value)
    
    directory, fname = os.path.split(self.value)
    # Let's have absolute paths.
    directory = os.path.abspath(directory)
    
    if self.value == '': 
        self.value=directory
        
    
    try: 
        flist = os.listdir(directory)
    except Exception:
        self.show_brief_message("Can't read directory!")
        return False
        
    flist = [os.path.join(directory, x) for x in flist]
    possibilities = list(filter(
        (lambda x: os.path.split(x)[1].startswith(fname)), flist
        ))

    if len(possibilities) == 0:
        # can't complete
        curses.beep()
        self.cursor_position = len(self.value)

    elif len(possibilities) == 1:
        if self.value != possibilities[0]:
            self.value = possibilities[0]
            if os.path.isdir(self.value) \
                and not self.value.endswith(os.sep):
                self.value = self.value + os.sep
        self.cursor_position = len(self.value)
    
    elif len(possibilities) > 1:
        self.value = os.path.commonprefix(possibilities)
        self.cursor_position = len(self.value)
        curses.beep()
        
    if os.path.isdir(self.value) and len(possibilities) < 2:
        self.parent.wMain.change_dir(self.value)
        if os.path.isdir(self.value) \
            and not self.value.endswith(os.sep):
            self.value = self.value + os.sep
        self.cursor_position = len(self.value)
        
        #self.h_exit_up(None)
    else:
        self.parent.value = directory
        self.parent.update_grid()


.. @+node:ekr.20170624151245.480: *7* class FileGrid
class FileGrid(wggrid.SimpleGrid):
    default_column_number = 3
    
    @others
.. @+node:ekr.20170624151245.481: *8* FileGrid.set_up_handlers
def set_up_handlers(self):
    '''FileGrid.set_up_handlers.'''
    super(FileGrid, self).set_up_handlers()
    self.handlers.update ({
        curses.ascii.NL:    self.h_select_file,
        curses.ascii.CR:    self.h_select_file,
        curses.ascii.SP:    self.h_select_file,
    })

.. @+node:ekr.20170624151245.482: *8* FileGrid.change_dir
def change_dir(self, select_file):
    try:
        os.listdir(select_file)
    except OSError:
        utilNotify.notify_wait(title="Error", message="Cannot enter directory.")
        return False
    self.parent.value = select_file
    self.parent.wCommand.value = select_file
    self.parent.update_grid()
    self.edit_cell = [0, 0]
    self.begin_row_display_at = 0
    self.begin_col_display_at = 0
    return True
    


.. @+node:ekr.20170624151245.483: *8* FileGrid.h_select_file
def h_select_file(self, *args, **keywrods):
    try:
         select_file = os.path.join(self.parent.value, self.values[self.edit_cell[0]][self.edit_cell[1]])
         select_file = os.path.abspath(select_file)
    except (TypeError, IndexError):
        self.edit_cell = [0, 0]
        return False
    
    if os.path.isdir(select_file):
        self.change_dir(select_file)
    else:
        self.parent.wCommand.value = select_file
        self.h_exit_down(None)

.. @+node:ekr.20170624151245.484: *8* FileGrid.display_value
def display_value(self, vl):
    p = os.path.split(vl)
    if p[1]:
        return p[1]
    else:
        return os.path.split(p[0])[1] + os.sep
    
.. @+node:ekr.20170624151245.485: *7* class FileSelector
class FileSelector(fmFormMutt.FormMutt):
    MAIN_WIDGET_CLASS   = FileGrid
    COMMAND_WIDGET_CLASS= FileCommand
    BLANK_LINES_BASE     = 0
    @others
.. @+node:ekr.20170624151245.486: *8* __init__
def __init__(self,
select_dir=False, #Select a dir, not a file
must_exist=False, #Selected File must already exist
confirm_if_exists=True,
sort_by_extension=True,
*args, **keywords):

    self.select_dir = select_dir
    self.must_exist = must_exist
    self.confirm_if_exists = confirm_if_exists
    self.sort_by_extension = sort_by_extension
    
    super(FileSelector, self).__init__(*args, **keywords)
    try:
        if not self.value:
            self.value = os.getcwd()
    except Exception:
        self.value = os.getcwd()

.. @+node:ekr.20170624151245.487: *8* try_exit
def try_exit(self):
    if not self.wCommand.value:
        self.value=''
        self.exit_editing()
        return None
        
    # There is a bug in the next three lines
    self.wCommand.value = os.path.join(self.value, self.wCommand.value)
    self.wCommand.value = os.path.expanduser(self.wCommand.value)
    self.wCommand.value = os.path.abspath(self.wCommand.value)
    
    
    self.value = self.wCommand.value
    
    if self.confirm_if_exists and os.path.exists(self.value):
        if not utilNotify.notify_yes_no(title="Confirm", message="Select Existing File?"):
            return False
    if self.must_exist and not os.path.exists(self.value):
        utilNotify.notify_confirm(title="Error", message="Selected filename does not exist.")
        return False
    if self.select_dir and not os.path.isdir(self.value):
        utilNotify.notify_confirm(title="Error", message="Selected filename is not a directory.")
        return False
    self.exit_editing()
    return True

.. @+node:ekr.20170624151245.488: *8* set_colors
def set_colors(self):
    self.wCommand.color = 'IMPORTANT'
    self.wCommand.color = 'STANDOUT'
    
    
.. @+node:ekr.20170624151245.489: *8* beforeEditing
def beforeEditing(self,):
    self.adjust_widgets()
    self.set_colors()
    
.. @+node:ekr.20170624151245.490: *8* update_grid
def update_grid(self,):
    if self.value:
        self.value = os.path.expanduser(self.value)
    
    if not os.path.exists(self.value):
        self.value = os.getcwd()
        
    if os.path.isdir(self.value):
        working_dir = self.value
    else:
        working_dir = os.path.dirname(self.value)
        
    self.wStatus1.value = working_dir
    
    file_list = []
    if os.path.abspath(os.path.join(working_dir, '..')) != os.path.abspath(working_dir):
        file_list.append('..')
    try:
        file_list.extend([os.path.join(working_dir, fn) for fn in os.listdir(working_dir)])
    except OSError:
        utilNotify.notify_wait(title="Error", message="Could not read specified directory.")
    # DOES NOT CURRENTLY WORK - EXCEPT FOR THE WORKING DIRECTORY.  REFACTOR.
    new_file_list= []
    for f in file_list:
        f = os.path.normpath(f)
        if os.path.isdir(f):
            new_file_list.append(f + os.sep)
        else:
            new_file_list.append(f) # + "*")
    file_list = new_file_list
    del new_file_list

    # sort Filelist
    file_list.sort()
    if self.sort_by_extension:
        file_list.sort(key=self.get_extension)
    file_list.sort(key=os.path.isdir, reverse=True)
    
    self.wMain.set_grid_values_from_flat_list(file_list, reset_cursor=False)
            
    self.display()

.. @+node:ekr.20170624151245.491: *8* get_extension
def get_extension(self, fn):
    return os.path.splitext(fn)[1]

.. @+node:ekr.20170624151245.492: *8* adjust_widgets
def adjust_widgets(self):
    self.update_grid()
    
.. @+node:ekr.20170624151245.493: *7* selectFile
def selectFile(starting_value=None, *args, **keywords):
    F = FileSelector(*args, **keywords)
    F.set_colors()
    F.wCommand.show_bold = True
    if starting_value:
        if not os.path.exists(os.path.abspath(os.path.expanduser(starting_value))):
            F.value = os.getcwd()
        else:
            F.value = starting_value
            F.wCommand.value = starting_value
    else:
        F.value = os.getcwd()
    F.update_grid()
    F.display()
    F.edit()    
    return F.wCommand.value
        
.. @+node:ekr.20170624151245.494: *6* @file ../external/npyscreen/fmForm.py
#!/usr/bin/python
# pylint: disable=no-member
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.495: *7* Declarations
from . import proto_fm_screen_area
from . import wgwidget  as widget
from . import wgbutton  as button
import weakref
# from . import npyspmfuncs as pmfuncs
#import Menu
import curses
import _curses
from . import npysGlobalOptions
from . import wgwidget_proto
from . import fm_form_edit_loop   as form_edit_loop
from . import util_viewhelp
from . import npysGlobalOptions as GlobalOptions
from .eveventhandler import EventHandler
from .globals import DISABLE_RESIZE_SYSTEM

.. @+node:ekr.20170624151245.496: *7* class _FormBase
class _FormBase(proto_fm_screen_area.ScreenArea, 
        widget.InputHandler, 
        wgwidget_proto._LinePrinter,
        EventHandler):
    BLANK_COLUMNS_RIGHT= 2
    BLANK_LINES_BASE   = 2
    OK_BUTTON_TEXT     = 'OK'
    OK_BUTTON_BR_OFFSET = (2,6)
    OKBUTTON_TYPE = button.MiniButton
    DEFAULT_X_OFFSET = 2
    PRESERVE_SELECTED_WIDGET_DEFAULT = False # Preserve cursor location between displays?
    FRAMED = True
    ALLOW_RESIZE = True
    FIX_MINIMUM_SIZE_WHEN_CREATED = True    
    WRAP_HELP = True
    
    
    @others
.. @+node:ekr.20170624151245.497: *8* __init__
def __init__(self, name=None, parentApp=None, framed=None, help=None, color='FORMDEFAULT', 
                widget_list=None, cycle_widgets=False, *args, **keywords):
    super(_FormBase, self).__init__(*args, **keywords)
    self.initialize_event_handling()
    self.preserve_selected_widget = self.__class__.PRESERVE_SELECTED_WIDGET_DEFAULT
    if parentApp:
        try:
            self.parentApp = weakref.proxy(parentApp)
        except Exception:
            self.parentApp = parentApp
        try:
            self.keypress_timeout = self.parentApp.keypress_timeout_default
        except AttributeError:
            pass
    if framed is None:
        self.framed = self.__class__.FRAMED
    else:
        self.framed = framed
    self.name=name
    self.editing = False
    ## OLD MENU CODE REMOVED self.__menus  = []
    self._clear_all_widgets()

    self.help = help

    self.color = color
    
    self.cycle_widgets = cycle_widgets

    self.set_up_handlers()
    self.set_up_exit_condition_handlers()
    if hasattr(self, 'initialWidgets'):
        self.create_widgets_from_list(self.__class__.initialWidgets)
    if widget_list:
        self.create_widgets_from_list(widget_list)
    self.create()
    
    if self.FIX_MINIMUM_SIZE_WHEN_CREATED:
        self.min_l = self.lines
        self.min_c = self.columns
    
        
.. @+node:ekr.20170624151245.498: *8* resize
def resize(self):
    pass

.. @+node:ekr.20170624151245.499: *8* _clear_all_widgets
def _clear_all_widgets(self, ):
    self._widgets__     = []
    self._widgets_by_id = {}
    self._next_w_id = 0
    self.nextrely = self.DEFAULT_NEXTRELY
    self.nextrelx = self.DEFAULT_X_OFFSET
    self.editw = 0 # Index of widget to edit.

.. @+node:ekr.20170624151245.500: *8* create_widgets_from_list
def create_widgets_from_list(self, widget_list):
    # This code is currently experimental, and the API may change in future releases
    # (npyscreen.TextBox, {'rely': 2, 'relx': 7, 'editable': False})
    for line in widget_list:
        w_type   = line[0]
        keywords = line[1]
        self.add_widget(w_type, **keywords)

.. @+node:ekr.20170624151245.501: *8* set_value
def set_value(self, value):
    self.value = value
    for _w in self._widgets__:
        if hasattr(_w, 'when_parent_changes_value'):
            _w.when_parent_changes_value()

.. @+node:ekr.20170624151245.502: *8* _resize
def _resize(self, *args):
    # global DISABLE_RESIZE_SYSTEM
    # EKR: This is an imported symbol, not a global!
    if DISABLE_RESIZE_SYSTEM:
        return False
        
    if not self.ALLOW_RESIZE:
        return False
        
    if hasattr(self, 'parentApp'):
        self.parentApp.resize()
        
    self._create_screen()
    self.resize()
    for w in self._widgets__:
        w._resize()
    self.DISPLAY()



.. @+node:ekr.20170624151245.503: *8* create
def create(self):
    """Programmers should over-ride this in derived classes, creating widgets here"""
    pass

.. @+node:ekr.20170624151245.504: *8* set_up_handlers
def set_up_handlers(self):
    '''FormBase.set_up_handlers.'''
    self.complex_handlers = []
    self.handlers = { 
        curses.KEY_F1: self.h_display_help,
        "KEY_F(1)":         self.h_display_help,
        "^O":               self.h_display_help,
        "^L":               self.h_display,
        curses.KEY_RESIZE:  self._resize,
    }
.. @+node:ekr.20170624151245.505: *8* _FormBase.set_up_exit_condition_handlers
def set_up_exit_condition_handlers(self):
    # What happens when widgets exit?
    # each widget will set it's how_exited value: this should
    # be used to look up the following table.

    self.how_exited_handers = {
        widget.EXITED_DOWN:    self.find_next_editable,
        widget.EXITED_RIGHT:   self.find_next_editable,
        widget.EXITED_UP:      self.find_previous_editable,
        widget.EXITED_LEFT:    self.find_previous_editable,
        widget.EXITED_ESCAPE:  self.do_nothing,
        True:                  self.find_next_editable, # A default value
        widget.EXITED_MOUSE:   self.get_and_use_mouse_event,
        False:                  self.do_nothing,
        None:                   self.do_nothing,
        }

.. @+node:ekr.20170624151245.506: *8* handle_exiting_widgets
def handle_exiting_widgets(self, condition):
    self.how_exited_handers[condition]()

.. @+node:ekr.20170624151245.507: *8* do_nothing
def do_nothing(self, *args, **keywords):
    pass

.. @+node:ekr.20170624151245.508: *8* exit_editing
def exit_editing(self, *args, **keywords):
    self.editing = False
    try:
        self._widgets__[self.editw].entry_widget.editing = False
    except Exception:
        pass
    try:
        self._widgets__[self.editw].editing = False
    except Exception:
        pass

.. @+node:ekr.20170624151245.509: *8* adjust_widgets
def adjust_widgets(self):
    """This method can be overloaded by derived classes. It is called when editing any widget, as opposed to
    the while_editing() method, which may only be called when moving between widgets.  Since it is called for
    every keypress, and perhaps more, be careful when selecting what should be done here."""


.. @+node:ekr.20170624151245.510: *8* while_editing
def while_editing(self, *args, **keywords):
    """This function gets called during the edit loop, on each iteration
    of the loop.  It does nothing: it is here to make customising the loop
    as easy as overriding this function. A proxy to the currently selected widget is 
    passed to the function."""

.. @+node:ekr.20170624151245.511: *8* on_screen
def on_screen(self):
    # is the widget in editw on sreen at the moment?
    # if not, alter screen so that it is.

    w = weakref.proxy(self._widgets__[self.editw])

    max_y, max_x = self._max_physical()

    w_my, w_mx = w.calculate_area_needed()

    # always try to show the top of the screen.
    self.show_from_y = 0
    self.show_from_x = 0

    while w.rely + w_my -1 > self.show_from_y + max_y:
        self.show_from_y += 1

    while w.rely < self.show_from_y:
        self.show_from_y -= 1


    while w.relx + w_mx -1 > self.show_from_x + max_x:
        self.show_from_x += 1

    while w.relx < self.show_from_x:
        self.show_from_x -= 1

.. @+node:ekr.20170624151245.512: *8* h_display_help
def h_display_help(self, input):
    if self.help == None: return
    if self.name:
        help_name="%s Help" %(self.name)
    else: help_name=None
    curses.flushinp()
    util_viewhelp.view_help(self.help, title=help_name, autowrap=self.WRAP_HELP)
    #select.ViewText(self.help, name=help_name)
    self.display()
    return True

.. @+node:ekr.20170624151245.513: *8* _FormBase.DISPLAY
def DISPLAY(self):
    self.curses_pad.redrawwin()
    self.erase()
    self.display()
    self.display(clear=False)
    if self.editing and self.editw is not None:
        self._widgets__[self.editw].display()


.. @+node:ekr.20170624151245.514: *8* h_display
def h_display(self, input):
    self._resize()
    self.DISPLAY()
    
.. @+node:ekr.20170624151245.515: *8* safe_get_mouse_event
def safe_get_mouse_event(self):
    try:
        mouse_event = curses.getmouse()
        return mouse_event
    except _curses.error:
        return None

.. @+node:ekr.20170624151245.516: *8* get_and_use_mouse_event
def get_and_use_mouse_event(self):
    mouse_event = self.safe_get_mouse_event()
    if mouse_event:
        self.use_mouse_event(mouse_event)
    
.. @+node:ekr.20170624151245.517: *8* use_mouse_event
def use_mouse_event(self, mouse_event):
    wg = self.find_mouse_handler(mouse_event)
    if wg:
        self.set_editing(wg)
        if hasattr(wg, 'handle_mouse_event'):
            wg.handle_mouse_event(mouse_event)
    else:
        curses.beep()

.. @+node:ekr.20170624151245.518: *8* find_mouse_handler
def find_mouse_handler(self, mouse_event):
    #mouse_id, x, y, z, bstate = mouse_event
    for wd in self._widgets__:
        try:
            if wd.intersted_in_mouse_event(mouse_event) == True:
                return wd
        except AttributeError:
            pass
    return None
    
.. @+node:ekr.20170624151245.519: *8* set_editing
def set_editing(self, wdg):
    try:
        self.editw = self._widgets__.index(wdg)
    except ValueError:
        pass


.. @+node:ekr.20170624151245.520: *8* find_next_editable
def find_next_editable(self, *args):
    if not self.cycle_widgets:
        r = list(range(self.editw+1, len(self._widgets__)))
    else:
        r = list(range(self.editw+1, len(self._widgets__))) + list(range(0, self.editw))
    for n in r:
        if self._widgets__[n].editable and not self._widgets__[n].hidden: 
            self.editw = n
            break
    self.display()


.. @+node:ekr.20170624151245.521: *8* find_previous_editable
def find_previous_editable(self, *args):
    if self.editw != 0:     
        # remember that xrange does not return the 'last' value,
        # so go to -1, not 0! (fence post error in reverse)
        for n in range(self.editw-1, -1, -1 ):
            if self._widgets__[n].editable and not self._widgets__[n].hidden: 
                self.editw = n
                break

#def widget_useable_space(self, rely=0, relx=0):
#    #Slightly misreports space available.
#    mxy, mxx = self.lines-1, self.columns-1
#    return (mxy-1-rely, mxx-1-relx)

.. @+node:ekr.20170624151245.522: *8* center_on_display
def center_on_display(self):
    my, mx = self._max_physical()
    if self.lines < my:
        self.show_aty = (my - self.lines) // 2
    else:
        self.show_aty = 0

    if self.columns < mx:
        self.show_atx = (mx - self.columns) // 2
    else:
        self.show_atx = 0


.. @+node:ekr.20170624151245.523: *8* _FormBase.display
def display(self, clear=False):
    #APPLICATION_THEME_MANAGER.setTheme(self)
    if curses.has_colors() and not npysGlobalOptions.DISABLE_ALL_COLORS:
        self.curses_pad.attrset(0)
        color_attribute = self.theme_manager.findPair(self, self.color)
        self.curses_pad.bkgdset(' ', color_attribute)
        self.curses_pad.attron(color_attribute)
    self.curses_pad.erase()
    self.draw_form()
    for w in [wg for wg in self._widgets__ if wg.hidden]:
        w.clear()
    for w in [wg for wg in self._widgets__ if not wg.hidden]:
        w.update(clear=clear)

    self.refresh()

.. @+node:ekr.20170624151245.524: *8* draw_title_and_help
def draw_title_and_help(self):
    try:
        if self.name:
            _title = self.name[:(self.columns-4)]
            _title = ' ' + str(_title) + ' '
            #self.curses_pad.addstr(0,1, ' '+str(_title)+' ')
            if isinstance(_title, bytes):
                _title = _title.decode('utf-8', 'replace')
            self.add_line(0,1, 
                _title, 
                self.make_attributes_list(_title, curses.A_NORMAL),
                self.columns-4
                )
    except Exception:
        pass

    if self.help and self.editing:
        try:
            help_advert = " Help: F1 or ^O "
            if isinstance(help_advert, bytes):
                help_advert = help_advert.decode('utf-8', 'replace')
            self.add_line(
             0, self.curses_pad.getmaxyx()[1]-len(help_advert)-2, 
             help_advert,
             self.make_attributes_list(help_advert, curses.A_NORMAL),
             len(help_advert)
             )
        except Exception:
            pass

.. @+node:ekr.20170624151245.525: *8* draw_form
def draw_form(self):
    if self.framed:
        if curses.has_colors() and not GlobalOptions.DISABLE_ALL_COLORS:
            self.curses_pad.attrset(0)
            self.curses_pad.bkgdset(' ', curses.A_NORMAL | self.theme_manager.findPair(self, self.color))
        self.curses_pad.border()
        self.draw_title_and_help()


.. @+node:ekr.20170624151245.526: *8* add_widget
def add_widget(self, widgetClass, w_id=None, max_height=None, rely=None, relx=None, *args, **keywords):
    """Add a widget to the form.  The form will do its best to decide on placing, unless you override it.
    The form of this function is add_widget(WidgetClass, ....) with any arguments or keywords supplied to
    the widget. The wigdet will be added to self._widgets__

    It is safe to use the return value of this function to keep hold of the widget, since that is a weak
    reference proxy, but it is not safe to keep hold of self._widgets__"""

    if rely is None:
        rely = self.nextrely
    if relx is None:
        relx = self.nextrelx

    if max_height is False:
        max_height = self.curses_pad.getmaxyx()[0] - rely - 1

    _w = widgetClass(self, 
            rely=rely, 
            relx=relx, 
            max_height=max_height, 
            *args, **keywords)

    self.nextrely = _w.height + _w.rely 
    self._widgets__.append(_w)
    w_proxy = weakref.proxy(_w)
    if not w_id:
        w_id = self._next_w_id
        self._next_w_id += 1
    self._widgets_by_id[w_id] = w_proxy

    return w_proxy

.. @+node:ekr.20170624151245.527: *8* get_widget
def get_widget(self, w_id):
    return self._widgets_by_id[w_id]

add = add_widget

.. @+node:ekr.20170624151245.528: *7* class FormBaseNew
class FormBaseNew(form_edit_loop.FormNewEditLoop, _FormBase):
    # use the new-style edit loop.
    pass

.. @+node:ekr.20170624151245.529: *7* class Form
class Form(form_edit_loop.FormDefaultEditLoop, _FormBase, ):
    #use the old-style edit loop

    def resize(self):
        super(Form, self).resize()
        self.move_ok_button()
.. @+node:ekr.20170624151245.530: *7* class FormBaseNewExpanded
class FormBaseNewExpanded(form_edit_loop.FormNewEditLoop, _FormBase):
    BLANK_LINES_BASE   = 1
    OK_BUTTON_BR_OFFSET = (1,6)
    # use the new-style edit loop.

.. @+node:ekr.20170624151245.531: *7* class FormExpanded
class FormExpanded(form_edit_loop.FormDefaultEditLoop, _FormBase, ):
    BLANK_LINES_BASE   = 1
    OK_BUTTON_BR_OFFSET = (1,6)
    #use the old-style edit loop


    
    
    
.. @+node:ekr.20170624151245.532: *7* class TitleForm
class TitleForm(Form):
    """A form without a box, just a title line"""
    BLANK_LINES_BASE    = 1
    DEFAULT_X_OFFSET    = 1
    DEFAULT_NEXTRELY    = 1
    BLANK_COLUMNS_RIGHT = 0
    OK_BUTTON_BR_OFFSET = (1,6)
    #OKBUTTON_TYPE = button.MiniButton
    #DEFAULT_X_OFFSET = 1
    @others
.. @+node:ekr.20170624151245.533: *8* draw_form
def draw_form(self):
    MAXY, MAXX = self.curses_pad.getmaxyx()
    self.curses_pad.hline(0, 0, curses.ACS_HLINE, MAXX) 
    self.draw_title_and_help()
    
.. @+node:ekr.20170624151245.534: *7* class TitleFooterForm
class TitleFooterForm(TitleForm):
    BLANK_LINES_BASE=1
    @others
.. @+node:ekr.20170624151245.535: *8* draw_form
def draw_form(self):
    MAXY, MAXX = self.curses_pad.getmaxyx()

    if self.editing:
        self.curses_pad.hline(MAXY-1, 0, curses.ACS_HLINE, 
                MAXX - self.__class__.OK_BUTTON_BR_OFFSET[1] - 1)
    else:
        self.curses_pad.hline(MAXY-1, 0, curses.ACS_HLINE, MAXX-1)

    super(TitleFooterForm, self).draw_form()

.. @+node:ekr.20170624151245.536: *7* class SplitForm
class SplitForm(Form):
    MOVE_LINE_ON_RESIZE = False
    """Just the same as the Title Form, but with a horizontal line"""
    @others
.. @+node:ekr.20170624151245.537: *8* __init__
def __init__(self, draw_line_at=None, *args, **keywords):
    super(SplitForm, self).__init__(*args, **keywords)
    if not hasattr(self, 'draw_line_at'):
        if draw_line_at != None:
            self.draw_line_at = draw_line_at
        else:
            self.draw_line_at = self.get_half_way()

.. @+node:ekr.20170624151245.538: *8* draw_form
def draw_form(self,):
    MAXY, MAXX = self.curses_pad.getmaxyx()
    super(SplitForm, self).draw_form()
    self.curses_pad.hline(self.draw_line_at, 1, curses.ACS_HLINE, MAXX-2)

.. @+node:ekr.20170624151245.539: *8* get_half_way
def get_half_way(self):
    return self.curses_pad.getmaxyx()[0] // 2

.. @+node:ekr.20170624151245.540: *8* resize
def resize(self):
    super(SplitForm, self).resize()
    if self.MOVE_LINE_ON_RESIZE:
        self.draw_line_at = self.get_half_way()


.. @+node:ekr.20170624151245.541: *7* blank_terminal
def blank_terminal():
    F = _FormBase(framed=False)
    F.erase()
    F.display()


.. @+node:ekr.20170624151245.542: *6* @file ../external/npyscreen/fmFormMultiPage.py
## Very, very experimental. Do NOT USE.
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.543: *7* Declarations
import curses
from .         import fmForm
from .wgwidget import NotEnoughSpaceForWidget
from .         import wgNMenuDisplay


.. @+node:ekr.20170624151245.544: *7* class FormMultiPage
class FormMultiPage(fmForm.FormBaseNew):
    page_info_pre_pages_display = '[ '
    page_info_post_pages_display = ' ]'
    page_info_pages_name = 'Page'
    page_info_out_of     = 'of'
    @others
.. @+node:ekr.20170624151245.545: *8* __init__
def __init__(self, display_pages=True, pages_label_color='NORMAL', *args, **keywords):
    self.display_pages = display_pages
    self.pages_label_color = pages_label_color
    super(FormMultiPage, self).__init__(*args, **keywords)
    self.switch_page(0)

.. @+node:ekr.20170624151245.546: *8* draw_form
def draw_form(self, *args, **keywords):
    super(FormMultiPage, self).draw_form(*args, **keywords)
    self.display_page_number()

.. @+node:ekr.20170624151245.547: *8* _resize
def _resize(self, *args):
    if not self.ALLOW_RESIZE:
        return False

    if hasattr(self, 'parentApp'):
        self.parentApp.resize()
        
    self._create_screen()
    self.resize()
    for page in self._pages__:
        for w in page:
            w._resize()
    self.DISPLAY()


.. @+node:ekr.20170624151245.548: *8* display_page_number
def display_page_number(self):
    if not self.display_pages:
        return False
        
    if len(self._pages__) > 1:
        display_text = "%s%s %s %s %s%s" % (
            self.page_info_pre_pages_display,
            self.page_info_pages_name,
            self._active_page + 1,
            self.page_info_out_of,
            len(self._pages__),
            self.page_info_post_pages_display,
        )
    # for python2
        if isinstance(display_text, bytes):
            display_text = display_text.decode('utf-8', 'replace')
    
        maxy,maxx = self.curses_pad.getmaxyx()
    
        if (maxx-5) <= len(display_text):
            # then give up.
            return False
    
        self.add_line(
            maxy - 1,
            maxx - len(display_text) - 2,
            display_text,
            self.make_attributes_list(display_text, 
                 curses.A_NORMAL | self.theme_manager.findPair(self, 
                                                              self.pages_label_color)),
            maxx - len(display_text) - 2,
        )
    

.. @+node:ekr.20170624151245.549: *8* add_widget_intelligent
def add_widget_intelligent(self, *args, **keywords):
    try:
        return self.add_widget(*args, **keywords)
    except NotEnoughSpaceForWidget:
        self.add_page()
        return self.add_widget(*args, **keywords)
        

.. @+node:ekr.20170624151245.550: *8* _clear_all_widgets
def _clear_all_widgets(self,):
    super(FormMultiPage, self)._clear_all_widgets()
    self._pages__     = [ [],]
    self._active_page = 0
    self.switch_page(self._active_page, display=False)

.. @+node:ekr.20170624151245.551: *8* switch_page
def switch_page(self, page, display=True):
    self._widgets__ = self._pages__[page]
    self._active_page = page
    self.editw = 0
    if display:
        self.display(clear=True)

.. @+node:ekr.20170624151245.552: *8* add_page
def add_page(self):
    self._pages__.append([])
    page_number   = len(self._pages__)-1
    self.nextrely = self.DEFAULT_NEXTRELY
    self.nextrelx = self.DEFAULT_X_OFFSET
    self.switch_page(page_number, display=False)
    return page_number

.. @+node:ekr.20170624151245.553: *8* find_next_editable
def find_next_editable(self, *args):
    if not self.editw == len(self._widgets__):
        value_changed = False
        if not self.cycle_widgets:
            r = list(range(self.editw+1, len(self._widgets__)))
        else:
            r = list(range(self.editw+1, len(self._widgets__))) + list(range(0, self.editw))
        for n in r:
            if self._widgets__[n].editable and not self._widgets__[n].hidden: 
                self.editw = n
                value_changed = True
                break
        if not value_changed:
            if self._active_page < len(self._pages__)-1:
                self.switch_page(self._active_page + 1)
    self.display()


.. @+node:ekr.20170624151245.554: *8* find_previous_editable
def find_previous_editable(self, *args):
    if self.editw == 0:
        if self._active_page > 0:
            self.switch_page(self._active_page-1)
    
    if not self.editw == 0:     
        # remember that xrange does not return the 'last' value,
        # so go to -1, not 0! (fence post error in reverse)
        for n in range(self.editw-1, -1, -1 ):
            if self._widgets__[n].editable and not self._widgets__[n].hidden: 
                self.editw = n
                break
                
                
.. @+node:ekr.20170624151245.555: *7* class FormMultiPageAction
class FormMultiPageAction(FormMultiPage):
    CANCEL_BUTTON_BR_OFFSET = (2, 12)
    OK_BUTTON_TEXT          = "OK"
    CANCEL_BUTTON_TEXT      = "Cancel"
    
    @others
.. @+node:ekr.20170624151245.556: *8* on_ok
def on_ok(self):
    pass

.. @+node:ekr.20170624151245.557: *8* on_cancel
def on_cancel(self):
    pass

.. @+node:ekr.20170624151245.558: *8* pre_edit_loop
def pre_edit_loop(self):
    self._page_for_buttons = len(self._pages__)-1
    self.switch_page(self._page_for_buttons)
    
    # Add ok and cancel buttons. Will remove later
    tmp_rely, tmp_relx = self.nextrely, self.nextrelx
    
    c_button_text = self.CANCEL_BUTTON_TEXT
    cmy, cmx = self.curses_pad.getmaxyx()
    cmy -= self.__class__.CANCEL_BUTTON_BR_OFFSET[0]
    cmx -= len(c_button_text)+self.__class__.CANCEL_BUTTON_BR_OFFSET[1]
    self.c_button = self.add_widget(self.__class__.OKBUTTON_TYPE, name=c_button_text, rely=cmy, relx=cmx, use_max_space=True)
    self._c_button_postion = len(self._widgets__)-1
    self.c_button.update()
    
    my, mx = self.curses_pad.getmaxyx()
    ok_button_text = self.OK_BUTTON_TEXT
    my -= self.__class__.OK_BUTTON_BR_OFFSET[0]
    mx -= len(ok_button_text)+self.__class__.OK_BUTTON_BR_OFFSET[1]
    self.ok_button = self.add_widget(self.__class__.OKBUTTON_TYPE, name=ok_button_text, rely=my, relx=mx, use_max_space=True)
    self._ok_button_postion = len(self._widgets__)-1
    # End add buttons
    self.nextrely, self.nextrelx = tmp_rely, tmp_relx
    self.switch_page(0)
    
.. @+node:ekr.20170624151245.559: *8* _during_edit_loop
def _during_edit_loop(self):
    if self.ok_button.value or self.c_button.value:
        self.editing = False

    if self.ok_button.value:
        self.ok_button.value = False
        self.edit_return_value = self.on_ok()
    elif self.c_button.value:
        self.c_button.value = False
        self.edit_return_value = self.on_cancel()

.. @+node:ekr.20170624151245.560: *8* resize
def resize(self):
    super(FormMultiPageAction, self).resize()
    self.move_ok_button()
      
.. @+node:ekr.20170624151245.561: *8* move_ok_button
def move_ok_button(self):
    if hasattr(self, 'ok_button'):
        my, mx = self.curses_pad.getmaxyx()
        my -= self.__class__.OK_BUTTON_BR_OFFSET[0]
        mx -= len(self.__class__.OK_BUTTON_TEXT)+self.__class__.OK_BUTTON_BR_OFFSET[1]
        self.ok_button.relx = mx
        self.ok_button.rely = my
    if hasattr(self, 'c_button'):
        c_button_text = self.CANCEL_BUTTON_TEXT
        cmy, cmx = self.curses_pad.getmaxyx()
        cmy -= self.__class__.CANCEL_BUTTON_BR_OFFSET[0]
        cmx -= len(c_button_text)+self.__class__.CANCEL_BUTTON_BR_OFFSET[1]
        self.c_button.rely = cmy
        self.c_button.relx = cmx


.. @+node:ekr.20170624151245.562: *8* post_edit_loop
def post_edit_loop(self):
    self.switch_page(self._page_for_buttons)
    self.ok_button.destroy()
    self.c_button.destroy()
    del self._widgets__[self._ok_button_postion]
    del self.ok_button
    del self._widgets__[self._c_button_postion]
    del self.c_button
    #self.nextrely, self.nextrelx = tmp_rely, tmp_relx
    self.display()
    self.editing = False
    
    return self.edit_return_value


.. @+node:ekr.20170624151245.563: *7* class FormMultiPageWithMenus
class FormMultiPageWithMenus(FormMultiPage, wgNMenuDisplay.HasMenus):
    @others
.. @+node:ekr.20170624151245.564: *8* __init__
def __init__(self, *args, **keywords):
    super(FormMultiPageWithMenus, self).__init__(*args, **keywords)
    self.initialize_menus()

.. @+node:ekr.20170624151245.565: *7* class FormMultiPageActionWithMenus
class FormMultiPageActionWithMenus(FormMultiPageAction, wgNMenuDisplay.HasMenus):
    @others
.. @+node:ekr.20170624151245.566: *8* __init__
def __init__(self, *args, **keywords):
    super(FormMultiPageActionWithMenus, self).__init__(*args, **keywords)
    self.initialize_menus()
.. @+node:ekr.20170624151245.567: *6* @file ../external/npyscreen/fmFormMutt.py
#/usr/bin/env python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.568: *7* Declarations
import curses
from . import fmForm
from . import fmFormWithMenus
from . import wgtextbox
from . import wgmultiline
#import grid
#import editmultiline


.. @+node:ekr.20170624151245.569: *7* class FormMutt
class FormMutt(fmForm.FormBaseNew):
    BLANK_LINES_BASE     = 0
    BLANK_COLUMNS_RIGHT  = 0
    DEFAULT_X_OFFSET = 2
    FRAMED = False
    MAIN_WIDGET_CLASS   = wgmultiline.MultiLine
    MAIN_WIDGET_CLASS_START_LINE = 1
    STATUS_WIDGET_CLASS = wgtextbox.Textfield
    STATUS_WIDGET_X_OFFSET = 0
    COMMAND_WIDGET_CLASS= wgtextbox.Textfield
    COMMAND_WIDGET_NAME = None
    COMMAND_WIDGET_BEGIN_ENTRY_AT = None
    COMMAND_ALLOW_OVERRIDE_BEGIN_ENTRY_AT = True
    #MAIN_WIDGET_CLASS = grid.SimpleGrid
    #MAIN_WIDGET_CLASS = editmultiline.MultiLineEdit
    @others
.. @+node:ekr.20170624151245.570: *8* __init__
def __init__(self, cycle_widgets = True, *args, **keywords):
    super(FormMutt, self).__init__(cycle_widgets=cycle_widgets, *args, **keywords)


.. @+node:ekr.20170624151245.571: *8* draw_form
def draw_form(self):
    MAXY, MAXX = self.lines, self.columns #self.curses_pad.getmaxyx()
    self.curses_pad.hline(0, 0, curses.ACS_HLINE, MAXX-1)  
    self.curses_pad.hline(MAXY-2-self.BLANK_LINES_BASE, 0, curses.ACS_HLINE, MAXX-1)  

.. @+node:ekr.20170624151245.572: *8* create
def create(self):
    ### MAXY, MAXX    = self.lines, self.columns
    MAXY = self.lines
    
    self.wStatus1 = self.add(self.__class__.STATUS_WIDGET_CLASS,  rely=0, 
                                    relx=self.__class__.STATUS_WIDGET_X_OFFSET,
                                    editable=False,  
                                    )
    
    if self.__class__.MAIN_WIDGET_CLASS:
        self.wMain    = self.add(self.__class__.MAIN_WIDGET_CLASS,    
                                        rely=self.__class__.MAIN_WIDGET_CLASS_START_LINE,  
                                        relx=0,     max_height = -2,
                                        )
    self.wStatus2 = self.add(self.__class__.STATUS_WIDGET_CLASS,  rely=MAXY-2-self.BLANK_LINES_BASE, 
                                    relx=self.__class__.STATUS_WIDGET_X_OFFSET,
                                    editable=False,  
                                    )
    
    if not self.__class__.COMMAND_WIDGET_BEGIN_ENTRY_AT:
        self.wCommand = self.add(self.__class__.COMMAND_WIDGET_CLASS, name=self.__class__.COMMAND_WIDGET_NAME,
                                rely = MAXY-1-self.BLANK_LINES_BASE, relx=0,)
    else:
        self.wCommand = self.add(
            self.__class__.COMMAND_WIDGET_CLASS, name=self.__class__.COMMAND_WIDGET_NAME,
                                rely = MAXY-1-self.BLANK_LINES_BASE, relx=0,
                                begin_entry_at = self.__class__.COMMAND_WIDGET_BEGIN_ENTRY_AT,
                                allow_override_begin_entry_at = self.__class__.COMMAND_ALLOW_OVERRIDE_BEGIN_ENTRY_AT
                                )
        
    self.wStatus1.important = True
    self.wStatus2.important = True
    self.nextrely = 2

.. @+node:ekr.20170624151245.573: *8* h_display
def h_display(self, input):
    super(FormMutt, self).h_display(input)
    if hasattr(self, 'wMain'):
        if not self.wMain.hidden:
            self.wMain.display()
    
.. @+node:ekr.20170624151245.574: *8* resize
def resize(self):
    super(FormMutt, self).resize()
    ### MAXY, MAXX    = self.lines, self.columns
    MAXY = self.lines
    self.wStatus2.rely = MAXY-2-self.BLANK_LINES_BASE
    self.wCommand.rely = MAXY-1-self.BLANK_LINES_BASE

.. @+node:ekr.20170624151245.575: *7* class FormMuttWithMenus
class FormMuttWithMenus(FormMutt, fmFormWithMenus.FormBaseNewWithMenus):
    @others
.. @+node:ekr.20170624151245.576: *8* __init__
def __init__(self, *args, **keywords):
    super(FormMuttWithMenus, self).__init__(*args, **keywords)
    self.initialize_menus()
.. @+node:ekr.20170624151245.577: *6* @file ../external/npyscreen/fmFormMuttActive.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.578: *7* Declarations
import weakref
import re
import curses
import collections
from . import fmFormMutt
from . import fmFormWithMenus
from . import npysNPSFilteredData
from . import wgtextbox

# This file defines Action Controllers
# and Widgets
# and Forms


##########################################################################################
# Action Controllers
##########################################################################################

.. @+node:ekr.20170624151245.579: *7* class ActionControllerSimple
class ActionControllerSimple(object):
    @others
##########################################################################################
# Widgets
##########################################################################################

.. @+node:ekr.20170624151245.580: *8* __init__
def __init__(self, parent=None):
    try:
        self.parent = weakref.proxy(parent)
    except Exception:
        self.parent = parent
    self._action_list = []
    self.create()

.. @+node:ekr.20170624151245.581: *8* create
def create(self):
    pass

.. @+node:ekr.20170624151245.582: *8* add_action
def add_action(self, ident, function, live):
    ident = re.compile(ident)
    self._action_list.append({'identifier': ident, 
                              'function': function, 
                              'live': live 
                              })

.. @+node:ekr.20170624151245.583: *8* process_command_live
def process_command_live(self, command_line, control_widget_proxy):
    for a in self._action_list:
        if a['identifier'].match(command_line) and a['live']==True:
            a['function'](command_line, control_widget_proxy, live=True)
            
.. @+node:ekr.20170624151245.584: *8* process_command_complete
def process_command_complete(self, command_line, control_widget_proxy):
    for a in self._action_list:
        if a['identifier'].match(command_line):
            a['function'](command_line, control_widget_proxy, live=False)


.. @+node:ekr.20170624151245.585: *7* class TextCommandBox
class TextCommandBox(wgtextbox.Textfield):
    @others
.. @+node:ekr.20170624151245.586: *8* __init__
def __init__(self, screen, 
                history=False, 
                history_max=100, 
                set_up_history_keys=False,
                *args, **keywords):
    super(TextCommandBox, self).__init__(screen, *args, **keywords)
    self.history = history
    self._history_store = collections.deque(maxlen=history_max)        
    self._current_history_index = False
    self._current_command = None
    if set_up_history_keys:
        self.set_up_history_keys()
    
    # History functions currently not complete.
    
.. @+node:ekr.20170624151245.587: *8* set_up_handlers
def set_up_handlers(self):
    '''TextCommandBox.set_up_handlers.'''
    super(TextCommandBox, self).set_up_handlers()
    self.handlers.update({
       curses.ascii.NL:     self.h_execute_command,
       curses.ascii.CR:     self.h_execute_command,
    })

.. @+node:ekr.20170624151245.588: *8* set_up_history_keys
def set_up_history_keys(self):
    '''ActionControllerSimple.set_up_history_keys'''
    self.handlers.update({
        "^P":   self.h_get_previous_history,
        "^N":   self.h_get_next_history,
        curses.KEY_UP: self.h_get_previous_history,
        curses.KEY_DOWN: self.h_get_next_history,
    })

.. @+node:ekr.20170624151245.589: *8* h_get_previous_history
def h_get_previous_history(self, ch):
    if self._current_history_index is False:
        self._current_command = self.value
        _current_history_index = -1
    else:
        _current_history_index = self._current_history_index - 1
    try:
        self.value = self._history_store[_current_history_index]
    except IndexError:
        return True
    self.cursor_position = len(self.value)
    self._current_history_index = _current_history_index
    self.display()

.. @+node:ekr.20170624151245.590: *8* h_get_next_history
def h_get_next_history(self, ch):
    if self._current_history_index is False:
        return True
    elif self._current_history_index == -1:
        self.value = self._current_command
        self._current_history_index = False
        self.cursor_position = len(self.value)
        self.display()
        return True
    else:
        _current_history_index = self._current_history_index + 1
    try:
        self.value = self._history_store[_current_history_index]
    except IndexError:
        return True
    self.cursor_position = len(self.value)
    self._current_history_index = _current_history_index
    self.display()

.. @+node:ekr.20170624151245.591: *8* h_execute_command
def h_execute_command(self, *args, **keywords):
    if self.history:
        self._history_store.append(self.value)
        self._current_history_index = False
    self.parent.action_controller.process_command_complete(self.value, weakref.proxy(self))
    self.value = ''
    
.. @+node:ekr.20170624151245.592: *8* when_value_edited
def when_value_edited(self):
    super(TextCommandBox, self).when_value_edited()
    if self.editing:
        self.parent.action_controller.process_command_live(self.value, weakref.proxy(self))
    else:
        self.parent.action_controller.process_command_complete(self.value, weakref.proxy(self))

.. @+node:ekr.20170624151245.593: *7* class TextCommandBoxTraditional
class TextCommandBoxTraditional(TextCommandBox):
    # EXPERIMENTAL
    # WILL PASS INPUT TO A LINKED WIDGET - THE LINKED WIDGET
    # UNLESS PUT IN TO COMMAND LINE MODE BY THE ENTRY OF BEGINNING_OF_COMMAND_LINE_CHARS
    # WILL NEED TO BE ALTERED TO LOOK AS IF IT IS BEING EDITED TOO.
    BEGINNING_OF_COMMAND_LINE_CHARS = (":", "/")
    @others
##########################################################################################
# Form Classes
##########################################################################################

.. @+node:ekr.20170624151245.594: *8* __init__
def __init__(self, screen,
                history=True, 
                history_max=100, 
                set_up_history_keys=True,
                *args, **keywords):
    super(TextCommandBoxTraditional, self).__init__(screen,
     history=history,
     history_max=history_max, 
     set_up_history_keys=set_up_history_keys,
     *args, **keywords
    )
    self.linked_widget = None
    self.always_pass_to_linked_widget = []

.. @+node:ekr.20170624151245.595: *8* ActionControllerSimple.handle_input
def handle_input(self, inputch):
    try:
        inputchstr = chr(inputch)
    except Exception:
        inputchstr = False
    
    try:
        input_unctrl = curses.ascii.unctrl(inputch)
    except TypeError:
        input_unctrl = False
        
    if not self.linked_widget:
        return super(TextCommandBoxTraditional, self).handle_input(inputch)
    
    if (inputch in self.always_pass_to_linked_widget) or \
        (inputchstr in self.always_pass_to_linked_widget) or \
        (input_unctrl in self.always_pass_to_linked_widget):
        rtn = self.linked_widget.handle_input(inputch)
        self.linked_widget.update()
        return rtn

    if inputchstr and (self.value == '' or self.value == None):
        if inputchstr in self.BEGINNING_OF_COMMAND_LINE_CHARS or \
            inputch in self.BEGINNING_OF_COMMAND_LINE_CHARS:
            return super(TextCommandBoxTraditional, self).handle_input(inputch)
        
    if self.value:
        return super(TextCommandBoxTraditional, self).handle_input(inputch)
    
    rtn = self.linked_widget.handle_input(inputch)
    self.linked_widget.update()
    return rtn


.. @+node:ekr.20170624151245.596: *7* class FormMuttActive
class FormMuttActive(fmFormMutt.FormMutt):
    DATA_CONTROLER    = npysNPSFilteredData.NPSFilteredDataList
    ACTION_CONTROLLER  = ActionControllerSimple
    COMMAND_WIDGET_CLASS = TextCommandBox
    @others
.. @+node:ekr.20170624151245.597: *8* __init__
def __init__(self, *args, **keywords):
    # first create action_controller, so that the create methods
    # of forms can use it.
    self.action_controller = self.ACTION_CONTROLLER(parent=self)
    # then call the superclass init method.
    super(FormMuttActive, self).__init__(*args, **keywords)
    self.set_value(self.DATA_CONTROLER())
    

.. @+node:ekr.20170624151245.598: *7* class FormMuttActiveWithMenus
class FormMuttActiveWithMenus(FormMuttActive, fmFormWithMenus.FormBaseNewWithMenus):
    @others
.. @+node:ekr.20170624151245.599: *8* __init__
def __init__(self, *args, **keywords):
    super(FormMuttActiveWithMenus, self).__init__(*args, **keywords)
    self.initialize_menus()
    
.. @+node:ekr.20170624151245.600: *7* class FormMuttActiveTraditional
class FormMuttActiveTraditional(fmFormMutt.FormMutt):
    DATA_CONTROLER    = npysNPSFilteredData.NPSFilteredDataList
    ACTION_CONTROLLER  = ActionControllerSimple
    COMMAND_WIDGET_CLASS = TextCommandBoxTraditional
    @others
.. @+node:ekr.20170624151245.601: *8* __init__
def __init__(self, *args, **keywords):
    # First create action_controller so that create methods of forms 
    # can use it.
    self.action_controller        = self.ACTION_CONTROLLER(parent=self)
    super(FormMuttActiveTraditional, self).__init__(*args, **keywords)
    self.set_value(self.DATA_CONTROLER())
    self.wCommand.linked_widget   = self.wMain
    self.wMain.editable           = False
    self.wMain.always_show_cursor = True
    
    # special mouse handling
    self.wMain.interested_in_mouse_even_when_not_editable = True

.. @+node:ekr.20170624151245.602: *7* class FormMuttActiveTraditionalWithMenus
class FormMuttActiveTraditionalWithMenus(FormMuttActiveTraditional, 
 fmFormWithMenus.FormBaseNewWithMenus):
    @others
.. @+node:ekr.20170624151245.603: *8* __init__
def __init__(self, *args, **keywords):
    super(FormMuttActiveTraditionalWithMenus, self).__init__(*args, **keywords)
    self.initialize_menus()
.. @+node:ekr.20170624151245.604: *6* @file ../external/npyscreen/fmFormWithMenus.py
#!/usr/bin/env python
# encoding: utf-8
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.605: *7* Declarations
import curses
from . import fmForm
from . import fmActionForm
from . import fmActionFormV2
from . import wgNMenuDisplay

.. @+node:ekr.20170624151245.606: *7* class FormBaseNewWithMenus
class FormBaseNewWithMenus(fmForm.FormBaseNew, wgNMenuDisplay.HasMenus):
    """The FormBaseNew class, but with a handling system for menus as well.  See the HasMenus class for details."""
    @others
.. @+node:ekr.20170624151245.607: *8* __init__
def __init__(self, *args, **keywords):
    super(FormBaseNewWithMenus, self).__init__(*args, **keywords)
    self.initialize_menus()

.. @+node:ekr.20170624151245.608: *8* display_menu_advert_at
def display_menu_advert_at(self):
    return self.lines-1, 1

.. @+node:ekr.20170624151245.609: *8* draw_form
def draw_form(self):
    super(FormBaseNewWithMenus, self).draw_form()
    menu_advert = " " + self.__class__.MENU_KEY + ": Menu "
    if isinstance(menu_advert, bytes):
        menu_advert = menu_advert.decode('utf-8', 'replace')
    y, x = self.display_menu_advert_at()
    self.add_line(y, x, 
        menu_advert, 
        self.make_attributes_list(menu_advert, curses.A_NORMAL),
        self.columns - x - 1
        )


.. @+node:ekr.20170624151245.610: *7* class FormWithMenus
class FormWithMenus(fmForm.Form, wgNMenuDisplay.HasMenus):
    """The Form class, but with a handling system for menus as well.  See the HasMenus class for details."""
    @others
# The following class does not inherit from FormWithMenus and so some code is duplicated.  
# The pig is getting to inherit edit() from ActionForm, but draw_form from FormWithMenus
.. @+node:ekr.20170624151245.611: *8* __init__
def __init__(self, *args, **keywords):
    super(FormWithMenus, self).__init__(*args, **keywords)
    self.initialize_menus()

.. @+node:ekr.20170624151245.612: *8* display_menu_advert_at
def display_menu_advert_at(self):
    return self.lines-1, 1

.. @+node:ekr.20170624151245.613: *8* draw_form
def draw_form(self):
    super(FormWithMenus, self).draw_form()
    menu_advert = " " + self.__class__.MENU_KEY + ": Menu "
    y, x = self.display_menu_advert_at()
    if isinstance(menu_advert, bytes):
        menu_advert = menu_advert.decode('utf-8', 'replace')
    self.add_line(y, x, 
        menu_advert, 
        self.make_attributes_list(menu_advert, curses.A_NORMAL),
        self.columns - x - 1
        )

.. @+node:ekr.20170624151245.614: *7* class ActionFormWithMenus
class ActionFormWithMenus(fmActionForm.ActionForm, wgNMenuDisplay.HasMenus):
    @others
.. @+node:ekr.20170624151245.615: *8* __init__
def __init__(self, *args, **keywords):
    super(ActionFormWithMenus, self).__init__(*args, **keywords)
    self.initialize_menus()

.. @+node:ekr.20170624151245.616: *8* display_menu_advert_at
def display_menu_advert_at(self):
    return self.lines-1, 1

.. @+node:ekr.20170624151245.617: *8* draw_form
def draw_form(self):
    super(ActionFormWithMenus, self).draw_form()
    menu_advert = " " + self.__class__.MENU_KEY + ": Menu "
    y, x = self.display_menu_advert_at()
    
    if isinstance(menu_advert, bytes):
        menu_advert = menu_advert.decode('utf-8', 'replace')
    self.add_line(y, x, 
        menu_advert, 
        self.make_attributes_list(menu_advert, curses.A_NORMAL),
        self.columns - x - 1
        )

.. @+node:ekr.20170624151245.618: *7* class ActionFormV2WithMenus
class ActionFormV2WithMenus(fmActionFormV2.ActionFormV2, wgNMenuDisplay.HasMenus):
    @others
.. @+node:ekr.20170624151245.619: *8* __init__
def __init__(self, *args, **keywords):
    super(ActionFormV2WithMenus, self).__init__(*args, **keywords)
    self.initialize_menus()


    
.. @+node:ekr.20170624151245.620: *7* class SplitFormWithMenus
class SplitFormWithMenus(fmForm.SplitForm, FormWithMenus):
    """Just the same as the Title Form, but with a horizontal line"""
    @others
.. @+node:ekr.20170624151245.621: *8* draw_form
def draw_form(self):
    super(SplitFormWithMenus, self).draw_form()

.. @+node:ekr.20170624151245.622: *6* @file ../external/npyscreen/fmPopup.py
#!/usr/bin/python
# encoding: utf-8

@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.623: *7* Declarations
from . import fmForm
from . import fmActionFormV2
# import curses


.. @+node:ekr.20170624151245.624: *7* class Popup
class Popup(fmForm.Form):
    DEFAULT_LINES      = 12
    DEFAULT_COLUMNS    = 60
    SHOW_ATX           = 10
    SHOW_ATY           = 2
        
.. @+node:ekr.20170624151245.625: *7* class ActionPopup
class ActionPopup(fmActionFormV2.ActionFormV2):
    DEFAULT_LINES      = 12
    DEFAULT_COLUMNS    = 60
    SHOW_ATX           = 10
    SHOW_ATY           = 2
    
    
.. @+node:ekr.20170624151245.626: *7* class MessagePopup
class MessagePopup(Popup):
    @others
.. @+node:ekr.20170624151245.627: *8* __init__
def __init__(self, *args, **keywords):
    from . import wgmultiline as multiline 
    super(MessagePopup, self).__init__(*args, **keywords)
    self.TextWidget = self.add(multiline.Pager, scroll_exit=True, max_height=self.widget_useable_space()[0]-2)
    
.. @+node:ekr.20170624151245.628: *7* class PopupWide
class PopupWide(Popup):
    DEFAULT_LINES      = 14
    DEFAULT_COLUMNS    = None
    SHOW_ATX           = 0
    SHOW_ATY           = 0
        
.. @+node:ekr.20170624151245.629: *7* class ActionPopupWide
class ActionPopupWide(fmActionFormV2.ActionFormV2):
    DEFAULT_LINES      = 14
    DEFAULT_COLUMNS    = None
    SHOW_ATX           = 0
    SHOW_ATY           = 0
.. @+node:ekr.20170624151245.630: *6* @file ../external/npyscreen/globals.py
#!/usr/bin/env python

@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.631: *7* Declarations
DEBUG = False
DISABLE_RESIZE_SYSTEM = False
.. @+node:ekr.20170624151245.632: *6* @file ../external/npyscreen/muMenu.py
#!/usr/bin/python
# encoding: utf-8

@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.633: *7* Declarations
# import sys
# import os
from . import wgmultiline
from . import fmForm
# import weakref


.. @+node:ekr.20170624151245.634: *7* class Menu
class Menu(object):
    "This class is obsolete and Depricated.  Use NewMenu instead."

    @others
.. @+node:ekr.20170624151245.635: *8* __init__
def __init__(self, name=None, show_atx=None, show_aty=None):
    self.__menu_items = []
    self.name = name
    self.__show_atx = show_atx
    self.__show_aty = show_aty
    
.. @+node:ekr.20170624151245.636: *8* before_item_select
def before_item_select(self):
    pass
    
.. @+node:ekr.20170624151245.637: *8* add_item
def add_item(self, text, func):
    self.__menu_items.append((text, func))

.. @+node:ekr.20170624151245.638: *8* set_menu
def set_menu(self, pairs):
    """Pass in a list of pairs of text labels and functions"""
    self.__menu_items = []
    for pair in pairs:
        self.add_item(pair[0], pair[1])
    
.. @+node:ekr.20170624151245.639: *8* edit
def edit(self, *args, **keywords):
    """Display choice to user, execute function associated"""
    
    menu_text = [x[0] for x in self.__menu_items]
    
    longest_text = 0
    #Slightly different layout if we are showing a title
    if self.name: longest_text=len(self.name)+2
    for item in menu_text: 
        if len(item) > longest_text:
            longest_text = len(item)
    
    height = len(menu_text)
    if self.name:
        height +=3
    else:
        height +=2
    
    if height > 14: 
        height = 13
    
    atx = self.__show_atx or 20
    aty = self.__show_aty or 2
    
    popup = fmForm.Form(name=self.name, 
        lines=height, columns=longest_text+4,
            show_aty=aty, show_atx=atx, )
    if not self.name: popup.nextrely = 1
    l = popup.add(wgmultiline.MultiLine, 
                    values=menu_text, 
                    #exit_left=True,
                    return_exit=True)
    
    popup.display()
    l.edit()
    if l.value is not None:
        self.before_item_select()
        self.__menu_items[l.value][1]()

.. @+node:ekr.20170624151245.640: *6* @file ../external/npyscreen/muNewMenu.py
#!/usr/bin/env python
# encoding: utf-8
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.641: *7* Declarations
import weakref


.. @+node:ekr.20170624151245.642: *7* class NewMenu
class NewMenu(object):
    """docstring for NewMenu"""
    @others
.. @+node:ekr.20170624151245.643: *8* __init__
def __init__(self, name=None, shortcut=None, preDisplayFunction=None, pdfuncArguments=None, pdfuncKeywords=None):
    self.name      = name
    self._menuList = []
    self.enabled   = True
    self.shortcut  = shortcut
    self.pre_display_function = preDisplayFunction
    self.pdfunc_arguments= pdfuncArguments or ()
    self.pdfunc_keywords = pdfuncKeywords  or {}

.. @+node:ekr.20170624151245.644: *8* addItemsFromList
def addItemsFromList(self, item_list):
    for l in item_list:
        if isinstance(l, MenuItem):
            self.addNewSubmenu(*l)
        else:
            self.addItem(*l)

.. @+node:ekr.20170624151245.645: *8* addItem
def addItem(self, *args, **keywords):
    _itm = MenuItem(*args, **keywords)
    self._menuList.append(_itm)

.. @+node:ekr.20170624151245.646: *8* addSubmenu
def addSubmenu(self, submenu):
    "Not recommended. Use addNewSubmenu instead"
    # _itm = submenu
    self._menuList.append(submenu)

.. @+node:ekr.20170624151245.647: *8* addNewSubmenu
def addNewSubmenu(self, *args, **keywords):
    _mnu = NewMenu(*args, **keywords)
    self._menuList.append(_mnu)
    return weakref.proxy(_mnu)

.. @+node:ekr.20170624151245.648: *8* getItemObjects
def getItemObjects(self):
    return [itm for itm in self._menuList if itm.enabled]

.. @+node:ekr.20170624151245.649: *8* do_pre_display_function
def do_pre_display_function(self):
    if self.pre_display_function:
        return self.pre_display_function(*self.pdfunc_arguments, **self.pdfunc_keywords)

.. @+node:ekr.20170624151245.650: *7* class MenuItem
class MenuItem(object):
    """docstring for MenuItem"""
    @others
.. @+node:ekr.20170624151245.651: *8* __init__
def __init__(self, text='', onSelect=None, shortcut=None, document=None, arguments=None, keywords=None):
    self.setText(text)
    self.setOnSelect(onSelect)
    self.setDocumentation(document)
    self.shortcut = shortcut
    self.enabled = True
    self.arguments = arguments or ()
    self.keywords = keywords or {}
    
.. @+node:ekr.20170624151245.652: *8* setText
def setText(self, text):
    self._text = text
    
.. @+node:ekr.20170624151245.653: *8* getText
def getText(self):
    return self._text

.. @+node:ekr.20170624151245.654: *8* setOnSelect
def setOnSelect(self, onSelect):
    self.onSelectFunction = onSelect
    
.. @+node:ekr.20170624151245.655: *8* setDocumentation
def setDocumentation(self, document):
    self._help = document

.. @+node:ekr.20170624151245.656: *8* getDocumentation
def getDocumentation(self):
    return self._help

.. @+node:ekr.20170624151245.657: *8* getHelp
def getHelp(self):
    return self._help

.. @+node:ekr.20170624151245.658: *8* do
def do(self):
    if self.onSelectFunction:
        return self.onSelectFunction(*self.arguments, **self.keywords)
.. @+node:ekr.20170624151245.659: *6* @file ../external/npyscreen/npysGlobalOptions.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.660: *7* Declarations
DISABLE_ALL_COLORS = False
ASCII_ONLY         = False # See the safe_string function in wgwidget.  At the moment the encoding is not safe
.. @+node:ekr.20170624151245.661: *6* @file ../external/npyscreen/npysNPSFilteredData.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.662: *7* class NPSFilteredDataBase
class NPSFilteredDataBase(object):
    @others
.. @+node:ekr.20170624151245.663: *8* __init__
def __init__(self, values=None):
    self._values  = None
    self._filter  = None
    self._filtered_values = None
    self.set_values(values)

.. @+node:ekr.20170624151245.664: *8* set_values
def set_values(self, value):
    self._values = value

.. @+node:ekr.20170624151245.665: *8* get_all_values
def get_all_values(self):
    return self._values

.. @+node:ekr.20170624151245.666: *8* set_filter
def set_filter(self, this_filter):
    self._filter = this_filter
    self._apply_filter()

.. @+node:ekr.20170624151245.667: *8* filter_data
def filter_data(self):
    # should set self._filtered_values to the filtered values
    raise Exception("You need to define the way the filter operates")

.. @+node:ekr.20170624151245.668: *8* get
def get(self):
    self._apply_filter()
    return self._filtered_values

.. @+node:ekr.20170624151245.669: *8* _apply_filter
def _apply_filter(self):
    # Could do some caching here - but the default definition does not.
    self._filtered_values = self.filter_data()
        
.. @+node:ekr.20170624151245.670: *7* class NPSFilteredDataList
class NPSFilteredDataList(NPSFilteredDataBase):
    @others
.. @+node:ekr.20170624151245.671: *8* filter_data
def filter_data(self):
    if self._filter and self.get_all_values():
        return [x for x in self.get_all_values() if self._filter in x]
    else:
        return self.get_all_values()


.. @+node:ekr.20170624151245.672: *6* @file ../external/npyscreen/npyspmfuncs.py
#!/usr/bin/python

@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.673: *7* Declarations
import curses
import os

.. @+node:ekr.20170624151245.674: *7* class ResizeError
class ResizeError(Exception):
    "The screen has been resized"
    
.. @+node:ekr.20170624151245.675: *7* hidecursor
def hidecursor():
    try:
        curses.curs_set(0)
    except Exception:
        pass

.. @+node:ekr.20170624151245.676: *7* showcursor
def showcursor():
    try:
        curses.curs_set(1)
    except Exception:
        pass

.. @+node:ekr.20170624151245.677: *7* CallSubShell
def CallSubShell(subshell):
    """Call this function if you need to execute an external command in a subshell (os.system).  All the usual warnings apply -- the command line will be
    expanded by the shell, so make sure it is safe before passing it to this function."""
    curses.def_prog_mode()
    #curses.endwin() # Probably causes a memory leak.
    
    rtn = os.system("%s" % (subshell))
    curses.reset_prog_mode()
    if rtn is not 0: return False
    else: return True

    curses.reset_prog_mode()

hide_cursor = hidecursor
show_cursor = showcursor
.. @+node:ekr.20170624151245.678: *6* @file ../external/npyscreen/npyssafewrapper.py
#!/usr/bin/env python
# encoding: utf-8
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.679: *7* Declarations
import curses
# import _curses
#import curses.wrapper
import locale
import os
#import pty
import subprocess
import sys
import warnings

_NEVER_RUN_INITSCR = True
_SCREEN = None

.. @+node:ekr.20170624151245.680: *7* wrapper_basic
def wrapper_basic(call_function):
    #set the locale properly
    locale.setlocale(locale.LC_ALL, '')
    return curses.wrapper(call_function)

#def wrapper(call_function):
#   locale.setlocale(locale.LC_ALL, '')
#   screen = curses.initscr()
#   curses.noecho()
#   curses.cbreak()
#   
#   return_code = call_function(screen)
#   
#   curses.nocbreak()
#   curses.echo()
#   curses.endwin()

.. @+node:ekr.20170624151245.681: *7* wrapper
def wrapper(call_function, fork=None, reset=True):
    global _NEVER_RUN_INITSCR
    if fork:
        wrapper_fork(call_function, reset=reset)
    elif fork == False:
        wrapper_no_fork(call_function)
    else:
        if _NEVER_RUN_INITSCR:
            wrapper_no_fork(call_function)
        else:
            wrapper_fork(call_function, reset=reset)

.. @+node:ekr.20170624151245.682: *7* wrapper_fork
def wrapper_fork(call_function, reset=True):
    pid = os.fork()
    if pid:
        # Parent
        os.waitpid(pid, 0)
        if reset:
            external_reset()
    else:
        locale.setlocale(locale.LC_ALL, '')
        _SCREEN = curses.initscr()
        try:
            curses.start_color()
        except Exception:
            pass
        _SCREEN.keypad(1)
        curses.noecho()
        curses.cbreak()
        curses.def_prog_mode()
        curses.reset_prog_mode()
        ### return_code = call_function(_SCREEN)
        call_function(_SCREEN)
        _SCREEN.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()
        sys.exit(0)

.. @+node:ekr.20170624151245.683: *7* external_reset
def external_reset():
    subprocess.call(['reset', '-Q'])
    
.. @+node:ekr.20170624151245.684: *7* wrapper_no_fork
def wrapper_no_fork(call_function, reset=False):
    global _NEVER_RUN_INITSCR
    if not _NEVER_RUN_INITSCR:
        warnings.warn("""Repeated calls of endwin may cause a memory leak. Use wrapper_fork to avoid.""")
    global _SCREEN
    return_code = None
    if _NEVER_RUN_INITSCR:
        _NEVER_RUN_INITSCR = False
        locale.setlocale(locale.LC_ALL, '')
        _SCREEN = curses.initscr()
        try:
            curses.start_color()
        except Exception:
            pass
        curses.noecho()
        curses.cbreak()
        _SCREEN.keypad(1)

    curses.noecho()
    curses.cbreak()
    _SCREEN.keypad(1)
    
    try:
        return_code = call_function(_SCREEN)    
    finally:
        _SCREEN.keypad(0)
        curses.echo()
        curses.nocbreak()
        # Calling endwin() and then refreshing seems to cause a memory leak.
        curses.endwin()
        if reset:
            external_reset()
    return return_code  
.. @+node:ekr.20170624151245.685: *6* @file ../external/npyscreen/npysThemeManagers.py
#!/usr/bin/env python
# encoding: utf-8
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.686: *7* Declarations
import curses
from . import npysGlobalOptions

.. @+node:ekr.20170624151245.687: *7* disableColor
def disableColor():
    npysGlobalOptions.DISABLE_ALL_COLORS = True

.. @+node:ekr.20170624151245.688: *7* enableColor
def enableColor():
    npysGlobalOptions.DISABLE_ALL_COLORS = False

.. @+node:ekr.20170624151245.689: *7* class ThemeManager
class ThemeManager(object):
    # a tuple with (color_number, (r, g, b))
    # you can use this to redefine colour values.
    # This will only work on compatible terminals.
    # Betware that effects will last beyond the end of the 
    # application.
    _color_values = ( 
        #(curses.COLOR_GREEN, (150,250,100)), 
    )
    
    
    _colors_to_define = ( 
     # DO NOT DEFINE THE WHITE_BLACK COLOR - THINGS BREAK
     #('WHITE_BLACK',      DO_NOT_DO_THIS,      DO_NOT_DO_THIS),
     ('BLACK_WHITE',      curses.COLOR_BLACK,      curses.COLOR_WHITE),
     #('BLACK_ON_DEFAULT', curses.COLOR_BLACK,      -1),
     #('WHITE_ON_DEFAULT', curses.COLOR_WHITE,      -1),
     ('BLUE_BLACK',       curses.COLOR_BLUE,       curses.COLOR_BLACK),
     ('CYAN_BLACK',       curses.COLOR_CYAN,       curses.COLOR_BLACK),
     ('GREEN_BLACK',      curses.COLOR_GREEN,      curses.COLOR_BLACK),
     ('MAGENTA_BLACK',    curses.COLOR_MAGENTA,    curses.COLOR_BLACK),
     ('RED_BLACK',        curses.COLOR_RED,        curses.COLOR_BLACK),
     ('YELLOW_BLACK',     curses.COLOR_YELLOW,     curses.COLOR_BLACK),
     ('BLACK_RED',        curses.COLOR_BLACK,      curses.COLOR_RED),
     ('BLACK_GREEN',      curses.COLOR_BLACK,      curses.COLOR_GREEN),
     ('BLACK_YELLOW',     curses.COLOR_BLACK,      curses.COLOR_YELLOW),
     ('BLACK_CYAN',       curses.COLOR_BLACK,       curses.COLOR_CYAN),
     ('BLUE_WHITE',       curses.COLOR_BLUE,       curses.COLOR_WHITE),
     ('CYAN_WHITE',       curses.COLOR_CYAN,       curses.COLOR_WHITE),
     ('GREEN_WHITE',      curses.COLOR_GREEN,      curses.COLOR_WHITE),
     ('MAGENTA_WHITE',    curses.COLOR_MAGENTA,    curses.COLOR_WHITE),
     ('RED_WHITE',        curses.COLOR_RED,        curses.COLOR_WHITE),
     ('YELLOW_WHITE',     curses.COLOR_YELLOW,     curses.COLOR_WHITE),
)
    
    default_colors = {
        'DEFAULT'     : 'WHITE_BLACK',
        'FORMDEFAULT' : 'WHITE_BLACK',
        'NO_EDIT'     : 'BLUE_BLACK',
        'STANDOUT'    : 'CYAN_BLACK',
        'CURSOR'      : 'WHITE_BLACK',
        'CURSOR_INVERSE': 'BLACK_WHITE',
        'LABEL'       : 'GREEN_BLACK',
        'LABELBOLD'   : 'WHITE_BLACK',
        'CONTROL'     : 'YELLOW_BLACK',
        'IMPORTANT'   : 'GREEN_BLACK',
        'SAFE'        : 'GREEN_BLACK',
        'WARNING'     : 'YELLOW_BLACK',
        'DANGER'      : 'RED_BLACK',
        'CRITICAL'    : 'BLACK_RED',
        'GOOD'        : 'GREEN_BLACK',
        'GOODHL'      : 'GREEN_BLACK',
        'VERYGOOD'    : 'BLACK_GREEN',
        'CAUTION'     : 'YELLOW_BLACK',
        'CAUTIONHL'   : 'BLACK_YELLOW',
    }
    @others
.. @+node:ekr.20170624151245.690: *8* __init__
def __init__(self):
    #curses.use_default_colors()
    self.define_colour_numbers()
    self._defined_pairs = {}
    self._names         = {}
    try:
        self._max_pairs = curses.COLOR_PAIRS - 1
        do_color = True
    except AttributeError:
        # curses.start_color has failed or has not been called
        do_color = False
        # Disable all color use across the application
        disableColor()
    if do_color and curses.has_colors():
        self.initialize_pairs()
        self.initialize_names()

.. @+node:ekr.20170624151245.691: *8* define_colour_numbers
def define_colour_numbers(self):
    if curses.can_change_color():
        for c in self._color_values:
            curses.init_color(c[0], *c[1])

    
.. @+node:ekr.20170624151245.692: *8* findPair
def findPair(self, caller, request='DEFAULT'):
    if not curses.has_colors() or npysGlobalOptions.DISABLE_ALL_COLORS:
        return False

    if request=='DEFAULT':
        request = caller.color
    # Locate the requested colour pair.  Default to default if not found.
    try:
        pair = self._defined_pairs[self._names[request]]
    except Exception:
        pair = self._defined_pairs[self._names['DEFAULT']]

    # now make the actual attribute
    color_attribute = curses.color_pair(pair[0])
    
    return color_attribute
            
.. @+node:ekr.20170624151245.693: *8* setDefault
def setDefault(self, caller):
    return False
    
.. @+node:ekr.20170624151245.694: *8* initialize_pairs
def initialize_pairs(self):
    # White on Black is fixed as color_pair 0
    self._defined_pairs['WHITE_BLACK'] = (0, curses.COLOR_WHITE, curses.COLOR_BLACK)
    for cp in self.__class__._colors_to_define:
        if cp[0] == 'WHITE_BLACK':
            # silently protect the user from breaking things.
            continue
        self.initalize_pair(cp[0], cp[1], cp[2])

.. @+node:ekr.20170624151245.695: *8* initialize_names
def initialize_names(self):
       self._names.update(self.__class__.default_colors)

.. @+node:ekr.20170624151245.696: *8* initalize_pair
def initalize_pair(self, name, fg, bg):
    # Initialize a color_pair for the required colour and return the number. Raise an exception if this is not possible.
    if (len(list(self._defined_pairs.keys()))+1) == self._max_pairs:
        raise Exception("Too many colours")
    
    _this_pair_number = len(list(self._defined_pairs.keys())) + 1
    
    curses.init_pair(_this_pair_number, fg, bg)
    
    self._defined_pairs[name] = (_this_pair_number, fg, bg)
    
    return _this_pair_number
    
.. @+node:ekr.20170624151245.697: *8* get_pair_number
def get_pair_number(self, name):
    return self._defined_pairs[name][0]
.. @+node:ekr.20170624151245.698: *6* @file ../external/npyscreen/npysThemes.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.699: *7* Declarations
import curses
from . import npysThemeManagers as ThemeManagers

.. @+node:ekr.20170624151245.700: *7* class DefaultTheme
class DefaultTheme(ThemeManagers.ThemeManager):
    default_colors = {
        'DEFAULT'     : 'WHITE_BLACK',
        'FORMDEFAULT' : 'WHITE_BLACK',
        'NO_EDIT'     : 'BLUE_BLACK',
        'STANDOUT'    : 'CYAN_BLACK',
        'CURSOR'      : 'WHITE_BLACK',
        'CURSOR_INVERSE': 'BLACK_WHITE',
        'LABEL'       : 'GREEN_BLACK',
        'LABELBOLD'   : 'WHITE_BLACK',
        'CONTROL'     : 'YELLOW_BLACK',
        'WARNING'     : 'RED_BLACK',
        'CRITICAL'    : 'BLACK_RED',
        'GOOD'        : 'GREEN_BLACK',
        'GOODHL'      : 'GREEN_BLACK',
        'VERYGOOD'    : 'BLACK_GREEN',
        'CAUTION'     : 'YELLOW_BLACK',
        'CAUTIONHL'   : 'BLACK_YELLOW',
    }
    
.. @+node:ekr.20170624151245.701: *7* class ElegantTheme
class ElegantTheme(ThemeManagers.ThemeManager):
    default_colors = {
        'DEFAULT'     : 'WHITE_BLACK',
        'FORMDEFAULT' : 'WHITE_BLACK',
        'NO_EDIT'     : 'BLUE_BLACK',
        'STANDOUT'    : 'CYAN_BLACK',
        'CURSOR'      : 'CYAN_BLACK',
        'CURSOR_INVERSE': 'BLACK_CYAN',
        'LABEL'       : 'GREEN_BLACK',
        'LABELBOLD'   : 'WHITE_BLACK',
        'CONTROL'     : 'YELLOW_BLACK',
        'WARNING'     : 'RED_BLACK',
        'CRITICAL'    : 'BLACK_RED',
        'GOOD'        : 'GREEN_BLACK',
        'GOODHL'      : 'GREEN_BLACK',
        'VERYGOOD'    : 'BLACK_GREEN',
        'CAUTION'     : 'YELLOW_BLACK',
        'CAUTIONHL'   : 'BLACK_YELLOW',
    }


.. @+node:ekr.20170624151245.702: *7* class ColorfulTheme
class ColorfulTheme(ThemeManagers.ThemeManager):
    default_colors = {
        'DEFAULT'     : 'RED_BLACK',
        'FORMDEFAULT' : 'YELLOW_BLACK',
        'NO_EDIT'     : 'BLUE_BLACK',
        'STANDOUT'    : 'CYAN_BLACK',
        'CURSOR'      : 'WHITE_BLACK',
        'CURSOR_INVERSE': 'BLACK_WHITE',
        'LABEL'       : 'BLUE_BLACK',
        'LABELBOLD'   : 'YELLOW_BLACK',
        'CONTROL'     : 'GREEN_BLACK',
        'WARNING'     : 'RED_BLACK',
        'CRITICAL'    : 'BLACK_RED',
        'GOOD'        : 'GREEN_BLACK',
        'GOODHL'      : 'GREEN_BLACK',
        'VERYGOOD'    : 'BLACK_GREEN',
        'CAUTION'     : 'YELLOW_BLACK',
        'CAUTIONHL'   : 'BLACK_YELLOW',
        }

.. @+node:ekr.20170624151245.703: *7* class BlackOnWhiteTheme
class BlackOnWhiteTheme(ThemeManagers.ThemeManager):
    default_colors = {
        'DEFAULT'     : 'BLACK_WHITE',
        'FORMDEFAULT' : 'BLACK_WHITE',
        'NO_EDIT'     : 'BLUE_WHITE',
        'STANDOUT'    : 'CYAN_WHITE',
        'CURSOR'      : 'BLACK_WHITE',
        'CURSOR_INVERSE': 'WHITE_BLACK',
        'LABEL'       : 'RED_WHITE',
        'LABELBOLD'   : 'BLACK_WHITE',
        'CONTROL'     : 'BLUE_WHITE',
        'WARNING'     : 'RED_WHITE',
        'CRITICAL'    : 'BLACK_RED',
        'GOOD'        : 'GREEN_BLACK',
        'GOODHL'      : 'GREEN_WHITE',
        'VERYGOOD'    : 'WHITE_GREEN',
        'CAUTION'     : 'YELLOW_WHITE',
        'CAUTIONHL'   : 'BLACK_YELLOW',
    }

.. @+node:ekr.20170624151245.704: *7* class TransparentThemeDarkText
class TransparentThemeDarkText(ThemeManagers.ThemeManager):
    _colors_to_define = ( 
    ('BLACK_WHITE',      curses.COLOR_BLACK,      curses.COLOR_WHITE),
    ('BLUE_BLACK',       curses.COLOR_BLUE,       curses.COLOR_BLACK),
    ('CYAN_BLACK',       curses.COLOR_CYAN,       curses.COLOR_BLACK),
    ('GREEN_BLACK',      curses.COLOR_GREEN,      curses.COLOR_BLACK),
    ('MAGENTA_BLACK',    curses.COLOR_MAGENTA,    curses.COLOR_BLACK),
    ('RED_BLACK',        curses.COLOR_RED,        curses.COLOR_BLACK),
    ('YELLOW_BLACK',     curses.COLOR_YELLOW,     curses.COLOR_BLACK),
    ('BLACK_RED',        curses.COLOR_BLACK,      curses.COLOR_RED),
    ('BLACK_GREEN',      curses.COLOR_BLACK,      curses.COLOR_GREEN),
    ('BLACK_YELLOW',     curses.COLOR_BLACK,      curses.COLOR_YELLOW),

    ('BLUE_WHITE',       curses.COLOR_BLUE,       curses.COLOR_WHITE),
    ('CYAN_WHITE',       curses.COLOR_CYAN,       curses.COLOR_WHITE),
    ('GREEN_WHITE',      curses.COLOR_GREEN,      curses.COLOR_WHITE),
    ('MAGENTA_WHITE',    curses.COLOR_MAGENTA,    curses.COLOR_WHITE),
    ('RED_WHITE',        curses.COLOR_RED,        curses.COLOR_WHITE),
    ('YELLOW_WHITE',     curses.COLOR_YELLOW,     curses.COLOR_WHITE),
     
    ('BLACK_ON_DEFAULT',   curses.COLOR_BLACK,      -1),
    ('WHITE_ON_DEFAULT',   curses.COLOR_WHITE,      -1),
    ('BLUE_ON_DEFAULT',    curses.COLOR_BLUE,       -1),
    ('CYAN_ON_DEFAULT',    curses.COLOR_CYAN,       -1),
    ('GREEN_ON_DEFAULT',   curses.COLOR_GREEN,      -1),
    ('MAGENTA_ON_DEFAULT', curses.COLOR_MAGENTA,    -1),
    ('RED_ON_DEFAULT',     curses.COLOR_RED,        -1),
    ('YELLOW_ON_DEFAULT',  curses.COLOR_YELLOW,     -1),
    )

    default_colors = {
        'DEFAULT'     : 'BLACK_ON_DEFAULT',
        'FORMDEFAULT' : 'BLACK_ON_DEFAULT',
        'NO_EDIT'     : 'BLUE_ON_DEFAULT',
        'STANDOUT'    : 'CYAN_ON_DEFAULT',
        'CURSOR'      : 'BLACK_WHITE',
        'CURSOR_INVERSE': 'WHITE_BLACK',
        'LABEL'       : 'RED_ON_DEFAULT',
        'LABELBOLD'   : 'BLACK_ON_DEFAULT',
        'CONTROL'     : 'BLUE_ON_DEFAULT',
        'WARNING'     : 'RED_WHITE',
        'CRITICAL'    : 'BLACK_RED',
        'GOOD'        : 'GREEN_BLACK',
        'GOODHL'      : 'GREEN_WHITE',
        'VERYGOOD'    : 'WHITE_GREEN',
        'CAUTION'     : 'YELLOW_WHITE',
        'CAUTIONHL'   : 'BLACK_YELLOW',
    }


    @others
.. @+node:ekr.20170624151245.705: *8* __init__
def __init__(self, *args, **keywords):
    curses.use_default_colors()
    super(TransparentThemeDarkText, self).__init__(*args, **keywords)
    
.. @+node:ekr.20170624151245.706: *7* class TransparentThemeLightText
class TransparentThemeLightText(TransparentThemeDarkText):
    default_colors = {
        'DEFAULT'     : 'WHITE_ON_DEFAULT',
        'FORMDEFAULT' : 'WHITE_ON_DEFAULT',
        'NO_EDIT'     : 'BLUE_ON_DEFAULT',
        'STANDOUT'    : 'CYAN_ON_DEFAULT',
        'CURSOR'      : 'WHITE_BLACK',
        'CURSOR_INVERSE': 'BLACK_WHITE',
        'LABEL'       : 'RED_ON_DEFAULT',
        'LABELBOLD'   : 'BLACK_ON_DEFAULT',
        'CONTROL'     : 'BLUE_ON_DEFAULT',
        'WARNING'     : 'RED_BLACK',
        'CRITICAL'    : 'BLACK_RED',
        'GOOD'        : 'GREEN_BLACK',
        'GOODHL'      : 'GREEN_BLACK',
        'VERYGOOD'    : 'BLACK_GREEN',
        'CAUTION'     : 'YELLOW_BLACK',
        'CAUTIONHL'   : 'BLACK_YELLOW',
    }
    
.. @+node:ekr.20170624151245.707: *6* @file ../external/npyscreen/npysTree.py
import weakref
import collections
import leo.core.leoGlobals as g
assert g
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.708: *7* class TreeData (object)
class TreeData(object):
    # This is a new version of NPSTreeData that follows PEP8.
    CHILDCLASS = None
    @others
.. @+node:ekr.20170624151245.709: *8* TreeData.__init__
def __init__(self,
    content=None,
    parent=None,
    selected=False,
    selectable=True,
    highlight=False,
    expanded=True,
    ignore_root=True,
    sort_function=None,
):
    self.set_parent(parent)
        # EKR: set self._parent to None or weakref.proxy(parent)
    self.set_content(content)
        # EKR: sets self.content.
    # EKR: other ivars.
    self.selectable = selectable
    self.selected = selected
    self.highlight = highlight
    self.expanded = expanded
    self._children = []
    self.ignore_root = ignore_root
    self.sort = False
    self.sort_function = sort_function
    self.sort_function_wrapper = True
.. @+node:ekr.20170624151245.710: *8* TreeData._get_children_list
def _get_children_list(self):
    return self._children

.. @+node:ekr.20170624151245.711: *8* TreeData.create_wrapped_sort_function
def create_wrapped_sort_function(self, this_function):
    def new_function(the_item):
        if the_item:
            the_real_item = the_item.get_content()
            return this_function(the_real_item)
        else:
            return the_item
    return new_function

.. @+node:ekr.20170624151245.712: *8* TreeData.getters
.. @+node:ekr.20170624151245.713: *9* TreeData.find_depth
def find_depth(self, d=0):
    parent = self.get_parent()
    while parent:
        d += 1
        parent = parent.get_parent()
    return d
    # Recursive
    #if self._parent == None:
    #    return d
    #else:
    #    return(self._parent.findDepth(d+1))
.. @+node:ekr.20170624151245.714: *9* TreeData.get_children
def get_children(self):
    for c in self._children:
        try:
            yield weakref.proxy(c)
        except Exception:
            yield c
.. @+node:ekr.20170624151245.715: *9* TreeData.get_children_objects
def get_children_objects(self):
    return self._children[:]
.. @+node:ekr.20170624151245.716: *9* TreeData.get_content
def get_content(self):
    return self.content
.. @+node:ekr.20170624151245.717: *9* TreeData.get_content_for_display
def get_content_for_display(self):
    return str(self.content)
.. @+node:ekr.20170624151245.718: *9* TreeData.get_parent
def get_parent(self):
    return self._parent
.. @+node:ekr.20170624151245.719: *9* TreeData.get_tree_as_list
def get_tree_as_list(self, only_expanded=True, sort=None, key=None):
    _a = []
    for node in self.walk_tree(
        only_expanded=only_expanded,
        ignore_root=self.ignore_root,
        sort=sort,
    ):
        try:
            _a.append(weakref.proxy(node))
        except Exception:
            _a.append(node)
    # g.trace('=====', _a)
        # Over-ridden in LeoTreeData.
    return _a
.. @+node:ekr.20170624151245.720: *9* TreeData.has_children
def has_children(self):
    
    return len(self._children) > 0
    # if len(self._children) > 0:
        # return True
    # else:
        # return False
.. @+node:ekr.20170624151245.721: *8* TreeData.predicates
.. @+node:ekr.20170624151245.722: *9* TreeData.is_highlighted
def is_highlighted(self):
    return self.highlight

.. @+node:ekr.20170624151245.723: *9* TreeData.is_last_sibling
def is_last_sibling(self):
    if self.get_parent():
        if list(self.get_parent().get_children())[-1] == self:
            return True
        else:
            return False
    else:
        return None

.. @+node:ekr.20170624151245.724: *9* TreeData.is_selected
def is_selected(self):
    return self.selected

.. @+node:ekr.20170624151245.725: *8* TreeData.setters
.. @+node:ekr.20170624151245.726: *9* TreeData.new_child
def new_child(self, *args, **keywords):
    if self.CHILDCLASS:
        cld = self.CHILDCLASS
    else:
        cld = type(self)
    c = cld(parent=self, *args, **keywords)
    self._children.append(c)
    return weakref.proxy(c)
.. @+node:ekr.20170624151245.727: *9* TreeData.remove_child
def remove_child(self, child):
    new_children = []
    for ch in self._children:
        # do it this way because of weakref equality bug.
        if not ch.get_content() == child.get_content():
            new_children.append(ch)
        else:
            ch.set_parent(None)
    self._children = new_children
.. @+node:ekr.20170624151245.728: *9* TreeData.set_content
def set_content(self, content):
    self.content = content
.. @+node:ekr.20170624151245.729: *9* TreeData.set_parent
def set_parent(self, parent):
    if parent == None:
        self._parent = None
    else:
        self._parent = weakref.proxy(parent)
.. @+node:ekr.20170624151245.730: *8* TreeData.walk_parents
def walk_parents(self):
    p = self.get_parent()
    while p:
        yield p
        p = p.get_parent()
.. @+node:ekr.20170624151245.731: *8* TreeData.walk_tree
def walk_tree(self, only_expanded=True, ignore_root=True, sort=None, sort_function=None):
    #Iterate over Tree
    if sort is None:
        sort = self.sort

    if sort_function is None:
        sort_function = self.sort_function

    # example sort function # sort = True
    # example sort function # def sort_function(the_item):
    # example sort function #     import email.utils
    # example sort function #     if the_item:
    # example sort function #         if the_item.getContent():
    # example sort function #             frm = the_item.getContent().get('from')
    # example sort function #             try:
    # example sort function #                 frm = email.utils.parseaddr(frm)[0]
    # example sort function #             except Exception:
    # example sort function #                 pass
    # example sort function #             return frm
    # example sort function #     else:
    # example sort function #         return the_item
    #key = operator.methodcaller('getContent',)

    if self.sort_function_wrapper and sort_function:
       # def wrapped_sort_function(the_item):
       #     if the_item:
       #         the_real_item = the_item.getContent()
       #         return sort_function(the_real_item)
       #     else:
       #         return the_item
       # _this_sort_function = wrapped_sort_function
       _this_sort_function = self.create_wrapped_sort_function(sort_function)
    else:
        _this_sort_function = sort_function

    key = _this_sort_function
    if not ignore_root:
        yield self
    nodes_to_yield = collections.deque() # better memory management than a list for pop(0)
    if self.expanded or not only_expanded:
        if sort:
            # This and the similar block below could be combined into a nested function
            if key:
                nodes_to_yield.extend(sorted(self.get_children(), key=key,))
            else:
                nodes_to_yield.extend(sorted(self.get_children()))
        else:
            nodes_to_yield.extend(self.get_children())
        while nodes_to_yield:
            child = nodes_to_yield.popleft()
            if child.expanded or not only_expanded:
                # This and the similar block above could be combined into a nested function
                if sort:
                    if key:
                        # must be reverse because about to use extendleft() below.
                        nodes_to_yield.extendleft(sorted(child.get_children(), key=key, reverse=True))
                    else:
                        nodes_to_yield.extendleft(sorted(child.get_children(), reverse=True))
                else:
                    #for node in child.getChildren():
                    #    if node not in nodes_to_yield:
                    #        nodes_to_yield.appendleft(node)
                    yield_these = list(child.get_children())
                    yield_these.reverse()
                    nodes_to_yield.extendleft(yield_these)
                    del yield_these
            yield child
.. @+node:ekr.20170624151245.732: *6* @file ../external/npyscreen/proto_fm_screen_area.py
#!/usr/bin/env python
import leo.core.leoGlobals as g
assert g
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.733: *7* Declarations
import curses
import curses.panel
#import curses.wrapper
from . import npyspmfuncs as pmfuncs
# import os
from . import npysThemeManagers as ThemeManagers


# For more complex method of getting the size of screen
try:
    import fcntl, termios, struct, sys
except Exception:
    # Win32 platforms do not have fcntl
    pass


APPLICATION_THEME_MANAGER = None

.. @+node:ekr.20170624151245.734: *7* setTheme
def setTheme(theme):
    global APPLICATION_THEME_MANAGER
    APPLICATION_THEME_MANAGER = theme()

.. @+node:ekr.20170624151245.735: *7* getTheme
def getTheme():
    return APPLICATION_THEME_MANAGER



.. @+node:ekr.20170624151245.736: *7* class ScreenArea
class ScreenArea(object):
    BLANK_LINES_BASE   =0
    BLANK_COLUMNS_RIGHT=0
    DEFAULT_NEXTRELY=2
    DEFAULT_LINES      = 0
    DEFAULT_COLUMNS    = 0
    SHOW_ATX           = 0
    SHOW_ATY           = 0
    
    """A screen area that can be safely resized.  But this is a low-level class, not the
    object you are looking for."""

    @others
.. @+node:ekr.20170624151245.737: *8* ScreenArea.__init__
def __init__(self, lines=0, columns=0, 
        minimum_lines = 24,
        minimum_columns = 80,
        show_atx = 0, 
        show_aty = 0,
         **keywords):

    
# Putting a default in here will override the system in _create_screen. For testing?
    if not lines:
        lines = self.__class__.DEFAULT_LINES
    if not columns:
        columns = self.__class__.DEFAULT_COLUMNS
        
    if lines:   minimum_lines   = lines
    if columns: minimum_columns = columns

    self.lines = lines #or 25
    self.columns = columns #or 80

    self.min_l = minimum_lines
    self.min_c = minimum_columns

    # Panels can be bigger than the screen area. These two variables
    # set which bit of the panel should be visible.
    # ie. They are about the virtual, not the physical, screen.
    self.show_from_y = 0
    self.show_from_x = 0
    self.show_atx = show_atx or self.__class__.SHOW_ATX
    self.show_aty = show_aty or self.__class__.SHOW_ATY
    self.ALL_SHOWN = False
    
    global APPLICATION_THEME_MANAGER
    if APPLICATION_THEME_MANAGER is None:
        self.theme_manager = ThemeManagers.ThemeManager()
    else:
        self.theme_manager = APPLICATION_THEME_MANAGER
    
    self.keypress_timeout = None
    

    self._create_screen()

.. @+node:ekr.20170624151245.738: *8* ScreenArea._create_screen
def _create_screen(self):

    try:
        if self.lines_were_auto_set: self.lines = None
        if self.cols_were_auto_set: self.columns = None
    except Exception: pass

    
    if not self.lines: 
        self.lines = self._max_physical()[0]+1
        self.lines_were_auto_set = True
    if not self.columns: 
        self.columns = self._max_physical()[1]+1
        self.cols_were_auto_set = True

    if self.min_l > self.lines:
        self.lines = self.min_l

    if self.min_c > self.columns:
        self.columns = self.min_c

    #self.area = curses.newpad(self.lines, self.columns)
    self.curses_pad = curses.newpad(self.lines, self.columns)
    #self.max_y, self.max_x = self.lines, self.columns
    self.max_y, self.max_x = self.curses_pad.getmaxyx()

.. @+node:ekr.20170624151245.739: *8* ScreenArea._max_physical
def _max_physical(self):
    "How big is the physical screen?"
    # On OS X newwin does not correctly get the size of the screen.
    # let's see how big we could be: create a temp screen
    # and see the size curses makes it.  No good to keep, though
    try:
        mxy, mxx = struct.unpack('hh', fcntl.ioctl(sys.stderr.fileno(), termios.TIOCGWINSZ, 'xxxx'))
        if (mxy, mxx) == (0,0):
            raise ValueError
    except (ValueError, NameError):
        mxy, mxx = curses.newwin(0,0).getmaxyx()

    # return safe values, i.e. slightly smaller.
    return (mxy-1, mxx-1)

.. @+node:ekr.20170624151245.740: *8* ScreenArea.useable_space
def useable_space(self, rely=0, relx=0):
   mxy, mxx = self.lines, self.columns
   return (mxy-rely, mxx-1-relx) # x - 1 because can't use last line bottom right.

.. @+node:ekr.20170624151245.741: *8* ScreenArea.widget_useable_space
def widget_useable_space(self, rely=0, relx=0):
    #Slightly misreports space available.
    #mxy, mxx = self.lines, self.columns-1
    mxy, mxx = self.useable_space(rely=rely, relx=relx)
    return (mxy-self.BLANK_LINES_BASE, mxx-self.BLANK_COLUMNS_RIGHT)

.. @+node:ekr.20170624151245.742: *8* ScreenArea.refresh
def refresh(self):
    # g.trace(g.callers())
    pmfuncs.hide_cursor()
    _my, _mx = self._max_physical()
    self.curses_pad.move(0,0)
    # Since we can have pannels larger than the screen
    # let's allow for scrolling them
    
    # Getting strange errors on OS X, with curses sometimes crashing at this point. 
    # Suspect screen size not updated in time. This try: seems to solve it with no ill effects.
    try:
        self.curses_pad.refresh(
            self.show_from_y,
            self.show_from_x,
            self.show_aty,
            self.show_atx,
            _my,_mx)
    except curses.error:
        pass
    self.ALL_SHOWN = (
        self.show_from_y is 0 and
        self.show_from_x is 0 and
        _my >= self.lines and
        _mx >= self.columns
    )
.. @+node:ekr.20170624151245.743: *8* erase
def erase(self):
    self.curses_pad.erase()
    self.refresh()

.. @+node:ekr.20170624151245.744: *6* @file ../external/npyscreen/stdfmemail.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.745: *7* Declarations
import curses
import weakref
import npyscreen
# import email
import mimetypes
import os.path

.. @+node:ekr.20170624151245.746: *7* class EmailTreeLine
class EmailTreeLine(npyscreen.TreeLine):
    @others
.. @+node:ekr.20170624151245.747: *8* display_value
def display_value(self, vl):
    return vl
    if vl:
        return vl.getContent().get_content_type()
    else:
        return ""

.. @+node:ekr.20170624151245.748: *7* class EmailTree
class EmailTree(npyscreen.MultiLineTreeNew):
    _contained_widgets = EmailTreeLine
    @others
.. @+node:ekr.20170624151245.749: *8* display_value
def display_value(self, vl):
    return vl.getContent().get_content_type()
    #return vl.get_content_type()

.. @+node:ekr.20170624151245.750: *8* EmailTree.h_select
def h_select(self, ch):
    if self.values[self.cursor_line].hasChildren():
        self.cursor_line += 1
        return False
    
    try:
        value = [weakref.proxy(self.values[self.cursor_line]),]
    except TypeError:
        # Actually, this is inefficient, since with the NPSTree class (default) we will always be here - since by default we will 
        # try to create a weakref to a weakref, and that will fail with a type-error.  BUT we are only doing it on a keypress, so
        # it shouldn't create a huge performance hit, and is future-proof. Code replicated in h_select_exit
        value = [self.values[self.cursor_line],]
    self.parent.when_select_part(value)
    self.editing = False
    self.how_exited=npyscreen.wgwidget.EXITED_UP
    self.hidden  = True
    
.. @+node:ekr.20170624151245.751: *8* h_select_exit
def h_select_exit(self, ch):
    self.h_select(ch)

.. @+node:ekr.20170624151245.752: *8* set_up_handlers
def set_up_handlers(self):
    '''EmailTree.set_up_handlers.'''
    super(EmailTree, self).set_up_handlers()
    self.handlers.update({
        ord('s'):   self.h_save_message_part,
    })
    
.. @+node:ekr.20170624151245.753: *8* h_save_message_part
def h_save_message_part(self, ch):
    self.parent.saveMessagePart()
    npyscreen.notify_wait("Message part saved to your downloads folder: \n %s" % self.parent.DOWNLOAD_DIR)        


.. @+node:ekr.20170624151245.754: *7* class EmailPager
class EmailPager(npyscreen.Pager):
    @others
.. @+node:ekr.20170624151245.755: *8* set_up_handlers
def set_up_handlers(self):
    '''EmailPager.set_up_handlers.'''
    super(EmailPager, self).set_up_handlers()
    self.handlers.update({
        curses.KEY_LEFT:    self.h_exit_tree,
        ord('s'):           self.h_save_message_part,
        ord('x'):           self.h_exit_tree,
        ord('q'):           self.h_exit_tree,
        curses.ascii.ESC:   self.h_exit_tree,
    })

.. @+node:ekr.20170624151245.756: *8* EmailPager.h_exit_tree
def h_exit_tree(self, ch):
    self.editing    = False
    self.how_exited = True
    self.parent.when_show_tree(ch)

.. @+node:ekr.20170624151245.757: *8* h_save_message_part
def h_save_message_part(self, ch):
    self.parent.saveMessagePart()
    npyscreen.notify_wait("Message part saved to your downloads folder: \n %s" % self.parent.DOWNLOAD_DIR)


.. @+node:ekr.20170624151245.758: *7* class EmailViewFm
class EmailViewFm(npyscreen.SplitFormWithMenus):
    BLANK_COLUMNS_RIGHT= 1
    SHORT_HEADER_LIST = ('from', 'to', 'cc', 'bcc' 'date', 'subject', 'reply-to')
    DOWNLOAD_DIR = os.path.expanduser("~/Downloads")
    
    @others
.. @+node:ekr.20170624151245.759: *8* setEmail
def setEmail(self, this_email):
    #Clear everything
    self.this_email          = this_email
    self.wSubject.value      = ""
    self.wFrom.value         = ""
    self.wDate.value         = ""
    self.wEmailBody.values   = []
    self.wStatusLine.value   = ""
    self.wEmailBody.hidden   = True
    self.wEmailBody.start_display_at = 0
    self.wMessageTree.hidden = False
    self.wMessageTree.cursor_line = 0
            
    self.updateEmailTree()
    
    self.wSubject.value     = this_email['subject']
    self.wFrom.value        = this_email['from']
    self.wDate.value        = this_email['date']


.. @+node:ekr.20170624151245.760: *8* setValue
def setValue(self, this_email):
    return self.setEmail(this_email)


.. @+node:ekr.20170624151245.761: *8* updateEmailTree
def updateEmailTree(self):
    self._parse_email_tree(self.this_email)
    self.wMessageTree.values = self._this_email_tree
    

.. @+node:ekr.20170624151245.762: *8* set_up_handlers
def set_up_handlers(self):
    '''EmailViewFm.set_up_handlers.'''
    super(EmailViewFm, self).set_up_handlers()
    self.handlers.update({})

.. @+node:ekr.20170624151245.763: *8* create
def create(self):
    self.m1 = self.add_menu(name="Read Email")
    self.m1.addItemsFromList([
        ('View Short Headers',              self.viewShortHeaders),
        ('View Full Headers',               self.viewAllHeaders),
        ('View Message Tree',              self.viewMessageTree),
        ('Save this Message Part',          self.saveMessagePart),
        ('View Message Source',             self.viewMessageSource),
    ])
    self.nextrely = 1
    self.wSubject = self.add(npyscreen.TitleText, begin_entry_at=10, editable=False, 
                                    use_two_lines=False, name = "Subject:")
    self.wFrom    = self.add(npyscreen.TitleText, begin_entry_at=10, 
                                    editable=False, name = "From:", ) #max_width=-8)
    self.wDate    = self.add(npyscreen.TitleText, begin_entry_at=10, 
                                    editable=False, name = "Date:")
    
    self.draw_line_at   = self.nextrely
    self.nextrely      += 1
    _body_rely          = self.nextrely        
    self.wEmailBody     = self.add(EmailPager, max_height=-1, scroll_exit=True, hidden=True)
    self.nextrely       = _body_rely
    self.wMessageTree   = self.add(EmailTree, max_height=-1, scroll_exit=True, hidden=False)
    self.nextrely      += 1
    self.wStatusLine    = self.add(npyscreen.FixedText, 
        editable=False, 
        use_max_space=True, 
        color='STANDOUT', 
        value="Status Line-Status Line-Status Line-Status Line-Status Line-Status Line-Status Line-")


.. @+node:ekr.20170624151245.764: *8* _parse_email_tree
def _parse_email_tree(self, this_email):
    "Create an NPSTree representation of the email."
    self._this_email_tree = npyscreen.NPSTreeData(content=this_email, ignoreRoot=False)
    if this_email.is_multipart():
        for part in this_email.get_payload():
            self._tree_add_children(self._this_email_tree, part)

.. @+node:ekr.20170624151245.765: *8* _tree_add_children
def _tree_add_children(self, tree_node, this_message_part):
    use_part = this_message_part
    this_child = tree_node.newChild(content=use_part)
    try:
        if use_part.is_multipart():
            for part in use_part.get_payload():
                self._tree_add_children(this_child, part)
    except AttributeError:
        # Dealing with a string only, not a message.
        pass

.. @+node:ekr.20170624151245.766: *8* when_select_part
def when_select_part(self, vl):
    self.wEmailBody.hidden = False
    self.wEmailBody.setValuesWrap(vl[0].getContent().get_payload(decode=True).decode(errors='replace').split("\n"))
    self.wEmailBody.start_display_at = 0       
    self.wMessageTree.hidden = True

.. @+node:ekr.20170624151245.767: *8* when_show_tree
def when_show_tree(self, vl):
    if self.wMessageTree.hidden:
        self.wEmailBody.hidden = True
        if self.wEmailBody.editing:
            self.wEmailBody.h_exit_tree(vl)
        self.wMessageTree.hidden = False
        self.wStatusLine.value = ""
        self.display()

.. @+node:ekr.20170624151245.768: *8* viewShortHeaders
def viewShortHeaders(self,):
    s_header_list = []
    for headers in self.SHORT_HEADER_LIST:
        these_headers = self.this_email.get_all(headers)
        if these_headers:
            for h in these_headers:
                s_header_list.append(str(headers).capitalize() + ": " + h.strip())
    npyscreen.notify_confirm(s_header_list, wide=True, wrap=False)
    
.. @+node:ekr.20170624151245.769: *8* saveMessagePart
def saveMessagePart(self, vl=None):
    if vl == None:
        vl = self.wMessageTree.values[self.wMessageTree.cursor_line].getContent()
    if vl.is_multipart():
        for v in vl.get_payload():
            self.saveMessagePart(v)
    else:
        self._savePartToFile(vl)

.. @+node:ekr.20170624151245.770: *8* _savePartToFile
def _savePartToFile(self, messagePart):
    fn = messagePart.get_filename()
    counter = 0
    if not fn:
        ext = mimetypes.guess_extension(messagePart.get_content_type()) # Bug in python returns .ksh for text/plain.  Wait for python fix?
        if not ext:
            # generic extension?
            ext = '.bin'
        fn = 'emailpart%s' % (ext)
    fn = os.path.basename(fn) # Sanitize Filename.
    attempted_filename = fn
    while os.path.exists(os.path.join(self.DOWNLOAD_DIR, attempted_filename)):
        counter += 1
        attempted_filename = "%s%s%s" % (os.path.splitext(fn)[0], counter, os.path.splitext(fn)[1])
    fn = attempted_filename
    fqfn = os.path.join(self.DOWNLOAD_DIR, fn)
    if messagePart.get_content_maintype() == "text":
        with open(fqfn, 'w') as f:
            f.write(messagePart.get_payload(decode=True))
    else:
        with open(fqfn, 'wb') as f:
            f.write(messagePart.get_payload(decode=True))


.. @+node:ekr.20170624151245.771: *8* viewAllHeaders
def viewAllHeaders(self,):
    s_header_list = []
    for headers in list(self.this_email.keys()):
        these_headers = self.this_email.get_all(headers)
        if these_headers:
            for h in these_headers:
                s_header_list.append(str(headers).capitalize() + ": " + h.strip())
    npyscreen.notify_confirm(s_header_list, wide=True, wrap=True)
        

.. @+node:ekr.20170624151245.772: *8* viewMessageTree
def viewMessageTree(self,):
    self.wEmailBody.h_exit_tree(None)
    self.wEmailBody.hidden = True

.. @+node:ekr.20170624151245.773: *8* viewMessageSource
def viewMessageSource(self,):
    npyscreen.notify_confirm(self.this_email.as_string(), wide=True)
.. @+node:ekr.20170624151245.774: *6* @file ../external/npyscreen/util_viewhelp.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.775: *7* Declarations
import textwrap


.. @+node:ekr.20170624151245.776: *7* view_help
def view_help(message, title="Message", form_color="STANDOUT", scroll_exit=False, autowrap=False):
    from . import fmForm
    from . import wgmultiline
    F = fmForm.Form(name=title, color=form_color)
    mlw = F.add(wgmultiline.Pager, scroll_exit=True, autowrap=autowrap)
    mlw_width = mlw.width-1
    
    message_lines = []
    for line in message.splitlines():
        line = textwrap.wrap(line, mlw_width)
        if line == []:
            message_lines.append('')
        else:
            message_lines.extend(line)
    mlw.values = message_lines
    F.edit()
    del mlw
    del F
    
.. @+node:ekr.20170624151245.777: *6* @file ../external/npyscreen/utilNotify.py
# pylint: disable=no-member
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.778: *7* Declarations
from . import fmPopup
from . import wgmultiline
# from . import fmPopup
import curses
import textwrap

.. @+node:ekr.20170624151245.779: *7* class ConfirmCancelPopup (fmPopup.ActionPopup)
class ConfirmCancelPopup(fmPopup.ActionPopup):
    @others
.. @+node:ekr.20170624151245.780: *8* on_ok
def on_ok(self):
    self.value = True
.. @+node:ekr.20170624151245.781: *8* on_cancel
def on_cancel(self):
    self.value = False

.. @+node:ekr.20170624151245.782: *7* class YesNoPopup (ConfirmCancelPopup)
class YesNoPopup(ConfirmCancelPopup):
    OK_BUTTON_TEXT = "Yes"
    CANCEL_BUTTON_TEXT = "No"
    
.. @+node:ekr.20170624151245.783: *7* _prepare_message
def _prepare_message(message):
    if isinstance(message, (list, tuple)):
        return "\n".join([ s.rstrip() for s in message])
        #return "\n".join(message)
    else:
        return message

.. @+node:ekr.20170624151245.784: *7* _wrap_message_lines
def _wrap_message_lines(message, line_length):
    lines = []
    for line in message.split('\n'):
        lines.extend(textwrap.wrap(line.rstrip(), line_length))
    return lines
    
.. @+node:ekr.20170624151245.785: *7* notify
def notify(message, title="Message", form_color='STANDOUT', 
            wrap=True, wide=False,
            ):
    message = _prepare_message(message)
    if wide:
        F = fmPopup.PopupWide(name=title, color=form_color)
    else:
        F   = fmPopup.Popup(name=title, color=form_color)
    F.preserve_selected_widget = True
    mlw = F.add(wgmultiline.Pager,)
    mlw_width = mlw.width-1
    if wrap:
        message = _wrap_message_lines(message, mlw_width)
    mlw.values = message
    F.display()
    
.. @+node:ekr.20170624151245.786: *7* notify_confirm
def notify_confirm(message, title="Message", form_color='STANDOUT', wrap=True, wide=False,
                    editw = 0,):
    message = _prepare_message(message)
    if wide:
        F = fmPopup.PopupWide(name=title, color=form_color)
    else:
        F   = fmPopup.Popup(name=title, color=form_color)
    F.preserve_selected_widget = True
    mlw = F.add(wgmultiline.Pager,)
    mlw_width = mlw.width-1
    if wrap:
        message = _wrap_message_lines(message, mlw_width)
    else:
        message = message.split("\n")
    mlw.values = message
    F.editw = editw
    F.edit()

.. @+node:ekr.20170624151245.787: *7* notify_wait
def notify_wait(*args, **keywords):
    notify(*args, **keywords)
    curses.napms(3000)
    curses.flushinp()    
    
    
.. @+node:ekr.20170624151245.788: *7* notify_ok_cancel
def notify_ok_cancel(message, title="Message", form_color='STANDOUT', wrap=True, editw = 0,):
    message = _prepare_message(message)
    F   = ConfirmCancelPopup(name=title, color=form_color)
    F.preserve_selected_widget = True
    mlw = F.add(wgmultiline.Pager,)
    mlw_width = mlw.width-1
    if wrap:
        message = _wrap_message_lines(message, mlw_width)
    mlw.values = message
    F.editw = editw
    F.edit()
    return F.value

.. @+node:ekr.20170624151245.789: *7* notify_yes_no
def notify_yes_no(message, title="Message", form_color='STANDOUT', wrap=True, editw = 0,):
    message = _prepare_message(message)
    F   = YesNoPopup(name=title, color=form_color)
    F.preserve_selected_widget = True
    mlw = F.add(wgmultiline.Pager,)
    mlw_width = mlw.width-1
    if wrap:
        message = _wrap_message_lines(message, mlw_width)
    mlw.values = message
    F.editw = editw
    F.edit()
    return F.value

    
.. @+node:ekr.20170624151245.790: *6* @file ../external/npyscreen/wgannotatetextbox.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.791: *7* Declarations
from . import wgwidget
from .wgtextbox import Textfield



.. @+node:ekr.20170624151245.792: *7* class AnnotateTextboxBase
class AnnotateTextboxBase(wgwidget.Widget):
    """A base class intented for customization. Note in particular the annotationColor and annotationNoColor methods
    which you should override."""
    ANNOTATE_WIDTH = 5
    
    @others
.. @+node:ekr.20170624151245.793: *8* __init__
def __init__(self, screen, value = False, annotation_color='CONTROL', **keywords):
    self.value = value
    self.annotation_color = annotation_color
    super(AnnotateTextboxBase, self).__init__(screen, **keywords)
    
    self._init_text_area(screen)
    
    if hasattr(self, 'display_value'):
        self.text_area.display_value = self.display_value
    self.show_bold = False
    self.highlight = False
    self.important = False
    self.hide      = False

.. @+node:ekr.20170624151245.794: *8* _init_text_area
def _init_text_area(self, screen):
    self.text_area = Textfield(screen, rely=self.rely, relx=self.relx+self.ANNOTATE_WIDTH, 
                  width=self.width-self.ANNOTATE_WIDTH, value=self.name)

.. @+node:ekr.20170624151245.795: *8* _display_annotation_at
def _display_annotation_at(self):
    return (self.rely, self.relx)
    

.. @+node:ekr.20170624151245.796: *8* getAnnotationAndColor
def getAnnotationAndColor(self):
    return ('xxx', 'CONTROL')

.. @+node:ekr.20170624151245.797: *8* annotationColor
def annotationColor(self):
    displayy, displayx = self._display_annotation_at()
    _annotation, _color = self.getAnnotationAndColor()
    self.parent.curses_pad.addnstr(displayy, displayx, _annotation, self.ANNOTATE_WIDTH, self.parent.theme_manager.findPair(self, _color))

.. @+node:ekr.20170624151245.798: *8* annotationNoColor
def annotationNoColor(self):
    displayy, displayx = self._display_annotation_at()
    _annotation, _color = self.getAnnotationAndColor()
    self.parent.curses_pad.addnstr(displayy, displayx, _annotation, self.ANNOTATE_WIDTH)

.. @+node:ekr.20170624151245.799: *8* AnnotateTextboxBase.update
def update(self, clear=True):
    if clear: 
        self.clear()
    if self.hidden:
        self.clear()
        return False
    if self.hide: 
        return True

    self.text_area.value = self.value

    if self.do_colors():    
        self.annotationColor()
    else:
        self.annotationNoColor()


    if self.editing:
        self.text_area.highlight = True
    else:
        self.text_area.highlight = False
    
    if self.show_bold: 
        self.text_area.show_bold = True
    else: 
        self.text_area.show_bold = False
        
    if self.important:
        self.text_area.important = True
    else:
        self.text_area.important = False

    if self.highlight: 
        self.text_area.highlight = True
    else: 
        self.text_area.highlight = False

    self.text_area.update(clear=clear)
    
.. @+node:ekr.20170624151245.800: *8* calculate_area_needed
def calculate_area_needed(self):
    return 1,0

.. @+node:ekr.20170624151245.801: *7* class AnnotateTextboxBaseRight
class AnnotateTextboxBaseRight(AnnotateTextboxBase):
    @others
.. @+node:ekr.20170624151245.802: *8* _init_text_area
def _init_text_area(self, screen):
    self.text_area = Textfield(screen, rely=self.rely, relx=self.relx, 
                  width=self.width-self.ANNOTATE_WIDTH, value=self.name)

.. @+node:ekr.20170624151245.803: *8* _display_annotation_at
def _display_annotation_at(self):
    return (self.rely, self.relx+self.width-self.ANNOTATE_WIDTH)



.. @+node:ekr.20170624151245.804: *6* @file ../external/npyscreen/wgautocomplete.py
#!/usr/bin/env python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.805: *7* Declarations
import curses
from . import wgtextbox    as textbox
from . import wgmultiline  as multiline
from . import wgtitlefield as titlefield
import os
# from . import fmForm as Form
from . import fmPopup as Popup

.. @+node:ekr.20170624151245.806: *7* class Autocomplete
class Autocomplete(textbox.Textfield):
    """This class is fairly useless, but override auto_complete to change that.  See filename class for example"""
    @others
.. @+node:ekr.20170624151245.807: *8* set_up_handlers
def set_up_handlers(self):
    '''Autocomplete.set_up_handlers.'''
    super(Autocomplete, self).set_up_handlers()
    self.handlers.update({
        curses.ascii.TAB: self.auto_complete
    })

.. @+node:ekr.20170624151245.808: *8* auto_complete
def auto_complete(self, input):
    curses.beep()

.. @+node:ekr.20170624151245.809: *8* get_choice
def get_choice(self, values):
    # If auto_complete needs the user to select from a list of values, this function lets them do that.
    
    #tmp_window = Form.TitleForm(name=self.name, framed=True)
    tmp_window = Popup.Popup(name=self.name, framed=True)
    sel = tmp_window.add_widget(multiline.MultiLine, 
            values=values, 
            value=self.value,
            return_exit=True, select_exit=True)
    #sel = multiline.MultiLine(tmp_window, values=values, value=self.value)
    tmp_window.display()
    sel.value=0
    sel.edit()
    return sel.value


.. @+node:ekr.20170624151245.810: *7* class Filename
class Filename(Autocomplete):
    @others
.. @+node:ekr.20170624151245.811: *8* auto_complete
def auto_complete(self, input):
    # expand ~
    self.value = os.path.expanduser(self.value)

    for i in range(1):
        dir, fname = os.path.split(self.value)
        # Let's have absolute paths.
        dir = os.path.abspath(dir)

        if self.value == '': 
            self.value=dir
            break

        try: 
            flist = os.listdir(dir)
        except Exception:
            self.show_brief_message("Can't read directory!")
            break

        flist = [os.path.join(dir, x) for x in flist]
        possibilities = list(filter(
            (lambda x: os.path.split(x)[1].startswith(fname)), flist
            ))

        if len(possibilities) is 0:
            # can't complete
            curses.beep()
            break

        if len(possibilities) is 1:
            if self.value != possibilities[0]:
                self.value = possibilities[0]
            if os.path.isdir(self.value) \
                and not self.value.endswith(os.sep):
                self.value = self.value + os.sep
            else:
                if not os.path.isdir(self.value):
                    self.h_exit_down(None)
                break

        if len(possibilities) > 1:
            filelist = possibilities
        else:
            filelist = flist #os.listdir(os.path.dirname(self.value))

        filelist = list(map((lambda x: os.path.normpath(os.path.join(self.value, x))), filelist))
        files_only = []
        dirs_only = []

        if fname.startswith('.'):
            filelist = list(filter((lambda x: os.path.basename(x).startswith('.')), filelist))
        else:
            filelist = list(filter((lambda x: not os.path.basename(x).startswith('.')), filelist))

        for index1 in range(len(filelist)):
            if os.path.isdir(filelist[index1]) and not filelist[index1].endswith(os.sep):
                filelist[index1] = filelist[index1] + os.sep

            if os.path.isdir(filelist[index1]):
                dirs_only.append(filelist[index1])
        
            else:
                files_only.append(filelist[index1])

        dirs_only.sort()
        files_only.sort()
        combined_list = dirs_only + files_only
        combined_list.insert(0, self.value)
        self.value = combined_list[self.get_choice(combined_list)]
        break

        # Can't complete
        curses.beep()
    #os.path.normpath(self.value)
    os.path.normcase(self.value)
    self.cursor_position=len(self.value)

.. @+node:ekr.20170624151245.812: *7* class TitleFilename
class TitleFilename(titlefield.TitleText):
    _entry_type = Filename


.. @+node:ekr.20170624151245.813: *6* @file ../external/npyscreen/wgboxwidget.py
import curses
import weakref
from .wgwidget import Widget
from .wgmultiline import MultiLine
# pylint: disable=no-member
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.814: *7* class BoxBasic
class BoxBasic(Widget):
    @others
.. @+node:ekr.20170624151245.815: *8* __init__
def __init__(self, screen, footer=None, *args, **keywords):
    super(BoxBasic, self).__init__(screen, *args, **keywords)
    self.footer = footer
    if 'color' in keywords:
        self.color = keywords['color'] or 'LABEL'
    else:
        self.color = 'LABEL'

.. @+node:ekr.20170624151245.816: *8* BoxBasic.update
def update(self, clear=True):
    if clear: self.clear()
    if self.hidden:
        self.clear()
        return False
    HEIGHT = self.height - 1
    WIDTH  = self.width - 1
    # draw box.
    self.parent.curses_pad.hline(self.rely, self.relx, curses.ACS_HLINE, WIDTH)
    self.parent.curses_pad.hline(self.rely + HEIGHT, self.relx, curses.ACS_HLINE, WIDTH)
    self.parent.curses_pad.vline(self.rely, self.relx, curses.ACS_VLINE, self.height)
    self.parent.curses_pad.vline(self.rely, self.relx+WIDTH, curses.ACS_VLINE, HEIGHT)
    
    # draw corners
    self.parent.curses_pad.addch(self.rely, self.relx, curses.ACS_ULCORNER, )
    self.parent.curses_pad.addch(self.rely, self.relx+WIDTH, curses.ACS_URCORNER, )
    self.parent.curses_pad.addch(self.rely+HEIGHT, self.relx, curses.ACS_LLCORNER, )
    self.parent.curses_pad.addch(self.rely+HEIGHT, self.relx+WIDTH, curses.ACS_LRCORNER, )
    
    # draw title
    if self.name:
        if isinstance(self.name, bytes):
            name = self.name.decode(self.encoding, 'replace')
        else:
            name = self.name
        name = self.safe_string(name)
        name = " " + name + " "
        if isinstance(name, bytes):
            name = name.decode(self.encoding, 'replace')
        name_attributes = curses.A_NORMAL
        if self.do_colors() and not self.editing:
            name_attributes = name_attributes | self.parent.theme_manager.findPair(self, self.color) #| curses.A_BOLD
        elif self.editing:
            name_attributes = name_attributes | self.parent.theme_manager.findPair(self, 'HILIGHT')
        else:
            name_attributes = name_attributes #| curses.A_BOLD
        
        if self.editing:
            name_attributes = name_attributes | curses.A_BOLD
            
        self.add_line(self.rely, self.relx+4, name, 
            self.make_attributes_list(name, name_attributes), 
            self.width-8)
        # end draw title
        
        # draw footer
    if hasattr(self, 'footer') and self.footer:
        footer_text = self.footer
        if isinstance(footer_text, bytes):
            footer_text = footer_text.decode(self.encoding, 'replace')
        footer_text = self.safe_string(footer_text)
        footer_text = " " + footer_text + " "
        if isinstance(footer_text, bytes):
            footer_text = footer_text.decode(self.encoding, 'replace')
        
        footer_attributes = self.get_footer_attributes(footer_text)
        if len(footer_text) <= self.width - 4:
            placing = self.width - 4 - len(footer_text)
        else:
            placing = 4
    
        self.add_line(self.rely+HEIGHT, self.relx+placing, footer_text, 
            footer_attributes, 
            self.width-placing-2)
    
        

.. @+node:ekr.20170624151245.817: *8* get_footer_attributes
def get_footer_attributes(self, footer_text):
    footer_attributes = curses.A_NORMAL
    if self.do_colors() and not self.editing:
        footer_attributes = footer_attributes | self.parent.theme_manager.findPair(self, self.color) #| curses.A_BOLD
    elif self.editing:
        footer_attributes = footer_attributes | self.parent.theme_manager.findPair(self, 'HILIGHT')
    else:
        footer_attributes = footer_attributes #| curses.A_BOLD
    
    if self.editing:
        footer_attributes = footer_attributes | curses.A_BOLD
    #footer_attributes = self.parent.theme_manager.findPair(self, self.color)
    return self.make_attributes_list(footer_text, footer_attributes)
    
    
.. @+node:ekr.20170624151245.818: *7* class BoxTitle
class BoxTitle(BoxBasic):
    _contained_widget = MultiLine
    @others
.. @+node:ekr.20170624151245.819: *8* BoxTitle.__init__
def __init__(self, screen, contained_widget_arguments=None, *args, **keywords):
    super(BoxTitle, self).__init__(screen, *args, **keywords)
    if contained_widget_arguments:
        self.make_contained_widget(contained_widget_arguments=contained_widget_arguments)
    else:
        self.make_contained_widget()
    if 'editable' in keywords:
        self.entry_widget.editable=keywords['editable']
    if 'value' in keywords:
        self.value = keywords['value']
    if 'values' in keywords:
        self.values = keywords['values']
    if 'scroll_exit' in keywords:
        self.entry_widget.scroll_exit = keywords['scroll_exit']
    if 'slow_scroll' in keywords:
        self.entry_widget.scroll_exit = keywords['slow_scroll']
    

.. @+node:ekr.20170624151245.820: *8* BoxTitle.make_contained_widget
def make_contained_widget(self, contained_widget_arguments=None):
    ### The *only* make_contained_widget (singular) in npyscreen.
    self._my_widgets = []
    if contained_widget_arguments:
        self._my_widgets.append(
            self._contained_widget(
                self.parent, 
                rely=self.rely+1,
                relx = self.relx+2, 
                max_width=self.width-4,
                max_height=self.height-2,
                **contained_widget_arguments
        ))
    else:
        self._my_widgets.append(
            self._contained_widget(
                self.parent, 
                rely=self.rely+1,
                relx = self.relx+2, 
                max_width=self.width-4,
                max_height=self.height-2,
        ))
    self.entry_widget = weakref.proxy(self._my_widgets[0])
    self.entry_widget.parent_widget = weakref.proxy(self)
.. @+node:ekr.20170624151245.821: *8* BoxTitle.update
def update(self, clear=True):
    if self.hidden and clear:
        self.clear()
        return False
    elif self.hidden:
        return False
    super(BoxTitle, self).update(clear=clear)
    for w in self._my_widgets:
        w.update(clear=clear)
        
.. @+node:ekr.20170624151245.822: *8* BoxTitle.resize
def resize(self):
    super(BoxTitle, self).resize()
    self.entry_widget.resize()

.. @+node:ekr.20170624151245.823: *8* BoxTitle.edit
def edit(self):
    self.editing=True
    self.display()
    self.entry_widget.edit()
    #self.value = self.textarea.value
    self.how_exited = self.entry_widget.how_exited
    self.editing=False
    self.display()


    
.. @+node:ekr.20170624151245.824: *8* BoxTitle.get_value
def get_value(self):
    if hasattr(self, 'entry_widget'):
        return self.entry_widget.value
    elif hasattr(self, '__tmp_value'):
        return self.__tmp_value
    else:
        return None
.. @+node:ekr.20170624151245.825: *8* BoxTitle.set_value
def set_value(self, value):
    if hasattr(self, 'entry_widget'):
        self.entry_widget.value = value
    else:
        # probably trying to set the value before the textarea is initialised
        self.__tmp_value = value
.. @+node:ekr.20170624151245.826: *8* BoxTitle.del_value
def del_value(self):
    del self.entry_widget.value
value = property(get_value, set_value, del_value)

.. @+node:ekr.20170624151245.827: *8* BoxTitle.get_values
def get_values(self):
    if hasattr(self, 'entry_widget'): 
        return self.entry_widget.values
    elif hasattr(self, '__tmp_value'):
        return self.__tmp_values
    else:
        return None
.. @+node:ekr.20170624151245.828: *8* BoxTitle.set_values
def set_values(self, value):
    if hasattr(self, 'entry_widget'): 
        self.entry_widget.values = value
    elif hasattr(self, '__tmp_value'):
        # probably trying to set the value before the textarea is initialised
        self.__tmp_values = value
.. @+node:ekr.20170624151245.829: *8* BoxTitle.del_values
def del_values(self):
    del self.entry_widget.value
values = property(get_values, set_values, del_values)

.. @+node:ekr.20170624151245.830: *8* BoxTitle.get_editable
def get_editable(self):
    if hasattr(self, 'entry_widget'): 
        return self.entry_widget.editable
    else:
        return None
.. @+node:ekr.20170624151245.831: *8* BoxTitle.set_editable
def set_editable(self, value):
    if hasattr(self, 'entry_widget'): 
        self.entry_widget.editable = value
    elif hasattr(self, '__tmp_value'):
        # probably trying to set the value before the textarea is initialised
        self.__tmp_values = value
.. @+node:ekr.20170624151245.832: *8* BoxTitle.del_editable
def del_editable(self):
    del self.entry_widget.editable
editable = property(get_editable, set_editable, del_editable)

       
   

.. @+node:ekr.20170624151245.833: *6* @file ../external/npyscreen/wgbutton.py
#!/usr/bin/python

@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.834: *7* Declarations
import curses
import locale
# import weakref
from . import npysGlobalOptions as GlobalOptions
# from . import wgwidget    as widget
from . import wgcheckbox  as checkbox

.. @+node:ekr.20170624151245.835: *7* class MiniButton
class MiniButton(checkbox._ToggleControl):
    DEFAULT_CURSOR_COLOR = None
    @others
.. @+node:ekr.20170624151245.836: *8* __init__
def __init__(self, screen, name='Button', cursor_color=None, *args, **keywords):
    self.encoding = 'utf-8'
    self.cursor_color = cursor_color or self.__class__.DEFAULT_CURSOR_COLOR
    if GlobalOptions.ASCII_ONLY or locale.getpreferredencoding() == 'US-ASCII':
        self._force_ascii = True
    else:
        self._force_ascii = False
    self.name = self.safe_string(name)
    self.label_width = len(name) + 2
    super(MiniButton, self).__init__(screen, *args, **keywords)
    if 'color' in keywords:
        self.color = keywords['color']
    else:
        self.color = 'CONTROL'
    
.. @+node:ekr.20170624151245.837: *8* calculate_area_needed
def calculate_area_needed(self):
    return 1, self.label_width+2

.. @+node:ekr.20170624151245.838: *8* MiniButton.update
def update(self, clear=True):
    if clear: self.clear()
    if self.hidden:
        self.clear()
        return False
    
    
    if self.value and self.do_colors():
        self.parent.curses_pad.addstr(self.rely, self.relx, '>', self.parent.theme_manager.findPair(self))
        self.parent.curses_pad.addstr(self.rely, self.relx+self.width-1, '<', self.parent.theme_manager.findPair(self))
    elif self.value:
        self.parent.curses_pad.addstr(self.rely, self.relx, '>')
        self.parent.curses_pad.addstr(self.rely, self.relx+self.width-1, '<')
        
    
    if self.editing:
        button_state = curses.A_STANDOUT
    else:
        button_state = curses.A_NORMAL
    
    button_name = self.name
    if isinstance(button_name, bytes):
        button_name = button_name.decode(self.encoding, 'replace')
    button_name = button_name.center(self.label_width)
    
    if self.do_colors():
        if self.cursor_color:
            if self.editing:
                button_attributes = self.parent.theme_manager.findPair(self, self.cursor_color)
            else:
                button_attributes  = self.parent.theme_manager.findPair(self, self.color)
        else:    
            button_attributes = self.parent.theme_manager.findPair(self, self.color) | button_state
    else:
        button_attributes = button_state
    
    self.add_line(self.rely, self.relx+1,
        button_name,
        self.make_attributes_list(button_name, button_attributes),
        self.label_width
        )


.. @+node:ekr.20170624151245.839: *7* class MiniButtonPress
class MiniButtonPress(MiniButton):
    # NB.  The when_pressed_function functionality is potentially dangerous. It can set up
    # a circular reference that the garbage collector will never free. 
    # If this is a risk for your program, it is best to subclass this object and
    # override when_pressed_function instead.  Otherwise your program will leak memory.
    @others
.. @+node:ekr.20170624151245.840: *8* __init__
def __init__(self, screen, when_pressed_function=None, *args, **keywords):
    super(MiniButtonPress, self).__init__(screen, *args, **keywords)
    self.when_pressed_function = when_pressed_function

.. @+node:ekr.20170624151245.841: *8* set_up_handlers
def set_up_handlers(self):
    '''MiniButtonPress.set_up_handlers.'''
    super(MiniButtonPress, self).set_up_handlers()
    self.handlers.update({
        curses.ascii.NL: self.h_toggle,
        curses.ascii.CR: self.h_toggle,
    })
    
.. @+node:ekr.20170624151245.842: *8* destroy
def destroy(self):
    self.when_pressed_function = None
    del self.when_pressed_function

.. @+node:ekr.20170624151245.843: *8* h_toggle
def h_toggle(self, ch):
    self.value = True
    self.display()
    if self.when_pressed_function:
        self.when_pressed_function()
    else:
        self.whenPressed()
    self.value = False
    self.display()

.. @+node:ekr.20170624151245.844: *8* whenPressed
def whenPressed(self):
    pass
.. @+node:ekr.20170624151245.845: *6* @file ../external/npyscreen/wgcheckbox.py
#!/usr/bin/python

@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.846: *7* Declarations
from .wgtextbox   import Textfield
from .wgwidget    import Widget
#from .wgmultiline import MultiLine
from . import wgwidget as widget
import curses

.. @+node:ekr.20170624151245.847: *7* class _ToggleControl
class _ToggleControl(Widget):
    @others
.. @+node:ekr.20170624151245.848: *8* set_up_handlers
def set_up_handlers(self):
    '''ToggleControl.set_up_handlers.'''
    super(_ToggleControl, self).set_up_handlers()
    self.handlers.update({
        curses.ascii.SP: self.h_toggle,
        ord('x'):        self.h_toggle,
        curses.ascii.NL: self.h_select_exit,
        curses.ascii.CR: self.h_select_exit,
        ord('j'):        self.h_exit_down,
        ord('k'):        self.h_exit_up,
        ord('h'):        self.h_exit_left,
        ord('l'):        self.h_exit_right,                      
    })

.. @+node:ekr.20170624151245.849: *8* h_toggle
def h_toggle(self, ch):
    if self.value is False or self.value is None or self.value == 0: 
        self.value = True
    else: 
        self.value = False
    self.whenToggled()

.. @+node:ekr.20170624151245.850: *8* whenToggled
def whenToggled(self):
    pass

.. @+node:ekr.20170624151245.851: *8* _ToggleControl.h_select_exit
def h_select_exit(self, ch):
    if not self.value:
        self.h_toggle(ch)
    self.editing = False
    self.how_exited = widget.EXITED_DOWN


.. @+node:ekr.20170624151245.852: *7* class CheckboxBare
class CheckboxBare(_ToggleControl):
    False_box = '[ ]'
    True_box  = '[X]'
    
    @others
.. @+node:ekr.20170624151245.853: *8* __init__
def __init__(self, screen, value = False, **keywords):
    super(CheckboxBare, self).__init__(screen, **keywords)
    self.value = value
    self.hide  = False

.. @+node:ekr.20170624151245.854: *8* calculate_area_needed
def calculate_area_needed(self):
    return 1, 4

.. @+node:ekr.20170624151245.855: *8* CheckboxBare.update
def update(self, clear=True):
    if clear: self.clear()
    if self.hidden:
        self.clear()
        return False
    if self.hide: return True

    if self.value:
        cb_display = self.__class__.True_box
    else:
        cb_display = self.__class__.False_box
    
    if self.do_colors():    
        self.parent.curses_pad.addstr(self.rely, self.relx, cb_display, self.parent.theme_manager.findPair(self, 'CONTROL'))
    else:
        self.parent.curses_pad.addstr(self.rely, self.relx, cb_display)
    
    if self.editing:
        if self.value:
            char_under_cur = 'X'
        else:
            char_under_cur = ' '
        if self.do_colors():
            self.parent.curses_pad.addstr(self.rely, self.relx + 1, char_under_cur, self.parent.theme_manager.findPair(self) | curses.A_STANDOUT)
        else:
            self.parent.curses_pad.addstr(self.rely,  self.relx + 1, curses.A_STANDOUT)
        
        




.. @+node:ekr.20170624151245.856: *7* class Checkbox
class Checkbox(_ToggleControl):
    False_box = '[ ]'
    True_box  = '[X]'
    
    @others
.. @+node:ekr.20170624151245.857: *8* __init__
def __init__(self, screen, value = False, **keywords):
    self.value = value
    super(Checkbox, self).__init__(screen, **keywords)
    
    self._create_label_area(screen)
    
    
    self.show_bold = False
    self.highlight = False
    self.important = False
    self.hide      = False
    
.. @+node:ekr.20170624151245.858: *8* _create_label_area
def _create_label_area(self, screen):
    l_a_width = self.width - 5
    
    if l_a_width < 1:
         raise ValueError("Width of checkbox + label must be at least 6")
       
    self.label_area = Textfield(screen, rely=self.rely, relx=self.relx+5, 
                  width=self.width-5, value=self.name)
    

.. @+node:ekr.20170624151245.859: *8* CheckBox.update
def update(self, clear=True):
    if clear: self.clear()
    if self.hidden:
        self.clear()
        return False
    if self.hide: return True

    if self.value:
        cb_display = self.__class__.True_box
    else:
        cb_display = self.__class__.False_box
    
    if self.do_colors():    
        self.parent.curses_pad.addstr(self.rely, self.relx, cb_display, self.parent.theme_manager.findPair(self, 'CONTROL'))
    else:
        self.parent.curses_pad.addstr(self.rely, self.relx, cb_display)

    self._update_label_area()

.. @+node:ekr.20170624151245.860: *8* _update_label_area
def _update_label_area(self, clear=True):
    self.label_area.value = self.name
    self._update_label_row_attributes(self.label_area, clear=clear)

.. @+node:ekr.20170624151245.861: *8* _update_label_row_attributes
def _update_label_row_attributes(self, row, clear=True):
    if self.editing:
        row.highlight = True
    else:
        row.highlight = False
    
    if self.show_bold: 
        row.show_bold = True
    else: 
        row.show_bold = False
        
    if self.important:
        row.important = True
    else:
        row.important = False

    if self.highlight: 
        row.highlight = True
    else: 
        row.highlight = False

    row.update(clear=clear)
    
.. @+node:ekr.20170624151245.862: *8* calculate_area_needed
def calculate_area_needed(self):
    return 1,0

.. @+node:ekr.20170624151245.863: *7* class CheckBox
class CheckBox(Checkbox):
    pass

   
.. @+node:ekr.20170624151245.864: *7* class RoundCheckBox
class RoundCheckBox(Checkbox):
    False_box = '( )'
    True_box  = '(X)'
    
.. @+node:ekr.20170624151245.865: *7* class CheckBoxMultiline
class CheckBoxMultiline(Checkbox):
    @others
.. @+node:ekr.20170624151245.866: *8* _create_label_area
def _create_label_area(self, screen):    
    self.label_area = []
    for y in range(self.height):
        self.label_area.append(
           Textfield(screen, rely=self.rely+y, 
                       relx=self.relx+5, 
                       width=self.width-5, 
                       value=None) 
        )

.. @+node:ekr.20170624151245.867: *8* _update_label_area
def _update_label_area(self, clear=True):
    for x in range(len(self.label_area)):
        if x >= len(self.name):
            self.label_area[x].value = ''
            self.label_area[x].hidden = True
        else:
            self.label_area[x].value = self.name[x]
            self.label_area[x].hidden = False
            self._update_label_row_attributes(self.label_area[x], clear=clear)
            
.. @+node:ekr.20170624151245.868: *8* calculate_area_needed
def calculate_area_needed(self):
    return 0,0
    
.. @+node:ekr.20170624151245.869: *7* class RoundCheckBoxMultiline
class RoundCheckBoxMultiline(CheckBoxMultiline):
    False_box = '( )'
    True_box  = '(X)'
    

.. @+node:ekr.20170624151245.870: *6* @file ../external/npyscreen/wgcombobox.py
#!/usr/bin/env python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.871: *7* Declarations
import curses

from . import wgtextbox     as textbox
from . import wgmultiline   as multiline
# from . import fmForm        as Form
from . import fmPopup       as Popup
from . import wgtitlefield  as titlefield

.. @+node:ekr.20170624151245.872: *7* class ComboBox
class ComboBox(textbox.Textfield):
    ENSURE_STRING_VALUE = False
    @others
.. @+node:ekr.20170624151245.873: *8* ComboBox.__init__
def __init__(self, screen, value = None, values=None,**keywords):
    self.values = values or []
    self.value = value or None
    if value is 0: 
        self.value = 0
    super(ComboBox, self).__init__(screen, **keywords)
    
.. @+node:ekr.20170624151245.874: *8* ComboBox.display_value
def display_value(self, vl):
    """Overload this function to change how values are displayed.  
    Should accept one argument (the object to be represented), and return a string."""
    return str(vl)

.. @+node:ekr.20170624151245.875: *8* ComboBox.update
def update(self, **keywords):
    keywords.update({'cursor': False})
    super(ComboBox, self).update(**keywords)

.. @+node:ekr.20170624151245.876: *8* ComboBox._print
def _print(self):
    if self.value == None or self.value is '':
        printme = '-unset-'
    else:
        try:
            printme = self.display_value(self.values[self.value])
        except IndexError:
            printme = '-error-'
    if self.do_colors():
        self.parent.curses_pad.addnstr(self.rely, self.relx, printme, self.width, self.parent.theme_manager.findPair(self))
    else:
        self.parent.curses_pad.addnstr(self.rely, self.relx, printme, self.width)


.. @+node:ekr.20170624151245.877: *8* ComboBox.edit
def edit(self):
    #We'll just use the widget one
    super(textbox.Textfield, self).edit()

.. @+node:ekr.20170624151245.878: *8* ComboBox.set_up_handlers
def set_up_handlers(self):
    '''ComboBox.set_up_handlers.'''
    super(textbox.Textfield, self).set_up_handlers()
    self.handlers.update({
        curses.ascii.SP:  self.h_change_value,
        #curses.ascii.TAB: self.h_change_value,
        curses.ascii.NL:  self.h_change_value,
        curses.ascii.CR:  self.h_change_value,
        ord('x'):         self.h_change_value,
        ord('k'):         self.h_exit_up,
        ord('j'):         self.h_exit_down,
        ord('h'):         self.h_exit_left,
        ord('l'):         self.h_exit_right,                      
    })

.. @+node:ekr.20170624151245.879: *8* ComboBox.h_change_value
def h_change_value(self, input):
    "Pop up a window in which to select the values for the field"
    F = Popup.Popup(name = self.name)
    l = F.add(multiline.MultiLine, 
        values = [self.display_value(x) for x in self.values],
        return_exit=True, select_exit=True,
        value=self.value)
    F.display()
    l.edit()
    self.value = l.value


.. @+node:ekr.20170624151245.880: *7* class TitleCombo
class TitleCombo(titlefield.TitleText):
    _entry_type = ComboBox
    
    @others
.. @+node:ekr.20170624151245.881: *8* get_values
def get_values(self):
    try:
        return self.entry_widget.values
    except Exception:
        try:
            return self.__tmp_values
        except Exception:
            return None

.. @+node:ekr.20170624151245.882: *8* set_values
def set_values(self, values):
    try:
        self.entry_widget.values = values
    except Exception:
        # probably trying to set the value before the textarea is initialised
        self.__tmp_values = values
        
.. @+node:ekr.20170624151245.883: *8* del_values
def del_values(self):
    del self.entry_widget.values

values = property(get_values, set_values, del_values)

.. @+node:ekr.20170624151245.884: *6* @file ../external/npyscreen/wgdatecombo.py
#!/usr/bin/env python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.885: *7* Declarations
from . import wgtextbox     as textbox
from . import wgtitlefield  as titlefield
from . import wgmonthbox    as monthbox
from . import fmPopup       as Popup
# from . import fmForm        as Form
# import datetime
import curses


.. @+node:ekr.20170624151245.886: *7* class DateCombo
class DateCombo(textbox.Textfield, monthbox.DateEntryBase):
    @others
.. @+node:ekr.20170624151245.887: *8* __init__
def __init__(self, screen, allowPastDate=True, allowTodaysDate=True, allowClear=True, **keywords):
    super(DateCombo, self).__init__(screen, **keywords)
    self.allow_date_in_past = allowPastDate
    self.allow_todays_date  = allowTodaysDate
    self.allow_clear        = allowClear

.. @+node:ekr.20170624151245.888: *8* DateCombo.update
def update(self, **keywords):
    keywords.update({'cursor': False})
    super(DateCombo, self).update(**keywords)

.. @+node:ekr.20170624151245.889: *8* edit
def edit(self):
    #We'll just use the widget one
    super(textbox.Textfield, self).edit()

.. @+node:ekr.20170624151245.890: *8* display_value
def display_value(self, vl):
    if self.value:
        try:
            # in python 2.4 this will raise ValueError if date is before 1900
            #return self.value.strftime("%a, %d %B, %Y")
            return self.value.strftime("%d %B, %Y")
        except ValueError:
            return self.value.isoformat()
        except AttributeError:
            return "-error-"
    else:
        return "-unset-"
        
.. @+node:ekr.20170624151245.891: *8* _print
def _print(self):
    if self.do_colors():
        self.parent.curses_pad.addnstr(self.rely, self.relx, self.display_value(self.value), self.width, self.parent.theme_manager.findPair(self,))
    else:
        self.parent.curses_pad.addnstr(self.rely, self.relx, self.display_value(self.value), self.width)
        
.. @+node:ekr.20170624151245.892: *8* h_change_value
def h_change_value(self, *arg):
    # Remember to leave extra space at the end of the popup, or the clear function can't work properly.
    # _old_date = self.value
    F = Popup.Popup(name = self.name,
                    columns = (monthbox.MonthBox.DAY_FIELD_WIDTH * 7) + 4, 
                    lines=13,
                    )
    #F = Form.Form()
    m = F.add(monthbox.MonthBox,
                allowPastDate   = self.allow_date_in_past,
                allowTodaysDate = self.allow_todays_date,
                use_max_space   = True,
                use_datetime    = self.use_datetime,
                allowClear      = self.allow_clear,
    )
    try:
        # Is it a date, do we think?
        self.value.isoformat()
        m.value = self.value
    except Exception:
        # if not, we could do worse than today
        m.value = self.date_or_datetime().today()
        # But make sure that that is acceptable
        m._check_today_validity()
    F.display()
    m.edit()
    self.value = m.value
    # The following is perhaps confusing.
    #if self.value == _old_date:
    #   self.h_exit_down('')

.. @+node:ekr.20170624151245.893: *8* set_up_handlers
def set_up_handlers(self):
    '''DataCombo.set_up_handlers.'''
    super(textbox.Textfield, self).set_up_handlers()
    self.handlers.update({curses.ascii.SP:  self.h_change_value,
        #curses.ascii.TAB: self.h_change_value,
        curses.ascii.CR:    self.h_change_value,
        curses.ascii.NL:    self.h_change_value,
        ord('x'):           self.h_change_value,
        ord('j'):           self.h_exit_down,
        ord('k'):           self.h_exit_up,
    })
.. @+node:ekr.20170624151245.894: *7* class TitleDateCombo
class TitleDateCombo(titlefield.TitleText):
    _entry_type = DateCombo



        

.. @+node:ekr.20170624151245.895: *6* @file ../external/npyscreen/wgeditmultiline.py
#!/usr/bin/python
# pylint: disable=no-member
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.896: *7* Declarations
from . import wgwidget    as widget
from . import npysGlobalOptions as GlobalOptions
import locale
import sys
import curses
import textwrap
import re
# from functools import reduce

.. @+node:ekr.20170624151245.897: *7* class MultiLineEdit
class MultiLineEdit(widget.Widget):
    _SAFE_STRING_STRIPS_NL = False
    @others
.. @+node:ekr.20170624151245.898: *8* MultiLineEdit.__init__
def __init__(self, screen, autowrap=True, slow_scroll=True, scroll_exit=True, value=None, **keywords):
    self.value = value or ''
    super(MultiLineEdit, self).__init__(screen, **keywords)
    self.cursor_position = 0
    self.start_display_at = 0 #Line number
    self.maximum_display_width  = self.width - 1 # Leave room for cursor
    self.maximum_display_height = self.height
    self.slow_scroll = slow_scroll
    self.scroll_exit = scroll_exit
    self.encoding = locale.getpreferredencoding()
    self.autowrap = autowrap
    self.wrapon = re.compile(r"\s+|-+") # EKR: added r
    if GlobalOptions.ASCII_ONLY or locale.getpreferredencoding() == 'US-ASCII':
        self._force_ascii = True
    else:
        self._force_ascii = False
.. @+node:ekr.20170624151245.899: *8* MultiLineEdit.safe_filter
def safe_filter(self, this_string):
    s = []
    for cha in this_string:   #.replace('\n', ''): Not of this widget
        if cha == "\n":
            s.append(cha)
        else:
            try:
                s.append(str(cha))
            except Exception:
                s.append('?')
    s = ''.join(s)
    return s
    


.. @+node:ekr.20170624151245.900: *8* MultiLineEdit.get_value_as_list
def get_value_as_list(self, upto=None, keepends=False, useEncoding=True):
    if useEncoding:
        text_to_print = self.safe_string(self.value)
    else:
        text_to_print = self.value
    if upto:
        text = text_to_print[:upto]
    else:
        text = text_to_print
    if upto:
        lines = text.splitlines(keepends)
    else:
        lines = text.splitlines()
    return lines

.. @+node:ekr.20170624151245.901: *8* MultiLineEdit.translate_cursor
def translate_cursor(self, y):
    """Translate cursor position from point in a str to y,x on in widget (you'll need to add in rely, relx yourself)"""
    if self.value == "": return 0,0
    position = y
    if position == 0: 
        return 0,0
    text_to_cursor = self.get_value_as_list(upto=position, keepends=True, useEncoding=False)
    y = (len(text_to_cursor))-1
    x = len(text_to_cursor[-1])
    if text_to_cursor[-1][-1] == '\n': 
        y += 1
        x = 0
    return y, x
        
.. @+node:ekr.20170624151245.902: *8* MultiLineEdit.calculate_area_needed
def calculate_area_needed(self):
    return 0,0

.. @+node:ekr.20170624151245.903: *8* MultiLineEdit.update
def update(self, clear=True):
    if clear: self.clear()
    display_length = self.maximum_display_height
    display_width = self.maximum_display_width
    xdisplay_offset = 0
    text_to_display = self.get_value_as_list()
    if self.cursor_position < 0:
        self.cursor_position = 0
    if self.cursor_position > len(self.value):
        self.cursor_position = len(self.value)
    self.cursory, self.cursorx = self.translate_cursor(self.cursor_position)
    if self.editing:
        if self.slow_scroll:
            if self.cursory > self.start_display_at+display_length-1:
                self.start_display_at = self.cursory - (display_length-1) 
            if self.cursory < self.start_display_at:
                self.start_display_at = self.cursory
        else:
            if self.cursory > self.start_display_at+(display_length-1):
                self.start_display_at = self.cursory
            if self.cursory < self.start_display_at:
                self.start_display_at = self.cursory - (display_length-1)
        if self.start_display_at < 0:
            self.start_display_at=0
        if self.cursorx > display_width:
            xdisplay_offset = self.cursorx - display_width
    # max_display = len(text_to_display[self.start_display_at:])
    for line_counter in range(self.height):
        if line_counter >= len(text_to_display)-self.start_display_at: 
            break
        line_to_display = text_to_display[self.start_display_at+line_counter][xdisplay_offset:]
        line_to_display = self.safe_string(line_to_display)
        if isinstance(line_to_display, bytes):
            line_to_display = line_to_display.decode(self.encoding, 'replace')
        column = 0
        place_in_string = 0
        while column <= (display_width):
            if not line_to_display:
                break
            if place_in_string >= len(line_to_display):
                break
            width_of_char_to_print = 1
                # self.find_width_of_char(string_to_print[place_in_string])
                # change this when actually have a function to do this
            if column - 1 + width_of_char_to_print > display_width:
                break
            if self.do_colors():
                color = self.parent.theme_manager.findPair(self)
            else:
                color = curses.A_NORMAL
            self.parent.curses_pad.addstr(
                self.rely+line_counter,
                self.relx+column, 
                self._print_unicode_char(line_to_display[place_in_string]), 
                color,
            )
            column += width_of_char_to_print
            place_in_string += 1
        # This needs altering using the methods from the textbox class
        # to properly deal with unicode.
        
        #if self.do_colors():
        #    self.parent.curses_pad.addnstr(self.rely+line_counter, self.relx, 
        #        text_to_display[self.start_display_at+line_counter][xdisplay_offset:], display_width,
        #        self.parent.theme_manager.findPair(self))
        #else:
        #    self.parent.curses_pad.addnstr(self.rely+line_counter, self.relx, 
        #        text_to_display[self.start_display_at+line_counter][xdisplay_offset:], display_width)
        #
    if self.editing:
        # Cursors do not seem to work on pads.
            # self.parent_screen.move(self.rely, self.cursor_position - self.begin_at)
        # let's have a fake cursor
        _cur_y, _cur_x = self.translate_cursor(self.cursor_position)
            # _cur_y += self.rely - self.start_display_at
            # assert _cur_y >= 0
            # _cur_x += self.relx - xdisplay_offset
            # char_under_cur = self.parent.curses_pad.inch(_cur_y, _cur_x)
            # self.parent.curses_pad.addch(_cur_y, _cur_x, char_under_cur, curses.A_STANDOUT)
        try:
            char_under_cur = self.safe_string(self.value[self.cursor_position])
            if char_under_cur == '\n':
                char_under_cur = ' '
        except Exception:
            char_under_cur = ' '
        if self.do_colors():
            self.parent.curses_pad.addstr(
                self.rely + _cur_y - self.start_display_at,
                _cur_x - xdisplay_offset + self.relx,
                char_under_cur, 
                self.parent.theme_manager.findPair(self) | curses.A_STANDOUT,
            )
        else:
            self.parent.curses_pad.addstr(
                self.rely + _cur_y - self.start_display_at,
                _cur_x - xdisplay_offset + self.relx,
                char_under_cur,
                curses.A_STANDOUT,
            )
.. @+node:ekr.20170624151245.904: *8* MultiLineEdit._print_unicode_char
def _print_unicode_char(self, ch):
    '''return the ch to print.  For python 3 this is just ch.'''
    # pylint: disable=arguments-differ
    if self._force_ascii:
        return ch.encode('ascii', 'replace')
    elif sys.version_info[0] >= 3:
        return ch
    else:
        return ch.encode('utf-8', 'strict')

.. @+node:ekr.20170624151245.905: *8* MultiLineEdit.reformat_preserve_nl
def reformat_preserve_nl(self, *ignorethese):
    # Adapted from a script found at:
    #http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/148061
    #width=self.maximum_display_width
    #text = self.value
    #self.value = reduce(lambda line, word, width=width: '%s%s%s' %
    #          (line,
    #           ' \n'[(len(line)-line.rfind('\n')-1
    #             + len(word.split('\n',1)[0]
    #                  ) >= width)],
    #           word),
    #          text.split(' ')
    #         )
    
    width=self.maximum_display_width
    text = self.value
    lines = []
    for paragraph in text.split('\n'):
        line = []
        len_line = 0
        for word in paragraph.split(' '):
            len_word = len(word)
            if len_line + len_word <= width:
                line.append(word)
                len_line += len_word + 1
            else:
                lines.append(' '.join(line))
                line = [word]
                len_line = len_word + 1
        lines.append(' '.join(line))
    self.value = '\n'.join(lines)
    return self.value



.. @+node:ekr.20170624151245.906: *8* MultiLineEdit.full_reformat
def full_reformat(self, *args):
    w = DocWrapper(width=self.maximum_display_width)
    self.value = w.fill(self.value)
    
#def handle_mouse_event(self, mouse_event):
    # unfinished
    #mouse_id, x, y, z, bstate = mouse_event
    #rel_mouse_x = x - self.relx
    #rel_mouse_y = y = self.rely
    #self.cursor_position = rel_mouse_x + self.begin_at
    #self.display()
.. @+node:ekr.20170624151245.907: *8* MultiLineEdit.Handlers
.. @+node:ekr.20170624151245.908: *9* MultiLineEdit.set_up_handlers
def set_up_handlers(self):
    '''MultiLineEdit.set_up_handlers.'''
    super(MultiLineEdit, self).set_up_handlers()    
    # For OS X
    # del_key = curses.ascii.alt('~')
    self.handlers.update({
        curses.ascii.NL:    self.h_add_nl,
        curses.ascii.CR:    self.h_add_nl,
        curses.KEY_LEFT:    self.h_cursor_left,
        curses.KEY_RIGHT:   self.h_cursor_right,
        curses.KEY_UP:      self.h_line_up,
        curses.KEY_DOWN:    self.h_line_down,
        curses.KEY_DC:      self.h_delete_right,
        curses.ascii.DEL:   self.h_delete_left,
        curses.ascii.BS:    self.h_delete_left,
        curses.KEY_BACKSPACE: self.h_delete_left,
        # mac os x curses reports DEL as escape oddly
        "^R":               self.full_reformat,
        # no solution yet                   
        #"^K":          self.h_erase_right,
        #"^U":          self.h_erase_left,
    })
    self.complex_handlers.extend((
        (self.t_input_isprint, self.h_addch),
        # (self.t_is_ck, self.h_erase_right),
        # (self.t_is_cu, self.h_erase_left),
    ))
.. @+node:ekr.20170624151245.909: *9* MultiLineEdit.h_addch
def h_addch(self, inp):
    if self.editable:
        if self._last_get_ch_was_unicode == True and isinstance(self.value, bytes):
            # probably dealing with python2.
            ch_adding = inp
            self.value = self.value.decode()
        elif self._last_get_ch_was_unicode == True:
            ch_adding = inp
        else:
            try:
                ch_adding = chr(inp)
            except TypeError:
                ch_adding = input
        self.value = self.value[:self.cursor_position] + ch_adding \
            + self.value[self.cursor_position:]
        self.cursor_position += len(ch_adding)
    else:
        return False
    if self.autowrap:
        self.reformat_preserve_nl()

.. @+node:ekr.20170624151245.910: *9* MultiLineEdit.t_input_isprint
def t_input_isprint(self, inp):
    if self._last_get_ch_was_unicode and inp not in '\n\t\r':
        return True
    if curses.ascii.isprint(inp) and (chr(inp) not in '\n\t\r'): 
        return True
    else:
        return False

.. @+node:ekr.20170624151245.911: *9* MultiLineEdit.h_addch_disabled
def h_addch_disabled(self, input):
    """Add printable characters.  However, do NOT add newlines with this function"""
    if not self.editable: return False
    self.value = self.value[:self.cursor_position] + chr(input) \
        + self.value[self.cursor_position:]
    self.cursor_position += len(chr(input))
    
    if self.autowrap:
        self.reformat_preserve_nl()


.. @+node:ekr.20170624151245.912: *9* MultiLineEdit.h_line_down
def h_line_down(self, input):
    end_this_line = self.value.find("\n", self.cursor_position) 
    if end_this_line == -1:
        if self.scroll_exit: 
            self.h_exit_down(None)
        else: 
            self.cursor_position = len(self.value)
    else:
        self.cursor_position = end_this_line + 1
        for x in range(self.cursorx):
            if self.cursor_position > len(self.value)-1:
                break
            elif self.value[self.cursor_position] == "\n":
                break
            else:
                self.cursor_position += 1
        

.. @+node:ekr.20170624151245.913: *9* MultiLineEdit.h_line_up
def h_line_up(self, input):
    end_last_line = self.value.rfind("\n", 0, self.cursor_position) 
    if end_last_line == -1:
        if self.scroll_exit: self.h_exit_up(None)
        else: self.cursor_position = 0
    else:
        start_last_line = self.value.rfind("\n", 0, end_last_line)
        if start_last_line == -1: start_last_line = 0
        else: start_last_line += 1
        if end_last_line - start_last_line <= self.cursorx:
            self.cursor_position = end_last_line
        else: 
            self.cursor_position = start_last_line + self.cursorx 
            if self.value[self.cursor_position] == "\n":
                self.cursor_position += 1 
# Bug somewhere here when dealing with empty lines.
.. @+node:ekr.20170624151245.914: *9* MultiLineEdit.h_add_nl
def h_add_nl(self, input):
    self.value = self.value[:self.cursor_position] + "\n" + self.value[self.cursor_position:]
    self.cursor_position += 1

.. @+node:ekr.20170624151245.915: *9* MultiLineEdit.h_cursor_left
def h_cursor_left(self, input):
    if self.cursor_position > 0: 
        self.cursor_position -= 1
    

.. @+node:ekr.20170624151245.916: *9* MultiLineEdit.h_cursor_right
def h_cursor_right(self, input):
    self.cursor_position += 1

.. @+node:ekr.20170624151245.917: *9* MultiLineEdit.h_delete_left
def h_delete_left(self, input):
    if self.editable and self.cursor_position > 0:
        self.value = self.value[:self.cursor_position-1] + self.value[self.cursor_position:]
    
    self.cursor_position -= 1

.. @+node:ekr.20170624151245.918: *9* MultiLineEdit.h_delete_right
def h_delete_right(self, input):
    if self.editable:
        self.value = self.value[:self.cursor_position] + self.value[self.cursor_position+1:]

.. @+node:ekr.20170624151245.919: *7* class DocWrapper
class DocWrapper(textwrap.TextWrapper):
    """Wrap text in a document, processing each paragraph individually"""
    # Code from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/358228
    @others
.. @+node:ekr.20170624151245.920: *8* wrap
def wrap(self, text):
    """Override textwrap.TextWrapper to process 'text' properly when
    multiple paragraphs present"""
    para_edge = re.compile(r"(\n\s*\n)", re.MULTILINE)
    paragraphs = para_edge.split(text)
    wrapped_lines = []
    for para in paragraphs:
        if para.isspace():
            if not self.replace_whitespace:
                # Do not take the leading and trailing newlines since
                # joining the list with newlines (as self.fill will do)
                # will put them back in.
                if self.expand_tabs:
                    para = para.expandtabs()
                wrapped_lines.append(para[1:-1])
            else:
                # self.fill will end up putting in the needed newline to
                # space out the paragraphs
                wrapped_lines.append('')
        else:
            wrapped_lines.extend(textwrap.TextWrapper.wrap(self, para))
    return wrapped_lines

    
.. @+node:ekr.20170624151245.921: *6* @file ../external/npyscreen/wgfilenamecombo.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.922: *7* Declarations
from . import fmFileSelector
from . import wgcombobox

.. @+node:ekr.20170624151245.923: *7* class FilenameCombo
class FilenameCombo(wgcombobox.ComboBox):
    @others
.. @+node:ekr.20170624151245.924: *8* __init__
def __init__(self, screen,
# The following are all options taken from the FileSelector
select_dir=False, #Select a dir, not a file
must_exist=False, #Selected File must already exist
confirm_if_exists=False,
sort_by_extension=True,
*args, **keywords):
    self.select_dir = select_dir
    self.must_exist = must_exist
    self.confirm_if_exists = confirm_if_exists
    self.sort_by_extension = sort_by_extension
    
    super(FilenameCombo, self).__init__(screen, *args, **keywords)
    
.. @+node:ekr.20170624151245.925: *8* _print
def _print(self):
    if self.value == None:
        printme = '- Unset -'
    else:
        try:
            printme = self.display_value(self.value)
        except IndexError:
            printme = '-error-'
    if self.do_colors():
        self.parent.curses_pad.addnstr(self.rely, self.relx, printme, self.width, self.parent.theme_manager.findPair(self))
    else:
        self.parent.curses_pad.addnstr(self.rely, self.relx, printme, self.width)



.. @+node:ekr.20170624151245.926: *8* h_change_value
def h_change_value(self, *args, **keywords):
    self.value = fmFileSelector.selectFile(
        starting_value = self.value,
        select_dir = self.select_dir,
        must_exist = self.must_exist,
        confirm_if_exists = self.confirm_if_exists,
        sort_by_extension = self.sort_by_extension
    )
    if self.value == '':
        self.value = None
    self.display()
    

.. @+node:ekr.20170624151245.927: *7* class TitleFilenameCombo
class TitleFilenameCombo(wgcombobox.TitleCombo):
    _entry_type = FilenameCombo
.. @+node:ekr.20170624151245.928: *6* @file ../external/npyscreen/wgFormControlCheckbox.py
#!/usr/bin/env pyton

@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.929: *7* Declarations
from . import wgcheckbox
import weakref

.. @+node:ekr.20170624151245.930: *7* class FormControlCheckbox
class FormControlCheckbox(wgcheckbox.Checkbox):
    @others
.. @+node:ekr.20170624151245.931: *8* __init__
def __init__(self, *args, **keywords):
    super(FormControlCheckbox, self).__init__(*args, **keywords)
    self._visibleWhenSelected    = []
    self._notVisibleWhenSelected = []

.. @+node:ekr.20170624151245.932: *8* addVisibleWhenSelected
def addVisibleWhenSelected(self, w):
    """Add a widget to be visible only when this box is selected"""
    self._register(w, vws=True)

.. @+node:ekr.20170624151245.933: *8* addInvisibleWhenSelected
def addInvisibleWhenSelected(self, w):
    self._register(w, vws=False)
    
.. @+node:ekr.20170624151245.934: *8* _register
def _register(self, w, vws=True):
    if vws:
        working_list = self._visibleWhenSelected
    else:
        working_list = self._notVisibleWhenSelected
        
    if w in working_list:
        pass
    else:
        try:
            working_list.append(weakref.proxy(w))
        except TypeError:
            working_list.append(w)
    
    self.updateDependents()

.. @+node:ekr.20170624151245.935: *8* updateDependents
def updateDependents(self):
    # This doesn't yet work.
    if self.value:
        for w in self._visibleWhenSelected:
            w.hidden    = False
            w.editable  = True
        for w in self._notVisibleWhenSelected:
            w.hidden    =  True
            w.editable  =  False
    else:
        for w in self._visibleWhenSelected:
            w.hidden    = True
            w.editable  = False
        for w in self._notVisibleWhenSelected:
            w.hidden    =  False
            w.editable  =  True
    self.parent.display()

.. @+node:ekr.20170624151245.936: *8* h_toggle
def h_toggle(self, *args):
    super(FormControlCheckbox, self).h_toggle(*args)
    self.updateDependents()
    

    
.. @+node:ekr.20170624151245.937: *6* @file ../external/npyscreen/wggrid.py
#!/usr/bin/env python
# encoding: utf-8
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.938: *7* Declarations
import curses
from . import wgwidget   as widget
from . import wgtextbox  as textbox


.. @+node:ekr.20170624151245.939: *7* class SimpleGrid
class SimpleGrid(widget.Widget):
    _contained_widgets    = textbox.Textfield
    default_column_number = 4
    additional_y_offset   = 0
    additional_x_offset   = 0
    @others
.. @+node:ekr.20170624151245.940: *8* SimpleGrid.__init__
def __init__(self, screen, columns = None, 
        column_width = None, col_margin=1, row_height = 1, 
        values = None,
        always_show_cursor = False,
        select_whole_line = False,
        on_select_callback = None,
        **keywords):
    super(SimpleGrid, self).__init__(screen, **keywords)
    self.col_margin = col_margin
    self.always_show_cursor = always_show_cursor
    self.columns_requested = columns
    self.column_width_requested = column_width
    self.row_height = row_height
    self.make_contained_widgets()
    
    self.begin_row_display_at = 0
    self.begin_col_display_at = 0
    self.on_empty_display = ''
    self.select_whole_line = select_whole_line
    
    self.edit_cell = None
    
    if not values:
        self.values = None
    else:
        self.values = values

    self.on_select_callback = on_select_callback
        
.. @+node:ekr.20170624151245.941: *8* SimpleGrid.set_grid_values_from_flat_list
def set_grid_values_from_flat_list(self, new_values, max_cols=None, reset_cursor=True):
    if not max_cols:
        max_cols = self.columns
    grid_values = [ [], ]
    col_number        = 0
    row_number        = 0
    for f in new_values:
        if col_number >= max_cols:
            col_number = 0
            grid_values.append([])
            row_number += 1
        grid_values[row_number].append(f)    
        col_number += 1
    self.values = grid_values
    if reset_cursor:
        self.edit_cell = [0,0]
    
.. @+node:ekr.20170624151245.942: *8* SimpleGrid.resize
def resize(self):
    self.make_contained_widgets()

.. @+node:ekr.20170624151245.943: *8* SimpleGrid.make_contained_widgets
def make_contained_widgets(self):
    if self.column_width_requested:
        # don't need a margin for the final column
        self.columns = (self.width + self.col_margin) // (self.column_width_requested + self.col_margin)
    elif self.columns_requested:
        self.columns = self.columns_requested
    else:
        self.columns = self.default_column_number
    self._my_widgets = []
    column_width = (self.width + self.col_margin - self.additional_x_offset) // self.columns
    column_width -= self.col_margin
    self._column_width = column_width
    if column_width < 1: raise Exception("Too many columns for space available")
    for h in range( (self.height - self.additional_y_offset) // self.row_height ):
        h_coord = h * self.row_height
        row = []
        for cell in range(self.columns):
            x_offset = cell * (self._column_width + self.col_margin)
            row.append(self._contained_widgets(self.parent, rely=h_coord+self.rely + self.additional_y_offset, relx = self.relx + x_offset + self.additional_x_offset, width=column_width, height=self.row_height))
        self._my_widgets.append(row)

.. @+node:ekr.20170624151245.944: *8* SimpleGrid.display_value
def display_value(self, vl):
    """Overload this function to change how values are displayed.  
    Should accept one argument (the object to be represented), and return a string."""
    return str(vl)

    
.. @+node:ekr.20170624151245.945: *8* SimpleGrid.calculate_area_needed
def calculate_area_needed(self):
    return 0,0

.. @+node:ekr.20170624151245.946: *8* SimpleGrid.update
def update(self, clear=True):
    if clear == True:
        self.clear()
    if self.begin_col_display_at < 0:
        self.begin_col_display_at = 0
    if self.begin_row_display_at < 0:
        self.begin_row_display_at = 0
    if (self.editing or self.always_show_cursor) and not self.edit_cell:
        self.edit_cell = [0,0]
    row_indexer = self.begin_row_display_at
    for widget_row in self._my_widgets:
        column_indexer = self.begin_col_display_at
        for cell in widget_row:
            cell.grid_current_value_index = (row_indexer, column_indexer)
            self._print_cell(cell, )
            column_indexer += 1
        row_indexer += 1

.. @+node:ekr.20170624151245.947: *8* SimpleGrid._print_cell
def _print_cell(self, cell,):
    row_indexer, column_indexer = cell.grid_current_value_index
    try:
        cell_value = self.display_value(self.values[row_indexer][column_indexer])
    except IndexError:
        cell_value = self.on_empty_display
        cell.grid_current_value_index = -1
    except TypeError:
        cell_value = self.on_empty_display
        cell.grid_current_value_index = -1
        
    cell.grid_current_value_index
    self._cell_widget_show_value(cell, cell_value)        
    
    if self.value:
        if cell.grid_current_value_index in self.value or cell.grid_current_value_index == self.value:
            self._cell_widget_show_value_selected(cell, True)
        else:
            self._cell_widget_show_value_selected(cell, False)
    else:
        self._cell_widget_show_value_selected(cell, False)
    
    if (self.editing or self.always_show_cursor) and cell.grid_current_value_index != -1:
        if self.select_whole_line:
            if (self.edit_cell[0] == cell.grid_current_value_index[0]):
                self._cell_show_cursor(cell, True)
                cell.highlight_whole_widget = True
            else:
                self._cell_show_cursor(cell, False)
        elif ((self.edit_cell[0] == cell.grid_current_value_index[0]) and (self.edit_cell[1] == cell.grid_current_value_index[1])):
            self._cell_show_cursor(cell, True)
        else:
            self._cell_show_cursor(cell, False)
    else:
        self._cell_show_cursor(cell, False)
        
    self.custom_print_cell(cell, cell_value)
    
    cell.update() # <-------------------- WILL NEED TO OPTIMIZE THIS
    
.. @+node:ekr.20170624151245.948: *8* SimpleGrid.custom_print_cell
def custom_print_cell(self, actual_cell, cell_display_value):
    pass
    
    
    
.. @+node:ekr.20170624151245.949: *8* SimpleGrid._cell_widget_show_value
def _cell_widget_show_value(self, cell, value):
    cell.value = value

.. @+node:ekr.20170624151245.950: *8* SimpleGrid._cell_widget_show_value_selected
def _cell_widget_show_value_selected(self, cell, yes_no):
    cell.show_bold = yes_no

.. @+node:ekr.20170624151245.951: *8* SimpleGrid._cell_show_cursor
def _cell_show_cursor(self, cell, yes_no):
    cell.highlight = yes_no
    
.. @+node:ekr.20170624151245.952: *8* SimpleGrid.handle_mouse_event
def handle_mouse_event(self, mouse_event):
    # unfinished
    for row in self._my_widgets:
        for c in row:
            if c.intersted_in_mouse_event(mouse_event):
                if c.grid_current_value_index != -1:
                    self.edit_cell = list(c.grid_current_value_index)
    self.display()

    
.. @+node:ekr.20170624151245.953: *8* SimpleGrid.set_up_handlers
def set_up_handlers(self):
    '''SimpleGrid.set_up_handlers.'''
    super(SimpleGrid, self).set_up_handlers()
    self.handlers = {
        curses.KEY_UP:      self.h_move_line_up,
        curses.KEY_LEFT:    self.h_move_cell_left,
        curses.KEY_DOWN:    self.h_move_line_down,
        curses.KEY_RIGHT:   self.h_move_cell_right,
        "k":                self.h_move_line_up,
        "h":                self.h_move_cell_left,
        "j":                self.h_move_line_down,
        "l":                self.h_move_cell_right,
        curses.KEY_NPAGE:   self.h_move_page_down,
        curses.KEY_PPAGE:   self.h_move_page_up,
        curses.KEY_HOME:    self.h_show_beginning,
        curses.KEY_END:     self.h_show_end,
        ord('g'):           self.h_show_beginning,
        ord('G'):           self.h_show_end,
        curses.ascii.TAB:   self.h_exit,
        curses.KEY_BTAB:     self.h_exit_up,
        '^P':               self.h_exit_up,
        '^N':               self.h_exit_down,
        #curses.ascii.NL:    self.h_exit,
        #curses.ascii.SP:    self.h_exit,
        #ord('x'):       self.h_exit,
        ord('q'):       self.h_exit,
        curses.ascii.ESC:   self.h_exit,
        curses.KEY_MOUSE:    self.h_exit_mouse,
    }
    self.complex_handlers = []
.. @+node:ekr.20170624151245.954: *8* SimpleGrid.getValuesFlatList
def getValuesFlatList(self):
    output_list = []
    for row in self.values:
        for col in row:
            output_list.append(col)
    return output_list


.. @+node:ekr.20170624151245.955: *8* SimpleGrid.ensure_cursor_on_display_down_right
def ensure_cursor_on_display_down_right(self, inpt=None):
    while self.begin_row_display_at  + len(self._my_widgets) - 1 < self.edit_cell[0]:
        self.h_scroll_display_down(inpt)
    while self.edit_cell[1] > self.begin_col_display_at + self.columns - 1:
        self.h_scroll_right(inpt)

.. @+node:ekr.20170624151245.956: *8* SimpleGrid.ensure_cursor_on_display_up
def ensure_cursor_on_display_up(self, inpt=None):
    while self.begin_row_display_at  >  self.edit_cell[0]:
        self.h_scroll_display_up(inpt)
    
.. @+node:ekr.20170624151245.957: *8* SimpleGrid.h_show_beginning
def h_show_beginning(self, inpt):
    self.begin_col_display_at = 0
    self.begin_row_display_at = 0
    self.edit_cell = [0, 0]
    self.on_select(inpt)

.. @+node:ekr.20170624151245.958: *8* SimpleGrid.h_show_end
def h_show_end(self, inpt):
    self.edit_cell = [len(self.values) - 1 , len(self.values[-1]) - 1]
    self.ensure_cursor_on_display_down_right()
    self.on_select(inpt)
    
.. @+node:ekr.20170624151245.959: *8* SimpleGrid.h_move_cell_left
def h_move_cell_left(self, inpt):
    if self.edit_cell[1] > 0:
        self.edit_cell[1] -= 1
    
    if self.edit_cell[1] < self.begin_col_display_at:
        self.h_scroll_left(inpt)
    self.on_select(inpt)

.. @+node:ekr.20170624151245.960: *8* SimpleGrid.h_move_cell_right
def h_move_cell_right(self, inpt):
    if self.edit_cell[1] <= len(self.values[self.edit_cell[0]]) -2:   # Only allow move to end of current line
        self.edit_cell[1] += 1
    
    if self.edit_cell[1] > self.begin_col_display_at + self.columns - 1:
        self.h_scroll_right(inpt)
    self.on_select(inpt)

.. @+node:ekr.20170624151245.961: *8* SimpleGrid.h_move_line_down
def h_move_line_down(self, inpt):
    if self.edit_cell[0] <= (len(self.values) -2) \
    and (len(self.values[self.edit_cell[0]+1]) > self.edit_cell[1]):
        self.edit_cell[0] += 1
    if self.begin_row_display_at  + len(self._my_widgets) - 1 < self.edit_cell[0]:
        self.h_scroll_display_down(inpt)
    self.on_select(inpt)

.. @+node:ekr.20170624151245.962: *8* SimpleGrid.h_move_line_up
def h_move_line_up(self, inpt):
    if self.edit_cell[0] > 0:
        self.edit_cell[0] -= 1
        
    if self.edit_cell[0] < self.begin_row_display_at:
        self.h_scroll_display_up(inpt)
    self.on_select(inpt)

.. @+node:ekr.20170624151245.963: *8* SimpleGrid.h_scroll_right
def h_scroll_right(self, inpt):
    if self.begin_col_display_at + self.columns < len(self.values[self.edit_cell[0]]):
        self.begin_col_display_at += self.columns
    self.on_select(inpt)
    
.. @+node:ekr.20170624151245.964: *8* SimpleGrid.h_scroll_left
def h_scroll_left(self, inpt):
    if self.begin_col_display_at > 0:
        self.begin_col_display_at -= self.columns
    
    if self.begin_col_display_at < 0:
        self.begin_col_display_at = 0
    self.on_select(inpt)

.. @+node:ekr.20170624151245.965: *8* SimpleGrid.h_scroll_display_down
def h_scroll_display_down(self, inpt):
    if self.begin_row_display_at + len(self._my_widgets) < len(self.values):
        self.begin_row_display_at += len(self._my_widgets)
    self.on_select(inpt)
    
.. @+node:ekr.20170624151245.966: *8* SimpleGrid.h_scroll_display_up
def h_scroll_display_up(self, inpt):
    if self.begin_row_display_at > 0:
        self.begin_row_display_at -= len(self._my_widgets)
    if self.begin_row_display_at < 0:
        self.begin_row_display_at = 0
    self.on_select(inpt)

.. @+node:ekr.20170624151245.967: *8* SimpleGrid.h_move_page_up
def h_move_page_up(self, inpt):
    self.edit_cell[0] -= len(self._my_widgets)
    if self.edit_cell[0] < 0:
         self.edit_cell[0] = 0
    self.ensure_cursor_on_display_up()
    self.on_select(inpt)
         
.. @+node:ekr.20170624151245.968: *8* SimpleGrid.h_move_page_down
def h_move_page_down(self, inpt):
    self.edit_cell[0] += len(self._my_widgets)
    if self.edit_cell[0] > len(self.values) - 1:
         self.edit_cell[0] = len(self.values) -1
    
    self.ensure_cursor_on_display_down_right()
    self.on_select(inpt)

.. @+node:ekr.20170624151245.969: *8* SimpleGrid.on_select
def on_select(self, input):
    if self.on_select_callback:
        self.on_select_callback()

.. @+node:ekr.20170624151245.970: *8* SimpleGrid.h_exit
def h_exit(self, ch):
    self.editing = False
    self.how_exited = True

.. @+node:ekr.20170624151245.971: *8* SimpleGrid.selected_row
def selected_row(self):
    try:
        return self.values[self.edit_cell[0]]
    except KeyError:
        pass




.. @+node:ekr.20170624151245.972: *6* @file ../external/npyscreen/wggridcoltitles.py
#!/usr/bin/env python
# encoding: utf-8
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.973: *7* Declarations
import curses
from . import wggrid    as grid
from . import wgtextbox as textbox

.. @+node:ekr.20170624151245.974: *7* class GridColTitles
class GridColTitles(grid.SimpleGrid):
    additional_y_offset   = 2
    _col_widgets = textbox.Textfield
    @others
.. @+node:ekr.20170624151245.975: *8* GridColTitles.__init__
def __init__(self, screen, col_titles = None, *args, **keywords):
    if col_titles:
        self.col_titles = col_titles
    else:
        self.col_titles = []
    super(GridColTitles, self).__init__(screen, *args, **keywords)

.. @+node:ekr.20170624151245.976: *8* GridColTitles.make_contained_widgets
def make_contained_widgets(self):
    super(GridColTitles, self).make_contained_widgets()
    self._my_col_titles = []
    for title_cell in range(self.columns):
        x_offset = title_cell * (self._column_width+self.col_margin)
        self._my_col_titles.append(self._col_widgets(self.parent, rely=self.rely, relx = self.relx + x_offset, width=self._column_width, height=1))
        
        
.. @+node:ekr.20170624151245.977: *8* GridColTitles.update
def update(self, clear=True):
    super(GridColTitles, self).update(clear = True)
    
    _title_counter = 0
    for title_cell in self._my_col_titles:
        try:
            title_text = self.col_titles[self.begin_col_display_at+_title_counter]
        except IndexError:
            title_text = None
        self.update_title_cell(title_cell, title_text)
        _title_counter += 1
        
    self.parent.curses_pad.hline(self.rely+1, self.relx, curses.ACS_HLINE, self.width)

.. @+node:ekr.20170624151245.978: *8* GridColTitles.update_title_cell
def update_title_cell(self, cell, cell_title):
    cell.value = cell_title
    cell.update()
    
.. @+node:ekr.20170624151245.979: *6* @file ../external/npyscreen/wgmonthbox.py
#!/usr/bin/env python

@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.980: *7* Declarations
from . import wgwidget as widget
import calendar
import datetime
import curses

.. @+node:ekr.20170624151245.981: *7* class DateEntryBase
class DateEntryBase(widget.Widget):
    @others
.. @+node:ekr.20170624151245.982: *8* __init__
def __init__(self, screen, allowPastDate=True, allowTodaysDate=True, firstWeekDay=6, 
                use_datetime = False, allowClear=False, **keywords):
    super(DateEntryBase, self).__init__(screen, **keywords)
    self.allow_date_in_past = allowPastDate
    self.allow_todays_date  = allowTodaysDate
    self.allow_clear        = allowClear
    self.use_datetime = use_datetime
    self._max = datetime.date.max
    self._min = datetime.date.min
    self.firstWeekDay = firstWeekDay
    
.. @+node:ekr.20170624151245.983: *8* date_or_datetime
def date_or_datetime(self):
    if self.use_datetime:
        return datetime.datetime
    else:
        return datetime.date
        
.. @+node:ekr.20170624151245.984: *8* _check_date
def _check_date(self):
    if not self.value:
        return None
    if not self.allow_date_in_past:
        if self.value < self.date_or_datetime().today():
            if self.allow_todays_date:
                self.value = self.date_or_datetime().today()
            else:
                self.value = self.date_or_datetime().today() + datetime.timedelta(1)      
    
.. @+node:ekr.20170624151245.985: *8* _check_today_validity
def _check_today_validity(self, onErrorHigher=True):
    """If not allowed to select today's date, and today is selected, move either higher or lower
    depending on the value of onErrorHigher"""
    if not self.allow_date_in_past:
        onErrorHigher = True
    if self.allow_todays_date:
        return True
    else:
        if self.value == self.date_or_datetime().today():
            if onErrorHigher:
                self.value += datetime.timedelta(1)
            else:
                self.value -= datetime.timedelta(1)


.. @+node:ekr.20170624151245.986: *8* set_up_handlers
def set_up_handlers(self):
    '''DataEntryBase.set_up_handlers.'''
    super(DateEntryBase, self).set_up_handlers()
    self.handlers.update({
        "D":    self.h_day_less,
        "d":    self.h_day_more,
        "W":    self.h_week_less,
        "w":    self.h_week_more,
        "M":    self.h_month_less,
        "m":    self.h_month_more,
        "Y":    self.h_year_less,
        "y":    self.h_year_more,
        "t":    self.h_find_today,
        "q":    self.h_clear,
        "c":    self.h_clear,
    })
.. @+node:ekr.20170624151245.987: *8* _reduce_value_by_delta
def _reduce_value_by_delta(self, delta):
    old_value = self.value
    try:
        self.value -= delta
    except Exception:
        self.value = old_value

.. @+node:ekr.20170624151245.988: *8* _increase_value_by_delta
def _increase_value_by_delta(self, delta):
    old_value = self.value
    try:
        self.value += delta
    except Exception:
        self.value = old_value


.. @+node:ekr.20170624151245.989: *8* h_day_less
def h_day_less(self, *args):
    self._reduce_value_by_delta(datetime.timedelta(1))
    self._check_date()
    self._check_today_validity(onErrorHigher=False)

.. @+node:ekr.20170624151245.990: *8* h_day_more
def h_day_more(self, *args):
    self._increase_value_by_delta(datetime.timedelta(1))
    self._check_date()
    self._check_today_validity(onErrorHigher=True)

.. @+node:ekr.20170624151245.991: *8* h_week_less
def h_week_less(self, *args):
    self._reduce_value_by_delta(datetime.timedelta(7))
    self._check_date()
    self._check_today_validity(onErrorHigher=False)

.. @+node:ekr.20170624151245.992: *8* h_week_more
def h_week_more(self, *args):
    self._increase_value_by_delta(datetime.timedelta(7))
    self._check_date()
    self._check_today_validity(onErrorHigher=True)

.. @+node:ekr.20170624151245.993: *8* h_month_less
def h_month_less(self, *args):
    self._reduce_value_by_delta(datetime.timedelta(28))
    self._check_date()
    self._check_today_validity(onErrorHigher=False)

.. @+node:ekr.20170624151245.994: *8* h_month_more
def h_month_more(self, *args):
    self._increase_value_by_delta(datetime.timedelta(28))
    self._check_date()
    self._check_today_validity(onErrorHigher=True)

.. @+node:ekr.20170624151245.995: *8* h_year_less
def h_year_less(self, *args):
    old_value = self.value
    try:
        if self.value.month == 2 and self.value.day == 29:
            self.value = self.value.replace(year=self.value.year-1, day=self.value.day-1)
        else:
            self.value = self.value.replace(year=self.value.year-1)
        self._check_date()
        self._check_today_validity(onErrorHigher=False)
    except Exception:
        self.value=old_value

.. @+node:ekr.20170624151245.996: *8* h_year_more
def h_year_more(self, *args):
    old_value = self.value
    try:
        if self.value.month == 2 and self.value.day == 29:
            self.value = self.value.replace(year=self.value.year+1, day=self.value.day-1)
        else:
            self.value = self.value.replace(year=self.value.year+1)
        self._check_date()
        self._check_today_validity(onErrorHigher=True)
    except Exception:
        self.value = old_value
        
.. @+node:ekr.20170624151245.997: *8* h_find_today
def h_find_today(self, *args):
    self.value = self.date_or_datetime().today()  
    self._check_date()
    self._check_today_validity(onErrorHigher=True)

.. @+node:ekr.20170624151245.998: *8* h_clear
def h_clear(self, *args):
    if self.allow_clear:
        self.value   = None
        self.editing = None 

.. @+node:ekr.20170624151245.999: *7* class MonthBox
class MonthBox(DateEntryBase):
    DAY_FIELD_WIDTH = 4
    
    @others
.. @+node:ekr.20170624151245.1000: *8* MonthBox.__init__
def __init__(self, screen, **keywords):
    super(MonthBox, self).__init__(screen, **keywords)
    
.. @+node:ekr.20170624151245.1001: *8* MonthBox.calculate_area_needed
def calculate_area_needed(self):
    # Rember that although months only have 4-5 weeks, they can span 6 weeks.
    # Currently allowing 2 lines for headers, so 8 lines total
    return 10, self.__class__.DAY_FIELD_WIDTH * 7

.. @+node:ekr.20170624151245.1002: *8* MonthBox.update
def update(self, clear=True):
    calendar.setfirstweekday(self.firstWeekDay)
    if clear: self.clear()
    if self.hidden:
        self.clear()
        return False
    
    # Title line        
    if not self.value:
        _title_line = "No Value Set"
    else:
        year  = self.value.year
        month = self.value.month
        try:
            monthname = self.value.strftime('%B')
        except ValueError:
            monthname = "Month: %s" % self.value.month
        day   = self.value.day
        
        _title_line = "%s, %s" % (monthname, year)
    
    if isinstance(_title_line, bytes):
        _title_line = _title_line.decode(self.encoding, 'replace')
    
    if self.do_colors():
        title_attribute = self.parent.theme_manager.findPair(self)
    else:
        title_attribute = curses.A_NORMAL
    
    self.add_line(self.rely, self.relx, 
        _title_line,
        self.make_attributes_list(_title_line, title_attribute),
        self.width-1
    )
    
    
    if self.value:
        # Print the days themselves
        try:
            cal_data = calendar.monthcalendar(year, month)
            do_cal_print = True
        except OverflowError:
            do_cal_print = False
            self.parent.curses_pad.addstr(self.rely+1, self.relx, "Unable to display")
            self.parent.curses_pad.addstr(self.rely+2, self.relx, "calendar for date.")
        if do_cal_print:
            # Print the day names
            # weekheader puts an extra space at the end of each name
            
            cal_header = calendar.weekheader(self.__class__.DAY_FIELD_WIDTH - 1)
            if isinstance(cal_header, bytes):
                cal_header = cal_header.decode(self.encoding, 'replace')
            
            if self.do_colors():
                cal_title_attribute = self.parent.theme_manager.findPair(self, 'LABEL')
            else:
                cal_title_attribute = curses.A_NORMAL
            self.add_line(self.rely+1, self.relx,
                cal_header,
                self.make_attributes_list(cal_header, cal_title_attribute),
                self.width,
                )
                
            print_line = self.rely+2
    
            for calrow in cal_data:
                print_column = self.relx
        
                for thisday in calrow:
                    if thisday is 0:
                        pass
                    elif day == thisday:
                        if self.do_colors():
                            self.parent.curses_pad.addstr(print_line, print_column, str(thisday), curses.A_STANDOUT | self.parent.theme_manager.findPair(self, self.color))
                        else:
                            self.parent.curses_pad.addstr(print_line, print_column, str(thisday), curses.A_STANDOUT)
                    else:
                        if self.do_colors():
                            self.parent.curses_pad.addstr(print_line, print_column, str(thisday), self.parent.theme_manager.findPair(self, self.color))
                        else:
                            self.parent.curses_pad.addstr(print_line, print_column, str(thisday))
                    print_column += self.__class__.DAY_FIELD_WIDTH
        
                print_line += 1
                
        # Print some help
        if self.allow_clear:
            key_help = "keys: dwmyDWMY t cq"
        else:
            key_help = "keys: dwmyDWMY t"
        
        if self.do_colors():
            self.parent.curses_pad.addstr(self.rely+9, self.relx, key_help, self.parent.theme_manager.findPair(self, 'LABEL'))
        else:
            self.parent.curses_pad.addstr(self.rely+9, self.relx, key_help)

    
.. @+node:ekr.20170624151245.1003: *8* MonthBox.set_up_handlers
def set_up_handlers(self):
    '''MonthBox.set_up_handlers.'''
    super(MonthBox, self).set_up_handlers()
    self.handlers.update({
        curses.KEY_LEFT:    self.h_day_less,
        curses.KEY_RIGHT:   self.h_day_more,
        curses.KEY_UP:      self.h_week_less,
        curses.KEY_DOWN:    self.h_week_more,
        curses.ascii.SP:    self.h_exit_down,
        "^T":               self.h_find_today,
    })

.. @+node:ekr.20170624151245.1004: *6* @file ../external/npyscreen/wgmultiline.py
#!/usr/bin/python
# pylint: disable=no-member
import leo.core.leoGlobals as g
assert g
import copy
from . import wgwidget       as widget
from . import wgtextbox      as textbox
import textwrap
import curses
from . import wgtitlefield   as titlefield
from . import fmPopup        as Popup
import weakref
import collections
MORE_LABEL = "- more -" # string to tell user there are more options
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1005: *7* Declarations
.. @+node:ekr.20170624151245.1006: *7* class FilterPopupHelper
class FilterPopupHelper(Popup.Popup):
    @others
.. @+node:ekr.20170624151245.1007: *8* create
def create(self):
    super(FilterPopupHelper, self).create()
    self.filterbox = self.add(titlefield.TitleText, name='Find:', )
    self.nextrely += 1
    self.statusline = self.add(textbox.Textfield, color = 'LABEL', editable = False)

.. @+node:ekr.20170624151245.1008: *8* updatestatusline
def updatestatusline(self):
    self.owner_widget._filter   = self.filterbox.value
    filtered_lines = self.owner_widget.get_filtered_indexes()
    len_f = len(filtered_lines)
    if self.filterbox.value == None or self.filterbox.value == '':
        self.statusline.value = ''
    elif len_f == 0: 
        self.statusline.value = '(No Matches)'
    elif len_f == 1:
        self.statusline.value = '(1 Match)'
    else:
        self.statusline.value = '(%s Matches)' % len_f

.. @+node:ekr.20170624151245.1009: *8* adjust_widgets
def adjust_widgets(self):
    self.updatestatusline()
    self.statusline.display()
    
    
    

.. @+node:ekr.20170624151245.1010: *7* class MultiLine (Widget)
class MultiLine(widget.Widget):
    _safe_to_display_cache = True
    """
    Display a list of items to the user. By overloading the display_value
    method, this widget can be made to display different kinds of objects.
    Given the standard definition, the same effect can be achieved by
    altering the __str__() method of displayed objects
    """
    _MINIMUM_HEIGHT = 2 # Raise an error if not given this.
    _contained_widgets = textbox.Textfield
    _contained_widget_height = 1
    @others
.. @+node:ekr.20170624151245.1011: *8* MultiLine.__init__
def __init__(self, screen,
    values=None,
    value=None,
    slow_scroll=False,
    scroll_exit=False,
    return_exit=False,
    select_exit=False,
    exit_left=False,
    exit_right=False,
    widgets_inherit_color=False,
    always_show_cursor=False,
    allow_filtering=True,
    ** keywords
):
    self.never_cache = False
    self.exit_left = exit_left
    self.exit_right = exit_right
    self.allow_filtering = allow_filtering
    self.widgets_inherit_color = widgets_inherit_color
    super(MultiLine, self).__init__(screen, **keywords)
        # Call the base class.
    if self.height < self.__class__._MINIMUM_HEIGHT:
        raise widget.NotEnoughSpaceForWidget(
            "Height of %s allocated. Not enough space allowed for %s" % (
                self.height, str(self)))
    self.make_contained_widgets()
    self.return_exit = return_exit
        # does pushing return select and then leave the widget?
    self.select_exit = select_exit
        # does any selection leave the widget?
    self.always_show_cursor = always_show_cursor
        # Show cursor even when not editing?
    self.slow_scroll = slow_scroll
    self.scroll_exit = scroll_exit
    # EKR: Cursor and value ivars.
    self.start_display_at = 0
    self.cursor_line = 0
    self.values = values or []
    self.value = value
    self._filter = None
    # For optimisation...
    self._last_start_display_at = None
    self._last_cursor_line = None
    self._last_values = copy.copy(values)
    self._last_value = copy.copy(value)
    self._last_filter = None
    self._filtered_values_cache = []
    # override - it looks nicer.
    if self.scroll_exit:
        self.slow_scroll = True
.. @+node:ekr.20170624151245.1012: *8* MultiLine.resize
def resize(self):
    super(MultiLine, self).resize()
    self.make_contained_widgets()
    self.reset_display_cache()
    self.display()

.. @+node:ekr.20170624151245.1013: *8* MultiLine.make_contained_widgets
def make_contained_widgets(self):
    ### The *only* make_contained_widgets (plural) in npyscreen.
    trace = False
    trace_widgets = True
    self._my_widgets = []
    height = self.height // self.__class__._contained_widget_height
    if trace: g.trace(self.__class__.__name__, height) #, g.callers(2))
        # Called from BoxTitle.make_contained_widget.
    for h in range(height):
        ### EKR: it's LeoMLTree._contained_widgets that we have to emulate.
        self._my_widgets.append(
            self._contained_widgets(
                self.parent, 
                rely=(h*self._contained_widget_height)+self.rely, 
                relx = self.relx, 
                max_width=self.width, 
                max_height=self.__class__._contained_widget_height
        ))
    if trace and trace_widgets:
        g.printList(self._my_widgets)
        g.printList(['value: %r' % (z.value) for z in self._my_widgets])
.. @+node:ekr.20170624151245.1014: *8* MultiLine.display_value
def display_value(self, vl):
    """Overload this function to change how values are displayed.  
    Should accept one argument (the object to be represented), and return a string or the 
    object to be passed to the contained widget."""
    try:
        return self.safe_string(str(vl))
    except ReferenceError:
        return "**REFERENCE ERROR**"
    try:
        return "Error displaying " + self.safe_string(repr(vl))
    except Exception:
        return "**** Error ****"
.. @+node:ekr.20170624151245.1015: *8* MultiLine.calculate_area_needed
def calculate_area_needed(self):
    return 0,0
.. @+node:ekr.20170624151245.1016: *8* MultiLine.reset_cursor
def reset_cursor(self):
    self.start_display_at = 0
    self.cursor_line      = 0
.. @+node:ekr.20170624151245.1017: *8* MultiLine.reset_display_cache
def reset_display_cache(self):
    self._last_values = False
    self._last_value  = False
.. @+node:ekr.20170624151245.1018: *8* MultiLine.update (LeoMLTree overrides this)
def update(self, clear=True):
    trace = False ### LeoMLTree.update overrides this.
    if trace and self.hidden:
        g.trace('hidden')
    if self.hidden and clear:
        self.clear()
        return False
    elif self.hidden:
        return False
    if self.values == None:
        self.values = []
    # clear = None is a good value for this widget
    display_length = len(self._my_widgets)
    #self._remake_filter_cache()
    self._filtered_values_cache = self.get_filtered_indexes()
    if self.editing or self.always_show_cursor:
        # EKR: Put cursor_line in range.
        if self.cursor_line < 0:
            self.cursor_line = 0
        if self.cursor_line > len(self.values) - 1:
            self.cursor_line = len(self.values) - 1
        if self.slow_scroll:
            # Scroll by lines.
            if self.cursor_line > self.start_display_at + display_length - 1:
                self.start_display_at = self.cursor_line - (display_length - 1)
            if self.cursor_line < self.start_display_at:
                self.start_display_at = self.cursor_line
        else:
            # Scroll by pages.
            if self.cursor_line > self.start_display_at + (display_length - 2):
                self.start_display_at = self.cursor_line
            if self.cursor_line < self.start_display_at:
                self.start_display_at = self.cursor_line - (display_length - 2)
                if self.start_display_at < 0: self.start_display_at = 0
    # Don't update the screen if nothing has changed.
    # no_change = False
    try:
        no_change = (
            self._safe_to_display_cache and
            self._last_value is self.value and
            self.values == self._last_values and
            self.start_display_at == self._last_start_display_at and
            clear != True and
            self._last_cursor_line == self.cursor_line and
            self._last_filter == self._filter and
            self.editing
        )
    except Exception:
        no_change = False
    if clear:
        no_change = False
    if trace:
        from . import npysTree as npysTree
        val = self.values[self.cursor_line]
        # name = val.__class__.__name__ 
        if isinstance(val, npysTree.TreeData):
            val = val.get_content()
        g.trace('changed: %5s, cursor_line: %s %s' % (
            not no_change, self.cursor_line, val))
            # self.start_display_at,
    if not no_change or clear or self.never_cache:
        if clear is True:
            self.clear()
        if self._last_start_display_at != self.start_display_at and clear is None:
            self.clear()
        else:
            pass
        self._last_start_display_at = self.start_display_at
        self._before_print_lines()
        indexer = 0 + self.start_display_at
        for line in self._my_widgets[: -1]:
            self._print_line(line, indexer)
            line.task = "PRINTLINE"
            line.update(clear=True)
            indexer += 1
        # Now do the final line
        line = self._my_widgets[-1]
        if (len(self.values) <= indexer + 1):
            # or (len(self._my_widgets)*self._contained_widget_height)<self.height:
            self._print_line(line, indexer)
            line.task = "PRINTLINE"
            line.update(clear=False)
        elif len((self._my_widgets) * self._contained_widget_height) < self.height:
            self._print_line(line, indexer)
            line.task = "PRINTLINELASTOFSCREEN"
            line.update(clear=False)
            if self.do_colors():
                self.parent.curses_pad.addstr(self.rely + self.height - 1, self.relx, MORE_LABEL, self.parent.theme_manager.findPair(self, 'CONTROL'))
            else:
                self.parent.curses_pad.addstr(self.rely + self.height - 1, self.relx, MORE_LABEL)
        else:
            #line.value = MORE_LABEL
            line.name = MORE_LABEL
            line.task = MORE_LABEL
            #line.highlight = False
            #line.show_bold = False
            line.clear()
            if self.do_colors():
                self.parent.curses_pad.addstr(
                    self.rely + self.height - 1,
                    self.relx, MORE_LABEL,
                    self.parent.theme_manager.findPair(self, 'CONTROL'),
                )
            else:
                self.parent.curses_pad.addstr(
                    self.rely + self.height - 1,
                    self.relx,
                    MORE_LABEL,
                )
        if self.editing or self.always_show_cursor:
            self.set_is_line_cursor(self._my_widgets[(self.cursor_line - self.start_display_at)], True)
            self._my_widgets[(self.cursor_line - self.start_display_at)].update(clear=True)
        else:
            # There is a bug somewhere that affects the first line.  This cures it.
            # Without this line, the first line inherits the color of the form when not editing. Not clear why.
            self._my_widgets[0].update()
    # EKR: remember the previous values.
    self._last_start_display_at = self.start_display_at
    self._last_cursor_line = self.cursor_line
    self._last_values = copy.copy(self.values)
    self._last_value = copy.copy(self.value)
    # Prevent the program crashing if the user has changed values and
    # the cursor is now on the bottom line.
    if (self._my_widgets[self.cursor_line - self.start_display_at].task in
        (MORE_LABEL, "PRINTLINELASTOFSCREEN")
    ):
        if self.slow_scroll:
            self.start_display_at += 1
        else:
            self.start_display_at = self.cursor_line
        self.update(clear=clear)
.. @+node:ekr.20170624151245.1019: *8* MultiLine._before_print_lines
def _before_print_lines(self):
    # Provide a function for the Tree classes to override.
    pass
.. @+node:ekr.20170624151245.1020: *8* MultiLine._print_line
def _print_line(self, line, value_indexer):
    
    trace = False ### LeoMLTree.update overrides this.
    if self.widgets_inherit_color and self.do_colors():
        line.color = self.color
    self._set_line_values(line, value_indexer)
    # Sets line.value
    if trace: g.trace(value_indexer, line.value.get_content())
        # line.value is a weakref to a LeoTreeData.
    self._set_line_highlighting(line, value_indexer)
.. @+node:ekr.20170624151245.1021: *8* MultiLine.setters
.. @+node:ekr.20170624151245.1022: *9* MultiLine._set_line_values
def _set_line_values(self, line, value_indexer):
    try:
        _vl = self.values[value_indexer]
    except IndexError:
        self._set_line_blank(line)
        return False
    except TypeError:
        self._set_line_blank(line)
        return False
    line.value = self.display_value(_vl)
    line.hidden = False
.. @+node:ekr.20170624151245.1023: *9* MultiLine._set_line_blank
def _set_line_blank(self, line):
    line.value    = None
    line.show_bold= False
    line.name     = None
    line.hidden   = True
.. @+node:ekr.20170624151245.1024: *9* MultiLine._set_line_highlighting
def _set_line_highlighting(self, line, value_indexer):
    if value_indexer in self._filtered_values_cache:
        self.set_is_line_important(line, True)
    else:
        self.set_is_line_important(line, False)
    if (value_indexer == self.value) and \
        (self.value is not None):
        self.set_is_line_bold(line, True)
    else: 
        self.set_is_line_bold(line, False)
    self.set_is_line_cursor(line, False)
.. @+node:ekr.20170624151245.1025: *9* MultiLine.set_is_line_important
def set_is_line_important(self, line, value):
    line.important = value
.. @+node:ekr.20170624151245.1026: *9* MultiLine.set_is_line_bold
def set_is_line_bold(self, line, value):
    line.show_bold = value
.. @+node:ekr.20170624151245.1027: *9* MultiLine.set_is_line_cursor
def set_is_line_cursor(self, line, value):
    # g.trace('Multiline')
    line.highlight = value
.. @+node:ekr.20170624151245.1028: *8* MultiLine.filters
.. @+node:ekr.20170624151245.1029: *9* MultiLine.get_filtered_indexes
def get_filtered_indexes(self, force_remake_cache=False):
    if not force_remake_cache:
        try:
            if self._last_filter == self._filter and self._last_values == self.values:
                return self._filtered_values_cache
        except ReferenceError:
            # Can happen if self.values was a list of weak references
            pass
    self._last_filter = self._filter
    self._last_values = copy.copy(self.values)
    if self._filter == None or self._filter == '':
        return []
    list_of_indexes = []
    for indexer in range(len(self.values)):
        if self.filter_value(indexer):
            list_of_indexes.append(indexer)
    return list_of_indexes
.. @+node:ekr.20170624151245.1030: *9* MultiLine.get_filtered_values
def get_filtered_values(self):
    fvls = []
    for vli in self.get_filtered_indexes():
        fvls.append(self.values[vli])
    return fvls

.. @+node:ekr.20170624151245.1031: *9* MultiLine._remake_filter_cache
def _remake_filter_cache(self):
    self._filtered_values_cache = self.get_filtered_indexes(force_remake_cache=True)
.. @+node:ekr.20170624151245.1032: *9* MultiLine.filter_value
def filter_value(self, index):
    if self._filter in self.display_value(self.values[index]):
        return True
    else:
        return False
.. @+node:ekr.20170624151245.1033: *9* MultiLine.jump_to_first_filtered
def jump_to_first_filtered(self, ):
    self.h_cursor_beginning(None)
    self.move_next_filtered(include_this_line=True)
.. @+node:ekr.20170624151245.1034: *9* MultiLine.clear_filter
def clear_filter(self):
    self._filter = None
    self.cursor_line = 0
    self.start_display_at = 0
.. @+node:ekr.20170624151245.1035: *9* MultiLine.move_next_filtered
def move_next_filtered(self, include_this_line=False, *args):
    if self._filter == None:
        return False
    for possible in self._filtered_values_cache:
        if (possible==self.cursor_line and include_this_line==True):
            self.update()
            break
        elif possible > self.cursor_line:
            self.cursor_line = possible
            self.update()
            break
    try:
        if self.cursor_line-self.start_display_at > len(self._my_widgets) or \
        self._my_widgets[self.cursor_line-self.start_display_at].task == MORE_LABEL: 
            if self.slow_scroll:
                self.start_display_at += 1
            else:
                self.start_display_at = self.cursor_line
    except IndexError:
        self.cursor_line = 0
        self.start_display_at = 0
.. @+node:ekr.20170624151245.1036: *9* MultiLine.move_previous_filtered
def move_previous_filtered(self, *args):
    if self._filter == None:
        return False
    # nextline = self.cursor_line
    _filtered_values_cache_reversed = copy.copy(self._filtered_values_cache)
    _filtered_values_cache_reversed.reverse()
    for possible in _filtered_values_cache_reversed:
        if possible < self.cursor_line:
            self.cursor_line = possible
            return True
.. @+node:ekr.20170624151245.1037: *8* MultiLine.get_selected_objects
def get_selected_objects(self):
    if self.value == None:
        return None
    else:
        return [self.values[x] for x in self.value]
.. @+node:ekr.20170624151245.1038: *8* MultiLine.Handlers
.. @+node:ekr.20170624151245.1039: *9* MultiLine.handle_mouse_event
def handle_mouse_event(self, mouse_event):
    # unfinished
    #mouse_id, x, y, z, bstate = mouse_event
    #self.cursor_line = y - self.rely - self.parent.show_aty + self.start_display_at
    mouse_id, rel_x, rel_y, z, bstate = self.interpret_mouse_event(mouse_event)
    self.cursor_line = rel_y // self._contained_widget_height + self.start_display_at
    ##if self.cursor_line > len(self.values):
    ##    self.cursor_line = len(self.values)
    self.display()
.. @+node:ekr.20170624151245.1040: *9* MultiLine.set_up_handlers
def set_up_handlers(self):
    '''MultiLine.set_up_handlers.'''
    super(MultiLine, self).set_up_handlers()
    self.handlers.update ({
        curses.KEY_UP:      self.h_cursor_line_up,
        ord('k'):           self.h_cursor_line_up,
        curses.KEY_LEFT:    self.h_cursor_line_up,
        curses.KEY_DOWN:    self.h_cursor_line_down,
        ord('j'):           self.h_cursor_line_down,
        curses.KEY_RIGHT:   self.h_cursor_line_down,
        curses.KEY_NPAGE:   self.h_cursor_page_down,
        curses.KEY_PPAGE:   self.h_cursor_page_up,
        curses.ascii.TAB:   self.h_exit_down,
        curses.ascii.NL:    self.h_select_exit,
        curses.KEY_HOME:    self.h_cursor_beginning,
        curses.KEY_END:     self.h_cursor_end,
        ord('g'):           self.h_cursor_beginning,
        ord('G'):           self.h_cursor_end,
        ord('x'):           self.h_select,
        # "^L":        self.h_set_filtered_to_selected,
        curses.ascii.SP:    self.h_select,
        curses.ascii.ESC:   self.h_exit_escape,
        curses.ascii.CR:    self.h_select_exit,
    })  
    if self.allow_filtering:
        self.handlers.update ( {
            ord('l'):       self.h_set_filter,
            ord('L'):       self.h_clear_filter,
            ord('n'):       self.move_next_filtered,
            ord('N'):       self.move_previous_filtered,
            ord('p'):       self.move_previous_filtered,
            # "^L":        self.h_set_filtered_to_selected,
        } )   
    if self.exit_left:
        self.handlers.update({
            curses.KEY_LEFT:    self.h_exit_left
        })
    if self.exit_right:
        self.handlers.update({
            curses.KEY_RIGHT:   self.h_exit_right
        })
    self.complex_handlers = [
        # (self.t_input_isprint, self.h_find_char)
    ]
.. @+node:ekr.20170624151245.1041: *9* MultiLine.h_find_char
def h_find_char(self, input):
    # The following ought to work, but there is a curses keyname bug
    # searchingfor = curses.keyname(input).upper()
    # do this instead:
    searchingfor = chr(input).upper()
    for counter in range(len(self.values)):
        try:
            if self.values[counter].find(searchingfor) is not -1:
                self.cursor_line = counter
                break
        except AttributeError:
            break
.. @+node:ekr.20170624151245.1042: *9* MultiLine.t_input_isprint
def t_input_isprint(self, input):
    if curses.ascii.isprint(input): return True
    else: return False
.. @+node:ekr.20170624151245.1043: *9* MultiLine.h_set_filter
def h_set_filter(self, ch):
    if not self.allow_filtering:
        return None
    P = FilterPopupHelper()
    P.owner_widget = weakref.proxy(self)
    P.display()
    P.filterbox.edit()
    self._remake_filter_cache()
    self.jump_to_first_filtered()
.. @+node:ekr.20170624151245.1044: *9* MultiLine.h_clear_filter
def h_clear_filter(self, ch):
    self.clear_filter()
    self.update()

.. @+node:ekr.20170624151245.1045: *9* MultiLine.h_cursor_beginning
def h_cursor_beginning(self, ch):

    self.cursor_line = 0
.. @+node:ekr.20170624151245.1046: *9* MultiLine.h_cursor_end
def h_cursor_end(self, ch):
    self.cursor_line= len(self.values)-1
    if self.cursor_line < 0:
        self.cursor_line = 0
.. @+node:ekr.20170624151245.1047: *9* MultiLine.h_cursor_page_down
def h_cursor_page_down(self, ch):
    self.cursor_line += (len(self._my_widgets)-1) # -1 because of the -more-
    if self.cursor_line >= len(self.values)-1:
        self.cursor_line = len(self.values) -1
    if not (self.start_display_at + len(self._my_widgets) -1 ) > len(self.values):
        self.start_display_at += (len(self._my_widgets)-1)
        if self.start_display_at > len(self.values) - (len(self._my_widgets)-1):
            self.start_display_at = len(self.values) - (len(self._my_widgets)-1)

.. @+node:ekr.20170624151245.1048: *9* MultiLine.h_cursor_page_up
def h_cursor_page_up(self, ch):
    self.cursor_line -= (len(self._my_widgets)-1)
    if self.cursor_line < 0:
        self.cursor_line = 0
    self.start_display_at -= (len(self._my_widgets)-1)
    if self.start_display_at < 0: self.start_display_at = 0
.. @+node:ekr.20170624151245.1049: *9* MultiLine.h_cursor_line_up
def h_cursor_line_up(self, ch):
    self.cursor_line -= 1
    if self.cursor_line < 0: 
        if self.scroll_exit:
            self.cursor_line = 0
            self.h_exit_up(ch)
        else: 
            self.cursor_line = 0

.. @+node:ekr.20170624151245.1050: *9* MultiLine.h_cursor_line_down
def h_cursor_line_down(self, ch):
    self.cursor_line += 1
    if self.cursor_line >= len(self.values):
        if self.scroll_exit: 
            self.cursor_line = len(self.values)-1
            self.h_exit_down(ch)
            return True
        else: 
            self.cursor_line -=1
            return True
    if self._my_widgets[self.cursor_line-self.start_display_at].task == MORE_LABEL: 
        if self.slow_scroll:
            self.start_display_at += 1
        else:
            self.start_display_at = self.cursor_line
.. @+node:ekr.20170624151245.1051: *9* MultiLine.h_exit
def h_exit(self, ch):
    
    # g.trace('MultiLine')
    self.editing = False
    self.how_exited = True

.. @+node:ekr.20170624151245.1052: *9* MultiLine.h_set_filtered_to_selected
def h_set_filtered_to_selected(self, ch):
    # This is broken on multiline
    if len(self._filtered_values_cache) < 2:
        self.value = self._filtered_values_cache
    else:
        # There is an error - trying to select too many things.
        curses.beep()
.. @+node:ekr.20170624151245.1053: *9* MultiLine.h_select
def h_select(self, ch):
    
    # g.trace('MultiLine')
    self.value = self.cursor_line
    if self.select_exit:
        self.editing = False
        self.how_exited = True
.. @+node:ekr.20170624151245.1054: *9* MultiLine.h_select_exit
def h_select_exit(self, ch):
    
    # g.trace('MultiLine')
    self.h_select(ch)
    if self.return_exit or self.select_exit:
        self.editing = False
        self.how_exited=True
.. @+node:ekr.20170624151245.1055: *9* MultiLine.edit
def edit(self):
    
    # g.trace('MultiLine')
    self.editing = True
    self.how_exited = None
    #if self.value: self.cursor_line = self.value
    self.display()
    while self.editing:
        self.get_and_use_key_press()
        self.update(clear=None)
        ##  self.clear()
        ##  self.update(clear=False)
        self.parent.refresh()
        ##  curses.napms(10)
        ##  curses.flushinp()
.. @+node:ekr.20170624151245.1056: *7* class MultiLineAction
class MultiLineAction(MultiLine):
    RAISE_ERROR_IF_EMPTY_ACTION = False
    @others
.. @+node:ekr.20170624151245.1057: *8* MultiLineAction.__init__
def __init__(self, *args, **keywords):
    self.allow_multi_action = False  
    super(MultiLineAction, self).__init__(*args, **keywords)  

.. @+node:ekr.20170624151245.1058: *8* MultiLineAction.actionHighlighted
def actionHighlighted(self, act_on_this, key_press):
    "Override this Method"
    pass

.. @+node:ekr.20170624151245.1059: *8* MultiLineAction.h_act_on_highlighted
def h_act_on_highlighted(self, ch):
    try:
        return self.actionHighlighted(self.values[self.cursor_line], ch)
    except IndexError:
        if self.RAISE_ERROR_IF_EMPTY_ACTION:
            raise
        else:
            pass
        
.. @+node:ekr.20170624151245.1060: *8* MultiLineAction.set_up_handlers
def set_up_handlers(self):
    '''MultiLineAction.set_up_handlers.'''
    super(MultiLineAction, self).set_up_handlers()
    self.handlers.update ( {
        curses.ascii.NL:    self.h_act_on_highlighted,
        curses.ascii.CR:    self.h_act_on_highlighted,
        ord('x'):           self.h_act_on_highlighted,
        curses.ascii.SP:    self.h_act_on_highlighted,
    })


.. @+node:ekr.20170624151245.1061: *7* class MultiLineActionWithShortcuts
class MultiLineActionWithShortcuts(MultiLineAction):
    shortcut_attribute_name = 'shortcut'
    @others
.. @+node:ekr.20170624151245.1062: *8* MultiLineActionWithShortcuts.set_up_handlers
def set_up_handlers(self):
    '''MultiLineActionWithShortcuts.set_up_handlers.'''
    super(MultiLineActionWithShortcuts, self).set_up_handlers()
    self.add_complex_handlers( ((self.h_find_shortcut_action, self.h_execute_shortcut_action),) )
    
    
.. @+node:ekr.20170624151245.1063: *8* MultiLineActionWithShortcuts.h_find_shortcut_action
def h_find_shortcut_action(self, _input):
    _input_decoded = curses.ascii.unctrl(_input)
    for r in range(len(self.values)):
        if hasattr(self.values[r], self.shortcut_attribute_name):
            # from . import utilNotify
            if getattr(self.values[r], self.shortcut_attribute_name) == _input \
            or getattr(self.values[r], self.shortcut_attribute_name) == _input_decoded:
                return r
    return False

.. @+node:ekr.20170624151245.1064: *8* MultiLineActionWithShortcuts.h_execute_shortcut_action
def h_execute_shortcut_action(self, _input):
    l = self.h_find_shortcut_action(_input)
    if l is False:
        return None
    self.cursor_line = l
    self.display()
    self.h_act_on_highlighted(_input)


    

.. @+node:ekr.20170624151245.1065: *7* class Pager
class Pager(MultiLine):
    @others
.. @+node:ekr.20170624151245.1066: *8* Pager.__init__
def __init__(self, screen, autowrap=False,  center=False, **keywords):
    super(Pager, self).__init__(screen, **keywords)
    self.autowrap = autowrap
    self.center = center
    self._values_cache_for_wrapping = []
    
.. @+node:ekr.20170624151245.1067: *8* Pager.reset_display_cache
def reset_display_cache(self):
    super(Pager, self).reset_display_cache()
    self._values_cache_for_wrapping = False

.. @+node:ekr.20170624151245.1068: *8* Pager._wrap_message_lines
def _wrap_message_lines(self, message_lines, line_length):
    lines = []
    for line in message_lines:
        if line.rstrip() == '':
            lines.append('')
        else:
            this_line_set = textwrap.wrap(line.rstrip(), line_length)
            if this_line_set:
                lines.extend(this_line_set)
            else:
                lines.append('')
    return lines

.. @+node:ekr.20170624151245.1069: *8* Pager.resize
def resize(self):
    super(Pager, self).resize()
    if self.autowrap:
        self.setValuesWrap(list(self.values))
    if self.center:
        self.centerValues()

.. @+node:ekr.20170624151245.1070: *8* Pager.setValuesWrap
def setValuesWrap(self, lines):
    if self.autowrap and (lines == self._values_cache_for_wrapping):
        return False
    try:
        lines = lines.split('\n')
    except AttributeError:
        pass
    self.values = self._wrap_message_lines(lines, self.width-1)
    self._values_cache_for_wrapping = self.values

.. @+node:ekr.20170624151245.1071: *8* Pager.centerValues
def centerValues(self):
    self.values  = [ l.strip().center(self.width-1) for l in self.values ]

.. @+node:ekr.20170624151245.1072: *8* Pager.update
def update(self, clear=True):
    #we look this up a lot. Let's have it here.
    if self.autowrap:
        self.setValuesWrap(list(self.values))
    
    if self.center:
        self.centerValues()
        
    display_length = len(self._my_widgets)
    values_len = len(self.values)

    if self.start_display_at > values_len - display_length: 
        self.start_display_at = values_len - display_length
    if self.start_display_at < 0: self.start_display_at = 0
    
    indexer = 0 + self.start_display_at
    for line in self._my_widgets[:-1]: 
        self._print_line(line, indexer)
        indexer += 1
    
    # Now do the final line
    line = self._my_widgets[-1]
        
    if values_len <= indexer+1:
        self._print_line(line, indexer)
    else:
        line.value = MORE_LABEL
        line.highlight = False
        line.show_bold = False
    
    for w in self._my_widgets: 
        # call update to avoid needless refreshes
        w.update(clear=True)
    # There is a bug somewhere that affects the first line.  This cures it.
    # Without this line, the first line inherits the color of the form when not editing. Not clear why.
    self._my_widgets[0].update()
        
        
        
.. @+node:ekr.20170624151245.1073: *8* Pager.edit
def edit(self):
    # Make sure a value never gets set.
    value = self.value
    super(Pager, self).edit()
    self.value = value

.. @+node:ekr.20170624151245.1074: *8* Pager.h_scroll_line_up
def h_scroll_line_up(self, input):
    self.start_display_at -= 1
    if self.scroll_exit and self.start_display_at < 0:
        self.editing = False
        self.how_exited = widget.EXITED_UP

.. @+node:ekr.20170624151245.1075: *8* Pager.h_scroll_line_down
def h_scroll_line_down(self, input):
    self.start_display_at += 1
    if self.scroll_exit and self.start_display_at >= len(self.values)-self.start_display_at+1:
        self.editing = False
        self.how_exited = widget.EXITED_DOWN

.. @+node:ekr.20170624151245.1076: *8* Pager.h_scroll_page_down
def h_scroll_page_down(self, input):
    self.start_display_at += len(self._my_widgets)

.. @+node:ekr.20170624151245.1077: *8* Pager.h_scroll_page_up
def h_scroll_page_up(self, input):
    self.start_display_at -= len(self._my_widgets)

.. @+node:ekr.20170624151245.1078: *8* Pager.h_show_beginning
def h_show_beginning(self, input):
    self.start_display_at = 0   

.. @+node:ekr.20170624151245.1079: *8* Pager.h_show_end
def h_show_end(self, input):
    self.start_display_at = len(self.values) - len(self._my_widgets)

.. @+node:ekr.20170624151245.1080: *8* Pager.h_select_exit
def h_select_exit(self, _input):
    self.exit(self, _input)

.. @+node:ekr.20170624151245.1081: *8* Pager.set_up_handlers
def set_up_handlers(self):
    '''Pager.set_up_handlers.'''
    super(Pager, self).set_up_handlers()
    self.handlers = {
        curses.KEY_UP:      self.h_scroll_line_up,
        curses.KEY_LEFT:    self.h_scroll_line_up,
        curses.KEY_DOWN:    self.h_scroll_line_down,
        curses.KEY_RIGHT:   self.h_scroll_line_down,
        curses.KEY_NPAGE:   self.h_scroll_page_down,
        curses.KEY_PPAGE:   self.h_scroll_page_up,
        curses.KEY_HOME:    self.h_show_beginning,
        curses.KEY_END:     self.h_show_end,
        curses.ascii.NL:    self.h_exit,
        curses.ascii.CR:    self.h_exit,
        curses.ascii.SP:    self.h_scroll_page_down,
        curses.ascii.TAB:   self.h_exit,
        ord('j'):           self.h_scroll_line_down,
        ord('k'):           self.h_scroll_line_up,
        ord('x'):           self.h_exit,
        ord('q'):           self.h_exit,
        ord('g'):           self.h_show_beginning,
        ord('G'):           self.h_show_end,
        curses.ascii.ESC:   self.h_exit_escape,
    }
    self.complex_handlers = []

.. @+node:ekr.20170624151245.1082: *7* class TitleMultiLine
class TitleMultiLine(titlefield.TitleText):
    _entry_type = MultiLine

    @others
.. @+node:ekr.20170624151245.1083: *8* get_selected_objects
def get_selected_objects(self):
    return self.entry_widget.get_selected_objects()

.. @+node:ekr.20170624151245.1084: *8* get_values
def get_values(self):
    if hasattr(self, 'entry_widget'): 
        return self.entry_widget.values
    elif hasattr(self, '__tmp_value'):
        return self.__tmp_values
    else:
        return None
.. @+node:ekr.20170624151245.1085: *8* set_values
def set_values(self, value):
    if hasattr(self, 'entry_widget'): 
        self.entry_widget.values = value
    elif hasattr(self, '__tmp_value'):
        # probably trying to set the value before the textarea is initialised
        self.__tmp_values = value
.. @+node:ekr.20170624151245.1086: *8* del_values
def del_values(self):
    del self.entry_widget.value
values = property(get_values, set_values, del_values)


.. @+node:ekr.20170624151245.1087: *7* class TitlePager
class TitlePager(TitleMultiLine):
    _entry_type = Pager

.. @+node:ekr.20170624151245.1088: *7* class BufferPager
class BufferPager(Pager):
    DEFAULT_MAXLEN = None
    
    @others
.. @+node:ekr.20170624151245.1089: *8* BufferPager.__init__
def __init__(self, screen, maxlen=False, *args, **keywords):
    super(BufferPager, self).__init__(screen, *args, **keywords)
    if maxlen is False:
        maxlen = self.DEFAULT_MAXLEN
    self.values = collections.deque(maxlen=maxlen)

.. @+node:ekr.20170624151245.1090: *8* BufferPager.clearBuffer
def clearBuffer(self):
    self.values.clear()

.. @+node:ekr.20170624151245.1091: *8* BufferPager.setValuesWrap
def setValuesWrap(self, lines):
    if self.autowrap and (lines == self._values_cache_for_wrapping):
        return False
    try:
        lines = lines.split('\n')
    except AttributeError:
        pass
    
    self.clearBuffer()
    self.buffer(self._wrap_message_lines(lines, self.width-1))
    self._values_cache_for_wrapping = copy.deepcopy(self.values) 

.. @+node:ekr.20170624151245.1092: *8* BufferPager.buffer
def buffer(self, lines, scroll_end=True, scroll_if_editing=False):
    "Add data to be displayed in the buffer."
    self.values.extend(lines)
    if scroll_end:
        if not self.editing:
            self.start_display_at = len(self.values) - len(self._my_widgets)
        elif scroll_if_editing:
            self.start_display_at = len(self.values) - len(self._my_widgets)
            
.. @+node:ekr.20170624151245.1093: *7* class TitleBufferPager
class TitleBufferPager(TitleMultiLine):
    _entry_type = BufferPager
        
    @others
.. @+node:ekr.20170624151245.1094: *8* clearBuffer
def clearBuffer(self):
    return self.entry_widget.clearBuffer()

.. @+node:ekr.20170624151245.1095: *8* buffer
def buffer(self, *args, **values):
    return self.entry_widget.buffer(*args, **values)
            




.. @+node:ekr.20170624151245.1096: *6* @file ../external/npyscreen/wgmultilineeditable.py
import curses
from . import wgwidget
from . import wgmultiline
from . import wgtextbox as textbox
from . import wgboxwidget
import leo.core.leoGlobals as g
assert g
#pylint: disable=no-member
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1097: *7* class MultiLineEditable (MultiLine)
class MultiLineEditable(wgmultiline.MultiLine):
    _contained_widgets      = textbox.Textfield 
    CHECK_VALUE             = True
    ALLOW_CONTINUE_EDITING  = True
    CONTINUE_EDITING_AFTER_EDITING_ONE_LINE = True
    
    @others
.. @+node:ekr.20170624151245.1098: *8* MultiLineEditable.get_new_value
def get_new_value(self):
    return ''
    
.. @+node:ekr.20170624151245.1099: *8* MultiLineEditable.check_line_value
def check_line_value(self, vl):
    if not vl:
        return False
    else:
        return True
        
.. @+node:ekr.20170624151245.1100: *8* MultiLineEditable.edit_cursor_line_value
def edit_cursor_line_value(self):
    if not self.values:
        self.insert_line_value()
        return False
    try:
        active_line = self._my_widgets[(self.cursor_line-self.start_display_at)]
    except IndexError:
        self._my_widgets[0] ### Huh?
        self.cursor_line = 0
        self.insert_line_value()
        return True
    active_line.highlight = False
    active_line.edit()
    try:
        self.values[self.cursor_line] = active_line.value
    except IndexError:
        self.values.append(active_line.value)
        if not self.cursor_line:
            self.cursor_line = 0
        self.cursor_line = len(self.values) - 1
    self.reset_display_cache()
    
    if self.CHECK_VALUE:
        if not self.check_line_value(self.values[self.cursor_line]):
            self.delete_line_value()
            return False
    
    self.display()
    return True

.. @+node:ekr.20170624151245.1101: *8* MultiLineEditable.insert_line_value
def insert_line_value(self):
    if self.cursor_line is None:
        self.cursor_line = 0
    self.values.insert(self.cursor_line, self.get_new_value())
    self.display()
    cont = self.edit_cursor_line_value()
    if cont and self.ALLOW_CONTINUE_EDITING:
        self._continue_editing()

.. @+node:ekr.20170624151245.1102: *8* MultiLineEditable.delete_line_value
def delete_line_value(self):
    if self.values:
        del self.values[self.cursor_line]
        self.display()
.. @+node:ekr.20170624151245.1103: *8* MultiLineEditable._continue_editing
def _continue_editing(self):
    
    # g.trace('MultiLineEditable')
    active_line = self._my_widgets[(self.cursor_line-self.start_display_at)]
    continue_editing = self.ALLOW_CONTINUE_EDITING
    if hasattr(active_line, 'how_exited'):
        while active_line.how_exited == wgwidget.EXITED_DOWN and continue_editing:
            self.values.insert(self.cursor_line+1, self.get_new_value())
            self.cursor_line += 1
            self.display()
            continue_editing = self.edit_cursor_line_value()
            active_line = self._my_widgets[(self.cursor_line-self.start_display_at)]

.. @+node:ekr.20170624151245.1104: *8* MultiLineEditable.Handlers
.. @+node:ekr.20170624151245.1105: *9* MultiLineEditable.h_insert_next_line
def h_insert_next_line(self, ch):
    
    # pylint: disable=len-as-condition
    if len(self.values) == self.cursor_line - 1 or len(self.values) == 0:
        self.values.append(self.get_new_value())
        self.cursor_line += 1
        self.display()
        cont = self.edit_cursor_line_value()
        if cont and self.ALLOW_CONTINUE_EDITING:
            self._continue_editing()
        
    else:
        self.cursor_line += 1
        self.insert_line_value()

.. @+node:ekr.20170624151245.1106: *9* MultiLineEditable.h_edit_cursor_line_value
def h_edit_cursor_line_value(self, ch):
    continue_line = self.edit_cursor_line_value()
    if continue_line and self.CONTINUE_EDITING_AFTER_EDITING_ONE_LINE:
        self._continue_editing()
        
.. @+node:ekr.20170624151245.1107: *9* MultiLineEditable.h_insert_value
def h_insert_value(self, ch):
    return self.insert_line_value()

.. @+node:ekr.20170624151245.1108: *9* MultiLineEditable.h_delete_line_value
def h_delete_line_value(self, ch):
    self.delete_line_value()
.. @+node:ekr.20170624151245.1109: *9* set_up_handlers
def set_up_handlers(self):
    '''MultiLineEditable.set_up_handlers.'''
    super(MultiLineEditable, self).set_up_handlers()
    self.handlers.update ( {
        ord('i'):               self.h_insert_value,
        ord('o'):               self.h_insert_next_line,
        curses.ascii.CR:        self.h_edit_cursor_line_value,
        curses.ascii.NL:        self.h_edit_cursor_line_value,
        curses.ascii.SP:        self.h_edit_cursor_line_value,
        curses.ascii.DEL:       self.h_delete_line_value,
        curses.ascii.BS:        self.h_delete_line_value,
        curses.KEY_BACKSPACE:   self.h_delete_line_value,
    })
.. @+node:ekr.20170624151245.1110: *7* class MultiLineEditableTitle
class MultiLineEditableTitle(wgmultiline.TitleMultiLine):
    _entry_type = MultiLineEditable
    
.. @+node:ekr.20170624151245.1111: *7* class MultiLineEditableBoxed
class MultiLineEditableBoxed(wgboxwidget.BoxTitle):
    _contained_widget = MultiLineEditable
    
.. @+node:ekr.20170624151245.1112: *6* @file ../external/npyscreen/wgmultilinetree.py
#!/usr/bin/python
<< wgmultilinetree imports >>
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1113: *7* << wgmultilinetree imports >>
import curses
import weakref

from . import wgmultiline    as multiline
from . import wgtextbox      as textbox
from npyscreen.compatibility_code import npysNPSTree as NPSTree
from .npysTree import TreeData

import leo.core.leoGlobals as g
assert g

.. @+node:ekr.20170624151245.1114: *7* class TreeLine (textbox.TextfieldBase)
class TreeLine(textbox.TextfieldBase):
    @others
.. @+node:ekr.20170624151245.1115: *8* TreeLine.__init__
def __init__(self, *args, **keywords):
    self._tree_real_value   = None
    self._tree_ignore_root  = None
    self._tree_depth        = False
    self._tree_sibling_next = False
    self._tree_has_children = False
    self._tree_expanded     = True
    self._tree_last_line    = False
    self._tree_depth_next   = False
    self.safe_depth_display = False
    self.show_v_lines       = True
    super(TreeLine, self).__init__(*args, **keywords)
.. @+node:ekr.20170624151245.1116: *8* TreeLine._get_content_for_display
# Compatibility

def _get_content_for_display(self, vl):
    try:
        return vl.get_content_for_display()
    except AttributeError:
        return vl.getContentForDisplay()
.. @+node:ekr.20170624151245.1117: *8* TreeLine._print
def _print(self, left_margin=0):
    self.left_margin = left_margin
    self.parent.curses_pad.bkgdset(' ',curses.A_NORMAL)
    self.left_margin += self._print_tree(self.relx)
    if self.highlight:
        self.parent.curses_pad.bkgdset(' ',curses.A_STANDOUT)
    super(TreeLine, self)._print()
.. @+node:ekr.20170624151245.1118: *8* TreeLine._print_tree
def _print_tree(self, real_x):
    if (not hasattr(self._tree_real_value, 'find_depth') and
        not hasattr(self._tree_real_value, 'findDepth')
    ):
        margin_needed = 0
        return margin_needed

    control_chars_added = 0
    this_safe_depth_display = self.safe_depth_display or ((self.width // 2) + 1)
    if self._tree_depth_next:
        _tree_depth_next = self._tree_depth_next
    else:
        _tree_depth_next = 0
    dp = self._tree_depth
    if self._tree_ignore_root:
        dp -= 1
    if dp: # > 0:
        if dp < this_safe_depth_display:                    
            for i in range(dp-1):
                if (i < _tree_depth_next) and (not self._tree_last_line):
                        # was i+1 < # and not (_tree_depth_next==1):
                    if self.show_v_lines:
                        self.parent.curses_pad.addch(
                            self.rely,
                            real_x,
                            curses.ACS_VLINE,
                            curses.A_NORMAL)
                        if self.height > 1:
                            for h in range(self.height-1):
                                self.parent.curses_pad.addch(
                                    self.rely+h+1,
                                    real_x,
                                    curses.ACS_VLINE,
                                    curses.A_NORMAL)
                    else:
                        self.parent.curses_pad.addch(
                            self.rely,
                            real_x,
                            ' ',
                            curses.A_NORMAL)
                        
                else:
                    if self.show_v_lines:
                        self.parent.curses_pad.addch(
                            self.rely,
                            real_x,
                            curses.ACS_BTEE,
                            curses.A_NORMAL)
                    else:
                        self.parent.curses_pad.addch(
                            self.rely,
                            real_x,
                            ' ',
                            curses.A_NORMAL)
                real_x +=1
                self.parent.curses_pad.addch(
                    self.rely,
                    real_x,
                    ord(' '),
                    curses.A_NORMAL)
                real_x +=1

            if self._tree_sibling_next or _tree_depth_next > self._tree_depth:
                self.parent.curses_pad.addch(
                    self.rely,
                    real_x,
                    curses.ACS_LTEE,
                    curses.A_NORMAL)
                if self.height > 1:
                    for h in range(self.height-1):
                        self.parent.curses_pad.addch(
                            self.rely+h+1,
                            real_x,
                            curses.ACS_VLINE,
                            curses.A_NORMAL)
            else:
                self.parent.curses_pad.addch(
                    self.rely,
                    real_x,
                    curses.ACS_LLCORNER,
                    curses.A_NORMAL)
            real_x += 1
            self.parent.curses_pad.addch(
                self.rely,
                real_x,
                curses.ACS_HLINE,
                curses.A_NORMAL)
            real_x += 1
        else: # dp >= this_safe_depth_display
            self.parent.curses_pad.addch(
                self.rely,
                real_x,
                curses.ACS_HLINE,
                curses.A_NORMAL)
            real_x += 1
            self.parent.curses_pad.addstr(
                self.rely, real_x,
                "[ %s ]" % (str(dp)),
                curses.A_NORMAL)
            real_x += len(str(dp)) + 4
            self.parent.curses_pad.addch(
                self.rely,
                real_x,
                curses.ACS_RTEE,
                curses.A_NORMAL)
            real_x += 1
            
    if self._tree_has_children:
        if self._tree_expanded:
            self.parent.curses_pad.addch(
                self.rely,
                real_x,
                curses.ACS_TTEE,
                curses.A_NORMAL)
            if self.height > 1:
                for h in range(self.height-1):
                    self.parent.curses_pad.addch(
                        self.rely+h+1,
                        real_x,
                        curses.ACS_VLINE,
                        curses.A_NORMAL)
        else: # not expanded
            self.parent.curses_pad.addch(
                self.rely,
                real_x,
                curses.ACS_RARROW,
                curses.A_NORMAL)

    real_x +=1 # whether or not the tree has children
    control_chars_added += real_x - self.relx
    margin_needed = control_chars_added + 1
    return margin_needed
.. @+node:ekr.20170624151245.1119: *8* TreeLine.display_value
def display_value(self, vl):
    try:
        return self.safe_string(
            self._get_content_for_display(self._tree_real_value))
    except Exception:
        # Catch the times this is None.
        return self.safe_string(vl)
.. @+node:ekr.20170624151245.1120: *7* class TreeLineAnnotated (experimental)
class TreeLineAnnotated(TreeLine):
    ## Experimental.
    _annotate = "   ?   "
    _annotatecolor = 'CONTROL'

    @others
.. @+node:ekr.20170624151245.1121: *8* getAnnotationAndColor
def getAnnotationAndColor(self):
    # This is actually the api.
    # Override this function to return the correct string and colour name as a tuple.
    self.setAnnotateString()
    return (self._annotate, self._annotatecolor)
.. @+node:ekr.20170624151245.1122: *8* setAnnotateString
def setAnnotateString(self):
    # This was an experimental function it was the original way to set the string and annotation.
    self._annotate = "   ?   "
    self._annotatecolor = 'CONTROL'

.. @+node:ekr.20170624151245.1123: *8* annotationColor
def annotationColor(self, real_x):
    # Must return the "Margin" needed before the entry begins
     # historical reasons.
    _annotation, _color = self.getAnnotationAndColor()
    self.parent.curses_pad.addstr(self.rely, real_x, _annotation, self.parent.theme_manager.findPair(self, _color))
    return len(_annotation)

.. @+node:ekr.20170624151245.1124: *8* annotationNoColor
def annotationNoColor(self, real_x):
    # Must return the "Margin" needed before the entry begins
    #self.parent.curses_pad.addstr(self.rely, real_x, 'xxx')
    #return 3
    _annotation, _color = self.getAnnotationAndColor()
    self.parent.curses_pad.addstr(self.rely, real_x, _annotation)
    return len(_annotation)

.. @+node:ekr.20170624151245.1125: *8* _print
def _print(self):
    self.left_margin = 0
    self.parent.curses_pad.bkgdset(' ',curses.A_NORMAL)
    self.left_margin += self._print_tree(self.relx)
    if self.do_colors():    
        self.left_margin += self.annotationColor(self.left_margin+self.relx)
    else:
        self.left_margin += self.annotationNoColor(self.left_margin+self.relx)
    if self.highlight:
        self.parent.curses_pad.bkgdset(' ',curses.A_STANDOUT)
    super(TreeLine, self)._print()


.. @+node:ekr.20170624151245.1126: *7* class MLTree (multiline.MultiLine)
class MLTree(multiline.MultiLine):

    _contained_widgets = TreeLine

    @others
.. @+node:ekr.20170624151245.1127: *8* MLTree._before_print_lines
# Compatibility.
def _before_print_lines(self):
    pass
.. @+node:ekr.20170624151245.1128: *8* MLTree._find_depth
def _find_depth(self, vl):
    try:
        return vl.find_depth()
    except AttributeError:
        return vl.findDepth()

.. @+node:ekr.20170624151245.1129: *8* MLTree._get_content
def _get_content(self, vl):
    try:
        return vl.get_content()
    except AttributeError:
        return vl.getContent()

.. @+node:ekr.20170624151245.1130: *8* MLTree._get_ignore_root
def _get_ignore_root(self, vl):
    try:
        return vl.ignore_root
    except AttributeError:
        return vl.ignoreRoot

.. @+node:ekr.20170624151245.1131: *8* MLTree._get_tree_as_list
def _get_tree_as_list(self, vl):
    g.trace('MLTree:', vl)
    try:
        return vl.get_tree_as_list()
    except AttributeError:
        return vl.getTreeAsList()
.. @+node:ekr.20170624151245.1132: *8* MLTree._has_children
def _has_children(self, vl):
    try:
        return vl.has_children()
    except AttributeError:
        return vl.hasChildren()
.. @+node:ekr.20170624151245.1133: *8* MLTree._set_line_values
def _set_line_values(self, line, value_indexer):
    line._tree_real_value   = None
    line._tree_depth        = False
    line._tree_sibling_next = False
    line._tree_has_children = False
    line._tree_expanded     = False
    line._tree_last_line    = False
    line._tree_depth_next   = False
    line._tree_ignore_root  = None
    try:
        line.value = self.display_value(self.values[value_indexer])
        line._tree_real_value = self.values[value_indexer]
        line._tree_ignore_root = self._get_ignore_root(self._myFullValues)
        try:
            line._tree_depth        = self._find_depth(self.values[value_indexer])
            line._tree_has_children = self._has_children(self.values[value_indexer])
            line._tree_expanded     = self.values[value_indexer].expanded
        except Exception:
            line._tree_depth        = False
            line._tree_has_children = False
            line._tree_expanded     = False
        try:
            if line._tree_depth == self._find_depth(self.values[value_indexer+1]):
                line._tree_sibling_next = True
            else:
                line._tree_sibling_next = False
        except Exception:
            line._sibling_next = False
            line._tree_last_line = True
        try:
            line._tree_depth_next = self._find_depth(self.values[value_indexer+1])
        except Exception:
            line._tree_depth_next = False
        line.hidden = False
    except IndexError:
        self._set_line_blank(line)
    except TypeError:
        self._set_line_blank(line)
.. @+node:ekr.20170624151245.1134: *8* MLTree._walk_tree
def _walk_tree(self, root, only_expanded=True, ignore_root=True, sort=None, sort_function=None):
    try:
        return root.walk_tree(
            only_expanded=only_expanded,
            ignore_root=ignore_root,
            sort=sort,
            sort_function=sort_function)
    except AttributeError:
        return root.walkTree(
            onlyExpanded=only_expanded,
            ignoreRoot=ignore_root,
            sort=sort,
            sort_function=sort_function)
.. @+node:ekr.20170624151245.1135: *8* MLTree._walkMyValues
def _walkMyValues(self):
    return self._walk_tree(self._myFullValues)
.. @+node:ekr.20170624151245.1136: *8* MLTree.clearDisplayCache
def clearDisplayCache(self):
    self._cached_tree = None
    self._cached_sort = None
    self._cached_tree_as_list = None
.. @+node:ekr.20170624151245.1137: *8* MLTree.convertToTree
def convertToTree(self, tree):
    "Override this function to convert a set of values to a tree."
    return None
.. @+node:ekr.20170624151245.1138: *8* MLTree.display_value
def display_value(self, vl):
    return vl
.. @+node:ekr.20170624151245.1139: *8* MLTree.filter_value
def filter_value(self, index):
    if self._filter in self._get_content(self.display_value(self.values[index])):
        return True
    else:
        return False
.. @+node:ekr.20170624151245.1140: *8* MLTree.resize
def resize(self):
    super(MLTree, self).resize()
    self.clearDisplayCache()
    self.update(clear=True)
    self.display()
.. @+node:ekr.20170624151245.1141: *8* MLTree.values Property
@others

values = property(_getApparentValues, _setMyValues, _delMyValues)
.. @+node:ekr.20170624151245.1142: *9* MLTree._delMyValues
def _delMyValues(self):
    self._myFullValues = None
.. @+node:ekr.20170624151245.1143: *9* MLTree._getApparentValues
def _getApparentValues(self):
    try:
        if (
            self._cached_tree is weakref.proxy(self._myFullValues) and 
            (self._cached_sort == (self._myFullValues.sort, self._myFullValues.sort_function))
        ):
            return self._cached_tree_as_list
    except Exception:
        pass
    self._cached_tree = weakref.proxy(self._myFullValues)
    self._cached_sort = (self._myFullValues.sort, self._myFullValues.sort_function)
    self._cached_tree_as_list = self._get_tree_as_list(self._myFullValues)
    return self._cached_tree_as_list
.. @+node:ekr.20170624151245.1144: *9* MLTree._setMyValues
def _setMyValues(self, tree):
    if tree == [] or tree == None:
        self._myFullValues = TreeData() #NPSTree.NPSTreeData()
    elif not (isinstance(tree, TreeData) or isinstance(tree, NPSTree.NPSTreeData)):
        tree = self.convertToTree(tree)
        # g.trace(tree)
        self._myFullValues = tree
        if not (isinstance(tree, TreeData) or isinstance(tree, NPSTree.NPSTreeData)):
            raise TypeError(
                "MultiLineTree widget can only contain a TreeData or NPSTreeData object"
                " in its values attribute"
            )
    else:
        self._myFullValues = tree
.. @+node:ekr.20170624151245.1145: *8* MLTree.Handlers
.. @+node:ekr.20170624151245.1146: *9* MLTree.h_collapse_tree
def h_collapse_tree(self, ch):
    if self.values[self.cursor_line].expanded and self._has_children(self.values[self.cursor_line]):
        self.values[self.cursor_line].expanded = False
    else:
        look_for_depth = self._find_depth(self.values[self.cursor_line]) - 1
        cursor_line = self.cursor_line - 1
        while cursor_line >= 0:
            if look_for_depth == self._find_depth(self.values[cursor_line]):
                self.cursor_line = cursor_line
                self.values[cursor_line].expanded = False
                break
            else:
                cursor_line -= 1
    self._cached_tree = None
    self.display()
.. @+node:ekr.20170624151245.1147: *9* MLTree.h_expand_tree
def h_expand_tree(self, ch):
    if not self.values[self.cursor_line].expanded:
        self.values[self.cursor_line].expanded = True
    else:
        for v in self._walk_tree(
            self.values[self.cursor_line],
            only_expanded=False
        ):
            v.expanded = True
    self._cached_tree = None
    self.display()
.. @+node:ekr.20170624151245.1148: *9* MLTree.h_collapse_all
def h_collapse_all(self, ch):
    for v in self._walk_tree(self._myFullValues, only_expanded=True):
        v.expanded = False
    self._cached_tree = None
    self.cursor_line = 0
    self.display()

.. @+node:ekr.20170624151245.1149: *9* MLTree.h_expand_all
def h_expand_all(self, ch):
    for v in self._walk_tree(self._myFullValues, only_expanded=False):
        v.expanded    = True
    self._cached_tree = None
    self.cursor_line  = 0
    self.display()
.. @+node:ekr.20170624151245.1150: *9* MLTree.set_up_handlers
def set_up_handlers(self):
    '''TreeLineAnnotated.set_up_handlers.'''
    super(MLTree, self).set_up_handlers()
    self.handlers.update({
        ord('<'): self.h_collapse_tree,
        ord('>'): self.h_expand_tree,
        ord('['): self.h_collapse_tree,
        ord(']'): self.h_expand_tree,
        ord('{'): self.h_collapse_all,
        ord('}'): self.h_expand_all,
        ord('h'): self.h_collapse_tree,
        ord('l'): self.h_expand_tree,          
    })
.. @+node:ekr.20170624151245.1151: *7* class MLTreeAnnotated
class MLTreeAnnotated(MLTree):
    _contained_widgets = TreeLineAnnotated

.. @+node:ekr.20170624151245.1152: *7* class MLTreeAction
class MLTreeAction(MLTree, multiline.MultiLineAction):
    pass

.. @+node:ekr.20170624151245.1153: *7* class MLTreeAnnotatedAction
class MLTreeAnnotatedAction(MLTree, multiline.MultiLineAction):
    _contained_widgets = TreeLineAnnotated










.. @+node:ekr.20170624151245.1154: *6* @nosent ../external/npyscreen/wgmultilineeditabletree.py
#!/usr/bin/python
'''The MLTreeEditable class.'''
# By Edward K. Ream

# pylint: disable=logging-not-lazy

import curses
import logging
import npyscreen
import weakref
@others
@language python
@tabwidth -4


.. @+node:ekr.20170624151245.1155: *7* Logging
def print_list(aList, tag=None, sort=False, indent=''):
    
    if aList:
        bList = list(sorted(aList)) if sort else aList
        logging.info('%s...[' % (tag) if tag else '[')
        for e in bList:
            logging.info('%s%s' % (indent, repr(e).strip()))
        logging.info(']')
    else:
        logging.info(tag + '...[]' if tag else '[]')
.. @+node:ekr.20170624151245.1156: *7* class TreeDataEditable (npyscreen.TreeData)
class TreeDataEditable(npyscreen.TreeData):
    '''A TreeData class that has a len and new_first_child methods.'''

    def __len__(self):
        return len(self.content)
        
    def new_child_at(self, index, *args, **keywords):
        '''Same as TreeData.new_child, with insert(index, c) instead of append(c)'''
        if self.CHILDCLASS:
            cld = self.CHILDCLASS
        else:
            cld = type(self)
        c = cld(parent=self, *args, **keywords)
        self._children.insert(index, c)
        return weakref.proxy(c)
.. @+node:ekr.20170624151245.1157: *7* class TreeLineEditable (npyscreen.TreeLine)
class TreeLineEditable(npyscreen.TreeLine):
    '''A editable TreeLine class.'''

    def __init__(self, *args, **kwargs):

        super(TreeLineEditable, self).__init__(*args, **kwargs)
        self.set_handlers()

    @others
.. @+node:ekr.20170624151245.1158: *8* TreeLineEditable.edit
def edit(self):
    """Allow the user to edit the widget: ie. start handling keypresses."""
    self.editing = True
    # self._pre_edit()
    self.highlight = True
    self.how_exited = False
    # self._edit_loop()
    old_parent_editing = self.parent.editing
    self.parent.editing = True
    while self.editing and self.parent.editing:
        self.display()
        self.get_and_use_key_press()
            # A base TreeLine method.
    self.parent.editing = old_parent_editing
    self.editing = False
    self.how_exited = True
    # return self._post_edit()
    self.highlight = False
    self.update()
.. @+node:ekr.20170624151245.1159: *8* TreeLineEditable.handlers
.. @+node:ekr.20170624151245.1160: *9* TreeLineEditable.h_cursor_beginning
def h_cursor_beginning(self, ch):

    self.cursor_position = 0
.. @+node:ekr.20170624151245.1161: *9* TreeLineEditable.h_cursor_end
def h_cursor_end(self, ch):
    
    # self.value is a TreeDataEditable.
    self.cursor_position = max(0, len(self.value.content)-1)
.. @+node:ekr.20170624151245.1162: *9* TreeLineEditable.h_cursor_left
def h_cursor_left(self, input):
    
    self.cursor_position = max(0, self.cursor_position -1)
.. @+node:ekr.20170624151245.1163: *9* TreeLineEditable.h_cursor_right
def h_cursor_right(self, input):

    self.cursor_position += 1

.. @+node:ekr.20170624151245.1164: *9* TreeLineEditable.h_delete_left
def h_delete_left(self, input):

    # self.value is a TreeDataEditable.
    n = self.cursor_position
    s = self.value.content
    if 0 <= n <= len(s):
        self.value.content = s[:n] + s[n+1:]
        self.cursor_position -= 1
.. @+node:ekr.20170624151245.1165: *9* TreeLineEditable.h_end_editing
def h_end_editing(self, ch):

    # logging.info('TreeLineEditable: %s' % ch)
    self.editing = False
    self.how_exited = None
.. @+node:ekr.20170624151245.1166: *9* TreeLineEditable.h_insert
def h_insert(self, i):

    # self.value is a TreeDataEditable.
    n = self.cursor_position + 1
    s = self.value.content
    self.value.content = s[:n] + chr(i) + s[n:]
    self.cursor_position += 1
.. @+node:ekr.20170624151245.1167: *9* TreeLineEditable.set_handlers
def set_handlers(self):
    
    # pylint: disable=no-member
    # Override *all* other complex handlers.
    if 1:
        self.complex_handlers = (
            (curses.ascii.isprint, self.h_insert),
        )
    else:
        self.complex_handlers.append(
            (curses.ascii.isprint, self.h_insert),
        )
    self.handlers.update({
        curses.ascii.ESC:       self.h_end_editing,
        curses.ascii.NL:        self.h_end_editing,
        curses.ascii.LF:        self.h_end_editing,
        curses.KEY_HOME:        self.h_cursor_beginning,  # 262
        curses.KEY_END:         self.h_cursor_end,        # 358.
        curses.KEY_LEFT:        self.h_cursor_left,
        curses.KEY_RIGHT:       self.h_cursor_right,
        curses.ascii.BS:        self.h_delete_left,
        curses.KEY_BACKSPACE:   self.h_delete_left,
    })
.. @+node:ekr.20170624151245.1168: *7* class MLTreeEditable (npyscreen.MLTree)
class MLTreeLine (npyscreen.MLTree):

    # pylint: disable=used-before-assignment
    _contained_widgets = TreeLineEditable
        
    def set_up_handlers(self):
        super(MLTreeLine, self).set_up_handlers()
        assert not hasattr(self, 'hidden_root_node'), repr(self)
        ### self.leo_c = None # Set later.
        self.hidden_root_node = None
        self.set_handlers()

    @others
.. @+node:ekr.20170624151245.1169: *8* MLTreeEditable.Debugging
def dump_values(self):
    
    def info(z):
        return '%15s: %s' % (z._parent.get_content(), z.get_content())

    print_list([info(z) for z in self.values])
    
def dump_widgets(self):
    
    def info(z):
        return '%s.%s' % (id(z), z.__class__.__name__)

    print_list([info(z) for z in self._my_widgets])
.. @+node:ekr.20170624151245.1170: *8* MLTreeEditable.Entries
.. @+node:ekr.20170624151245.1171: *9* MLTreeEditable.delete_line (to do: delete all children)
def delete_line(self):

    trace = True
    if trace:
        logging.info('cursor_line: %r' % self.cursor_line)
        self.dump_values()
    if self.values:
        del self.values[self.cursor_line]
        self.display()
.. @+node:ekr.20170624151245.1172: *9* MLTreeEditable.edit_headline
def edit_headline(self):

    trace = True
    if not self.values:
        if trace: logging.info('no values')
        self.insert_line()
        return False
    try:
        active_line = self._my_widgets[(self.cursor_line-self.start_display_at)]
        if trace: logging.info('MLTreeEditable.active_line: %r' % active_line)
    except IndexError:
        # pylint: disable=pointless-statement
        self._my_widgets[0]
            # Does this have something to do with weakrefs?
        self.cursor_line = 0
        self.insert_line()
        return True
    active_line.highlight = False
    active_line.edit()
    try:
        self.values[self.cursor_line] = active_line.value
    except IndexError:
        self.values.append(active_line.value)
        if not self.cursor_line:
            self.cursor_line = 0
        self.cursor_line = len(self.values) - 1
    self.reset_display_cache()
    self.display()
    return True
.. @+node:ekr.20170624151245.1173: *9* MLTreeEditable.new_node
def new_node(self):
    '''
    Insert a new outline TreeData widget at the current line.
    As with Leo, insert as the first child of the current line if
    the current line is expanded. Otherwise insert after the current line.
    '''
    trace = True
    trace_values = False
    node = self.values[self.cursor_line]
    if trace:
        logging.info('LeoMLTree: %r' % node)
        if trace_values:
            self.dump_values()
    headline = 'New headline'
    if node.has_children() and node.expanded:
        node = node.new_child_at(index=0, content=headline)
    elif node.get_parent():
        parent = node.get_parent()
        node = parent.new_child(content=headline)
    else:
        parent = self.hidden_root_node
        index = parent._children.index(node)
        node = parent.new_child_at(index=index, content=headline)
    if trace:
        logging.info('LeoMLTree: line: %3s %s' % (self.cursor_line, headline))
    return node
.. @+node:ekr.20170624151245.1174: *9* MLTreeEditable.insert_line
def insert_line(self):
    
    trace = True
    trace_values = False
    if trace:
        logging.info('cursor_line: %r', self.cursor_line)
        if trace_values: self.dump_values()
    if self.cursor_line is None:
        self.cursor_line = 0
    self.values.insert(self.cursor_line+1, self.new_node())
    self.cursor_line += 1
    self.display()
    self.edit_headline()
   
.. @+node:ekr.20170624151245.1175: *8* MLTreeEditable.Handlers
# These insert or delete entire outline nodes.
.. @+node:ekr.20170624151245.1176: *9* MLTreeEditable.h_delete
def h_delete(self, ch):

    self.delete_line()
.. @+node:ekr.20170624151245.1177: *9* MLTreeEditable.h_edit_headline
def h_edit_headline(self, ch):
    
    self.edit_headline()
.. @+node:ekr.20170624151245.1178: *9* MLTreeEditable.h_insert
def h_insert(self, ch):

    return self.insert_line()
.. @+node:ekr.20170624151245.1179: *9* MLTreeEditable.h_move_left
def h_move_left(self, ch):
    
    node = self.values[self.cursor_line]
    if self._has_children(node) and node.expanded:
        self.h_collapse_tree(ch)
    else:
        self.h_cursor_line_up(ch)
.. @+node:ekr.20170624151245.1180: *9* MLTreeEditable.h_move_right
def h_move_right(self, ch):
    
    node = self.values[self.cursor_line]
    if self._has_children(node):
        if node.expanded:
            self.h_cursor_line_down(ch)
        else:
            self.h_expand_tree(ch)
    else:
        self.h_cursor_line_down(ch)
.. @+node:ekr.20170624151245.1181: *9* MLTreeEditable.set_handlers
def set_handlers(self):
    
    # pylint: disable=no-member
    d = {
        curses.KEY_LEFT: self.h_move_left,
        curses.KEY_RIGHT: self.h_move_right,
        ord('d'): self.h_delete,
        ord('h'): self.h_edit_headline,
        ord('i'): self.h_insert,
        ### ord('o'): self.h_insert_after,
        # curses.ascii.CR:        self.h_edit_cursor_line_value,
        # curses.ascii.NL:        self.h_edit_cursor_line_value,
        # curses.ascii.SP:        self.h_edit_cursor_line_value,
        # curses.ascii.DEL:       self.h_delete_line_value,
        # curses.ascii.BS:        self.h_delete_line_value,
        # curses.KEY_BACKSPACE:   self.h_delete_line_value,
    }
    self.handlers.update(d)
.. @+node:ekr.20170624151245.1182: *6* @file ../external/npyscreen/wgmultilinetreeselectable.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1183: *7* Declarations
import curses
from . import wgmultilinetree

.. @+node:ekr.20170624151245.1184: *7* class TreeLineSelectable
class TreeLineSelectable(wgmultilinetree.TreeLine):
    # NB - as print is currently defined, it is assumed that these will 
    # NOT contain multi-width characters, and that len() will correctly
    # give an indication of the correct offset
    CAN_SELECT              = '[ ]'
    CAN_SELECT_SELECTED     = '[*]'
    CANNOT_SELECT           = '   '
    CANNOT_SELECT_SELECTED  = ' * '
    
    @others
.. @+node:ekr.20170624151245.1185: *8* _print_select_controls
def _print_select_controls(self):
    SELECT_DISPLAY = None
    
    if self._tree_real_value.selectable:
        if self.value.selected:
            SELECT_DISPLAY = self.CAN_SELECT_SELECTED
        else:
            SELECT_DISPLAY = self.CAN_SELECT
    else:
        if self.value.selected:
            SELECT_DISPLAY = self.CANNOT_SELECT_SELECTED
        else:
            SELECT_DISPLAY = self.CANNOT_SELECT
    
    
    if self.do_colors():
        attribute_list = self.parent.theme_manager.findPair(self, 'CONTROL')
    else:
        attribute_list = curses.A_NORMAL
    
    
    #python2 compatibility
    if isinstance(SELECT_DISPLAY, bytes):
        SELECT_DISPLAY = SELECT_DISPLAY.decode()
    
    
    
    self.add_line(self.rely,
                  self.left_margin+self.relx,
                  SELECT_DISPLAY, 
                  self.make_attributes_list(SELECT_DISPLAY, attribute_list),
                  self.width-self.left_margin,
    )
    
    return len(SELECT_DISPLAY)


.. @+node:ekr.20170624151245.1186: *8* _print
def _print(self, left_margin=0):
    if not hasattr(self._tree_real_value, 'selected'):
        return None
    self.left_margin = left_margin
    self.parent.curses_pad.bkgdset(' ',curses.A_NORMAL)
    self.left_margin += self._print_tree(self.relx)
    
    self.left_margin += self._print_select_controls() + 1

    
    if self.highlight:
        self.parent.curses_pad.bkgdset(' ',curses.A_STANDOUT)
    super(wgmultilinetree.TreeLine, self)._print()
    
    
.. @+node:ekr.20170624151245.1187: *7* class TreeLineSelectableAnnotated
class TreeLineSelectableAnnotated(TreeLineSelectable, wgmultilinetree.TreeLineAnnotated):
    @others
.. @+node:ekr.20170624151245.1188: *8* _print
def _print(self, left_margin=0):
    if not hasattr(self._tree_real_value, 'selected'):
        return None
    self.left_margin = left_margin
    self.parent.curses_pad.bkgdset(' ',curses.A_NORMAL)
    self.left_margin += self._print_tree(self.relx)
    self.left_margin += self._print_select_controls() + 1
    if self.do_colors():    
        self.left_margin += self.annotationColor(self.left_margin+self.relx)
    else:
        self.left_margin += self.annotationNoColor(self.left_margin+self.relx)
    if self.highlight:
        self.parent.curses_pad.bkgdset(' ',curses.A_STANDOUT)
    super(wgmultilinetree.TreeLine, self)._print()
    
    

.. @+node:ekr.20170624151245.1189: *7* class MLTreeMultiSelect
class MLTreeMultiSelect(wgmultilinetree.MLTree):
    _contained_widgets = TreeLineSelectable
    @others
.. @+node:ekr.20170624151245.1190: *8* __init__
def __init__(self, screen, select_cascades=True, *args, **keywords):
    super(MLTreeMultiSelect, self).__init__(screen, *args, **keywords)
    self.select_cascades = select_cascades
    
.. @+node:ekr.20170624151245.1191: *8* MLTreeMultiSelect.h_select
def h_select(self, ch):
    vl = self.values[self.cursor_line]
    vl_to_set = not vl.selected
    if self.select_cascades:
        for v in self._walk_tree(vl, only_expanded=False, ignore_root=False):
            if v.selectable:
                v.selected = vl_to_set
    else:
        vl.selected = vl_to_set
    if self.select_exit:
        self.editing = False
        self.how_exited = True
    self.display()
.. @+node:ekr.20170624151245.1192: *8* get_selected_objects
def get_selected_objects(self, return_node=True):
    for v in self._walk_tree(self._myFullValues, only_expanded=False, ignore_root=False):
        if v.selected:
            if return_node:
                yield v
            else:
                yield self._get_content(v)
                
.. @+node:ekr.20170624151245.1193: *7* class MLTreeMultiSelectAnnotated
class MLTreeMultiSelectAnnotated(MLTreeMultiSelect):
    _contained_widgets = TreeLineSelectableAnnotated
    
.. @+node:ekr.20170624151245.1194: *6* @file ../external/npyscreen/wgmultiselect.py
#!/usr/bin/python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1195: *7* Declarations
from . import wgmultiline    as multiline
from . import wgselectone    as selectone
from . import wgcheckbox     as checkbox
import curses

.. @+node:ekr.20170624151245.1196: *7* class MultiSelect
class MultiSelect(selectone.SelectOne):
    _contained_widgets = checkbox.Checkbox

    @others
.. @+node:ekr.20170624151245.1197: *8* MultiSelect.set_up_handlers
def set_up_handlers(self):
    '''MultiSelect.set_up_handlers.'''
    super(MultiSelect, self).set_up_handlers()
    self.handlers.update({
        ord("x"):           self.h_select_toggle,
        curses.ascii.SP:    self.h_select_toggle,
        ord("X"):           self.h_select,
        "^U":               self.h_select_none,
    })

.. @+node:ekr.20170624151245.1198: *8* MultiSelect.h_select_none
def h_select_none(self, input):
    self.value = []

.. @+node:ekr.20170624151245.1199: *8* MultiSelect.h_select_toggle
def h_select_toggle(self, input):
    if self.cursor_line in self.value:
        self.value.remove(self.cursor_line)
    else:
        self.value.append(self.cursor_line)

.. @+node:ekr.20170624151245.1200: *8* MultiSelect.h_set_filtered_to_selected
def h_set_filtered_to_selected(self, ch):
    self.value = self._filtered_values_cache

.. @+node:ekr.20170624151245.1201: *8* MultiSelect.h_select_exit
def h_select_exit(self, ch):
    if not self.cursor_line in self.value:
        self.value.append(self.cursor_line)
    if self.return_exit:
        self.editing = False
        self.how_exited=True
        
.. @+node:ekr.20170624151245.1202: *8* MultiSelect.get_selected_objects
def get_selected_objects(self):
    if self.value == [] or self.value == None:
        return None
    else:
        return [self.values[x] for x in self.value]
        
.. @+node:ekr.20170624151245.1203: *7* class MultiSelectAction
class MultiSelectAction(MultiSelect):
    always_act_on_many = False
    @others
.. @+node:ekr.20170624151245.1204: *8* MultiSelectAction.actionHighlighted
def actionHighlighted(self, act_on_this, key_press):
    "Override this Method"
    pass

.. @+node:ekr.20170624151245.1205: *8* MultiSelectAction.actionSelected
def actionSelected(self, act_on_these, keypress):
    "Override this Method"
    pass

.. @+node:ekr.20170624151245.1206: *8* MultiSelectAction.set_up_handlers
def set_up_handlers(self):
    '''MultiSelectAction.set_up_handlers.'''
    super(MultiSelectAction, self).set_up_handlers()
    self.handlers.update ( {
        curses.ascii.NL:    self.h_act_on_highlighted,
        curses.ascii.CR:    self.h_act_on_highlighted,
        ord(';'):           self.h_act_on_selected,
        # "^L":             self.h_set_filtered_to_selected,
        curses.ascii.SP:    self.h_act_on_highlighted,
    })

.. @+node:ekr.20170624151245.1207: *8* MultiSelectAction.h_act_on_highlighted
def h_act_on_highlighted(self, ch):
    if self.always_act_on_many:
        return self.h_act_on_selected(ch)
    else:
        return self.actionHighlighted(self.values[self.cursor_line], ch)

.. @+node:ekr.20170624151245.1208: *8* MultiSelectAction.h_act_on_selected
def h_act_on_selected(self, ch):
    if self.vale:
        return self.actionSelected(self.get_selected_objects(), ch)

    
.. @+node:ekr.20170624151245.1209: *7* class MultiSelectFixed
class MultiSelectFixed(MultiSelect):
    # This does not allow the user to change Values, but does allow the user to move around.
    # Useful for displaying Data.
    @others
.. @+node:ekr.20170624151245.1210: *8* user_set_value
def user_set_value(self, input):
    pass

.. @+node:ekr.20170624151245.1211: *8* set_up_handlers
def set_up_handlers(self):
    '''MultiSelectFixed.set_up_handlers.'''
    super(MultiSelectFixed, self).set_up_handlers()
    self.handlers.update({
        ord("x"):           self.user_set_value,
        ord("X"):           self.user_set_value,
        curses.ascii.SP:    self.user_set_value,
        "^U":               self.user_set_value,
        curses.ascii.NL:    self.h_exit_down,
        curses.ascii.CR:    self.h_exit_down,
    })
.. @+node:ekr.20170624151245.1212: *7* class TitleMultiSelect
class TitleMultiSelect(multiline.TitleMultiLine):
    _entry_type = MultiSelect
            
        
        
.. @+node:ekr.20170624151245.1213: *7* class TitleMultiSelectFixed
class TitleMultiSelectFixed(multiline.TitleMultiLine):
    _entry_type = MultiSelectFixed
    
    
.. @+node:ekr.20170624151245.1214: *6* @file ../external/npyscreen/wgmultiselecttree.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1215: *7* Declarations
from . import wgmultilinetree as multilinetree
from . import wgcheckbox      as checkbox
import curses
import weakref


.. @+node:ekr.20170624151245.1216: *7* class MultiSelectTree
class MultiSelectTree(multilinetree.SelectOneTree):
    _contained_widgets = checkbox.Checkbox

    @others
.. @+node:ekr.20170624151245.1217: *8* MultiSelectTree.set_up_handlers
def set_up_handlers(self):
    '''MultiSelectTree.set_up_handlers.'''
    super(MultiSelectTree, self).set_up_handlers()
    self.handlers.update({
        ord("x"):    self.h_select_toggle,
        curses.ascii.SP: self.h_select_toggle,
        ord("X"):    self.h_select,
        "^U":        self.h_select_none,
    })
.. @+node:ekr.20170624151245.1218: *8* MultiSelectTree.h_select_none
def h_select_none(self, input):
    self.value = []

.. @+node:ekr.20170624151245.1219: *8* MultiSelectTree.h_select_toggle
def h_select_toggle(self, input):
    try:
        working_with = weakref.proxy(self.values[self.cursor_line])
    except TypeError:
        working_with = self.values[self.cursor_line]
    if working_with in self.value:
        self.value.remove(working_with)
    else:
        self.value.append(working_with)
        
.. @+node:ekr.20170624151245.1220: *8* MultiSelectTree.h_set_filtered_to_selected
def h_set_filtered_to_selected(self, ch):
    self.value = self.get_filtered_values()

.. @+node:ekr.20170624151245.1221: *8* MultiSelectTree.h_select_exit
def h_select_exit(self, ch):
    try:
        working_with = weakref.proxy(self.values[self.cursor_line])
    except TypeError:
        working_with = self.values[self.cursor_line]
    
    if not working_with in self.value:
        self.value.append(working_with)
    if self.return_exit:
        self.editing = False
        self.how_exited=True
.. @+node:ekr.20170624151245.1222: *6* @file ../external/npyscreen/wgNMenuDisplay.py
#!/usr/bin/env python
# encoding: utf-8

@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1223: *7* Declarations
from . import muNewMenu    as NewMenu
from . import fmForm       as Form
from . import wgmultiline  as multiline
from . import wgannotatetextbox
# from . import utilNotify
import weakref
import curses

.. @+node:ekr.20170624151245.1224: *7* class MenuViewerController
class MenuViewerController(object):
    @others
.. @+node:ekr.20170624151245.1225: *8* __init__
def __init__(self, menu=None):
    self.setMenu(menu)
    self.create()
    self._menuStack = []
    self._editing = False

.. @+node:ekr.20170624151245.1226: *8* create
def create(self):
    pass
    
.. @+node:ekr.20170624151245.1227: *8* setMenu
def setMenu(self, mnu):
    self._menuStack = []
    self._setMenuWithoutResettingStack(mnu)

.. @+node:ekr.20170624151245.1228: *8* _setMenuWithoutResettingStack
def _setMenuWithoutResettingStack(self, mnu):
    self._menu = mnu
    self._DisplayArea._menuListWidget.value = None
    
.. @+node:ekr.20170624151245.1229: *8* _goToSubmenu
def _goToSubmenu(self, mnu):
    self._menuStack.append(self._menu)
    self._menu = mnu

.. @+node:ekr.20170624151245.1230: *8* _returnToPrevious
def _returnToPrevious(self):
    self._menu = self._menuStack.pop()


.. @+node:ekr.20170624151245.1231: *8* _executeSelection
def _executeSelection(self, sel):
    self._editing = False
    return sel()
    
.. @+node:ekr.20170624151245.1232: *8* edit
def edit(self):
    try:
        if self._menu is None:
            raise ValueError("No Menu Set")
    except AttributeError:
        raise ValueError("No Menu Set")
    self._editing = True
    while self._editing:
        if self._menu is not None:
            self._DisplayArea.name = self._menu.name
        if hasattr(self._menu, 'do_pre_display_function'):
            self._menu.do_pre_display_function()
        self._DisplayArea.display()
        self._DisplayArea._menuListWidget.value = None
        self._DisplayArea._menuListWidget.cursor_line = 0
        _menulines = []
        _actionsToTake = []
        if len(self._menuStack) > 0:
            _menulines.append(PreviousMenu())
            # _returnToPreviousSet = True
            _actionsToTake.append((self._returnToPrevious, ))
        # else:
            # _returnToPreviousSet = False
        
        for itm in self._menu.getItemObjects():
            if isinstance(itm, NewMenu.MenuItem):
                _menulines.append(itm)
                _actionsToTake.append((self._executeSelection, itm.do))
            elif isinstance(itm, NewMenu.NewMenu):
                _menulines.append(itm)
                _actionsToTake.append((self._goToSubmenu, itm))
            else:
                raise ValueError("menu %s contains objects I don't know how to handle." % self._menu.name)
        
        
        self._DisplayArea._menuListWidget.values = _menulines
        self._DisplayArea.display()
        self._DisplayArea._menuListWidget.edit()
        _vlu = self._DisplayArea._menuListWidget.value
        if _vlu is None:
            self.editing = False
            return None
        try:
            _fctn = _actionsToTake[_vlu][0]
            _args = _actionsToTake[_vlu][1:]
        except IndexError:
            try:
                _fctn = _actionsToTake[_vlu]
                _args = []
            except IndexError:
                # Menu must be empty.
                return False
        _return_value = _fctn(*_args)
    
    return _return_value
        

.. @+node:ekr.20170624151245.1233: *7* class PreviousMenu
class PreviousMenu(NewMenu.NewMenu):
    pass


.. @+node:ekr.20170624151245.1234: *7* class MenuDisplay
class MenuDisplay(MenuViewerController):
    @others
.. @+node:ekr.20170624151245.1235: *8* __init__
def __init__(self, color='CONTROL', lines=15, columns=39, show_atx=5, show_aty=2, *args, **keywords):
    self._DisplayArea = MenuDisplayScreen(lines=lines, 
                                columns=columns, 
                                show_atx=show_atx, 
                                show_aty=show_aty, 
                                color=color)
    super(MenuDisplay, self).__init__(*args, **keywords)

.. @+node:ekr.20170624151245.1236: *7* class MenuDisplayFullScreen
class MenuDisplayFullScreen(MenuViewerController):
    @others
.. @+node:ekr.20170624151245.1237: *8* __init__
def __init__(self, *args, **keywords):
    self._DisplayArea = MenuDisplayScreen()
    super(MenuDisplayFullScreen, self).__init__(*args, **keywords)



.. @+node:ekr.20170624151245.1238: *7* class wgMenuLine
class wgMenuLine(wgannotatetextbox.AnnotateTextboxBaseRight):
    ANNOTATE_WIDTH = 3
    @others
.. @+node:ekr.20170624151245.1239: *8* getAnnotationAndColor
def getAnnotationAndColor(self,):
    try:
        if self.value.shortcut:
            return (self.safe_string(self.value.shortcut), 'LABEL')
        else:
            return ('', 'LABEL')
    except AttributeError:
        return ('', 'LABEL')

.. @+node:ekr.20170624151245.1240: *8* display_value
def display_value(self, vl):
    # if this function raises an exception, it gets masked.
    # this is a bug.
    if not vl:
        return None
    if isinstance(vl, PreviousMenu):
        return '<-- Back'
    elif isinstance(vl, NewMenu.NewMenu):
        return ('%s -->' % self.safe_string(self.value.name))
    elif isinstance(vl, NewMenu.MenuItem):
        return self.safe_string(self.value.getText())
    else:
        return self.safe_string(str(self.value))
        

.. @+node:ekr.20170624151245.1241: *7* class wgMenuListWithSortCuts
class wgMenuListWithSortCuts(multiline.MultiLineActionWithShortcuts):
    _contained_widgets = wgMenuLine
    @others
.. @+node:ekr.20170624151245.1242: *8* __init__
def __init__(self, screen,  allow_filtering=False, *args, **keywords):
    return super(wgMenuListWithSortCuts, self).__init__(screen, allow_filtering=allow_filtering, *args, **keywords)

#def actionHighlighted(self, act_on_this, key_press):
#    if isinstance(act_on_this, MenuItem):
#        return act_on_this.do()
#    else:
#        return act_on_this
.. @+node:ekr.20170624151245.1243: *8* actionHighlighted
def actionHighlighted(self, act_on_this, key_press):
    return self.h_select_exit(key_press)

.. @+node:ekr.20170624151245.1244: *8* display_value
def display_value(self, vl):
    return vl

.. @+node:ekr.20170624151245.1245: *7* class MenuDisplayScreen
class MenuDisplayScreen(Form.Form):
    @others
.. @+node:ekr.20170624151245.1246: *8* __init__
def __init__(self, *args, **keywords):
    super(MenuDisplayScreen, self).__init__(*args, **keywords)
    #self._menuListWidget = self.add(multiline.MultiLine, return_exit=True)
    self._menuListWidget = self.add(wgMenuListWithSortCuts, return_exit=True)
    self._menuListWidget.add_handlers({
        ord('q'):       self._menuListWidget.h_exit_down,
        ord('Q'):       self._menuListWidget.h_exit_down,
        ord('x'):       self._menuListWidget.h_select_exit,
        curses.ascii.SP:    self._menuListWidget.h_select_exit,
    })
    
.. @+node:ekr.20170624151245.1247: *7* class HasMenus
class HasMenus(object):
    MENU_KEY          = "^X"
    MENU_DISPLAY_TYPE = MenuDisplay
    MENU_WIDTH        = None
    @others
.. @+node:ekr.20170624151245.1248: *8* initialize_menus
def initialize_menus(self):
    if self.MENU_WIDTH:
        self._NMDisplay = self.MENU_DISPLAY_TYPE(columns=self.MENU_WIDTH)
    else:
        self._NMDisplay = self.MENU_DISPLAY_TYPE()
    if not hasattr(self, '_NMenuList'):
        self._NMenuList = []
    self._MainMenu  = NewMenu.NewMenu
    self.add_handlers({self.__class__.MENU_KEY: self.root_menu})
    
.. @+node:ekr.20170624151245.1249: *8* new_menu
def new_menu(self, name=None, *args, **keywords):
    if not hasattr(self, '_NMenuList'):
        self._NMenuList = []
    _mnu = NewMenu.NewMenu(name=name, *args, **keywords)
    self._NMenuList.append(_mnu)
    return weakref.proxy(_mnu)

.. @+node:ekr.20170624151245.1250: *8* add_menu
def add_menu(self, *args, **keywords):
    return self.new_menu(*args, **keywords)
    
.. @+node:ekr.20170624151245.1251: *8* root_menu
def root_menu(self, *args):
    if len(self._NMenuList) == 1:
        self._NMDisplay.setMenu(self._NMenuList[0])
        self._NMDisplay.edit()
    else:    
        _root_menu = NewMenu.NewMenu(name="Menus")
        for mnu in self._NMenuList:
            _root_menu.addSubmenu(mnu)            
        self._NMDisplay.setMenu(_root_menu)
        self._NMDisplay.edit()
    self.DISPLAY()

.. @+node:ekr.20170624151245.1252: *8* use_existing_menu
def use_existing_menu(self, _mnu):
    if not hasattr(self, '_NMenuList'):
        self._NMenuList = []
    self._NMenuList.append(_mnu)
    return weakref.proxy(_mnu)

    
.. @+node:ekr.20170624151245.1253: *8* popup_menu
def popup_menu(self, menu):
    self._NMDisplay.setMenu(menu)
    self._NMDisplay.edit()



    
.. @+node:ekr.20170624151245.1254: *6* @file ../external/npyscreen/wgpassword.py
#!/usr/bin/python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1255: *7* Declarations
# import curses
from .wgtextbox import Textfield
from . import wgtitlefield as titlefield


.. @+node:ekr.20170624151245.1256: *7* class PasswordEntry
class PasswordEntry(Textfield):
    @others
.. @+node:ekr.20170624151245.1257: *8* _print
def _print(self):
    strlen = len(self.value)
    if self.maximum_string_length < strlen:
        tmp_x = self.relx
        for i in range(self.maximum_string_length):
            self.parent.curses_pad.addch(self.rely, tmp_x, '-') 
            tmp_x += 1

    else:
        tmp_x = self.relx
        for i in range(strlen):
            self.parent.curses_pad.addstr(self.rely, tmp_x, '-') 
            tmp_x += 1

.. @+node:ekr.20170624151245.1258: *7* class TitlePassword
class TitlePassword(titlefield.TitleText):
    _entry_type = PasswordEntry

.. @+node:ekr.20170624151245.1259: *6* @file ../external/npyscreen/wgselectone.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1260: *7* Declarations
from . import wgmultiline  as multiline
from . import wgcheckbox   as checkbox

.. @+node:ekr.20170624151245.1261: *7* class SelectOne
class SelectOne(multiline.MultiLine):
    _contained_widgets = checkbox.RoundCheckBox
    
    @others
.. @+node:ekr.20170624151245.1262: *8* SelectOne.update
def update(self, clear=True):
    if self.hidden:
        self.clear()
        return False
    # Make sure that self.value is a list
    if not hasattr(self.value, "append"):
        if self.value is not None:
            self.value = [self.value, ]
        else:
            self.value = []
            
    super(SelectOne, self).update(clear=clear)

.. @+node:ekr.20170624151245.1263: *8* SelectOne.h_select
def h_select(self, ch):
    self.value = [self.cursor_line,]

.. @+node:ekr.20170624151245.1264: *8* SelectOne._print_line
def _print_line(self, line, value_indexer):
    try:
        display_this = self.display_value(self.values[value_indexer])
        line.value = display_this
        line.hide = False
        if hasattr(line, 'selected'):
            if (value_indexer in self.value and (self.value is not None)):
                line.selected = True
            else:
                line.selected = False
        # Most classes in the standard library use this
        else:
            if (value_indexer in self.value and (self.value is not None)):
                line.show_bold = True
                line.name = display_this
                line.value = True
            else:
                line.show_bold = False
                line.name = display_this
                line.value = False
                
        if value_indexer in self._filtered_values_cache:
            line.important = True
        else:
            line.important = False
        
        
    except IndexError:
        line.name = None
        line.hide = True

    line.highlight= False
    
.. @+node:ekr.20170624151245.1265: *7* class TitleSelectOne
class TitleSelectOne(multiline.TitleMultiLine):
    _entry_type = SelectOne
    
.. @+node:ekr.20170624151245.1266: *6* @file ../external/npyscreen/wgslider.py
#!/usr/bin/python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1267: *7* Declarations
import curses
from . import wgwidget     as widget
from . import wgtitlefield as titlefield

.. @+node:ekr.20170624151245.1268: *7* class Slider
class Slider(widget.Widget):
    DEFAULT_BLOCK_COLOR = None
    @others
.. @+node:ekr.20170624151245.1269: *8* Slider.__init__
def __init__(self, screen, value=0, 
            out_of=100, step=1, lowest=0,
            label=True, 
            block_color = None,
            **keywords):
    self.out_of = out_of
    self.value = value
    self.step = step
    self.lowest = lowest
    self.block_color = block_color or self.__class__.DEFAULT_BLOCK_COLOR
    super(Slider, self).__init__(screen, **keywords)
    if self.parent.curses_pad.getmaxyx()[0]-1 == self.rely: self.on_last_line = True
    else: self.on_last_line = False
    if self.on_last_line:
        self.maximum_string_length = self.width - 1
    else:   
        self.maximum_string_length = self.width
    self.label = label

.. @+node:ekr.20170624151245.1270: *8* Slider.calculate_area_needed
def calculate_area_needed(self):
    return 1,0

.. @+node:ekr.20170624151245.1271: *8* Slider.translate_value
def translate_value(self):
    """What do different values mean?  If you subclass this object, and override this 
    method, you can change how the labels are displayed.  This method should return a
    unicode string, to be displayed to the user. You probably want to ensure this is a fixed width."""
    
    stri = "%s / %s" %(self.value, self.out_of)
    if isinstance(stri, bytes):
        stri = stri.decode(self.encoding, 'replace')
    l = (len(str(self.out_of)))*2+4
    stri = stri.rjust(l)
    return stri

.. @+node:ekr.20170624151245.1272: *8* Slider.update
def update(self, clear=True):
    if clear: self.clear()
    if self.hidden:
        self.clear()
        return False
    length_of_display = self.width + 1
    blocks_on_screen = length_of_display

    if self.label:
        label_str = self.translate_value()
        if isinstance(label_str, bytes):
            label_str = label_str.decode(self.encoding, 'replace')
        blocks_on_screen -= len(label_str)+3
        if self.do_colors():
            label_attributes = self.parent.theme_manager.findPair(self)
        else:
            label_attributes = curses.A_NORMAL
        self.add_line(
            self.rely, self.relx+blocks_on_screen+2,
            label_str,
            self.make_attributes_list(label_str, label_attributes),
            len(label_str)
            )
        
        # If want to handle neg. numbers, this line would need changing.
    blocks_to_fill = (float(self.value) / float(self.out_of)) * int(blocks_on_screen)

    if self.editing:
        self.parent.curses_pad.attron(curses.A_BOLD)
        #self.parent.curses_pad.bkgdset(curses.ACS_HLINE)
        #self.parent.curses_pad.bkgdset(">")
        #self.parent.curses_pad.bkgdset(curses.A_NORMAL)
        BACKGROUND_CHAR = ">"
        BARCHAR         = curses.ACS_HLINE
    else:
        self.parent.curses_pad.attroff(curses.A_BOLD)
        self.parent.curses_pad.bkgdset(curses.A_NORMAL)
        #self.parent.curses_pad.bkgdset(curses.ACS_HLINE)
        BACKGROUND_CHAR = curses.ACS_HLINE
        BARCHAR         = " "
    

    for n in range(blocks_on_screen):
        xoffset = self.relx
        if self.do_colors():
            self.parent.curses_pad.addch(self.rely,n+xoffset, BACKGROUND_CHAR, curses.A_NORMAL | self.parent.theme_manager.findPair(self))
        else:
            self.parent.curses_pad.addch(self.rely,n+xoffset, BACKGROUND_CHAR, curses.A_NORMAL)

    for n in range(int(blocks_to_fill)):
        if self.do_colors():
            if self.block_color:
                self.parent.curses_pad.addch(self.rely,n+xoffset, BARCHAR, self.parent.theme_manager.findPair(self, self.block_color))
            else:
                self.parent.curses_pad.addch(self.rely,n+xoffset, BARCHAR, curses.A_STANDOUT | self.parent.theme_manager.findPair(self))
        else:
            self.parent.curses_pad.addch(self.rely,n+xoffset, BARCHAR, curses.A_STANDOUT) #curses.ACS_BLOCK)

    self.parent.curses_pad.attroff(curses.A_BOLD)
    self.parent.curses_pad.bkgdset(curses.A_NORMAL)

.. @+node:ekr.20170624151245.1273: *8* Slider.set_value
def set_value(self, val):
    #"We can only represent ints or floats, and must be less than what we are out of..."
    if val is None: val = 0
    if not isinstance(val, int) and not isinstance(val, float):
        raise ValueError

    else:
        self.__value = val

    if self.__value > self.out_of: raise ValueError

.. @+node:ekr.20170624151245.1274: *8* Slider.get_value
def get_value(self):
    return float(self.__value)
value = property(get_value, set_value)

.. @+node:ekr.20170624151245.1275: *8* Slider.set_up_handlers
def set_up_handlers(self):
    '''Slider.set_up_handlers.'''
    super(widget.Widget, self).set_up_handlers()
    self.handlers.update({ 
        curses.KEY_LEFT: self.h_decrease,
        curses.KEY_RIGHT: self.h_increase,
        ord('+'): self.h_increase,
        ord('-'): self.h_decrease,
        ord('h'): self.h_decrease,
        ord('l'): self.h_increase,
        ord('j'): self.h_exit_down,
        ord('k'): self.h_exit_up,
    })

.. @+node:ekr.20170624151245.1276: *8* Slider.h_increase
def h_increase(self, ch):
    if (self.value + self.step <= self.out_of): self.value += self.step

.. @+node:ekr.20170624151245.1277: *8* Slider.h_decrease
def h_decrease(self, ch):
    if (self.value - self.step >= self.lowest): self.value -= self.step


.. @+node:ekr.20170624151245.1278: *7* class TitleSlider
class TitleSlider(titlefield.TitleText):
    _entry_type = Slider

.. @+node:ekr.20170624151245.1279: *7* class SliderNoLabel
class SliderNoLabel(Slider):
    @others
.. @+node:ekr.20170624151245.1280: *8* __init__
def __init__(self, screen, label=False, *args, **kwargs):
    super(SliderNoLabel, self).__init__(screen, label=label, *args, **kwargs)    

.. @+node:ekr.20170624151245.1281: *8* translate_value
def translate_value(self):
    return ''

.. @+node:ekr.20170624151245.1282: *7* class TitleSliderNoLabel
class TitleSliderNoLabel(TitleSlider):
    _entry_type = SliderNoLabel

.. @+node:ekr.20170624151245.1283: *7* class SliderPercent
class SliderPercent(Slider):
    @others
.. @+node:ekr.20170624151245.1284: *8* __init__
def __init__(self, screen, accuracy=2, *args, **kwargs):
    super(SliderPercent, self).__init__(screen, *args, **kwargs)
    self.accuracy = accuracy

.. @+node:ekr.20170624151245.1285: *8* translate_value
def translate_value(self):
    pc = float(self.value) / float(self.out_of) * 100
    return '%.*f%%' % (int(self.accuracy), pc)

.. @+node:ekr.20170624151245.1286: *7* class TitleSliderPercent
class TitleSliderPercent(TitleSlider):
    _entry_type = SliderPercent
.. @+node:ekr.20170624151245.1287: *6* @file ../external/npyscreen/wgtextbox.py
#!/usr/bin/python
import leo.core.leoGlobals as g
assert g
import curses
import curses.ascii
import sys
import locale
#import curses.wrapper
from . import wgwidget as widget
from . import npysGlobalOptions as GlobalOptions

# pylint: disable=no-member
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1288: *7* class TextfieldBase (Widget)
class TextfieldBase(widget.Widget):
    ENSURE_STRING_VALUE = True
    @others
.. @+node:ekr.20170624151245.1289: *8* TextfieldBase.__init__
def __init__(self, screen,
    value='',
    highlight_color='CURSOR',
    highlight_whole_widget=False,
    invert_highlight_color=True,
    **keywords
):
    ### For Leo, called from MultiLine.make_contained_widgets.
    # g.trace('TextfieldBase: value', repr(value), g.callers())
    try:
        self.value = value or ""
    except Exception:
        self.value = ""
    
    super(TextfieldBase, self).__init__(screen, **keywords)

    if GlobalOptions.ASCII_ONLY or locale.getpreferredencoding() == 'US-ASCII':
        self._force_ascii = True
    else:
        self._force_ascii = False
    
    self.cursor_position = False
    self.highlight_color = highlight_color
    self.highlight_whole_widget = highlight_whole_widget
    self.invert_highlight_color = invert_highlight_color
    self.show_bold = False
    self.highlight = False
    self.important = False
    
    self.syntax_highlighting = False
    self._highlightingdata   = None
    self.left_margin = 0
    
    self.begin_at = 0   # Where does the display string begin?
    self.set_text_widths()
    self.update()
    
.. @+node:ekr.20170624151245.1290: *8* set_text_widths
def set_text_widths(self):
    if self.on_last_line:
        self.maximum_string_length = self.width - 2  # Leave room for the cursor
    else:   
        self.maximum_string_length = self.width - 1  # Leave room for the cursor at the end of the string.
.. @+node:ekr.20170624151245.1291: *8* resize
def resize(self):
    self.set_text_widths()
.. @+node:ekr.20170624151245.1292: *8* calculate_area_needed
def calculate_area_needed(self):
    "Need one line of screen, and any width going"
    return 1,0

.. @+node:ekr.20170624151245.1293: *8* TextfieldBase.update (LeoTreeLine USED TO override this)
update_count = 0

def update(self, clear=True, cursor=True):
    """Update the contents of the textbox, without calling the final refresh to the screen"""
    # pylint: disable=arguments-differ
    
    # cursor not working. See later for a fake cursor
        #if self.editing: pmfuncs.show_cursor()
        #else: pmfuncs.hide_cursor()
    # Not needed here -- gets called too much!
        #pmfuncs.hide_cursor()
        
    trace = False
    self.update_count += 1
    if trace:
        g.trace('%3s %s TextfieldBase: cursor: %5r %s' % (
            self.update_count, id(self), self.cursor_position, self.value))
    if clear: self.clear()
    if self.hidden:
        return True
    value_to_use_for_calculations = self.value   
    if self.ENSURE_STRING_VALUE:
        if value_to_use_for_calculations in (None, False, True):
            value_to_use_for_calculations = ''
            self.value = ''
    if self.begin_at < 0: self.begin_at = 0
    if self.left_margin >= self.maximum_string_length:
        raise ValueError
    if self.editing:
        if isinstance(self.value, bytes):
            # use a unicode version of self.value to work out where the cursor is.
            # not always accurate, but better than the bytes
            value_to_use_for_calculations = self.display_value(self.value).decode(self.encoding, 'replace')
        if cursor:
            if self.cursor_position is False:
                self.cursor_position = len(value_to_use_for_calculations)

            elif self.cursor_position > len(value_to_use_for_calculations):
                self.cursor_position = len(value_to_use_for_calculations)

            elif self.cursor_position < 0:
                self.cursor_position = 0

            if self.cursor_position < self.begin_at:
                self.begin_at = self.cursor_position

            while self.cursor_position > self.begin_at + self.maximum_string_length - self.left_margin: # -1:
                self.begin_at += 1
        else:
            if self.do_colors():
                self.parent.curses_pad.bkgdset(' ', self.parent.theme_manager.findPair(self, self.highlight_color) | curses.A_STANDOUT)
            else:
                self.parent.curses_pad.bkgdset(' ',curses.A_STANDOUT)
    # Do this twice so that the _print method can ignore it if needed.
    if self.highlight:
        if self.do_colors():
            if self.invert_highlight_color:
                attributes=self.parent.theme_manager.findPair(self, self.highlight_color) | curses.A_STANDOUT
            else:
                attributes=self.parent.theme_manager.findPair(self, self.highlight_color)
            self.parent.curses_pad.bkgdset(' ', attributes)
        else:
            self.parent.curses_pad.bkgdset(' ',curses.A_STANDOUT)
    if self.show_bold:
        self.parent.curses_pad.attron(curses.A_BOLD)
    if self.important and not self.do_colors():
        self.parent.curses_pad.attron(curses.A_UNDERLINE)
    self._print()
    # reset everything to normal
    self.parent.curses_pad.attroff(curses.A_BOLD)
    self.parent.curses_pad.attroff(curses.A_UNDERLINE)
    self.parent.curses_pad.bkgdset(' ',curses.A_NORMAL)
    self.parent.curses_pad.attrset(0)
    if self.editing and cursor:
        self.print_cursor()
.. @+node:ekr.20170624151245.1294: *8* TextfieldBase.print_cursor
def print_cursor(self):
    # This needs fixing for Unicode multi-width chars.

    # Cursors do not seem to work on pads.
        #self.parent.curses_pad.move(self.rely, self.cursor_position - self.begin_at)
    # let's have a fake cursor
        # _cur_loc_x = self.cursor_position - self.begin_at + self.relx + self.left_margin
    # The following two lines work fine for ascii, but not for unicode
        #char_under_cur = self.parent.curses_pad.inch(self.rely, _cur_loc_x)
        #self.parent.curses_pad.addch(self.rely, self.cursor_position - self.begin_at + self.relx, char_under_cur, curses.A_STANDOUT)
    #The following appears to work for unicode as well.

    try:
        #char_under_cur = self.value[self.cursor_position] #use the real value
        char_under_cur = self._get_string_to_print()[self.cursor_position]
        char_under_cur = self.safe_string(char_under_cur)
    except IndexError:
        char_under_cur = ' '
    except TypeError:
        char_under_cur = ' '
    if self.do_colors():
        self.parent.curses_pad.addstr(
            self.rely,
            self.cursor_position - self.begin_at + self.relx + self.left_margin,
            char_under_cur,
            self.parent.theme_manager.findPair(self, 'CURSOR_INVERSE'))
    else:
        self.parent.curses_pad.addstr(
            self.rely,
            self.cursor_position - self.begin_at + self.relx + self.left_margin,
            char_under_cur,
            curses.A_STANDOUT)
.. @+node:ekr.20170624151245.1295: *8* print_cursor_pre_unicode
def print_cursor_pre_unicode(self):
    # Cursors do not seem to work on pads.
        #self.parent.curses_pad.move(self.rely, self.cursor_position - self.begin_at)
    # let's have a fake cursor
        # _cur_loc_x = self.cursor_position - self.begin_at + self.relx + self.left_margin
    # The following two lines work fine for ascii, but not for unicode
        #char_under_cur = self.parent.curses_pad.inch(self.rely, _cur_loc_x)
        #self.parent.curses_pad.addch(self.rely, self.cursor_position - self.begin_at + self.relx, char_under_cur, curses.A_STANDOUT)
    #The following appears to work for unicode as well.
    try:
        char_under_cur = self.display_value(self.value)[self.cursor_position]
    except Exception:
        char_under_cur = ' '

    self.parent.curses_pad.addstr(self.rely, self.cursor_position - self.begin_at + self.relx + self.left_margin, char_under_cur, curses.A_STANDOUT)
.. @+node:ekr.20170624151245.1296: *8* display_value
def display_value(self, value):
    if value == None:
        return ''
    else:
        try:
            str_value = str(value)
        except UnicodeEncodeError:
            str_value = self.safe_string(value)
            return str_value
        except ReferenceError:                
            return ">*ERROR*ERROR*ERROR*<"
        return self.safe_string(str_value)
.. @+node:ekr.20170624151245.1297: *8* TextFieldBase.find_width_of_char
def find_width_of_char(self, ch):
    return 1
.. @+node:ekr.20170624151245.1298: *8* _print_unicode_char
def _print_unicode_char(self, ch):
    '''return the ch to print.  For python 3 this is just ch.'''
    # pylint: disable=arguments-differ
    if self._force_ascii:
        return ch.encode('ascii', 'replace')
    elif sys.version_info[0] >= 3:
        return ch
    else:
        return ch.encode('utf-8', 'strict')
.. @+node:ekr.20170624151245.1299: *8* TextfieldBase._get_string_to_print
def _get_string_to_print(self):
    string_to_print = self.display_value(self.value)
    if not string_to_print:
        return None
    string_to_print = string_to_print[
        self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin]
    
    if sys.version_info[0] >= 3:
        string_to_print = self.display_value(self.value)[
            self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin]
    else:
        # ensure unicode only here encoding here.
        dv = self.display_value(self.value)
        if isinstance(dv, bytes):
            dv = dv.decode(self.encoding, 'replace')
        string_to_print = dv[
            self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin]
    return string_to_print
.. @+node:ekr.20170624151245.1300: *8* TextfieldBase._print
def _print(self):
    string_to_print = self._get_string_to_print()
    if not string_to_print:
        return None
    string_to_print = string_to_print[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin]
    
    if sys.version_info[0] >= 3:
        string_to_print = self.display_value(self.value)[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin]
    else:
        # ensure unicode only here encoding here.
        dv = self.display_value(self.value)
        if isinstance(dv, bytes):
            dv = dv.decode(self.encoding, 'replace')
        string_to_print = dv[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin]
    
    column = 0
    place_in_string = 0
    if self.syntax_highlighting:
        self.update_highlighting(start=self.begin_at, end=self.maximum_string_length+self.begin_at-self.left_margin)
        while column <= (self.maximum_string_length - self.left_margin):
            if not string_to_print or place_in_string > len(string_to_print)-1:
                break
            width_of_char_to_print = self.find_width_of_char(string_to_print[place_in_string])
            if column - 1 + width_of_char_to_print > self.maximum_string_length:
                break 
            try:
                highlight = self._highlightingdata[self.begin_at+place_in_string]
            except Exception:
                highlight = curses.A_NORMAL                
            self.parent.curses_pad.addstr(
                self.rely,
                self.relx+column+self.left_margin, 
                self._print_unicode_char(string_to_print[place_in_string]), 
                highlight
            )
            column += self.find_width_of_char(string_to_print[place_in_string])
            place_in_string += 1
    else:
        if self.do_colors():
            if self.show_bold and self.color == 'DEFAULT':
                color = self.parent.theme_manager.findPair(self, 'BOLD') | curses.A_BOLD
            elif self.show_bold:
                color = self.parent.theme_manager.findPair(self, self.color) | curses.A_BOLD
            elif self.important:
                color = self.parent.theme_manager.findPair(self, 'IMPORTANT') | curses.A_BOLD
            else:
                color = self.parent.theme_manager.findPair(self)
        else:
            if self.important or self.show_bold:
                color = curses.A_BOLD
            else:
                color = curses.A_NORMAL
        while column <= (self.maximum_string_length - self.left_margin):
            if not string_to_print or place_in_string > len(string_to_print)-1:
                if self.highlight_whole_widget:
                    self.parent.curses_pad.addstr(
                        self.rely,
                        self.relx+column+self.left_margin, 
                        ' ', 
                        color,
                    )
                    column += width_of_char_to_print
                    place_in_string += 1
                    continue
                else:
                    break
            width_of_char_to_print = self.find_width_of_char(string_to_print[place_in_string])
            if column - 1 + width_of_char_to_print > self.maximum_string_length:
                break 
            self.parent.curses_pad.addstr(
                self.rely,
                self.relx+column+self.left_margin, 
                self._print_unicode_char(string_to_print[place_in_string]), 
                color,
            )
            column += width_of_char_to_print
            place_in_string += 1
.. @+node:ekr.20170624151245.1301: *8* _print_pre_unicode
def _print_pre_unicode(self):
    # This method was used to print the string before we became interested in unicode.
    
    string_to_print = self.display_value(self.value)
    if string_to_print == None: return
    
    if self.syntax_highlighting:
        self.update_highlighting(start=self.begin_at, end=self.maximum_string_length+self.begin_at-self.left_margin)
        for i in range(len(string_to_print[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin])):
            try:
                highlight = self._highlightingdata[self.begin_at+i]
            except Exception:
                highlight = curses.A_NORMAL
            self.parent.curses_pad.addstr(
                self.rely,self.relx+i+self.left_margin, 
                string_to_print[self.begin_at+i], 
                highlight 
            )
    elif self.do_colors():
        coltofind = 'DEFAULT'
        if self.show_bold and self.color == 'DEFAULT':
            coltofind = 'BOLD'
        if self.show_bold:
            self.parent.curses_pad.addstr(
                self.rely,
                self.relx+self.left_margin,
                string_to_print[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin], 
                self.parent.theme_manager.findPair(self, coltofind) | curses.A_BOLD)
        elif self.important:
            coltofind = 'IMPORTANT'
            self.parent.curses_pad.addstr(
                self.rely,
                self.relx+self.left_margin,
                string_to_print[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin], 
                self.parent.theme_manager.findPair(self, coltofind) | curses.A_BOLD)
        else:
            self.parent.curses_pad.addstr(
                self.rely,
                self.relx+self.left_margin,
                string_to_print[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin], 
                self.parent.theme_manager.findPair(self))
    else:
        if self.important:
            self.parent.curses_pad.addstr(
                self.rely,
                self.relx+self.left_margin, 
                string_to_print[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin],
                curses.A_BOLD)
        elif self.show_bold:
            self.parent.curses_pad.addstr(
                self.rely,
                self.relx+self.left_margin, 
                string_to_print[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin],
                curses.A_BOLD)
        else:
            self.parent.curses_pad.addstr(
                self.rely,
                self.relx+self.left_margin, 
                string_to_print[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin])
.. @+node:ekr.20170624151245.1302: *8* update_highlighting
def update_highlighting(self, start=None, end=None, clear=False):
    if clear or (self._highlightingdata == None):
        self._highlightingdata = []
    
    # string_to_print = self.display_value(self.value)
    self.display_value(self.value)
.. @+node:ekr.20170624151245.1303: *7* class Textfield (TextfieldBase)
class Textfield(TextfieldBase):
    @others
.. @+node:ekr.20170624151245.1304: *8* Textfield.show_brief_message
def show_brief_message(self, message):
    curses.beep()
    keep_for_a_moment = self.value
    self.value = message
    self.editing=False
    self.display()
    curses.napms(1200)
    self.editing=True
    self.value = keep_for_a_moment
    

.. @+node:ekr.20170624151245.1305: *8* Textfield.edit
def edit(self):
    
    # g.trace('Textfield')
    self.editing = 1
    if self.cursor_position is False:
        self.cursor_position = len(self.value or '')
    self.parent.curses_pad.keypad(1)
    
    self.old_value = self.value
    
    self.how_exited = False

    while self.editing:
        self.display()
        self.get_and_use_key_press()

    self.begin_at = 0
    self.display()
    self.cursor_position = False
    return self.how_exited, self.value

###########################################################################################
# Handlers and methods

.. @+node:ekr.20170624151245.1306: *8* Textfield.t_input_isprint
def t_input_isprint(self, inp):
    if self._last_get_ch_was_unicode and inp not in '\n\t\r':
        return True
    # if curses.ascii.isprint(inp) and \
    # (chr(inp) not in '\n\t\r'): 
        # return True
    # else: 
        # return False
    return curses.ascii.isprint(inp) and chr(inp) not in '\n\t\r'
    
    
.. @+node:ekr.20170624151245.1307: *8* Textfield handlers
.. @+node:ekr.20170624151245.1308: *9* Textfield.h_addch
def h_addch(self, inp):
    if self.editable:
        #self.value = self.value[:self.cursor_position] + curses.keyname(input) \
        #   + self.value[self.cursor_position:]
        #self.cursor_position += len(curses.keyname(input))
        
        # workaround for the metamode bug:
        if self._last_get_ch_was_unicode == True and isinstance(self.value, bytes):
            # probably dealing with python2.
            ch_adding = inp
            self.value = self.value.decode()
        elif self._last_get_ch_was_unicode == True:
            ch_adding = inp
        else:
            try:
                ch_adding = chr(inp)
            except TypeError:
                ch_adding = input
        self.value = self.value[:self.cursor_position] + ch_adding \
            + self.value[self.cursor_position:]
        self.cursor_position += len(ch_adding)

        # or avoid it entirely:
        #self.value = self.value[:self.cursor_position] + curses.ascii.unctrl(input) \
        #   + self.value[self.cursor_position:]
        #self.cursor_position += len(curses.ascii.unctrl(input))

.. @+node:ekr.20170624151245.1309: *9* Textfield.h_cursor_left
def h_cursor_left(self, input):
    self.cursor_position -= 1

.. @+node:ekr.20170624151245.1310: *9* Textfield.h_cursor_right
def h_cursor_right(self, input):
    self.cursor_position += 1

.. @+node:ekr.20170624151245.1311: *9* Textfield.h_delete_left
def h_delete_left(self, input):
    if self.editable and self.cursor_position > 0:
        self.value = self.value[:self.cursor_position-1] + self.value[self.cursor_position:]
    
    self.cursor_position -= 1
    self.begin_at -= 1


.. @+node:ekr.20170624151245.1312: *9* Textfield.h_delete_right
def h_delete_right(self, input):
    if self.editable:
        self.value = self.value[:self.cursor_position] + self.value[self.cursor_position+1:]

.. @+node:ekr.20170624151245.1313: *9* Textfield.h_erase_left
def h_erase_left(self, input):
    if self.editable:
        self.value = self.value[self.cursor_position:]
        self.cursor_position=0

.. @+node:ekr.20170624151245.1314: *9* Textfield.h_erase_right
def h_erase_right(self, input):
    if self.editable:
        self.value = self.value[:self.cursor_position]
        self.cursor_position = len(self.value)
        self.begin_at = 0

.. @+node:ekr.20170624151245.1315: *9* Textfield.handle_mouse_event
def handle_mouse_event(self, mouse_event):
    #mouse_id, x, y, z, bstate = mouse_event
    #rel_mouse_x = x - self.relx - self.parent.show_atx
    mouse_id, rel_x, rel_y, z, bstate = self.interpret_mouse_event(mouse_event)
    self.cursor_position = rel_x + self.begin_at
    self.display()


.. @+node:ekr.20170624151245.1316: *9* Textfield.set_up_handlers
def set_up_handlers(self):
    '''Textfield.set_up_handlers.'''
    super(Textfield, self).set_up_handlers()    
    # For OS X
    # del_key = curses.ascii.alt('~')
    self.handlers.update({
        curses.KEY_LEFT:    self.h_cursor_left,
        curses.KEY_RIGHT:   self.h_cursor_right,
        curses.KEY_DC:      self.h_delete_right,
        curses.ascii.DEL:   self.h_delete_left,
        curses.ascii.BS:    self.h_delete_left,
        curses.KEY_BACKSPACE: self.h_delete_left,
        # mac os x curses reports DEL as escape oddly
        # no solution yet                   
        "^K":           self.h_erase_right,
        "^U":           self.h_erase_left,
    })
    self.complex_handlers.extend((
        (self.t_input_isprint, self.h_addch),
        # (self.t_is_ck, self.h_erase_right),
        # (self.t_is_cu, self.h_erase_left),
    ))

.. @+node:ekr.20170624151245.1317: *7* class FixedText (TextfieldBase)
class FixedText(TextfieldBase):
    @others
.. @+node:ekr.20170624151245.1318: *8* FixedText.set_up_handlers
def set_up_handlers(self):
    '''FixedText.set_up_handlers.'''
    super(FixedText, self).set_up_handlers()
    self.handlers.update({
        curses.KEY_LEFT:    self.h_cursor_left,
        curses.KEY_RIGHT:   self.h_cursor_right,
        ord('k'):    self.h_exit_up,
        ord('j'):    self.h_exit_down,
    })


.. @+node:ekr.20170624151245.1319: *8* FixedText.h_cursor_left
def h_cursor_left(self, input):
    if self.begin_at > 0:
        self.begin_at -= 1

.. @+node:ekr.20170624151245.1320: *8* FixedText.h_cursor_right
def h_cursor_right(self, input):
    if len(self.value) - self.begin_at > self.maximum_string_length:
        self.begin_at += 1

.. @+node:ekr.20170624151245.1321: *8* FixedText.update
def update(self, clear=True,):
    # pylint: disable=arguments-differ
    super(FixedText, self).update(clear=clear, cursor=False)

.. @+node:ekr.20170624151245.1322: *8* FixedText.edit
def edit(self):
    self.editing = 1
    self.highlight = False
    self.cursor_position = 0
    self.parent.curses_pad.keypad(1)
    
    self.old_value = self.value
    
    self.how_exited = False

    while self.editing:
        self.display()
        self.get_and_use_key_press()

    self.begin_at = 0
    self.highlight = False
    self.display()

    return self.how_exited, self.value

.. @+node:ekr.20170624151245.1323: *6* @file ../external/npyscreen/wgtextbox_controlchrs.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1324: *7* Declarations
# import curses
from . import wgtextbox as textbox

.. @+node:ekr.20170624151245.1325: *7* class TextfieldCtrlChars
class TextfieldCtrlChars(textbox.Textfield):
    "Implements a textfield, but which can be prefixed with special curses graphics.  Currently unfinished. Not for use."
    @others
.. @+node:ekr.20170624151245.1326: *8* __init__
def __init__(self, *args, **keywords):
    self.ctr_chars = []
    super(TextfieldCtrlChars, self).__init__(*args, **keywords)

.. @+node:ekr.20170624151245.1327: *8* _get_maximum_string_length
def _get_maximum_string_length(self):
    if self.on_last_line:
        _maximum_string_length = self.width - 1
    else:   
        _maximum_string_length = self.width
    
    _maximum_string_length -= (len(self.ctr_chars) + 1)
    
    return _maximum_string_length

.. @+node:ekr.20170624151245.1328: *8* _set_maxiumum_string_length
def _set_maxiumum_string_length(self, *args):
    pass

.. @+node:ekr.20170624151245.1329: *8* _del_maxiumum_string_length
def _del_maxiumum_string_length(self):
    pass

maximum_string_length = property(_get_maximum_string_length, _set_maxiumum_string_length, _del_maxiumum_string_length)


.. @+node:ekr.20170624151245.1330: *6* @file ../external/npyscreen/wgtextboxunicode.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1331: *7* Declarations
from . import wgtextbox

import unicodedata
# import curses



.. @+node:ekr.20170624151245.1332: *7* class TextfieldUnicode
class TextfieldUnicode(wgtextbox.Textfield):
    width_mapping = {'F':2, 'H': 1, 'W': 2, 'Na': 1, 'N': 1}
    @others
.. @+node:ekr.20170624151245.1333: *8* find_apparent_cursor_position
def find_apparent_cursor_position(self, ):
    string_to_print = self.display_value(self.value)[self.begin_at:self.maximum_string_length+self.begin_at-self.left_margin]
    cursor_place_in_visible_string = self.cursor_position - self.begin_at
    counter = 0
    columns = 0
    while counter < cursor_place_in_visible_string:
         columns += self.find_width_of_char(string_to_print[counter])
         counter += 1
    return columns

.. @+node:ekr.20170624151245.1334: *8* TextfieldUnicode.find_width_of_char
def find_width_of_char(self, char):
    return 1
    w = unicodedata.east_asian_width(char)
    if w == 'A':
        # Abiguous - allow 1, but be aware that this could well be wrong
        return 1
    else:
        return self.__class__.width_mapping[w]

        

    

.. @+node:ekr.20170624151245.1335: *6* @file ../external/npyscreen/wgtexttokens.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1336: *7* Declarations
import curses
# import sys
from . import wgwidget
from . import wgtextbox
from . import wgtitlefield

.. @+node:ekr.20170624151245.1337: *7* class TextTokens
class TextTokens(wgtextbox.Textfield,wgwidget.Widget):
    """This is an experiemental widget"""
    
    # NB IT DOES NOT CURRENTLY SUPPORT THE HIGHLIGHTING COLORS
    # OF THE TEXTFIELD CLASS.
    
    
    @others
.. @+node:ekr.20170624151245.1338: *8* TextTokens.__init__
def __init__(self, *args, **keywords):        
    super(TextTokens, self).__init__(*args, **keywords)
    self.begin_at        = 0 # which token to begin display with
    self.maximum_string_length = self.width - 2
    self.left_margin     = 0
    self.cursor_position = 0
    
    self.important = False
    self.highlight = False
    self.show_bold = False

.. @+node:ekr.20170624151245.1339: *8* TextTokens.find_cursor_offset_on_screen
def find_cursor_offset_on_screen(self, position):
    index  = self.begin_at 
    offset = 0
    while index < position:
        offset += len(self.decode_token(self.value[index]))
        index  += 1
    return offset - self.begin_at # I don't quite understand
                                  # why the - self.begin_at is needed
                                  # but without it the cursor and screen
                                  # get out of sync

.. @+node:ekr.20170624151245.1340: *8* TextTokens.decode_token
def decode_token(self, tk):
    r = ''.join(tk)
    if len(r) > 1:
        r = ' [' + r + '] '
    if isinstance(r, bytes):
        r = r.decode(self.encoding, 'replace')
    return r

# text and highlighting generator.
.. @+node:ekr.20170624151245.1341: *8* TextTokens.get_literal_text_and_highlighting_generator
def get_literal_text_and_highlighting_generator(self, start_at=0,):
    # could perform initialization here.
    index = start_at
    string_length = 0
    # output = ''
    while string_length <= self.maximum_string_length and len(self.value) > index:
        token_output = self.decode_token(self.value[index])
        if isinstance(token_output, bytes):
            token_output = token_output.decode(self.encoding, 'replace')
        highlighting = [curses.A_NORMAL for c in token_output]
        yield(token_output, highlighting)
        index += 1

.. @+node:ekr.20170624151245.1342: *8* TextTokens.get_literal_text_to_display
def get_literal_text_to_display(self, start_at=0,):
    g = self.get_literal_text_and_highlighting_generator(start_at=start_at)
    txt = []
    highlighting = []
    for i in g:
        txt += i[0]
        highlighting += i[1]
    return txt, highlighting
        
            
.. @+node:ekr.20170624151245.1343: *8* TextTokens.update
def update(self, clear=True, cursor=True):
    if clear: self.clear()
    if self.begin_at    < 0: self.begin_at = 0
    if self.left_margin >= self.maximum_string_length:
        raise ValueError
        
    if self.cursor_position < 0:
        self.cursor_position = 0
    if self.cursor_position > len(self.value):
        self.cursor_position = len(self.value)
    
    if self.cursor_position < self.begin_at:
        self.begin_at = self.cursor_position
    
    while self.find_cursor_offset_on_screen(self.cursor_position) > \
             self.find_cursor_offset_on_screen(self.begin_at) + \
             self.maximum_string_length - self.left_margin -1: # -1:
        self.begin_at += 1


    text, highlighting = self.get_literal_text_to_display(start_at=self.begin_at)
    if self.do_colors():
        if self.important:
            color = self.parent.theme_manager.findPair(self, 'IMPORTANT') | curses.A_BOLD            
        else:
            color = self.parent.theme_manager.findPair(self, self.color)
        if self.show_bold:
            color = color | curses.A_BOLD
        if self.highlight:
            if not self.editing:
                color = color | curses.A_STANDOUT
            else:
                color = color | curses.A_UNDERLINE
        highlighting = [color for c in highlighting if c == curses.A_NORMAL]
    else:
        color = curses.A_NORMAL
        if self.important or self.show_bold:
            color = color | curses.A_BOLD
        if self.important:
            color = color | curses.A_UNDERLINE
        if self.highlight:
            if not self.editing:
                color = color | curses.A_STANDOUT
            else:
                color = color | curses.A_UNDERLINE
        highlighting = [color for c in highlighting if c == curses.A_NORMAL]
    
    self._print(text, highlighting)
    
    if self.editing and cursor:
        self.print_cursor()
    

.. @+node:ekr.20170624151245.1344: *8* TextTokens._print
def _print(self, text, highlighting):
    self.add_line(self.rely, 
                  self.relx + self.left_margin,
                  text,
                  highlighting,
                  self.maximum_string_length - self.left_margin
                  )
.. @+node:ekr.20170624151245.1345: *8* TextTokens.print_cursor
def print_cursor(self):
    # _cur_loc_x = self.cursor_position - self.begin_at + self.relx + self.left_margin
    try:
        char_under_cur = self.decode_token(self.value[self.cursor_position]) #use the real value
        char_under_cur = self.safe_string(char_under_cur)
    except IndexError:
        char_under_cur = ' '
    
    if isinstance(char_under_cur, bytes):
        char_under_cur = char_under_cur.decode(self.encoding, 'replace')
    
    offset = self.find_cursor_offset_on_screen(self.cursor_position)
    if self.do_colors():
        ATTR_LIST = self.parent.theme_manager.findPair(self) | curses.A_STANDOUT
    else:
        ATTR_LIST = curses.A_STANDOUT

    self.add_line(self.rely, 
         self.begin_at + self.relx + self.left_margin + offset,
        char_under_cur, 
        self.make_attributes_list(char_under_cur, ATTR_LIST),
        # I don't understand why the "- self.begin_at" is needed in the following line
        # but it is or the cursor can end up overrunning the end of the widget.
        self.maximum_string_length+1 - self.left_margin - offset - self.begin_at,
        )

.. @+node:ekr.20170624151245.1346: *8* TextTokens.h_addch
def h_addch(self, inp):
    if self.editable:
        #self.value = self.value[:self.cursor_position] + curses.keyname(input) \
        #   + self.value[self.cursor_position:]
        #self.cursor_position += len(curses.keyname(input))
        
        # workaround for the metamode bug:
        if self._last_get_ch_was_unicode == True and isinstance(self.value, bytes):
            # probably dealing with python2.
            ch_adding = inp
            self.value = self.value.decode()
        elif self._last_get_ch_was_unicode == True:
            ch_adding = inp
        else:
            try:
                ch_adding = chr(inp)
            except TypeError:
                ch_adding = input
        self.value = self.value[:self.cursor_position] + [ch_adding,] \
            + self.value[self.cursor_position:]
        self.cursor_position += len(ch_adding)

.. @+node:ekr.20170624151245.1347: *8* TextTokens.display_value
def display_value(self, vl):
    return vl


.. @+node:ekr.20170624151245.1348: *8* TextTokens.calculate_area_needed
def calculate_area_needed(self):
    "Need one line of screen, and any width going"
    return 1,0
    


.. @+node:ekr.20170624151245.1349: *7* class TitleTextTokens
class TitleTextTokens(wgtitlefield.TitleText):
    _entry_type = TextTokens

    
.. @+node:ekr.20170624151245.1350: *6* @file ../external/npyscreen/wgtitlefield.py
#!/usr/bin/python
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1351: *7* Declarations
# import curses
import weakref
from . import wgtextbox  as textbox
from . import wgwidget   as widget

.. @+node:ekr.20170624151245.1352: *7* class TitleText
class TitleText(widget.Widget):
    _entry_type = textbox.Textfield

    @others
.. @+node:ekr.20170624151245.1353: *8* TitleText.__init__
def __init__(self, screen, 
    begin_entry_at = 16, 
    field_width = None,
    value = None,
    use_two_lines = None,
    hidden=False,
    labelColor='LABEL',
    allow_override_begin_entry_at=True,
    **keywords):
    
    self.text_field_begin_at = begin_entry_at
    self.field_width_request = field_width
    self.labelColor = labelColor
    self.allow_override_begin_entry_at = allow_override_begin_entry_at
    super(TitleText, self).__init__(screen, **keywords)

    if self.name is None: self.name = 'NoName'

    if use_two_lines is None:
        if len(self.name)+2 >= begin_entry_at: 
            self.use_two_lines = True
        else: 
            self.use_two_lines = False
    else: 
        self.use_two_lines = use_two_lines

    self._passon = keywords.copy()
    for dangerous in ('relx', 'rely','value',):# 'width','max_width'):
        try:
            self._passon.pop(dangerous)
        except Exception:
            pass
            
    if self.field_width_request:
        self._passon['width'] = self.field_width_request
    else:
        if 'max_width' in self._passon.keys():
            if self._passon['max_width'] > 0:
                if self._passon['max_width'] < self.text_field_begin_at:
                    raise ValueError("The maximum width specified is less than the text_field_begin_at value.")
                else:
                    self._passon['max_width'] -= self.text_field_begin_at+1

    if 'width' in self._passon:
        #if 0 < self._passon['width'] < self.text_field_begin_at:
        #    raise ValueError("The maximum width specified %s is less than the text_field_begin_at value %s." % (self._passon['width'], self.text_field_begin_at))
        if self._passon['width'] > 0:
            self._passon['width'] -= self.text_field_begin_at+1
    
    if self.use_two_lines:
        if 'max_height' in self._passon and self._passon['max_height']:
            if self._passon['max_height'] == 1:
                raise ValueError("I don't know how to resolve this: max_height == 1 but widget using 2 lines.")
            self._passon['max_height'] -= 1
        if 'height' in self._passon and self._passon['height']:
            raise ValueError("I don't know how to resolve this: height == 1 but widget using 2 lines.")
            self._passon['height'] -= 1
    

    self.make_contained_widgets()
    self.set_value(value)
    self.hidden = hidden
    
    

.. @+node:ekr.20170624151245.1354: *8* TitleText.resize
def resize(self):
    super(TitleText, self).resize()
    self.label_widget.relx = self.relx
    self.label_widget.rely = self.rely
    self.entry_widget.relx = self.relx + self.text_field_begin_at
    self.entry_widget.rely = self.rely + self._contained_rely_offset
    self.label_widget._resize()
    self.entry_widget._resize()
    self.recalculate_size()
    
.. @+node:ekr.20170624151245.1355: *8* TitleText.make_contained_widgets
def make_contained_widgets(self):
    self.label_widget = textbox.Textfield(self.parent, relx=self.relx, rely=self.rely, width=len(self.name)+1, value=self.name, color=self.labelColor)
    if self.label_widget.on_last_line and self.use_two_lines:
        # we're in trouble here.
        if len(self.name) > 12: 
            ab_label = 12
        else: 
            ab_label = len(self.name)
        self.use_two_lines = False
        self.label_widget = textbox.Textfield(self.parent, relx=self.relx, rely=self.rely, width=ab_label+1, value=self.name)
        if self.allow_override_begin_entry_at:
            self.text_field_begin_at = ab_label + 1
    if self.use_two_lines: 
        self._contained_rely_offset = 1
    else: 
        self._contained_rely_offset = 0
            
    self.entry_widget = self.__class__._entry_type(self.parent, 
                            relx=(self.relx + self.text_field_begin_at), 
                            rely=(self.rely+self._contained_rely_offset), value = self.value,
                            **self._passon)
    self.entry_widget.parent_widget = weakref.proxy(self)
    self.recalculate_size()
    

.. @+node:ekr.20170624151245.1356: *8* TitleText.recalculate_size
def recalculate_size(self):
    self.height = self.entry_widget.height
    if self.use_two_lines: self.height += 1
    else: pass
    self.width = self.entry_widget.width + self.text_field_begin_at

.. @+node:ekr.20170624151245.1357: *8* TitleText.edit
def edit(self):
    self.editing=True
    self.display()
    self.entry_widget.edit()
    #self.value = self.textarea.value
    self.how_exited = self.entry_widget.how_exited
    self.editing=False
    self.display()

.. @+node:ekr.20170624151245.1358: *8* TitleText.update
def update(self, clear = True):
    if clear: self.clear()
    if self.hidden: return False
    if self.editing: 
        self.label_widget.show_bold = True
        self.label_widget.color = 'LABELBOLD'
    else: 
        self.label_widget.show_bold = False
        self.label_widget.color = self.labelColor
    self.label_widget.update()
    self.entry_widget.update()

.. @+node:ekr.20170624151245.1359: *8* TitleText.handle_mouse_event
def handle_mouse_event(self, mouse_event):
    if self.entry_widget.intersted_in_mouse_event(mouse_event):
        self.entry_widget.handle_mouse_event(mouse_event)

.. @+node:ekr.20170624151245.1360: *8* TitleText.get_value
def get_value(self):
    if hasattr(self, 'entry_widget'):
        return self.entry_widget.value
    elif hasattr(self, '__tmp_value'):
        return self.__tmp_value
    else:
        return None
.. @+node:ekr.20170624151245.1361: *8* TitleText.set_value
def set_value(self, value):
    if hasattr(self, 'entry_widget'):
        self.entry_widget.value = value
    else:
        # probably trying to set the value before the textarea is initialised
        self.__tmp_value = value
.. @+node:ekr.20170624151245.1362: *8* TitleText.del_value
def del_value(self):
    del self.entry_widget.value
value = property(get_value, set_value, del_value)

.. @+node:ekr.20170624151245.1363: *8* TitleText.editable
@property
def editable(self):
    try:
        return self.entry_widget.editable
    except AttributeError:
        return self._editable
    
.. @+node:ekr.20170624151245.1364: *8* TitleText.editable
@editable.setter
def editable(self, value):
    self._editable = value
    try:
        self.entry_widget.editable = value
    except AttributeError:
        self._editable = value

.. @+node:ekr.20170624151245.1365: *8* TitleText.add_handlers
def add_handlers(self, handler_dictionary):
    """
    Pass handlers to entry_widget
    """
    self.entry_widget.add_handlers(handler_dictionary)

.. @+node:ekr.20170624151245.1366: *7* class TitleFixedText
class TitleFixedText(TitleText):
    _entry_type = textbox.FixedText
.. @+node:ekr.20170624151245.1367: *6* @file ../external/npyscreen/wgwidget.py
#!/usr/bin/python
# pylint: disable=no-member,access-member-before-definition
<< wgwidget imports >>
<< wgwidgets data >>
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1368: *7* << wgwidget imports >>
import leo.core.leoGlobals as g
# import leo.plugins.cursesGui2 as cursesGui2
assert g

# import codecs
import copy
import curses
import curses.ascii
# import string
import sys
#import curses.wrapper
import weakref
from . import npysGlobalOptions as GlobalOptions
from . import wgwidget_proto
import locale
# import warnings
from .globals import DEBUG
# experimental
from .eveventhandler import EventHandler
.. @+node:ekr.20170624151245.1369: *7* << wgwidgets data >>
EXITED_DOWN  =  1
EXITED_UP    = -1
EXITED_LEFT  = -2
EXITED_RIGHT =  2
EXITED_ESCAPE= 127
EXITED_MOUSE = 130
SETMAX       = 'SETMAX'
RAISEERROR   = 'RAISEERROR'
ALLOW_NEW_INPUT = True

TEST_SETTINGS = {
    'TEST_INPUT': None,
    'TEST_INPUT_LOG': [],
    'CONTINUE_AFTER_TEST_INPUT': False,
    'INPUT_GENERATOR': None,
}
.. @+node:ekr.20170624151245.1370: *7* add_test_input_from_iterable
def add_test_input_from_iterable(test_input):
    global TEST_SETTINGS
    if not TEST_SETTINGS['TEST_INPUT']:
        TEST_SETTINGS['TEST_INPUT'] = []
    TEST_SETTINGS['TEST_INPUT'].extend([ch for ch in test_input])
.. @+node:ekr.20170624151245.1371: *7* add_test_input_ch
def add_test_input_ch(test_input):
    global TEST_SETTINGS
    if not TEST_SETTINGS['TEST_INPUT']:
        TEST_SETTINGS['TEST_INPUT'] = []
    TEST_SETTINGS['TEST_INPUT'].append(test_input)
    

.. @+node:ekr.20170624151245.1372: *7* class ExhaustedTestInput
class ExhaustedTestInput(Exception):
    pass

.. @+node:ekr.20170624151245.1373: *7* class NotEnoughSpaceForWidget
class NotEnoughSpaceForWidget(Exception):
    pass

.. @+node:ekr.20170624151245.1374: *7* class InputHandler (wgwidget.py)
class InputHandler(object):
    "An object that can handle user input"

    @others
.. @+node:ekr.20170624151245.3924: *8* IH.handle_input
def handle_input(self, i):
    """
    Dispatch a handler in this class or parents.
    
    i is the character code. Leo handles codes from 1..351.
    
    Return True if input has been completely handled.
    """
    def tell(f):
        import re
        pattern = r'<bound method ([\w\.]*\.)?(\w+) of <([\w\.]*\.)?(\w+) object at (.+)>>'
        m = re.match(pattern, repr(f))
        if m:
            return '%s.%s' % (m.group(4), m.group(2))
        else:
            return repr(f)

    trace = False
    trace_entry = False
    trace_parent = False
    parent_widget = getattr(self, 'parent_widget', None)
    parent = getattr(self, 'parent', None)
    if trace and trace_entry:
        g.trace('self: %20s, parent: %8s, %3s = %r' % (
            self.__class__.__name__,
            parent.__class__.__name__,
            i, curses.ascii.unctrl(i),
        ))
    # A special case for F4 so we can run unit tests.
    # myLeoSettings.leo binds F4.
    if i == 268:
        g.app.gui.do_key(i)
        return True
    if i in self.handlers:
        f = self.handlers[i]
        if trace: g.trace('handler: %3s %s' % (i, tell(f)))
        f(i)
        return True
    try:
        _unctrl_input = curses.ascii.unctrl(i)
    except TypeError:
        _unctrl_input = None
    if _unctrl_input and (_unctrl_input in self.handlers):
        f = self.handlers[_unctrl_input]
        if trace: g.trace('handler: %3s %s' % (_unctrl_input, tell(f)))
        f(i)
        return True
    for test, handler in getattr(self, 'complex_handlers', []):
        if test(i): # was is not False.
            if trace: g.trace('complex: %3s %s' % (i, tell(handler)))
            return handler(i)
    if parent_widget and hasattr(parent_widget, 'handle_input'):
        if trace and trace_parent:
            g.trace('parent_widget.handle_input', i, parent_widget)
        if parent_widget.handle_input(i):
            return True
    if parent and hasattr(self.parent, 'handle_input'):
        if trace and trace_parent:
            g.trace('parent.handle_input', i, parent_widget)
        if parent.handle_input(i):
            return True
    # Handle Leo bindings *last*.
    # g.app is a LeoApp instance, *not* a CursesApp.
    if g.app and g.app.gui and hasattr(g.app.gui, 'do_key'):
        if trace: g.trace('    leo: %3s %s' % (i, tell(g.app.gui.do_key)))
        return g.app.gui.do_key(i)
    return False
.. @+node:ekr.20170624151245.1376: *8* IH.set_up_handlers
def set_up_handlers(self):
    """
    InputHandler.set_up_handlers.

    This function should be called somewhere during object initialisation
    (which all library-defined widgets do). You might like to override this
    in your own definition, but in most cases the add_handers or
    add_complex_handlers methods are what you want.
    """
    #called in __init__
    self.handlers = {
        curses.ascii.NL:     self.h_exit_down,
        curses.ascii.CR:     self.h_exit_down,
        curses.ascii.TAB:    self.h_exit_down,
        curses.KEY_BTAB:     self.h_exit_up,
        curses.KEY_DOWN:     self.h_exit_down,
        curses.KEY_UP:       self.h_exit_up,
        curses.KEY_LEFT:     self.h_exit_left,
        curses.KEY_RIGHT:    self.h_exit_right,
        "^P":                self.h_exit_up,
        "^N":                self.h_exit_down,
        curses.ascii.ESC:    self.h_exit_escape,
        curses.KEY_MOUSE:    self.h_exit_mouse,
    }
    self.complex_handlers = []

.. @+node:ekr.20170624151245.1377: *8* IH.add_handlers
def add_handlers(self, handler_dictionary):
    """Update the dictionary of simple handlers.  Pass in a dictionary with keyname (eg "^P" or curses.KEY_DOWN) as the key, and the function that key should call as the values """
    self.handlers.update(handler_dictionary)

.. @+node:ekr.20170624151245.1378: *8* IH.add_complex_handlers
def add_complex_handlers(self, handlers_list):
    """add complex handlers: format of the list is pairs of
    (test_function, callback) sets"""

    for pair in handlers_list:
        assert len(pair) == 2
    self.complex_handlers.extend(handlers_list)
    
.. @+node:ekr.20170624151245.1379: *8* IH.remove_complex_handler
def remove_complex_handler(self, test_function):
    _new_list = []
    for pair in self.complex_handlers:
        if not pair[0] == test_function:
            _new_list.append(pair)
    self.complex_handlers = _new_list

.. @+node:ekr.20170624151245.1380: *8* IH.handlers (default for all widgets)
# Handler Methods here - npc convention - prefix with h_

@others
.. @+node:ekr.20170624151245.1381: *9* InputHandler.h_exit_down
def h_exit_down(self, _input):
    """Called when user leaves the widget to the next widget"""
    # g.trace('MultiLine')
    if not self._test_safe_to_exit():
        return False
    self.editing = False
    self.how_exited = EXITED_DOWN
.. @+node:ekr.20170624151245.1382: *9* InputHandler.h_exit_right
def h_exit_right(self, _input):
    if not self._test_safe_to_exit():
        return False
    self.editing = False
    self.how_exited = EXITED_RIGHT
.. @+node:ekr.20170624151245.1383: *9* InputHandler.h_exit_up
def h_exit_up(self, _input):
    if not self._test_safe_to_exit():
        return False
    # Called when the user leaves the widget to the previous widget
    self.editing = False
    self.how_exited = EXITED_UP
.. @+node:ekr.20170624151245.1384: *9* InputHandler.h_exit_left
def h_exit_left(self, _input):
    if not self._test_safe_to_exit():
        return False
    self.editing = False
    self.how_exited = EXITED_LEFT
.. @+node:ekr.20170624151245.1385: *9* InputHandler.h_exit_escape
def h_exit_escape(self, _input):
    if not self._test_safe_to_exit():
        return False
    self.editing = False
    self.how_exited = EXITED_ESCAPE
.. @+node:ekr.20170624151245.1386: *9* InputHandler.h_exit_mouse
def h_exit_mouse(self, _input):
    mouse_event = self.parent.safe_get_mouse_event()
    if mouse_event and self.intersted_in_mouse_event(mouse_event):
        self.handle_mouse_event(mouse_event)
    else:
        if mouse_event and self._test_safe_to_exit():
            curses.ungetmouse(*mouse_event)
            ch = self.parent.curses_pad.getch()
            assert ch == curses.KEY_MOUSE
        self.editing = False
        self.how_exited = EXITED_MOUSE
.. @+node:ekr.20170624151245.1387: *7* class Widget (InputHandler, _LinePrinter, EventHandler)
class Widget(InputHandler, wgwidget_proto._LinePrinter, EventHandler):
    "A base class for widgets. Do not use directly"
    
    _SAFE_STRING_STRIPS_NL = True
    
    @others
.. @+node:ekr.20170624151245.1388: *8* Widget.__init__
def __init__(self, screen, 
        relx=0, rely=0, name=None, value=None, 
        width = False, height = False,
        max_height = False, max_width=False,
        editable=True,
        hidden=False,
        color='DEFAULT',
        use_max_space=False,
        check_value_change=True,
        check_cursor_move=True,
        value_changed_callback=None,
        **keywords):
    """The following named arguments may be supplied:
    name= set the name of the widget.
    width= set the width of the widget.
    height= set the height.
    max_height= let the widget choose a height up to this maximum.
    max_width=  let the widget choose a width up to this maximum.
    editable=True/False the user may change the value of the widget.
    hidden=True/False The widget is hidden.
    check_value_change=True - perform a check on every keypress and run when_value_edit if the value is different.
    check_cursor_move=True - perform a check every keypress and run when_cursor_moved if the cursor has moved.
    value_changed_callback - should be None or a Function.  If it is a function, it will have be called when the value changes
                           and passed the keyword argument widget=self.
    """
    self.check_value_change=check_value_change
    self.check_cursor_move =check_cursor_move
    self.hidden = hidden
    self.interested_in_mouse_even_when_not_editable = False# used only for rare widgets to allow user to click
                                                    # even if can't actually select the widget.  See mutt-style forms
                                                    
    try:
        self.parent = weakref.proxy(screen)
    except TypeError:
        self.parent = screen
    self.use_max_space = use_max_space    
    self.set_relyx(rely, relx)
    #self.relx = relx
    #self.rely = rely
    self.color = color
    self.encoding = 'utf-8'#locale.getpreferredencoding()
    if GlobalOptions.ASCII_ONLY or locale.getpreferredencoding() == 'US-ASCII':
        self._force_ascii = True
    else:
        self._force_ascii = False
    
    
    self.set_up_handlers()
    
    # To allow derived classes to set this and then call this method safely...
    try:
        self.value
    except AttributeError:
        self.value = value

    # same again
    try:
        self.name
    except Exception:
        self.name=name
        
    self.request_width =  width     # widgets should honour if possible
    self.request_height = height    # widgets should honour if possible

    self.max_height = max_height
    self.max_width = max_width

    self.set_size()

    self.editing = False        # Change to true during an edit
    
    self.editable = editable
    if self.parent.curses_pad.getmaxyx()[0]-1 == self.rely: self.on_last_line = True
    else: self.on_last_line = False
    
    if value_changed_callback:
        self.value_changed_callback = value_changed_callback
    else:
        self.value_changed_callback = None
    
    self.initialize_event_handling()
.. @+node:ekr.20170624151245.1389: *8* Widget._edit_loop
def _edit_loop(self):

    if not self.parent.editing:
        _i_set_parent_editing = True
        self.parent.editing   = True
    else:
        _i_set_parent_editing = False
    while self.editing and self.parent.editing:
        # g.pr('Widget._edit_loop:', self.__class__.__name__, g.callers(2))
        self.display()
        self.get_and_use_key_press()
    if _i_set_parent_editing:
        self.parent.editing = False
    
    if self.editing:
        self.editing    = False
        self.how_exited = True
.. @+node:ekr.20170624151245.1390: *8* Widget._get_ch
def _get_ch(self):
    #try:
    #    # Python3.3 and above - returns unicode
    #    ch = self.parent.curses_pad.get_wch()
    #    self._last_get_ch_was_unicode = True
    #except AttributeError:
        
    # For now, disable all attempt to use get_wch()
    # but everything that follows could be in the except clause above.
    
        # Try to read utf-8 if possible.
    _stored_bytes =[]
    self._last_get_ch_was_unicode = True
    global ALLOW_NEW_INPUT
    if ALLOW_NEW_INPUT == True and locale.getpreferredencoding() == 'UTF-8':
        ch = self.parent.curses_pad.getch()
        if ch <= 127:
            rtn_ch = ch
            self._last_get_ch_was_unicode = False
            return rtn_ch
        elif ch <= 193:
            rtn_ch = ch
            self._last_get_ch_was_unicode = False
            return rtn_ch
        # if we are here, we need to read 1, 2 or 3 more bytes.
        # all of the subsequent bytes should be in the range 128 - 191, 
        # but we'll risk not checking...
        elif 194 <= ch <= 223: 
                # 2 bytes
                _stored_bytes.append(ch)
                _stored_bytes.append(self.parent.curses_pad.getch())
        elif 224 <= ch <= 239: 
                # 3 bytes 
                _stored_bytes.append(ch)
                _stored_bytes.append(self.parent.curses_pad.getch()) 
                _stored_bytes.append(self.parent.curses_pad.getch()) 
        elif 240 <= ch <= 244: 
                # 4 bytes 
                _stored_bytes.append(ch) 
                _stored_bytes.append(self.parent.curses_pad.getch()) 
                _stored_bytes.append(self.parent.curses_pad.getch()) 
                _stored_bytes.append(self.parent.curses_pad.getch())
        elif ch >= 245:
            # probably a control character
            self._last_get_ch_was_unicode = False
            return ch
        
        if sys.version_info[0] >= 3:
            ch = bytes(_stored_bytes).decode('utf-8', errors='strict')
        else:
            ch = ''.join([chr(b) for b in _stored_bytes])
            ch = ch.decode('utf-8')
    else:
        ch = self.parent.curses_pad.getch()
        self._last_get_ch_was_unicode = False
    
    # This line should not be in the except clause.
    return ch
.. @+node:ekr.20170624151245.1391: *8* Widget._internal_when_value_edited
def _internal_when_value_edited(self):
    if self.value_changed_callback:
        return self.value_changed_callback(widget=self)
.. @+node:ekr.20170624151245.1392: *8* Widget._move_widget_on_terminal_resize
def _move_widget_on_terminal_resize(self):
    if self._requested_rely < 0 or self._requested_relx < 0:
        self.set_relyx(self._requested_rely, self._requested_relx)
.. @+node:ekr.20170624151245.1393: *8* Widget._post_edit
def _post_edit(self):
    self.highlight = 0
    self.update()
    
.. @+node:ekr.20170624151245.1394: *8* Widget._pre_edit
def _pre_edit(self):
    self.highlight = 1
    # old_value = self.value
    self.how_exited = False
.. @+node:ekr.20170624151245.1395: *8* Widget._recalculate_size
def _recalculate_size(self):
    return self.set_size()
.. @+node:ekr.20170624151245.1396: *8* Widget._resize
def _resize(self):
    "Internal Method. This will be the method called when the terminal resizes."
    self._move_widget_on_terminal_resize()
    self._recalculate_size()
    if self.parent.curses_pad.getmaxyx()[0]-1 == self.rely: self.on_last_line = True
    else: self.on_last_line = False
    self.resize()
    self.when_resized()
.. @+node:ekr.20170624151245.1397: *8* Widget._safe_to_exit
def _safe_to_exit(self):
    return True
.. @+node:ekr.20170624151245.1398: *8* Widget._test_safe_to_exit
def _test_safe_to_exit(self):
    # EKR: both these methods return True by default.
    return self._safe_to_exit() and self.safe_to_exit()
    # if self._safe_to_exit() and self.safe_to_exit():
        # return True
    # else:
        # return False
.. @+node:ekr.20170624151245.1399: *8* Widget.calculate_area_needed
def calculate_area_needed(self): 
    """Classes should provide a function to
    calculate the screen area they need, returning either y,x, or 0,0 if
    they want all the screen they can.  However, do not use this to say how
    big a given widget is ... use .height and .width instead"""
    return 0,0
.. @+node:ekr.20170624151245.1400: *8* Widget.clear
def clear(self, usechar=' '):
    """Blank the screen area used by this widget, ready for redrawing"""
    for y in range(self.height):
        #This method is too slow
        #   for x in range(self.width+1):
        #       try:
        #           # We are in a try loop in case the cursor is moved off the bottom right corner of the screen
        #           self.parent.curses_pad.addch(self.rely+y, self.relx + x, usechar)
        #       except Exception: pass
        #Use this instead
        pad = self.parent.curses_pad
        s = usechar * (self.width)
        if self.do_colors():
            color = self.parent.theme_manager.findPair(self, self.parent.color)
            for y in range(self.height):
                pad.addstr(self.rely+y, self.relx, s, color)
        else:
            for y in range(self.height):
                pad.addstr(self.rely+y, self.relx, s)
        # Old code
        # if self.do_colors():
            # self.parent.curses_pad.addstr(
                # self.rely+y,
                # self.relx, usechar * (self.width),
                # self.parent.theme_manager.findPair(self, self.parent.color))
                    # # used to be width + 1
        # else:
            # self.parent.curses_pad.addstr(
                # self.rely+y,
                # self.relx,
                # usechar * (self.width))
                    # # used to be width + 1
.. @+node:ekr.20170624151245.1401: *8* Widget.destroy
def destroy(self):
    """Destroy the widget: methods should provide a mechanism to destroy any references that might
    case a memory leak.  See select. module for an example"""
    pass
    
.. @+node:ekr.20170624151245.1402: *8* Widget.display
def display(self):
    """Do an update of the object AND refresh the screen"""
    if self.hidden:
        self.clear()
        self.parent.refresh()
    else:
        self.update()
        self.parent.refresh()
.. @+node:ekr.20170624151245.1403: *8* Widget.do_colors
def do_colors(self):
    "Returns True if the widget should try to paint in coloour."
    if curses.has_colors() and not GlobalOptions.DISABLE_ALL_COLORS:
        return True
    else:
        return False
.. @+node:ekr.20170624151245.1404: *8* Widget.edit
def edit(self):
    """Allow the user to edit the widget: ie. start handling keypresses."""
    
    # g.trace('Widget')
    self.editing = 1
    self._pre_edit()
    self._edit_loop()
    return self._post_edit()
.. @+node:ekr.20170624151245.1405: *8* Widget.get_and_use_key_press
def get_and_use_key_press(self):
    global TEST_SETTINGS
    trace = False

    if (TEST_SETTINGS['TEST_INPUT'] is None) and (TEST_SETTINGS['INPUT_GENERATOR'] is None):
        curses.raw()
        curses.cbreak()
        curses.meta(1)
        self.parent.curses_pad.keypad(1)
        if self.parent.keypress_timeout:
            curses.halfdelay(self.parent.keypress_timeout)
            ch = self._get_ch()
            if ch == -1:
                return self.try_while_waiting()
        else:
            self.parent.curses_pad.timeout(-1)
            ch = self._get_ch()
        # handle escape-prefixed rubbish.
        if ch == curses.ascii.ESC:
            #self.parent.curses_pad.timeout(1)
            self.parent.curses_pad.nodelay(1)
            ch2 = self.parent.curses_pad.getch()
            if ch2 != -1: 
                ch = curses.ascii.alt(ch2)
            self.parent.curses_pad.timeout(-1) # back to blocking mode
            #curses.flushinp()
    elif (TEST_SETTINGS['INPUT_GENERATOR']):
        self._last_get_ch_was_unicode = True
        try:
            ch = next(TEST_SETTINGS['INPUT_GENERATOR'])
        except StopIteration:
            if TEST_SETTINGS['CONTINUE_AFTER_TEST_INPUT']:
                TEST_SETTINGS['INPUT_GENERATOR'] = None
                return
            else:
                raise ExhaustedTestInput
    else:
        self._last_get_ch_was_unicode = True
        try:
            ch = TEST_SETTINGS['TEST_INPUT'].pop(0)
            TEST_SETTINGS['TEST_INPUT_LOG'].append(ch)
        except IndexError:
            if TEST_SETTINGS['CONTINUE_AFTER_TEST_INPUT']:
                TEST_SETTINGS['TEST_INPUT'] = None
                return
            else:
                raise ExhaustedTestInput

    # if trace: g.trace('Widget', self.__class__.__name__, ch, chr(ch))
    if trace: g.pr('Widget', self.__class__.__name__, 'get_and_use_key_press', ch, chr(ch))
    self.handle_input(ch)
    if self.check_value_change:
        self.when_check_value_changed()
    if self.check_cursor_move:
        self.when_check_cursor_moved()
    self.try_adjust_widgets()
.. @+node:ekr.20170624151245.1406: *8* Widget.get_editable
def get_editable(self):
    return(self._is_editable)
.. @+node:ekr.20170624151245.1407: *8* Widget.handle_mouse_event
def handle_mouse_event(self, mouse_event):
    # mouse_id, x, y, z, bstate = mouse_event
    pass
.. @+node:ekr.20170624151245.1408: *8* Widget.interpret_mouse_event
def interpret_mouse_event(self, mouse_event):
    mouse_id, x, y, z, bstate = mouse_event
    x += self.parent.show_from_x
    y += self.parent.show_from_y
    rel_y       = y - self.rely - self.parent.show_aty
    rel_x = x - self.relx - self.parent.show_atx
    return (mouse_id, rel_x, rel_y, z, bstate)
    
#def when_parent_changes_value(self):
    # Can be called by forms when they chage their value.
    #pass
.. @+node:ekr.20170624151245.1409: *8* Widget.intersted_in_mouse_event
def intersted_in_mouse_event(self, mouse_event):
    if not self.editable and not self.interested_in_mouse_even_when_not_editable:
        return False
    mouse_id, x, y, z, bstate = mouse_event
    x += self.parent.show_from_x
    y += self.parent.show_from_y
    if self.relx <= x <= self.relx + self.width-1 + self.parent.show_atx:
        if self.rely  <= y <= self.rely + self.height-1 + self.parent.show_aty:
            return True
    return False
.. @+node:ekr.20170624151245.1410: *8* Widget.resize
def resize(self):
    "Widgets should override this to control what should happen when they are resized."
    pass
.. @+node:ekr.20170624151245.1411: *8* Widget.safe_filter
def safe_filter(self, this_string):
    try:
        this_string = this_string.decode(self.encoding, 'replace')
        return this_string.encode('ascii', 'replace').decode()
    except Exception:
        # Things have gone badly wrong if we get here, but let's try to salvage it.
        try:
            if self._safe_filter_value_cache[0] == this_string:
                return self._safe_filter_value_cache[1]
        except AttributeError:
            pass
        s = []
        for cha in this_string.replace('\n', ' '):
            #if curses.ascii.isprint(cha):
            #    s.append(cha)
            #else:
            #    s.append('?')
            try:
                s.append(str(cha))
            except Exception:
                s.append('?')
        s = ''.join(s)
    
        self._safe_filter_value_cache = (this_string, s)
    
        return s
    #s = ''
    #for cha in this_string.replace('\n', ''):
    #    try:
    #        s += cha.encode('ascii')
    #    except Exception:
    #        s += '?'
    #return s
.. @+node:ekr.20170624151245.1412: *8* widget.safe_string
def safe_string(self, this_string):
    """Check that what you are trying to display contains only
    printable chars.  (Try to catch dodgy input).  Give it a string,
    and it will return a string safe to print - without touching
    the original.  In Python 3 this function is not needed
    
    N.B. This will return a unicode string on python 3 and a utf-8 string
    on python2
    """
    try:
        if not this_string: 
            return ""
        #this_string = str(this_string)
        # In python 3
        #if sys.version_info[0] >= 3:
        #    return this_string.replace('\n', ' ')
        if self.__class__._SAFE_STRING_STRIPS_NL == True:
            rtn_value = this_string.replace('\n', ' ')
        else:
            rtn_value = this_string
    
        # Does the terminal want ascii?
        if self._force_ascii:
            if isinstance(rtn_value, bytes):
                # no it isn't.
                try:
                    rtn_value = rtn_value.decode(self.encoding, 'replace')
                except TypeError:
                    # Python2.6
                    rtn_value = rtn_value.decode(self.encoding, 'replace')
            else:
                if sys.version_info[0] >= 3:
                    # even on python3, in this case, we want a string that
                    # contains only ascii chars - but in unicode, so:
                    rtn_value = rtn_value.encode('ascii', 'replace').decode()
                    return rtn_value     
                else:
                    return rtn_value.encode('ascii', 'replace')
            return rtn_value
        # If not....
        if not GlobalOptions.ASCII_ONLY:
            # is the string already unicode?
            if isinstance(rtn_value, bytes):
                # no it isn't.
                try:
                    rtn_value = rtn_value.decode(self.encoding, 'replace')
                except Exception:
                    # Python2.6
                    rtn_value = rtn_value.decode(self.encoding, 'replace')
            if sys.version_info[0] >= 3:
                return rtn_value     
            else:
                return rtn_value.encode('utf-8', 'replace')
        else:
            rtn = self.safe_filter(this_string)
            return rtn
    except Exception:
        if DEBUG:
            raise
        else:
            return "*ERROR DISPLAYING STRING*"
.. @+node:ekr.20170624151245.1413: *8* Widget.safe_to_exit
def safe_to_exit(self):
    return True
.. @+node:ekr.20170624151245.1414: *8* Widget.set_editable
def set_editable(self, value):
    if value: self._is_editable = True
    else: self._is_editable = False
.. @+node:ekr.20170624151245.1415: *8* Widget.set_relyx
def set_relyx(self, y, x):
    """
    Set the position of the widget on the Form.  If y or x is a negative value,
    npyscreen will try to position it relative to the bottom or right edge of the 
    Form.  Note that this ignores any margins that the Form may have defined.
    This is currently an experimental feature.  A future version of the API may 
    take account of the margins set by the parent Form.
    """
    self._requested_rely = y
    self._requested_relx = x
    if y >= 0:
        self.rely = y
    else:
        self._requested_rely = y
        self.rely = self.parent.curses_pad.getmaxyx()[0] + y
        # I don't think there is any real value in using these margins
        #if self.parent.BLANK_LINES_BASE and not self.use_max_space:
        #    self.rely -= self.parent.BLANK_LINES_BASE
        if self.rely < 0:
            self.rely = 0
    if x >= 0:
        self.relx = x            
    else:
        self.relx = self.parent.curses_pad.getmaxyx()[1] + x
        # I don't think there is any real value in using these margins
        #if self.parent.BLANK_COLUMNS_RIGHT and not self.use_max_space:
        #    self.relx -= self.parent.BLANK_COLUMNS_RIGHT
        if self.relx < 0:
            self.relx = 0
.. @+node:ekr.20170624151245.1416: *8* Widget.set_size
def set_size(self):
    """Set the size of the object, reconciling the user's request with the space available"""
    my, mx = self.space_available()
    #my = my+1 # Probably want to remove this.
    ny, nx = self.calculate_area_needed()
    
    max_height = self.max_height
    max_width  = self.max_width
    # What to do if max_height or max_width is negative
    if max_height not in (None, False) and max_height < 0:
        max_height = my + max_height
    if max_width not in (None, False) and max_width < 0:
        max_width = mx + max_width
        
    if max_height not in (None, False) and max_height <= 0:
        raise NotEnoughSpaceForWidget("Not enough space for requested size")  
    if max_width not in (None, False) and max_width <= 0:
        raise NotEnoughSpaceForWidget("Not enough space for requested size")
    
    if ny > 0:
        if my >= ny: 
            self.height = ny
        else: 
            self.height = RAISEERROR
    elif max_height:
        if max_height <= my: 
            self.height = max_height
        else: 
            self.height = self.request_height
    else: 
        self.height = (self.request_height or my)
    
    #if mx <= 0 or my <= 0:
    #    raise Exception("Not enough space for widget")


    if nx > 0:                 # if a minimum space is specified....
        if mx >= nx:           # if max width is greater than needed space 
            self.width = nx    # width is needed space
        else: 
            self.width = RAISEERROR    # else raise an error
    elif self.max_width:       # otherwise if a max width is speciied
        if max_width <= mx: 
            self.width = max_width
        else: 
            self.width = RAISEERROR
    else: 
        self.width = self.request_width or mx
    if self.height == RAISEERROR or self.width == RAISEERROR:
        # Not enough space for widget
        raise NotEnoughSpaceForWidget("Not enough space: max y and x = %s , %s. Height and Width = %s , %s " % (my, mx, self.height, self.width) ) # unsafe. Need to add error here.
.. @+node:ekr.20170624151245.1417: *8* Widget.space_available
def space_available(self):
    """The space available left on the screen, returned as rows, columns"""
    if self.use_max_space:
        y, x = self.parent.useable_space(self.rely, self.relx)
    else:
        y, x = self.parent.widget_useable_space(self.rely, self.relx)
    return y,x
.. @+node:ekr.20170624151245.1418: *8* Widget.try_adjust_widgets
def try_adjust_widgets(self):
    if hasattr(self.parent, "adjust_widgets"):
        self.parent.adjust_widgets()
    if hasattr(self.parent, "parentApp"):
        if hasattr(self.parent.parentApp, "_internal_adjust_widgets"):
            self.parent.parentApp._internal_adjust_widgets()
        if hasattr(self.parent.parentApp, "adjust_widgets"):
            self.parent.parentApp.adjust_widgets()
.. @+node:ekr.20170624151245.1419: *8* Widget.try_while_waiting
def try_while_waiting(self):
    if hasattr(self.parent, "while_waiting"):
        self.parent.while_waiting()
    if hasattr(self.parent, "parentApp"):
        if hasattr(self.parent.parentApp, "_internal_while_waiting"):
            self.parent.parentApp._internal_while_waiting()
        if hasattr(self.parent.parentApp, "while_waiting"):
            self.parent.parentApp.while_waiting()
.. @+node:ekr.20170624151245.1420: *8* Widget.update
def update(self, clear=True):
    """How should object display itself on the screen. Define here, but do not actually refresh the curses
    display, since this should be done as little as possible.  This base widget puts nothing on screen."""
    g.trace('Widget', g.callers())
    if self.hidden:
        self.clear()
        return True
.. @+node:ekr.20170624151245.1421: *8* Widget.when_*
.. @+node:ekr.20170624151245.1422: *9* Widget.when_check_cursor_moved
def when_check_cursor_moved(self):
    if hasattr(self, 'cursor_line'):
        cursor = self.cursor_line
    elif hasattr(self, 'cursor_position'):
        cursor = self.cursor_position
    elif hasattr(self, 'edit_cell'):
        cursor = copy.copy(self.edit_cell)
    else:
        return None
    try:
        if self._old_cursor == cursor:
            return False
    except AttributeError:
        pass
    # Value must have changed:
    self._old_cursor = cursor
    self.when_cursor_moved()
    if hasattr(self, 'parent_widget'):
        self.parent_widget.when_cursor_moved()
.. @+node:ekr.20170624151245.1423: *9* Widget.when_check_value_changed
def when_check_value_changed(self):
    "Check whether the widget's value has changed and call when_valued_edited if so."
    try:
        if self.value == self._old_value:
            return False
    except AttributeError:
        self._old_value = copy.deepcopy(self.value)
        self.when_value_edited()
    # Value must have changed:
    self._old_value = copy.deepcopy(self.value)
    self._internal_when_value_edited()
    self.when_value_edited()
    if hasattr(self, 'parent_widget'):
        self.parent_widget.when_value_edited()
        self.parent_widget._internal_when_value_edited()
    return True
.. @+node:ekr.20170624151245.1424: *9* Widget.when_cursor_moved
def when_cursor_moved(self):
    "Called when the cursor moves"
    pass
.. @+node:ekr.20170624151245.1425: *9* Widget.when_resized
def when_resized(self):
    # this method is called when the widget has been resized.
    pass
.. @+node:ekr.20170624151245.1426: *9* Widget.when_value_edited
def when_value_edited(self):
    """Called when the user edits the value of the widget.  Will usually also be called the first time
    that the user edits the widget."""
    pass
.. @+node:ekr.20170624151245.1427: *7* class DummyWidget
class DummyWidget(Widget):
    "This widget is invisible and does nothing.  Which is sometimes important."
    @others
.. @+node:ekr.20170624151245.1428: *8* DummyWidget.__init__
def __init__(self, screen, *args, **keywords):
    super(DummyWidget, self).__init__(screen, *args, **keywords)
    self.height = 0
    self.widget = 0
    self.parent = screen
.. @+node:ekr.20170624151245.1429: *8* DummyWidget.display
def display(self):
    pass
.. @+node:ekr.20170624151245.1430: *8* DummyWidget.update
def update(self, clear=False):
    pass
.. @+node:ekr.20170624151245.1431: *8* DummyWidget.set_editable
def set_editable(self, value):
    if value: self._is_editable = True
    else: self._is_editable = False
.. @+node:ekr.20170624151245.1432: *8* DummyWidget.get_editable
def get_editable(self):
    return(self._is_editable)
.. @+node:ekr.20170624151245.1433: *8* DummyWidget.clear
def clear(self, usechar=' '):
    pass
.. @+node:ekr.20170624151245.1434: *8* DummyWidget.calculate_area_needed
def calculate_area_needed(self):
    return 0,0


.. @+node:ekr.20170624151245.1435: *6* @file ../external/npyscreen/wgwidget_proto.py
@others
@language python
@tabwidth -4
.. @+node:ekr.20170624151245.1436: *7* Declarations
import sys

.. @+node:ekr.20170624151245.1437: *7* class _LinePrinter
class _LinePrinter(object):
    """A base class for printing lines to the screen.
       Do not use directly. For internal use only.
       Experimental.
    """
    @others
.. @+node:ekr.20170624151245.1438: *8* _LinePrinter.find_width_of_char
def find_width_of_char(self, ch):
    # will eventually need changing.
    return 1

.. @+node:ekr.20170624151245.1439: *8* _print_unicode_char
def _print_unicode_char(self, ch, force_ascii=None):
    if hasattr(self, '_force_ascii') and force_ascii is None:
        force_ascii = self._force_ascii
    # return the ch to print.  For python 3 this is just ch
    if force_ascii:
        return ch.encode('ascii', 'replace')
    elif sys.version_info[0] >= 3:
        return ch
    else:
        return ch.encode('utf-8', 'replace')

.. @+node:ekr.20170624151245.1440: *8* add_line
def add_line(self, realy, realx, 
            unicode_string, 
            attributes_list, max_columns, 
            force_ascii=False):
    if isinstance(unicode_string, bytes):
        raise ValueError("This class prints unicode strings only.")
    
    if len(unicode_string) != len(attributes_list):
        raise ValueError("Must supply an attribute for every character.")

    column = 0
    place_in_string = 0
    
    if hasattr(self, 'curses_pad'):
        # we are a form
        print_on = self.curses_pad
    else:
        # we are a widget
        print_on = self.parent.curses_pad    
    
    
    while column <= (max_columns-1):
        try:
            width_of_char_to_print = self.find_width_of_char(unicode_string[place_in_string])
        except IndexError:
            break
        if column - 1 + width_of_char_to_print > max_columns:
            break
        try:
            print_on.addstr(realy,realx+column, 
                self._print_unicode_char(unicode_string[place_in_string]), 
                attributes_list[place_in_string]
                )
        except IndexError:
            break
        column += width_of_char_to_print
        place_in_string += 1

.. @+node:ekr.20170624151245.1441: *8* make_attributes_list
def make_attributes_list(self, unicode_string, attribute):
    """A convenience function.  Retuns a list the length of the unicode_string
    provided, with each entry of the list containing a copy of attribute."""
    if isinstance(unicode_string, bytes):
        raise ValueError("This class is intended for unicode strings only.")
    
    atb_array = []
    ln = len(unicode_string)
    for x in range(ln):
        atb_array.append(attribute)
    return atb_array
.. @+node:ekr.20170624151245.1442: *5*  ---- gui classes
.. @+node:ekr.20170624151245.1443: *6* class HeadWrapper (leoFrame.StringTextWrapper)
class HeadWrapper(leoFrame.StringTextWrapper):
    '''
    A Wrapper class for headline widgets, returned by c.edit_widget(p)
    during unit tests.
    '''
    
    def __init__(self, c, name, p):
        '''Ctor for HeadWrapper class'''
        # g.trace('HeadWrapper', p.h)
        leoFrame.StringTextWrapper.__init__(self, c, name)
        self.trace = False # For tracing in base class.
        self.p = p.copy()
        self.s = p.v._headString

    @others
.. @+node:ekr.20170624151245.1444: *7* HeadWrapper.setAllText
def setAllText(self, s):
    '''HeadWrapper.setAllText'''
    # Don't allow newlines.
    self.s = s.replace('\n','').replace('\r','')
    i = len(self.s)
    self.ins = i
    self.sel = i, i
    self.p.v._headString = self.s
.. @+node:ekr.20170624151245.1445: *6* class KeyHandlerClass
class KeyHandlerClass(object):
    '''
    A class to support emacs-style commands.
    c.k is an instance of this class.
    '''
    @others
.. @+node:ekr.20170624151245.1777: *7*  k.Birth
.. @+node:ekr.20170624151245.1798: *8* k.__init__& helpers
def __init__(self, c):
    '''Create a key handler for c.'''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug('(k)')
    self.c = c
    self.dispatchEvent = None
    self.fnc = None
        # A singleton defined in k.finishCreate.
    self.getArgInstance = None
        # A singleton defined in k.finishCreate.
    self.inited = False
        # Set at end of finishCreate.
    self.swap_mac_keys = False
        # How to init this??
    self.w = None
        # Note: will be None for NullGui.
    # Generalize...
    self.x_hasNumeric = ['sort-lines', 'sort-fields']
    self.altX_prompt = 'full-command: '
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.defineSettingsIvars()
    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction()
.. @+node:ekr.20170624151245.1806: *9* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):
    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.functionTail = None # For commands that take minibuffer arguments.
    # These are true globals
    self.getArgEscapes = []
    self.getArgEscapeFlag = False # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None, n=None, handler=None)
.. @+node:ekr.20170624151245.1807: *9* k.defineInternalIvars
def defineInternalIvars(self):
    '''Define internal ivars of the KeyHandlerClass class.'''
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None # New support for the demo.py plugin.
    self.demoPrevKey = None # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
.. @+node:ekr.20170624151245.1808: *9* k.defineMultiLineCommands
def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
.. @+node:ekr.20170624151245.1809: *9* k.defineSettingIvars
def defineSettingsIvars(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable_autocompleter_initially')
    self.enable_calltips = getBool('enable_calltips_initially')
    self.ignore_caps_lock = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_foreground_color = getColor('minibuffer_foreground_color') or 'black'
    self.minibuffer_warning_color = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys = getBool('swap_mac_keys')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable_alt_ctrl_bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'
    self.command_mode_bg_color = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg
    # g.trace(self.c.shortFileName())
.. @+node:ekr.20170624151245.1810: *9* k.defineSingleLineCommands
def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere', # 2011/06/07
        'set-find-node-only', # 2011/06/07
        'set-find-suboutline-only', # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
.. @+node:ekr.20170624151245.1811: *9* k.defineSpecialKeys
def defineSpecialKeys(self):
    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''
    k = self
    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&": "ampersand",
        "^": "asciicircum",
        "~": "asciitilde",
        "*": "asterisk",
        "@": "at",
        "\\": "backslash",
        "|": "bar",
        "{": "braceleft",
        "}": "braceright",
        "[": "bracketleft",
        "]": "bracketright",
        ":": "colon", # removed from code.
        ",": "comma",
        "$": "dollar",
        "=": "equal",
        "!": "exclam", # removed from code.
        ">": "greater",
        "<": "less",
        "-": "minus",
        "#": "numbersign",
        '"': "quotedbl",
        "'": "quoteright",
        "(": "parenleft",
        ")": "parenright", # removed from code.
        "%": "percent",
        ".": "period", # removed from code.
        "+": "plus",
        "?": "question",
        "`": "quoteleft",
        ";": "semicolon",
        "/": "slash",
        " ": "space", # removed from code.
        "_": "underscore",
    }
    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s
    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict[k.guiBindNamesDict.get(key)] = key
.. @+node:ekr.20170624151245.1812: *9* k.defineTkNames
def defineTkNames(self):
    k = self
    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left', 'Right', 'Up', 'Down',
        # Page up/down keys.
        'Next', 'Prior',
        # Home end keys.
        'Home', 'End'
        # Modifier keys.
        'Caps_Lock', 'Num_Lock',
        # F-keys.
        'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
        # All others.
        'Begin', 'Break', 'Clear', 'Delete', 'Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace', 'Linefeed', 'Return', 'Tab',
    )
    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp': 'BackSpace', # Dubious: should be '\b'
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ltarrow': 'Left',
        'pageup': 'Prior',
        'pagedn': 'Next',
        'rtarrow': 'Right',
        'uparrow': 'Up',
    }
    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict[s.lower()] = s
@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20170624151245.1806: *9* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):
    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.functionTail = None # For commands that take minibuffer arguments.
    # These are true globals
    self.getArgEscapes = []
    self.getArgEscapeFlag = False # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None, n=None, handler=None)
.. @+node:ekr.20170624151245.1807: *9* k.defineInternalIvars
def defineInternalIvars(self):
    '''Define internal ivars of the KeyHandlerClass class.'''
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None # New support for the demo.py plugin.
    self.demoPrevKey = None # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
.. @+node:ekr.20170624151245.1808: *9* k.defineMultiLineCommands
def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
.. @+node:ekr.20170624151245.1809: *9* k.defineSettingIvars
def defineSettingsIvars(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable_autocompleter_initially')
    self.enable_calltips = getBool('enable_calltips_initially')
    self.ignore_caps_lock = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_foreground_color = getColor('minibuffer_foreground_color') or 'black'
    self.minibuffer_warning_color = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys = getBool('swap_mac_keys')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable_alt_ctrl_bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'
    self.command_mode_bg_color = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg
    # g.trace(self.c.shortFileName())
.. @+node:ekr.20170624151245.1810: *9* k.defineSingleLineCommands
def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere', # 2011/06/07
        'set-find-node-only', # 2011/06/07
        'set-find-suboutline-only', # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
.. @+node:ekr.20170624151245.1811: *9* k.defineSpecialKeys
def defineSpecialKeys(self):
    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''
    k = self
    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&": "ampersand",
        "^": "asciicircum",
        "~": "asciitilde",
        "*": "asterisk",
        "@": "at",
        "\\": "backslash",
        "|": "bar",
        "{": "braceleft",
        "}": "braceright",
        "[": "bracketleft",
        "]": "bracketright",
        ":": "colon", # removed from code.
        ",": "comma",
        "$": "dollar",
        "=": "equal",
        "!": "exclam", # removed from code.
        ">": "greater",
        "<": "less",
        "-": "minus",
        "#": "numbersign",
        '"': "quotedbl",
        "'": "quoteright",
        "(": "parenleft",
        ")": "parenright", # removed from code.
        "%": "percent",
        ".": "period", # removed from code.
        "+": "plus",
        "?": "question",
        "`": "quoteleft",
        ";": "semicolon",
        "/": "slash",
        " ": "space", # removed from code.
        "_": "underscore",
    }
    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s
    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict[k.guiBindNamesDict.get(key)] = key
.. @+node:ekr.20170624151245.1812: *9* k.defineTkNames
def defineTkNames(self):
    k = self
    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left', 'Right', 'Up', 'Down',
        # Page up/down keys.
        'Next', 'Prior',
        # Home end keys.
        'Home', 'End'
        # Modifier keys.
        'Caps_Lock', 'Num_Lock',
        # F-keys.
        'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
        # All others.
        'Begin', 'Break', 'Clear', 'Delete', 'Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace', 'Linefeed', 'Return', 'Tab',
    )
    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp': 'BackSpace', # Dubious: should be '\b'
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ltarrow': 'Left',
        'pageup': 'Prior',
        'pagedn': 'Next',
        'rtarrow': 'Right',
        'uparrow': 'Up',
    }
    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict[s.lower()] = s
@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20170624151245.1813: *8* k.cmd (decorator)
def cmd(name):
    '''Command decorator for the leoKeys class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'k',])
.. @+node:ekr.20170624151245.1814: *8* k.finishCreate & helpers
def finishCreate(self):
    '''
    Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.
    '''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug('(k)', self.c)
    c, k = self.c, self
    k.w = c.frame.miniBufferWidget
        # Will be None for NullGui.
    k.fnc = FileNameChooser(c)
        # A singleton. Defined here so that c.k will exist.
    k.getArgInstance = GetArg(c)
        # a singleton. Defined here so that c.k will exist.
    k.makeAllBindings()
    k.initCommandHistory()
    k.inited = True
    k.setDefaultInputState()
    k.resetLabel()
.. @+node:ekr.20170624151245.1815: *8* k.oops
def oops(self):
    g.trace('Should be defined in subclass:', g.callers(4))
.. @+node:ekr.20170624151245.1816: *8* k.setDefaultEditingKeyAction (New)
def setDefaultEditingAction(self):
    k = self; c = k.c
    action = c.config.getString('default_editing_state') or 'insert'
    action.lower()
    if action not in ('command', 'insert', 'overwrite'):
        g.trace('ignoring default_editing_state: %s' % (action))
        action = 'insert'
    self.defaultEditingAction = action
.. @+node:ekr.20170624151245.1817: *8* k.setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction(self, allowCommandState=True):
    k = self; c = k.c
    # g.trace(g.callers())
    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command', 'insert', 'overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % (defaultAction))
        self.unboundKeyAction = 'insert'
    # g.trace(self.unboundKeyAction)
    self.defaultUnboundKeyAction = self.unboundKeyAction
    k.setInputState(self.defaultUnboundKeyAction)
.. @+node:ekr.20170624151245.1798: *8* k.__init__& helpers
def __init__(self, c):
    '''Create a key handler for c.'''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug('(k)')
    self.c = c
    self.dispatchEvent = None
    self.fnc = None
        # A singleton defined in k.finishCreate.
    self.getArgInstance = None
        # A singleton defined in k.finishCreate.
    self.inited = False
        # Set at end of finishCreate.
    self.swap_mac_keys = False
        # How to init this??
    self.w = None
        # Note: will be None for NullGui.
    # Generalize...
    self.x_hasNumeric = ['sort-lines', 'sort-fields']
    self.altX_prompt = 'full-command: '
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.defineSettingsIvars()
    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction()
.. @+node:ekr.20170624151245.1806: *9* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):
    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.functionTail = None # For commands that take minibuffer arguments.
    # These are true globals
    self.getArgEscapes = []
    self.getArgEscapeFlag = False # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None, n=None, handler=None)
.. @+node:ekr.20170624151245.1807: *9* k.defineInternalIvars
def defineInternalIvars(self):
    '''Define internal ivars of the KeyHandlerClass class.'''
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None # New support for the demo.py plugin.
    self.demoPrevKey = None # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
.. @+node:ekr.20170624151245.1808: *9* k.defineMultiLineCommands
def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
.. @+node:ekr.20170624151245.1809: *9* k.defineSettingIvars
def defineSettingsIvars(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable_autocompleter_initially')
    self.enable_calltips = getBool('enable_calltips_initially')
    self.ignore_caps_lock = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_foreground_color = getColor('minibuffer_foreground_color') or 'black'
    self.minibuffer_warning_color = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys = getBool('swap_mac_keys')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable_alt_ctrl_bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'
    self.command_mode_bg_color = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg
    # g.trace(self.c.shortFileName())
.. @+node:ekr.20170624151245.1810: *9* k.defineSingleLineCommands
def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere', # 2011/06/07
        'set-find-node-only', # 2011/06/07
        'set-find-suboutline-only', # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
.. @+node:ekr.20170624151245.1811: *9* k.defineSpecialKeys
def defineSpecialKeys(self):
    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''
    k = self
    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&": "ampersand",
        "^": "asciicircum",
        "~": "asciitilde",
        "*": "asterisk",
        "@": "at",
        "\\": "backslash",
        "|": "bar",
        "{": "braceleft",
        "}": "braceright",
        "[": "bracketleft",
        "]": "bracketright",
        ":": "colon", # removed from code.
        ",": "comma",
        "$": "dollar",
        "=": "equal",
        "!": "exclam", # removed from code.
        ">": "greater",
        "<": "less",
        "-": "minus",
        "#": "numbersign",
        '"': "quotedbl",
        "'": "quoteright",
        "(": "parenleft",
        ")": "parenright", # removed from code.
        "%": "percent",
        ".": "period", # removed from code.
        "+": "plus",
        "?": "question",
        "`": "quoteleft",
        ";": "semicolon",
        "/": "slash",
        " ": "space", # removed from code.
        "_": "underscore",
    }
    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s
    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict[k.guiBindNamesDict.get(key)] = key
.. @+node:ekr.20170624151245.1812: *9* k.defineTkNames
def defineTkNames(self):
    k = self
    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left', 'Right', 'Up', 'Down',
        # Page up/down keys.
        'Next', 'Prior',
        # Home end keys.
        'Home', 'End'
        # Modifier keys.
        'Caps_Lock', 'Num_Lock',
        # F-keys.
        'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
        # All others.
        'Begin', 'Break', 'Clear', 'Delete', 'Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace', 'Linefeed', 'Return', 'Tab',
    )
    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp': 'BackSpace', # Dubious: should be '\b'
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ltarrow': 'Left',
        'pageup': 'Prior',
        'pagedn': 'Next',
        'rtarrow': 'Right',
        'uparrow': 'Up',
    }
    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict[s.lower()] = s
@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20170624151245.1806: *9* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):
    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.functionTail = None # For commands that take minibuffer arguments.
    # These are true globals
    self.getArgEscapes = []
    self.getArgEscapeFlag = False # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None, n=None, handler=None)
.. @+node:ekr.20170624151245.1807: *9* k.defineInternalIvars
def defineInternalIvars(self):
    '''Define internal ivars of the KeyHandlerClass class.'''
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None # New support for the demo.py plugin.
    self.demoPrevKey = None # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
.. @+node:ekr.20170624151245.1808: *9* k.defineMultiLineCommands
def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
.. @+node:ekr.20170624151245.1809: *9* k.defineSettingIvars
def defineSettingsIvars(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable_autocompleter_initially')
    self.enable_calltips = getBool('enable_calltips_initially')
    self.ignore_caps_lock = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_foreground_color = getColor('minibuffer_foreground_color') or 'black'
    self.minibuffer_warning_color = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys = getBool('swap_mac_keys')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable_alt_ctrl_bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'
    self.command_mode_bg_color = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg
    # g.trace(self.c.shortFileName())
.. @+node:ekr.20170624151245.1810: *9* k.defineSingleLineCommands
def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere', # 2011/06/07
        'set-find-node-only', # 2011/06/07
        'set-find-suboutline-only', # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
.. @+node:ekr.20170624151245.1811: *9* k.defineSpecialKeys
def defineSpecialKeys(self):
    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''
    k = self
    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&": "ampersand",
        "^": "asciicircum",
        "~": "asciitilde",
        "*": "asterisk",
        "@": "at",
        "\\": "backslash",
        "|": "bar",
        "{": "braceleft",
        "}": "braceright",
        "[": "bracketleft",
        "]": "bracketright",
        ":": "colon", # removed from code.
        ",": "comma",
        "$": "dollar",
        "=": "equal",
        "!": "exclam", # removed from code.
        ">": "greater",
        "<": "less",
        "-": "minus",
        "#": "numbersign",
        '"': "quotedbl",
        "'": "quoteright",
        "(": "parenleft",
        ")": "parenright", # removed from code.
        "%": "percent",
        ".": "period", # removed from code.
        "+": "plus",
        "?": "question",
        "`": "quoteleft",
        ";": "semicolon",
        "/": "slash",
        " ": "space", # removed from code.
        "_": "underscore",
    }
    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s
    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict[k.guiBindNamesDict.get(key)] = key
.. @+node:ekr.20170624151245.1812: *9* k.defineTkNames
def defineTkNames(self):
    k = self
    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left', 'Right', 'Up', 'Down',
        # Page up/down keys.
        'Next', 'Prior',
        # Home end keys.
        'Home', 'End'
        # Modifier keys.
        'Caps_Lock', 'Num_Lock',
        # F-keys.
        'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
        # All others.
        'Begin', 'Break', 'Clear', 'Delete', 'Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace', 'Linefeed', 'Return', 'Tab',
    )
    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp': 'BackSpace', # Dubious: should be '\b'
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ltarrow': 'Left',
        'pageup': 'Prior',
        'pagedn': 'Next',
        'rtarrow': 'Right',
        'uparrow': 'Up',
    }
    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict[s.lower()] = s
@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20170624151245.1813: *8* k.cmd (decorator)
def cmd(name):
    '''Command decorator for the leoKeys class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'k',])
.. @+node:ekr.20170624151245.1814: *8* k.finishCreate & helpers
def finishCreate(self):
    '''
    Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.
    '''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug('(k)', self.c)
    c, k = self.c, self
    k.w = c.frame.miniBufferWidget
        # Will be None for NullGui.
    k.fnc = FileNameChooser(c)
        # A singleton. Defined here so that c.k will exist.
    k.getArgInstance = GetArg(c)
        # a singleton. Defined here so that c.k will exist.
    k.makeAllBindings()
    k.initCommandHistory()
    k.inited = True
    k.setDefaultInputState()
    k.resetLabel()
.. @+node:ekr.20170624151245.1815: *8* k.oops
def oops(self):
    g.trace('Should be defined in subclass:', g.callers(4))
.. @+node:ekr.20170624151245.1816: *8* k.setDefaultEditingKeyAction (New)
def setDefaultEditingAction(self):
    k = self; c = k.c
    action = c.config.getString('default_editing_state') or 'insert'
    action.lower()
    if action not in ('command', 'insert', 'overwrite'):
        g.trace('ignoring default_editing_state: %s' % (action))
        action = 'insert'
    self.defaultEditingAction = action
.. @+node:ekr.20170624151245.1817: *8* k.setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction(self, allowCommandState=True):
    k = self; c = k.c
    # g.trace(g.callers())
    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command', 'insert', 'overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % (defaultAction))
        self.unboundKeyAction = 'insert'
    # g.trace(self.unboundKeyAction)
    self.defaultUnboundKeyAction = self.unboundKeyAction
    k.setInputState(self.defaultUnboundKeyAction)
.. @+node:ekr.20170624151245.1818: *7* k.Binding
.. @+node:ekr.20170624151245.1842: *8* k.bindKey & helpers
def bindKey(self, pane, shortcut, callback, commandName, modeFlag=False, tag=None):
    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.

    tag gives the source of the binding.

    '''
    trace = False and not g.unitTesting
        # and commandName.startswith('move-lines')
        # and (shortcut == 'F1' or commandName == 'help')
    trace_list = False
    k = self
    if not k.check_bind_key(commandName, pane, shortcut):
        return False
    aList = k.bindingsDict.get(shortcut, [])
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s, stroke
        else:
            stroke = k.strokeFromSetting(shortcut)
        if trace:
            tag = tag.split(' ')[-1]
            g.trace('%7s %25r %17s %s' % (pane, stroke and stroke.s, tag, commandName))
            g.trace(g.callers())
        si = g.ShortcutInfo(kind=tag, pane=pane,
            func=callback, commandName=commandName, stroke=stroke)
        if shortcut:
            k.bindKeyToDict(pane, shortcut, si)
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList, commandName, pane, shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict[stroke] = aList
            if trace and trace_list: g.trace(shortcut, aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding', shortcut, 'to', commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
.. @+node:ekr.20170624151245.1848: *9* k.check_bind_key
def check_bind_key(self, commandName, pane, shortcut):
    # k = self
    if not shortcut:
        return False
        # return True # #327: binding to None clears previous bindings.
    assert g.isStroke(shortcut)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if shortcut.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:', '%s = %s' % (
                commandName, shortcut))
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', shortcut, commandName, g.callers())
        return False
    else:
        return True
.. @+node:ekr.20170624151245.1849: *9* k.kill_one_shortcut
def kill_one_shortcut(self, stroke):
    '''
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    '''
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)
    inv_d = lm.invert(d)
    # g.trace('1', stroke, stroke in c.config.shortcutsDict.d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
    # g.trace('2', stroke, stroke in c.config.shortcutsDict.d)
    # g.trace('3', c.config.shortcutsDict.d.get('help'))
.. @+node:ekr.20170624151245.1850: *9* k.remove_conflicting_definitions
def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si), si
        if pane in ('button', 'all', si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke, k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName, commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
.. @+node:ekr.20170624151245.1851: *9* k.bindKeyToDict
def bindKeyToDict(self, pane, stroke, si):
    '''Update k.masterBindingsDict for the stroke.'''
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    trace = False and not g.unitTesting
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = si
    k.masterBindingsDict[pane] = d
    if trace and si.commandName.startswith('goto-next-visible'):
        g.trace('%4s %10s' % (pane, stroke.s), si.commandName, si.func.__name__)
.. @+node:ekr.20170624151245.1852: *9* k.bindOpenWith
def bindOpenWith(self, d):
    '''Register an open-with command.'''
    k = self; c = k.c
    shortcut = d.get('shortcut')
    name = d.get('name')
    # g.trace(d)
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)
    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName, shortcut, openWithCallback, pane='all', verbose=False)
.. @+node:ekr.20170624151245.1848: *9* k.check_bind_key
def check_bind_key(self, commandName, pane, shortcut):
    # k = self
    if not shortcut:
        return False
        # return True # #327: binding to None clears previous bindings.
    assert g.isStroke(shortcut)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if shortcut.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:', '%s = %s' % (
                commandName, shortcut))
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', shortcut, commandName, g.callers())
        return False
    else:
        return True
.. @+node:ekr.20170624151245.1849: *9* k.kill_one_shortcut
def kill_one_shortcut(self, stroke):
    '''
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    '''
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)
    inv_d = lm.invert(d)
    # g.trace('1', stroke, stroke in c.config.shortcutsDict.d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
    # g.trace('2', stroke, stroke in c.config.shortcutsDict.d)
    # g.trace('3', c.config.shortcutsDict.d.get('help'))
.. @+node:ekr.20170624151245.1850: *9* k.remove_conflicting_definitions
def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si), si
        if pane in ('button', 'all', si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke, k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName, commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
.. @+node:ekr.20170624151245.1851: *9* k.bindKeyToDict
def bindKeyToDict(self, pane, stroke, si):
    '''Update k.masterBindingsDict for the stroke.'''
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    trace = False and not g.unitTesting
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = si
    k.masterBindingsDict[pane] = d
    if trace and si.commandName.startswith('goto-next-visible'):
        g.trace('%4s %10s' % (pane, stroke.s), si.commandName, si.func.__name__)
.. @+node:ekr.20170624151245.1852: *9* k.bindOpenWith
def bindOpenWith(self, d):
    '''Register an open-with command.'''
    k = self; c = k.c
    shortcut = d.get('shortcut')
    name = d.get('name')
    # g.trace(d)
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)
    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName, shortcut, openWithCallback, pane='all', verbose=False)
.. @+node:ekr.20170624151245.1853: *8* k.checkBindings
def checkBindings(self):
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    k = self; c = k.c
    if not c.config.getBool('warn_about_missing_settings'): return
    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&', '')
        if not c.config.exists(key, 'shortcut'):
            if abbrev:
                g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name, abbrev, key))
            else:
                g.trace('No shortcut for %s = %s' % (name, key))
.. @+node:ekr.20170624151245.1854: *8* k.completeAllBindings
def completeAllBindings(self, w=None):
    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''
    # g.trace(w)
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
.. @+node:ekr.20170624151245.1855: *8* k.completeAllBindingsForWidget
def completeAllBindingsForWidget(self, w):
    '''Make all a master gui binding for widget w.'''
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
.. @+node:ekr.20170624151245.1856: *8* k.dumpMasterBindingsDict
def dumpMasterBindingsDict(self):
    '''Dump k.masterBindingsDict.'''
    k = self; d = k.masterBindingsDict
    g.pr('\nk.masterBindingsDict...\n')
    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            si = d2.get(key2)
            assert g.isShortcutInfo(si), si
            g.pr('%20s %s' % (key2, si.commandName))
.. @+node:ekr.20170624151245.1857: *8* k.initAbbrev & helper
def initAbbrev(self):
    k = self; c = k.c; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName, key)
.. @+node:ekr.20170624151245.1859: *9* k.initOneAbbrev
def initOneAbbrev(self, commandName, key):
    '''Enter key as an abbreviation for commandName in c.commandsDict.'''
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
.. @+node:ekr.20170624151245.1859: *9* k.initOneAbbrev
def initOneAbbrev(self, commandName, key):
    '''Enter key as an abbreviation for commandName in c.commandsDict.'''
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
.. @+node:ekr.20170624151245.1860: *8* k.initSpecialIvars
def initSpecialIvars(self):
    '''Set ivars for special keystrokes from previously-existing bindings.'''
    k = self; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn = c.config.getBool('warn_about_missing_settings')
    for ivar, commandName in (
        ('fullCommandKey', 'full-command'),
        ('abortAllModesKey', 'keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey', 'auto-complete-force'),
        ('demoNextKey', 'demo-next'),
        ('demoPrevKey', 'demo-prev'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList, found = aList or [], False
        for pane in ('text', 'all'):
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.pane == pane:
                    if trace: g.trace(commandName, ivar, si.stroke)
                    setattr(k, ivar, si.stroke)
                    found = True; break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
.. @+node:ekr.20170624151245.1861: *8* k.killBinding
def killBinding(self, commandName):
    '''
    Kill all bindings for all keystrokes presently assigned to commandName.
    '''
    # g.trace(commandName)
.. @+node:ekr.20170624151245.1862: *8* k.makeAllBindings
def makeAllBindings(self):
    '''Make all key bindings in all of Leo's panes.'''
    k = self
    k.bindingsDict = {}
    k.addModeCommands()
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
.. @+node:ekr.20170624151245.1863: *8* k.makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict(self):
    '''Add bindings for all entries in c.commandsDict.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    d = c.commandsDict
    t1 = time.time()
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of si with si.stroke == stroke.
    d2 = g.TypedDictOfLists(
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke, valType=g.ShortcutInfo)
    for commandName in sorted(d):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for si in aList:
            if trace and commandName == 'help':
                g.trace(key, repr(si.stroke), aList)
            assert isinstance(si, g.ShortcutInfo)
            # Important: si.stroke is already canonicalized.
            stroke = si.stroke
            si.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add(stroke, si)
    # Step 2: make the bindings.
    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for si in aList2:
            assert isinstance(si, g.ShortcutInfo)
            commandName = si.commandName
            command = c.commandsDict.get(commandName)
            tag = si.kind
            pane = si.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane, stroke, command, commandName, tag=tag)
    t2 = time.time()
    if trace:
        g.trace('%0.2f sec %s' % ((t2 - t1), c.shortFileName()))
.. @+node:ekr.20170624151245.1864: *8* k.makeMasterGuiBinding
def makeMasterGuiBinding(self, stroke, w=None, trace=False):
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    trace = False and not g.unitTesting
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree, 'bindingWidget') and f.tree.bindingWidget or None
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
    if trace: g.trace(len(aList), stroke)
.. @+node:ekr.20170624151245.1842: *8* k.bindKey & helpers
def bindKey(self, pane, shortcut, callback, commandName, modeFlag=False, tag=None):
    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.

    tag gives the source of the binding.

    '''
    trace = False and not g.unitTesting
        # and commandName.startswith('move-lines')
        # and (shortcut == 'F1' or commandName == 'help')
    trace_list = False
    k = self
    if not k.check_bind_key(commandName, pane, shortcut):
        return False
    aList = k.bindingsDict.get(shortcut, [])
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s, stroke
        else:
            stroke = k.strokeFromSetting(shortcut)
        if trace:
            tag = tag.split(' ')[-1]
            g.trace('%7s %25r %17s %s' % (pane, stroke and stroke.s, tag, commandName))
            g.trace(g.callers())
        si = g.ShortcutInfo(kind=tag, pane=pane,
            func=callback, commandName=commandName, stroke=stroke)
        if shortcut:
            k.bindKeyToDict(pane, shortcut, si)
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList, commandName, pane, shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict[stroke] = aList
            if trace and trace_list: g.trace(shortcut, aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding', shortcut, 'to', commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
.. @+node:ekr.20170624151245.1848: *9* k.check_bind_key
def check_bind_key(self, commandName, pane, shortcut):
    # k = self
    if not shortcut:
        return False
        # return True # #327: binding to None clears previous bindings.
    assert g.isStroke(shortcut)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if shortcut.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:', '%s = %s' % (
                commandName, shortcut))
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', shortcut, commandName, g.callers())
        return False
    else:
        return True
.. @+node:ekr.20170624151245.1849: *9* k.kill_one_shortcut
def kill_one_shortcut(self, stroke):
    '''
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    '''
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)
    inv_d = lm.invert(d)
    # g.trace('1', stroke, stroke in c.config.shortcutsDict.d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
    # g.trace('2', stroke, stroke in c.config.shortcutsDict.d)
    # g.trace('3', c.config.shortcutsDict.d.get('help'))
.. @+node:ekr.20170624151245.1850: *9* k.remove_conflicting_definitions
def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si), si
        if pane in ('button', 'all', si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke, k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName, commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
.. @+node:ekr.20170624151245.1851: *9* k.bindKeyToDict
def bindKeyToDict(self, pane, stroke, si):
    '''Update k.masterBindingsDict for the stroke.'''
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    trace = False and not g.unitTesting
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = si
    k.masterBindingsDict[pane] = d
    if trace and si.commandName.startswith('goto-next-visible'):
        g.trace('%4s %10s' % (pane, stroke.s), si.commandName, si.func.__name__)
.. @+node:ekr.20170624151245.1852: *9* k.bindOpenWith
def bindOpenWith(self, d):
    '''Register an open-with command.'''
    k = self; c = k.c
    shortcut = d.get('shortcut')
    name = d.get('name')
    # g.trace(d)
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)
    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName, shortcut, openWithCallback, pane='all', verbose=False)
.. @+node:ekr.20170624151245.1848: *9* k.check_bind_key
def check_bind_key(self, commandName, pane, shortcut):
    # k = self
    if not shortcut:
        return False
        # return True # #327: binding to None clears previous bindings.
    assert g.isStroke(shortcut)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if shortcut.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:', '%s = %s' % (
                commandName, shortcut))
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', shortcut, commandName, g.callers())
        return False
    else:
        return True
.. @+node:ekr.20170624151245.1849: *9* k.kill_one_shortcut
def kill_one_shortcut(self, stroke):
    '''
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    '''
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)
    inv_d = lm.invert(d)
    # g.trace('1', stroke, stroke in c.config.shortcutsDict.d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
    # g.trace('2', stroke, stroke in c.config.shortcutsDict.d)
    # g.trace('3', c.config.shortcutsDict.d.get('help'))
.. @+node:ekr.20170624151245.1850: *9* k.remove_conflicting_definitions
def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si), si
        if pane in ('button', 'all', si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke, k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName, commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
.. @+node:ekr.20170624151245.1851: *9* k.bindKeyToDict
def bindKeyToDict(self, pane, stroke, si):
    '''Update k.masterBindingsDict for the stroke.'''
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    trace = False and not g.unitTesting
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = si
    k.masterBindingsDict[pane] = d
    if trace and si.commandName.startswith('goto-next-visible'):
        g.trace('%4s %10s' % (pane, stroke.s), si.commandName, si.func.__name__)
.. @+node:ekr.20170624151245.1852: *9* k.bindOpenWith
def bindOpenWith(self, d):
    '''Register an open-with command.'''
    k = self; c = k.c
    shortcut = d.get('shortcut')
    name = d.get('name')
    # g.trace(d)
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)
    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName, shortcut, openWithCallback, pane='all', verbose=False)
.. @+node:ekr.20170624151245.1853: *8* k.checkBindings
def checkBindings(self):
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    k = self; c = k.c
    if not c.config.getBool('warn_about_missing_settings'): return
    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&', '')
        if not c.config.exists(key, 'shortcut'):
            if abbrev:
                g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name, abbrev, key))
            else:
                g.trace('No shortcut for %s = %s' % (name, key))
.. @+node:ekr.20170624151245.1854: *8* k.completeAllBindings
def completeAllBindings(self, w=None):
    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''
    # g.trace(w)
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
.. @+node:ekr.20170624151245.1855: *8* k.completeAllBindingsForWidget
def completeAllBindingsForWidget(self, w):
    '''Make all a master gui binding for widget w.'''
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
.. @+node:ekr.20170624151245.1856: *8* k.dumpMasterBindingsDict
def dumpMasterBindingsDict(self):
    '''Dump k.masterBindingsDict.'''
    k = self; d = k.masterBindingsDict
    g.pr('\nk.masterBindingsDict...\n')
    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            si = d2.get(key2)
            assert g.isShortcutInfo(si), si
            g.pr('%20s %s' % (key2, si.commandName))
.. @+node:ekr.20170624151245.1857: *8* k.initAbbrev & helper
def initAbbrev(self):
    k = self; c = k.c; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName, key)
.. @+node:ekr.20170624151245.1859: *9* k.initOneAbbrev
def initOneAbbrev(self, commandName, key):
    '''Enter key as an abbreviation for commandName in c.commandsDict.'''
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
.. @+node:ekr.20170624151245.1859: *9* k.initOneAbbrev
def initOneAbbrev(self, commandName, key):
    '''Enter key as an abbreviation for commandName in c.commandsDict.'''
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
.. @+node:ekr.20170624151245.1860: *8* k.initSpecialIvars
def initSpecialIvars(self):
    '''Set ivars for special keystrokes from previously-existing bindings.'''
    k = self; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn = c.config.getBool('warn_about_missing_settings')
    for ivar, commandName in (
        ('fullCommandKey', 'full-command'),
        ('abortAllModesKey', 'keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey', 'auto-complete-force'),
        ('demoNextKey', 'demo-next'),
        ('demoPrevKey', 'demo-prev'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList, found = aList or [], False
        for pane in ('text', 'all'):
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.pane == pane:
                    if trace: g.trace(commandName, ivar, si.stroke)
                    setattr(k, ivar, si.stroke)
                    found = True; break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
.. @+node:ekr.20170624151245.1861: *8* k.killBinding
def killBinding(self, commandName):
    '''
    Kill all bindings for all keystrokes presently assigned to commandName.
    '''
    # g.trace(commandName)
.. @+node:ekr.20170624151245.1862: *8* k.makeAllBindings
def makeAllBindings(self):
    '''Make all key bindings in all of Leo's panes.'''
    k = self
    k.bindingsDict = {}
    k.addModeCommands()
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
.. @+node:ekr.20170624151245.1863: *8* k.makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict(self):
    '''Add bindings for all entries in c.commandsDict.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    d = c.commandsDict
    t1 = time.time()
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of si with si.stroke == stroke.
    d2 = g.TypedDictOfLists(
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke, valType=g.ShortcutInfo)
    for commandName in sorted(d):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for si in aList:
            if trace and commandName == 'help':
                g.trace(key, repr(si.stroke), aList)
            assert isinstance(si, g.ShortcutInfo)
            # Important: si.stroke is already canonicalized.
            stroke = si.stroke
            si.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add(stroke, si)
    # Step 2: make the bindings.
    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for si in aList2:
            assert isinstance(si, g.ShortcutInfo)
            commandName = si.commandName
            command = c.commandsDict.get(commandName)
            tag = si.kind
            pane = si.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane, stroke, command, commandName, tag=tag)
    t2 = time.time()
    if trace:
        g.trace('%0.2f sec %s' % ((t2 - t1), c.shortFileName()))
.. @+node:ekr.20170624151245.1864: *8* k.makeMasterGuiBinding
def makeMasterGuiBinding(self, stroke, w=None, trace=False):
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    trace = False and not g.unitTesting
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree, 'bindingWidget') and f.tree.bindingWidget or None
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
    if trace: g.trace(len(aList), stroke)
.. @+node:ekr.20170624151245.1865: *7* k.Command history
.. @+node:ekr.20170624151245.1871: *8* k.addToCommandHistory
def addToCommandHistory(self, commandName):
    '''Add a name to the command history.'''
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None
    # g.trace(commandName,h)
.. @+node:ekr.20170624151245.1872: *8* k.commandHistoryDown
def commandHistoryFwd(self):
    '''
    Move down the Command History - fall off the bottom (return empty string)
    if necessary
    '''
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        commandName = ''
        if i == len(h) -1:
            # fall off the bottom
            i = None
        elif i != None:
            # move to next down in list
            i += 1
            commandName = h[i]
        # (else i == None; no change to index, command == '')
        # g.trace(i,h)
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
.. @+node:ekr.20170624151245.1873: *8* k.commandHistoryUp
def commandHistoryBackwd(self):
    '''
    Return the previous entry in the Command History - stay at the top
    if we are there
    '''
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        if i == None:
            # first time in - set to last entry
            i = len(h) -1
        elif i > 0:
            i -= 1
        commandName = h[i]
        k.commandIndex = i
        # g.trace(i,h)
        k.setLabel(k.mb_prefix + commandName)
.. @+node:ekr.20170624151245.1874: *8* k.initCommandHistory
def initCommandHistory(self):
    '''Init command history from @data command-history nodes.'''
    k, c = self, self.c
    aList = c.config.getData('history-list') or []
    for command in reversed(aList):
        k.addToCommandHistory(command)

def resetCommandHistory(self):
    ''' reset the command history index to indicate that
        we are pointing 'past' the last entry
    '''
    self.commandIndex = None
    #
.. @+node:ekr.20170624151245.1875: *8* k.sortCommandHistory
def sortCommandHistory(self):
    '''Sort the command history.'''
    k = self
    k.commandHistory.sort()
    k.commandIndex = None
.. @+node:ekr.20170624151245.1871: *8* k.addToCommandHistory
def addToCommandHistory(self, commandName):
    '''Add a name to the command history.'''
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None
    # g.trace(commandName,h)
.. @+node:ekr.20170624151245.1872: *8* k.commandHistoryDown
def commandHistoryFwd(self):
    '''
    Move down the Command History - fall off the bottom (return empty string)
    if necessary
    '''
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        commandName = ''
        if i == len(h) -1:
            # fall off the bottom
            i = None
        elif i != None:
            # move to next down in list
            i += 1
            commandName = h[i]
        # (else i == None; no change to index, command == '')
        # g.trace(i,h)
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
.. @+node:ekr.20170624151245.1873: *8* k.commandHistoryUp
def commandHistoryBackwd(self):
    '''
    Return the previous entry in the Command History - stay at the top
    if we are there
    '''
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        if i == None:
            # first time in - set to last entry
            i = len(h) -1
        elif i > 0:
            i -= 1
        commandName = h[i]
        k.commandIndex = i
        # g.trace(i,h)
        k.setLabel(k.mb_prefix + commandName)
.. @+node:ekr.20170624151245.1874: *8* k.initCommandHistory
def initCommandHistory(self):
    '''Init command history from @data command-history nodes.'''
    k, c = self, self.c
    aList = c.config.getData('history-list') or []
    for command in reversed(aList):
        k.addToCommandHistory(command)

def resetCommandHistory(self):
    ''' reset the command history index to indicate that
        we are pointing 'past' the last entry
    '''
    self.commandIndex = None
    #
.. @+node:ekr.20170624151245.1875: *8* k.sortCommandHistory
def sortCommandHistory(self):
    '''Sort the command history.'''
    k = self
    k.commandHistory.sort()
    k.commandIndex = None
.. @+node:ekr.20170624151245.1876: *7* k.Dispatching
.. @+node:ekr.20170624151245.1881: *8* k.fullCommand (alt-x) & helper
@cmd('full-command')
def fullCommand(self, event, specialStroke=None, specialFunc=None, help=False, helpHandler=None):
    '''Handle 'full-command' (alt-x) mode.'''
    trace = False and not g.unitTesting
    verbose = False
    try:
        k = self; c = k.c
        state = k.getState('full-command')
        helpPrompt = 'Help for command: '
        c.check_event(event)
        ch = char = event.char if event else ''
        stroke = event.stroke if event else ''
        if trace: g.trace('state', state, repr(char))
        if state > 0:
            k.setLossage(char, stroke)
        if state == 0:
            k.mb_event = event # Save the full event for later.
            k.setState('full-command', 1, handler=k.fullCommand)
            prompt = helpPrompt if help else k.altX_prompt
            k.setLabelBlue(prompt)
            k.mb_help = help
            k.mb_helpHandler = helpHandler
            c.minibufferWantsFocus()
        elif char == 'Ins' or k.isFKey(char):
            pass
        elif char == 'Escape':
            k.keyboardQuit()
        elif char == 'Down':
            k.commandHistoryFwd()
        elif char == 'Up':
            k.commandHistoryBackwd()
        elif char in ('\n', 'Return'):
            if trace and verbose: g.trace('***Return')
            # if trace and trace_event:
                # g.trace('hasSelection %r' % (
                    # k.mb_event and k.mb_event.w and k.mb_event.w.hasSelection()))
            # Fix bug 157: save and restore the selection.
            w = k.mb_event and k.mb_event.w
            if w and hasattr(w, 'hasSelection') and w.hasSelection():
                sel1, sel2 = w.getSelectionRange()
                ins = w.getInsertPoint()
                c.frame.log.deleteTab('Completion')
                w.setSelectionRange(sel1, sel2, insert=ins)
            else:
                c.frame.log.deleteTab('Completion')
                    # 2016/04/27
            if k.mb_help:
                s = k.getLabel()
                commandName = s[len(helpPrompt):].strip()
                k.clearState()
                k.resetLabel()
                if k.mb_helpHandler: k.mb_helpHandler(commandName)
            else:
                s = k.getLabel(ignorePrompt=True)
                commandName = s.strip()
                ok = k.callAltXFunction(k.mb_event)
                if ok:
                    k.addToCommandHistory(commandName)
        elif char in ('\t', 'Tab'):
            if trace and verbose: g.trace('***Tab')
            k.doTabCompletion(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif char in ('\b', 'BackSpace'):
            if trace and verbose: g.trace('***BackSpace')
            k.doBackSpace(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
            # g.trace('non-ascii')
            if specialStroke:
                g.trace(specialStroke)
                specialFunc()
            c.minibufferWantsFocus()
        else:
            # Clear the list, any other character besides tab indicates that a new prefix is in effect.
            k.mb_tabList = []
            k.updateLabel(event)
            k.mb_tabListPrefix = k.getLabel()
            c.minibufferWantsFocus()
            # g.trace('new prefix',k.mb_tabListPrefix)
    except Exception:
        g.es_exception()
        self.keyboardQuit()
.. @+node:ekr.20170624151245.1883: *9* callAltXFunction
def callAltXFunction(self, event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    # s = k.getLabel()
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    if trace: g.trace('command:', commandName, 'tail:', tail)
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.
        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))
    else:
        func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            # g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            try:
                func(event)
            except Exception:
                g.es_exception()
        else:
            c.widgetWantsFocusNow(event and event.widget)
                # Important, so cut-text works, e.g.
            try:
                func(event)
            except Exception:
                g.es_exception()
        k.endCommand(commandName)
        return True
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setStatusLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
        return False
.. @+node:ekr.20170624151245.1883: *9* callAltXFunction
def callAltXFunction(self, event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    # s = k.getLabel()
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    if trace: g.trace('command:', commandName, 'tail:', tail)
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.
        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))
    else:
        func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            # g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            try:
                func(event)
            except Exception:
                g.es_exception()
        else:
            c.widgetWantsFocusNow(event and event.widget)
                # Important, so cut-text works, e.g.
            try:
                func(event)
            except Exception:
                g.es_exception()
        k.endCommand(commandName)
        return True
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setStatusLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
        return False
.. @+node:ekr.20170624151245.1884: *8* k.endCommand
def endCommand(self, commandName):
    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''
    k = self; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return
    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        if not k.inState():
            k.commandName = None
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
            k.newMinibufferWidget = None
.. @+node:ekr.20170624151245.1881: *8* k.fullCommand (alt-x) & helper
@cmd('full-command')
def fullCommand(self, event, specialStroke=None, specialFunc=None, help=False, helpHandler=None):
    '''Handle 'full-command' (alt-x) mode.'''
    trace = False and not g.unitTesting
    verbose = False
    try:
        k = self; c = k.c
        state = k.getState('full-command')
        helpPrompt = 'Help for command: '
        c.check_event(event)
        ch = char = event.char if event else ''
        stroke = event.stroke if event else ''
        if trace: g.trace('state', state, repr(char))
        if state > 0:
            k.setLossage(char, stroke)
        if state == 0:
            k.mb_event = event # Save the full event for later.
            k.setState('full-command', 1, handler=k.fullCommand)
            prompt = helpPrompt if help else k.altX_prompt
            k.setLabelBlue(prompt)
            k.mb_help = help
            k.mb_helpHandler = helpHandler
            c.minibufferWantsFocus()
        elif char == 'Ins' or k.isFKey(char):
            pass
        elif char == 'Escape':
            k.keyboardQuit()
        elif char == 'Down':
            k.commandHistoryFwd()
        elif char == 'Up':
            k.commandHistoryBackwd()
        elif char in ('\n', 'Return'):
            if trace and verbose: g.trace('***Return')
            # if trace and trace_event:
                # g.trace('hasSelection %r' % (
                    # k.mb_event and k.mb_event.w and k.mb_event.w.hasSelection()))
            # Fix bug 157: save and restore the selection.
            w = k.mb_event and k.mb_event.w
            if w and hasattr(w, 'hasSelection') and w.hasSelection():
                sel1, sel2 = w.getSelectionRange()
                ins = w.getInsertPoint()
                c.frame.log.deleteTab('Completion')
                w.setSelectionRange(sel1, sel2, insert=ins)
            else:
                c.frame.log.deleteTab('Completion')
                    # 2016/04/27
            if k.mb_help:
                s = k.getLabel()
                commandName = s[len(helpPrompt):].strip()
                k.clearState()
                k.resetLabel()
                if k.mb_helpHandler: k.mb_helpHandler(commandName)
            else:
                s = k.getLabel(ignorePrompt=True)
                commandName = s.strip()
                ok = k.callAltXFunction(k.mb_event)
                if ok:
                    k.addToCommandHistory(commandName)
        elif char in ('\t', 'Tab'):
            if trace and verbose: g.trace('***Tab')
            k.doTabCompletion(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif char in ('\b', 'BackSpace'):
            if trace and verbose: g.trace('***BackSpace')
            k.doBackSpace(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
            # g.trace('non-ascii')
            if specialStroke:
                g.trace(specialStroke)
                specialFunc()
            c.minibufferWantsFocus()
        else:
            # Clear the list, any other character besides tab indicates that a new prefix is in effect.
            k.mb_tabList = []
            k.updateLabel(event)
            k.mb_tabListPrefix = k.getLabel()
            c.minibufferWantsFocus()
            # g.trace('new prefix',k.mb_tabListPrefix)
    except Exception:
        g.es_exception()
        self.keyboardQuit()
.. @+node:ekr.20170624151245.1883: *9* callAltXFunction
def callAltXFunction(self, event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    # s = k.getLabel()
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    if trace: g.trace('command:', commandName, 'tail:', tail)
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.
        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))
    else:
        func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            # g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            try:
                func(event)
            except Exception:
                g.es_exception()
        else:
            c.widgetWantsFocusNow(event and event.widget)
                # Important, so cut-text works, e.g.
            try:
                func(event)
            except Exception:
                g.es_exception()
        k.endCommand(commandName)
        return True
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setStatusLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
        return False
.. @+node:ekr.20170624151245.1883: *9* callAltXFunction
def callAltXFunction(self, event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    # s = k.getLabel()
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    if trace: g.trace('command:', commandName, 'tail:', tail)
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.
        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))
    else:
        func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            # g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            try:
                func(event)
            except Exception:
                g.es_exception()
        else:
            c.widgetWantsFocusNow(event and event.widget)
                # Important, so cut-text works, e.g.
            try:
                func(event)
            except Exception:
                g.es_exception()
        k.endCommand(commandName)
        return True
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setStatusLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
        return False
.. @+node:ekr.20170624151245.1884: *8* k.endCommand
def endCommand(self, commandName):
    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''
    k = self; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return
    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        if not k.inState():
            k.commandName = None
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
            k.newMinibufferWidget = None
.. @+node:ekr.20170624151245.1885: *7* k.Externally visible commands
.. @+node:ekr.20170624151245.1897: *8* k.menuCommandKey
def menuCommandKey(self, event=None):
    # This method must exist, but it never gets called.
    pass
.. @+node:ekr.20170624151245.1898: *8* k.printBindings & helper
@cmd('print-bindings')
def printBindings(self, event=None):
    '''Print all the bindings presently in effect.'''
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            s1 = '' if si.pane == 'all' else si.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = si.commandName
            s4 = si.kind or '<no hash>'
            data.append((s1, s2, s3, s4),)
    # Print keys by type:
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt', # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl', # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append('***** %s...\n' % prefix)
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result # for unit test.
.. @+node:ekr.20170624151245.1900: *9* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    lm = g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        # g.trace('%10s %s' % (key, repr(kind)))
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane + key # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
.. @+node:ekr.20170624151245.1900: *9* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    lm = g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        # g.trace('%10s %s' % (key, repr(kind)))
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane + key # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
.. @+node:ekr.20170624151245.1901: *8* k.printButtons
@cmd('print-buttons')
def printButtons(self, event=None):
    '''Print all @button and @command commands, their bindings and their source.'''
    k = self; c = k.c
    tabName = '@buttons && @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('', s, tabName=tabName)

    data = []
    for aList in [c.config.getButtons(), c.config.getCommands()]:
        for z in aList:
            p, script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h, tag),)
    for aList in [g.app.config.atLocalButtonsList, g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h, 'L'),)
    result = ['%s %s' % (z[1], z[0]) for z in sorted(data)]
    result.extend([
        '',
        'legend:',
        'G leoSettings.leo',
        'L local .leo File',
        'M myLeoSettings.leo',
    ])
    put('\n'.join(result))
.. @+node:ekr.20170624151245.1902: *8* k.printCommands
@cmd('print-commands')
def printCommands(self, event=None):
    '''Print all the known commands and their bindings, if any.'''
    k = self; c = k.c; tabName = 'Commands'
    c.frame.log.clearTab(tabName)
    inverseBindingDict = k.computeInverseBindingDict()
    data, n = [], 0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName, [('', ''),])
        for z in dataList:
            pane, key = z
            pane = '%s ' % (pane) if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key', '')
            s1 = pane + key
            s2 = commandName
            n = max(n, len(s1))
            data.append((s1, s2),)
    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n, z1, z2) for z1, z2 in data]
    g.es('', ''.join(lines), tabName=tabName)
.. @+node:ekr.20170624151245.1903: *8* k.repeatComplexCommand & helper
@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.warning('no previous command')
.. @+node:ekr.20170624151245.1905: *9* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict[last](event)
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20170624151245.1905: *9* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict[last](event)
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20170624151245.1906: *8* k.set-xxx-State
@cmd('set-command-state')
def setCommandState(self, event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-insert-state')
def setInsertState(self, event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-overwrite-state')
def setOverwriteState(self, event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
.. @+node:ekr.20170624151245.1907: *8* k.toggle-input-state
@cmd('toggle-input-state')
def toggleInputState(self, event=None):
    '''The toggle-input-state command.'''
    k = self; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction
    if default == 'insert':
        state = 'command' if state == 'insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state == 'overwrite' else 'overwrite'
    else:
        state = 'insert' if state == 'command' else 'command' # prefer insert to overwrite.
    k.setInputState(state)
    k.showStateAndMode()
.. @+node:ekr.20170624151245.1897: *8* k.menuCommandKey
def menuCommandKey(self, event=None):
    # This method must exist, but it never gets called.
    pass
.. @+node:ekr.20170624151245.1898: *8* k.printBindings & helper
@cmd('print-bindings')
def printBindings(self, event=None):
    '''Print all the bindings presently in effect.'''
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            s1 = '' if si.pane == 'all' else si.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = si.commandName
            s4 = si.kind or '<no hash>'
            data.append((s1, s2, s3, s4),)
    # Print keys by type:
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt', # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl', # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append('***** %s...\n' % prefix)
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result # for unit test.
.. @+node:ekr.20170624151245.1900: *9* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    lm = g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        # g.trace('%10s %s' % (key, repr(kind)))
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane + key # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
.. @+node:ekr.20170624151245.1900: *9* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    lm = g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        # g.trace('%10s %s' % (key, repr(kind)))
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane + key # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
.. @+node:ekr.20170624151245.1901: *8* k.printButtons
@cmd('print-buttons')
def printButtons(self, event=None):
    '''Print all @button and @command commands, their bindings and their source.'''
    k = self; c = k.c
    tabName = '@buttons && @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('', s, tabName=tabName)

    data = []
    for aList in [c.config.getButtons(), c.config.getCommands()]:
        for z in aList:
            p, script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h, tag),)
    for aList in [g.app.config.atLocalButtonsList, g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h, 'L'),)
    result = ['%s %s' % (z[1], z[0]) for z in sorted(data)]
    result.extend([
        '',
        'legend:',
        'G leoSettings.leo',
        'L local .leo File',
        'M myLeoSettings.leo',
    ])
    put('\n'.join(result))
.. @+node:ekr.20170624151245.1902: *8* k.printCommands
@cmd('print-commands')
def printCommands(self, event=None):
    '''Print all the known commands and their bindings, if any.'''
    k = self; c = k.c; tabName = 'Commands'
    c.frame.log.clearTab(tabName)
    inverseBindingDict = k.computeInverseBindingDict()
    data, n = [], 0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName, [('', ''),])
        for z in dataList:
            pane, key = z
            pane = '%s ' % (pane) if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key', '')
            s1 = pane + key
            s2 = commandName
            n = max(n, len(s1))
            data.append((s1, s2),)
    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n, z1, z2) for z1, z2 in data]
    g.es('', ''.join(lines), tabName=tabName)
.. @+node:ekr.20170624151245.1903: *8* k.repeatComplexCommand & helper
@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.warning('no previous command')
.. @+node:ekr.20170624151245.1905: *9* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict[last](event)
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20170624151245.1905: *9* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict[last](event)
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20170624151245.1906: *8* k.set-xxx-State
@cmd('set-command-state')
def setCommandState(self, event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-insert-state')
def setInsertState(self, event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-overwrite-state')
def setOverwriteState(self, event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
.. @+node:ekr.20170624151245.1907: *8* k.toggle-input-state
@cmd('toggle-input-state')
def toggleInputState(self, event=None):
    '''The toggle-input-state command.'''
    k = self; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction
    if default == 'insert':
        state = 'command' if state == 'insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state == 'overwrite' else 'overwrite'
    else:
        state = 'insert' if state == 'command' else 'command' # prefer insert to overwrite.
    k.setInputState(state)
    k.showStateAndMode()
.. @+node:ekr.20170624151245.1908: *7* k.Externally visible helpers
.. @+node:ekr.20170624151245.1920: *8* Wrappers for GetArg methods
# New in Leo 5.4    
def getNextArg(self, handler):
    '''
    Get the next arg.  For example, after a Tab in the find commands.
    See the docstring for k.get1Arg for examples of its use.
    '''
    # Replace the current handler.
    self.getArgInstance.after_get_arg_state = ('getarg', 1, handler)
    
# New in Leo 5.4  
def get1Arg(self, event, handler,
    # returnKind=None, returnState=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    << docstring for k.get1arg >>
    returnKind, returnState = None, None
    assert handler, g.callers()
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def getArg(self, event,
    returnKind=None, returnState=None, handler=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    '''Convenience method mapping k.getArg to ga.get_arg.'''
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def doBackSpace(self, tabList, completion=True):
    '''Convenience method mapping k.doBackSpace to ga.do_back_space.'''
    self.getArgInstance.do_back_space(tabList, completion)

def doTabCompletion(self, tabList):
    '''Convenience method mapping k.doTabCompletion to ga.do_tab.'''
    self.getArgInstance.do_tab(tabList)

def getMinibufferCommandName(self):
    '''
    Convenience method mapping k.getMinibufferCommandName to
    ga.get_minibuffer_command_name.
    '''
    return self.getArgInstance.get_minibuffer_command_name()
.. @+node:ekr.20170624151245.1922: *9* << docstring for k.get1arg >>
'''
k.get1Arg: Handle the next character the user types when accumulating a
user argument from the minibuffer. Ctrl-G will abort this processing at any
time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.
    
Example 1: get one argument from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
Example 2: get two arguments from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.setLabelBlue('second prompt: ')
        k.getNextArg(handler=self.myCommand2)
        
    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
k.get1Arg and k.getNextArg are a convenience methods. They simply passes
their arguments to the get_arg method of the singleton GetArg instance. This
docstring describes k.get1arg and k.getNextArg as if they were the
corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n, handler)
though they aren't represented that way. When the state machine in the
GetArg class is active, the kind is 'getArg'.  This constant has special
meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    <Return> or (sometimes) <tab>.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.
    
'''
.. @+node:ekr.20170624151245.1922: *9* << docstring for k.get1arg >>
'''
k.get1Arg: Handle the next character the user types when accumulating a
user argument from the minibuffer. Ctrl-G will abort this processing at any
time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.
    
Example 1: get one argument from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
Example 2: get two arguments from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.setLabelBlue('second prompt: ')
        k.getNextArg(handler=self.myCommand2)
        
    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
k.get1Arg and k.getNextArg are a convenience methods. They simply passes
their arguments to the get_arg method of the singleton GetArg instance. This
docstring describes k.get1arg and k.getNextArg as if they were the
corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n, handler)
though they aren't represented that way. When the state machine in the
GetArg class is active, the kind is 'getArg'.  This constant has special
meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    <Return> or (sometimes) <tab>.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.
    
'''
.. @+node:ekr.20170624151245.1923: *8* k.keyboardQuit
@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True, mouseClick=False):
    '''
    This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.
    '''
    trace = False and not g.unitTesting
    k = self; c = k.c
    if trace: g.trace(g.callers())
    if g.app.quitting:
        return
    # 2011/05/30: We may be called from Qt event handlers.
    # Make sure to end editing!
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
.. @+node:ekr.20170624151245.1924: *8* k.manufactureKeyPressForCommandName (changed)
def manufactureKeyPressForCommandName(self, w, commandName):
    '''Implement a command by passing a keypress to the gui.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    stroke = k.getShortcutForCommandName(commandName)
    if not stroke:
        shortcut = None
    elif g.isStroke(stroke):
        shortcut = stroke.s
    else:
        stroke = k.strokeFromSetting(stroke)
        shortcut = stroke.s
    assert g.isString(shortcut)
    if trace and shortcut: g.trace(
        'shortcut', repr(shortcut), 'commandName', commandName)
    if shortcut and w:
        g.app.gui.set_focus(c, w)
        g.app.gui.event_generate(c, None, shortcut, w)
    else:
        message = 'no shortcut for %s' % (commandName)
        if trace: g.trace(message)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.error(message)
.. @+node:ekr.20170624151245.1925: *8* k.overrideCommand
def overrideCommand(self, commandName, func):
    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            si = d2.get(key2)
            assert g.isShortcutInfo(si), si
            if si.commandName == commandName:
                si.func = func
                d2[key2] = si
.. @+node:ekr.20170624151245.1926: *8* k.registerCommand
def registerCommand(self, commandName, shortcut, func,
    pane='all', source_c=None, verbose=False
):
    '''
    Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.
    source_c is the commander in which an @command or @button node is defined.
    '''
    trace = False and not g.unitTesting and commandName == 'help'
    traceCommand = False
    traceEntry = True
    traceStroke = True
    c, k = self.c, self
    is_local = c.shortFileName() not in ('myLeoSettings.leo', 'leoSettings.leo')
    if trace and traceEntry:
        # g.trace(pane, commandName, 'source_c:', source_c)
        g.trace(pane, commandName, shortcut, g.callers())
    f = c.commandsDict.get(commandName)
    if f and f.__name__ != func.__name__:
        g.trace('redefining', commandName, f, '->', func)
        # g.trace('f.__name__', f.__name__, 'func.__name__', func.__name__)
    assert not g.isStroke(shortcut)
    c.commandsDict[commandName] = func
    if shortcut:
        if trace and traceStroke: g.trace('shortcut', shortcut)
        stroke = k.strokeFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    elif is_local:
        # 327: Don't get defaults when handling a local file.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk, aList = c.config.getShortcut(commandName)
        for si in aList:
            assert g.isShortcutInfo(si), si
            assert g.isStrokeOrNone(si.stroke)
            if si.stroke and not si.pane.endswith('-mode'):
                # if trace: g.trace('*** found',si)
                stroke = si.stroke
                pane = si.pane # 2015/05/11.
                break
    if trace and traceStroke:
        g.trace('is_local', is_local, pane, stroke, commandName, c.shortFileName())
    if stroke:
        ok = k.bindKey(pane, stroke, func, commandName, tag='register-command')
            # Must be a stroke.
        k.makeMasterGuiBinding(stroke, trace=trace) # Must be a stroke.
        if trace and traceCommand and ok and not g.app.silentMode:
            g.blue('', '@command: %s = %s' % (
                commandName, k.prettyPrintKey(stroke)))
    elif is_local:
        k.killBinding(commandName)
    elif trace and traceCommand and not g.app.silentMode:
            g.blue('', '@command: %s' % (commandName))
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict[key] = c.commandsDict.get(commandName)
                    break
.. @+node:ekr.20170624151245.1927: *8* k.simulateCommand & k.commandExists
def simulateCommand(self, commandName, event=None):
    '''Execute a Leo command by name.'''
    k = self; c = k.c
    func = self.commandExists(commandName)
    if func:
        # g.trace(commandName,func.__name__)
        if event:
            pass
        elif commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.app.gui.create_key_event(c, None, None, None)
        k.masterCommand(event=event, func=func)
        if c.exists:
            return k.funcReturn
        else:
            return None
    elif g.app.unitTesting:
        raise AttributeError
    else:
        g.error('simulateCommand: no command for %s' % (commandName))
        return None
.. @+node:ekr.20170624151245.1929: *9* k.commandExists
def commandExists(self, commandName):
    '''Return the command handler for the given command name, or None.'''
    c, k = self.c, self
    commandName = commandName.strip()
    if commandName:
        aList = commandName.split(None)
        if len(aList) == 1:
            k.givenArgs = []
        else:
            commandName = aList[0]
            k.givenArgs = aList[1:]
        # g.trace(commandName,k.givenArgs)
        func = c.commandsDict.get(commandName)
        return func
    else:
        return None
.. @+node:ekr.20170624151245.1929: *9* k.commandExists
def commandExists(self, commandName):
    '''Return the command handler for the given command name, or None.'''
    c, k = self.c, self
    commandName = commandName.strip()
    if commandName:
        aList = commandName.split(None)
        if len(aList) == 1:
            k.givenArgs = []
        else:
            commandName = aList[0]
            k.givenArgs = aList[1:]
        # g.trace(commandName,k.givenArgs)
        func = c.commandsDict.get(commandName)
        return func
    else:
        return None
.. @+node:ekr.20170624151245.1930: *8* k.getFileName
def getFileName(self, event, callback=None,
    filterExt=None, prompt='Enter File Name: ', tabName='Dired'
):
    '''Get a file name from the minibuffer.'''
    k = self
    k.fnc.get_file_name(event, callback, filterExt, prompt, tabName)
.. @+node:ekr.20170624151245.1920: *8* Wrappers for GetArg methods
# New in Leo 5.4    
def getNextArg(self, handler):
    '''
    Get the next arg.  For example, after a Tab in the find commands.
    See the docstring for k.get1Arg for examples of its use.
    '''
    # Replace the current handler.
    self.getArgInstance.after_get_arg_state = ('getarg', 1, handler)
    
# New in Leo 5.4  
def get1Arg(self, event, handler,
    # returnKind=None, returnState=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    << docstring for k.get1arg >>
    returnKind, returnState = None, None
    assert handler, g.callers()
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def getArg(self, event,
    returnKind=None, returnState=None, handler=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    '''Convenience method mapping k.getArg to ga.get_arg.'''
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def doBackSpace(self, tabList, completion=True):
    '''Convenience method mapping k.doBackSpace to ga.do_back_space.'''
    self.getArgInstance.do_back_space(tabList, completion)

def doTabCompletion(self, tabList):
    '''Convenience method mapping k.doTabCompletion to ga.do_tab.'''
    self.getArgInstance.do_tab(tabList)

def getMinibufferCommandName(self):
    '''
    Convenience method mapping k.getMinibufferCommandName to
    ga.get_minibuffer_command_name.
    '''
    return self.getArgInstance.get_minibuffer_command_name()
.. @+node:ekr.20170624151245.1922: *9* << docstring for k.get1arg >>
'''
k.get1Arg: Handle the next character the user types when accumulating a
user argument from the minibuffer. Ctrl-G will abort this processing at any
time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.
    
Example 1: get one argument from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
Example 2: get two arguments from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.setLabelBlue('second prompt: ')
        k.getNextArg(handler=self.myCommand2)
        
    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
k.get1Arg and k.getNextArg are a convenience methods. They simply passes
their arguments to the get_arg method of the singleton GetArg instance. This
docstring describes k.get1arg and k.getNextArg as if they were the
corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n, handler)
though they aren't represented that way. When the state machine in the
GetArg class is active, the kind is 'getArg'.  This constant has special
meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    <Return> or (sometimes) <tab>.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.
    
'''
.. @+node:ekr.20170624151245.1922: *9* << docstring for k.get1arg >>
'''
k.get1Arg: Handle the next character the user types when accumulating a
user argument from the minibuffer. Ctrl-G will abort this processing at any
time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.
    
Example 1: get one argument from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
Example 2: get two arguments from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.setLabelBlue('second prompt: ')
        k.getNextArg(handler=self.myCommand2)
        
    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
k.get1Arg and k.getNextArg are a convenience methods. They simply passes
their arguments to the get_arg method of the singleton GetArg instance. This
docstring describes k.get1arg and k.getNextArg as if they were the
corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n, handler)
though they aren't represented that way. When the state machine in the
GetArg class is active, the kind is 'getArg'.  This constant has special
meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    <Return> or (sometimes) <tab>.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.
    
'''
.. @+node:ekr.20170624151245.1923: *8* k.keyboardQuit
@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True, mouseClick=False):
    '''
    This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.
    '''
    trace = False and not g.unitTesting
    k = self; c = k.c
    if trace: g.trace(g.callers())
    if g.app.quitting:
        return
    # 2011/05/30: We may be called from Qt event handlers.
    # Make sure to end editing!
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
.. @+node:ekr.20170624151245.1924: *8* k.manufactureKeyPressForCommandName (changed)
def manufactureKeyPressForCommandName(self, w, commandName):
    '''Implement a command by passing a keypress to the gui.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    stroke = k.getShortcutForCommandName(commandName)
    if not stroke:
        shortcut = None
    elif g.isStroke(stroke):
        shortcut = stroke.s
    else:
        stroke = k.strokeFromSetting(stroke)
        shortcut = stroke.s
    assert g.isString(shortcut)
    if trace and shortcut: g.trace(
        'shortcut', repr(shortcut), 'commandName', commandName)
    if shortcut and w:
        g.app.gui.set_focus(c, w)
        g.app.gui.event_generate(c, None, shortcut, w)
    else:
        message = 'no shortcut for %s' % (commandName)
        if trace: g.trace(message)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.error(message)
.. @+node:ekr.20170624151245.1925: *8* k.overrideCommand
def overrideCommand(self, commandName, func):
    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            si = d2.get(key2)
            assert g.isShortcutInfo(si), si
            if si.commandName == commandName:
                si.func = func
                d2[key2] = si
.. @+node:ekr.20170624151245.1926: *8* k.registerCommand
def registerCommand(self, commandName, shortcut, func,
    pane='all', source_c=None, verbose=False
):
    '''
    Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.
    source_c is the commander in which an @command or @button node is defined.
    '''
    trace = False and not g.unitTesting and commandName == 'help'
    traceCommand = False
    traceEntry = True
    traceStroke = True
    c, k = self.c, self
    is_local = c.shortFileName() not in ('myLeoSettings.leo', 'leoSettings.leo')
    if trace and traceEntry:
        # g.trace(pane, commandName, 'source_c:', source_c)
        g.trace(pane, commandName, shortcut, g.callers())
    f = c.commandsDict.get(commandName)
    if f and f.__name__ != func.__name__:
        g.trace('redefining', commandName, f, '->', func)
        # g.trace('f.__name__', f.__name__, 'func.__name__', func.__name__)
    assert not g.isStroke(shortcut)
    c.commandsDict[commandName] = func
    if shortcut:
        if trace and traceStroke: g.trace('shortcut', shortcut)
        stroke = k.strokeFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    elif is_local:
        # 327: Don't get defaults when handling a local file.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk, aList = c.config.getShortcut(commandName)
        for si in aList:
            assert g.isShortcutInfo(si), si
            assert g.isStrokeOrNone(si.stroke)
            if si.stroke and not si.pane.endswith('-mode'):
                # if trace: g.trace('*** found',si)
                stroke = si.stroke
                pane = si.pane # 2015/05/11.
                break
    if trace and traceStroke:
        g.trace('is_local', is_local, pane, stroke, commandName, c.shortFileName())
    if stroke:
        ok = k.bindKey(pane, stroke, func, commandName, tag='register-command')
            # Must be a stroke.
        k.makeMasterGuiBinding(stroke, trace=trace) # Must be a stroke.
        if trace and traceCommand and ok and not g.app.silentMode:
            g.blue('', '@command: %s = %s' % (
                commandName, k.prettyPrintKey(stroke)))
    elif is_local:
        k.killBinding(commandName)
    elif trace and traceCommand and not g.app.silentMode:
            g.blue('', '@command: %s' % (commandName))
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict[key] = c.commandsDict.get(commandName)
                    break
.. @+node:ekr.20170624151245.1927: *8* k.simulateCommand & k.commandExists
def simulateCommand(self, commandName, event=None):
    '''Execute a Leo command by name.'''
    k = self; c = k.c
    func = self.commandExists(commandName)
    if func:
        # g.trace(commandName,func.__name__)
        if event:
            pass
        elif commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.app.gui.create_key_event(c, None, None, None)
        k.masterCommand(event=event, func=func)
        if c.exists:
            return k.funcReturn
        else:
            return None
    elif g.app.unitTesting:
        raise AttributeError
    else:
        g.error('simulateCommand: no command for %s' % (commandName))
        return None
.. @+node:ekr.20170624151245.1929: *9* k.commandExists
def commandExists(self, commandName):
    '''Return the command handler for the given command name, or None.'''
    c, k = self.c, self
    commandName = commandName.strip()
    if commandName:
        aList = commandName.split(None)
        if len(aList) == 1:
            k.givenArgs = []
        else:
            commandName = aList[0]
            k.givenArgs = aList[1:]
        # g.trace(commandName,k.givenArgs)
        func = c.commandsDict.get(commandName)
        return func
    else:
        return None
.. @+node:ekr.20170624151245.1929: *9* k.commandExists
def commandExists(self, commandName):
    '''Return the command handler for the given command name, or None.'''
    c, k = self.c, self
    commandName = commandName.strip()
    if commandName:
        aList = commandName.split(None)
        if len(aList) == 1:
            k.givenArgs = []
        else:
            commandName = aList[0]
            k.givenArgs = aList[1:]
        # g.trace(commandName,k.givenArgs)
        func = c.commandsDict.get(commandName)
        return func
    else:
        return None
.. @+node:ekr.20170624151245.1930: *8* k.getFileName
def getFileName(self, event, callback=None,
    filterExt=None, prompt='Enter File Name: ', tabName='Dired'
):
    '''Get a file name from the minibuffer.'''
    k = self
    k.fnc.get_file_name(event, callback, filterExt, prompt, tabName)
.. @+node:ekr.20170624151245.1931: *7* k.Master event handlers
.. @+node:ekr.20170624151245.1957: *8* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler(self, event):
    '''The master key handler for almost all key bindings.'''
    trace = False and not g.app.unitTesting
    traceGC = False and not g.app.unitTesting
    verbose = True
    trace_unbound = True
    k, c = self, self.c
    c.check_event(event)
    << define vars >>
    assert g.isStrokeOrNone(stroke)
    if char in special_keys:
        if trace and verbose: g.trace('char', char)
        return
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:', repr(stroke), 'char:',
        repr(event and event.char),
        'ch:', repr(event and event.char),
        'state', state, 'state2', k.unboundKeyAction)
    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if hasattr(c, 'screenCastController') and c.screenCastController:
            c.screenCastController.quit()
        k.masterCommand(commandName='keyboard-quit',
            event=event, func=k.keyboardQuit, stroke=stroke)
        return
    # 2017/01/31: Important support for the demo.py plugin.
    demo = getattr(g.app, 'demo', None)
    if demo:
        # Shortcut everything so that demo-next or demo-prev
        # won't alter of our ivars.
        if k.demoNextKey and stroke == k.demoNextKey:
            if demo.trace: g.trace('demo-next', stroke)
            demo.next_command()
            return
        elif k.demoPrevKey and stroke == k.demoPrevKey:
            if demo.trace: g.trace('demo-prev', stroke)
            demo.prev_command()
            return
    # Always handle modes regardless of vim.
    if k.inState():
        if trace: g.trace('   state %-15s %s' % (state, stroke))
        done = k.doMode(event, state, stroke)
        if done: return
    # Handle vim keys only if not in a state.
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        if trace: g.trace('vc.do_key returns', ok)
        if ok: return
    if traceGC: g.printNewObjects('masterKey 2')
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if w_name.startswith('canvas'):
            # 2016/04/09: experimental.
            if trace: g.trace('plain key in tree')
        elif self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key', stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            k.handleUnboundKeys(event, char, stroke)
            return
    # 2011/02/08: Use getPaneBindings for *all* keys.
    si = k.getPaneBinding(stroke, w)
    if si:
        assert g.isShortcutInfo(si), si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound', stroke, si.func.__name__)
        k.masterCommand(event=event,
            commandName=si.commandName, func=si.func, stroke=si.stroke)
    elif w_name.startswith('canvas'):
        # 2016/04/09: experimental.
        if trace: g.trace('unbound plain key in tree: search')
        k.searchTree(char)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace and trace_unbound: g.trace(' unbound', stroke)
        k.handleUnboundKeys(event, char, stroke)
.. @+node:ekr.20170624151245.1970: *9* << define vars >>
w = event and event.widget
char = event.char if event else ''
stroke = event.stroke if event else ''
w_name = c.widget_name(w)
if w_name.startswith('log'):
    # A hack: send the event to the text part of the log.
    w = event.widget = c.frame.log.logCtrl
state = k.state.kind
special_keys = (
    'Alt_L', 'Alt_R',
    'Caps_Lock', 'Control_L', 'Control_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
)
self.master_key_count += 1
isPlain = k.isPlainKey(stroke)
.. @+node:ekr.20170624151245.1971: *9* k.callStateFunction
def callStateFunction(self, event):
    trace = False and not g.unitTesting
    k, val = self, None
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    if trace: g.trace(k.state.kind, 'ch', ch, 'stroke', stroke,
        'ignore_unbound_non_ascii_keys', k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns', repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b', '\n', '\r', '\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            # if trace: g.trace(k.state.handler.__name__)
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for', k.state.kind)
    return val
.. @+node:ekr.20170624151245.1972: *9* k.doMode
def doMode(self, event, state, stroke):
    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'):
        if k.handleMiniBindings(event, state, stroke):
            return True
    # Second, honor general modes.
    if state == 'getArg':
        k.getArg(event, stroke=stroke)
        return True
    elif state in ('getFileName', 'get-file-name'):
        if trace: g.trace(event, state, stroke)
        k.getFileName(event)
        return True
    elif state in ('full-command', 'auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function', k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns', repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('calling generalModeHandler', stroke)
            k.generalModeHandler(event,
                commandName=si.commandName, func=si.func,
                modeName=state, nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode', stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler', handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
.. @+node:ekr.20170624151245.1973: *9* k.getPaneBinding
def getPaneBinding(self, stroke, w):
    trace = False and not g.unitTesting
    trace_dict = True
    verbose = True
    k = self; w_name = k.c.widget_name(w)
    state = k.unboundKeyAction
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return None
    if trace: g.trace('===== w_name', repr(w_name), 'stroke', stroke,
        # 'w', w,
        'isTextWrapper(w)', g.isTextWrapper(w))
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'), # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        if trace and trace_dict:
            d = k.masterBindingsDict.get(key, {})
            g.trace('key:', key)
            if d:
                g.trace('d.get(%s)' % (stroke))
                g.trace(d.get(stroke))
            
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command', 'insert', 'overwrite') and state == key or # 2010/02/09
            key in ('text', 'all') and g.isTextWrapper(w) or
            key in ('button', 'all')
        ):
            d = k.masterBindingsDict.get(key, {})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key, name, stroke, stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    table = ('previous-line', 'next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case', si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found: %s = %s' % (
                            key, name, repr(si.stroke), si.commandName))
                        return si
    return None
.. @+node:ekr.20170624151245.1974: *9* k.handleDefaultChar
def handleDefaultChar(self, event, stroke):
    '''Handle an unbound key.'''
    trace = False and not g.unitTesting
    verbose = True
    c, k = self.c, self
    w = event and event.widget
    name = c.widget_name(w)
    if trace and verbose:
        g.trace('widget_name', name, 'stroke', stroke,
        'enable alt-ctrl', self.enable_alt_ctrl_bindings)
    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:', stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
    elif name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring', stroke)
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        log_w = event.widget
        if log_w and hasattr(log_w, 'supportsHighLevelInterface'):
            # Send the event to the text widget, not the LeoLog instance.
            i = log_w.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                log_w.insert(i, s)
        elif trace: g.trace('not supportsHighLevelInterface', log_w)
    else:
        pass # Ignore the event
.. @+node:ekr.20170624151245.1975: *9* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    k = self; c = k.c
    trace = False and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    if state in ('getArg', 'full-command'):
        if stroke in ('\b', 'BackSpace', '\r', 'Linefeed', '\n', 'Return', '\t', 'Tab', 'Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key', stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini', 'all', 'text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane), stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane), si.commandName, stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke), 'mini binding', si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName, event=event, func=si.func, stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
.. @+node:ekr.20170624151245.1976: *9* k.handleUnboundKeys
def handleUnboundKeys(self, event, char, stroke):
    trace = False and not g.unitTesting
    verbose = True
    k = self; c = k.c
    modesTuple = ('insert', 'overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char), repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode', stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key', stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode', repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
    elif(not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char), repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char), repr(stroke))
        return
    elif(
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore', stroke)
        return
    else:
        if trace: g.trace('no func', repr(char), repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
.. @+node:ekr.20170624151245.1977: *9* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20170624151245.1978: *9* k.masterCommand & helpers
def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    '''
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    '''
    c, k = self.c, self
    trace = False and not g.unitTesting and g.app.gui.guiName() == 'curses'
    traceGC = False
    traceStroke = True
    # if trace: g.trace(commandName, func)
    if traceGC: g.printNewObjects('masterCom 1')
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke # Set this global for general use.
    char = ch = event.char if event else ''
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
    # Important: it is *not* an error for func to be None.
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    inserted = not special
    if trace and traceStroke: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke, repr(ch), func and func.__name__))
    if inserted:
        k.setLossage(ch, stroke)
    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    if special: # Don't pass these on.
        return
    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event, stroke)
        if expanded: return
    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for', commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly.
            if trace:
                g.trace('calling command directly', commandName)
            c.doCommand(func, commandName, event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
    elif k.inState():
        pass #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        k.handleDefaultChar(event, stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1981: *9* k.searchTree
def searchTree(self, char):
    '''Search all visible nodes for a headline starting with stroke.'''
    trace = False and not g.unitTesting
    if trace: g.trace(char)
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        '''Return True if p contains char.'''
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.
    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if trace: g.trace(p.h)
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            else:
                p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
.. @+node:ekr.20170624151245.1970: *9* << define vars >>
w = event and event.widget
char = event.char if event else ''
stroke = event.stroke if event else ''
w_name = c.widget_name(w)
if w_name.startswith('log'):
    # A hack: send the event to the text part of the log.
    w = event.widget = c.frame.log.logCtrl
state = k.state.kind
special_keys = (
    'Alt_L', 'Alt_R',
    'Caps_Lock', 'Control_L', 'Control_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
)
self.master_key_count += 1
isPlain = k.isPlainKey(stroke)
.. @+node:ekr.20170624151245.1971: *9* k.callStateFunction
def callStateFunction(self, event):
    trace = False and not g.unitTesting
    k, val = self, None
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    if trace: g.trace(k.state.kind, 'ch', ch, 'stroke', stroke,
        'ignore_unbound_non_ascii_keys', k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns', repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b', '\n', '\r', '\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            # if trace: g.trace(k.state.handler.__name__)
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for', k.state.kind)
    return val
.. @+node:ekr.20170624151245.1972: *9* k.doMode
def doMode(self, event, state, stroke):
    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'):
        if k.handleMiniBindings(event, state, stroke):
            return True
    # Second, honor general modes.
    if state == 'getArg':
        k.getArg(event, stroke=stroke)
        return True
    elif state in ('getFileName', 'get-file-name'):
        if trace: g.trace(event, state, stroke)
        k.getFileName(event)
        return True
    elif state in ('full-command', 'auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function', k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns', repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('calling generalModeHandler', stroke)
            k.generalModeHandler(event,
                commandName=si.commandName, func=si.func,
                modeName=state, nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode', stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler', handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
.. @+node:ekr.20170624151245.1973: *9* k.getPaneBinding
def getPaneBinding(self, stroke, w):
    trace = False and not g.unitTesting
    trace_dict = True
    verbose = True
    k = self; w_name = k.c.widget_name(w)
    state = k.unboundKeyAction
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return None
    if trace: g.trace('===== w_name', repr(w_name), 'stroke', stroke,
        # 'w', w,
        'isTextWrapper(w)', g.isTextWrapper(w))
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'), # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        if trace and trace_dict:
            d = k.masterBindingsDict.get(key, {})
            g.trace('key:', key)
            if d:
                g.trace('d.get(%s)' % (stroke))
                g.trace(d.get(stroke))
            
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command', 'insert', 'overwrite') and state == key or # 2010/02/09
            key in ('text', 'all') and g.isTextWrapper(w) or
            key in ('button', 'all')
        ):
            d = k.masterBindingsDict.get(key, {})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key, name, stroke, stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    table = ('previous-line', 'next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case', si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found: %s = %s' % (
                            key, name, repr(si.stroke), si.commandName))
                        return si
    return None
.. @+node:ekr.20170624151245.1974: *9* k.handleDefaultChar
def handleDefaultChar(self, event, stroke):
    '''Handle an unbound key.'''
    trace = False and not g.unitTesting
    verbose = True
    c, k = self.c, self
    w = event and event.widget
    name = c.widget_name(w)
    if trace and verbose:
        g.trace('widget_name', name, 'stroke', stroke,
        'enable alt-ctrl', self.enable_alt_ctrl_bindings)
    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:', stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
    elif name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring', stroke)
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        log_w = event.widget
        if log_w and hasattr(log_w, 'supportsHighLevelInterface'):
            # Send the event to the text widget, not the LeoLog instance.
            i = log_w.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                log_w.insert(i, s)
        elif trace: g.trace('not supportsHighLevelInterface', log_w)
    else:
        pass # Ignore the event
.. @+node:ekr.20170624151245.1975: *9* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    k = self; c = k.c
    trace = False and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    if state in ('getArg', 'full-command'):
        if stroke in ('\b', 'BackSpace', '\r', 'Linefeed', '\n', 'Return', '\t', 'Tab', 'Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key', stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini', 'all', 'text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane), stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane), si.commandName, stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke), 'mini binding', si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName, event=event, func=si.func, stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
.. @+node:ekr.20170624151245.1976: *9* k.handleUnboundKeys
def handleUnboundKeys(self, event, char, stroke):
    trace = False and not g.unitTesting
    verbose = True
    k = self; c = k.c
    modesTuple = ('insert', 'overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char), repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode', stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key', stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode', repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
    elif(not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char), repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char), repr(stroke))
        return
    elif(
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore', stroke)
        return
    else:
        if trace: g.trace('no func', repr(char), repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
.. @+node:ekr.20170624151245.1977: *9* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20170624151245.1978: *9* k.masterCommand & helpers
def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    '''
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    '''
    c, k = self.c, self
    trace = False and not g.unitTesting and g.app.gui.guiName() == 'curses'
    traceGC = False
    traceStroke = True
    # if trace: g.trace(commandName, func)
    if traceGC: g.printNewObjects('masterCom 1')
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke # Set this global for general use.
    char = ch = event.char if event else ''
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
    # Important: it is *not* an error for func to be None.
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    inserted = not special
    if trace and traceStroke: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke, repr(ch), func and func.__name__))
    if inserted:
        k.setLossage(ch, stroke)
    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    if special: # Don't pass these on.
        return
    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event, stroke)
        if expanded: return
    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for', commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly.
            if trace:
                g.trace('calling command directly', commandName)
            c.doCommand(func, commandName, event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
    elif k.inState():
        pass #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        k.handleDefaultChar(event, stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1981: *9* k.searchTree
def searchTree(self, char):
    '''Search all visible nodes for a headline starting with stroke.'''
    trace = False and not g.unitTesting
    if trace: g.trace(char)
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        '''Return True if p contains char.'''
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.
    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if trace: g.trace(p.h)
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            else:
                p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
.. @+node:ekr.20170624151245.1957: *8* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler(self, event):
    '''The master key handler for almost all key bindings.'''
    trace = False and not g.app.unitTesting
    traceGC = False and not g.app.unitTesting
    verbose = True
    trace_unbound = True
    k, c = self, self.c
    c.check_event(event)
    << define vars >>
    assert g.isStrokeOrNone(stroke)
    if char in special_keys:
        if trace and verbose: g.trace('char', char)
        return
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:', repr(stroke), 'char:',
        repr(event and event.char),
        'ch:', repr(event and event.char),
        'state', state, 'state2', k.unboundKeyAction)
    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if hasattr(c, 'screenCastController') and c.screenCastController:
            c.screenCastController.quit()
        k.masterCommand(commandName='keyboard-quit',
            event=event, func=k.keyboardQuit, stroke=stroke)
        return
    # 2017/01/31: Important support for the demo.py plugin.
    demo = getattr(g.app, 'demo', None)
    if demo:
        # Shortcut everything so that demo-next or demo-prev
        # won't alter of our ivars.
        if k.demoNextKey and stroke == k.demoNextKey:
            if demo.trace: g.trace('demo-next', stroke)
            demo.next_command()
            return
        elif k.demoPrevKey and stroke == k.demoPrevKey:
            if demo.trace: g.trace('demo-prev', stroke)
            demo.prev_command()
            return
    # Always handle modes regardless of vim.
    if k.inState():
        if trace: g.trace('   state %-15s %s' % (state, stroke))
        done = k.doMode(event, state, stroke)
        if done: return
    # Handle vim keys only if not in a state.
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        if trace: g.trace('vc.do_key returns', ok)
        if ok: return
    if traceGC: g.printNewObjects('masterKey 2')
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if w_name.startswith('canvas'):
            # 2016/04/09: experimental.
            if trace: g.trace('plain key in tree')
        elif self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key', stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            k.handleUnboundKeys(event, char, stroke)
            return
    # 2011/02/08: Use getPaneBindings for *all* keys.
    si = k.getPaneBinding(stroke, w)
    if si:
        assert g.isShortcutInfo(si), si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound', stroke, si.func.__name__)
        k.masterCommand(event=event,
            commandName=si.commandName, func=si.func, stroke=si.stroke)
    elif w_name.startswith('canvas'):
        # 2016/04/09: experimental.
        if trace: g.trace('unbound plain key in tree: search')
        k.searchTree(char)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace and trace_unbound: g.trace(' unbound', stroke)
        k.handleUnboundKeys(event, char, stroke)
.. @+node:ekr.20170624151245.1970: *9* << define vars >>
w = event and event.widget
char = event.char if event else ''
stroke = event.stroke if event else ''
w_name = c.widget_name(w)
if w_name.startswith('log'):
    # A hack: send the event to the text part of the log.
    w = event.widget = c.frame.log.logCtrl
state = k.state.kind
special_keys = (
    'Alt_L', 'Alt_R',
    'Caps_Lock', 'Control_L', 'Control_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
)
self.master_key_count += 1
isPlain = k.isPlainKey(stroke)
.. @+node:ekr.20170624151245.1971: *9* k.callStateFunction
def callStateFunction(self, event):
    trace = False and not g.unitTesting
    k, val = self, None
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    if trace: g.trace(k.state.kind, 'ch', ch, 'stroke', stroke,
        'ignore_unbound_non_ascii_keys', k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns', repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b', '\n', '\r', '\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            # if trace: g.trace(k.state.handler.__name__)
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for', k.state.kind)
    return val
.. @+node:ekr.20170624151245.1972: *9* k.doMode
def doMode(self, event, state, stroke):
    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'):
        if k.handleMiniBindings(event, state, stroke):
            return True
    # Second, honor general modes.
    if state == 'getArg':
        k.getArg(event, stroke=stroke)
        return True
    elif state in ('getFileName', 'get-file-name'):
        if trace: g.trace(event, state, stroke)
        k.getFileName(event)
        return True
    elif state in ('full-command', 'auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function', k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns', repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('calling generalModeHandler', stroke)
            k.generalModeHandler(event,
                commandName=si.commandName, func=si.func,
                modeName=state, nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode', stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler', handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
.. @+node:ekr.20170624151245.1973: *9* k.getPaneBinding
def getPaneBinding(self, stroke, w):
    trace = False and not g.unitTesting
    trace_dict = True
    verbose = True
    k = self; w_name = k.c.widget_name(w)
    state = k.unboundKeyAction
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return None
    if trace: g.trace('===== w_name', repr(w_name), 'stroke', stroke,
        # 'w', w,
        'isTextWrapper(w)', g.isTextWrapper(w))
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'), # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        if trace and trace_dict:
            d = k.masterBindingsDict.get(key, {})
            g.trace('key:', key)
            if d:
                g.trace('d.get(%s)' % (stroke))
                g.trace(d.get(stroke))
            
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command', 'insert', 'overwrite') and state == key or # 2010/02/09
            key in ('text', 'all') and g.isTextWrapper(w) or
            key in ('button', 'all')
        ):
            d = k.masterBindingsDict.get(key, {})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key, name, stroke, stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    table = ('previous-line', 'next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case', si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found: %s = %s' % (
                            key, name, repr(si.stroke), si.commandName))
                        return si
    return None
.. @+node:ekr.20170624151245.1974: *9* k.handleDefaultChar
def handleDefaultChar(self, event, stroke):
    '''Handle an unbound key.'''
    trace = False and not g.unitTesting
    verbose = True
    c, k = self.c, self
    w = event and event.widget
    name = c.widget_name(w)
    if trace and verbose:
        g.trace('widget_name', name, 'stroke', stroke,
        'enable alt-ctrl', self.enable_alt_ctrl_bindings)
    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:', stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
    elif name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring', stroke)
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        log_w = event.widget
        if log_w and hasattr(log_w, 'supportsHighLevelInterface'):
            # Send the event to the text widget, not the LeoLog instance.
            i = log_w.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                log_w.insert(i, s)
        elif trace: g.trace('not supportsHighLevelInterface', log_w)
    else:
        pass # Ignore the event
.. @+node:ekr.20170624151245.1975: *9* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    k = self; c = k.c
    trace = False and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    if state in ('getArg', 'full-command'):
        if stroke in ('\b', 'BackSpace', '\r', 'Linefeed', '\n', 'Return', '\t', 'Tab', 'Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key', stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini', 'all', 'text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane), stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane), si.commandName, stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke), 'mini binding', si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName, event=event, func=si.func, stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
.. @+node:ekr.20170624151245.1976: *9* k.handleUnboundKeys
def handleUnboundKeys(self, event, char, stroke):
    trace = False and not g.unitTesting
    verbose = True
    k = self; c = k.c
    modesTuple = ('insert', 'overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char), repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode', stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key', stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode', repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
    elif(not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char), repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char), repr(stroke))
        return
    elif(
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore', stroke)
        return
    else:
        if trace: g.trace('no func', repr(char), repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
.. @+node:ekr.20170624151245.1977: *9* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20170624151245.1978: *9* k.masterCommand & helpers
def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    '''
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    '''
    c, k = self.c, self
    trace = False and not g.unitTesting and g.app.gui.guiName() == 'curses'
    traceGC = False
    traceStroke = True
    # if trace: g.trace(commandName, func)
    if traceGC: g.printNewObjects('masterCom 1')
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke # Set this global for general use.
    char = ch = event.char if event else ''
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
    # Important: it is *not* an error for func to be None.
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    inserted = not special
    if trace and traceStroke: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke, repr(ch), func and func.__name__))
    if inserted:
        k.setLossage(ch, stroke)
    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    if special: # Don't pass these on.
        return
    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event, stroke)
        if expanded: return
    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for', commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly.
            if trace:
                g.trace('calling command directly', commandName)
            c.doCommand(func, commandName, event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
    elif k.inState():
        pass #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        k.handleDefaultChar(event, stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1981: *9* k.searchTree
def searchTree(self, char):
    '''Search all visible nodes for a headline starting with stroke.'''
    trace = False and not g.unitTesting
    if trace: g.trace(char)
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        '''Return True if p contains char.'''
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.
    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if trace: g.trace(p.h)
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            else:
                p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
.. @+node:ekr.20170624151245.1970: *9* << define vars >>
w = event and event.widget
char = event.char if event else ''
stroke = event.stroke if event else ''
w_name = c.widget_name(w)
if w_name.startswith('log'):
    # A hack: send the event to the text part of the log.
    w = event.widget = c.frame.log.logCtrl
state = k.state.kind
special_keys = (
    'Alt_L', 'Alt_R',
    'Caps_Lock', 'Control_L', 'Control_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
)
self.master_key_count += 1
isPlain = k.isPlainKey(stroke)
.. @+node:ekr.20170624151245.1971: *9* k.callStateFunction
def callStateFunction(self, event):
    trace = False and not g.unitTesting
    k, val = self, None
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    if trace: g.trace(k.state.kind, 'ch', ch, 'stroke', stroke,
        'ignore_unbound_non_ascii_keys', k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns', repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b', '\n', '\r', '\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            # if trace: g.trace(k.state.handler.__name__)
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for', k.state.kind)
    return val
.. @+node:ekr.20170624151245.1972: *9* k.doMode
def doMode(self, event, state, stroke):
    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'):
        if k.handleMiniBindings(event, state, stroke):
            return True
    # Second, honor general modes.
    if state == 'getArg':
        k.getArg(event, stroke=stroke)
        return True
    elif state in ('getFileName', 'get-file-name'):
        if trace: g.trace(event, state, stroke)
        k.getFileName(event)
        return True
    elif state in ('full-command', 'auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function', k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns', repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('calling generalModeHandler', stroke)
            k.generalModeHandler(event,
                commandName=si.commandName, func=si.func,
                modeName=state, nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode', stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler', handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
.. @+node:ekr.20170624151245.1973: *9* k.getPaneBinding
def getPaneBinding(self, stroke, w):
    trace = False and not g.unitTesting
    trace_dict = True
    verbose = True
    k = self; w_name = k.c.widget_name(w)
    state = k.unboundKeyAction
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return None
    if trace: g.trace('===== w_name', repr(w_name), 'stroke', stroke,
        # 'w', w,
        'isTextWrapper(w)', g.isTextWrapper(w))
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'), # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        if trace and trace_dict:
            d = k.masterBindingsDict.get(key, {})
            g.trace('key:', key)
            if d:
                g.trace('d.get(%s)' % (stroke))
                g.trace(d.get(stroke))
            
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command', 'insert', 'overwrite') and state == key or # 2010/02/09
            key in ('text', 'all') and g.isTextWrapper(w) or
            key in ('button', 'all')
        ):
            d = k.masterBindingsDict.get(key, {})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key, name, stroke, stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    table = ('previous-line', 'next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case', si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found: %s = %s' % (
                            key, name, repr(si.stroke), si.commandName))
                        return si
    return None
.. @+node:ekr.20170624151245.1974: *9* k.handleDefaultChar
def handleDefaultChar(self, event, stroke):
    '''Handle an unbound key.'''
    trace = False and not g.unitTesting
    verbose = True
    c, k = self.c, self
    w = event and event.widget
    name = c.widget_name(w)
    if trace and verbose:
        g.trace('widget_name', name, 'stroke', stroke,
        'enable alt-ctrl', self.enable_alt_ctrl_bindings)
    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:', stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
    elif name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring', stroke)
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        log_w = event.widget
        if log_w and hasattr(log_w, 'supportsHighLevelInterface'):
            # Send the event to the text widget, not the LeoLog instance.
            i = log_w.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                log_w.insert(i, s)
        elif trace: g.trace('not supportsHighLevelInterface', log_w)
    else:
        pass # Ignore the event
.. @+node:ekr.20170624151245.1975: *9* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    k = self; c = k.c
    trace = False and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    if state in ('getArg', 'full-command'):
        if stroke in ('\b', 'BackSpace', '\r', 'Linefeed', '\n', 'Return', '\t', 'Tab', 'Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key', stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini', 'all', 'text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane), stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane), si.commandName, stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke), 'mini binding', si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName, event=event, func=si.func, stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
.. @+node:ekr.20170624151245.1976: *9* k.handleUnboundKeys
def handleUnboundKeys(self, event, char, stroke):
    trace = False and not g.unitTesting
    verbose = True
    k = self; c = k.c
    modesTuple = ('insert', 'overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char), repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode', stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key', stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode', repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
    elif(not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char), repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char), repr(stroke))
        return
    elif(
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore', stroke)
        return
    else:
        if trace: g.trace('no func', repr(char), repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
.. @+node:ekr.20170624151245.1977: *9* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20170624151245.1978: *9* k.masterCommand & helpers
def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    '''
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    '''
    c, k = self.c, self
    trace = False and not g.unitTesting and g.app.gui.guiName() == 'curses'
    traceGC = False
    traceStroke = True
    # if trace: g.trace(commandName, func)
    if traceGC: g.printNewObjects('masterCom 1')
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke # Set this global for general use.
    char = ch = event.char if event else ''
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
    # Important: it is *not* an error for func to be None.
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    inserted = not special
    if trace and traceStroke: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke, repr(ch), func and func.__name__))
    if inserted:
        k.setLossage(ch, stroke)
    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    if special: # Don't pass these on.
        return
    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event, stroke)
        if expanded: return
    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for', commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly.
            if trace:
                g.trace('calling command directly', commandName)
            c.doCommand(func, commandName, event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
    elif k.inState():
        pass #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        k.handleDefaultChar(event, stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1981: *9* k.searchTree
def searchTree(self, char):
    '''Search all visible nodes for a headline starting with stroke.'''
    trace = False and not g.unitTesting
    if trace: g.trace(char)
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        '''Return True if p contains char.'''
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.
    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if trace: g.trace(p.h)
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            else:
                p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
.. @+node:ekr.20170624151245.1982: *7* k.Minibuffer
# These may be overridden, but this code is now gui-independent.
.. @+node:ekr.20170624151245.1997: *8* k.extendLabel
def extendLabel(self, s, select=False, protect=False):
    trace = False and not g.unitTesting
    k = self; c = k.c; w = self.w
    if not (w and s): return
    if trace: g.trace(s)
    c.widgetWantsFocusNow(w)
    w.insert('end', s)
    if select:
        i, j = k.getEditableTextRange()
        w.setSelectionRange(i, j, insert=j)
    if protect:
        k.protectLabel()
.. @+node:ekr.20170624151245.1998: *8* k.getEditableTextRange
def getEditableTextRange(self):
    k = self; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i, j
.. @+node:ekr.20170624151245.1999: *8* k.getLabel
def getLabel(self, ignorePrompt=False):
    k = self; w = self.w
    if not w: return ''
    s = w.getAllText()
    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
.. @+node:ekr.20170624151245.2000: *8* k.killLine
def killLine(self, protect=True):
    k = self
    w = k.w
    s = w.getAllText()
    s = s[: len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n, n, insert=n)
    if protect:
        k.mb_prefix = s
.. @+node:ekr.20170624151245.2001: *8* k.minibufferWantsFocus
# def minibufferWantsFocus(self):
    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
.. @+node:ekr.20170624151245.2002: *8* k.protectLabel
def protectLabel(self):
    k = self; w = self.w
    if not w: return
    k.mb_prefix = w.getAllText()
.. @+node:ekr.20170624151245.2003: *8* k.resetLabel
def resetLabel(self):
    '''Reset the minibuffer label.'''
    k = self
    c, w = k.c, k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:
        w.setSelectionRange(0, 0, insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label='%s State' % (state.capitalize()))
.. @+node:ekr.20170624151245.2004: *8* k.selectAll
def selectAll(self):
    '''Select all the user-editable text of the minibuffer.'''
    w = self.w
    i, j = self.getEditableTextRange()
    w.setSelectionRange(i, j, insert=j)
.. @+node:ekr.20170624151245.2005: *8* k.setLabel
def setLabel(self, s, protect=False):
    '''Set the label of the minibuffer.'''
    trace = False and not g.app.unitTesting
    k, w = self, self.w
    if w:
        if trace: g.trace(repr(s), g.callers())
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n, n, insert=n)
        if protect:
            k.mb_prefix = s
    elif trace:
        g.trace('*** no w ***')
.. @+node:ekr.20170624151245.2006: *8* k.setLabelBlue
def setLabelBlue(self, label, protect=True):
    '''Set the minibuffer label.'''
    trace = False and not g.unitTesting
    k = self; w = k.w
    if trace: g.trace('label:', label, g.callers())
    if w:
        w.setStyleClass('') # normal state, not warning or error
        if label is not None:
            k.setLabel(label, protect=protect)
    elif trace:
        g.trace('*** no w ***')
.. @+node:ekr.20170624151245.2007: *8* k.setLabelGrey
def setLabelGrey(self, label=None):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_warning')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
.. @+node:ekr.20170624151245.2008: *8* k.setLabelRed
def setLabelRed(self, label=None, protect=False):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_error')
    if label is not None:
        k.setLabel(label, protect)
.. @+node:ekr.20170624151245.2009: *8* k.setStatusLabel
def setStatusLabel(self, s):
    '''
    Set the label to s.

    Use k.setStatusLabel, not k.setLael, to report the status of a Leo
    command. This allows the option to use g.es instead of the minibuffer
    to report status.
    '''
    k = self
    k.setLabel(s, protect=False)
.. @+node:ekr.20170624151245.2010: *8* k.updateLabel
def updateLabel(self, event):
    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumulation.'''
    trace = False or g.trace_minibuffer and not g.app.unitTesting
    k = self; c = k.c; w = self.w
    ch = event.char if event else ''
    if trace: g.trace('ch', ch, 'k.stroke', k.stroke)
    if ch and ch not in ('\n', '\r'):
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i, j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i - 1)
                i -= 1
        else:
            w.insert(ins, ch)
            i = ins + 1
.. @+node:ekr.20170624151245.1997: *8* k.extendLabel
def extendLabel(self, s, select=False, protect=False):
    trace = False and not g.unitTesting
    k = self; c = k.c; w = self.w
    if not (w and s): return
    if trace: g.trace(s)
    c.widgetWantsFocusNow(w)
    w.insert('end', s)
    if select:
        i, j = k.getEditableTextRange()
        w.setSelectionRange(i, j, insert=j)
    if protect:
        k.protectLabel()
.. @+node:ekr.20170624151245.1998: *8* k.getEditableTextRange
def getEditableTextRange(self):
    k = self; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i, j
.. @+node:ekr.20170624151245.1999: *8* k.getLabel
def getLabel(self, ignorePrompt=False):
    k = self; w = self.w
    if not w: return ''
    s = w.getAllText()
    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
.. @+node:ekr.20170624151245.2000: *8* k.killLine
def killLine(self, protect=True):
    k = self
    w = k.w
    s = w.getAllText()
    s = s[: len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n, n, insert=n)
    if protect:
        k.mb_prefix = s
.. @+node:ekr.20170624151245.2001: *8* k.minibufferWantsFocus
# def minibufferWantsFocus(self):
    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
.. @+node:ekr.20170624151245.2002: *8* k.protectLabel
def protectLabel(self):
    k = self; w = self.w
    if not w: return
    k.mb_prefix = w.getAllText()
.. @+node:ekr.20170624151245.2003: *8* k.resetLabel
def resetLabel(self):
    '''Reset the minibuffer label.'''
    k = self
    c, w = k.c, k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:
        w.setSelectionRange(0, 0, insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label='%s State' % (state.capitalize()))
.. @+node:ekr.20170624151245.2004: *8* k.selectAll
def selectAll(self):
    '''Select all the user-editable text of the minibuffer.'''
    w = self.w
    i, j = self.getEditableTextRange()
    w.setSelectionRange(i, j, insert=j)
.. @+node:ekr.20170624151245.2005: *8* k.setLabel
def setLabel(self, s, protect=False):
    '''Set the label of the minibuffer.'''
    trace = False and not g.app.unitTesting
    k, w = self, self.w
    if w:
        if trace: g.trace(repr(s), g.callers())
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n, n, insert=n)
        if protect:
            k.mb_prefix = s
    elif trace:
        g.trace('*** no w ***')
.. @+node:ekr.20170624151245.2006: *8* k.setLabelBlue
def setLabelBlue(self, label, protect=True):
    '''Set the minibuffer label.'''
    trace = False and not g.unitTesting
    k = self; w = k.w
    if trace: g.trace('label:', label, g.callers())
    if w:
        w.setStyleClass('') # normal state, not warning or error
        if label is not None:
            k.setLabel(label, protect=protect)
    elif trace:
        g.trace('*** no w ***')
.. @+node:ekr.20170624151245.2007: *8* k.setLabelGrey
def setLabelGrey(self, label=None):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_warning')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
.. @+node:ekr.20170624151245.2008: *8* k.setLabelRed
def setLabelRed(self, label=None, protect=False):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_error')
    if label is not None:
        k.setLabel(label, protect)
.. @+node:ekr.20170624151245.2009: *8* k.setStatusLabel
def setStatusLabel(self, s):
    '''
    Set the label to s.

    Use k.setStatusLabel, not k.setLael, to report the status of a Leo
    command. This allows the option to use g.es instead of the minibuffer
    to report status.
    '''
    k = self
    k.setLabel(s, protect=False)
.. @+node:ekr.20170624151245.2010: *8* k.updateLabel
def updateLabel(self, event):
    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumulation.'''
    trace = False or g.trace_minibuffer and not g.app.unitTesting
    k = self; c = k.c; w = self.w
    ch = event.char if event else ''
    if trace: g.trace('ch', ch, 'k.stroke', k.stroke)
    if ch and ch not in ('\n', '\r'):
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i, j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i - 1)
                i -= 1
        else:
            w.insert(ins, ch)
            i = ins + 1
.. @+node:ekr.20170624151245.2011: *7* k.Modes (no change)
.. @+node:ekr.20170624151245.2023: *8* k.addModeCommands (enterModeCallback)
def addModeCommands(self):
    '''Add commands created by @mode settings to c.commandsDict.'''
    trace = False and not g.unitTesting
    if trace: g.trace('(k)')
    k = self; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop

        def enterModeCallback(event=None, name=key):
            k.enterNamedMode(event, name)

        c.commandsDict[key] = f = enterModeCallback
        if trace: g.trace(f.__name__, key,
            'len(c.commandsDict.keys())', len(list(c.commandsDict.keys())))
.. @+node:ekr.20170624151245.2024: *8* k.badMode
def badMode(self, modeName):
    k = self
    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[: -5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
.. @+node:ekr.20170624151245.2025: *8* k.createModeBindings
def createModeBindings(self, modeName, d, w):
    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''
    trace = False and not g.unitTesting
    k = self; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*', '*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:', commandName, 'Referenced from', modeName)
            continue
        aList = d.get(commandName, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.ShortcutInfo(
                    kind='mode<%s>' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
.. @+node:ekr.20170624151245.2026: *8* k.endMode
def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane
    k.endCommand(k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
.. @+node:ekr.20170624151245.2027: *8* k.enterNamedMode
def enterNamedMode(self, event, commandName):
    k = self; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event, modeName=modeName)
.. @+node:ekr.20170624151245.2028: *8* k.exitNamedMode
@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    '''Exit an input mode.'''
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
.. @+node:ekr.20170624151245.2029: *8* k.modeHelp & helper (revise helper)
@cmd('mode-help')
def modeHelp(self, event):
    '''The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''
    k = self; c = k.c
    c.endEditing()
    # g.trace(k.inputModeName)
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
.. @+node:ekr.20170624151245.2031: *9* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si), si
                stroke = si.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[: -4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', '%s\n\n' % (prompt.kind.strip()), tabName=tabName)
    else:
        g.es('', '%s mode\n\n' % modeName, tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
.. @+node:ekr.20170624151245.2031: *9* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si), si
                stroke = si.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[: -4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', '%s\n\n' % (prompt.kind.strip()), tabName=tabName)
    else:
        g.es('', '%s mode\n\n' % modeName, tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
.. @+node:ekr.20170624151245.2032: *8* k.reinitMode (call k.createModeBindings???)
def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ') # ,protect=True)
.. @+node:ekr.20170624151245.2033: *8* k.generalModeHandler (OLD)
def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''
    k = self; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting
    if trace: g.trace(modeName, 'state', state)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, None, None, k.modeWidget)
            if trace: g.trace(modeName, 'state', state, commandName, 'nextMode', nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode) # Enter another mode.
.. @+node:ekr.20170624151245.2023: *8* k.addModeCommands (enterModeCallback)
def addModeCommands(self):
    '''Add commands created by @mode settings to c.commandsDict.'''
    trace = False and not g.unitTesting
    if trace: g.trace('(k)')
    k = self; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop

        def enterModeCallback(event=None, name=key):
            k.enterNamedMode(event, name)

        c.commandsDict[key] = f = enterModeCallback
        if trace: g.trace(f.__name__, key,
            'len(c.commandsDict.keys())', len(list(c.commandsDict.keys())))
.. @+node:ekr.20170624151245.2024: *8* k.badMode
def badMode(self, modeName):
    k = self
    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[: -5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
.. @+node:ekr.20170624151245.2025: *8* k.createModeBindings
def createModeBindings(self, modeName, d, w):
    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''
    trace = False and not g.unitTesting
    k = self; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*', '*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:', commandName, 'Referenced from', modeName)
            continue
        aList = d.get(commandName, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.ShortcutInfo(
                    kind='mode<%s>' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
.. @+node:ekr.20170624151245.2026: *8* k.endMode
def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane
    k.endCommand(k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
.. @+node:ekr.20170624151245.2027: *8* k.enterNamedMode
def enterNamedMode(self, event, commandName):
    k = self; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event, modeName=modeName)
.. @+node:ekr.20170624151245.2028: *8* k.exitNamedMode
@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    '''Exit an input mode.'''
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
.. @+node:ekr.20170624151245.2029: *8* k.modeHelp & helper (revise helper)
@cmd('mode-help')
def modeHelp(self, event):
    '''The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''
    k = self; c = k.c
    c.endEditing()
    # g.trace(k.inputModeName)
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
.. @+node:ekr.20170624151245.2031: *9* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si), si
                stroke = si.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[: -4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', '%s\n\n' % (prompt.kind.strip()), tabName=tabName)
    else:
        g.es('', '%s mode\n\n' % modeName, tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
.. @+node:ekr.20170624151245.2031: *9* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si), si
                stroke = si.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[: -4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', '%s\n\n' % (prompt.kind.strip()), tabName=tabName)
    else:
        g.es('', '%s mode\n\n' % modeName, tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
.. @+node:ekr.20170624151245.2032: *8* k.reinitMode (call k.createModeBindings???)
def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ') # ,protect=True)
.. @+node:ekr.20170624151245.2033: *8* k.generalModeHandler (OLD)
def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''
    k = self; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting
    if trace: g.trace(modeName, 'state', state)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, None, None, k.modeWidget)
            if trace: g.trace(modeName, 'state', state, commandName, 'nextMode', nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode) # Enter another mode.
.. @+node:ekr.20170624151245.2034: *7* k.Modes (changed)
.. @+node:ekr.20170624151245.2037: *8* k.initMode (changed)
def initMode(self, event, modeName):
    k = self; c = k.c
    trace = (False or g.trace_modes) and not g.unitTesting
    if not modeName:
        g.trace('oops: no modeName')
        return
    d = g.app.config.modeCommandsDict.get('enter-' + modeName)
    if not d:
        self.badMode(modeName)
        return
    else:
        k.modeBindingsDict = d
        si = d.get('*command-prompt*')
        if si:
            prompt = si.kind # A kludge.
        else:
            prompt = modeName
        if trace: g.trace('modeName: %s prompt: %s d.keys(): %s' % (
            modeName, prompt, sorted(list(d.keys()))))
    k.inputModeName = modeName
    k.silentMode = False
    aList = d.get('*entry-commands*', [])
    if aList:
        for si in aList:
            assert g.isShortcutInfo(si), si
            commandName = si.commandName
            if trace: g.trace('entry command:', commandName)
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                if trace: g.trace('redirect to mode', commandName)
                return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    k.showStateAndMode(prompt=prompt)
.. @+node:ekr.20170624151245.2038: *8* k.NEWgeneralModeHandler (NEW MODES)
def NEWgeneralModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''
    k = self; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting
    if trace: g.trace(modeName, 'state', state)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, None, None, k.modeWidget)
            if trace: g.trace(modeName, 'state', state, commandName, 'nextMode', nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                # if g.app.quitting or not c.exists: return
.. @+node:ekr.20170624151245.2037: *8* k.initMode (changed)
def initMode(self, event, modeName):
    k = self; c = k.c
    trace = (False or g.trace_modes) and not g.unitTesting
    if not modeName:
        g.trace('oops: no modeName')
        return
    d = g.app.config.modeCommandsDict.get('enter-' + modeName)
    if not d:
        self.badMode(modeName)
        return
    else:
        k.modeBindingsDict = d
        si = d.get('*command-prompt*')
        if si:
            prompt = si.kind # A kludge.
        else:
            prompt = modeName
        if trace: g.trace('modeName: %s prompt: %s d.keys(): %s' % (
            modeName, prompt, sorted(list(d.keys()))))
    k.inputModeName = modeName
    k.silentMode = False
    aList = d.get('*entry-commands*', [])
    if aList:
        for si in aList:
            assert g.isShortcutInfo(si), si
            commandName = si.commandName
            if trace: g.trace('entry command:', commandName)
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                if trace: g.trace('redirect to mode', commandName)
                return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    k.showStateAndMode(prompt=prompt)
.. @+node:ekr.20170624151245.2038: *8* k.NEWgeneralModeHandler (NEW MODES)
def NEWgeneralModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''
    k = self; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting
    if trace: g.trace(modeName, 'state', state)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, None, None, k.modeWidget)
            if trace: g.trace(modeName, 'state', state, commandName, 'nextMode', nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                # if g.app.quitting or not c.exists: return
.. @+node:ekr.20170624151245.2039: *7* k.Shortcuts & bindings
.. @+node:ekr.20170624151245.2059: *8* k.computeInverseBindingDict
def computeInverseBindingDict(self):
    k = self
    d = {}
        # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        aList = k.bindingsDict.get(stroke, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            shortcutList = k.bindingsDict.get(si.commandName, [])
                # Bug fix: 2017/03/26.
            aList = k.bindingsDict.get(stroke, g.ShortcutInfo(kind='dummy', pane='all'))
                # Important: only si.pane is required below.
            for si in aList:
                assert g.isShortcutInfo(si), si
                pane = '%s:' % (si.pane)
                data = (pane, stroke)
                if data not in shortcutList:
                    shortcutList.append(data)
            d[si.commandName] = shortcutList
    return d
.. @+node:ekr.20170624151245.2060: *8* k.getShortcutForCommand/Name
def getShortcutForCommandName(self, commandName):
    k = self; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke), repr(stroke)
            aList = k.bindingsDict.get(stroke, [])
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.commandName == commandName:
                    return stroke
    return None

def getShortcutForCommand(self, command):
    k = self
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke), repr(stroke)
            aList = k.bindingsDict.get(stroke, [])
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.commandName == command.__name__:
                    return stroke
    return None
.. @+node:ekr.20170624151245.2061: *8* k.isFKey
def isFKey(self, stroke):
    # k = self
    if not stroke: return False
    assert g.isString(stroke) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
.. @+node:ekr.20170624151245.2062: *8* k.isPlainKey
def isPlainKey(self, stroke):
    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''
    trace = False and not g.unitTesting
    k = self
    if not stroke:
        return False
    assert g.isString(stroke) or g.isStroke(stroke)
    shortcut = stroke.s if g.isStroke(stroke) else stroke
    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True
    for z in ('Alt', 'Ctrl', 'Command', 'Meta'):
        if shortcut.find(z) != -1:
            return False
    # Careful, allow bare angle brackets for unit tests.
    if shortcut.startswith('<') and shortcut.endswith('>'):
        shortcut = shortcut[1: -1]
    isPlain = (
        len(shortcut) == 1 or
        len(k.guiBindNamesInverseDict.get(shortcut, '')) == 1 or
        # A hack: allow Return to be bound to command.
        shortcut in ('Tab', '\t')
    )
    if trace: g.trace(isPlain,repr(shortcut))
    return isPlain and not self.isFKey(shortcut)
.. @+node:ekr.20170624151245.2063: *8* k.prettyPrintKey
def prettyPrintKey(self, stroke, brief=False):
    trace = False and not g.unitTesting
    k = self
    if not stroke:
        s = ''
    elif g.isStroke(stroke):
        s = stroke.s
    else:
        s = stroke
    if not s: return ''
    shift = s.find("shift") >= 0 or s.find("shft") >= 0
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[: -1].replace('-', '+') + '-'
    else: s = s.replace('-', '+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields', fields)
    if last and len(last) == 1:
        prev = s[: -1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last, last)
        if fields and fields[: -1]:
            s = '%s+%s' % ('+'.join(fields[: -1]), last)
        else:
            s = last
    if s.endswith(' '):
        s = s[: -1] + 'Space' # 2010/11/06
    return s
.. @+node:ekr.20170624151245.2064: *8* k.setLossage
def setLossage(self, ch, stroke):
    trace = False and not g.unitTesting
    # k = self
    if trace: g.trace(repr(stroke), g.callers())
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
.. @+node:ekr.20170624151245.2065: *8* k.stroke2char
def stroke2char(self, stroke):
    '''
    Convert a stroke to an (insertable) char.
    This method allows Leo to use strokes everywhere.
    '''
    # pylint: disable=len-as-condition
    trace = False and not g.unitTesting
    trace = trace and stroke.lower().find('1') > -1
    k = self
    if not stroke: return ''
    s = stroke.s if g.isStroke(stroke) else stroke
    # Allow bare angle brackets for unit tests.
    if s.startswith('<') and s.endswith('>'):
        s = s[1: -1]
    if len(s) == 0: return ''
    if len(s) == 1: return s
    for z in ('Alt', 'Ctrl', 'Command', 'Meta'):
        if s.find(z) != -1:
            return ''
            # This is not accurate: LeoQtEventFilter retains
            # the spelling of Alt-Ctrl keys because of the
            # @bool enable_alt_ctrl_bindings setting.
    # Special case the gang of four, plus 'Escape', 'PageDn', 'PageUp',
    d = {
        'BackSpace': '\b',
        'Escape': 'Escape',
        'Linefeed': '\r',
        'PageDn': 'Next', # Fix #416.
        'PageUp': 'Prior', # Fix #416.
        'Return': '\n',
        'Tab': '\t',
    }
    ch = d.get(s)
    if ch: return ch
    # First, do the common translations.
    ch = k.guiBindNamesInverseDict.get(s)
    if ch:
        if trace: g.trace(repr(stroke), repr(ch))
        return ch
    # A much-simplified form of code in k.strokeFromSetting.
    shift = s.find('Shift+') > -1 or s.find('Shift-') > -1
    s = s.replace('Shift+', '').replace('Shift-', '')
    last = s #  Everything should have been stripped.
    if len(s) == 1 and s.isalpha():
        if shift:
            s = last.upper()
        else:
            s = last.lower()
    val = s if len(s) == 1 else ''
    if trace: g.trace(repr(stroke), repr(val)) # 'shift',shift,
    return val
.. @+node:ekr.20170624151245.2066: *8* k.strokeFromSetting (changed in Leo 5.3)
def strokeFromSetting(self, setting):
    k = self
    trace = False and not g.unitTesting
    trace = trace and setting.lower().find('1') > -1
    verbose = False
    if not setting:
        return None
    assert g.isString(setting)
    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    if trace and verbose:
        g.trace('%20s %s' % (setting, shortcut), g.callers())
    return g.KeyStroke(shortcut) if shortcut else None

canonicalizeShortcut = strokeFromSetting # For compatibility.
.. @+node:ekr.20170624151245.2072: *9* << define cmd, ctrl, alt, shift >>
s2 = s.lower()
cmd = s2.find("cmd") >= 0 or s2.find("command") >= 0
ctrl = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt = s2.find("alt") >= 0
shift = s2.find("shift") >= 0 or s2.find("shft") >= 0
meta = s2.find("meta") >= 0
.. @+node:ekr.20170624151245.2073: *9* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True; ctrl = False
if alt and not ctrl:
    ctrl = True; alt = False
.. @+node:ekr.20170624151245.2074: *9* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[: -1].replace('-', '+') + '-'
else:
    s = s.replace('-', '+')
.. @+node:ekr.20170624151245.2075: *9* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s), repr(setting))
            g.trace(g.callers())
        return None
if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        # New in Leo 5.3: 2016/04/12: a major bug fix, with new unit test.
        if (cmd or ctrl or alt or shift) and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(), last)
.. @+node:ekr.20170624151245.2076: *9* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl, 'Ctrl+'),
    (cmd, 'Command+'),
    (meta, 'Meta+'),
    (shift, 'Shift+'),
    (True, last),
)
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag, val in table if flag])
.. @+node:ekr.20170624151245.2072: *9* << define cmd, ctrl, alt, shift >>
s2 = s.lower()
cmd = s2.find("cmd") >= 0 or s2.find("command") >= 0
ctrl = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt = s2.find("alt") >= 0
shift = s2.find("shift") >= 0 or s2.find("shft") >= 0
meta = s2.find("meta") >= 0
.. @+node:ekr.20170624151245.2073: *9* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True; ctrl = False
if alt and not ctrl:
    ctrl = True; alt = False
.. @+node:ekr.20170624151245.2074: *9* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[: -1].replace('-', '+') + '-'
else:
    s = s.replace('-', '+')
.. @+node:ekr.20170624151245.2075: *9* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s), repr(setting))
            g.trace(g.callers())
        return None
if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        # New in Leo 5.3: 2016/04/12: a major bug fix, with new unit test.
        if (cmd or ctrl or alt or shift) and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(), last)
.. @+node:ekr.20170624151245.2076: *9* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl, 'Ctrl+'),
    (cmd, 'Command+'),
    (meta, 'Meta+'),
    (shift, 'Shift+'),
    (True, last),
)
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag, val in table if flag])
.. @+node:ekr.20170624151245.2077: *8* k.traceBinding (not used)
def traceBinding(self, si, shortcut, w):
    k = self; c = k.c; gui = g.app.gui
    if not c.config.getBool('trace_bindings'): return
    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return
    pane_filter = c.config.getString('trace_bindings_pane_filter')
    if not pane_filter or pane_filter.lower() == si.pane:
        g.trace(si.pane, shortcut, si.commandName, gui.widget_name(w))
.. @+node:ekr.20170624151245.2059: *8* k.computeInverseBindingDict
def computeInverseBindingDict(self):
    k = self
    d = {}
        # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        aList = k.bindingsDict.get(stroke, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            shortcutList = k.bindingsDict.get(si.commandName, [])
                # Bug fix: 2017/03/26.
            aList = k.bindingsDict.get(stroke, g.ShortcutInfo(kind='dummy', pane='all'))
                # Important: only si.pane is required below.
            for si in aList:
                assert g.isShortcutInfo(si), si
                pane = '%s:' % (si.pane)
                data = (pane, stroke)
                if data not in shortcutList:
                    shortcutList.append(data)
            d[si.commandName] = shortcutList
    return d
.. @+node:ekr.20170624151245.2060: *8* k.getShortcutForCommand/Name
def getShortcutForCommandName(self, commandName):
    k = self; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke), repr(stroke)
            aList = k.bindingsDict.get(stroke, [])
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.commandName == commandName:
                    return stroke
    return None

def getShortcutForCommand(self, command):
    k = self
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke), repr(stroke)
            aList = k.bindingsDict.get(stroke, [])
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.commandName == command.__name__:
                    return stroke
    return None
.. @+node:ekr.20170624151245.2061: *8* k.isFKey
def isFKey(self, stroke):
    # k = self
    if not stroke: return False
    assert g.isString(stroke) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
.. @+node:ekr.20170624151245.2062: *8* k.isPlainKey
def isPlainKey(self, stroke):
    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''
    trace = False and not g.unitTesting
    k = self
    if not stroke:
        return False
    assert g.isString(stroke) or g.isStroke(stroke)
    shortcut = stroke.s if g.isStroke(stroke) else stroke
    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True
    for z in ('Alt', 'Ctrl', 'Command', 'Meta'):
        if shortcut.find(z) != -1:
            return False
    # Careful, allow bare angle brackets for unit tests.
    if shortcut.startswith('<') and shortcut.endswith('>'):
        shortcut = shortcut[1: -1]
    isPlain = (
        len(shortcut) == 1 or
        len(k.guiBindNamesInverseDict.get(shortcut, '')) == 1 or
        # A hack: allow Return to be bound to command.
        shortcut in ('Tab', '\t')
    )
    if trace: g.trace(isPlain,repr(shortcut))
    return isPlain and not self.isFKey(shortcut)
.. @+node:ekr.20170624151245.2063: *8* k.prettyPrintKey
def prettyPrintKey(self, stroke, brief=False):
    trace = False and not g.unitTesting
    k = self
    if not stroke:
        s = ''
    elif g.isStroke(stroke):
        s = stroke.s
    else:
        s = stroke
    if not s: return ''
    shift = s.find("shift") >= 0 or s.find("shft") >= 0
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[: -1].replace('-', '+') + '-'
    else: s = s.replace('-', '+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields', fields)
    if last and len(last) == 1:
        prev = s[: -1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last, last)
        if fields and fields[: -1]:
            s = '%s+%s' % ('+'.join(fields[: -1]), last)
        else:
            s = last
    if s.endswith(' '):
        s = s[: -1] + 'Space' # 2010/11/06
    return s
.. @+node:ekr.20170624151245.2064: *8* k.setLossage
def setLossage(self, ch, stroke):
    trace = False and not g.unitTesting
    # k = self
    if trace: g.trace(repr(stroke), g.callers())
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
.. @+node:ekr.20170624151245.2065: *8* k.stroke2char
def stroke2char(self, stroke):
    '''
    Convert a stroke to an (insertable) char.
    This method allows Leo to use strokes everywhere.
    '''
    # pylint: disable=len-as-condition
    trace = False and not g.unitTesting
    trace = trace and stroke.lower().find('1') > -1
    k = self
    if not stroke: return ''
    s = stroke.s if g.isStroke(stroke) else stroke
    # Allow bare angle brackets for unit tests.
    if s.startswith('<') and s.endswith('>'):
        s = s[1: -1]
    if len(s) == 0: return ''
    if len(s) == 1: return s
    for z in ('Alt', 'Ctrl', 'Command', 'Meta'):
        if s.find(z) != -1:
            return ''
            # This is not accurate: LeoQtEventFilter retains
            # the spelling of Alt-Ctrl keys because of the
            # @bool enable_alt_ctrl_bindings setting.
    # Special case the gang of four, plus 'Escape', 'PageDn', 'PageUp',
    d = {
        'BackSpace': '\b',
        'Escape': 'Escape',
        'Linefeed': '\r',
        'PageDn': 'Next', # Fix #416.
        'PageUp': 'Prior', # Fix #416.
        'Return': '\n',
        'Tab': '\t',
    }
    ch = d.get(s)
    if ch: return ch
    # First, do the common translations.
    ch = k.guiBindNamesInverseDict.get(s)
    if ch:
        if trace: g.trace(repr(stroke), repr(ch))
        return ch
    # A much-simplified form of code in k.strokeFromSetting.
    shift = s.find('Shift+') > -1 or s.find('Shift-') > -1
    s = s.replace('Shift+', '').replace('Shift-', '')
    last = s #  Everything should have been stripped.
    if len(s) == 1 and s.isalpha():
        if shift:
            s = last.upper()
        else:
            s = last.lower()
    val = s if len(s) == 1 else ''
    if trace: g.trace(repr(stroke), repr(val)) # 'shift',shift,
    return val
.. @+node:ekr.20170624151245.2066: *8* k.strokeFromSetting (changed in Leo 5.3)
def strokeFromSetting(self, setting):
    k = self
    trace = False and not g.unitTesting
    trace = trace and setting.lower().find('1') > -1
    verbose = False
    if not setting:
        return None
    assert g.isString(setting)
    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    if trace and verbose:
        g.trace('%20s %s' % (setting, shortcut), g.callers())
    return g.KeyStroke(shortcut) if shortcut else None

canonicalizeShortcut = strokeFromSetting # For compatibility.
.. @+node:ekr.20170624151245.2072: *9* << define cmd, ctrl, alt, shift >>
s2 = s.lower()
cmd = s2.find("cmd") >= 0 or s2.find("command") >= 0
ctrl = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt = s2.find("alt") >= 0
shift = s2.find("shift") >= 0 or s2.find("shft") >= 0
meta = s2.find("meta") >= 0
.. @+node:ekr.20170624151245.2073: *9* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True; ctrl = False
if alt and not ctrl:
    ctrl = True; alt = False
.. @+node:ekr.20170624151245.2074: *9* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[: -1].replace('-', '+') + '-'
else:
    s = s.replace('-', '+')
.. @+node:ekr.20170624151245.2075: *9* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s), repr(setting))
            g.trace(g.callers())
        return None
if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        # New in Leo 5.3: 2016/04/12: a major bug fix, with new unit test.
        if (cmd or ctrl or alt or shift) and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(), last)
.. @+node:ekr.20170624151245.2076: *9* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl, 'Ctrl+'),
    (cmd, 'Command+'),
    (meta, 'Meta+'),
    (shift, 'Shift+'),
    (True, last),
)
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag, val in table if flag])
.. @+node:ekr.20170624151245.2072: *9* << define cmd, ctrl, alt, shift >>
s2 = s.lower()
cmd = s2.find("cmd") >= 0 or s2.find("command") >= 0
ctrl = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt = s2.find("alt") >= 0
shift = s2.find("shift") >= 0 or s2.find("shft") >= 0
meta = s2.find("meta") >= 0
.. @+node:ekr.20170624151245.2073: *9* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True; ctrl = False
if alt and not ctrl:
    ctrl = True; alt = False
.. @+node:ekr.20170624151245.2074: *9* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[: -1].replace('-', '+') + '-'
else:
    s = s.replace('-', '+')
.. @+node:ekr.20170624151245.2075: *9* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s), repr(setting))
            g.trace(g.callers())
        return None
if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        # New in Leo 5.3: 2016/04/12: a major bug fix, with new unit test.
        if (cmd or ctrl or alt or shift) and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(), last)
.. @+node:ekr.20170624151245.2076: *9* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl, 'Ctrl+'),
    (cmd, 'Command+'),
    (meta, 'Meta+'),
    (shift, 'Shift+'),
    (True, last),
)
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag, val in table if flag])
.. @+node:ekr.20170624151245.2077: *8* k.traceBinding (not used)
def traceBinding(self, si, shortcut, w):
    k = self; c = k.c; gui = g.app.gui
    if not c.config.getBool('trace_bindings'): return
    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return
    pane_filter = c.config.getString('trace_bindings_pane_filter')
    if not pane_filter or pane_filter.lower() == si.pane:
        g.trace(si.pane, shortcut, si.commandName, gui.widget_name(w))
.. @+node:ekr.20170624151245.2078: *7* k.States
.. @+node:ekr.20170624151245.2090: *8* k.clearState
def clearState(self):
    '''Clear the key handler state.'''
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
.. @+node:ekr.20170624151245.2091: *8* k.getState
def getState(self, kind):
    k = self
    val = k.state.n if k.state.kind == kind else 0
    # g.trace(state,'returns',val)
    return val
.. @+node:ekr.20170624151245.2092: *8* k.getStateHandler
def getStateHandler(self):
    return self.state.handler
.. @+node:ekr.20170624151245.2093: *8* k.getStateKind
def getStateKind(self):
    return self.state.kind
.. @+node:ekr.20170624151245.2094: *8* k.inState
def inState(self, kind=None):
    k = self
    if kind:
        return k.state.kind == kind and k.state.n is not None
    else:
        return k.state.kind and k.state.n is not None
.. @+node:ekr.20170624151245.2095: *8* k.setDefaultInputState
def setDefaultInputState(self):
    k = self; state = k.defaultUnboundKeyAction
    # g.trace(state)
    k.setInputState(state)
.. @+node:ekr.20170624151245.2096: *8* k.setEditingState
def setEditingState(self):
    k = self; state = k.defaultEditingAction
    # g.trace(state)
    k.setInputState(state)
.. @+node:ekr.20170624151245.2097: *8* k.setInputState
def setInputState(self, state, set_border=False):
    k = self
    k.unboundKeyAction = state
.. @+node:ekr.20170624151245.2098: *8* k.setState
def setState(self, kind, n, handler=None):
    trace = False and not g.unitTesting
    k = self
    if kind and n is not None:
        if trace: g.trace('**** setting %s %s %s' % (
            kind, n, handler and handler.__name__), g.callers())
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        if trace: g.trace('clearing')
        k.clearState()
    # k.showStateAndMode()
.. @+node:ekr.20170624151245.2099: *8* k.showStateAndMode
def showStateAndMode(self, w=None, prompt=None, setFocus=True):
    '''Show the state and mode at the start of the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    state = k.unboundKeyAction
    mode = k.getStateKind()
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
    isText = g.isTextWrapper(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree, 'getWrapper'):
            if hasattr(w, 'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2, item=None)
            isText = bool(w) # A benign hack.
    if trace: g.trace('state: %s, text?: %s, w: %s' % (state, isText, w))
    if mode:
        if mode in ('getArg', 'getFileName', 'full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[: -5]
            s = '%s Mode' % mode.capitalize()
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    if trace: g.trace(repr(s))
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state, w)
    # 2015/07/11: reset the status line.
    if hasattr(c.frame.tree, 'set_status_line'):
        c.frame.tree.set_status_line(c.p)
.. @+node:ekr.20170624151245.2100: *8* k.showStateCursor
def showStateCursor(self, state, w):
    # g.trace(state,w)
    pass
.. @+node:ekr.20170624151245.2090: *8* k.clearState
def clearState(self):
    '''Clear the key handler state.'''
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
.. @+node:ekr.20170624151245.2091: *8* k.getState
def getState(self, kind):
    k = self
    val = k.state.n if k.state.kind == kind else 0
    # g.trace(state,'returns',val)
    return val
.. @+node:ekr.20170624151245.2092: *8* k.getStateHandler
def getStateHandler(self):
    return self.state.handler
.. @+node:ekr.20170624151245.2093: *8* k.getStateKind
def getStateKind(self):
    return self.state.kind
.. @+node:ekr.20170624151245.2094: *8* k.inState
def inState(self, kind=None):
    k = self
    if kind:
        return k.state.kind == kind and k.state.n is not None
    else:
        return k.state.kind and k.state.n is not None
.. @+node:ekr.20170624151245.2095: *8* k.setDefaultInputState
def setDefaultInputState(self):
    k = self; state = k.defaultUnboundKeyAction
    # g.trace(state)
    k.setInputState(state)
.. @+node:ekr.20170624151245.2096: *8* k.setEditingState
def setEditingState(self):
    k = self; state = k.defaultEditingAction
    # g.trace(state)
    k.setInputState(state)
.. @+node:ekr.20170624151245.2097: *8* k.setInputState
def setInputState(self, state, set_border=False):
    k = self
    k.unboundKeyAction = state
.. @+node:ekr.20170624151245.2098: *8* k.setState
def setState(self, kind, n, handler=None):
    trace = False and not g.unitTesting
    k = self
    if kind and n is not None:
        if trace: g.trace('**** setting %s %s %s' % (
            kind, n, handler and handler.__name__), g.callers())
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        if trace: g.trace('clearing')
        k.clearState()
    # k.showStateAndMode()
.. @+node:ekr.20170624151245.2099: *8* k.showStateAndMode
def showStateAndMode(self, w=None, prompt=None, setFocus=True):
    '''Show the state and mode at the start of the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    state = k.unboundKeyAction
    mode = k.getStateKind()
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
    isText = g.isTextWrapper(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree, 'getWrapper'):
            if hasattr(w, 'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2, item=None)
            isText = bool(w) # A benign hack.
    if trace: g.trace('state: %s, text?: %s, w: %s' % (state, isText, w))
    if mode:
        if mode in ('getArg', 'getFileName', 'full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[: -5]
            s = '%s Mode' % mode.capitalize()
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    if trace: g.trace(repr(s))
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state, w)
    # 2015/07/11: reset the status line.
    if hasattr(c.frame.tree, 'set_status_line'):
        c.frame.tree.set_status_line(c.p)
.. @+node:ekr.20170624151245.2100: *8* k.showStateCursor
def showStateCursor(self, state, w):
    # g.trace(state,w)
    pass
.. @+node:ekr.20170624151245.2101: *7* k.universalDispatcher & helpers
def universalDispatcher(self, event):
    '''Handle accumulation of universal argument.'''
    << about repeat counts >>
    k = self
    state = k.getState('u-arg')
    stroke = event.stroke if event else ''
    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg', 1, k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        char = event.char if event else ''
        if char == 'Escape':
            k.keyboardQuit()
        elif char == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif char.isdigit() or char == '-':
            k.updateLabel(event)
        elif char in (
            'Alt_L', 'Alt_R',
            'Control_L', 'Control_R',
            'Meta_L', 'Meta_R',
            'Shift_L', 'Shift_R',
        ):
            k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try: n = int(val) * k.repeatCount
            except ValueError: n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event, n)
            k.keyboardQuit()
    elif state == 2:
        k.doControlU(event, stroke)
.. @+node:ekr.20170624151245.2105: *8* << about repeat counts >>
@nocolor
@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
.. @+node:ekr.20170624151245.2106: *8* k.executeNTimes
def executeNTimes(self, event, n):
    trace = False and not g.unitTesting
    c, k = self.c, self
    w = event and event.widget
    stroke = event.stroke if event else ''
    if not stroke: return
    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand(event)
    else:
        si = k.getPaneBinding(stroke, event and event.widget)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('repeat', n, 'method', si.func.__name__,
                'stroke', stroke, 'widget', w)
            for z in range(n):
                event = g.app.gui.create_key_event(c, None, event, stroke, w)
                k.masterCommand(commandName=None, event=event, func=si.func, stroke=stroke)
        else:
            for z in range(n):
                k.masterKeyHandler(event)
.. @+node:ekr.20170624151245.2107: *8* doControlU
def doControlU(self, event, stroke):
    k = self
    ch = event.char if event else ''
    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))
    if ch == '(':
        k.clearState()
        k.resetLabel()
.. @+node:ekr.20170624151245.2105: *8* << about repeat counts >>
@nocolor
@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
.. @+node:ekr.20170624151245.2106: *8* k.executeNTimes
def executeNTimes(self, event, n):
    trace = False and not g.unitTesting
    c, k = self.c, self
    w = event and event.widget
    stroke = event.stroke if event else ''
    if not stroke: return
    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand(event)
    else:
        si = k.getPaneBinding(stroke, event and event.widget)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('repeat', n, 'method', si.func.__name__,
                'stroke', stroke, 'widget', w)
            for z in range(n):
                event = g.app.gui.create_key_event(c, None, event, stroke, w)
                k.masterCommand(commandName=None, event=event, func=si.func, stroke=stroke)
        else:
            for z in range(n):
                k.masterKeyHandler(event)
.. @+node:ekr.20170624151245.2107: *8* doControlU
def doControlU(self, event, stroke):
    k = self
    ch = event.char if event else ''
    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))
    if ch == '(':
        k.clearState()
        k.resetLabel()
.. @+node:ekr.20170624151245.1777: *7*  k.Birth
.. @+node:ekr.20170624151245.1798: *8* k.__init__& helpers
def __init__(self, c):
    '''Create a key handler for c.'''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug('(k)')
    self.c = c
    self.dispatchEvent = None
    self.fnc = None
        # A singleton defined in k.finishCreate.
    self.getArgInstance = None
        # A singleton defined in k.finishCreate.
    self.inited = False
        # Set at end of finishCreate.
    self.swap_mac_keys = False
        # How to init this??
    self.w = None
        # Note: will be None for NullGui.
    # Generalize...
    self.x_hasNumeric = ['sort-lines', 'sort-fields']
    self.altX_prompt = 'full-command: '
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.defineSettingsIvars()
    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction()
.. @+node:ekr.20170624151245.1806: *9* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):
    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.functionTail = None # For commands that take minibuffer arguments.
    # These are true globals
    self.getArgEscapes = []
    self.getArgEscapeFlag = False # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None, n=None, handler=None)
.. @+node:ekr.20170624151245.1807: *9* k.defineInternalIvars
def defineInternalIvars(self):
    '''Define internal ivars of the KeyHandlerClass class.'''
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None # New support for the demo.py plugin.
    self.demoPrevKey = None # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
.. @+node:ekr.20170624151245.1808: *9* k.defineMultiLineCommands
def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
.. @+node:ekr.20170624151245.1809: *9* k.defineSettingIvars
def defineSettingsIvars(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable_autocompleter_initially')
    self.enable_calltips = getBool('enable_calltips_initially')
    self.ignore_caps_lock = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_foreground_color = getColor('minibuffer_foreground_color') or 'black'
    self.minibuffer_warning_color = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys = getBool('swap_mac_keys')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable_alt_ctrl_bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'
    self.command_mode_bg_color = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg
    # g.trace(self.c.shortFileName())
.. @+node:ekr.20170624151245.1810: *9* k.defineSingleLineCommands
def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere', # 2011/06/07
        'set-find-node-only', # 2011/06/07
        'set-find-suboutline-only', # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
.. @+node:ekr.20170624151245.1811: *9* k.defineSpecialKeys
def defineSpecialKeys(self):
    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''
    k = self
    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&": "ampersand",
        "^": "asciicircum",
        "~": "asciitilde",
        "*": "asterisk",
        "@": "at",
        "\\": "backslash",
        "|": "bar",
        "{": "braceleft",
        "}": "braceright",
        "[": "bracketleft",
        "]": "bracketright",
        ":": "colon", # removed from code.
        ",": "comma",
        "$": "dollar",
        "=": "equal",
        "!": "exclam", # removed from code.
        ">": "greater",
        "<": "less",
        "-": "minus",
        "#": "numbersign",
        '"': "quotedbl",
        "'": "quoteright",
        "(": "parenleft",
        ")": "parenright", # removed from code.
        "%": "percent",
        ".": "period", # removed from code.
        "+": "plus",
        "?": "question",
        "`": "quoteleft",
        ";": "semicolon",
        "/": "slash",
        " ": "space", # removed from code.
        "_": "underscore",
    }
    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s
    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict[k.guiBindNamesDict.get(key)] = key
.. @+node:ekr.20170624151245.1812: *9* k.defineTkNames
def defineTkNames(self):
    k = self
    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left', 'Right', 'Up', 'Down',
        # Page up/down keys.
        'Next', 'Prior',
        # Home end keys.
        'Home', 'End'
        # Modifier keys.
        'Caps_Lock', 'Num_Lock',
        # F-keys.
        'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
        # All others.
        'Begin', 'Break', 'Clear', 'Delete', 'Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace', 'Linefeed', 'Return', 'Tab',
    )
    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp': 'BackSpace', # Dubious: should be '\b'
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ltarrow': 'Left',
        'pageup': 'Prior',
        'pagedn': 'Next',
        'rtarrow': 'Right',
        'uparrow': 'Up',
    }
    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict[s.lower()] = s
@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20170624151245.1806: *9* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):
    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.functionTail = None # For commands that take minibuffer arguments.
    # These are true globals
    self.getArgEscapes = []
    self.getArgEscapeFlag = False # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None, n=None, handler=None)
.. @+node:ekr.20170624151245.1807: *9* k.defineInternalIvars
def defineInternalIvars(self):
    '''Define internal ivars of the KeyHandlerClass class.'''
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None # New support for the demo.py plugin.
    self.demoPrevKey = None # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
.. @+node:ekr.20170624151245.1808: *9* k.defineMultiLineCommands
def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
.. @+node:ekr.20170624151245.1809: *9* k.defineSettingIvars
def defineSettingsIvars(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable_autocompleter_initially')
    self.enable_calltips = getBool('enable_calltips_initially')
    self.ignore_caps_lock = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_foreground_color = getColor('minibuffer_foreground_color') or 'black'
    self.minibuffer_warning_color = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys = getBool('swap_mac_keys')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable_alt_ctrl_bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'
    self.command_mode_bg_color = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg
    # g.trace(self.c.shortFileName())
.. @+node:ekr.20170624151245.1810: *9* k.defineSingleLineCommands
def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere', # 2011/06/07
        'set-find-node-only', # 2011/06/07
        'set-find-suboutline-only', # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
.. @+node:ekr.20170624151245.1811: *9* k.defineSpecialKeys
def defineSpecialKeys(self):
    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''
    k = self
    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&": "ampersand",
        "^": "asciicircum",
        "~": "asciitilde",
        "*": "asterisk",
        "@": "at",
        "\\": "backslash",
        "|": "bar",
        "{": "braceleft",
        "}": "braceright",
        "[": "bracketleft",
        "]": "bracketright",
        ":": "colon", # removed from code.
        ",": "comma",
        "$": "dollar",
        "=": "equal",
        "!": "exclam", # removed from code.
        ">": "greater",
        "<": "less",
        "-": "minus",
        "#": "numbersign",
        '"': "quotedbl",
        "'": "quoteright",
        "(": "parenleft",
        ")": "parenright", # removed from code.
        "%": "percent",
        ".": "period", # removed from code.
        "+": "plus",
        "?": "question",
        "`": "quoteleft",
        ";": "semicolon",
        "/": "slash",
        " ": "space", # removed from code.
        "_": "underscore",
    }
    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s
    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict[k.guiBindNamesDict.get(key)] = key
.. @+node:ekr.20170624151245.1812: *9* k.defineTkNames
def defineTkNames(self):
    k = self
    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left', 'Right', 'Up', 'Down',
        # Page up/down keys.
        'Next', 'Prior',
        # Home end keys.
        'Home', 'End'
        # Modifier keys.
        'Caps_Lock', 'Num_Lock',
        # F-keys.
        'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
        # All others.
        'Begin', 'Break', 'Clear', 'Delete', 'Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace', 'Linefeed', 'Return', 'Tab',
    )
    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp': 'BackSpace', # Dubious: should be '\b'
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ltarrow': 'Left',
        'pageup': 'Prior',
        'pagedn': 'Next',
        'rtarrow': 'Right',
        'uparrow': 'Up',
    }
    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict[s.lower()] = s
@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20170624151245.1813: *8* k.cmd (decorator)
def cmd(name):
    '''Command decorator for the leoKeys class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'k',])
.. @+node:ekr.20170624151245.1814: *8* k.finishCreate & helpers
def finishCreate(self):
    '''
    Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.
    '''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug('(k)', self.c)
    c, k = self.c, self
    k.w = c.frame.miniBufferWidget
        # Will be None for NullGui.
    k.fnc = FileNameChooser(c)
        # A singleton. Defined here so that c.k will exist.
    k.getArgInstance = GetArg(c)
        # a singleton. Defined here so that c.k will exist.
    k.makeAllBindings()
    k.initCommandHistory()
    k.inited = True
    k.setDefaultInputState()
    k.resetLabel()
.. @+node:ekr.20170624151245.1815: *8* k.oops
def oops(self):
    g.trace('Should be defined in subclass:', g.callers(4))
.. @+node:ekr.20170624151245.1816: *8* k.setDefaultEditingKeyAction (New)
def setDefaultEditingAction(self):
    k = self; c = k.c
    action = c.config.getString('default_editing_state') or 'insert'
    action.lower()
    if action not in ('command', 'insert', 'overwrite'):
        g.trace('ignoring default_editing_state: %s' % (action))
        action = 'insert'
    self.defaultEditingAction = action
.. @+node:ekr.20170624151245.1817: *8* k.setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction(self, allowCommandState=True):
    k = self; c = k.c
    # g.trace(g.callers())
    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command', 'insert', 'overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % (defaultAction))
        self.unboundKeyAction = 'insert'
    # g.trace(self.unboundKeyAction)
    self.defaultUnboundKeyAction = self.unboundKeyAction
    k.setInputState(self.defaultUnboundKeyAction)
.. @+node:ekr.20170624151245.1798: *8* k.__init__& helpers
def __init__(self, c):
    '''Create a key handler for c.'''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug('(k)')
    self.c = c
    self.dispatchEvent = None
    self.fnc = None
        # A singleton defined in k.finishCreate.
    self.getArgInstance = None
        # A singleton defined in k.finishCreate.
    self.inited = False
        # Set at end of finishCreate.
    self.swap_mac_keys = False
        # How to init this??
    self.w = None
        # Note: will be None for NullGui.
    # Generalize...
    self.x_hasNumeric = ['sort-lines', 'sort-fields']
    self.altX_prompt = 'full-command: '
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.defineSettingsIvars()
    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction()
.. @+node:ekr.20170624151245.1806: *9* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):
    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.functionTail = None # For commands that take minibuffer arguments.
    # These are true globals
    self.getArgEscapes = []
    self.getArgEscapeFlag = False # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None, n=None, handler=None)
.. @+node:ekr.20170624151245.1807: *9* k.defineInternalIvars
def defineInternalIvars(self):
    '''Define internal ivars of the KeyHandlerClass class.'''
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None # New support for the demo.py plugin.
    self.demoPrevKey = None # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
.. @+node:ekr.20170624151245.1808: *9* k.defineMultiLineCommands
def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
.. @+node:ekr.20170624151245.1809: *9* k.defineSettingIvars
def defineSettingsIvars(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable_autocompleter_initially')
    self.enable_calltips = getBool('enable_calltips_initially')
    self.ignore_caps_lock = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_foreground_color = getColor('minibuffer_foreground_color') or 'black'
    self.minibuffer_warning_color = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys = getBool('swap_mac_keys')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable_alt_ctrl_bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'
    self.command_mode_bg_color = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg
    # g.trace(self.c.shortFileName())
.. @+node:ekr.20170624151245.1810: *9* k.defineSingleLineCommands
def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere', # 2011/06/07
        'set-find-node-only', # 2011/06/07
        'set-find-suboutline-only', # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
.. @+node:ekr.20170624151245.1811: *9* k.defineSpecialKeys
def defineSpecialKeys(self):
    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''
    k = self
    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&": "ampersand",
        "^": "asciicircum",
        "~": "asciitilde",
        "*": "asterisk",
        "@": "at",
        "\\": "backslash",
        "|": "bar",
        "{": "braceleft",
        "}": "braceright",
        "[": "bracketleft",
        "]": "bracketright",
        ":": "colon", # removed from code.
        ",": "comma",
        "$": "dollar",
        "=": "equal",
        "!": "exclam", # removed from code.
        ">": "greater",
        "<": "less",
        "-": "minus",
        "#": "numbersign",
        '"': "quotedbl",
        "'": "quoteright",
        "(": "parenleft",
        ")": "parenright", # removed from code.
        "%": "percent",
        ".": "period", # removed from code.
        "+": "plus",
        "?": "question",
        "`": "quoteleft",
        ";": "semicolon",
        "/": "slash",
        " ": "space", # removed from code.
        "_": "underscore",
    }
    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s
    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict[k.guiBindNamesDict.get(key)] = key
.. @+node:ekr.20170624151245.1812: *9* k.defineTkNames
def defineTkNames(self):
    k = self
    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left', 'Right', 'Up', 'Down',
        # Page up/down keys.
        'Next', 'Prior',
        # Home end keys.
        'Home', 'End'
        # Modifier keys.
        'Caps_Lock', 'Num_Lock',
        # F-keys.
        'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
        # All others.
        'Begin', 'Break', 'Clear', 'Delete', 'Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace', 'Linefeed', 'Return', 'Tab',
    )
    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp': 'BackSpace', # Dubious: should be '\b'
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ltarrow': 'Left',
        'pageup': 'Prior',
        'pagedn': 'Next',
        'rtarrow': 'Right',
        'uparrow': 'Up',
    }
    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict[s.lower()] = s
@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20170624151245.1806: *9* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):
    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.functionTail = None # For commands that take minibuffer arguments.
    # These are true globals
    self.getArgEscapes = []
    self.getArgEscapeFlag = False # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None, n=None, handler=None)
.. @+node:ekr.20170624151245.1807: *9* k.defineInternalIvars
def defineInternalIvars(self):
    '''Define internal ivars of the KeyHandlerClass class.'''
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None # New support for the demo.py plugin.
    self.demoPrevKey = None # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
.. @+node:ekr.20170624151245.1808: *9* k.defineMultiLineCommands
def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
.. @+node:ekr.20170624151245.1809: *9* k.defineSettingIvars
def defineSettingsIvars(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable_autocompleter_initially')
    self.enable_calltips = getBool('enable_calltips_initially')
    self.ignore_caps_lock = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_foreground_color = getColor('minibuffer_foreground_color') or 'black'
    self.minibuffer_warning_color = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys = getBool('swap_mac_keys')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable_alt_ctrl_bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'
    self.command_mode_bg_color = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg
    # g.trace(self.c.shortFileName())
.. @+node:ekr.20170624151245.1810: *9* k.defineSingleLineCommands
def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere', # 2011/06/07
        'set-find-node-only', # 2011/06/07
        'set-find-suboutline-only', # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
.. @+node:ekr.20170624151245.1811: *9* k.defineSpecialKeys
def defineSpecialKeys(self):
    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''
    k = self
    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&": "ampersand",
        "^": "asciicircum",
        "~": "asciitilde",
        "*": "asterisk",
        "@": "at",
        "\\": "backslash",
        "|": "bar",
        "{": "braceleft",
        "}": "braceright",
        "[": "bracketleft",
        "]": "bracketright",
        ":": "colon", # removed from code.
        ",": "comma",
        "$": "dollar",
        "=": "equal",
        "!": "exclam", # removed from code.
        ">": "greater",
        "<": "less",
        "-": "minus",
        "#": "numbersign",
        '"': "quotedbl",
        "'": "quoteright",
        "(": "parenleft",
        ")": "parenright", # removed from code.
        "%": "percent",
        ".": "period", # removed from code.
        "+": "plus",
        "?": "question",
        "`": "quoteleft",
        ";": "semicolon",
        "/": "slash",
        " ": "space", # removed from code.
        "_": "underscore",
    }
    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s
    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict[k.guiBindNamesDict.get(key)] = key
.. @+node:ekr.20170624151245.1812: *9* k.defineTkNames
def defineTkNames(self):
    k = self
    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left', 'Right', 'Up', 'Down',
        # Page up/down keys.
        'Next', 'Prior',
        # Home end keys.
        'Home', 'End'
        # Modifier keys.
        'Caps_Lock', 'Num_Lock',
        # F-keys.
        'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
        # All others.
        'Begin', 'Break', 'Clear', 'Delete', 'Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace', 'Linefeed', 'Return', 'Tab',
    )
    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp': 'BackSpace', # Dubious: should be '\b'
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ltarrow': 'Left',
        'pageup': 'Prior',
        'pagedn': 'Next',
        'rtarrow': 'Right',
        'uparrow': 'Up',
    }
    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict[s.lower()] = s
@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20170624151245.1813: *8* k.cmd (decorator)
def cmd(name):
    '''Command decorator for the leoKeys class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'k',])
.. @+node:ekr.20170624151245.1814: *8* k.finishCreate & helpers
def finishCreate(self):
    '''
    Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.
    '''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.es_debug('(k)', self.c)
    c, k = self.c, self
    k.w = c.frame.miniBufferWidget
        # Will be None for NullGui.
    k.fnc = FileNameChooser(c)
        # A singleton. Defined here so that c.k will exist.
    k.getArgInstance = GetArg(c)
        # a singleton. Defined here so that c.k will exist.
    k.makeAllBindings()
    k.initCommandHistory()
    k.inited = True
    k.setDefaultInputState()
    k.resetLabel()
.. @+node:ekr.20170624151245.1815: *8* k.oops
def oops(self):
    g.trace('Should be defined in subclass:', g.callers(4))
.. @+node:ekr.20170624151245.1816: *8* k.setDefaultEditingKeyAction (New)
def setDefaultEditingAction(self):
    k = self; c = k.c
    action = c.config.getString('default_editing_state') or 'insert'
    action.lower()
    if action not in ('command', 'insert', 'overwrite'):
        g.trace('ignoring default_editing_state: %s' % (action))
        action = 'insert'
    self.defaultEditingAction = action
.. @+node:ekr.20170624151245.1817: *8* k.setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction(self, allowCommandState=True):
    k = self; c = k.c
    # g.trace(g.callers())
    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command', 'insert', 'overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % (defaultAction))
        self.unboundKeyAction = 'insert'
    # g.trace(self.unboundKeyAction)
    self.defaultUnboundKeyAction = self.unboundKeyAction
    k.setInputState(self.defaultUnboundKeyAction)
.. @+node:ekr.20170624151245.1818: *7* k.Binding
.. @+node:ekr.20170624151245.1842: *8* k.bindKey & helpers
def bindKey(self, pane, shortcut, callback, commandName, modeFlag=False, tag=None):
    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.

    tag gives the source of the binding.

    '''
    trace = False and not g.unitTesting
        # and commandName.startswith('move-lines')
        # and (shortcut == 'F1' or commandName == 'help')
    trace_list = False
    k = self
    if not k.check_bind_key(commandName, pane, shortcut):
        return False
    aList = k.bindingsDict.get(shortcut, [])
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s, stroke
        else:
            stroke = k.strokeFromSetting(shortcut)
        if trace:
            tag = tag.split(' ')[-1]
            g.trace('%7s %25r %17s %s' % (pane, stroke and stroke.s, tag, commandName))
            g.trace(g.callers())
        si = g.ShortcutInfo(kind=tag, pane=pane,
            func=callback, commandName=commandName, stroke=stroke)
        if shortcut:
            k.bindKeyToDict(pane, shortcut, si)
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList, commandName, pane, shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict[stroke] = aList
            if trace and trace_list: g.trace(shortcut, aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding', shortcut, 'to', commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
.. @+node:ekr.20170624151245.1848: *9* k.check_bind_key
def check_bind_key(self, commandName, pane, shortcut):
    # k = self
    if not shortcut:
        return False
        # return True # #327: binding to None clears previous bindings.
    assert g.isStroke(shortcut)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if shortcut.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:', '%s = %s' % (
                commandName, shortcut))
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', shortcut, commandName, g.callers())
        return False
    else:
        return True
.. @+node:ekr.20170624151245.1849: *9* k.kill_one_shortcut
def kill_one_shortcut(self, stroke):
    '''
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    '''
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)
    inv_d = lm.invert(d)
    # g.trace('1', stroke, stroke in c.config.shortcutsDict.d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
    # g.trace('2', stroke, stroke in c.config.shortcutsDict.d)
    # g.trace('3', c.config.shortcutsDict.d.get('help'))
.. @+node:ekr.20170624151245.1850: *9* k.remove_conflicting_definitions
def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si), si
        if pane in ('button', 'all', si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke, k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName, commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
.. @+node:ekr.20170624151245.1851: *9* k.bindKeyToDict
def bindKeyToDict(self, pane, stroke, si):
    '''Update k.masterBindingsDict for the stroke.'''
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    trace = False and not g.unitTesting
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = si
    k.masterBindingsDict[pane] = d
    if trace and si.commandName.startswith('goto-next-visible'):
        g.trace('%4s %10s' % (pane, stroke.s), si.commandName, si.func.__name__)
.. @+node:ekr.20170624151245.1852: *9* k.bindOpenWith
def bindOpenWith(self, d):
    '''Register an open-with command.'''
    k = self; c = k.c
    shortcut = d.get('shortcut')
    name = d.get('name')
    # g.trace(d)
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)
    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName, shortcut, openWithCallback, pane='all', verbose=False)
.. @+node:ekr.20170624151245.1848: *9* k.check_bind_key
def check_bind_key(self, commandName, pane, shortcut):
    # k = self
    if not shortcut:
        return False
        # return True # #327: binding to None clears previous bindings.
    assert g.isStroke(shortcut)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if shortcut.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:', '%s = %s' % (
                commandName, shortcut))
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', shortcut, commandName, g.callers())
        return False
    else:
        return True
.. @+node:ekr.20170624151245.1849: *9* k.kill_one_shortcut
def kill_one_shortcut(self, stroke):
    '''
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    '''
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)
    inv_d = lm.invert(d)
    # g.trace('1', stroke, stroke in c.config.shortcutsDict.d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
    # g.trace('2', stroke, stroke in c.config.shortcutsDict.d)
    # g.trace('3', c.config.shortcutsDict.d.get('help'))
.. @+node:ekr.20170624151245.1850: *9* k.remove_conflicting_definitions
def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si), si
        if pane in ('button', 'all', si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke, k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName, commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
.. @+node:ekr.20170624151245.1851: *9* k.bindKeyToDict
def bindKeyToDict(self, pane, stroke, si):
    '''Update k.masterBindingsDict for the stroke.'''
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    trace = False and not g.unitTesting
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = si
    k.masterBindingsDict[pane] = d
    if trace and si.commandName.startswith('goto-next-visible'):
        g.trace('%4s %10s' % (pane, stroke.s), si.commandName, si.func.__name__)
.. @+node:ekr.20170624151245.1852: *9* k.bindOpenWith
def bindOpenWith(self, d):
    '''Register an open-with command.'''
    k = self; c = k.c
    shortcut = d.get('shortcut')
    name = d.get('name')
    # g.trace(d)
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)
    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName, shortcut, openWithCallback, pane='all', verbose=False)
.. @+node:ekr.20170624151245.1853: *8* k.checkBindings
def checkBindings(self):
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    k = self; c = k.c
    if not c.config.getBool('warn_about_missing_settings'): return
    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&', '')
        if not c.config.exists(key, 'shortcut'):
            if abbrev:
                g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name, abbrev, key))
            else:
                g.trace('No shortcut for %s = %s' % (name, key))
.. @+node:ekr.20170624151245.1854: *8* k.completeAllBindings
def completeAllBindings(self, w=None):
    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''
    # g.trace(w)
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
.. @+node:ekr.20170624151245.1855: *8* k.completeAllBindingsForWidget
def completeAllBindingsForWidget(self, w):
    '''Make all a master gui binding for widget w.'''
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
.. @+node:ekr.20170624151245.1856: *8* k.dumpMasterBindingsDict
def dumpMasterBindingsDict(self):
    '''Dump k.masterBindingsDict.'''
    k = self; d = k.masterBindingsDict
    g.pr('\nk.masterBindingsDict...\n')
    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            si = d2.get(key2)
            assert g.isShortcutInfo(si), si
            g.pr('%20s %s' % (key2, si.commandName))
.. @+node:ekr.20170624151245.1857: *8* k.initAbbrev & helper
def initAbbrev(self):
    k = self; c = k.c; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName, key)
.. @+node:ekr.20170624151245.1859: *9* k.initOneAbbrev
def initOneAbbrev(self, commandName, key):
    '''Enter key as an abbreviation for commandName in c.commandsDict.'''
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
.. @+node:ekr.20170624151245.1859: *9* k.initOneAbbrev
def initOneAbbrev(self, commandName, key):
    '''Enter key as an abbreviation for commandName in c.commandsDict.'''
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
.. @+node:ekr.20170624151245.1860: *8* k.initSpecialIvars
def initSpecialIvars(self):
    '''Set ivars for special keystrokes from previously-existing bindings.'''
    k = self; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn = c.config.getBool('warn_about_missing_settings')
    for ivar, commandName in (
        ('fullCommandKey', 'full-command'),
        ('abortAllModesKey', 'keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey', 'auto-complete-force'),
        ('demoNextKey', 'demo-next'),
        ('demoPrevKey', 'demo-prev'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList, found = aList or [], False
        for pane in ('text', 'all'):
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.pane == pane:
                    if trace: g.trace(commandName, ivar, si.stroke)
                    setattr(k, ivar, si.stroke)
                    found = True; break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
.. @+node:ekr.20170624151245.1861: *8* k.killBinding
def killBinding(self, commandName):
    '''
    Kill all bindings for all keystrokes presently assigned to commandName.
    '''
    # g.trace(commandName)
.. @+node:ekr.20170624151245.1862: *8* k.makeAllBindings
def makeAllBindings(self):
    '''Make all key bindings in all of Leo's panes.'''
    k = self
    k.bindingsDict = {}
    k.addModeCommands()
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
.. @+node:ekr.20170624151245.1863: *8* k.makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict(self):
    '''Add bindings for all entries in c.commandsDict.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    d = c.commandsDict
    t1 = time.time()
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of si with si.stroke == stroke.
    d2 = g.TypedDictOfLists(
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke, valType=g.ShortcutInfo)
    for commandName in sorted(d):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for si in aList:
            if trace and commandName == 'help':
                g.trace(key, repr(si.stroke), aList)
            assert isinstance(si, g.ShortcutInfo)
            # Important: si.stroke is already canonicalized.
            stroke = si.stroke
            si.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add(stroke, si)
    # Step 2: make the bindings.
    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for si in aList2:
            assert isinstance(si, g.ShortcutInfo)
            commandName = si.commandName
            command = c.commandsDict.get(commandName)
            tag = si.kind
            pane = si.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane, stroke, command, commandName, tag=tag)
    t2 = time.time()
    if trace:
        g.trace('%0.2f sec %s' % ((t2 - t1), c.shortFileName()))
.. @+node:ekr.20170624151245.1864: *8* k.makeMasterGuiBinding
def makeMasterGuiBinding(self, stroke, w=None, trace=False):
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    trace = False and not g.unitTesting
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree, 'bindingWidget') and f.tree.bindingWidget or None
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
    if trace: g.trace(len(aList), stroke)
.. @+node:ekr.20170624151245.1842: *8* k.bindKey & helpers
def bindKey(self, pane, shortcut, callback, commandName, modeFlag=False, tag=None):
    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.

    tag gives the source of the binding.

    '''
    trace = False and not g.unitTesting
        # and commandName.startswith('move-lines')
        # and (shortcut == 'F1' or commandName == 'help')
    trace_list = False
    k = self
    if not k.check_bind_key(commandName, pane, shortcut):
        return False
    aList = k.bindingsDict.get(shortcut, [])
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s, stroke
        else:
            stroke = k.strokeFromSetting(shortcut)
        if trace:
            tag = tag.split(' ')[-1]
            g.trace('%7s %25r %17s %s' % (pane, stroke and stroke.s, tag, commandName))
            g.trace(g.callers())
        si = g.ShortcutInfo(kind=tag, pane=pane,
            func=callback, commandName=commandName, stroke=stroke)
        if shortcut:
            k.bindKeyToDict(pane, shortcut, si)
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList, commandName, pane, shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict[stroke] = aList
            if trace and trace_list: g.trace(shortcut, aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding', shortcut, 'to', commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
.. @+node:ekr.20170624151245.1848: *9* k.check_bind_key
def check_bind_key(self, commandName, pane, shortcut):
    # k = self
    if not shortcut:
        return False
        # return True # #327: binding to None clears previous bindings.
    assert g.isStroke(shortcut)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if shortcut.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:', '%s = %s' % (
                commandName, shortcut))
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', shortcut, commandName, g.callers())
        return False
    else:
        return True
.. @+node:ekr.20170624151245.1849: *9* k.kill_one_shortcut
def kill_one_shortcut(self, stroke):
    '''
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    '''
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)
    inv_d = lm.invert(d)
    # g.trace('1', stroke, stroke in c.config.shortcutsDict.d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
    # g.trace('2', stroke, stroke in c.config.shortcutsDict.d)
    # g.trace('3', c.config.shortcutsDict.d.get('help'))
.. @+node:ekr.20170624151245.1850: *9* k.remove_conflicting_definitions
def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si), si
        if pane in ('button', 'all', si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke, k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName, commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
.. @+node:ekr.20170624151245.1851: *9* k.bindKeyToDict
def bindKeyToDict(self, pane, stroke, si):
    '''Update k.masterBindingsDict for the stroke.'''
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    trace = False and not g.unitTesting
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = si
    k.masterBindingsDict[pane] = d
    if trace and si.commandName.startswith('goto-next-visible'):
        g.trace('%4s %10s' % (pane, stroke.s), si.commandName, si.func.__name__)
.. @+node:ekr.20170624151245.1852: *9* k.bindOpenWith
def bindOpenWith(self, d):
    '''Register an open-with command.'''
    k = self; c = k.c
    shortcut = d.get('shortcut')
    name = d.get('name')
    # g.trace(d)
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)
    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName, shortcut, openWithCallback, pane='all', verbose=False)
.. @+node:ekr.20170624151245.1848: *9* k.check_bind_key
def check_bind_key(self, commandName, pane, shortcut):
    # k = self
    if not shortcut:
        return False
        # return True # #327: binding to None clears previous bindings.
    assert g.isStroke(shortcut)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if shortcut.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:', '%s = %s' % (
                commandName, shortcut))
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', shortcut, commandName, g.callers())
        return False
    else:
        return True
.. @+node:ekr.20170624151245.1849: *9* k.kill_one_shortcut
def kill_one_shortcut(self, stroke):
    '''
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    '''
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)
    inv_d = lm.invert(d)
    # g.trace('1', stroke, stroke in c.config.shortcutsDict.d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
    # g.trace('2', stroke, stroke in c.config.shortcutsDict.d)
    # g.trace('3', c.config.shortcutsDict.d.get('help'))
.. @+node:ekr.20170624151245.1850: *9* k.remove_conflicting_definitions
def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si), si
        if pane in ('button', 'all', si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke, k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName, commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
.. @+node:ekr.20170624151245.1851: *9* k.bindKeyToDict
def bindKeyToDict(self, pane, stroke, si):
    '''Update k.masterBindingsDict for the stroke.'''
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    trace = False and not g.unitTesting
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = si
    k.masterBindingsDict[pane] = d
    if trace and si.commandName.startswith('goto-next-visible'):
        g.trace('%4s %10s' % (pane, stroke.s), si.commandName, si.func.__name__)
.. @+node:ekr.20170624151245.1852: *9* k.bindOpenWith
def bindOpenWith(self, d):
    '''Register an open-with command.'''
    k = self; c = k.c
    shortcut = d.get('shortcut')
    name = d.get('name')
    # g.trace(d)
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)
    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName, shortcut, openWithCallback, pane='all', verbose=False)
.. @+node:ekr.20170624151245.1853: *8* k.checkBindings
def checkBindings(self):
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    k = self; c = k.c
    if not c.config.getBool('warn_about_missing_settings'): return
    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&', '')
        if not c.config.exists(key, 'shortcut'):
            if abbrev:
                g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name, abbrev, key))
            else:
                g.trace('No shortcut for %s = %s' % (name, key))
.. @+node:ekr.20170624151245.1854: *8* k.completeAllBindings
def completeAllBindings(self, w=None):
    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''
    # g.trace(w)
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
.. @+node:ekr.20170624151245.1855: *8* k.completeAllBindingsForWidget
def completeAllBindingsForWidget(self, w):
    '''Make all a master gui binding for widget w.'''
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
.. @+node:ekr.20170624151245.1856: *8* k.dumpMasterBindingsDict
def dumpMasterBindingsDict(self):
    '''Dump k.masterBindingsDict.'''
    k = self; d = k.masterBindingsDict
    g.pr('\nk.masterBindingsDict...\n')
    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            si = d2.get(key2)
            assert g.isShortcutInfo(si), si
            g.pr('%20s %s' % (key2, si.commandName))
.. @+node:ekr.20170624151245.1857: *8* k.initAbbrev & helper
def initAbbrev(self):
    k = self; c = k.c; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName, key)
.. @+node:ekr.20170624151245.1859: *9* k.initOneAbbrev
def initOneAbbrev(self, commandName, key):
    '''Enter key as an abbreviation for commandName in c.commandsDict.'''
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
.. @+node:ekr.20170624151245.1859: *9* k.initOneAbbrev
def initOneAbbrev(self, commandName, key):
    '''Enter key as an abbreviation for commandName in c.commandsDict.'''
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
.. @+node:ekr.20170624151245.1860: *8* k.initSpecialIvars
def initSpecialIvars(self):
    '''Set ivars for special keystrokes from previously-existing bindings.'''
    k = self; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn = c.config.getBool('warn_about_missing_settings')
    for ivar, commandName in (
        ('fullCommandKey', 'full-command'),
        ('abortAllModesKey', 'keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey', 'auto-complete-force'),
        ('demoNextKey', 'demo-next'),
        ('demoPrevKey', 'demo-prev'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList, found = aList or [], False
        for pane in ('text', 'all'):
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.pane == pane:
                    if trace: g.trace(commandName, ivar, si.stroke)
                    setattr(k, ivar, si.stroke)
                    found = True; break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
.. @+node:ekr.20170624151245.1861: *8* k.killBinding
def killBinding(self, commandName):
    '''
    Kill all bindings for all keystrokes presently assigned to commandName.
    '''
    # g.trace(commandName)
.. @+node:ekr.20170624151245.1862: *8* k.makeAllBindings
def makeAllBindings(self):
    '''Make all key bindings in all of Leo's panes.'''
    k = self
    k.bindingsDict = {}
    k.addModeCommands()
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
.. @+node:ekr.20170624151245.1863: *8* k.makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict(self):
    '''Add bindings for all entries in c.commandsDict.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    d = c.commandsDict
    t1 = time.time()
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of si with si.stroke == stroke.
    d2 = g.TypedDictOfLists(
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke, valType=g.ShortcutInfo)
    for commandName in sorted(d):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for si in aList:
            if trace and commandName == 'help':
                g.trace(key, repr(si.stroke), aList)
            assert isinstance(si, g.ShortcutInfo)
            # Important: si.stroke is already canonicalized.
            stroke = si.stroke
            si.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add(stroke, si)
    # Step 2: make the bindings.
    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for si in aList2:
            assert isinstance(si, g.ShortcutInfo)
            commandName = si.commandName
            command = c.commandsDict.get(commandName)
            tag = si.kind
            pane = si.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane, stroke, command, commandName, tag=tag)
    t2 = time.time()
    if trace:
        g.trace('%0.2f sec %s' % ((t2 - t1), c.shortFileName()))
.. @+node:ekr.20170624151245.1864: *8* k.makeMasterGuiBinding
def makeMasterGuiBinding(self, stroke, w=None, trace=False):
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    trace = False and not g.unitTesting
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree, 'bindingWidget') and f.tree.bindingWidget or None
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
    if trace: g.trace(len(aList), stroke)
.. @+node:ekr.20170624151245.1865: *7* k.Command history
.. @+node:ekr.20170624151245.1871: *8* k.addToCommandHistory
def addToCommandHistory(self, commandName):
    '''Add a name to the command history.'''
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None
    # g.trace(commandName,h)
.. @+node:ekr.20170624151245.1872: *8* k.commandHistoryDown
def commandHistoryFwd(self):
    '''
    Move down the Command History - fall off the bottom (return empty string)
    if necessary
    '''
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        commandName = ''
        if i == len(h) -1:
            # fall off the bottom
            i = None
        elif i != None:
            # move to next down in list
            i += 1
            commandName = h[i]
        # (else i == None; no change to index, command == '')
        # g.trace(i,h)
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
.. @+node:ekr.20170624151245.1873: *8* k.commandHistoryUp
def commandHistoryBackwd(self):
    '''
    Return the previous entry in the Command History - stay at the top
    if we are there
    '''
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        if i == None:
            # first time in - set to last entry
            i = len(h) -1
        elif i > 0:
            i -= 1
        commandName = h[i]
        k.commandIndex = i
        # g.trace(i,h)
        k.setLabel(k.mb_prefix + commandName)
.. @+node:ekr.20170624151245.1874: *8* k.initCommandHistory
def initCommandHistory(self):
    '''Init command history from @data command-history nodes.'''
    k, c = self, self.c
    aList = c.config.getData('history-list') or []
    for command in reversed(aList):
        k.addToCommandHistory(command)

def resetCommandHistory(self):
    ''' reset the command history index to indicate that
        we are pointing 'past' the last entry
    '''
    self.commandIndex = None
    #
.. @+node:ekr.20170624151245.1875: *8* k.sortCommandHistory
def sortCommandHistory(self):
    '''Sort the command history.'''
    k = self
    k.commandHistory.sort()
    k.commandIndex = None
.. @+node:ekr.20170624151245.1871: *8* k.addToCommandHistory
def addToCommandHistory(self, commandName):
    '''Add a name to the command history.'''
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None
    # g.trace(commandName,h)
.. @+node:ekr.20170624151245.1872: *8* k.commandHistoryDown
def commandHistoryFwd(self):
    '''
    Move down the Command History - fall off the bottom (return empty string)
    if necessary
    '''
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        commandName = ''
        if i == len(h) -1:
            # fall off the bottom
            i = None
        elif i != None:
            # move to next down in list
            i += 1
            commandName = h[i]
        # (else i == None; no change to index, command == '')
        # g.trace(i,h)
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
.. @+node:ekr.20170624151245.1873: *8* k.commandHistoryUp
def commandHistoryBackwd(self):
    '''
    Return the previous entry in the Command History - stay at the top
    if we are there
    '''
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        if i == None:
            # first time in - set to last entry
            i = len(h) -1
        elif i > 0:
            i -= 1
        commandName = h[i]
        k.commandIndex = i
        # g.trace(i,h)
        k.setLabel(k.mb_prefix + commandName)
.. @+node:ekr.20170624151245.1874: *8* k.initCommandHistory
def initCommandHistory(self):
    '''Init command history from @data command-history nodes.'''
    k, c = self, self.c
    aList = c.config.getData('history-list') or []
    for command in reversed(aList):
        k.addToCommandHistory(command)

def resetCommandHistory(self):
    ''' reset the command history index to indicate that
        we are pointing 'past' the last entry
    '''
    self.commandIndex = None
    #
.. @+node:ekr.20170624151245.1875: *8* k.sortCommandHistory
def sortCommandHistory(self):
    '''Sort the command history.'''
    k = self
    k.commandHistory.sort()
    k.commandIndex = None
.. @+node:ekr.20170624151245.1876: *7* k.Dispatching
.. @+node:ekr.20170624151245.1881: *8* k.fullCommand (alt-x) & helper
@cmd('full-command')
def fullCommand(self, event, specialStroke=None, specialFunc=None, help=False, helpHandler=None):
    '''Handle 'full-command' (alt-x) mode.'''
    trace = False and not g.unitTesting
    verbose = False
    try:
        k = self; c = k.c
        state = k.getState('full-command')
        helpPrompt = 'Help for command: '
        c.check_event(event)
        ch = char = event.char if event else ''
        stroke = event.stroke if event else ''
        if trace: g.trace('state', state, repr(char))
        if state > 0:
            k.setLossage(char, stroke)
        if state == 0:
            k.mb_event = event # Save the full event for later.
            k.setState('full-command', 1, handler=k.fullCommand)
            prompt = helpPrompt if help else k.altX_prompt
            k.setLabelBlue(prompt)
            k.mb_help = help
            k.mb_helpHandler = helpHandler
            c.minibufferWantsFocus()
        elif char == 'Ins' or k.isFKey(char):
            pass
        elif char == 'Escape':
            k.keyboardQuit()
        elif char == 'Down':
            k.commandHistoryFwd()
        elif char == 'Up':
            k.commandHistoryBackwd()
        elif char in ('\n', 'Return'):
            if trace and verbose: g.trace('***Return')
            # if trace and trace_event:
                # g.trace('hasSelection %r' % (
                    # k.mb_event and k.mb_event.w and k.mb_event.w.hasSelection()))
            # Fix bug 157: save and restore the selection.
            w = k.mb_event and k.mb_event.w
            if w and hasattr(w, 'hasSelection') and w.hasSelection():
                sel1, sel2 = w.getSelectionRange()
                ins = w.getInsertPoint()
                c.frame.log.deleteTab('Completion')
                w.setSelectionRange(sel1, sel2, insert=ins)
            else:
                c.frame.log.deleteTab('Completion')
                    # 2016/04/27
            if k.mb_help:
                s = k.getLabel()
                commandName = s[len(helpPrompt):].strip()
                k.clearState()
                k.resetLabel()
                if k.mb_helpHandler: k.mb_helpHandler(commandName)
            else:
                s = k.getLabel(ignorePrompt=True)
                commandName = s.strip()
                ok = k.callAltXFunction(k.mb_event)
                if ok:
                    k.addToCommandHistory(commandName)
        elif char in ('\t', 'Tab'):
            if trace and verbose: g.trace('***Tab')
            k.doTabCompletion(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif char in ('\b', 'BackSpace'):
            if trace and verbose: g.trace('***BackSpace')
            k.doBackSpace(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
            # g.trace('non-ascii')
            if specialStroke:
                g.trace(specialStroke)
                specialFunc()
            c.minibufferWantsFocus()
        else:
            # Clear the list, any other character besides tab indicates that a new prefix is in effect.
            k.mb_tabList = []
            k.updateLabel(event)
            k.mb_tabListPrefix = k.getLabel()
            c.minibufferWantsFocus()
            # g.trace('new prefix',k.mb_tabListPrefix)
    except Exception:
        g.es_exception()
        self.keyboardQuit()
.. @+node:ekr.20170624151245.1883: *9* callAltXFunction
def callAltXFunction(self, event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    # s = k.getLabel()
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    if trace: g.trace('command:', commandName, 'tail:', tail)
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.
        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))
    else:
        func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            # g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            try:
                func(event)
            except Exception:
                g.es_exception()
        else:
            c.widgetWantsFocusNow(event and event.widget)
                # Important, so cut-text works, e.g.
            try:
                func(event)
            except Exception:
                g.es_exception()
        k.endCommand(commandName)
        return True
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setStatusLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
        return False
.. @+node:ekr.20170624151245.1883: *9* callAltXFunction
def callAltXFunction(self, event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    # s = k.getLabel()
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    if trace: g.trace('command:', commandName, 'tail:', tail)
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.
        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))
    else:
        func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            # g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            try:
                func(event)
            except Exception:
                g.es_exception()
        else:
            c.widgetWantsFocusNow(event and event.widget)
                # Important, so cut-text works, e.g.
            try:
                func(event)
            except Exception:
                g.es_exception()
        k.endCommand(commandName)
        return True
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setStatusLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
        return False
.. @+node:ekr.20170624151245.1884: *8* k.endCommand
def endCommand(self, commandName):
    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''
    k = self; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return
    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        if not k.inState():
            k.commandName = None
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
            k.newMinibufferWidget = None
.. @+node:ekr.20170624151245.1881: *8* k.fullCommand (alt-x) & helper
@cmd('full-command')
def fullCommand(self, event, specialStroke=None, specialFunc=None, help=False, helpHandler=None):
    '''Handle 'full-command' (alt-x) mode.'''
    trace = False and not g.unitTesting
    verbose = False
    try:
        k = self; c = k.c
        state = k.getState('full-command')
        helpPrompt = 'Help for command: '
        c.check_event(event)
        ch = char = event.char if event else ''
        stroke = event.stroke if event else ''
        if trace: g.trace('state', state, repr(char))
        if state > 0:
            k.setLossage(char, stroke)
        if state == 0:
            k.mb_event = event # Save the full event for later.
            k.setState('full-command', 1, handler=k.fullCommand)
            prompt = helpPrompt if help else k.altX_prompt
            k.setLabelBlue(prompt)
            k.mb_help = help
            k.mb_helpHandler = helpHandler
            c.minibufferWantsFocus()
        elif char == 'Ins' or k.isFKey(char):
            pass
        elif char == 'Escape':
            k.keyboardQuit()
        elif char == 'Down':
            k.commandHistoryFwd()
        elif char == 'Up':
            k.commandHistoryBackwd()
        elif char in ('\n', 'Return'):
            if trace and verbose: g.trace('***Return')
            # if trace and trace_event:
                # g.trace('hasSelection %r' % (
                    # k.mb_event and k.mb_event.w and k.mb_event.w.hasSelection()))
            # Fix bug 157: save and restore the selection.
            w = k.mb_event and k.mb_event.w
            if w and hasattr(w, 'hasSelection') and w.hasSelection():
                sel1, sel2 = w.getSelectionRange()
                ins = w.getInsertPoint()
                c.frame.log.deleteTab('Completion')
                w.setSelectionRange(sel1, sel2, insert=ins)
            else:
                c.frame.log.deleteTab('Completion')
                    # 2016/04/27
            if k.mb_help:
                s = k.getLabel()
                commandName = s[len(helpPrompt):].strip()
                k.clearState()
                k.resetLabel()
                if k.mb_helpHandler: k.mb_helpHandler(commandName)
            else:
                s = k.getLabel(ignorePrompt=True)
                commandName = s.strip()
                ok = k.callAltXFunction(k.mb_event)
                if ok:
                    k.addToCommandHistory(commandName)
        elif char in ('\t', 'Tab'):
            if trace and verbose: g.trace('***Tab')
            k.doTabCompletion(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif char in ('\b', 'BackSpace'):
            if trace and verbose: g.trace('***BackSpace')
            k.doBackSpace(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
            # g.trace('non-ascii')
            if specialStroke:
                g.trace(specialStroke)
                specialFunc()
            c.minibufferWantsFocus()
        else:
            # Clear the list, any other character besides tab indicates that a new prefix is in effect.
            k.mb_tabList = []
            k.updateLabel(event)
            k.mb_tabListPrefix = k.getLabel()
            c.minibufferWantsFocus()
            # g.trace('new prefix',k.mb_tabListPrefix)
    except Exception:
        g.es_exception()
        self.keyboardQuit()
.. @+node:ekr.20170624151245.1883: *9* callAltXFunction
def callAltXFunction(self, event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    # s = k.getLabel()
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    if trace: g.trace('command:', commandName, 'tail:', tail)
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.
        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))
    else:
        func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            # g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            try:
                func(event)
            except Exception:
                g.es_exception()
        else:
            c.widgetWantsFocusNow(event and event.widget)
                # Important, so cut-text works, e.g.
            try:
                func(event)
            except Exception:
                g.es_exception()
        k.endCommand(commandName)
        return True
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setStatusLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
        return False
.. @+node:ekr.20170624151245.1883: *9* callAltXFunction
def callAltXFunction(self, event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    # s = k.getLabel()
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    if trace: g.trace('command:', commandName, 'tail:', tail)
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.
        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))
    else:
        func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            # g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            try:
                func(event)
            except Exception:
                g.es_exception()
        else:
            c.widgetWantsFocusNow(event and event.widget)
                # Important, so cut-text works, e.g.
            try:
                func(event)
            except Exception:
                g.es_exception()
        k.endCommand(commandName)
        return True
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setStatusLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
        return False
.. @+node:ekr.20170624151245.1884: *8* k.endCommand
def endCommand(self, commandName):
    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''
    k = self; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return
    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        if not k.inState():
            k.commandName = None
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
            k.newMinibufferWidget = None
.. @+node:ekr.20170624151245.1885: *7* k.Externally visible commands
.. @+node:ekr.20170624151245.1897: *8* k.menuCommandKey
def menuCommandKey(self, event=None):
    # This method must exist, but it never gets called.
    pass
.. @+node:ekr.20170624151245.1898: *8* k.printBindings & helper
@cmd('print-bindings')
def printBindings(self, event=None):
    '''Print all the bindings presently in effect.'''
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            s1 = '' if si.pane == 'all' else si.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = si.commandName
            s4 = si.kind or '<no hash>'
            data.append((s1, s2, s3, s4),)
    # Print keys by type:
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt', # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl', # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append('***** %s...\n' % prefix)
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result # for unit test.
.. @+node:ekr.20170624151245.1900: *9* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    lm = g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        # g.trace('%10s %s' % (key, repr(kind)))
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane + key # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
.. @+node:ekr.20170624151245.1900: *9* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    lm = g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        # g.trace('%10s %s' % (key, repr(kind)))
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane + key # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
.. @+node:ekr.20170624151245.1901: *8* k.printButtons
@cmd('print-buttons')
def printButtons(self, event=None):
    '''Print all @button and @command commands, their bindings and their source.'''
    k = self; c = k.c
    tabName = '@buttons && @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('', s, tabName=tabName)

    data = []
    for aList in [c.config.getButtons(), c.config.getCommands()]:
        for z in aList:
            p, script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h, tag),)
    for aList in [g.app.config.atLocalButtonsList, g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h, 'L'),)
    result = ['%s %s' % (z[1], z[0]) for z in sorted(data)]
    result.extend([
        '',
        'legend:',
        'G leoSettings.leo',
        'L local .leo File',
        'M myLeoSettings.leo',
    ])
    put('\n'.join(result))
.. @+node:ekr.20170624151245.1902: *8* k.printCommands
@cmd('print-commands')
def printCommands(self, event=None):
    '''Print all the known commands and their bindings, if any.'''
    k = self; c = k.c; tabName = 'Commands'
    c.frame.log.clearTab(tabName)
    inverseBindingDict = k.computeInverseBindingDict()
    data, n = [], 0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName, [('', ''),])
        for z in dataList:
            pane, key = z
            pane = '%s ' % (pane) if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key', '')
            s1 = pane + key
            s2 = commandName
            n = max(n, len(s1))
            data.append((s1, s2),)
    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n, z1, z2) for z1, z2 in data]
    g.es('', ''.join(lines), tabName=tabName)
.. @+node:ekr.20170624151245.1903: *8* k.repeatComplexCommand & helper
@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.warning('no previous command')
.. @+node:ekr.20170624151245.1905: *9* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict[last](event)
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20170624151245.1905: *9* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict[last](event)
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20170624151245.1906: *8* k.set-xxx-State
@cmd('set-command-state')
def setCommandState(self, event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-insert-state')
def setInsertState(self, event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-overwrite-state')
def setOverwriteState(self, event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
.. @+node:ekr.20170624151245.1907: *8* k.toggle-input-state
@cmd('toggle-input-state')
def toggleInputState(self, event=None):
    '''The toggle-input-state command.'''
    k = self; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction
    if default == 'insert':
        state = 'command' if state == 'insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state == 'overwrite' else 'overwrite'
    else:
        state = 'insert' if state == 'command' else 'command' # prefer insert to overwrite.
    k.setInputState(state)
    k.showStateAndMode()
.. @+node:ekr.20170624151245.1897: *8* k.menuCommandKey
def menuCommandKey(self, event=None):
    # This method must exist, but it never gets called.
    pass
.. @+node:ekr.20170624151245.1898: *8* k.printBindings & helper
@cmd('print-bindings')
def printBindings(self, event=None):
    '''Print all the bindings presently in effect.'''
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            s1 = '' if si.pane == 'all' else si.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = si.commandName
            s4 = si.kind or '<no hash>'
            data.append((s1, s2, s3, s4),)
    # Print keys by type:
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt', # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl', # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append('***** %s...\n' % prefix)
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result # for unit test.
.. @+node:ekr.20170624151245.1900: *9* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    lm = g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        # g.trace('%10s %s' % (key, repr(kind)))
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane + key # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
.. @+node:ekr.20170624151245.1900: *9* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    lm = g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        # g.trace('%10s %s' % (key, repr(kind)))
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane + key # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
.. @+node:ekr.20170624151245.1901: *8* k.printButtons
@cmd('print-buttons')
def printButtons(self, event=None):
    '''Print all @button and @command commands, their bindings and their source.'''
    k = self; c = k.c
    tabName = '@buttons && @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('', s, tabName=tabName)

    data = []
    for aList in [c.config.getButtons(), c.config.getCommands()]:
        for z in aList:
            p, script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h, tag),)
    for aList in [g.app.config.atLocalButtonsList, g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h, 'L'),)
    result = ['%s %s' % (z[1], z[0]) for z in sorted(data)]
    result.extend([
        '',
        'legend:',
        'G leoSettings.leo',
        'L local .leo File',
        'M myLeoSettings.leo',
    ])
    put('\n'.join(result))
.. @+node:ekr.20170624151245.1902: *8* k.printCommands
@cmd('print-commands')
def printCommands(self, event=None):
    '''Print all the known commands and their bindings, if any.'''
    k = self; c = k.c; tabName = 'Commands'
    c.frame.log.clearTab(tabName)
    inverseBindingDict = k.computeInverseBindingDict()
    data, n = [], 0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName, [('', ''),])
        for z in dataList:
            pane, key = z
            pane = '%s ' % (pane) if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key', '')
            s1 = pane + key
            s2 = commandName
            n = max(n, len(s1))
            data.append((s1, s2),)
    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n, z1, z2) for z1, z2 in data]
    g.es('', ''.join(lines), tabName=tabName)
.. @+node:ekr.20170624151245.1903: *8* k.repeatComplexCommand & helper
@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.warning('no previous command')
.. @+node:ekr.20170624151245.1905: *9* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict[last](event)
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20170624151245.1905: *9* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict[last](event)
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20170624151245.1906: *8* k.set-xxx-State
@cmd('set-command-state')
def setCommandState(self, event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-insert-state')
def setInsertState(self, event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-overwrite-state')
def setOverwriteState(self, event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite', set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
.. @+node:ekr.20170624151245.1907: *8* k.toggle-input-state
@cmd('toggle-input-state')
def toggleInputState(self, event=None):
    '''The toggle-input-state command.'''
    k = self; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction
    if default == 'insert':
        state = 'command' if state == 'insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state == 'overwrite' else 'overwrite'
    else:
        state = 'insert' if state == 'command' else 'command' # prefer insert to overwrite.
    k.setInputState(state)
    k.showStateAndMode()
.. @+node:ekr.20170624151245.1908: *7* k.Externally visible helpers
.. @+node:ekr.20170624151245.1920: *8* Wrappers for GetArg methods
# New in Leo 5.4    
def getNextArg(self, handler):
    '''
    Get the next arg.  For example, after a Tab in the find commands.
    See the docstring for k.get1Arg for examples of its use.
    '''
    # Replace the current handler.
    self.getArgInstance.after_get_arg_state = ('getarg', 1, handler)
    
# New in Leo 5.4  
def get1Arg(self, event, handler,
    # returnKind=None, returnState=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    << docstring for k.get1arg >>
    returnKind, returnState = None, None
    assert handler, g.callers()
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def getArg(self, event,
    returnKind=None, returnState=None, handler=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    '''Convenience method mapping k.getArg to ga.get_arg.'''
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def doBackSpace(self, tabList, completion=True):
    '''Convenience method mapping k.doBackSpace to ga.do_back_space.'''
    self.getArgInstance.do_back_space(tabList, completion)

def doTabCompletion(self, tabList):
    '''Convenience method mapping k.doTabCompletion to ga.do_tab.'''
    self.getArgInstance.do_tab(tabList)

def getMinibufferCommandName(self):
    '''
    Convenience method mapping k.getMinibufferCommandName to
    ga.get_minibuffer_command_name.
    '''
    return self.getArgInstance.get_minibuffer_command_name()
.. @+node:ekr.20170624151245.1922: *9* << docstring for k.get1arg >>
'''
k.get1Arg: Handle the next character the user types when accumulating a
user argument from the minibuffer. Ctrl-G will abort this processing at any
time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.
    
Example 1: get one argument from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
Example 2: get two arguments from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.setLabelBlue('second prompt: ')
        k.getNextArg(handler=self.myCommand2)
        
    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
k.get1Arg and k.getNextArg are a convenience methods. They simply passes
their arguments to the get_arg method of the singleton GetArg instance. This
docstring describes k.get1arg and k.getNextArg as if they were the
corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n, handler)
though they aren't represented that way. When the state machine in the
GetArg class is active, the kind is 'getArg'.  This constant has special
meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    <Return> or (sometimes) <tab>.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.
    
'''
.. @+node:ekr.20170624151245.1922: *9* << docstring for k.get1arg >>
'''
k.get1Arg: Handle the next character the user types when accumulating a
user argument from the minibuffer. Ctrl-G will abort this processing at any
time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.
    
Example 1: get one argument from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
Example 2: get two arguments from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.setLabelBlue('second prompt: ')
        k.getNextArg(handler=self.myCommand2)
        
    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
k.get1Arg and k.getNextArg are a convenience methods. They simply passes
their arguments to the get_arg method of the singleton GetArg instance. This
docstring describes k.get1arg and k.getNextArg as if they were the
corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n, handler)
though they aren't represented that way. When the state machine in the
GetArg class is active, the kind is 'getArg'.  This constant has special
meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    <Return> or (sometimes) <tab>.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.
    
'''
.. @+node:ekr.20170624151245.1923: *8* k.keyboardQuit
@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True, mouseClick=False):
    '''
    This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.
    '''
    trace = False and not g.unitTesting
    k = self; c = k.c
    if trace: g.trace(g.callers())
    if g.app.quitting:
        return
    # 2011/05/30: We may be called from Qt event handlers.
    # Make sure to end editing!
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
.. @+node:ekr.20170624151245.1924: *8* k.manufactureKeyPressForCommandName (changed)
def manufactureKeyPressForCommandName(self, w, commandName):
    '''Implement a command by passing a keypress to the gui.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    stroke = k.getShortcutForCommandName(commandName)
    if not stroke:
        shortcut = None
    elif g.isStroke(stroke):
        shortcut = stroke.s
    else:
        stroke = k.strokeFromSetting(stroke)
        shortcut = stroke.s
    assert g.isString(shortcut)
    if trace and shortcut: g.trace(
        'shortcut', repr(shortcut), 'commandName', commandName)
    if shortcut and w:
        g.app.gui.set_focus(c, w)
        g.app.gui.event_generate(c, None, shortcut, w)
    else:
        message = 'no shortcut for %s' % (commandName)
        if trace: g.trace(message)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.error(message)
.. @+node:ekr.20170624151245.1925: *8* k.overrideCommand
def overrideCommand(self, commandName, func):
    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            si = d2.get(key2)
            assert g.isShortcutInfo(si), si
            if si.commandName == commandName:
                si.func = func
                d2[key2] = si
.. @+node:ekr.20170624151245.1926: *8* k.registerCommand
def registerCommand(self, commandName, shortcut, func,
    pane='all', source_c=None, verbose=False
):
    '''
    Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.
    source_c is the commander in which an @command or @button node is defined.
    '''
    trace = False and not g.unitTesting and commandName == 'help'
    traceCommand = False
    traceEntry = True
    traceStroke = True
    c, k = self.c, self
    is_local = c.shortFileName() not in ('myLeoSettings.leo', 'leoSettings.leo')
    if trace and traceEntry:
        # g.trace(pane, commandName, 'source_c:', source_c)
        g.trace(pane, commandName, shortcut, g.callers())
    f = c.commandsDict.get(commandName)
    if f and f.__name__ != func.__name__:
        g.trace('redefining', commandName, f, '->', func)
        # g.trace('f.__name__', f.__name__, 'func.__name__', func.__name__)
    assert not g.isStroke(shortcut)
    c.commandsDict[commandName] = func
    if shortcut:
        if trace and traceStroke: g.trace('shortcut', shortcut)
        stroke = k.strokeFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    elif is_local:
        # 327: Don't get defaults when handling a local file.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk, aList = c.config.getShortcut(commandName)
        for si in aList:
            assert g.isShortcutInfo(si), si
            assert g.isStrokeOrNone(si.stroke)
            if si.stroke and not si.pane.endswith('-mode'):
                # if trace: g.trace('*** found',si)
                stroke = si.stroke
                pane = si.pane # 2015/05/11.
                break
    if trace and traceStroke:
        g.trace('is_local', is_local, pane, stroke, commandName, c.shortFileName())
    if stroke:
        ok = k.bindKey(pane, stroke, func, commandName, tag='register-command')
            # Must be a stroke.
        k.makeMasterGuiBinding(stroke, trace=trace) # Must be a stroke.
        if trace and traceCommand and ok and not g.app.silentMode:
            g.blue('', '@command: %s = %s' % (
                commandName, k.prettyPrintKey(stroke)))
    elif is_local:
        k.killBinding(commandName)
    elif trace and traceCommand and not g.app.silentMode:
            g.blue('', '@command: %s' % (commandName))
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict[key] = c.commandsDict.get(commandName)
                    break
.. @+node:ekr.20170624151245.1927: *8* k.simulateCommand & k.commandExists
def simulateCommand(self, commandName, event=None):
    '''Execute a Leo command by name.'''
    k = self; c = k.c
    func = self.commandExists(commandName)
    if func:
        # g.trace(commandName,func.__name__)
        if event:
            pass
        elif commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.app.gui.create_key_event(c, None, None, None)
        k.masterCommand(event=event, func=func)
        if c.exists:
            return k.funcReturn
        else:
            return None
    elif g.app.unitTesting:
        raise AttributeError
    else:
        g.error('simulateCommand: no command for %s' % (commandName))
        return None
.. @+node:ekr.20170624151245.1929: *9* k.commandExists
def commandExists(self, commandName):
    '''Return the command handler for the given command name, or None.'''
    c, k = self.c, self
    commandName = commandName.strip()
    if commandName:
        aList = commandName.split(None)
        if len(aList) == 1:
            k.givenArgs = []
        else:
            commandName = aList[0]
            k.givenArgs = aList[1:]
        # g.trace(commandName,k.givenArgs)
        func = c.commandsDict.get(commandName)
        return func
    else:
        return None
.. @+node:ekr.20170624151245.1929: *9* k.commandExists
def commandExists(self, commandName):
    '''Return the command handler for the given command name, or None.'''
    c, k = self.c, self
    commandName = commandName.strip()
    if commandName:
        aList = commandName.split(None)
        if len(aList) == 1:
            k.givenArgs = []
        else:
            commandName = aList[0]
            k.givenArgs = aList[1:]
        # g.trace(commandName,k.givenArgs)
        func = c.commandsDict.get(commandName)
        return func
    else:
        return None
.. @+node:ekr.20170624151245.1930: *8* k.getFileName
def getFileName(self, event, callback=None,
    filterExt=None, prompt='Enter File Name: ', tabName='Dired'
):
    '''Get a file name from the minibuffer.'''
    k = self
    k.fnc.get_file_name(event, callback, filterExt, prompt, tabName)
.. @+node:ekr.20170624151245.1920: *8* Wrappers for GetArg methods
# New in Leo 5.4    
def getNextArg(self, handler):
    '''
    Get the next arg.  For example, after a Tab in the find commands.
    See the docstring for k.get1Arg for examples of its use.
    '''
    # Replace the current handler.
    self.getArgInstance.after_get_arg_state = ('getarg', 1, handler)
    
# New in Leo 5.4  
def get1Arg(self, event, handler,
    # returnKind=None, returnState=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    << docstring for k.get1arg >>
    returnKind, returnState = None, None
    assert handler, g.callers()
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def getArg(self, event,
    returnKind=None, returnState=None, handler=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    '''Convenience method mapping k.getArg to ga.get_arg.'''
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def doBackSpace(self, tabList, completion=True):
    '''Convenience method mapping k.doBackSpace to ga.do_back_space.'''
    self.getArgInstance.do_back_space(tabList, completion)

def doTabCompletion(self, tabList):
    '''Convenience method mapping k.doTabCompletion to ga.do_tab.'''
    self.getArgInstance.do_tab(tabList)

def getMinibufferCommandName(self):
    '''
    Convenience method mapping k.getMinibufferCommandName to
    ga.get_minibuffer_command_name.
    '''
    return self.getArgInstance.get_minibuffer_command_name()
.. @+node:ekr.20170624151245.1922: *9* << docstring for k.get1arg >>
'''
k.get1Arg: Handle the next character the user types when accumulating a
user argument from the minibuffer. Ctrl-G will abort this processing at any
time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.
    
Example 1: get one argument from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
Example 2: get two arguments from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.setLabelBlue('second prompt: ')
        k.getNextArg(handler=self.myCommand2)
        
    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
k.get1Arg and k.getNextArg are a convenience methods. They simply passes
their arguments to the get_arg method of the singleton GetArg instance. This
docstring describes k.get1arg and k.getNextArg as if they were the
corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n, handler)
though they aren't represented that way. When the state machine in the
GetArg class is active, the kind is 'getArg'.  This constant has special
meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    <Return> or (sometimes) <tab>.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.
    
'''
.. @+node:ekr.20170624151245.1922: *9* << docstring for k.get1arg >>
'''
k.get1Arg: Handle the next character the user types when accumulating a
user argument from the minibuffer. Ctrl-G will abort this processing at any
time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.
    
Example 1: get one argument from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
Example 2: get two arguments from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.setLabelBlue('second prompt: ')
        k.getNextArg(handler=self.myCommand2)
        
    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
k.get1Arg and k.getNextArg are a convenience methods. They simply passes
their arguments to the get_arg method of the singleton GetArg instance. This
docstring describes k.get1arg and k.getNextArg as if they were the
corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n, handler)
though they aren't represented that way. When the state machine in the
GetArg class is active, the kind is 'getArg'.  This constant has special
meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    <Return> or (sometimes) <tab>.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.
    
'''
.. @+node:ekr.20170624151245.1923: *8* k.keyboardQuit
@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True, mouseClick=False):
    '''
    This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.
    '''
    trace = False and not g.unitTesting
    k = self; c = k.c
    if trace: g.trace(g.callers())
    if g.app.quitting:
        return
    # 2011/05/30: We may be called from Qt event handlers.
    # Make sure to end editing!
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
.. @+node:ekr.20170624151245.1924: *8* k.manufactureKeyPressForCommandName (changed)
def manufactureKeyPressForCommandName(self, w, commandName):
    '''Implement a command by passing a keypress to the gui.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    stroke = k.getShortcutForCommandName(commandName)
    if not stroke:
        shortcut = None
    elif g.isStroke(stroke):
        shortcut = stroke.s
    else:
        stroke = k.strokeFromSetting(stroke)
        shortcut = stroke.s
    assert g.isString(shortcut)
    if trace and shortcut: g.trace(
        'shortcut', repr(shortcut), 'commandName', commandName)
    if shortcut and w:
        g.app.gui.set_focus(c, w)
        g.app.gui.event_generate(c, None, shortcut, w)
    else:
        message = 'no shortcut for %s' % (commandName)
        if trace: g.trace(message)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.error(message)
.. @+node:ekr.20170624151245.1925: *8* k.overrideCommand
def overrideCommand(self, commandName, func):
    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            si = d2.get(key2)
            assert g.isShortcutInfo(si), si
            if si.commandName == commandName:
                si.func = func
                d2[key2] = si
.. @+node:ekr.20170624151245.1926: *8* k.registerCommand
def registerCommand(self, commandName, shortcut, func,
    pane='all', source_c=None, verbose=False
):
    '''
    Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.
    source_c is the commander in which an @command or @button node is defined.
    '''
    trace = False and not g.unitTesting and commandName == 'help'
    traceCommand = False
    traceEntry = True
    traceStroke = True
    c, k = self.c, self
    is_local = c.shortFileName() not in ('myLeoSettings.leo', 'leoSettings.leo')
    if trace and traceEntry:
        # g.trace(pane, commandName, 'source_c:', source_c)
        g.trace(pane, commandName, shortcut, g.callers())
    f = c.commandsDict.get(commandName)
    if f and f.__name__ != func.__name__:
        g.trace('redefining', commandName, f, '->', func)
        # g.trace('f.__name__', f.__name__, 'func.__name__', func.__name__)
    assert not g.isStroke(shortcut)
    c.commandsDict[commandName] = func
    if shortcut:
        if trace and traceStroke: g.trace('shortcut', shortcut)
        stroke = k.strokeFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    elif is_local:
        # 327: Don't get defaults when handling a local file.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk, aList = c.config.getShortcut(commandName)
        for si in aList:
            assert g.isShortcutInfo(si), si
            assert g.isStrokeOrNone(si.stroke)
            if si.stroke and not si.pane.endswith('-mode'):
                # if trace: g.trace('*** found',si)
                stroke = si.stroke
                pane = si.pane # 2015/05/11.
                break
    if trace and traceStroke:
        g.trace('is_local', is_local, pane, stroke, commandName, c.shortFileName())
    if stroke:
        ok = k.bindKey(pane, stroke, func, commandName, tag='register-command')
            # Must be a stroke.
        k.makeMasterGuiBinding(stroke, trace=trace) # Must be a stroke.
        if trace and traceCommand and ok and not g.app.silentMode:
            g.blue('', '@command: %s = %s' % (
                commandName, k.prettyPrintKey(stroke)))
    elif is_local:
        k.killBinding(commandName)
    elif trace and traceCommand and not g.app.silentMode:
            g.blue('', '@command: %s' % (commandName))
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict[key] = c.commandsDict.get(commandName)
                    break
.. @+node:ekr.20170624151245.1927: *8* k.simulateCommand & k.commandExists
def simulateCommand(self, commandName, event=None):
    '''Execute a Leo command by name.'''
    k = self; c = k.c
    func = self.commandExists(commandName)
    if func:
        # g.trace(commandName,func.__name__)
        if event:
            pass
        elif commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.app.gui.create_key_event(c, None, None, None)
        k.masterCommand(event=event, func=func)
        if c.exists:
            return k.funcReturn
        else:
            return None
    elif g.app.unitTesting:
        raise AttributeError
    else:
        g.error('simulateCommand: no command for %s' % (commandName))
        return None
.. @+node:ekr.20170624151245.1929: *9* k.commandExists
def commandExists(self, commandName):
    '''Return the command handler for the given command name, or None.'''
    c, k = self.c, self
    commandName = commandName.strip()
    if commandName:
        aList = commandName.split(None)
        if len(aList) == 1:
            k.givenArgs = []
        else:
            commandName = aList[0]
            k.givenArgs = aList[1:]
        # g.trace(commandName,k.givenArgs)
        func = c.commandsDict.get(commandName)
        return func
    else:
        return None
.. @+node:ekr.20170624151245.1929: *9* k.commandExists
def commandExists(self, commandName):
    '''Return the command handler for the given command name, or None.'''
    c, k = self.c, self
    commandName = commandName.strip()
    if commandName:
        aList = commandName.split(None)
        if len(aList) == 1:
            k.givenArgs = []
        else:
            commandName = aList[0]
            k.givenArgs = aList[1:]
        # g.trace(commandName,k.givenArgs)
        func = c.commandsDict.get(commandName)
        return func
    else:
        return None
.. @+node:ekr.20170624151245.1930: *8* k.getFileName
def getFileName(self, event, callback=None,
    filterExt=None, prompt='Enter File Name: ', tabName='Dired'
):
    '''Get a file name from the minibuffer.'''
    k = self
    k.fnc.get_file_name(event, callback, filterExt, prompt, tabName)
.. @+node:ekr.20170624151245.1931: *7* k.Master event handlers
.. @+node:ekr.20170624151245.1957: *8* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler(self, event):
    '''The master key handler for almost all key bindings.'''
    trace = False and not g.app.unitTesting
    traceGC = False and not g.app.unitTesting
    verbose = True
    trace_unbound = True
    k, c = self, self.c
    c.check_event(event)
    << define vars >>
    assert g.isStrokeOrNone(stroke)
    if char in special_keys:
        if trace and verbose: g.trace('char', char)
        return
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:', repr(stroke), 'char:',
        repr(event and event.char),
        'ch:', repr(event and event.char),
        'state', state, 'state2', k.unboundKeyAction)
    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if hasattr(c, 'screenCastController') and c.screenCastController:
            c.screenCastController.quit()
        k.masterCommand(commandName='keyboard-quit',
            event=event, func=k.keyboardQuit, stroke=stroke)
        return
    # 2017/01/31: Important support for the demo.py plugin.
    demo = getattr(g.app, 'demo', None)
    if demo:
        # Shortcut everything so that demo-next or demo-prev
        # won't alter of our ivars.
        if k.demoNextKey and stroke == k.demoNextKey:
            if demo.trace: g.trace('demo-next', stroke)
            demo.next_command()
            return
        elif k.demoPrevKey and stroke == k.demoPrevKey:
            if demo.trace: g.trace('demo-prev', stroke)
            demo.prev_command()
            return
    # Always handle modes regardless of vim.
    if k.inState():
        if trace: g.trace('   state %-15s %s' % (state, stroke))
        done = k.doMode(event, state, stroke)
        if done: return
    # Handle vim keys only if not in a state.
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        if trace: g.trace('vc.do_key returns', ok)
        if ok: return
    if traceGC: g.printNewObjects('masterKey 2')
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if w_name.startswith('canvas'):
            # 2016/04/09: experimental.
            if trace: g.trace('plain key in tree')
        elif self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key', stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            k.handleUnboundKeys(event, char, stroke)
            return
    # 2011/02/08: Use getPaneBindings for *all* keys.
    si = k.getPaneBinding(stroke, w)
    if si:
        assert g.isShortcutInfo(si), si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound', stroke, si.func.__name__)
        k.masterCommand(event=event,
            commandName=si.commandName, func=si.func, stroke=si.stroke)
    elif w_name.startswith('canvas'):
        # 2016/04/09: experimental.
        if trace: g.trace('unbound plain key in tree: search')
        k.searchTree(char)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace and trace_unbound: g.trace(' unbound', stroke)
        k.handleUnboundKeys(event, char, stroke)
.. @+node:ekr.20170624151245.1970: *9* << define vars >>
w = event and event.widget
char = event.char if event else ''
stroke = event.stroke if event else ''
w_name = c.widget_name(w)
if w_name.startswith('log'):
    # A hack: send the event to the text part of the log.
    w = event.widget = c.frame.log.logCtrl
state = k.state.kind
special_keys = (
    'Alt_L', 'Alt_R',
    'Caps_Lock', 'Control_L', 'Control_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
)
self.master_key_count += 1
isPlain = k.isPlainKey(stroke)
.. @+node:ekr.20170624151245.1971: *9* k.callStateFunction
def callStateFunction(self, event):
    trace = False and not g.unitTesting
    k, val = self, None
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    if trace: g.trace(k.state.kind, 'ch', ch, 'stroke', stroke,
        'ignore_unbound_non_ascii_keys', k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns', repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b', '\n', '\r', '\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            # if trace: g.trace(k.state.handler.__name__)
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for', k.state.kind)
    return val
.. @+node:ekr.20170624151245.1972: *9* k.doMode
def doMode(self, event, state, stroke):
    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'):
        if k.handleMiniBindings(event, state, stroke):
            return True
    # Second, honor general modes.
    if state == 'getArg':
        k.getArg(event, stroke=stroke)
        return True
    elif state in ('getFileName', 'get-file-name'):
        if trace: g.trace(event, state, stroke)
        k.getFileName(event)
        return True
    elif state in ('full-command', 'auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function', k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns', repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('calling generalModeHandler', stroke)
            k.generalModeHandler(event,
                commandName=si.commandName, func=si.func,
                modeName=state, nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode', stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler', handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
.. @+node:ekr.20170624151245.1973: *9* k.getPaneBinding
def getPaneBinding(self, stroke, w):
    trace = False and not g.unitTesting
    trace_dict = True
    verbose = True
    k = self; w_name = k.c.widget_name(w)
    state = k.unboundKeyAction
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return None
    if trace: g.trace('===== w_name', repr(w_name), 'stroke', stroke,
        # 'w', w,
        'isTextWrapper(w)', g.isTextWrapper(w))
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'), # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        if trace and trace_dict:
            d = k.masterBindingsDict.get(key, {})
            g.trace('key:', key)
            if d:
                g.trace('d.get(%s)' % (stroke))
                g.trace(d.get(stroke))
            
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command', 'insert', 'overwrite') and state == key or # 2010/02/09
            key in ('text', 'all') and g.isTextWrapper(w) or
            key in ('button', 'all')
        ):
            d = k.masterBindingsDict.get(key, {})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key, name, stroke, stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    table = ('previous-line', 'next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case', si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found: %s = %s' % (
                            key, name, repr(si.stroke), si.commandName))
                        return si
    return None
.. @+node:ekr.20170624151245.1974: *9* k.handleDefaultChar
def handleDefaultChar(self, event, stroke):
    '''Handle an unbound key.'''
    trace = False and not g.unitTesting
    verbose = True
    c, k = self.c, self
    w = event and event.widget
    name = c.widget_name(w)
    if trace and verbose:
        g.trace('widget_name', name, 'stroke', stroke,
        'enable alt-ctrl', self.enable_alt_ctrl_bindings)
    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:', stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
    elif name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring', stroke)
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        log_w = event.widget
        if log_w and hasattr(log_w, 'supportsHighLevelInterface'):
            # Send the event to the text widget, not the LeoLog instance.
            i = log_w.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                log_w.insert(i, s)
        elif trace: g.trace('not supportsHighLevelInterface', log_w)
    else:
        pass # Ignore the event
.. @+node:ekr.20170624151245.1975: *9* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    k = self; c = k.c
    trace = False and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    if state in ('getArg', 'full-command'):
        if stroke in ('\b', 'BackSpace', '\r', 'Linefeed', '\n', 'Return', '\t', 'Tab', 'Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key', stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini', 'all', 'text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane), stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane), si.commandName, stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke), 'mini binding', si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName, event=event, func=si.func, stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
.. @+node:ekr.20170624151245.1976: *9* k.handleUnboundKeys
def handleUnboundKeys(self, event, char, stroke):
    trace = False and not g.unitTesting
    verbose = True
    k = self; c = k.c
    modesTuple = ('insert', 'overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char), repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode', stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key', stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode', repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
    elif(not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char), repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char), repr(stroke))
        return
    elif(
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore', stroke)
        return
    else:
        if trace: g.trace('no func', repr(char), repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
.. @+node:ekr.20170624151245.1977: *9* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20170624151245.1978: *9* k.masterCommand & helpers
def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    '''
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    '''
    c, k = self.c, self
    trace = False and not g.unitTesting and g.app.gui.guiName() == 'curses'
    traceGC = False
    traceStroke = True
    # if trace: g.trace(commandName, func)
    if traceGC: g.printNewObjects('masterCom 1')
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke # Set this global for general use.
    char = ch = event.char if event else ''
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
    # Important: it is *not* an error for func to be None.
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    inserted = not special
    if trace and traceStroke: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke, repr(ch), func and func.__name__))
    if inserted:
        k.setLossage(ch, stroke)
    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    if special: # Don't pass these on.
        return
    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event, stroke)
        if expanded: return
    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for', commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly.
            if trace:
                g.trace('calling command directly', commandName)
            c.doCommand(func, commandName, event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
    elif k.inState():
        pass #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        k.handleDefaultChar(event, stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1981: *9* k.searchTree
def searchTree(self, char):
    '''Search all visible nodes for a headline starting with stroke.'''
    trace = False and not g.unitTesting
    if trace: g.trace(char)
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        '''Return True if p contains char.'''
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.
    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if trace: g.trace(p.h)
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            else:
                p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
.. @+node:ekr.20170624151245.1970: *9* << define vars >>
w = event and event.widget
char = event.char if event else ''
stroke = event.stroke if event else ''
w_name = c.widget_name(w)
if w_name.startswith('log'):
    # A hack: send the event to the text part of the log.
    w = event.widget = c.frame.log.logCtrl
state = k.state.kind
special_keys = (
    'Alt_L', 'Alt_R',
    'Caps_Lock', 'Control_L', 'Control_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
)
self.master_key_count += 1
isPlain = k.isPlainKey(stroke)
.. @+node:ekr.20170624151245.1971: *9* k.callStateFunction
def callStateFunction(self, event):
    trace = False and not g.unitTesting
    k, val = self, None
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    if trace: g.trace(k.state.kind, 'ch', ch, 'stroke', stroke,
        'ignore_unbound_non_ascii_keys', k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns', repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b', '\n', '\r', '\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            # if trace: g.trace(k.state.handler.__name__)
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for', k.state.kind)
    return val
.. @+node:ekr.20170624151245.1972: *9* k.doMode
def doMode(self, event, state, stroke):
    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'):
        if k.handleMiniBindings(event, state, stroke):
            return True
    # Second, honor general modes.
    if state == 'getArg':
        k.getArg(event, stroke=stroke)
        return True
    elif state in ('getFileName', 'get-file-name'):
        if trace: g.trace(event, state, stroke)
        k.getFileName(event)
        return True
    elif state in ('full-command', 'auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function', k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns', repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('calling generalModeHandler', stroke)
            k.generalModeHandler(event,
                commandName=si.commandName, func=si.func,
                modeName=state, nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode', stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler', handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
.. @+node:ekr.20170624151245.1973: *9* k.getPaneBinding
def getPaneBinding(self, stroke, w):
    trace = False and not g.unitTesting
    trace_dict = True
    verbose = True
    k = self; w_name = k.c.widget_name(w)
    state = k.unboundKeyAction
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return None
    if trace: g.trace('===== w_name', repr(w_name), 'stroke', stroke,
        # 'w', w,
        'isTextWrapper(w)', g.isTextWrapper(w))
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'), # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        if trace and trace_dict:
            d = k.masterBindingsDict.get(key, {})
            g.trace('key:', key)
            if d:
                g.trace('d.get(%s)' % (stroke))
                g.trace(d.get(stroke))
            
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command', 'insert', 'overwrite') and state == key or # 2010/02/09
            key in ('text', 'all') and g.isTextWrapper(w) or
            key in ('button', 'all')
        ):
            d = k.masterBindingsDict.get(key, {})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key, name, stroke, stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    table = ('previous-line', 'next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case', si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found: %s = %s' % (
                            key, name, repr(si.stroke), si.commandName))
                        return si
    return None
.. @+node:ekr.20170624151245.1974: *9* k.handleDefaultChar
def handleDefaultChar(self, event, stroke):
    '''Handle an unbound key.'''
    trace = False and not g.unitTesting
    verbose = True
    c, k = self.c, self
    w = event and event.widget
    name = c.widget_name(w)
    if trace and verbose:
        g.trace('widget_name', name, 'stroke', stroke,
        'enable alt-ctrl', self.enable_alt_ctrl_bindings)
    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:', stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
    elif name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring', stroke)
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        log_w = event.widget
        if log_w and hasattr(log_w, 'supportsHighLevelInterface'):
            # Send the event to the text widget, not the LeoLog instance.
            i = log_w.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                log_w.insert(i, s)
        elif trace: g.trace('not supportsHighLevelInterface', log_w)
    else:
        pass # Ignore the event
.. @+node:ekr.20170624151245.1975: *9* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    k = self; c = k.c
    trace = False and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    if state in ('getArg', 'full-command'):
        if stroke in ('\b', 'BackSpace', '\r', 'Linefeed', '\n', 'Return', '\t', 'Tab', 'Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key', stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini', 'all', 'text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane), stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane), si.commandName, stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke), 'mini binding', si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName, event=event, func=si.func, stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
.. @+node:ekr.20170624151245.1976: *9* k.handleUnboundKeys
def handleUnboundKeys(self, event, char, stroke):
    trace = False and not g.unitTesting
    verbose = True
    k = self; c = k.c
    modesTuple = ('insert', 'overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char), repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode', stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key', stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode', repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
    elif(not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char), repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char), repr(stroke))
        return
    elif(
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore', stroke)
        return
    else:
        if trace: g.trace('no func', repr(char), repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
.. @+node:ekr.20170624151245.1977: *9* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20170624151245.1978: *9* k.masterCommand & helpers
def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    '''
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    '''
    c, k = self.c, self
    trace = False and not g.unitTesting and g.app.gui.guiName() == 'curses'
    traceGC = False
    traceStroke = True
    # if trace: g.trace(commandName, func)
    if traceGC: g.printNewObjects('masterCom 1')
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke # Set this global for general use.
    char = ch = event.char if event else ''
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
    # Important: it is *not* an error for func to be None.
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    inserted = not special
    if trace and traceStroke: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke, repr(ch), func and func.__name__))
    if inserted:
        k.setLossage(ch, stroke)
    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    if special: # Don't pass these on.
        return
    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event, stroke)
        if expanded: return
    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for', commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly.
            if trace:
                g.trace('calling command directly', commandName)
            c.doCommand(func, commandName, event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
    elif k.inState():
        pass #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        k.handleDefaultChar(event, stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1981: *9* k.searchTree
def searchTree(self, char):
    '''Search all visible nodes for a headline starting with stroke.'''
    trace = False and not g.unitTesting
    if trace: g.trace(char)
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        '''Return True if p contains char.'''
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.
    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if trace: g.trace(p.h)
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            else:
                p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
.. @+node:ekr.20170624151245.1957: *8* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler(self, event):
    '''The master key handler for almost all key bindings.'''
    trace = False and not g.app.unitTesting
    traceGC = False and not g.app.unitTesting
    verbose = True
    trace_unbound = True
    k, c = self, self.c
    c.check_event(event)
    << define vars >>
    assert g.isStrokeOrNone(stroke)
    if char in special_keys:
        if trace and verbose: g.trace('char', char)
        return
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:', repr(stroke), 'char:',
        repr(event and event.char),
        'ch:', repr(event and event.char),
        'state', state, 'state2', k.unboundKeyAction)
    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if hasattr(c, 'screenCastController') and c.screenCastController:
            c.screenCastController.quit()
        k.masterCommand(commandName='keyboard-quit',
            event=event, func=k.keyboardQuit, stroke=stroke)
        return
    # 2017/01/31: Important support for the demo.py plugin.
    demo = getattr(g.app, 'demo', None)
    if demo:
        # Shortcut everything so that demo-next or demo-prev
        # won't alter of our ivars.
        if k.demoNextKey and stroke == k.demoNextKey:
            if demo.trace: g.trace('demo-next', stroke)
            demo.next_command()
            return
        elif k.demoPrevKey and stroke == k.demoPrevKey:
            if demo.trace: g.trace('demo-prev', stroke)
            demo.prev_command()
            return
    # Always handle modes regardless of vim.
    if k.inState():
        if trace: g.trace('   state %-15s %s' % (state, stroke))
        done = k.doMode(event, state, stroke)
        if done: return
    # Handle vim keys only if not in a state.
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        if trace: g.trace('vc.do_key returns', ok)
        if ok: return
    if traceGC: g.printNewObjects('masterKey 2')
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if w_name.startswith('canvas'):
            # 2016/04/09: experimental.
            if trace: g.trace('plain key in tree')
        elif self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key', stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            k.handleUnboundKeys(event, char, stroke)
            return
    # 2011/02/08: Use getPaneBindings for *all* keys.
    si = k.getPaneBinding(stroke, w)
    if si:
        assert g.isShortcutInfo(si), si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound', stroke, si.func.__name__)
        k.masterCommand(event=event,
            commandName=si.commandName, func=si.func, stroke=si.stroke)
    elif w_name.startswith('canvas'):
        # 2016/04/09: experimental.
        if trace: g.trace('unbound plain key in tree: search')
        k.searchTree(char)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace and trace_unbound: g.trace(' unbound', stroke)
        k.handleUnboundKeys(event, char, stroke)
.. @+node:ekr.20170624151245.1970: *9* << define vars >>
w = event and event.widget
char = event.char if event else ''
stroke = event.stroke if event else ''
w_name = c.widget_name(w)
if w_name.startswith('log'):
    # A hack: send the event to the text part of the log.
    w = event.widget = c.frame.log.logCtrl
state = k.state.kind
special_keys = (
    'Alt_L', 'Alt_R',
    'Caps_Lock', 'Control_L', 'Control_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
)
self.master_key_count += 1
isPlain = k.isPlainKey(stroke)
.. @+node:ekr.20170624151245.1971: *9* k.callStateFunction
def callStateFunction(self, event):
    trace = False and not g.unitTesting
    k, val = self, None
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    if trace: g.trace(k.state.kind, 'ch', ch, 'stroke', stroke,
        'ignore_unbound_non_ascii_keys', k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns', repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b', '\n', '\r', '\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            # if trace: g.trace(k.state.handler.__name__)
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for', k.state.kind)
    return val
.. @+node:ekr.20170624151245.1972: *9* k.doMode
def doMode(self, event, state, stroke):
    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'):
        if k.handleMiniBindings(event, state, stroke):
            return True
    # Second, honor general modes.
    if state == 'getArg':
        k.getArg(event, stroke=stroke)
        return True
    elif state in ('getFileName', 'get-file-name'):
        if trace: g.trace(event, state, stroke)
        k.getFileName(event)
        return True
    elif state in ('full-command', 'auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function', k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns', repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('calling generalModeHandler', stroke)
            k.generalModeHandler(event,
                commandName=si.commandName, func=si.func,
                modeName=state, nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode', stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler', handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
.. @+node:ekr.20170624151245.1973: *9* k.getPaneBinding
def getPaneBinding(self, stroke, w):
    trace = False and not g.unitTesting
    trace_dict = True
    verbose = True
    k = self; w_name = k.c.widget_name(w)
    state = k.unboundKeyAction
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return None
    if trace: g.trace('===== w_name', repr(w_name), 'stroke', stroke,
        # 'w', w,
        'isTextWrapper(w)', g.isTextWrapper(w))
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'), # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        if trace and trace_dict:
            d = k.masterBindingsDict.get(key, {})
            g.trace('key:', key)
            if d:
                g.trace('d.get(%s)' % (stroke))
                g.trace(d.get(stroke))
            
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command', 'insert', 'overwrite') and state == key or # 2010/02/09
            key in ('text', 'all') and g.isTextWrapper(w) or
            key in ('button', 'all')
        ):
            d = k.masterBindingsDict.get(key, {})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key, name, stroke, stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    table = ('previous-line', 'next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case', si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found: %s = %s' % (
                            key, name, repr(si.stroke), si.commandName))
                        return si
    return None
.. @+node:ekr.20170624151245.1974: *9* k.handleDefaultChar
def handleDefaultChar(self, event, stroke):
    '''Handle an unbound key.'''
    trace = False and not g.unitTesting
    verbose = True
    c, k = self.c, self
    w = event and event.widget
    name = c.widget_name(w)
    if trace and verbose:
        g.trace('widget_name', name, 'stroke', stroke,
        'enable alt-ctrl', self.enable_alt_ctrl_bindings)
    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:', stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
    elif name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring', stroke)
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        log_w = event.widget
        if log_w and hasattr(log_w, 'supportsHighLevelInterface'):
            # Send the event to the text widget, not the LeoLog instance.
            i = log_w.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                log_w.insert(i, s)
        elif trace: g.trace('not supportsHighLevelInterface', log_w)
    else:
        pass # Ignore the event
.. @+node:ekr.20170624151245.1975: *9* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    k = self; c = k.c
    trace = False and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    if state in ('getArg', 'full-command'):
        if stroke in ('\b', 'BackSpace', '\r', 'Linefeed', '\n', 'Return', '\t', 'Tab', 'Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key', stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini', 'all', 'text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane), stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane), si.commandName, stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke), 'mini binding', si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName, event=event, func=si.func, stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
.. @+node:ekr.20170624151245.1976: *9* k.handleUnboundKeys
def handleUnboundKeys(self, event, char, stroke):
    trace = False and not g.unitTesting
    verbose = True
    k = self; c = k.c
    modesTuple = ('insert', 'overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char), repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode', stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key', stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode', repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
    elif(not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char), repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char), repr(stroke))
        return
    elif(
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore', stroke)
        return
    else:
        if trace: g.trace('no func', repr(char), repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
.. @+node:ekr.20170624151245.1977: *9* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20170624151245.1978: *9* k.masterCommand & helpers
def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    '''
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    '''
    c, k = self.c, self
    trace = False and not g.unitTesting and g.app.gui.guiName() == 'curses'
    traceGC = False
    traceStroke = True
    # if trace: g.trace(commandName, func)
    if traceGC: g.printNewObjects('masterCom 1')
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke # Set this global for general use.
    char = ch = event.char if event else ''
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
    # Important: it is *not* an error for func to be None.
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    inserted = not special
    if trace and traceStroke: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke, repr(ch), func and func.__name__))
    if inserted:
        k.setLossage(ch, stroke)
    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    if special: # Don't pass these on.
        return
    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event, stroke)
        if expanded: return
    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for', commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly.
            if trace:
                g.trace('calling command directly', commandName)
            c.doCommand(func, commandName, event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
    elif k.inState():
        pass #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        k.handleDefaultChar(event, stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1981: *9* k.searchTree
def searchTree(self, char):
    '''Search all visible nodes for a headline starting with stroke.'''
    trace = False and not g.unitTesting
    if trace: g.trace(char)
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        '''Return True if p contains char.'''
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.
    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if trace: g.trace(p.h)
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            else:
                p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
.. @+node:ekr.20170624151245.1970: *9* << define vars >>
w = event and event.widget
char = event.char if event else ''
stroke = event.stroke if event else ''
w_name = c.widget_name(w)
if w_name.startswith('log'):
    # A hack: send the event to the text part of the log.
    w = event.widget = c.frame.log.logCtrl
state = k.state.kind
special_keys = (
    'Alt_L', 'Alt_R',
    'Caps_Lock', 'Control_L', 'Control_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
)
self.master_key_count += 1
isPlain = k.isPlainKey(stroke)
.. @+node:ekr.20170624151245.1971: *9* k.callStateFunction
def callStateFunction(self, event):
    trace = False and not g.unitTesting
    k, val = self, None
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    if trace: g.trace(k.state.kind, 'ch', ch, 'stroke', stroke,
        'ignore_unbound_non_ascii_keys', k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns', repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b', '\n', '\r', '\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            # if trace: g.trace(k.state.handler.__name__)
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for', k.state.kind)
    return val
.. @+node:ekr.20170624151245.1972: *9* k.doMode
def doMode(self, event, state, stroke):
    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'):
        if k.handleMiniBindings(event, state, stroke):
            return True
    # Second, honor general modes.
    if state == 'getArg':
        k.getArg(event, stroke=stroke)
        return True
    elif state in ('getFileName', 'get-file-name'):
        if trace: g.trace(event, state, stroke)
        k.getFileName(event)
        return True
    elif state in ('full-command', 'auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function', k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns', repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('calling generalModeHandler', stroke)
            k.generalModeHandler(event,
                commandName=si.commandName, func=si.func,
                modeName=state, nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode', stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler', handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
.. @+node:ekr.20170624151245.1973: *9* k.getPaneBinding
def getPaneBinding(self, stroke, w):
    trace = False and not g.unitTesting
    trace_dict = True
    verbose = True
    k = self; w_name = k.c.widget_name(w)
    state = k.unboundKeyAction
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return None
    if trace: g.trace('===== w_name', repr(w_name), 'stroke', stroke,
        # 'w', w,
        'isTextWrapper(w)', g.isTextWrapper(w))
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'), # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        if trace and trace_dict:
            d = k.masterBindingsDict.get(key, {})
            g.trace('key:', key)
            if d:
                g.trace('d.get(%s)' % (stroke))
                g.trace(d.get(stroke))
            
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command', 'insert', 'overwrite') and state == key or # 2010/02/09
            key in ('text', 'all') and g.isTextWrapper(w) or
            key in ('button', 'all')
        ):
            d = k.masterBindingsDict.get(key, {})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key, name, stroke, stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    table = ('previous-line', 'next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case', si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found: %s = %s' % (
                            key, name, repr(si.stroke), si.commandName))
                        return si
    return None
.. @+node:ekr.20170624151245.1974: *9* k.handleDefaultChar
def handleDefaultChar(self, event, stroke):
    '''Handle an unbound key.'''
    trace = False and not g.unitTesting
    verbose = True
    c, k = self.c, self
    w = event and event.widget
    name = c.widget_name(w)
    if trace and verbose:
        g.trace('widget_name', name, 'stroke', stroke,
        'enable alt-ctrl', self.enable_alt_ctrl_bindings)
    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:', stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
    elif name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring', stroke)
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        log_w = event.widget
        if log_w and hasattr(log_w, 'supportsHighLevelInterface'):
            # Send the event to the text widget, not the LeoLog instance.
            i = log_w.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                log_w.insert(i, s)
        elif trace: g.trace('not supportsHighLevelInterface', log_w)
    else:
        pass # Ignore the event
.. @+node:ekr.20170624151245.1975: *9* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    k = self; c = k.c
    trace = False and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    if state in ('getArg', 'full-command'):
        if stroke in ('\b', 'BackSpace', '\r', 'Linefeed', '\n', 'Return', '\t', 'Tab', 'Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key', stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini', 'all', 'text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane), stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane), si.commandName, stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke), 'mini binding', si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName, event=event, func=si.func, stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
.. @+node:ekr.20170624151245.1976: *9* k.handleUnboundKeys
def handleUnboundKeys(self, event, char, stroke):
    trace = False and not g.unitTesting
    verbose = True
    k = self; c = k.c
    modesTuple = ('insert', 'overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    if not g.isStroke(stroke):
        g.trace('can not happen: not a stroke', repr(stroke), g.callers())
        return
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char), repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode', stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key', stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode', repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
    elif(not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char), repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char), repr(stroke))
        return
    elif(
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore', stroke)
        return
    else:
        if trace: g.trace('no func', repr(char), repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
.. @+node:ekr.20170624151245.1977: *9* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20170624151245.1978: *9* k.masterCommand & helpers
def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    '''
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    '''
    c, k = self.c, self
    trace = False and not g.unitTesting and g.app.gui.guiName() == 'curses'
    traceGC = False
    traceStroke = True
    # if trace: g.trace(commandName, func)
    if traceGC: g.printNewObjects('masterCom 1')
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke # Set this global for general use.
    char = ch = event.char if event else ''
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
    # Important: it is *not* an error for func to be None.
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    inserted = not special
    if trace and traceStroke: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke, repr(ch), func and func.__name__))
    if inserted:
        k.setLossage(ch, stroke)
    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    if special: # Don't pass these on.
        return
    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event, stroke)
        if expanded: return
    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for', commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly.
            if trace:
                g.trace('calling command directly', commandName)
            c.doCommand(func, commandName, event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
    elif k.inState():
        pass #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        k.handleDefaultChar(event, stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1980: *10* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L', 'Alt_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Caps_Lock', 'Control_L', 'Control_R',
    'Num_Lock',
    'Shift_L', 'Shift_R',
)
.. @+node:ekr.20170624151245.1981: *9* k.searchTree
def searchTree(self, char):
    '''Search all visible nodes for a headline starting with stroke.'''
    trace = False and not g.unitTesting
    if trace: g.trace(char)
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        '''Return True if p contains char.'''
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.
    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if trace: g.trace(p.h)
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            else:
                p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
.. @+node:ekr.20170624151245.1982: *7* k.Minibuffer
# These may be overridden, but this code is now gui-independent.
.. @+node:ekr.20170624151245.1997: *8* k.extendLabel
def extendLabel(self, s, select=False, protect=False):
    trace = False and not g.unitTesting
    k = self; c = k.c; w = self.w
    if not (w and s): return
    if trace: g.trace(s)
    c.widgetWantsFocusNow(w)
    w.insert('end', s)
    if select:
        i, j = k.getEditableTextRange()
        w.setSelectionRange(i, j, insert=j)
    if protect:
        k.protectLabel()
.. @+node:ekr.20170624151245.1998: *8* k.getEditableTextRange
def getEditableTextRange(self):
    k = self; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i, j
.. @+node:ekr.20170624151245.1999: *8* k.getLabel
def getLabel(self, ignorePrompt=False):
    k = self; w = self.w
    if not w: return ''
    s = w.getAllText()
    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
.. @+node:ekr.20170624151245.2000: *8* k.killLine
def killLine(self, protect=True):
    k = self
    w = k.w
    s = w.getAllText()
    s = s[: len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n, n, insert=n)
    if protect:
        k.mb_prefix = s
.. @+node:ekr.20170624151245.2001: *8* k.minibufferWantsFocus
# def minibufferWantsFocus(self):
    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
.. @+node:ekr.20170624151245.2002: *8* k.protectLabel
def protectLabel(self):
    k = self; w = self.w
    if not w: return
    k.mb_prefix = w.getAllText()
.. @+node:ekr.20170624151245.2003: *8* k.resetLabel
def resetLabel(self):
    '''Reset the minibuffer label.'''
    k = self
    c, w = k.c, k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:
        w.setSelectionRange(0, 0, insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label='%s State' % (state.capitalize()))
.. @+node:ekr.20170624151245.2004: *8* k.selectAll
def selectAll(self):
    '''Select all the user-editable text of the minibuffer.'''
    w = self.w
    i, j = self.getEditableTextRange()
    w.setSelectionRange(i, j, insert=j)
.. @+node:ekr.20170624151245.2005: *8* k.setLabel
def setLabel(self, s, protect=False):
    '''Set the label of the minibuffer.'''
    trace = False and not g.app.unitTesting
    k, w = self, self.w
    if w:
        if trace: g.trace(repr(s), g.callers())
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n, n, insert=n)
        if protect:
            k.mb_prefix = s
    elif trace:
        g.trace('*** no w ***')
.. @+node:ekr.20170624151245.2006: *8* k.setLabelBlue
def setLabelBlue(self, label, protect=True):
    '''Set the minibuffer label.'''
    trace = False and not g.unitTesting
    k = self; w = k.w
    if trace: g.trace('label:', label, g.callers())
    if w:
        w.setStyleClass('') # normal state, not warning or error
        if label is not None:
            k.setLabel(label, protect=protect)
    elif trace:
        g.trace('*** no w ***')
.. @+node:ekr.20170624151245.2007: *8* k.setLabelGrey
def setLabelGrey(self, label=None):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_warning')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
.. @+node:ekr.20170624151245.2008: *8* k.setLabelRed
def setLabelRed(self, label=None, protect=False):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_error')
    if label is not None:
        k.setLabel(label, protect)
.. @+node:ekr.20170624151245.2009: *8* k.setStatusLabel
def setStatusLabel(self, s):
    '''
    Set the label to s.

    Use k.setStatusLabel, not k.setLael, to report the status of a Leo
    command. This allows the option to use g.es instead of the minibuffer
    to report status.
    '''
    k = self
    k.setLabel(s, protect=False)
.. @+node:ekr.20170624151245.2010: *8* k.updateLabel
def updateLabel(self, event):
    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumulation.'''
    trace = False or g.trace_minibuffer and not g.app.unitTesting
    k = self; c = k.c; w = self.w
    ch = event.char if event else ''
    if trace: g.trace('ch', ch, 'k.stroke', k.stroke)
    if ch and ch not in ('\n', '\r'):
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i, j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i - 1)
                i -= 1
        else:
            w.insert(ins, ch)
            i = ins + 1
.. @+node:ekr.20170624151245.1997: *8* k.extendLabel
def extendLabel(self, s, select=False, protect=False):
    trace = False and not g.unitTesting
    k = self; c = k.c; w = self.w
    if not (w and s): return
    if trace: g.trace(s)
    c.widgetWantsFocusNow(w)
    w.insert('end', s)
    if select:
        i, j = k.getEditableTextRange()
        w.setSelectionRange(i, j, insert=j)
    if protect:
        k.protectLabel()
.. @+node:ekr.20170624151245.1998: *8* k.getEditableTextRange
def getEditableTextRange(self):
    k = self; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i, j
.. @+node:ekr.20170624151245.1999: *8* k.getLabel
def getLabel(self, ignorePrompt=False):
    k = self; w = self.w
    if not w: return ''
    s = w.getAllText()
    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
.. @+node:ekr.20170624151245.2000: *8* k.killLine
def killLine(self, protect=True):
    k = self
    w = k.w
    s = w.getAllText()
    s = s[: len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n, n, insert=n)
    if protect:
        k.mb_prefix = s
.. @+node:ekr.20170624151245.2001: *8* k.minibufferWantsFocus
# def minibufferWantsFocus(self):
    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
.. @+node:ekr.20170624151245.2002: *8* k.protectLabel
def protectLabel(self):
    k = self; w = self.w
    if not w: return
    k.mb_prefix = w.getAllText()
.. @+node:ekr.20170624151245.2003: *8* k.resetLabel
def resetLabel(self):
    '''Reset the minibuffer label.'''
    k = self
    c, w = k.c, k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:
        w.setSelectionRange(0, 0, insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label='%s State' % (state.capitalize()))
.. @+node:ekr.20170624151245.2004: *8* k.selectAll
def selectAll(self):
    '''Select all the user-editable text of the minibuffer.'''
    w = self.w
    i, j = self.getEditableTextRange()
    w.setSelectionRange(i, j, insert=j)
.. @+node:ekr.20170624151245.2005: *8* k.setLabel
def setLabel(self, s, protect=False):
    '''Set the label of the minibuffer.'''
    trace = False and not g.app.unitTesting
    k, w = self, self.w
    if w:
        if trace: g.trace(repr(s), g.callers())
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n, n, insert=n)
        if protect:
            k.mb_prefix = s
    elif trace:
        g.trace('*** no w ***')
.. @+node:ekr.20170624151245.2006: *8* k.setLabelBlue
def setLabelBlue(self, label, protect=True):
    '''Set the minibuffer label.'''
    trace = False and not g.unitTesting
    k = self; w = k.w
    if trace: g.trace('label:', label, g.callers())
    if w:
        w.setStyleClass('') # normal state, not warning or error
        if label is not None:
            k.setLabel(label, protect=protect)
    elif trace:
        g.trace('*** no w ***')
.. @+node:ekr.20170624151245.2007: *8* k.setLabelGrey
def setLabelGrey(self, label=None):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_warning')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
.. @+node:ekr.20170624151245.2008: *8* k.setLabelRed
def setLabelRed(self, label=None, protect=False):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_error')
    if label is not None:
        k.setLabel(label, protect)
.. @+node:ekr.20170624151245.2009: *8* k.setStatusLabel
def setStatusLabel(self, s):
    '''
    Set the label to s.

    Use k.setStatusLabel, not k.setLael, to report the status of a Leo
    command. This allows the option to use g.es instead of the minibuffer
    to report status.
    '''
    k = self
    k.setLabel(s, protect=False)
.. @+node:ekr.20170624151245.2010: *8* k.updateLabel
def updateLabel(self, event):
    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumulation.'''
    trace = False or g.trace_minibuffer and not g.app.unitTesting
    k = self; c = k.c; w = self.w
    ch = event.char if event else ''
    if trace: g.trace('ch', ch, 'k.stroke', k.stroke)
    if ch and ch not in ('\n', '\r'):
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i, j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i - 1)
                i -= 1
        else:
            w.insert(ins, ch)
            i = ins + 1
.. @+node:ekr.20170624151245.2011: *7* k.Modes (no change)
.. @+node:ekr.20170624151245.2023: *8* k.addModeCommands (enterModeCallback)
def addModeCommands(self):
    '''Add commands created by @mode settings to c.commandsDict.'''
    trace = False and not g.unitTesting
    if trace: g.trace('(k)')
    k = self; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop

        def enterModeCallback(event=None, name=key):
            k.enterNamedMode(event, name)

        c.commandsDict[key] = f = enterModeCallback
        if trace: g.trace(f.__name__, key,
            'len(c.commandsDict.keys())', len(list(c.commandsDict.keys())))
.. @+node:ekr.20170624151245.2024: *8* k.badMode
def badMode(self, modeName):
    k = self
    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[: -5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
.. @+node:ekr.20170624151245.2025: *8* k.createModeBindings
def createModeBindings(self, modeName, d, w):
    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''
    trace = False and not g.unitTesting
    k = self; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*', '*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:', commandName, 'Referenced from', modeName)
            continue
        aList = d.get(commandName, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.ShortcutInfo(
                    kind='mode<%s>' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
.. @+node:ekr.20170624151245.2026: *8* k.endMode
def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane
    k.endCommand(k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
.. @+node:ekr.20170624151245.2027: *8* k.enterNamedMode
def enterNamedMode(self, event, commandName):
    k = self; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event, modeName=modeName)
.. @+node:ekr.20170624151245.2028: *8* k.exitNamedMode
@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    '''Exit an input mode.'''
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
.. @+node:ekr.20170624151245.2029: *8* k.modeHelp & helper (revise helper)
@cmd('mode-help')
def modeHelp(self, event):
    '''The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''
    k = self; c = k.c
    c.endEditing()
    # g.trace(k.inputModeName)
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
.. @+node:ekr.20170624151245.2031: *9* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si), si
                stroke = si.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[: -4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', '%s\n\n' % (prompt.kind.strip()), tabName=tabName)
    else:
        g.es('', '%s mode\n\n' % modeName, tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
.. @+node:ekr.20170624151245.2031: *9* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si), si
                stroke = si.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[: -4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', '%s\n\n' % (prompt.kind.strip()), tabName=tabName)
    else:
        g.es('', '%s mode\n\n' % modeName, tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
.. @+node:ekr.20170624151245.2032: *8* k.reinitMode (call k.createModeBindings???)
def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ') # ,protect=True)
.. @+node:ekr.20170624151245.2033: *8* k.generalModeHandler (OLD)
def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''
    k = self; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting
    if trace: g.trace(modeName, 'state', state)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, None, None, k.modeWidget)
            if trace: g.trace(modeName, 'state', state, commandName, 'nextMode', nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode) # Enter another mode.
.. @+node:ekr.20170624151245.2023: *8* k.addModeCommands (enterModeCallback)
def addModeCommands(self):
    '''Add commands created by @mode settings to c.commandsDict.'''
    trace = False and not g.unitTesting
    if trace: g.trace('(k)')
    k = self; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop

        def enterModeCallback(event=None, name=key):
            k.enterNamedMode(event, name)

        c.commandsDict[key] = f = enterModeCallback
        if trace: g.trace(f.__name__, key,
            'len(c.commandsDict.keys())', len(list(c.commandsDict.keys())))
.. @+node:ekr.20170624151245.2024: *8* k.badMode
def badMode(self, modeName):
    k = self
    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[: -5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
.. @+node:ekr.20170624151245.2025: *8* k.createModeBindings
def createModeBindings(self, modeName, d, w):
    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''
    trace = False and not g.unitTesting
    k = self; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*', '*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:', commandName, 'Referenced from', modeName)
            continue
        aList = d.get(commandName, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.ShortcutInfo(
                    kind='mode<%s>' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
.. @+node:ekr.20170624151245.2026: *8* k.endMode
def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane
    k.endCommand(k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
.. @+node:ekr.20170624151245.2027: *8* k.enterNamedMode
def enterNamedMode(self, event, commandName):
    k = self; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event, modeName=modeName)
.. @+node:ekr.20170624151245.2028: *8* k.exitNamedMode
@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    '''Exit an input mode.'''
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
.. @+node:ekr.20170624151245.2029: *8* k.modeHelp & helper (revise helper)
@cmd('mode-help')
def modeHelp(self, event):
    '''The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''
    k = self; c = k.c
    c.endEditing()
    # g.trace(k.inputModeName)
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
.. @+node:ekr.20170624151245.2031: *9* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si), si
                stroke = si.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[: -4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', '%s\n\n' % (prompt.kind.strip()), tabName=tabName)
    else:
        g.es('', '%s mode\n\n' % modeName, tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
.. @+node:ekr.20170624151245.2031: *9* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si), si
                stroke = si.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[: -4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', '%s\n\n' % (prompt.kind.strip()), tabName=tabName)
    else:
        g.es('', '%s mode\n\n' % modeName, tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
.. @+node:ekr.20170624151245.2032: *8* k.reinitMode (call k.createModeBindings???)
def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ') # ,protect=True)
.. @+node:ekr.20170624151245.2033: *8* k.generalModeHandler (OLD)
def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''
    k = self; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting
    if trace: g.trace(modeName, 'state', state)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, None, None, k.modeWidget)
            if trace: g.trace(modeName, 'state', state, commandName, 'nextMode', nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode) # Enter another mode.
.. @+node:ekr.20170624151245.2034: *7* k.Modes (changed)
.. @+node:ekr.20170624151245.2037: *8* k.initMode (changed)
def initMode(self, event, modeName):
    k = self; c = k.c
    trace = (False or g.trace_modes) and not g.unitTesting
    if not modeName:
        g.trace('oops: no modeName')
        return
    d = g.app.config.modeCommandsDict.get('enter-' + modeName)
    if not d:
        self.badMode(modeName)
        return
    else:
        k.modeBindingsDict = d
        si = d.get('*command-prompt*')
        if si:
            prompt = si.kind # A kludge.
        else:
            prompt = modeName
        if trace: g.trace('modeName: %s prompt: %s d.keys(): %s' % (
            modeName, prompt, sorted(list(d.keys()))))
    k.inputModeName = modeName
    k.silentMode = False
    aList = d.get('*entry-commands*', [])
    if aList:
        for si in aList:
            assert g.isShortcutInfo(si), si
            commandName = si.commandName
            if trace: g.trace('entry command:', commandName)
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                if trace: g.trace('redirect to mode', commandName)
                return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    k.showStateAndMode(prompt=prompt)
.. @+node:ekr.20170624151245.2038: *8* k.NEWgeneralModeHandler (NEW MODES)
def NEWgeneralModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''
    k = self; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting
    if trace: g.trace(modeName, 'state', state)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, None, None, k.modeWidget)
            if trace: g.trace(modeName, 'state', state, commandName, 'nextMode', nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                # if g.app.quitting or not c.exists: return
.. @+node:ekr.20170624151245.2037: *8* k.initMode (changed)
def initMode(self, event, modeName):
    k = self; c = k.c
    trace = (False or g.trace_modes) and not g.unitTesting
    if not modeName:
        g.trace('oops: no modeName')
        return
    d = g.app.config.modeCommandsDict.get('enter-' + modeName)
    if not d:
        self.badMode(modeName)
        return
    else:
        k.modeBindingsDict = d
        si = d.get('*command-prompt*')
        if si:
            prompt = si.kind # A kludge.
        else:
            prompt = modeName
        if trace: g.trace('modeName: %s prompt: %s d.keys(): %s' % (
            modeName, prompt, sorted(list(d.keys()))))
    k.inputModeName = modeName
    k.silentMode = False
    aList = d.get('*entry-commands*', [])
    if aList:
        for si in aList:
            assert g.isShortcutInfo(si), si
            commandName = si.commandName
            if trace: g.trace('entry command:', commandName)
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                if trace: g.trace('redirect to mode', commandName)
                return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    k.showStateAndMode(prompt=prompt)
.. @+node:ekr.20170624151245.2038: *8* k.NEWgeneralModeHandler (NEW MODES)
def NEWgeneralModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''
    k = self; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting
    if trace: g.trace(modeName, 'state', state)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, None, None, k.modeWidget)
            if trace: g.trace(modeName, 'state', state, commandName, 'nextMode', nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                # if g.app.quitting or not c.exists: return
.. @+node:ekr.20170624151245.2039: *7* k.Shortcuts & bindings
.. @+node:ekr.20170624151245.2059: *8* k.computeInverseBindingDict
def computeInverseBindingDict(self):
    k = self
    d = {}
        # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        aList = k.bindingsDict.get(stroke, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            shortcutList = k.bindingsDict.get(si.commandName, [])
                # Bug fix: 2017/03/26.
            aList = k.bindingsDict.get(stroke, g.ShortcutInfo(kind='dummy', pane='all'))
                # Important: only si.pane is required below.
            for si in aList:
                assert g.isShortcutInfo(si), si
                pane = '%s:' % (si.pane)
                data = (pane, stroke)
                if data not in shortcutList:
                    shortcutList.append(data)
            d[si.commandName] = shortcutList
    return d
.. @+node:ekr.20170624151245.2060: *8* k.getShortcutForCommand/Name
def getShortcutForCommandName(self, commandName):
    k = self; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke), repr(stroke)
            aList = k.bindingsDict.get(stroke, [])
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.commandName == commandName:
                    return stroke
    return None

def getShortcutForCommand(self, command):
    k = self
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke), repr(stroke)
            aList = k.bindingsDict.get(stroke, [])
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.commandName == command.__name__:
                    return stroke
    return None
.. @+node:ekr.20170624151245.2061: *8* k.isFKey
def isFKey(self, stroke):
    # k = self
    if not stroke: return False
    assert g.isString(stroke) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
.. @+node:ekr.20170624151245.2062: *8* k.isPlainKey
def isPlainKey(self, stroke):
    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''
    trace = False and not g.unitTesting
    k = self
    if not stroke:
        return False
    assert g.isString(stroke) or g.isStroke(stroke)
    shortcut = stroke.s if g.isStroke(stroke) else stroke
    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True
    for z in ('Alt', 'Ctrl', 'Command', 'Meta'):
        if shortcut.find(z) != -1:
            return False
    # Careful, allow bare angle brackets for unit tests.
    if shortcut.startswith('<') and shortcut.endswith('>'):
        shortcut = shortcut[1: -1]
    isPlain = (
        len(shortcut) == 1 or
        len(k.guiBindNamesInverseDict.get(shortcut, '')) == 1 or
        # A hack: allow Return to be bound to command.
        shortcut in ('Tab', '\t')
    )
    if trace: g.trace(isPlain,repr(shortcut))
    return isPlain and not self.isFKey(shortcut)
.. @+node:ekr.20170624151245.2063: *8* k.prettyPrintKey
def prettyPrintKey(self, stroke, brief=False):
    trace = False and not g.unitTesting
    k = self
    if not stroke:
        s = ''
    elif g.isStroke(stroke):
        s = stroke.s
    else:
        s = stroke
    if not s: return ''
    shift = s.find("shift") >= 0 or s.find("shft") >= 0
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[: -1].replace('-', '+') + '-'
    else: s = s.replace('-', '+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields', fields)
    if last and len(last) == 1:
        prev = s[: -1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last, last)
        if fields and fields[: -1]:
            s = '%s+%s' % ('+'.join(fields[: -1]), last)
        else:
            s = last
    if s.endswith(' '):
        s = s[: -1] + 'Space' # 2010/11/06
    return s
.. @+node:ekr.20170624151245.2064: *8* k.setLossage
def setLossage(self, ch, stroke):
    trace = False and not g.unitTesting
    # k = self
    if trace: g.trace(repr(stroke), g.callers())
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
.. @+node:ekr.20170624151245.2065: *8* k.stroke2char
def stroke2char(self, stroke):
    '''
    Convert a stroke to an (insertable) char.
    This method allows Leo to use strokes everywhere.
    '''
    # pylint: disable=len-as-condition
    trace = False and not g.unitTesting
    trace = trace and stroke.lower().find('1') > -1
    k = self
    if not stroke: return ''
    s = stroke.s if g.isStroke(stroke) else stroke
    # Allow bare angle brackets for unit tests.
    if s.startswith('<') and s.endswith('>'):
        s = s[1: -1]
    if len(s) == 0: return ''
    if len(s) == 1: return s
    for z in ('Alt', 'Ctrl', 'Command', 'Meta'):
        if s.find(z) != -1:
            return ''
            # This is not accurate: LeoQtEventFilter retains
            # the spelling of Alt-Ctrl keys because of the
            # @bool enable_alt_ctrl_bindings setting.
    # Special case the gang of four, plus 'Escape', 'PageDn', 'PageUp',
    d = {
        'BackSpace': '\b',
        'Escape': 'Escape',
        'Linefeed': '\r',
        'PageDn': 'Next', # Fix #416.
        'PageUp': 'Prior', # Fix #416.
        'Return': '\n',
        'Tab': '\t',
    }
    ch = d.get(s)
    if ch: return ch
    # First, do the common translations.
    ch = k.guiBindNamesInverseDict.get(s)
    if ch:
        if trace: g.trace(repr(stroke), repr(ch))
        return ch
    # A much-simplified form of code in k.strokeFromSetting.
    shift = s.find('Shift+') > -1 or s.find('Shift-') > -1
    s = s.replace('Shift+', '').replace('Shift-', '')
    last = s #  Everything should have been stripped.
    if len(s) == 1 and s.isalpha():
        if shift:
            s = last.upper()
        else:
            s = last.lower()
    val = s if len(s) == 1 else ''
    if trace: g.trace(repr(stroke), repr(val)) # 'shift',shift,
    return val
.. @+node:ekr.20170624151245.2066: *8* k.strokeFromSetting (changed in Leo 5.3)
def strokeFromSetting(self, setting):
    k = self
    trace = False and not g.unitTesting
    trace = trace and setting.lower().find('1') > -1
    verbose = False
    if not setting:
        return None
    assert g.isString(setting)
    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    if trace and verbose:
        g.trace('%20s %s' % (setting, shortcut), g.callers())
    return g.KeyStroke(shortcut) if shortcut else None

canonicalizeShortcut = strokeFromSetting # For compatibility.
.. @+node:ekr.20170624151245.2072: *9* << define cmd, ctrl, alt, shift >>
s2 = s.lower()
cmd = s2.find("cmd") >= 0 or s2.find("command") >= 0
ctrl = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt = s2.find("alt") >= 0
shift = s2.find("shift") >= 0 or s2.find("shft") >= 0
meta = s2.find("meta") >= 0
.. @+node:ekr.20170624151245.2073: *9* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True; ctrl = False
if alt and not ctrl:
    ctrl = True; alt = False
.. @+node:ekr.20170624151245.2074: *9* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[: -1].replace('-', '+') + '-'
else:
    s = s.replace('-', '+')
.. @+node:ekr.20170624151245.2075: *9* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s), repr(setting))
            g.trace(g.callers())
        return None
if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        # New in Leo 5.3: 2016/04/12: a major bug fix, with new unit test.
        if (cmd or ctrl or alt or shift) and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(), last)
.. @+node:ekr.20170624151245.2076: *9* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl, 'Ctrl+'),
    (cmd, 'Command+'),
    (meta, 'Meta+'),
    (shift, 'Shift+'),
    (True, last),
)
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag, val in table if flag])
.. @+node:ekr.20170624151245.2072: *9* << define cmd, ctrl, alt, shift >>
s2 = s.lower()
cmd = s2.find("cmd") >= 0 or s2.find("command") >= 0
ctrl = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt = s2.find("alt") >= 0
shift = s2.find("shift") >= 0 or s2.find("shft") >= 0
meta = s2.find("meta") >= 0
.. @+node:ekr.20170624151245.2073: *9* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True; ctrl = False
if alt and not ctrl:
    ctrl = True; alt = False
.. @+node:ekr.20170624151245.2074: *9* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[: -1].replace('-', '+') + '-'
else:
    s = s.replace('-', '+')
.. @+node:ekr.20170624151245.2075: *9* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s), repr(setting))
            g.trace(g.callers())
        return None
if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        # New in Leo 5.3: 2016/04/12: a major bug fix, with new unit test.
        if (cmd or ctrl or alt or shift) and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(), last)
.. @+node:ekr.20170624151245.2076: *9* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl, 'Ctrl+'),
    (cmd, 'Command+'),
    (meta, 'Meta+'),
    (shift, 'Shift+'),
    (True, last),
)
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag, val in table if flag])
.. @+node:ekr.20170624151245.2077: *8* k.traceBinding (not used)
def traceBinding(self, si, shortcut, w):
    k = self; c = k.c; gui = g.app.gui
    if not c.config.getBool('trace_bindings'): return
    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return
    pane_filter = c.config.getString('trace_bindings_pane_filter')
    if not pane_filter or pane_filter.lower() == si.pane:
        g.trace(si.pane, shortcut, si.commandName, gui.widget_name(w))
.. @+node:ekr.20170624151245.2059: *8* k.computeInverseBindingDict
def computeInverseBindingDict(self):
    k = self
    d = {}
        # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        aList = k.bindingsDict.get(stroke, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            shortcutList = k.bindingsDict.get(si.commandName, [])
                # Bug fix: 2017/03/26.
            aList = k.bindingsDict.get(stroke, g.ShortcutInfo(kind='dummy', pane='all'))
                # Important: only si.pane is required below.
            for si in aList:
                assert g.isShortcutInfo(si), si
                pane = '%s:' % (si.pane)
                data = (pane, stroke)
                if data not in shortcutList:
                    shortcutList.append(data)
            d[si.commandName] = shortcutList
    return d
.. @+node:ekr.20170624151245.2060: *8* k.getShortcutForCommand/Name
def getShortcutForCommandName(self, commandName):
    k = self; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke), repr(stroke)
            aList = k.bindingsDict.get(stroke, [])
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.commandName == commandName:
                    return stroke
    return None

def getShortcutForCommand(self, command):
    k = self
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke), repr(stroke)
            aList = k.bindingsDict.get(stroke, [])
            for si in aList:
                assert g.isShortcutInfo(si), si
                if si.commandName == command.__name__:
                    return stroke
    return None
.. @+node:ekr.20170624151245.2061: *8* k.isFKey
def isFKey(self, stroke):
    # k = self
    if not stroke: return False
    assert g.isString(stroke) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
.. @+node:ekr.20170624151245.2062: *8* k.isPlainKey
def isPlainKey(self, stroke):
    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''
    trace = False and not g.unitTesting
    k = self
    if not stroke:
        return False
    assert g.isString(stroke) or g.isStroke(stroke)
    shortcut = stroke.s if g.isStroke(stroke) else stroke
    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True
    for z in ('Alt', 'Ctrl', 'Command', 'Meta'):
        if shortcut.find(z) != -1:
            return False
    # Careful, allow bare angle brackets for unit tests.
    if shortcut.startswith('<') and shortcut.endswith('>'):
        shortcut = shortcut[1: -1]
    isPlain = (
        len(shortcut) == 1 or
        len(k.guiBindNamesInverseDict.get(shortcut, '')) == 1 or
        # A hack: allow Return to be bound to command.
        shortcut in ('Tab', '\t')
    )
    if trace: g.trace(isPlain,repr(shortcut))
    return isPlain and not self.isFKey(shortcut)
.. @+node:ekr.20170624151245.2063: *8* k.prettyPrintKey
def prettyPrintKey(self, stroke, brief=False):
    trace = False and not g.unitTesting
    k = self
    if not stroke:
        s = ''
    elif g.isStroke(stroke):
        s = stroke.s
    else:
        s = stroke
    if not s: return ''
    shift = s.find("shift") >= 0 or s.find("shft") >= 0
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[: -1].replace('-', '+') + '-'
    else: s = s.replace('-', '+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields', fields)
    if last and len(last) == 1:
        prev = s[: -1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last, last)
        if fields and fields[: -1]:
            s = '%s+%s' % ('+'.join(fields[: -1]), last)
        else:
            s = last
    if s.endswith(' '):
        s = s[: -1] + 'Space' # 2010/11/06
    return s
.. @+node:ekr.20170624151245.2064: *8* k.setLossage
def setLossage(self, ch, stroke):
    trace = False and not g.unitTesting
    # k = self
    if trace: g.trace(repr(stroke), g.callers())
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
.. @+node:ekr.20170624151245.2065: *8* k.stroke2char
def stroke2char(self, stroke):
    '''
    Convert a stroke to an (insertable) char.
    This method allows Leo to use strokes everywhere.
    '''
    # pylint: disable=len-as-condition
    trace = False and not g.unitTesting
    trace = trace and stroke.lower().find('1') > -1
    k = self
    if not stroke: return ''
    s = stroke.s if g.isStroke(stroke) else stroke
    # Allow bare angle brackets for unit tests.
    if s.startswith('<') and s.endswith('>'):
        s = s[1: -1]
    if len(s) == 0: return ''
    if len(s) == 1: return s
    for z in ('Alt', 'Ctrl', 'Command', 'Meta'):
        if s.find(z) != -1:
            return ''
            # This is not accurate: LeoQtEventFilter retains
            # the spelling of Alt-Ctrl keys because of the
            # @bool enable_alt_ctrl_bindings setting.
    # Special case the gang of four, plus 'Escape', 'PageDn', 'PageUp',
    d = {
        'BackSpace': '\b',
        'Escape': 'Escape',
        'Linefeed': '\r',
        'PageDn': 'Next', # Fix #416.
        'PageUp': 'Prior', # Fix #416.
        'Return': '\n',
        'Tab': '\t',
    }
    ch = d.get(s)
    if ch: return ch
    # First, do the common translations.
    ch = k.guiBindNamesInverseDict.get(s)
    if ch:
        if trace: g.trace(repr(stroke), repr(ch))
        return ch
    # A much-simplified form of code in k.strokeFromSetting.
    shift = s.find('Shift+') > -1 or s.find('Shift-') > -1
    s = s.replace('Shift+', '').replace('Shift-', '')
    last = s #  Everything should have been stripped.
    if len(s) == 1 and s.isalpha():
        if shift:
            s = last.upper()
        else:
            s = last.lower()
    val = s if len(s) == 1 else ''
    if trace: g.trace(repr(stroke), repr(val)) # 'shift',shift,
    return val
.. @+node:ekr.20170624151245.2066: *8* k.strokeFromSetting (changed in Leo 5.3)
def strokeFromSetting(self, setting):
    k = self
    trace = False and not g.unitTesting
    trace = trace and setting.lower().find('1') > -1
    verbose = False
    if not setting:
        return None
    assert g.isString(setting)
    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    if trace and verbose:
        g.trace('%20s %s' % (setting, shortcut), g.callers())
    return g.KeyStroke(shortcut) if shortcut else None

canonicalizeShortcut = strokeFromSetting # For compatibility.
.. @+node:ekr.20170624151245.2072: *9* << define cmd, ctrl, alt, shift >>
s2 = s.lower()
cmd = s2.find("cmd") >= 0 or s2.find("command") >= 0
ctrl = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt = s2.find("alt") >= 0
shift = s2.find("shift") >= 0 or s2.find("shft") >= 0
meta = s2.find("meta") >= 0
.. @+node:ekr.20170624151245.2073: *9* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True; ctrl = False
if alt and not ctrl:
    ctrl = True; alt = False
.. @+node:ekr.20170624151245.2074: *9* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[: -1].replace('-', '+') + '-'
else:
    s = s.replace('-', '+')
.. @+node:ekr.20170624151245.2075: *9* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s), repr(setting))
            g.trace(g.callers())
        return None
if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        # New in Leo 5.3: 2016/04/12: a major bug fix, with new unit test.
        if (cmd or ctrl or alt or shift) and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(), last)
.. @+node:ekr.20170624151245.2076: *9* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl, 'Ctrl+'),
    (cmd, 'Command+'),
    (meta, 'Meta+'),
    (shift, 'Shift+'),
    (True, last),
)
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag, val in table if flag])
.. @+node:ekr.20170624151245.2072: *9* << define cmd, ctrl, alt, shift >>
s2 = s.lower()
cmd = s2.find("cmd") >= 0 or s2.find("command") >= 0
ctrl = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt = s2.find("alt") >= 0
shift = s2.find("shift") >= 0 or s2.find("shft") >= 0
meta = s2.find("meta") >= 0
.. @+node:ekr.20170624151245.2073: *9* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True; ctrl = False
if alt and not ctrl:
    ctrl = True; alt = False
.. @+node:ekr.20170624151245.2074: *9* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[: -1].replace('-', '+') + '-'
else:
    s = s.replace('-', '+')
.. @+node:ekr.20170624151245.2075: *9* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s), repr(setting))
            g.trace(g.callers())
        return None
if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        # New in Leo 5.3: 2016/04/12: a major bug fix, with new unit test.
        if (cmd or ctrl or alt or shift) and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(), last)
.. @+node:ekr.20170624151245.2076: *9* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl, 'Ctrl+'),
    (cmd, 'Command+'),
    (meta, 'Meta+'),
    (shift, 'Shift+'),
    (True, last),
)
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag, val in table if flag])
.. @+node:ekr.20170624151245.2077: *8* k.traceBinding (not used)
def traceBinding(self, si, shortcut, w):
    k = self; c = k.c; gui = g.app.gui
    if not c.config.getBool('trace_bindings'): return
    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return
    pane_filter = c.config.getString('trace_bindings_pane_filter')
    if not pane_filter or pane_filter.lower() == si.pane:
        g.trace(si.pane, shortcut, si.commandName, gui.widget_name(w))
.. @+node:ekr.20170624151245.2078: *7* k.States
.. @+node:ekr.20170624151245.2090: *8* k.clearState
def clearState(self):
    '''Clear the key handler state.'''
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
.. @+node:ekr.20170624151245.2091: *8* k.getState
def getState(self, kind):
    k = self
    val = k.state.n if k.state.kind == kind else 0
    # g.trace(state,'returns',val)
    return val
.. @+node:ekr.20170624151245.2092: *8* k.getStateHandler
def getStateHandler(self):
    return self.state.handler
.. @+node:ekr.20170624151245.2093: *8* k.getStateKind
def getStateKind(self):
    return self.state.kind
.. @+node:ekr.20170624151245.2094: *8* k.inState
def inState(self, kind=None):
    k = self
    if kind:
        return k.state.kind == kind and k.state.n is not None
    else:
        return k.state.kind and k.state.n is not None
.. @+node:ekr.20170624151245.2095: *8* k.setDefaultInputState
def setDefaultInputState(self):
    k = self; state = k.defaultUnboundKeyAction
    # g.trace(state)
    k.setInputState(state)
.. @+node:ekr.20170624151245.2096: *8* k.setEditingState
def setEditingState(self):
    k = self; state = k.defaultEditingAction
    # g.trace(state)
    k.setInputState(state)
.. @+node:ekr.20170624151245.2097: *8* k.setInputState
def setInputState(self, state, set_border=False):
    k = self
    k.unboundKeyAction = state
.. @+node:ekr.20170624151245.2098: *8* k.setState
def setState(self, kind, n, handler=None):
    trace = False and not g.unitTesting
    k = self
    if kind and n is not None:
        if trace: g.trace('**** setting %s %s %s' % (
            kind, n, handler and handler.__name__), g.callers())
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        if trace: g.trace('clearing')
        k.clearState()
    # k.showStateAndMode()
.. @+node:ekr.20170624151245.2099: *8* k.showStateAndMode
def showStateAndMode(self, w=None, prompt=None, setFocus=True):
    '''Show the state and mode at the start of the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    state = k.unboundKeyAction
    mode = k.getStateKind()
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
    isText = g.isTextWrapper(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree, 'getWrapper'):
            if hasattr(w, 'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2, item=None)
            isText = bool(w) # A benign hack.
    if trace: g.trace('state: %s, text?: %s, w: %s' % (state, isText, w))
    if mode:
        if mode in ('getArg', 'getFileName', 'full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[: -5]
            s = '%s Mode' % mode.capitalize()
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    if trace: g.trace(repr(s))
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state, w)
    # 2015/07/11: reset the status line.
    if hasattr(c.frame.tree, 'set_status_line'):
        c.frame.tree.set_status_line(c.p)
.. @+node:ekr.20170624151245.2100: *8* k.showStateCursor
def showStateCursor(self, state, w):
    # g.trace(state,w)
    pass
.. @+node:ekr.20170624151245.2090: *8* k.clearState
def clearState(self):
    '''Clear the key handler state.'''
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
.. @+node:ekr.20170624151245.2091: *8* k.getState
def getState(self, kind):
    k = self
    val = k.state.n if k.state.kind == kind else 0
    # g.trace(state,'returns',val)
    return val
.. @+node:ekr.20170624151245.2092: *8* k.getStateHandler
def getStateHandler(self):
    return self.state.handler
.. @+node:ekr.20170624151245.2093: *8* k.getStateKind
def getStateKind(self):
    return self.state.kind
.. @+node:ekr.20170624151245.2094: *8* k.inState
def inState(self, kind=None):
    k = self
    if kind:
        return k.state.kind == kind and k.state.n is not None
    else:
        return k.state.kind and k.state.n is not None
.. @+node:ekr.20170624151245.2095: *8* k.setDefaultInputState
def setDefaultInputState(self):
    k = self; state = k.defaultUnboundKeyAction
    # g.trace(state)
    k.setInputState(state)
.. @+node:ekr.20170624151245.2096: *8* k.setEditingState
def setEditingState(self):
    k = self; state = k.defaultEditingAction
    # g.trace(state)
    k.setInputState(state)
.. @+node:ekr.20170624151245.2097: *8* k.setInputState
def setInputState(self, state, set_border=False):
    k = self
    k.unboundKeyAction = state
.. @+node:ekr.20170624151245.2098: *8* k.setState
def setState(self, kind, n, handler=None):
    trace = False and not g.unitTesting
    k = self
    if kind and n is not None:
        if trace: g.trace('**** setting %s %s %s' % (
            kind, n, handler and handler.__name__), g.callers())
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        if trace: g.trace('clearing')
        k.clearState()
    # k.showStateAndMode()
.. @+node:ekr.20170624151245.2099: *8* k.showStateAndMode
def showStateAndMode(self, w=None, prompt=None, setFocus=True):
    '''Show the state and mode at the start of the minibuffer.'''
    trace = False and not g.unitTesting
    c, k = self.c, self
    state = k.unboundKeyAction
    mode = k.getStateKind()
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
    isText = g.isTextWrapper(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree, 'getWrapper'):
            if hasattr(w, 'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2, item=None)
            isText = bool(w) # A benign hack.
    if trace: g.trace('state: %s, text?: %s, w: %s' % (state, isText, w))
    if mode:
        if mode in ('getArg', 'getFileName', 'full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[: -5]
            s = '%s Mode' % mode.capitalize()
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    if trace: g.trace(repr(s))
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state, w)
    # 2015/07/11: reset the status line.
    if hasattr(c.frame.tree, 'set_status_line'):
        c.frame.tree.set_status_line(c.p)
.. @+node:ekr.20170624151245.2100: *8* k.showStateCursor
def showStateCursor(self, state, w):
    # g.trace(state,w)
    pass
.. @+node:ekr.20170624151245.2101: *7* k.universalDispatcher & helpers
def universalDispatcher(self, event):
    '''Handle accumulation of universal argument.'''
    << about repeat counts >>
    k = self
    state = k.getState('u-arg')
    stroke = event.stroke if event else ''
    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg', 1, k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        char = event.char if event else ''
        if char == 'Escape':
            k.keyboardQuit()
        elif char == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif char.isdigit() or char == '-':
            k.updateLabel(event)
        elif char in (
            'Alt_L', 'Alt_R',
            'Control_L', 'Control_R',
            'Meta_L', 'Meta_R',
            'Shift_L', 'Shift_R',
        ):
            k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try: n = int(val) * k.repeatCount
            except ValueError: n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event, n)
            k.keyboardQuit()
    elif state == 2:
        k.doControlU(event, stroke)
.. @+node:ekr.20170624151245.2105: *8* << about repeat counts >>
@nocolor
@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
.. @+node:ekr.20170624151245.2106: *8* k.executeNTimes
def executeNTimes(self, event, n):
    trace = False and not g.unitTesting
    c, k = self.c, self
    w = event and event.widget
    stroke = event.stroke if event else ''
    if not stroke: return
    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand(event)
    else:
        si = k.getPaneBinding(stroke, event and event.widget)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('repeat', n, 'method', si.func.__name__,
                'stroke', stroke, 'widget', w)
            for z in range(n):
                event = g.app.gui.create_key_event(c, None, event, stroke, w)
                k.masterCommand(commandName=None, event=event, func=si.func, stroke=stroke)
        else:
            for z in range(n):
                k.masterKeyHandler(event)
.. @+node:ekr.20170624151245.2107: *8* doControlU
def doControlU(self, event, stroke):
    k = self
    ch = event.char if event else ''
    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))
    if ch == '(':
        k.clearState()
        k.resetLabel()
.. @+node:ekr.20170624151245.2105: *8* << about repeat counts >>
@nocolor
@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
.. @+node:ekr.20170624151245.2106: *8* k.executeNTimes
def executeNTimes(self, event, n):
    trace = False and not g.unitTesting
    c, k = self.c, self
    w = event and event.widget
    stroke = event.stroke if event else ''
    if not stroke: return
    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand(event)
    else:
        si = k.getPaneBinding(stroke, event and event.widget)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('repeat', n, 'method', si.func.__name__,
                'stroke', stroke, 'widget', w)
            for z in range(n):
                event = g.app.gui.create_key_event(c, None, event, stroke, w)
                k.masterCommand(commandName=None, event=event, func=si.func, stroke=stroke)
        else:
            for z in range(n):
                k.masterKeyHandler(event)
.. @+node:ekr.20170624151245.2107: *8* doControlU
def doControlU(self, event, stroke):
    k = self
    ch = event.char if event else ''
    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))
    if ch == '(':
        k.clearState()
        k.resetLabel()
.. @+node:ekr.20170624151245.2108: *6* class LeoGui
class LeoGui(object):
    """The base class of all gui classes.

    Subclasses are expected to override all do-nothing methods of this class.
    """
    @others
.. @+node:ekr.20170624151245.2171: *7* LeoGui.__init__
def __init__(self, guiName):
    '''Ctor for the LeoGui class.'''
    # g.trace("LeoGui",guiName,g.callers())
    self.active = None # Used only by qt_gui.
    self.consoleOnly = True # True if g.es goes to console.
    self.globalFindTabManager = None
    self.globalFindDialog = None
    self.globalFindTab = None
    self.idleTimeClass = None
    self.isNullGui = False
    self.lastFrame = None
    self.leoIcon = None
    self.mGuiName = guiName
    self.mainLoop = None
    self.plainTextWidget = None
        # For SpellTabHandler class only.
    self.root = None
    self.script = None
    self.splashScreen = None
    self.trace = False
    self.utils = None
    # To keep pylint happy.
    self.ScriptingControllerClass = NullScriptingControllerClass
.. @+node:ekr.20170624151245.2172: *7* LeoGui: Must be defined only in base class
.. @+node:ekr.20170624151245.2177: *8* LeoGui.create_key_event (LeoGui)
def create_key_event(self, c, char, stroke, w, event=None, x=None, y=None, x_root=None, y_root=None):
    # Do not call strokeFromSetting here!
    # For example, this would wrongly convert Ctrl-C to Ctrl-c,
    # in effect, converting a user binding from Ctrl-Shift-C to Ctrl-C.
    return LeoKeyEvent(c, char, event, stroke, w, x, y, x_root, y_root)
.. @+node:ekr.20170624151245.2178: *8* LeoGui.guiName
def guiName(self):
    try:
        return self.mGuiName
    except Exception:
        return "invalid gui name"
.. @+node:ekr.20170624151245.2179: *8* LeoGui.setScript
def setScript(self, script=None, scriptFileName=None):
    self.script = script
    self.scriptFileName = scriptFileName
.. @+node:ekr.20170624151245.2180: *8* LeoGui.event_generate (LeoGui)
def event_generate(self, c, char, shortcut, w):
    event = self.create_key_event(c, char, shortcut, w)
    c.k.masterKeyHandler(event)
    c.outerUpdate()
.. @+node:ekr.20170624151245.2177: *8* LeoGui.create_key_event (LeoGui)
def create_key_event(self, c, char, stroke, w, event=None, x=None, y=None, x_root=None, y_root=None):
    # Do not call strokeFromSetting here!
    # For example, this would wrongly convert Ctrl-C to Ctrl-c,
    # in effect, converting a user binding from Ctrl-Shift-C to Ctrl-C.
    return LeoKeyEvent(c, char, event, stroke, w, x, y, x_root, y_root)
.. @+node:ekr.20170624151245.2178: *8* LeoGui.guiName
def guiName(self):
    try:
        return self.mGuiName
    except Exception:
        return "invalid gui name"
.. @+node:ekr.20170624151245.2179: *8* LeoGui.setScript
def setScript(self, script=None, scriptFileName=None):
    self.script = script
    self.scriptFileName = scriptFileName
.. @+node:ekr.20170624151245.2180: *8* LeoGui.event_generate (LeoGui)
def event_generate(self, c, char, shortcut, w):
    event = self.create_key_event(c, char, shortcut, w)
    c.k.masterKeyHandler(event)
    c.outerUpdate()
.. @+node:ekr.20170624151245.2181: *7* LeoGu: Must be defined in subclasses
.. @+node:ekr.20170624151245.2200: *8* LeoGui.destroySelf
def destroySelf(self):
    self.oops()
.. @+node:ekr.20170624151245.2201: *8* LeoGui.dialogs
def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    """Create and run Leo's About Leo dialog."""
    self.oops()

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self, c, title, message, cancelButtonText=None, okButtonText=None):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskOkCancelStringDialog(self, c, title, message, cancelButtonText=None,
                               okButtonText=None, default="", wide=False):
    """Create and run askOkCancelString dialog ."""
    self.oops()

def runAskYesNoDialog(self, c, title, message=None, yes_all=False, no_all=False):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self, c, title,
    message=None, yesMessage="Yes", noMessage="No",
    yesToAllMessage=None, defaultButton="Yes", cancelMessage=None,
):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()

def runPropertiesDialog(self, title='Properties', data=None, callback=None, buttons=None):
    """Dispay a modal TkPropertiesDialog"""
    self.oops()
.. @+node:ekr.20170624151245.2202: *8* LeoGui.file dialogs
def runOpenFileDialog(self, c, title, filetypes, defaultextension, multiple=False, startpath=None):
    """Create and run an open file dialog ."""
    self.oops()

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    """Create and run a save file dialog ."""
    self.oops()
.. @+node:ekr.20170624151245.2203: *8* LeoGui.panels
def createColorPanel(self, c):
    """Create a color panel"""
    self.oops()

def createComparePanel(self, c):
    """Create Compare panel."""
    self.oops()

def createFindTab(self, c, parentFrame):
    """Create a find tab in the indicated frame."""
    self.oops()

def createFontPanel(self, c):
    """Create a hidden Font panel."""
    self.oops()

def createLeoFrame(self, c, title):
    """Create a new Leo frame."""
    self.oops()
.. @+node:ekr.20170624151245.2204: *8* LeoGui.runMainLoop
def runMainLoop(self):
    """Run the gui's main loop."""
    self.oops()
.. @+node:ekr.20170624151245.2205: *8* LeoGui.utils
@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for
None returns.

The type of commander passed to methods depends on the type of frame
or dialog being created. The commander may be a Commands instance or
one of its subcommanders.
.. @+node:ekr.20170624151245.2212: *9* LeoGui.Clipboard
def replaceClipboardWith(self, s):
    self.oops()

def getTextFromClipboard(self):
    self.oops()
.. @+node:ekr.20170624151245.2213: *9* LeoGui.Dialog utils
def attachLeoIcon(self, window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self, dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame(self, parent, caption=None, relief="groove", bd=2, padx=0, pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info(self, window):
    """Return the window information."""
    self.oops()
.. @+node:ekr.20170624151245.2214: *9* LeoGui.Focus
def get_focus(self, *args, **kwargs):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self, commander, widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
.. @+node:ekr.20170624151245.2215: *9* LeoGui.Font
def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    # g.trace('g.app.gui',g.callers()) # 'family',family,'size',size,'defaultSize',defaultSize,
    self.oops()
.. @+node:ekr.20170624151245.2216: *9* LeoGui.getFullVersion
def getFullVersion(self, c=None):
    return 'LeoGui: dummy version'
.. @+node:ekr.20170624151245.2217: *9* LeoGui.makeScriptButton
def makeScriptButton(self, c,
    args=None,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False,
):
    self.oops()
.. @+node:ekr.20170624151245.2212: *9* LeoGui.Clipboard
def replaceClipboardWith(self, s):
    self.oops()

def getTextFromClipboard(self):
    self.oops()
.. @+node:ekr.20170624151245.2213: *9* LeoGui.Dialog utils
def attachLeoIcon(self, window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self, dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame(self, parent, caption=None, relief="groove", bd=2, padx=0, pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info(self, window):
    """Return the window information."""
    self.oops()
.. @+node:ekr.20170624151245.2214: *9* LeoGui.Focus
def get_focus(self, *args, **kwargs):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self, commander, widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
.. @+node:ekr.20170624151245.2215: *9* LeoGui.Font
def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    # g.trace('g.app.gui',g.callers()) # 'family',family,'size',size,'defaultSize',defaultSize,
    self.oops()
.. @+node:ekr.20170624151245.2216: *9* LeoGui.getFullVersion
def getFullVersion(self, c=None):
    return 'LeoGui: dummy version'
.. @+node:ekr.20170624151245.2217: *9* LeoGui.makeScriptButton
def makeScriptButton(self, c,
    args=None,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False,
):
    self.oops()
.. @+node:ekr.20170624151245.2200: *8* LeoGui.destroySelf
def destroySelf(self):
    self.oops()
.. @+node:ekr.20170624151245.2201: *8* LeoGui.dialogs
def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    """Create and run Leo's About Leo dialog."""
    self.oops()

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self, c, title, message, cancelButtonText=None, okButtonText=None):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskOkCancelStringDialog(self, c, title, message, cancelButtonText=None,
                               okButtonText=None, default="", wide=False):
    """Create and run askOkCancelString dialog ."""
    self.oops()

def runAskYesNoDialog(self, c, title, message=None, yes_all=False, no_all=False):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self, c, title,
    message=None, yesMessage="Yes", noMessage="No",
    yesToAllMessage=None, defaultButton="Yes", cancelMessage=None,
):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()

def runPropertiesDialog(self, title='Properties', data=None, callback=None, buttons=None):
    """Dispay a modal TkPropertiesDialog"""
    self.oops()
.. @+node:ekr.20170624151245.2202: *8* LeoGui.file dialogs
def runOpenFileDialog(self, c, title, filetypes, defaultextension, multiple=False, startpath=None):
    """Create and run an open file dialog ."""
    self.oops()

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    """Create and run a save file dialog ."""
    self.oops()
.. @+node:ekr.20170624151245.2203: *8* LeoGui.panels
def createColorPanel(self, c):
    """Create a color panel"""
    self.oops()

def createComparePanel(self, c):
    """Create Compare panel."""
    self.oops()

def createFindTab(self, c, parentFrame):
    """Create a find tab in the indicated frame."""
    self.oops()

def createFontPanel(self, c):
    """Create a hidden Font panel."""
    self.oops()

def createLeoFrame(self, c, title):
    """Create a new Leo frame."""
    self.oops()
.. @+node:ekr.20170624151245.2204: *8* LeoGui.runMainLoop
def runMainLoop(self):
    """Run the gui's main loop."""
    self.oops()
.. @+node:ekr.20170624151245.2205: *8* LeoGui.utils
@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for
None returns.

The type of commander passed to methods depends on the type of frame
or dialog being created. The commander may be a Commands instance or
one of its subcommanders.
.. @+node:ekr.20170624151245.2212: *9* LeoGui.Clipboard
def replaceClipboardWith(self, s):
    self.oops()

def getTextFromClipboard(self):
    self.oops()
.. @+node:ekr.20170624151245.2213: *9* LeoGui.Dialog utils
def attachLeoIcon(self, window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self, dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame(self, parent, caption=None, relief="groove", bd=2, padx=0, pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info(self, window):
    """Return the window information."""
    self.oops()
.. @+node:ekr.20170624151245.2214: *9* LeoGui.Focus
def get_focus(self, *args, **kwargs):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self, commander, widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
.. @+node:ekr.20170624151245.2215: *9* LeoGui.Font
def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    # g.trace('g.app.gui',g.callers()) # 'family',family,'size',size,'defaultSize',defaultSize,
    self.oops()
.. @+node:ekr.20170624151245.2216: *9* LeoGui.getFullVersion
def getFullVersion(self, c=None):
    return 'LeoGui: dummy version'
.. @+node:ekr.20170624151245.2217: *9* LeoGui.makeScriptButton
def makeScriptButton(self, c,
    args=None,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False,
):
    self.oops()
.. @+node:ekr.20170624151245.2212: *9* LeoGui.Clipboard
def replaceClipboardWith(self, s):
    self.oops()

def getTextFromClipboard(self):
    self.oops()
.. @+node:ekr.20170624151245.2213: *9* LeoGui.Dialog utils
def attachLeoIcon(self, window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self, dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame(self, parent, caption=None, relief="groove", bd=2, padx=0, pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info(self, window):
    """Return the window information."""
    self.oops()
.. @+node:ekr.20170624151245.2214: *9* LeoGui.Focus
def get_focus(self, *args, **kwargs):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self, commander, widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
.. @+node:ekr.20170624151245.2215: *9* LeoGui.Font
def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    # g.trace('g.app.gui',g.callers()) # 'family',family,'size',size,'defaultSize',defaultSize,
    self.oops()
.. @+node:ekr.20170624151245.2216: *9* LeoGui.getFullVersion
def getFullVersion(self, c=None):
    return 'LeoGui: dummy version'
.. @+node:ekr.20170624151245.2217: *9* LeoGui.makeScriptButton
def makeScriptButton(self, c,
    args=None,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False,
):
    self.oops()
.. @+node:ekr.20170624151245.2218: *7* LeoGui: May be defined in subclasses
.. @+node:ekr.20170624151245.2226: *8* LeoGui.dismiss_spash_screen
def dismiss_splash_screen(self):
    pass # May be overridden in subclasses.
.. @+node:ekr.20170624151245.2227: *8* LeoGui.ensure_commander_visible
def ensure_commander_visible(self, c):
    """E.g. if commanders are in tabs, make sure c's tab is visible"""
    pass
.. @+node:ekr.20170624151245.2228: *8* LeoGui.finishCreate
def finishCreate(self):
    # This may be overridden in subclasses.
    pass
.. @+node:ekr.20170624151245.2229: *8* LeoGui.killPopupMenu & postPopupMenu
# These definitions keep pylint happy.

def postPopupMenu(self, *args, **keys):
    pass
.. @+node:ekr.20170624151245.2230: *8* LeoGui.oops
def oops(self):
    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        g.pr("LeoGui oops", g.callers(4), "should be overridden in subclass")
.. @+node:ekr.20170624151245.2231: *8* LeoGui.put_help
def put_help(self, c, s, short_title):
    pass

.. @+node:ekr.20170624151245.2232: *8* LeoGui.widget_name (LeoGui)
def widget_name(self, w):
    # First try the widget's getName method.
    if not 'w':
        return '<no widget>'
    elif hasattr(w, 'getName'):
        return w.getName()
    elif hasattr(w, '_name'):
        return w._name
    else:
        return repr(w)
.. @+node:ekr.20170624151245.2226: *8* LeoGui.dismiss_spash_screen
def dismiss_splash_screen(self):
    pass # May be overridden in subclasses.
.. @+node:ekr.20170624151245.2227: *8* LeoGui.ensure_commander_visible
def ensure_commander_visible(self, c):
    """E.g. if commanders are in tabs, make sure c's tab is visible"""
    pass
.. @+node:ekr.20170624151245.2228: *8* LeoGui.finishCreate
def finishCreate(self):
    # This may be overridden in subclasses.
    pass
.. @+node:ekr.20170624151245.2229: *8* LeoGui.killPopupMenu & postPopupMenu
# These definitions keep pylint happy.

def postPopupMenu(self, *args, **keys):
    pass
.. @+node:ekr.20170624151245.2230: *8* LeoGui.oops
def oops(self):
    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        g.pr("LeoGui oops", g.callers(4), "should be overridden in subclass")
.. @+node:ekr.20170624151245.2231: *8* LeoGui.put_help
def put_help(self, c, s, short_title):
    pass

.. @+node:ekr.20170624151245.2232: *8* LeoGui.widget_name (LeoGui)
def widget_name(self, w):
    # First try the widget's getName method.
    if not 'w':
        return '<no widget>'
    elif hasattr(w, 'getName'):
        return w.getName()
    elif hasattr(w, '_name'):
        return w._name
    else:
        return repr(w)
.. @+node:ekr.20170624151245.2171: *7* LeoGui.__init__
def __init__(self, guiName):
    '''Ctor for the LeoGui class.'''
    # g.trace("LeoGui",guiName,g.callers())
    self.active = None # Used only by qt_gui.
    self.consoleOnly = True # True if g.es goes to console.
    self.globalFindTabManager = None
    self.globalFindDialog = None
    self.globalFindTab = None
    self.idleTimeClass = None
    self.isNullGui = False
    self.lastFrame = None
    self.leoIcon = None
    self.mGuiName = guiName
    self.mainLoop = None
    self.plainTextWidget = None
        # For SpellTabHandler class only.
    self.root = None
    self.script = None
    self.splashScreen = None
    self.trace = False
    self.utils = None
    # To keep pylint happy.
    self.ScriptingControllerClass = NullScriptingControllerClass
.. @+node:ekr.20170624151245.2172: *7* LeoGui: Must be defined only in base class
.. @+node:ekr.20170624151245.2177: *8* LeoGui.create_key_event (LeoGui)
def create_key_event(self, c, char, stroke, w, event=None, x=None, y=None, x_root=None, y_root=None):
    # Do not call strokeFromSetting here!
    # For example, this would wrongly convert Ctrl-C to Ctrl-c,
    # in effect, converting a user binding from Ctrl-Shift-C to Ctrl-C.
    return LeoKeyEvent(c, char, event, stroke, w, x, y, x_root, y_root)
.. @+node:ekr.20170624151245.2178: *8* LeoGui.guiName
def guiName(self):
    try:
        return self.mGuiName
    except Exception:
        return "invalid gui name"
.. @+node:ekr.20170624151245.2179: *8* LeoGui.setScript
def setScript(self, script=None, scriptFileName=None):
    self.script = script
    self.scriptFileName = scriptFileName
.. @+node:ekr.20170624151245.2180: *8* LeoGui.event_generate (LeoGui)
def event_generate(self, c, char, shortcut, w):
    event = self.create_key_event(c, char, shortcut, w)
    c.k.masterKeyHandler(event)
    c.outerUpdate()
.. @+node:ekr.20170624151245.2177: *8* LeoGui.create_key_event (LeoGui)
def create_key_event(self, c, char, stroke, w, event=None, x=None, y=None, x_root=None, y_root=None):
    # Do not call strokeFromSetting here!
    # For example, this would wrongly convert Ctrl-C to Ctrl-c,
    # in effect, converting a user binding from Ctrl-Shift-C to Ctrl-C.
    return LeoKeyEvent(c, char, event, stroke, w, x, y, x_root, y_root)
.. @+node:ekr.20170624151245.2178: *8* LeoGui.guiName
def guiName(self):
    try:
        return self.mGuiName
    except Exception:
        return "invalid gui name"
.. @+node:ekr.20170624151245.2179: *8* LeoGui.setScript
def setScript(self, script=None, scriptFileName=None):
    self.script = script
    self.scriptFileName = scriptFileName
.. @+node:ekr.20170624151245.2180: *8* LeoGui.event_generate (LeoGui)
def event_generate(self, c, char, shortcut, w):
    event = self.create_key_event(c, char, shortcut, w)
    c.k.masterKeyHandler(event)
    c.outerUpdate()
.. @+node:ekr.20170624151245.2181: *7* LeoGu: Must be defined in subclasses
.. @+node:ekr.20170624151245.2200: *8* LeoGui.destroySelf
def destroySelf(self):
    self.oops()
.. @+node:ekr.20170624151245.2201: *8* LeoGui.dialogs
def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    """Create and run Leo's About Leo dialog."""
    self.oops()

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self, c, title, message, cancelButtonText=None, okButtonText=None):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskOkCancelStringDialog(self, c, title, message, cancelButtonText=None,
                               okButtonText=None, default="", wide=False):
    """Create and run askOkCancelString dialog ."""
    self.oops()

def runAskYesNoDialog(self, c, title, message=None, yes_all=False, no_all=False):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self, c, title,
    message=None, yesMessage="Yes", noMessage="No",
    yesToAllMessage=None, defaultButton="Yes", cancelMessage=None,
):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()

def runPropertiesDialog(self, title='Properties', data=None, callback=None, buttons=None):
    """Dispay a modal TkPropertiesDialog"""
    self.oops()
.. @+node:ekr.20170624151245.2202: *8* LeoGui.file dialogs
def runOpenFileDialog(self, c, title, filetypes, defaultextension, multiple=False, startpath=None):
    """Create and run an open file dialog ."""
    self.oops()

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    """Create and run a save file dialog ."""
    self.oops()
.. @+node:ekr.20170624151245.2203: *8* LeoGui.panels
def createColorPanel(self, c):
    """Create a color panel"""
    self.oops()

def createComparePanel(self, c):
    """Create Compare panel."""
    self.oops()

def createFindTab(self, c, parentFrame):
    """Create a find tab in the indicated frame."""
    self.oops()

def createFontPanel(self, c):
    """Create a hidden Font panel."""
    self.oops()

def createLeoFrame(self, c, title):
    """Create a new Leo frame."""
    self.oops()
.. @+node:ekr.20170624151245.2204: *8* LeoGui.runMainLoop
def runMainLoop(self):
    """Run the gui's main loop."""
    self.oops()
.. @+node:ekr.20170624151245.2205: *8* LeoGui.utils
@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for
None returns.

The type of commander passed to methods depends on the type of frame
or dialog being created. The commander may be a Commands instance or
one of its subcommanders.
.. @+node:ekr.20170624151245.2212: *9* LeoGui.Clipboard
def replaceClipboardWith(self, s):
    self.oops()

def getTextFromClipboard(self):
    self.oops()
.. @+node:ekr.20170624151245.2213: *9* LeoGui.Dialog utils
def attachLeoIcon(self, window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self, dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame(self, parent, caption=None, relief="groove", bd=2, padx=0, pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info(self, window):
    """Return the window information."""
    self.oops()
.. @+node:ekr.20170624151245.2214: *9* LeoGui.Focus
def get_focus(self, *args, **kwargs):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self, commander, widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
.. @+node:ekr.20170624151245.2215: *9* LeoGui.Font
def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    # g.trace('g.app.gui',g.callers()) # 'family',family,'size',size,'defaultSize',defaultSize,
    self.oops()
.. @+node:ekr.20170624151245.2216: *9* LeoGui.getFullVersion
def getFullVersion(self, c=None):
    return 'LeoGui: dummy version'
.. @+node:ekr.20170624151245.2217: *9* LeoGui.makeScriptButton
def makeScriptButton(self, c,
    args=None,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False,
):
    self.oops()
.. @+node:ekr.20170624151245.2212: *9* LeoGui.Clipboard
def replaceClipboardWith(self, s):
    self.oops()

def getTextFromClipboard(self):
    self.oops()
.. @+node:ekr.20170624151245.2213: *9* LeoGui.Dialog utils
def attachLeoIcon(self, window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self, dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame(self, parent, caption=None, relief="groove", bd=2, padx=0, pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info(self, window):
    """Return the window information."""
    self.oops()
.. @+node:ekr.20170624151245.2214: *9* LeoGui.Focus
def get_focus(self, *args, **kwargs):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self, commander, widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
.. @+node:ekr.20170624151245.2215: *9* LeoGui.Font
def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    # g.trace('g.app.gui',g.callers()) # 'family',family,'size',size,'defaultSize',defaultSize,
    self.oops()
.. @+node:ekr.20170624151245.2216: *9* LeoGui.getFullVersion
def getFullVersion(self, c=None):
    return 'LeoGui: dummy version'
.. @+node:ekr.20170624151245.2217: *9* LeoGui.makeScriptButton
def makeScriptButton(self, c,
    args=None,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False,
):
    self.oops()
.. @+node:ekr.20170624151245.2200: *8* LeoGui.destroySelf
def destroySelf(self):
    self.oops()
.. @+node:ekr.20170624151245.2201: *8* LeoGui.dialogs
def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    """Create and run Leo's About Leo dialog."""
    self.oops()

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self, c, title, message, cancelButtonText=None, okButtonText=None):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskOkCancelStringDialog(self, c, title, message, cancelButtonText=None,
                               okButtonText=None, default="", wide=False):
    """Create and run askOkCancelString dialog ."""
    self.oops()

def runAskYesNoDialog(self, c, title, message=None, yes_all=False, no_all=False):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self, c, title,
    message=None, yesMessage="Yes", noMessage="No",
    yesToAllMessage=None, defaultButton="Yes", cancelMessage=None,
):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()

def runPropertiesDialog(self, title='Properties', data=None, callback=None, buttons=None):
    """Dispay a modal TkPropertiesDialog"""
    self.oops()
.. @+node:ekr.20170624151245.2202: *8* LeoGui.file dialogs
def runOpenFileDialog(self, c, title, filetypes, defaultextension, multiple=False, startpath=None):
    """Create and run an open file dialog ."""
    self.oops()

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    """Create and run a save file dialog ."""
    self.oops()
.. @+node:ekr.20170624151245.2203: *8* LeoGui.panels
def createColorPanel(self, c):
    """Create a color panel"""
    self.oops()

def createComparePanel(self, c):
    """Create Compare panel."""
    self.oops()

def createFindTab(self, c, parentFrame):
    """Create a find tab in the indicated frame."""
    self.oops()

def createFontPanel(self, c):
    """Create a hidden Font panel."""
    self.oops()

def createLeoFrame(self, c, title):
    """Create a new Leo frame."""
    self.oops()
.. @+node:ekr.20170624151245.2204: *8* LeoGui.runMainLoop
def runMainLoop(self):
    """Run the gui's main loop."""
    self.oops()
.. @+node:ekr.20170624151245.2205: *8* LeoGui.utils
@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for
None returns.

The type of commander passed to methods depends on the type of frame
or dialog being created. The commander may be a Commands instance or
one of its subcommanders.
.. @+node:ekr.20170624151245.2212: *9* LeoGui.Clipboard
def replaceClipboardWith(self, s):
    self.oops()

def getTextFromClipboard(self):
    self.oops()
.. @+node:ekr.20170624151245.2213: *9* LeoGui.Dialog utils
def attachLeoIcon(self, window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self, dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame(self, parent, caption=None, relief="groove", bd=2, padx=0, pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info(self, window):
    """Return the window information."""
    self.oops()
.. @+node:ekr.20170624151245.2214: *9* LeoGui.Focus
def get_focus(self, *args, **kwargs):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self, commander, widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
.. @+node:ekr.20170624151245.2215: *9* LeoGui.Font
def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    # g.trace('g.app.gui',g.callers()) # 'family',family,'size',size,'defaultSize',defaultSize,
    self.oops()
.. @+node:ekr.20170624151245.2216: *9* LeoGui.getFullVersion
def getFullVersion(self, c=None):
    return 'LeoGui: dummy version'
.. @+node:ekr.20170624151245.2217: *9* LeoGui.makeScriptButton
def makeScriptButton(self, c,
    args=None,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False,
):
    self.oops()
.. @+node:ekr.20170624151245.2212: *9* LeoGui.Clipboard
def replaceClipboardWith(self, s):
    self.oops()

def getTextFromClipboard(self):
    self.oops()
.. @+node:ekr.20170624151245.2213: *9* LeoGui.Dialog utils
def attachLeoIcon(self, window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self, dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame(self, parent, caption=None, relief="groove", bd=2, padx=0, pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info(self, window):
    """Return the window information."""
    self.oops()
.. @+node:ekr.20170624151245.2214: *9* LeoGui.Focus
def get_focus(self, *args, **kwargs):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self, commander, widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
.. @+node:ekr.20170624151245.2215: *9* LeoGui.Font
def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    # g.trace('g.app.gui',g.callers()) # 'family',family,'size',size,'defaultSize',defaultSize,
    self.oops()
.. @+node:ekr.20170624151245.2216: *9* LeoGui.getFullVersion
def getFullVersion(self, c=None):
    return 'LeoGui: dummy version'
.. @+node:ekr.20170624151245.2217: *9* LeoGui.makeScriptButton
def makeScriptButton(self, c,
    args=None,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False,
):
    self.oops()
.. @+node:ekr.20170624151245.2218: *7* LeoGui: May be defined in subclasses
.. @+node:ekr.20170624151245.2226: *8* LeoGui.dismiss_spash_screen
def dismiss_splash_screen(self):
    pass # May be overridden in subclasses.
.. @+node:ekr.20170624151245.2227: *8* LeoGui.ensure_commander_visible
def ensure_commander_visible(self, c):
    """E.g. if commanders are in tabs, make sure c's tab is visible"""
    pass
.. @+node:ekr.20170624151245.2228: *8* LeoGui.finishCreate
def finishCreate(self):
    # This may be overridden in subclasses.
    pass
.. @+node:ekr.20170624151245.2229: *8* LeoGui.killPopupMenu & postPopupMenu
# These definitions keep pylint happy.

def postPopupMenu(self, *args, **keys):
    pass
.. @+node:ekr.20170624151245.2230: *8* LeoGui.oops
def oops(self):
    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        g.pr("LeoGui oops", g.callers(4), "should be overridden in subclass")
.. @+node:ekr.20170624151245.2231: *8* LeoGui.put_help
def put_help(self, c, s, short_title):
    pass

.. @+node:ekr.20170624151245.2232: *8* LeoGui.widget_name (LeoGui)
def widget_name(self, w):
    # First try the widget's getName method.
    if not 'w':
        return '<no widget>'
    elif hasattr(w, 'getName'):
        return w.getName()
    elif hasattr(w, '_name'):
        return w._name
    else:
        return repr(w)
.. @+node:ekr.20170624151245.2226: *8* LeoGui.dismiss_spash_screen
def dismiss_splash_screen(self):
    pass # May be overridden in subclasses.
.. @+node:ekr.20170624151245.2227: *8* LeoGui.ensure_commander_visible
def ensure_commander_visible(self, c):
    """E.g. if commanders are in tabs, make sure c's tab is visible"""
    pass
.. @+node:ekr.20170624151245.2228: *8* LeoGui.finishCreate
def finishCreate(self):
    # This may be overridden in subclasses.
    pass
.. @+node:ekr.20170624151245.2229: *8* LeoGui.killPopupMenu & postPopupMenu
# These definitions keep pylint happy.

def postPopupMenu(self, *args, **keys):
    pass
.. @+node:ekr.20170624151245.2230: *8* LeoGui.oops
def oops(self):
    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        g.pr("LeoGui oops", g.callers(4), "should be overridden in subclass")
.. @+node:ekr.20170624151245.2231: *8* LeoGui.put_help
def put_help(self, c, s, short_title):
    pass

.. @+node:ekr.20170624151245.2232: *8* LeoGui.widget_name (LeoGui)
def widget_name(self, w):
    # First try the widget's getName method.
    if not 'w':
        return '<no widget>'
    elif hasattr(w, 'getName'):
        return w.getName()
    elif hasattr(w, '_name'):
        return w._name
    else:
        return repr(w)
.. @+node:ekr.20170624151245.2233: *6* class LeoQTreeWidget (QTreeWidget)
class LeoQTreeWidget(QtWidgets.QTreeWidget):
    # To do: Generate @auto or @file nodes when appropriate.

    def __init__(self, c, parent):
        QtWidgets.QTreeWidget.__init__(self, parent)
        self.setAcceptDrops(True)
        enable_drag = c.config.getBool('enable-tree-dragging')
        self.setDragEnabled(bool(enable_drag))
        self.c = c
        self.was_alt_drag = False
        self.was_control_drag = False

    def __repr__(self):
        return 'LeoQTreeWidget: %s' % id(self)

    __str__ = __repr__
    # This is called during drags.

    def dragMoveEvent(self, ev):
        pass
    @others
.. @+node:ekr.20170624151245.3000: *7* LeoQTreeWidget: Event handlers
.. @+node:ekr.20170624151245.3381: *8* LeoQTreeWidget.dragEnterEvent & helper
def dragEnterEvent(self, ev):
    '''Export c.p's tree as a Leo mime-data.'''
    trace = False and not g.unitTesting
    c = self.c
    if not ev:
        g.trace('no event!')
        return
    md = ev.mimeData()
    if not md:
        g.trace('No mimeData!')
        return
    c.endEditing()
    # Fix bug 135: cross-file drag and drop is broken.
    # This handler may be called several times for the same drag.
    # Only the first should should set g.app.drag_source.
    if g.app.dragging:
        if trace: g.trace('** already dragging')
    else:
        g.app.dragging = True
        g.app.drag_source = c, c.p
        if trace: g.trace('g.app.drag_source: %r %r' % g.app.drag_source)
        self.setText(md)
        if trace: self.dump(ev, c.p, 'enter')
    # Always accept the drag, even if we are already dragging.
    ev.accept()
.. @+node:ekr.20170624151245.3383: *9* LeoQTreeWidget.setText
def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    if not g.isPython3:
        s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
        fn = g.toEncodedString(fn, encoding='utf-8', reportErrors=True)
    md.setText('%s,%s' % (fn, s))
.. @+node:ekr.20170624151245.3383: *9* LeoQTreeWidget.setText
def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    if not g.isPython3:
        s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
        fn = g.toEncodedString(fn, encoding='utf-8', reportErrors=True)
    md.setText('%s,%s' % (fn, s))
.. @+node:ekr.20170624151245.3384: *8* LeoQTreeWidget.dropEvent & helpers
def dropEvent(self, ev):
    '''Handle a drop event in the QTreeWidget.'''
    trace = False and not g.unitTesting
    trace_dump = False
    if not ev: return
    md = ev.mimeData()
    if not md:
        g.trace('no mimeData!')
        return
    mods = int(ev.keyboardModifiers())
    self.was_alt_drag = (mods & QtCore.Qt.AltModifier) != 0
    self.was_control_drag = (mods & QtCore.Qt.ControlModifier) != 0
    c, tree = self.c, self.c.frame.tree
    p = None
    item = self.itemAt(ev.pos())
    if item:
        itemHash = tree.itemHash(item)
        p = tree.item2positionDict.get(itemHash)
    if not p:
        # Fix bug: https://github.com/leo-editor/leo-editor/issues/59
        # Drop at last node.
        p = c.rootPosition()
        while p.hasNext():
            p.moveToNext()
    formats = set(str(f) for f in md.formats())
    ev.setDropAction(QtCore.Qt.IgnoreAction)
    ev.accept()
    hookres = g.doHook("outlinedrop", c=c, p=p, dropevent=ev, formats=formats)
    if hookres:
        # A plugin handled the drop.
        if trace: g.trace('hookres is True')
    else:
        if trace and trace_dump: self.dump(ev, p, 'drop ')
        if md.hasUrls():
            self.urlDrop(md, p)
        else:
            self.nodeDrop(md, p)
    g.app.dragging = False
.. @+node:ekr.20170624151245.3573: *9* LeoQTreeWidget.nodeDrop & helpers
def nodeDrop(self, md, p):
    '''
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    '''
    trace = False and not g.unitTesting
    c = self.c
    fn, s = self.parseText(md)
    if trace: g.trace('fn', fn, 'self.fileName()', self.fileName())
    if not s or not fn:
        if trace: g.trace('no fn or no s', fn, len(s or ''))
    elif fn == self.fileName():
        if p and p == c.p:
            if trace: g.trace('drag to same node')
        elif g.os_path_exists(fn):
            if trace: g.trace('intra-file drop')
            self.intraFileDrop(fn, c.p, p)
        else:
            if trace: g.trace('does not exist', fn)
    else:
        if trace: g.trace('inter-file drag')
        self.interFileDrop(fn, p, s)
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3580: *9* LeoQTreeWidget.urlDrop & helpers
def urlDrop(self, md, p):
    '''Handle a drop when md.urls().'''
    trace = False and not g.unitTesting
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        if trace: g.trace('no urs')
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',): # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
        # else: g.trace(url.scheme(),url)
    if trace: g.trace('changed', changed)
    if changed:
        c.setChanged(True)
        u.afterChangeGroup(c.p, undoType, reportFlag=False, dirtyVnodeList=[])
        c.redraw_now()
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3573: *9* LeoQTreeWidget.nodeDrop & helpers
def nodeDrop(self, md, p):
    '''
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    '''
    trace = False and not g.unitTesting
    c = self.c
    fn, s = self.parseText(md)
    if trace: g.trace('fn', fn, 'self.fileName()', self.fileName())
    if not s or not fn:
        if trace: g.trace('no fn or no s', fn, len(s or ''))
    elif fn == self.fileName():
        if p and p == c.p:
            if trace: g.trace('drag to same node')
        elif g.os_path_exists(fn):
            if trace: g.trace('intra-file drop')
            self.intraFileDrop(fn, c.p, p)
        else:
            if trace: g.trace('does not exist', fn)
    else:
        if trace: g.trace('inter-file drag')
        self.interFileDrop(fn, p, s)
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3580: *9* LeoQTreeWidget.urlDrop & helpers
def urlDrop(self, md, p):
    '''Handle a drop when md.urls().'''
    trace = False and not g.unitTesting
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        if trace: g.trace('no urs')
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',): # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
        # else: g.trace(url.scheme(),url)
    if trace: g.trace('changed', changed)
    if changed:
        c.setChanged(True)
        u.afterChangeGroup(c.p, undoType, reportFlag=False, dirtyVnodeList=[])
        c.redraw_now()
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3381: *8* LeoQTreeWidget.dragEnterEvent & helper
def dragEnterEvent(self, ev):
    '''Export c.p's tree as a Leo mime-data.'''
    trace = False and not g.unitTesting
    c = self.c
    if not ev:
        g.trace('no event!')
        return
    md = ev.mimeData()
    if not md:
        g.trace('No mimeData!')
        return
    c.endEditing()
    # Fix bug 135: cross-file drag and drop is broken.
    # This handler may be called several times for the same drag.
    # Only the first should should set g.app.drag_source.
    if g.app.dragging:
        if trace: g.trace('** already dragging')
    else:
        g.app.dragging = True
        g.app.drag_source = c, c.p
        if trace: g.trace('g.app.drag_source: %r %r' % g.app.drag_source)
        self.setText(md)
        if trace: self.dump(ev, c.p, 'enter')
    # Always accept the drag, even if we are already dragging.
    ev.accept()
.. @+node:ekr.20170624151245.3383: *9* LeoQTreeWidget.setText
def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    if not g.isPython3:
        s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
        fn = g.toEncodedString(fn, encoding='utf-8', reportErrors=True)
    md.setText('%s,%s' % (fn, s))
.. @+node:ekr.20170624151245.3383: *9* LeoQTreeWidget.setText
def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    if not g.isPython3:
        s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
        fn = g.toEncodedString(fn, encoding='utf-8', reportErrors=True)
    md.setText('%s,%s' % (fn, s))
.. @+node:ekr.20170624151245.3384: *8* LeoQTreeWidget.dropEvent & helpers
def dropEvent(self, ev):
    '''Handle a drop event in the QTreeWidget.'''
    trace = False and not g.unitTesting
    trace_dump = False
    if not ev: return
    md = ev.mimeData()
    if not md:
        g.trace('no mimeData!')
        return
    mods = int(ev.keyboardModifiers())
    self.was_alt_drag = (mods & QtCore.Qt.AltModifier) != 0
    self.was_control_drag = (mods & QtCore.Qt.ControlModifier) != 0
    c, tree = self.c, self.c.frame.tree
    p = None
    item = self.itemAt(ev.pos())
    if item:
        itemHash = tree.itemHash(item)
        p = tree.item2positionDict.get(itemHash)
    if not p:
        # Fix bug: https://github.com/leo-editor/leo-editor/issues/59
        # Drop at last node.
        p = c.rootPosition()
        while p.hasNext():
            p.moveToNext()
    formats = set(str(f) for f in md.formats())
    ev.setDropAction(QtCore.Qt.IgnoreAction)
    ev.accept()
    hookres = g.doHook("outlinedrop", c=c, p=p, dropevent=ev, formats=formats)
    if hookres:
        # A plugin handled the drop.
        if trace: g.trace('hookres is True')
    else:
        if trace and trace_dump: self.dump(ev, p, 'drop ')
        if md.hasUrls():
            self.urlDrop(md, p)
        else:
            self.nodeDrop(md, p)
    g.app.dragging = False
.. @+node:ekr.20170624151245.3573: *9* LeoQTreeWidget.nodeDrop & helpers
def nodeDrop(self, md, p):
    '''
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    '''
    trace = False and not g.unitTesting
    c = self.c
    fn, s = self.parseText(md)
    if trace: g.trace('fn', fn, 'self.fileName()', self.fileName())
    if not s or not fn:
        if trace: g.trace('no fn or no s', fn, len(s or ''))
    elif fn == self.fileName():
        if p and p == c.p:
            if trace: g.trace('drag to same node')
        elif g.os_path_exists(fn):
            if trace: g.trace('intra-file drop')
            self.intraFileDrop(fn, c.p, p)
        else:
            if trace: g.trace('does not exist', fn)
    else:
        if trace: g.trace('inter-file drag')
        self.interFileDrop(fn, p, s)
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3580: *9* LeoQTreeWidget.urlDrop & helpers
def urlDrop(self, md, p):
    '''Handle a drop when md.urls().'''
    trace = False and not g.unitTesting
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        if trace: g.trace('no urs')
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',): # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
        # else: g.trace(url.scheme(),url)
    if trace: g.trace('changed', changed)
    if changed:
        c.setChanged(True)
        u.afterChangeGroup(c.p, undoType, reportFlag=False, dirtyVnodeList=[])
        c.redraw_now()
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3573: *9* LeoQTreeWidget.nodeDrop & helpers
def nodeDrop(self, md, p):
    '''
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    '''
    trace = False and not g.unitTesting
    c = self.c
    fn, s = self.parseText(md)
    if trace: g.trace('fn', fn, 'self.fileName()', self.fileName())
    if not s or not fn:
        if trace: g.trace('no fn or no s', fn, len(s or ''))
    elif fn == self.fileName():
        if p and p == c.p:
            if trace: g.trace('drag to same node')
        elif g.os_path_exists(fn):
            if trace: g.trace('intra-file drop')
            self.intraFileDrop(fn, c.p, p)
        else:
            if trace: g.trace('does not exist', fn)
    else:
        if trace: g.trace('inter-file drag')
        self.interFileDrop(fn, p, s)
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3580: *9* LeoQTreeWidget.urlDrop & helpers
def urlDrop(self, md, p):
    '''Handle a drop when md.urls().'''
    trace = False and not g.unitTesting
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        if trace: g.trace('no urs')
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',): # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
        # else: g.trace(url.scheme(),url)
    if trace: g.trace('changed', changed)
    if changed:
        c.setChanged(True)
        u.afterChangeGroup(c.p, undoType, reportFlag=False, dirtyVnodeList=[])
        c.redraw_now()
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3761: *7* LeoQTreeWidget: utils
.. @+node:ekr.20170624151245.3764: *8* LeoQTreeWidget.dump
def dump(self, ev, p, tag):
    if ev:
        md = ev.mimeData()
        s = g.toUnicode(md.text(), 'utf-8')
        g.trace('md.text:', repr(s) if len(s) < 100 else len(s))
        for url in md.urls() or []:
            g.trace('     url:', url)
            g.trace('  url.fn:', url.toLocalFile())
            g.trace('url.text:', url.toString())
    else:
        g.trace('', tag, '** no event!')
.. @+node:ekr.20170624151245.3765: *8* LeoQTreeWidget.fileName
def fileName(self):
    '''Return the commander's filename.'''
    return self.c.fileName() or '<unsaved file>'
.. @+node:ekr.20170624151245.3764: *8* LeoQTreeWidget.dump
def dump(self, ev, p, tag):
    if ev:
        md = ev.mimeData()
        s = g.toUnicode(md.text(), 'utf-8')
        g.trace('md.text:', repr(s) if len(s) < 100 else len(s))
        for url in md.urls() or []:
            g.trace('     url:', url)
            g.trace('  url.fn:', url.toLocalFile())
            g.trace('url.text:', url.toString())
    else:
        g.trace('', tag, '** no event!')
.. @+node:ekr.20170624151245.3765: *8* LeoQTreeWidget.fileName
def fileName(self):
    '''Return the commander's filename.'''
    return self.c.fileName() or '<unsaved file>'
.. @+node:ekr.20170624151245.3000: *7* LeoQTreeWidget: Event handlers
.. @+node:ekr.20170624151245.3381: *8* LeoQTreeWidget.dragEnterEvent & helper
def dragEnterEvent(self, ev):
    '''Export c.p's tree as a Leo mime-data.'''
    trace = False and not g.unitTesting
    c = self.c
    if not ev:
        g.trace('no event!')
        return
    md = ev.mimeData()
    if not md:
        g.trace('No mimeData!')
        return
    c.endEditing()
    # Fix bug 135: cross-file drag and drop is broken.
    # This handler may be called several times for the same drag.
    # Only the first should should set g.app.drag_source.
    if g.app.dragging:
        if trace: g.trace('** already dragging')
    else:
        g.app.dragging = True
        g.app.drag_source = c, c.p
        if trace: g.trace('g.app.drag_source: %r %r' % g.app.drag_source)
        self.setText(md)
        if trace: self.dump(ev, c.p, 'enter')
    # Always accept the drag, even if we are already dragging.
    ev.accept()
.. @+node:ekr.20170624151245.3383: *9* LeoQTreeWidget.setText
def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    if not g.isPython3:
        s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
        fn = g.toEncodedString(fn, encoding='utf-8', reportErrors=True)
    md.setText('%s,%s' % (fn, s))
.. @+node:ekr.20170624151245.3383: *9* LeoQTreeWidget.setText
def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    if not g.isPython3:
        s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
        fn = g.toEncodedString(fn, encoding='utf-8', reportErrors=True)
    md.setText('%s,%s' % (fn, s))
.. @+node:ekr.20170624151245.3384: *8* LeoQTreeWidget.dropEvent & helpers
def dropEvent(self, ev):
    '''Handle a drop event in the QTreeWidget.'''
    trace = False and not g.unitTesting
    trace_dump = False
    if not ev: return
    md = ev.mimeData()
    if not md:
        g.trace('no mimeData!')
        return
    mods = int(ev.keyboardModifiers())
    self.was_alt_drag = (mods & QtCore.Qt.AltModifier) != 0
    self.was_control_drag = (mods & QtCore.Qt.ControlModifier) != 0
    c, tree = self.c, self.c.frame.tree
    p = None
    item = self.itemAt(ev.pos())
    if item:
        itemHash = tree.itemHash(item)
        p = tree.item2positionDict.get(itemHash)
    if not p:
        # Fix bug: https://github.com/leo-editor/leo-editor/issues/59
        # Drop at last node.
        p = c.rootPosition()
        while p.hasNext():
            p.moveToNext()
    formats = set(str(f) for f in md.formats())
    ev.setDropAction(QtCore.Qt.IgnoreAction)
    ev.accept()
    hookres = g.doHook("outlinedrop", c=c, p=p, dropevent=ev, formats=formats)
    if hookres:
        # A plugin handled the drop.
        if trace: g.trace('hookres is True')
    else:
        if trace and trace_dump: self.dump(ev, p, 'drop ')
        if md.hasUrls():
            self.urlDrop(md, p)
        else:
            self.nodeDrop(md, p)
    g.app.dragging = False
.. @+node:ekr.20170624151245.3573: *9* LeoQTreeWidget.nodeDrop & helpers
def nodeDrop(self, md, p):
    '''
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    '''
    trace = False and not g.unitTesting
    c = self.c
    fn, s = self.parseText(md)
    if trace: g.trace('fn', fn, 'self.fileName()', self.fileName())
    if not s or not fn:
        if trace: g.trace('no fn or no s', fn, len(s or ''))
    elif fn == self.fileName():
        if p and p == c.p:
            if trace: g.trace('drag to same node')
        elif g.os_path_exists(fn):
            if trace: g.trace('intra-file drop')
            self.intraFileDrop(fn, c.p, p)
        else:
            if trace: g.trace('does not exist', fn)
    else:
        if trace: g.trace('inter-file drag')
        self.interFileDrop(fn, p, s)
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3580: *9* LeoQTreeWidget.urlDrop & helpers
def urlDrop(self, md, p):
    '''Handle a drop when md.urls().'''
    trace = False and not g.unitTesting
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        if trace: g.trace('no urs')
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',): # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
        # else: g.trace(url.scheme(),url)
    if trace: g.trace('changed', changed)
    if changed:
        c.setChanged(True)
        u.afterChangeGroup(c.p, undoType, reportFlag=False, dirtyVnodeList=[])
        c.redraw_now()
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3573: *9* LeoQTreeWidget.nodeDrop & helpers
def nodeDrop(self, md, p):
    '''
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    '''
    trace = False and not g.unitTesting
    c = self.c
    fn, s = self.parseText(md)
    if trace: g.trace('fn', fn, 'self.fileName()', self.fileName())
    if not s or not fn:
        if trace: g.trace('no fn or no s', fn, len(s or ''))
    elif fn == self.fileName():
        if p and p == c.p:
            if trace: g.trace('drag to same node')
        elif g.os_path_exists(fn):
            if trace: g.trace('intra-file drop')
            self.intraFileDrop(fn, c.p, p)
        else:
            if trace: g.trace('does not exist', fn)
    else:
        if trace: g.trace('inter-file drag')
        self.interFileDrop(fn, p, s)
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3580: *9* LeoQTreeWidget.urlDrop & helpers
def urlDrop(self, md, p):
    '''Handle a drop when md.urls().'''
    trace = False and not g.unitTesting
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        if trace: g.trace('no urs')
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',): # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
        # else: g.trace(url.scheme(),url)
    if trace: g.trace('changed', changed)
    if changed:
        c.setChanged(True)
        u.afterChangeGroup(c.p, undoType, reportFlag=False, dirtyVnodeList=[])
        c.redraw_now()
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3381: *8* LeoQTreeWidget.dragEnterEvent & helper
def dragEnterEvent(self, ev):
    '''Export c.p's tree as a Leo mime-data.'''
    trace = False and not g.unitTesting
    c = self.c
    if not ev:
        g.trace('no event!')
        return
    md = ev.mimeData()
    if not md:
        g.trace('No mimeData!')
        return
    c.endEditing()
    # Fix bug 135: cross-file drag and drop is broken.
    # This handler may be called several times for the same drag.
    # Only the first should should set g.app.drag_source.
    if g.app.dragging:
        if trace: g.trace('** already dragging')
    else:
        g.app.dragging = True
        g.app.drag_source = c, c.p
        if trace: g.trace('g.app.drag_source: %r %r' % g.app.drag_source)
        self.setText(md)
        if trace: self.dump(ev, c.p, 'enter')
    # Always accept the drag, even if we are already dragging.
    ev.accept()
.. @+node:ekr.20170624151245.3383: *9* LeoQTreeWidget.setText
def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    if not g.isPython3:
        s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
        fn = g.toEncodedString(fn, encoding='utf-8', reportErrors=True)
    md.setText('%s,%s' % (fn, s))
.. @+node:ekr.20170624151245.3383: *9* LeoQTreeWidget.setText
def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    if not g.isPython3:
        s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
        fn = g.toEncodedString(fn, encoding='utf-8', reportErrors=True)
    md.setText('%s,%s' % (fn, s))
.. @+node:ekr.20170624151245.3384: *8* LeoQTreeWidget.dropEvent & helpers
def dropEvent(self, ev):
    '''Handle a drop event in the QTreeWidget.'''
    trace = False and not g.unitTesting
    trace_dump = False
    if not ev: return
    md = ev.mimeData()
    if not md:
        g.trace('no mimeData!')
        return
    mods = int(ev.keyboardModifiers())
    self.was_alt_drag = (mods & QtCore.Qt.AltModifier) != 0
    self.was_control_drag = (mods & QtCore.Qt.ControlModifier) != 0
    c, tree = self.c, self.c.frame.tree
    p = None
    item = self.itemAt(ev.pos())
    if item:
        itemHash = tree.itemHash(item)
        p = tree.item2positionDict.get(itemHash)
    if not p:
        # Fix bug: https://github.com/leo-editor/leo-editor/issues/59
        # Drop at last node.
        p = c.rootPosition()
        while p.hasNext():
            p.moveToNext()
    formats = set(str(f) for f in md.formats())
    ev.setDropAction(QtCore.Qt.IgnoreAction)
    ev.accept()
    hookres = g.doHook("outlinedrop", c=c, p=p, dropevent=ev, formats=formats)
    if hookres:
        # A plugin handled the drop.
        if trace: g.trace('hookres is True')
    else:
        if trace and trace_dump: self.dump(ev, p, 'drop ')
        if md.hasUrls():
            self.urlDrop(md, p)
        else:
            self.nodeDrop(md, p)
    g.app.dragging = False
.. @+node:ekr.20170624151245.3573: *9* LeoQTreeWidget.nodeDrop & helpers
def nodeDrop(self, md, p):
    '''
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    '''
    trace = False and not g.unitTesting
    c = self.c
    fn, s = self.parseText(md)
    if trace: g.trace('fn', fn, 'self.fileName()', self.fileName())
    if not s or not fn:
        if trace: g.trace('no fn or no s', fn, len(s or ''))
    elif fn == self.fileName():
        if p and p == c.p:
            if trace: g.trace('drag to same node')
        elif g.os_path_exists(fn):
            if trace: g.trace('intra-file drop')
            self.intraFileDrop(fn, c.p, p)
        else:
            if trace: g.trace('does not exist', fn)
    else:
        if trace: g.trace('inter-file drag')
        self.interFileDrop(fn, p, s)
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3580: *9* LeoQTreeWidget.urlDrop & helpers
def urlDrop(self, md, p):
    '''Handle a drop when md.urls().'''
    trace = False and not g.unitTesting
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        if trace: g.trace('no urs')
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',): # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
        # else: g.trace(url.scheme(),url)
    if trace: g.trace('changed', changed)
    if changed:
        c.setChanged(True)
        u.afterChangeGroup(c.p, undoType, reportFlag=False, dirtyVnodeList=[])
        c.redraw_now()
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3573: *9* LeoQTreeWidget.nodeDrop & helpers
def nodeDrop(self, md, p):
    '''
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    '''
    trace = False and not g.unitTesting
    c = self.c
    fn, s = self.parseText(md)
    if trace: g.trace('fn', fn, 'self.fileName()', self.fileName())
    if not s or not fn:
        if trace: g.trace('no fn or no s', fn, len(s or ''))
    elif fn == self.fileName():
        if p and p == c.p:
            if trace: g.trace('drag to same node')
        elif g.os_path_exists(fn):
            if trace: g.trace('intra-file drop')
            self.intraFileDrop(fn, c.p, p)
        else:
            if trace: g.trace('does not exist', fn)
    else:
        if trace: g.trace('inter-file drag')
        self.interFileDrop(fn, p, s)
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3577: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    '''Paste the mime data after (or as the first child of) p.'''
    trace = False and not g.unitTesting
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        if trace: g.trace('no isLeo')
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s, reassignIndices=True)
        # Paste the node after the presently selected node.
    if not pasted:
        if trace: g.trace('not pasted!')
        return
    if trace: g.trace('pasting...')
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p,
        pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw_now(pasted)
    c.recolor()
.. @+node:ekr.20170624151245.3578: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    '''Move p1 after (or as the first child of) p2.'''
    trace = False and not g.unitTesting
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if trace: g.trace('ok', ok, 'cloneDrag', cloneDrag)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1, 'Drag', undoData, dirtyVnodeList)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw_now(p1)
        else:
            c.redraw_now(p2)
    # elif trace: g.trace('** move failed')
.. @+node:ekr.20170624151245.3579: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
.. @+node:ekr.20170624151245.3580: *9* LeoQTreeWidget.urlDrop & helpers
def urlDrop(self, md, p):
    '''Handle a drop when md.urls().'''
    trace = False and not g.unitTesting
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        if trace: g.trace('no urs')
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',): # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
        # else: g.trace(url.scheme(),url)
    if trace: g.trace('changed', changed)
    if changed:
        c.setChanged(True)
        u.afterChangeGroup(c.p, undoType, reportFlag=False, dirtyVnodeList=[])
        c.redraw_now()
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3671: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    '''Read the file given by the url and put it in the outline.'''
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb') # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print('not found: %s' % (fn))
    return False
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3716: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    '''
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    '''
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False # Don't set the changed marker in the original file.
    else:
        u, undoType = c.undoer, 'Drag File'
        undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
        if p.hasChildren() and p.isExpanded():
            p2 = p.insertAsNthChild(0)
            parent = p
        elif p.h.startswith('@path '):
            # Fix bug https://github.com/leo-editor/leo-editor/issues/60
            # create relative paths & urls when dragging files
            p2 = p.insertAsNthChild(0)
            p.expand()
            parent = p
        else:
            p2 = p.insertAfter()
            parent = p.parent()
        # Fix bug https://github.com/leo-editor/leo-editor/issues/60
        # create relative paths & urls when dragging files
        aList = g.get_directives_dict_list(parent)
        path = g.scanAtPathDirectives(c, aList)
        # g.trace(p.h,path)
        if path:
            fn = os.path.relpath(fn, path)
            fn = g.toUnicodeFileEncoding(fn)
        self.createAtFileNode(fn, p2, s)
        u.afterInsertNode(p2, undoType, undoData)
        c.selectPosition(p2)
        return True # The original .leo file has changed.
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3738: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    '''
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('=====', g.callers())
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3749: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@auto %s' % (fn)
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3750: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3751: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''
    c = self.c; at = c.atFileCommands
    p.h = '@file %s' % (fn)
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
.. @+node:ekr.20170624151245.3752: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    '''Copy all nodes from fn, a .leo file, to the children of p.'''
    c = self.c
    p.h = 'From %s' % g.shortFileName(fn)
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(
            s, reassignIndices=True)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
.. @+node:ekr.20170624151245.3753: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3: # Don't just strip off c:\.
        p.h = abs_fn[len(prefix):].strip()
    else:
        p.h = '@url file://%s' % fn
.. @+node:ekr.20170624151245.3754: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    '''Return true if fn (a file name) can be parsed with an @auto parser.'''
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
.. @+node:ekr.20170624151245.3755: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict.keys())
        val = ext not in keys
    # g.trace('binary',ext,val)
    return val
.. @+node:ekr.20170624151245.3756: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    '''Return true if fn (a file name) represents an entire .leo file.'''
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
.. @+node:ekr.20170624151245.3757: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
.. @+node:ekr.20170624151245.3758: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
.. @+node:ekr.20170624151245.3759: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    '''Insert fn as an @path node after p.'''
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
.. @+node:ekr.20170624151245.3760: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    '''Insert the url in an @url node after p.'''
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    # 2014/06/06: this code may be necessary.  More testing is needed.
    # e = sys.getfilesystemencoding()
    # s = g.toUnicode(url.toString(),encoding=e)
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
.. @+node:ekr.20170624151245.3761: *7* LeoQTreeWidget: utils
.. @+node:ekr.20170624151245.3764: *8* LeoQTreeWidget.dump
def dump(self, ev, p, tag):
    if ev:
        md = ev.mimeData()
        s = g.toUnicode(md.text(), 'utf-8')
        g.trace('md.text:', repr(s) if len(s) < 100 else len(s))
        for url in md.urls() or []:
            g.trace('     url:', url)
            g.trace('  url.fn:', url.toLocalFile())
            g.trace('url.text:', url.toString())
    else:
        g.trace('', tag, '** no event!')
.. @+node:ekr.20170624151245.3765: *8* LeoQTreeWidget.fileName
def fileName(self):
    '''Return the commander's filename.'''
    return self.c.fileName() or '<unsaved file>'
.. @+node:ekr.20170624151245.3764: *8* LeoQTreeWidget.dump
def dump(self, ev, p, tag):
    if ev:
        md = ev.mimeData()
        s = g.toUnicode(md.text(), 'utf-8')
        g.trace('md.text:', repr(s) if len(s) < 100 else len(s))
        for url in md.urls() or []:
            g.trace('     url:', url)
            g.trace('  url.fn:', url.toLocalFile())
            g.trace('url.text:', url.toString())
    else:
        g.trace('', tag, '** no event!')
.. @+node:ekr.20170624151245.3765: *8* LeoQTreeWidget.fileName
def fileName(self):
    '''Return the commander's filename.'''
    return self.c.fileName() or '<unsaved file>'
.. @+node:ekr.20170624151245.3766: *6* class NullBody (LeoBody)
class NullBody(LeoBody):
    '''A do-nothing body class.'''
    @others
.. @+node:ekr.20170624151245.3769: *7*  NullBody.__init__
def __init__(self, frame, parentFrame):
    '''Ctor for NullBody class.'''
    # g.trace('NullBody','frame',frame,g.callers())
    LeoBody.__init__(self, frame, parentFrame)
        # Init the base class.
    self.insertPoint = 0
    self.selection = 0, 0
    self.s = "" # The body text
    self.widget = None
    self.wrapper = wrapper = StringTextWrapper(c=self.c, name='body')
    self.editorWidgets['1'] = wrapper
    self.colorizer = NullColorizer(self.c)
.. @+node:ekr.20170624151245.3770: *7* NullBody: LeoBody interface
# Birth, death...

def createControl(self, parentFrame, p): pass
# Editors...

def addEditor(self, event=None): pass

def assignPositionToEditor(self, p): pass

def createEditorFrame(self, w): return None

def cycleEditorFocus(self, event=None): pass

def deleteEditor(self, event=None): pass

def selectEditor(self, w): pass

def selectLabel(self, w): pass

def setEditorColors(self, bg, fg): pass

def unselectLabel(self, w): pass

def updateEditors(self): pass
# Events...

def forceFullRecolor(self): pass

def scheduleIdleTimeRoutine(self, function, *args, **keys): pass
# Low-level gui...

def setFocus(self): pass
.. @+node:ekr.20170624151245.3769: *7*  NullBody.__init__
def __init__(self, frame, parentFrame):
    '''Ctor for NullBody class.'''
    # g.trace('NullBody','frame',frame,g.callers())
    LeoBody.__init__(self, frame, parentFrame)
        # Init the base class.
    self.insertPoint = 0
    self.selection = 0, 0
    self.s = "" # The body text
    self.widget = None
    self.wrapper = wrapper = StringTextWrapper(c=self.c, name='body')
    self.editorWidgets['1'] = wrapper
    self.colorizer = NullColorizer(self.c)
.. @+node:ekr.20170624151245.3770: *7* NullBody: LeoBody interface
# Birth, death...

def createControl(self, parentFrame, p): pass
# Editors...

def addEditor(self, event=None): pass

def assignPositionToEditor(self, p): pass

def createEditorFrame(self, w): return None

def cycleEditorFocus(self, event=None): pass

def deleteEditor(self, event=None): pass

def selectEditor(self, w): pass

def selectLabel(self, w): pass

def setEditorColors(self, bg, fg): pass

def unselectLabel(self, w): pass

def updateEditors(self): pass
# Events...

def forceFullRecolor(self): pass

def scheduleIdleTimeRoutine(self, function, *args, **keys): pass
# Low-level gui...

def setFocus(self): pass
.. @+node:ekr.20170624151245.3771: *6* class NullColorizer (BaseColorizer)
class NullColorizer(leoColorizer.BaseColorizer):
    '''A colorizer class that doesn't color.'''
    pass
.. @+node:ekr.20170624151245.3772: *6* class NullFrame (LeoFrame)
class NullFrame(LeoFrame):
    '''A null frame class for tests and batch execution.'''
    @others
.. @+node:ekr.20170624151245.3775: *7* NullFrame.ctor
def __init__(self, c, title, gui):
    '''Ctor for the NullFrame class.'''
    # g.trace('NullFrame')
    LeoFrame.__init__(self, c, gui)
        # Init the base class.
    assert self.c
    self.wrapper = None
    self.iconBar = NullIconBarClass(self.c, self)
    self.isNullFrame = True
    self.outerFrame = None
    self.ratio = self.secondary_ratio = 0.5
    self.statusLineClass = NullStatusLineClass
    self.title = title
    self.top = None # Always None.
    # Create the component objects.
    self.body = NullBody(frame=self, parentFrame=None)
    self.log = NullLog(frame=self, parentFrame=None)
    self.menu = LeoMenu.NullMenu(frame=self)
    self.tree = NullTree(frame=self)
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
.. @+node:ekr.20170624151245.3776: *7* NullFrame.do nothings
def bringToFront(self): pass
def cascade(self, event=None): pass
def contractBodyPane(self, event=None): pass
def contractLogPane(self, event=None): pass
def contractOutlinePane(self, event=None): pass
def contractPane(self, event=None): pass
def deiconify(self): pass
def destroySelf(self): pass
def equalSizedPanes(self, event=None): pass
def expandBodyPane(self, event=None): pass
def expandLogPane(self, event=None): pass
def expandOutlinePane(self, event=None): pass
def expandPane(self, event=None): pass
def finishCreate(self): pass
def fullyExpandBodyPane(self, event=None): pass
def fullyExpandLogPane(self, event=None): pass
def fullyExpandOutlinePane(self, event=None): pass
def fullyExpandPane(self, event=None): pass
def get_window_info(self): return 600, 500, 20, 20
def hideBodyPane(self, event=None): pass
def hideLogPane(self, event=None): pass
def hideLogWindow(self, event=None): pass
def hideOutlinePane(self, event=None): pass
def hidePane(self, event=None): pass
def leoHelp(self, event=None): pass
def lift(self): pass
def minimizeAll(self, event=None): pass
def oops(self): g.trace("NullFrame", g.callers(4))
def resizePanesToRatio(self, ratio, secondary_ratio): pass
def resizeToScreen(self, event=None): pass
def setInitialWindowGeometry(self): pass
def setTopGeometry(self, w, h, x, y, adjustSize=True): return 0, 0, 0, 0
def setWrap(self, flag, force=False): pass
def toggleActivePane(self, event=None): pass
def toggleSplitDirection(self, event=None): pass
def update(self): pass
.. @+node:ekr.20170624151245.3775: *7* NullFrame.ctor
def __init__(self, c, title, gui):
    '''Ctor for the NullFrame class.'''
    # g.trace('NullFrame')
    LeoFrame.__init__(self, c, gui)
        # Init the base class.
    assert self.c
    self.wrapper = None
    self.iconBar = NullIconBarClass(self.c, self)
    self.isNullFrame = True
    self.outerFrame = None
    self.ratio = self.secondary_ratio = 0.5
    self.statusLineClass = NullStatusLineClass
    self.title = title
    self.top = None # Always None.
    # Create the component objects.
    self.body = NullBody(frame=self, parentFrame=None)
    self.log = NullLog(frame=self, parentFrame=None)
    self.menu = LeoMenu.NullMenu(frame=self)
    self.tree = NullTree(frame=self)
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
.. @+node:ekr.20170624151245.3776: *7* NullFrame.do nothings
def bringToFront(self): pass
def cascade(self, event=None): pass
def contractBodyPane(self, event=None): pass
def contractLogPane(self, event=None): pass
def contractOutlinePane(self, event=None): pass
def contractPane(self, event=None): pass
def deiconify(self): pass
def destroySelf(self): pass
def equalSizedPanes(self, event=None): pass
def expandBodyPane(self, event=None): pass
def expandLogPane(self, event=None): pass
def expandOutlinePane(self, event=None): pass
def expandPane(self, event=None): pass
def finishCreate(self): pass
def fullyExpandBodyPane(self, event=None): pass
def fullyExpandLogPane(self, event=None): pass
def fullyExpandOutlinePane(self, event=None): pass
def fullyExpandPane(self, event=None): pass
def get_window_info(self): return 600, 500, 20, 20
def hideBodyPane(self, event=None): pass
def hideLogPane(self, event=None): pass
def hideLogWindow(self, event=None): pass
def hideOutlinePane(self, event=None): pass
def hidePane(self, event=None): pass
def leoHelp(self, event=None): pass
def lift(self): pass
def minimizeAll(self, event=None): pass
def oops(self): g.trace("NullFrame", g.callers(4))
def resizePanesToRatio(self, ratio, secondary_ratio): pass
def resizeToScreen(self, event=None): pass
def setInitialWindowGeometry(self): pass
def setTopGeometry(self, w, h, x, y, adjustSize=True): return 0, 0, 0, 0
def setWrap(self, flag, force=False): pass
def toggleActivePane(self, event=None): pass
def toggleSplitDirection(self, event=None): pass
def update(self): pass
.. @+node:ekr.20170624151245.3777: *6* class NullGui (LeoGui)
class NullGui(LeoGui):
    """Null gui class."""
    @others
.. @+node:ekr.20170624151245.3786: *7* NullGui.__init__
def __init__(self, guiName='nullGui'):
    '''ctor for the NullGui class.'''
    LeoGui.__init__(self, guiName)
        # init the base class.
    self.clipboardContents = ''
    ### self.theDict = {}
    self.focusWidget = None
    ### self.frameFactory = g.NullObject()
    ### self.iconimages = {}
    ### self.insert_char_flag = False
    self.script = None
    self.lastFrame = None
        # The outer frame, used only to set the g.app.log in runMainLoop.
    self.isNullGui = True
    ### self.plainTextWidget = leoFrame.StringTextWrapper
.. @+node:ekr.20170624151245.3787: *7* NullGui.dialogs
def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    return self.simulateDialog("aboutLeoDialog", None)

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog", None)

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    return self.simulateDialog("okDialog", "Ok")

def runAskOkCancelNumberDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
):
    return self.simulateDialog("numberDialog", -1)

def runAskOkCancelStringDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
    default="",
    wide=False,
):
    return self.simulateDialog("stringDialog", '')

def runCompareDialog(self, c):
    return self.simulateDialog("compareDialog", '')

def runOpenFileDialog(self, c, title, filetypes, defaultextension,
    multiple=False,
    startpath=None,
):
    return self.simulateDialog("openFileDialog", None)

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    return self.simulateDialog("saveFileDialog", None)

def runAskYesNoDialog(self, c, title,
    message=None,
    yes_all=False,
    no_all=False,
):
    return self.simulateDialog("yesNoDialog", "no")

def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    return self.simulateDialog("yesNoCancelDialog", "cancel")
    
def simulateDialog(self, key, defaultVal):
    return defaultVal
.. @+node:ekr.20170624151245.3788: *7* NullGui.clipboard & focus
def get_focus(self, *args, **kwargs):
    return self.focusWidget

def getTextFromClipboard(self):
    return self.clipboardContents

def replaceClipboardWith(self, s):
    self.clipboardContents = s

def set_focus(self, commander, widget):
    self.focusWidget = widget
.. @+node:ekr.20170624151245.3789: *7* NullGui.do nothings
def alert(self, message): pass
def attachLeoIcon(self, window): pass
def destroySelf(self): pass
def finishCreate(self): pass
def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    return g.app.config.defaultFont
def getIconImage(self, name): return None
def getImageImage(self, name): return None
def getTreeImage(self, c, path): return None
def get_window_info(self, window): return 600, 500, 20, 20
def onActivateEvent(self, *args, **keys): pass
def onDeactivateEvent(self, *args, **keys): pass
.. @+node:ekr.20170624151245.3790: *7* NullGui.isTextWidget & isTextWrapper
def isTextWidget(self, w):
    return True # Must be True for unit tests.

def isTextWrapper(self, w):
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    return w and getattr(w, 'supportsHighLevelInterface', None)
.. @+node:ekr.20170624151245.3791: *7* NullGui.oops
def oops(self):
    g.trace("NullGui", g.callers(4))
.. @+node:ekr.20170624151245.3792: *7* NullGui.panels
def createComparePanel(self, c):
    """Create Compare panel."""
    self.oops()

def createFindTab(self, c, parentFrame):
    """Create a find tab in the indicated frame."""
    pass # Now always done during startup.

def createLeoFrame(self, c, title):
    """Create a null Leo Frame."""
    gui = self
    self.lastFrame = leoFrame.NullFrame(c, title, gui)
    return self.lastFrame
.. @+node:ekr.20170624151245.3793: *7* NullGui.runMainLoop
def runMainLoop(self):
    """Run the null gui's main loop."""
    if self.script:
        frame = self.lastFrame
        g.app.log = frame.log
        # g.es("start of batch script...\n")
        self.lastFrame.c.executeScript(script=self.script)
        # g.es("\nend of batch script")
    else:
        print('**** NullGui.runMainLoop: terminating Leo.')
    # Getting here will terminate Leo.
.. @+node:ekr.20170624151245.3786: *7* NullGui.__init__
def __init__(self, guiName='nullGui'):
    '''ctor for the NullGui class.'''
    LeoGui.__init__(self, guiName)
        # init the base class.
    self.clipboardContents = ''
    ### self.theDict = {}
    self.focusWidget = None
    ### self.frameFactory = g.NullObject()
    ### self.iconimages = {}
    ### self.insert_char_flag = False
    self.script = None
    self.lastFrame = None
        # The outer frame, used only to set the g.app.log in runMainLoop.
    self.isNullGui = True
    ### self.plainTextWidget = leoFrame.StringTextWrapper
.. @+node:ekr.20170624151245.3787: *7* NullGui.dialogs
def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    return self.simulateDialog("aboutLeoDialog", None)

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog", None)

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    return self.simulateDialog("okDialog", "Ok")

def runAskOkCancelNumberDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
):
    return self.simulateDialog("numberDialog", -1)

def runAskOkCancelStringDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
    default="",
    wide=False,
):
    return self.simulateDialog("stringDialog", '')

def runCompareDialog(self, c):
    return self.simulateDialog("compareDialog", '')

def runOpenFileDialog(self, c, title, filetypes, defaultextension,
    multiple=False,
    startpath=None,
):
    return self.simulateDialog("openFileDialog", None)

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    return self.simulateDialog("saveFileDialog", None)

def runAskYesNoDialog(self, c, title,
    message=None,
    yes_all=False,
    no_all=False,
):
    return self.simulateDialog("yesNoDialog", "no")

def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    return self.simulateDialog("yesNoCancelDialog", "cancel")
    
def simulateDialog(self, key, defaultVal):
    return defaultVal
.. @+node:ekr.20170624151245.3788: *7* NullGui.clipboard & focus
def get_focus(self, *args, **kwargs):
    return self.focusWidget

def getTextFromClipboard(self):
    return self.clipboardContents

def replaceClipboardWith(self, s):
    self.clipboardContents = s

def set_focus(self, commander, widget):
    self.focusWidget = widget
.. @+node:ekr.20170624151245.3789: *7* NullGui.do nothings
def alert(self, message): pass
def attachLeoIcon(self, window): pass
def destroySelf(self): pass
def finishCreate(self): pass
def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    return g.app.config.defaultFont
def getIconImage(self, name): return None
def getImageImage(self, name): return None
def getTreeImage(self, c, path): return None
def get_window_info(self, window): return 600, 500, 20, 20
def onActivateEvent(self, *args, **keys): pass
def onDeactivateEvent(self, *args, **keys): pass
.. @+node:ekr.20170624151245.3790: *7* NullGui.isTextWidget & isTextWrapper
def isTextWidget(self, w):
    return True # Must be True for unit tests.

def isTextWrapper(self, w):
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    return w and getattr(w, 'supportsHighLevelInterface', None)
.. @+node:ekr.20170624151245.3791: *7* NullGui.oops
def oops(self):
    g.trace("NullGui", g.callers(4))
.. @+node:ekr.20170624151245.3792: *7* NullGui.panels
def createComparePanel(self, c):
    """Create Compare panel."""
    self.oops()

def createFindTab(self, c, parentFrame):
    """Create a find tab in the indicated frame."""
    pass # Now always done during startup.

def createLeoFrame(self, c, title):
    """Create a null Leo Frame."""
    gui = self
    self.lastFrame = leoFrame.NullFrame(c, title, gui)
    return self.lastFrame
.. @+node:ekr.20170624151245.3793: *7* NullGui.runMainLoop
def runMainLoop(self):
    """Run the null gui's main loop."""
    if self.script:
        frame = self.lastFrame
        g.app.log = frame.log
        # g.es("start of batch script...\n")
        self.lastFrame.c.executeScript(script=self.script)
        # g.es("\nend of batch script")
    else:
        print('**** NullGui.runMainLoop: terminating Leo.')
    # Getting here will terminate Leo.
.. @+node:ekr.20170624151245.3794: *6* class NullLog (LeoLog)
class NullLog(LeoLog):
    '''A do-nothing log class.'''
    @others
.. @+node:ekr.20170624151245.3808: *7* Birth
.. @+node:ekr.20170624151245.3813: *8* NullLog.__init__
def __init__(self, frame=None, parentFrame=None):
    # Init the base class.
    LeoLog.__init__(self, frame, parentFrame)
    self.isNull = True
    self.logNumber = 0
    self.widget = self.createControl(parentFrame)
        # self.logCtrl is now a property of the base LeoLog class.
.. @+node:ekr.20170624151245.3814: *8* finishCreate (NullLog)
def finishCreate(self):
    pass
.. @+node:ekr.20170624151245.3815: *8* createControl
def createControl(self, parentFrame):
    return self.createTextWidget(parentFrame)
.. @+node:ekr.20170624151245.3816: *8* createTextWidget (NullLog)
def createTextWidget(self, parentFrame):
    self.logNumber += 1
    c = self.c
    log = StringTextWrapper(c=c, name="log-%d" % self.logNumber)
    return log
.. @+node:ekr.20170624151245.3813: *8* NullLog.__init__
def __init__(self, frame=None, parentFrame=None):
    # Init the base class.
    LeoLog.__init__(self, frame, parentFrame)
    self.isNull = True
    self.logNumber = 0
    self.widget = self.createControl(parentFrame)
        # self.logCtrl is now a property of the base LeoLog class.
.. @+node:ekr.20170624151245.3814: *8* finishCreate (NullLog)
def finishCreate(self):
    pass
.. @+node:ekr.20170624151245.3815: *8* createControl
def createControl(self, parentFrame):
    return self.createTextWidget(parentFrame)
.. @+node:ekr.20170624151245.3816: *8* createTextWidget (NullLog)
def createTextWidget(self, parentFrame):
    self.logNumber += 1
    c = self.c
    log = StringTextWrapper(c=c, name="log-%d" % self.logNumber)
    return log
.. @+node:ekr.20170624151245.3817: *7* isLogWidget (NullLog)
def isLogWidget(self, w):
    return False
.. @+node:ekr.20170624151245.3818: *7* oops
def oops(self):
    g.trace("NullLog:", g.callers(4))
.. @+node:ekr.20170624151245.3819: *7* put and putnl (NullLog)
def put(self, s, color=None, tabName='Log', from_redirect=False):
    # print('(nullGui) print',repr(s))
    if self.enabled:
        try:
            g.pr(s, newline=False)
        except UnicodeError:
            s = s.encode('ascii', 'replace')
            g.pr(s, newline=False)

def putnl(self, tabName='Log'):
    if self.enabled:
        g.pr('')
.. @+node:ekr.20170624151245.3820: *7* tabs (NullLog)
def clearTab(self, tabName, wrap='none'): pass

def createCanvas(self, tabName): pass

def createTab(self, tabName, createText=True, widget=None, wrap='none'): pass

def deleteTab(self, tabName, force=False): pass

def getSelectedTab(self): return None

def lowerTab(self, tabName): pass

def raiseTab(self, tabName): pass

def renameTab(self, oldName, newName): pass

def selectTab(self, tabName, createText=True, widget=None, wrap='none'): pass
.. @+node:ekr.20170624151245.3808: *7* Birth
.. @+node:ekr.20170624151245.3813: *8* NullLog.__init__
def __init__(self, frame=None, parentFrame=None):
    # Init the base class.
    LeoLog.__init__(self, frame, parentFrame)
    self.isNull = True
    self.logNumber = 0
    self.widget = self.createControl(parentFrame)
        # self.logCtrl is now a property of the base LeoLog class.
.. @+node:ekr.20170624151245.3814: *8* finishCreate (NullLog)
def finishCreate(self):
    pass
.. @+node:ekr.20170624151245.3815: *8* createControl
def createControl(self, parentFrame):
    return self.createTextWidget(parentFrame)
.. @+node:ekr.20170624151245.3816: *8* createTextWidget (NullLog)
def createTextWidget(self, parentFrame):
    self.logNumber += 1
    c = self.c
    log = StringTextWrapper(c=c, name="log-%d" % self.logNumber)
    return log
.. @+node:ekr.20170624151245.3813: *8* NullLog.__init__
def __init__(self, frame=None, parentFrame=None):
    # Init the base class.
    LeoLog.__init__(self, frame, parentFrame)
    self.isNull = True
    self.logNumber = 0
    self.widget = self.createControl(parentFrame)
        # self.logCtrl is now a property of the base LeoLog class.
.. @+node:ekr.20170624151245.3814: *8* finishCreate (NullLog)
def finishCreate(self):
    pass
.. @+node:ekr.20170624151245.3815: *8* createControl
def createControl(self, parentFrame):
    return self.createTextWidget(parentFrame)
.. @+node:ekr.20170624151245.3816: *8* createTextWidget (NullLog)
def createTextWidget(self, parentFrame):
    self.logNumber += 1
    c = self.c
    log = StringTextWrapper(c=c, name="log-%d" % self.logNumber)
    return log
.. @+node:ekr.20170624151245.3817: *7* isLogWidget (NullLog)
def isLogWidget(self, w):
    return False
.. @+node:ekr.20170624151245.3818: *7* oops
def oops(self):
    g.trace("NullLog:", g.callers(4))
.. @+node:ekr.20170624151245.3819: *7* put and putnl (NullLog)
def put(self, s, color=None, tabName='Log', from_redirect=False):
    # print('(nullGui) print',repr(s))
    if self.enabled:
        try:
            g.pr(s, newline=False)
        except UnicodeError:
            s = s.encode('ascii', 'replace')
            g.pr(s, newline=False)

def putnl(self, tabName='Log'):
    if self.enabled:
        g.pr('')
.. @+node:ekr.20170624151245.3820: *7* tabs (NullLog)
def clearTab(self, tabName, wrap='none'): pass

def createCanvas(self, tabName): pass

def createTab(self, tabName, createText=True, widget=None, wrap='none'): pass

def deleteTab(self, tabName, force=False): pass

def getSelectedTab(self): return None

def lowerTab(self, tabName): pass

def raiseTab(self, tabName): pass

def renameTab(self, oldName, newName): pass

def selectTab(self, tabName, createText=True, widget=None, wrap='none'): pass
.. @+node:ekr.20170624151245.3821: *6* class NullMiniBuffer (StringTextWrapper)
class NullMiniBuffer (StringTextWrapper): ### QMinibufferWrapper(QLineEditWrapper):

    def __init__(self, c):
        '''Ctor for NullMiniBuffer class.'''
        self.c = c
        StringTextWrapper.__init__(self, c=c, name='minibuffer')
        assert self.widget is None
        self.widget = g.NullObject()
        ### g.app.gui.setFilter(c, w, self, tag='minibuffer')

    def setStyleClass(self, style_class):
        pass
        ###
            # self.widget.setProperty('style_class', style_class)
            # self.widget.setStyleSheet(self.c.frame.top.styleSheet())
.. @+node:ekr.20170624151245.3822: *6* class NullTree (LeoTree)
class NullTree(LeoTree):
    '''A do-almost-nothing tree class.'''
    @others
.. @+node:ekr.20170624151245.3829: *7*  NullTree.__init__
def __init__(self, frame):
    '''Ctor for NullTree class.'''
    LeoTree.__init__(self, frame) # Init the base class.
    assert(self.frame)
    self.c = frame.c
    self.editWidgetsDict = {} # Keys are tnodes, values are StringTextWidgets.
    self.font = None
    self.fontName = None
    self.canvas = None
    self.redrawCount = 0
    self.trace_edit = False
    self.trace_select = False
    self.updateCount = 0
.. @+node:ekr.20170624151245.3830: *7* NullTree.edit_widget
def edit_widget(self, p):
    d = self.editWidgetsDict
    if not p or not p.v:
        return None
    w = d.get(p.v)
    if not w:
        d[p.v] = w = StringTextWrapper(
            c=self.c,
            name='head-%d' % (1 + len(list(d.keys()))))
        w.setAllText(p.h)
    return w
.. @+node:ekr.20170624151245.3831: *7* NullTree.editLabel
def editLabel(self, p, selectAll=False, selection=None):
    '''Start editing p's headline.'''
    self.endEditLabel()
    if p:
        self.revertHeadline = p.h
            # New in 4.4b2: helps undo.
        wrapper = StringTextWrapper(c=self.c, name='head-wrapper')
        e = None
        return e, wrapper
    else:
        return None, None
.. @+node:ekr.20170624151245.3832: *7* NullTree.printWidgets
def printWidgets(self):
    d = self.editWidgetsDict
    for key in d:
        # keys are vnodes, values are StringTextWidgets.
        w = d.get(key)
        g.pr('w', w, 'v.h:', key.headString, 's:', repr(w.s))
.. @+node:ekr.20170624151245.3833: *7* NullTree.Drawing & scrolling
def drawIcon(self, p):
    pass

def redraw(self, p=None, scroll=True, forceDraw=False):
    self.redrawCount += 1
    # g.trace(p and p.h, self.c.p.h)

def redraw_now(self, p=None, scroll=True, forceDraw=False):
    self.redraw(p)

def redraw_after_contract(self, p=None): self.redraw()

def redraw_after_expand(self, p=None): self.redraw()

def redraw_after_head_changed(self): self.redraw()

def redraw_after_icons_changed(self): self.redraw()

def redraw_after_select(self, p=None): self.redraw()

def scrollTo(self, p):
    pass
.. @+node:ekr.20170624151245.3834: *7* NullTree.setHeadline
def setHeadline(self, p, s):
    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''
    # g.trace('p',p.h,'s',repr(s),g.callers())
    w = self.edit_widget(p)
    if w:
        w.delete(0, 'end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[: -1]
        w.insert(0, s)
        self.revertHeadline = s
        # g.trace(repr(s),w.getAllText())
    else:
        g.trace('-' * 20, 'oops')
.. @+node:ekr.20170624151245.3829: *7*  NullTree.__init__
def __init__(self, frame):
    '''Ctor for NullTree class.'''
    LeoTree.__init__(self, frame) # Init the base class.
    assert(self.frame)
    self.c = frame.c
    self.editWidgetsDict = {} # Keys are tnodes, values are StringTextWidgets.
    self.font = None
    self.fontName = None
    self.canvas = None
    self.redrawCount = 0
    self.trace_edit = False
    self.trace_select = False
    self.updateCount = 0
.. @+node:ekr.20170624151245.3830: *7* NullTree.edit_widget
def edit_widget(self, p):
    d = self.editWidgetsDict
    if not p or not p.v:
        return None
    w = d.get(p.v)
    if not w:
        d[p.v] = w = StringTextWrapper(
            c=self.c,
            name='head-%d' % (1 + len(list(d.keys()))))
        w.setAllText(p.h)
    return w
.. @+node:ekr.20170624151245.3831: *7* NullTree.editLabel
def editLabel(self, p, selectAll=False, selection=None):
    '''Start editing p's headline.'''
    self.endEditLabel()
    if p:
        self.revertHeadline = p.h
            # New in 4.4b2: helps undo.
        wrapper = StringTextWrapper(c=self.c, name='head-wrapper')
        e = None
        return e, wrapper
    else:
        return None, None
.. @+node:ekr.20170624151245.3832: *7* NullTree.printWidgets
def printWidgets(self):
    d = self.editWidgetsDict
    for key in d:
        # keys are vnodes, values are StringTextWidgets.
        w = d.get(key)
        g.pr('w', w, 'v.h:', key.headString, 's:', repr(w.s))
.. @+node:ekr.20170624151245.3833: *7* NullTree.Drawing & scrolling
def drawIcon(self, p):
    pass

def redraw(self, p=None, scroll=True, forceDraw=False):
    self.redrawCount += 1
    # g.trace(p and p.h, self.c.p.h)

def redraw_now(self, p=None, scroll=True, forceDraw=False):
    self.redraw(p)

def redraw_after_contract(self, p=None): self.redraw()

def redraw_after_expand(self, p=None): self.redraw()

def redraw_after_head_changed(self): self.redraw()

def redraw_after_icons_changed(self): self.redraw()

def redraw_after_select(self, p=None): self.redraw()

def scrollTo(self, p):
    pass
.. @+node:ekr.20170624151245.3834: *7* NullTree.setHeadline
def setHeadline(self, p, s):
    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''
    # g.trace('p',p.h,'s',repr(s),g.callers())
    w = self.edit_widget(p)
    if w:
        w.delete(0, 'end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[: -1]
        w.insert(0, s)
        self.revertHeadline = s
        # g.trace(repr(s),w.getAllText())
    else:
        g.trace('-' * 20, 'oops')
.. @+node:ekr.20170624151245.3835: *6* class StringGui (NullGui)
class StringGui(LeoGui):
    '''
    A class representing all on-screen objects using subclasses of the
    leoFrame.StringTextWrapper class.
    '''
    @others
.. @+node:ekr.20170624151245.3839: *7* StringGui.__init__ (not used yet)
# def __init__(self, guiName='StringGui'):
    # '''ctor for the StringGui class.'''
    # LeoGui.__init__(self, guiName)
        # # init the base class.
    # self.clipboardContents = ''
    # self.theDict = {}
    # self.focusWidget = None
    # self.frameFactory = g.NullObject()
    # self.iconimages = {}
    # ### self.insert_char_flag = False
    # self.script = None
    # self.isNullGui = True
    # ### self.plainTextWidget = leoFrame.StringTextWrapper
.. @+node:ekr.20170624151245.3840: *7* StringGui.oops
def oops(self):
    g.trace("StringGui", g.callers(4))
.. @+node:ekr.20170624151245.3841: *7* StringGui.runMainLoop
def runMainLoop(self):
    self.oops()
.. @+node:ekr.20170624151245.3839: *7* StringGui.__init__ (not used yet)
# def __init__(self, guiName='StringGui'):
    # '''ctor for the StringGui class.'''
    # LeoGui.__init__(self, guiName)
        # # init the base class.
    # self.clipboardContents = ''
    # self.theDict = {}
    # self.focusWidget = None
    # self.frameFactory = g.NullObject()
    # self.iconimages = {}
    # ### self.insert_char_flag = False
    # self.script = None
    # self.isNullGui = True
    # ### self.plainTextWidget = leoFrame.StringTextWrapper
.. @+node:ekr.20170624151245.3840: *7* StringGui.oops
def oops(self):
    g.trace("StringGui", g.callers(4))
.. @+node:ekr.20170624151245.3841: *7* StringGui.runMainLoop
def runMainLoop(self):
    self.oops()
.. @+node:ekr.20170624151245.3842: *6* class StringTextWrapper
class StringTextWrapper(object):
    '''A class that represents text as a Python string.'''
    @others
.. @+node:ekr.20170624151245.3879: *7* stw.ctor
def __init__(self, c, name):
    '''Ctor for the StringTextWrapper class.'''
    self.c = c
    self.name = name
    self.ins = 0
    self.sel = 0, 0
    self.s = ''
    self.supportsHighLevelInterface = True
    self.widget = None # This ivar must exist, and be None.
    self.trace = False

def __repr__(self):
    return '<StringTextWrapper: %s %s>' % (id(self), self.name)

def getName(self):
    '''StringTextWrapper.'''
    return self.name # Essential.
.. @+node:ekr.20170624151245.3880: *7* stw.Clipboard
def clipboard_clear(self):
    g.app.gui.replaceClipboardWith('')

def clipboard_append(self, s):
    s1 = g.app.gui.getTextFromClipboard()
    g.app.gui.replaceClipboardWith(s1 + s)
.. @+node:ekr.20170624151245.3881: *7* stw.Do-nothings
# For StringTextWrapper.

def flashCharacter(self, i, bg='white', fg='red', flashes=3, delay=75): pass

def getXScrollPosition(self): return 0

def getYScrollPosition(self): return 0

def see(self, i): pass

def seeInsertPoint(self): pass

def setFocus(self): pass

def setXScrollPosition(self, i): pass

def setYScrollPosition(self, i): pass

def tag_configure(self, colorName, **keys): pass
.. @+node:ekr.20170624151245.3882: *7* stw.Text
.. @+node:ekr.20170624151245.3899: *8* stw.appendText
def appendText(self, s):
    '''StringTextWrapper.'''
    self.s = self.s + s
    self.ins = len(self.s)
    self.sel = self.ins, self.ins
.. @+node:ekr.20170624151245.3900: *8* stw.delete
def delete(self, i, j=None):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i > j: i, j = j, i
    s = self.getAllText()
    self.setAllText(s[: i] + s[j:])
    # Bug fix: 2011/11/13: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)
.. @+node:ekr.20170624151245.3901: *8* stw.deleteTextSelection
def deleteTextSelection(self):
    '''StringTextWrapper.'''
    i, j = self.getSelectionRange()
    self.delete(i, j)
.. @+node:ekr.20170624151245.3902: *8* stw.get
def get(self, i, j=None):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    s = self.s[i: j]
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3903: *8* stw.getAllText
def getAllText(self):
    '''StringTextWrapper.'''
    s = self.s
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3904: *8* stw.getInsertPoint
def getInsertPoint(self):
    '''StringTextWrapper.'''
    i = self.ins
    if i is None:
        if self.virtualInsertPoint is None:
            i = 0
        else:
            i = self.virtualInsertPoint
    self.virtualInsertPoint = i
    # g.trace('BaseTextWrapper): i:',i,'virtual',self.virtualInsertPoint)
    return i
.. @+node:ekr.20170624151245.3905: *8* stw.getSelectedText
def getSelectedText(self):
    '''StringTextWrapper.'''
    i, j = self.sel
    s = self.s[i: j]
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3906: *8* stw.getSelectionRange
def getSelectionRange(self, sort=True):
    '''Return the selected range of the widget.'''
    sel = self.sel
    if len(sel) == 2 and sel[0] >= 0 and sel[1] >= 0:
        i, j = sel
        if sort and i > j: sel = j, i # Bug fix: 10/5/07
        return sel
    else:
        i = self.ins
        return i, i
.. @+node:ekr.20170624151245.3907: *8* stw.hasSelection
def hasSelection(self):
    '''StringTextWrapper.'''
    i, j = self.getSelectionRange()
    return i != j
.. @+node:ekr.20170624151245.3908: *8* stw.insert
def insert(self, i, s):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    s1 = s
    self.s = self.s[: i] + s1 + self.s[i:]
    i += len(s1)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3909: *8* stw.selectAllText
def selectAllText(self, insert=None):
    '''StringTextWrapper.'''
    self.setSelectionRange(0, 'end', insert=insert)
.. @+node:ekr.20170624151245.3910: *8* stw.setAllText
def setAllText(self, s):
    '''StringTextWrapper.'''
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3911: *8* stw.setInsertPoint
def setInsertPoint(self, pos, s=None):
    '''StringTextWrapper.'''
    self.virtualInsertPoint = i = self.toPythonIndex(pos)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3912: *8* stw.setSelectionRange
def setSelectionRange(self, i, j, insert=None):
    '''StringTextWrapper.'''
    i, j = self.toPythonIndex(i), self.toPythonIndex(j)
    self.sel = i, j
    self.ins = j if insert is None else self.toPythonIndex(insert)
    if self.trace: g.trace('i', i, 'j', j, 'insert', repr(insert))
.. @+node:ekr.20170624151245.3913: *8* stw.toPythonIndex
def toPythonIndex(self, index):
    '''StringTextWrapper.'''
    return g.toPythonIndex(self.s, index)
.. @+node:ekr.20170624151245.3914: *8* stw.toPythonIndexRowCol
def toPythonIndexRowCol(self, index):
    '''StringTextWrapper.'''
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = g.convertPythonIndexToRowCol(s, i)
    return i, row, col
.. @+node:ekr.20170624151245.3899: *8* stw.appendText
def appendText(self, s):
    '''StringTextWrapper.'''
    self.s = self.s + s
    self.ins = len(self.s)
    self.sel = self.ins, self.ins
.. @+node:ekr.20170624151245.3900: *8* stw.delete
def delete(self, i, j=None):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i > j: i, j = j, i
    s = self.getAllText()
    self.setAllText(s[: i] + s[j:])
    # Bug fix: 2011/11/13: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)
.. @+node:ekr.20170624151245.3901: *8* stw.deleteTextSelection
def deleteTextSelection(self):
    '''StringTextWrapper.'''
    i, j = self.getSelectionRange()
    self.delete(i, j)
.. @+node:ekr.20170624151245.3902: *8* stw.get
def get(self, i, j=None):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    s = self.s[i: j]
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3903: *8* stw.getAllText
def getAllText(self):
    '''StringTextWrapper.'''
    s = self.s
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3904: *8* stw.getInsertPoint
def getInsertPoint(self):
    '''StringTextWrapper.'''
    i = self.ins
    if i is None:
        if self.virtualInsertPoint is None:
            i = 0
        else:
            i = self.virtualInsertPoint
    self.virtualInsertPoint = i
    # g.trace('BaseTextWrapper): i:',i,'virtual',self.virtualInsertPoint)
    return i
.. @+node:ekr.20170624151245.3905: *8* stw.getSelectedText
def getSelectedText(self):
    '''StringTextWrapper.'''
    i, j = self.sel
    s = self.s[i: j]
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3906: *8* stw.getSelectionRange
def getSelectionRange(self, sort=True):
    '''Return the selected range of the widget.'''
    sel = self.sel
    if len(sel) == 2 and sel[0] >= 0 and sel[1] >= 0:
        i, j = sel
        if sort and i > j: sel = j, i # Bug fix: 10/5/07
        return sel
    else:
        i = self.ins
        return i, i
.. @+node:ekr.20170624151245.3907: *8* stw.hasSelection
def hasSelection(self):
    '''StringTextWrapper.'''
    i, j = self.getSelectionRange()
    return i != j
.. @+node:ekr.20170624151245.3908: *8* stw.insert
def insert(self, i, s):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    s1 = s
    self.s = self.s[: i] + s1 + self.s[i:]
    i += len(s1)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3909: *8* stw.selectAllText
def selectAllText(self, insert=None):
    '''StringTextWrapper.'''
    self.setSelectionRange(0, 'end', insert=insert)
.. @+node:ekr.20170624151245.3910: *8* stw.setAllText
def setAllText(self, s):
    '''StringTextWrapper.'''
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3911: *8* stw.setInsertPoint
def setInsertPoint(self, pos, s=None):
    '''StringTextWrapper.'''
    self.virtualInsertPoint = i = self.toPythonIndex(pos)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3912: *8* stw.setSelectionRange
def setSelectionRange(self, i, j, insert=None):
    '''StringTextWrapper.'''
    i, j = self.toPythonIndex(i), self.toPythonIndex(j)
    self.sel = i, j
    self.ins = j if insert is None else self.toPythonIndex(insert)
    if self.trace: g.trace('i', i, 'j', j, 'insert', repr(insert))
.. @+node:ekr.20170624151245.3913: *8* stw.toPythonIndex
def toPythonIndex(self, index):
    '''StringTextWrapper.'''
    return g.toPythonIndex(self.s, index)
.. @+node:ekr.20170624151245.3914: *8* stw.toPythonIndexRowCol
def toPythonIndexRowCol(self, index):
    '''StringTextWrapper.'''
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = g.convertPythonIndexToRowCol(s, i)
    return i, row, col
.. @+node:ekr.20170624151245.3879: *7* stw.ctor
def __init__(self, c, name):
    '''Ctor for the StringTextWrapper class.'''
    self.c = c
    self.name = name
    self.ins = 0
    self.sel = 0, 0
    self.s = ''
    self.supportsHighLevelInterface = True
    self.widget = None # This ivar must exist, and be None.
    self.trace = False

def __repr__(self):
    return '<StringTextWrapper: %s %s>' % (id(self), self.name)

def getName(self):
    '''StringTextWrapper.'''
    return self.name # Essential.
.. @+node:ekr.20170624151245.3880: *7* stw.Clipboard
def clipboard_clear(self):
    g.app.gui.replaceClipboardWith('')

def clipboard_append(self, s):
    s1 = g.app.gui.getTextFromClipboard()
    g.app.gui.replaceClipboardWith(s1 + s)
.. @+node:ekr.20170624151245.3881: *7* stw.Do-nothings
# For StringTextWrapper.

def flashCharacter(self, i, bg='white', fg='red', flashes=3, delay=75): pass

def getXScrollPosition(self): return 0

def getYScrollPosition(self): return 0

def see(self, i): pass

def seeInsertPoint(self): pass

def setFocus(self): pass

def setXScrollPosition(self, i): pass

def setYScrollPosition(self, i): pass

def tag_configure(self, colorName, **keys): pass
.. @+node:ekr.20170624151245.3882: *7* stw.Text
.. @+node:ekr.20170624151245.3899: *8* stw.appendText
def appendText(self, s):
    '''StringTextWrapper.'''
    self.s = self.s + s
    self.ins = len(self.s)
    self.sel = self.ins, self.ins
.. @+node:ekr.20170624151245.3900: *8* stw.delete
def delete(self, i, j=None):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i > j: i, j = j, i
    s = self.getAllText()
    self.setAllText(s[: i] + s[j:])
    # Bug fix: 2011/11/13: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)
.. @+node:ekr.20170624151245.3901: *8* stw.deleteTextSelection
def deleteTextSelection(self):
    '''StringTextWrapper.'''
    i, j = self.getSelectionRange()
    self.delete(i, j)
.. @+node:ekr.20170624151245.3902: *8* stw.get
def get(self, i, j=None):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    s = self.s[i: j]
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3903: *8* stw.getAllText
def getAllText(self):
    '''StringTextWrapper.'''
    s = self.s
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3904: *8* stw.getInsertPoint
def getInsertPoint(self):
    '''StringTextWrapper.'''
    i = self.ins
    if i is None:
        if self.virtualInsertPoint is None:
            i = 0
        else:
            i = self.virtualInsertPoint
    self.virtualInsertPoint = i
    # g.trace('BaseTextWrapper): i:',i,'virtual',self.virtualInsertPoint)
    return i
.. @+node:ekr.20170624151245.3905: *8* stw.getSelectedText
def getSelectedText(self):
    '''StringTextWrapper.'''
    i, j = self.sel
    s = self.s[i: j]
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3906: *8* stw.getSelectionRange
def getSelectionRange(self, sort=True):
    '''Return the selected range of the widget.'''
    sel = self.sel
    if len(sel) == 2 and sel[0] >= 0 and sel[1] >= 0:
        i, j = sel
        if sort and i > j: sel = j, i # Bug fix: 10/5/07
        return sel
    else:
        i = self.ins
        return i, i
.. @+node:ekr.20170624151245.3907: *8* stw.hasSelection
def hasSelection(self):
    '''StringTextWrapper.'''
    i, j = self.getSelectionRange()
    return i != j
.. @+node:ekr.20170624151245.3908: *8* stw.insert
def insert(self, i, s):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    s1 = s
    self.s = self.s[: i] + s1 + self.s[i:]
    i += len(s1)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3909: *8* stw.selectAllText
def selectAllText(self, insert=None):
    '''StringTextWrapper.'''
    self.setSelectionRange(0, 'end', insert=insert)
.. @+node:ekr.20170624151245.3910: *8* stw.setAllText
def setAllText(self, s):
    '''StringTextWrapper.'''
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3911: *8* stw.setInsertPoint
def setInsertPoint(self, pos, s=None):
    '''StringTextWrapper.'''
    self.virtualInsertPoint = i = self.toPythonIndex(pos)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3912: *8* stw.setSelectionRange
def setSelectionRange(self, i, j, insert=None):
    '''StringTextWrapper.'''
    i, j = self.toPythonIndex(i), self.toPythonIndex(j)
    self.sel = i, j
    self.ins = j if insert is None else self.toPythonIndex(insert)
    if self.trace: g.trace('i', i, 'j', j, 'insert', repr(insert))
.. @+node:ekr.20170624151245.3913: *8* stw.toPythonIndex
def toPythonIndex(self, index):
    '''StringTextWrapper.'''
    return g.toPythonIndex(self.s, index)
.. @+node:ekr.20170624151245.3914: *8* stw.toPythonIndexRowCol
def toPythonIndexRowCol(self, index):
    '''StringTextWrapper.'''
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = g.convertPythonIndexToRowCol(s, i)
    return i, row, col
.. @+node:ekr.20170624151245.3899: *8* stw.appendText
def appendText(self, s):
    '''StringTextWrapper.'''
    self.s = self.s + s
    self.ins = len(self.s)
    self.sel = self.ins, self.ins
.. @+node:ekr.20170624151245.3900: *8* stw.delete
def delete(self, i, j=None):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i > j: i, j = j, i
    s = self.getAllText()
    self.setAllText(s[: i] + s[j:])
    # Bug fix: 2011/11/13: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)
.. @+node:ekr.20170624151245.3901: *8* stw.deleteTextSelection
def deleteTextSelection(self):
    '''StringTextWrapper.'''
    i, j = self.getSelectionRange()
    self.delete(i, j)
.. @+node:ekr.20170624151245.3902: *8* stw.get
def get(self, i, j=None):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    s = self.s[i: j]
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3903: *8* stw.getAllText
def getAllText(self):
    '''StringTextWrapper.'''
    s = self.s
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3904: *8* stw.getInsertPoint
def getInsertPoint(self):
    '''StringTextWrapper.'''
    i = self.ins
    if i is None:
        if self.virtualInsertPoint is None:
            i = 0
        else:
            i = self.virtualInsertPoint
    self.virtualInsertPoint = i
    # g.trace('BaseTextWrapper): i:',i,'virtual',self.virtualInsertPoint)
    return i
.. @+node:ekr.20170624151245.3905: *8* stw.getSelectedText
def getSelectedText(self):
    '''StringTextWrapper.'''
    i, j = self.sel
    s = self.s[i: j]
    return g.toUnicode(s)
.. @+node:ekr.20170624151245.3906: *8* stw.getSelectionRange
def getSelectionRange(self, sort=True):
    '''Return the selected range of the widget.'''
    sel = self.sel
    if len(sel) == 2 and sel[0] >= 0 and sel[1] >= 0:
        i, j = sel
        if sort and i > j: sel = j, i # Bug fix: 10/5/07
        return sel
    else:
        i = self.ins
        return i, i
.. @+node:ekr.20170624151245.3907: *8* stw.hasSelection
def hasSelection(self):
    '''StringTextWrapper.'''
    i, j = self.getSelectionRange()
    return i != j
.. @+node:ekr.20170624151245.3908: *8* stw.insert
def insert(self, i, s):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    s1 = s
    self.s = self.s[: i] + s1 + self.s[i:]
    i += len(s1)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3909: *8* stw.selectAllText
def selectAllText(self, insert=None):
    '''StringTextWrapper.'''
    self.setSelectionRange(0, 'end', insert=insert)
.. @+node:ekr.20170624151245.3910: *8* stw.setAllText
def setAllText(self, s):
    '''StringTextWrapper.'''
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3911: *8* stw.setInsertPoint
def setInsertPoint(self, pos, s=None):
    '''StringTextWrapper.'''
    self.virtualInsertPoint = i = self.toPythonIndex(pos)
    self.ins = i
    self.sel = i, i
.. @+node:ekr.20170624151245.3912: *8* stw.setSelectionRange
def setSelectionRange(self, i, j, insert=None):
    '''StringTextWrapper.'''
    i, j = self.toPythonIndex(i), self.toPythonIndex(j)
    self.sel = i, j
    self.ins = j if insert is None else self.toPythonIndex(insert)
    if self.trace: g.trace('i', i, 'j', j, 'insert', repr(insert))
.. @+node:ekr.20170624151245.3913: *8* stw.toPythonIndex
def toPythonIndex(self, index):
    '''StringTextWrapper.'''
    return g.toPythonIndex(self.s, index)
.. @+node:ekr.20170624151245.3914: *8* stw.toPythonIndexRowCol
def toPythonIndexRowCol(self, index):
    '''StringTextWrapper.'''
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = g.convertPythonIndexToRowCol(s, i)
    return i, row, col
.. @+node:ekr.20170624151245.3915: *6* class UnitTestGui (NullGui)
class UnitTestGui(NullGui):
    '''A gui class for use by unit tests.'''
    # Presently used only by the import/export unit tests.
    @others
.. @+node:ekr.20170624151245.3920: *7* UnitTestGui.__init__
def __init__(self, theDict=None, trace=False):
    '''ctor for the UnitTestGui class.'''
    self.oldGui = g.app.gui
    NullGui.__init__(self, "UnitTestGui")
        # Init the base class
    self.theDict = {} if theDict is None else theDict
    self.trace = trace
    g.app.gui = self

def destroySelf(self):
    g.app.gui = self.oldGui
.. @+node:ekr.20170624151245.3921: *7* UnitTestGui.createSpellTab
def createSpellTab(self, c, spellHandler, tabName):
    pass # This method keeps pylint happy.
.. @+node:ekr.20170624151245.3922: *7* UnitTestGui.runAtIdle
if 1: # Huh?

    def runAtIdle(self, aFunc):
        '''Run aFunc immediately for a unit test.

        This is a kludge, but it is probably the best that can be done.
        '''
        aFunc()
.. @+node:ekr.20170624151245.3923: *7* UnitTestGui.toUnicode
def toUnicode(self, s):
    # pylint: disable=no-member
    if g.isPython3:
        return str(s)
    else:
        return builtins.unicode(s)
.. @+node:ekr.20170624151245.3920: *7* UnitTestGui.__init__
def __init__(self, theDict=None, trace=False):
    '''ctor for the UnitTestGui class.'''
    self.oldGui = g.app.gui
    NullGui.__init__(self, "UnitTestGui")
        # Init the base class
    self.theDict = {} if theDict is None else theDict
    self.trace = trace
    g.app.gui = self

def destroySelf(self):
    g.app.gui = self.oldGui
.. @+node:ekr.20170624151245.3921: *7* UnitTestGui.createSpellTab
def createSpellTab(self, c, spellHandler, tabName):
    pass # This method keeps pylint happy.
.. @+node:ekr.20170624151245.3922: *7* UnitTestGui.runAtIdle
if 1: # Huh?

    def runAtIdle(self, aFunc):
        '''Run aFunc immediately for a unit test.

        This is a kludge, but it is probably the best that can be done.
        '''
        aFunc()
.. @+node:ekr.20170624151245.3923: *7* UnitTestGui.toUnicode
def toUnicode(self, s):
    # pylint: disable=no-member
    if g.isPython3:
        return str(s)
    else:
        return builtins.unicode(s)
.. @+node:ekr.20170624151245.3924: *5* IH.handle_input
def handle_input(self, i):
    """
    Dispatch a handler in this class or parents.
    
    i is the character code. Leo handles codes from 1..351.
    
    Return True if input has been completely handled.
    """
    def tell(f):
        import re
        pattern = r'<bound method ([\w\.]*\.)?(\w+) of <([\w\.]*\.)?(\w+) object at (.+)>>'
        m = re.match(pattern, repr(f))
        if m:
            return '%s.%s' % (m.group(4), m.group(2))
        else:
            return repr(f)

    trace = False
    trace_entry = False
    trace_parent = False
    parent_widget = getattr(self, 'parent_widget', None)
    parent = getattr(self, 'parent', None)
    if trace and trace_entry:
        g.trace('self: %20s, parent: %8s, %3s = %r' % (
            self.__class__.__name__,
            parent.__class__.__name__,
            i, curses.ascii.unctrl(i),
        ))
    # A special case for F4 so we can run unit tests.
    # myLeoSettings.leo binds F4.
    if i == 268:
        g.app.gui.do_key(i)
        return True
    if i in self.handlers:
        f = self.handlers[i]
        if trace: g.trace('handler: %3s %s' % (i, tell(f)))
        f(i)
        return True
    try:
        _unctrl_input = curses.ascii.unctrl(i)
    except TypeError:
        _unctrl_input = None
    if _unctrl_input and (_unctrl_input in self.handlers):
        f = self.handlers[_unctrl_input]
        if trace: g.trace('handler: %3s %s' % (_unctrl_input, tell(f)))
        f(i)
        return True
    for test, handler in getattr(self, 'complex_handlers', []):
        if test(i): # was is not False.
            if trace: g.trace('complex: %3s %s' % (i, tell(handler)))
            return handler(i)
    if parent_widget and hasattr(parent_widget, 'handle_input'):
        if trace and trace_parent:
            g.trace('parent_widget.handle_input', i, parent_widget)
        if parent_widget.handle_input(i):
            return True
    if parent and hasattr(self.parent, 'handle_input'):
        if trace and trace_parent:
            g.trace('parent.handle_input', i, parent_widget)
        if parent.handle_input(i):
            return True
    # Handle Leo bindings *last*.
    # g.app is a LeoApp instance, *not* a CursesApp.
    if g.app and g.app.gui and hasattr(g.app.gui, 'do_key'):
        if trace: g.trace('    leo: %3s %s' % (i, tell(g.app.gui.do_key)))
        return g.app.gui.do_key(i)
    return False
.. @+node:ekr.20170624151245.3925: *5* Leo's core
.. @+node:ekr.20170624151245.4430: *6* c.save & helper
@cmd('save-file')
def save(self, event=None, fileName=None):
    '''Save a Leo outline to a file.'''
    if False and g.app.gui.guiName() == 'curses':
        g.trace('===== Save disabled in curses gui =====')
        return
    c = self; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody:
        p.saveCursorAndScroll()
    if g.unitTesting and g.app.unitTestDict.get('init_error_dialogs') is not None:
        # A kludge for unit testing:
        # indicated that c.init_error_dialogs and c.raise_error_dialogs
        # will be called below, *without* actually saving the .leo file.
        c.init_error_dialogs()
        c.raise_error_dialogs(kind='write')
        return
    if g.app.disableSave:
        g.es("save commands disabled", color="purple")
        return
    c.init_error_dialogs()
    # 2013/09/28: use the fileName keyword argument if given.
    # This supports the leoBridge.
    # Make sure we never pass None to the ctor.
    if fileName:
        c.frame.title = g.computeWindowTitle(fileName)
        c.mFileName = fileName
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""
    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        g.app.syntax_error_files = []
        c.fileCommands.save(c.mFileName)
        c.syntaxErrorDialog()
    else:
        root = c.rootPosition()
        if not root.next() and root.isAtEditNode():
            # There is only a single @edit node in the outline.
            # A hack to allow "quick edit" of non-Leo files.
            # See https://bugs.launchpad.net/leo-editor/+bug/381527
            fileName = None
            # Write the @edit node if needed.
            if root.isDirty():
                c.atFileCommands.writeOneAtEditNode(root,
                    toString=False, force=True)
            c.setChanged(False)
        else:
            fileName = ''.join(c.k.givenArgs)
            if not fileName:
                fileName = g.app.gui.runSaveFileDialog(c,
                    initialfile=c.mFileName,
                    title="Save",
                    filetypes=[("Leo files", "*.leo")],
                    defaultextension=".leo")
        c.bringToFront()
        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.computeWindowTitle(c.mFileName)
            c.frame.setTitle(c.computeWindowTitle(c.mFileName))
                # 2013/08/04: use c.computeWindowTitle.
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            if g.app.qt_use_tabs and hasattr(c.frame, 'top'):
                c.frame.top.leo_master.setTabName(c, c.mFileName)
            c.fileCommands.save(c.mFileName)
            g.app.recentFilesManager.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)
    # Done in FileCommands.save.
    # c.redraw_after_icons_changed()
    c.raise_error_dialogs(kind='write')
    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocus()
        p.restoreCursorAndScroll()
    else:
        c.treeWantsFocus()
.. @+node:ekr.20170624151245.4431: *7* c.syntaxErrorDialog
def syntaxErrorDialog(self):
    '''Warn about syntax errors in files.'''
    c = self
    if g.app.syntax_error_files and c.config.getBool('syntax-error-popup', default=False):
        aList = sorted(set(g.app.syntax_error_files))
        g.app.syntax_error_files = []
        message = 'Python errors in:\n\n%s' % '\n'.join(aList)
        g.app.gui.runAskOkDialog(c,
            title='Python Errors',
            message=message,
            text="Ok")
.. @+node:ekr.20170624151245.4722: *6* c.putHelpFor
def putHelpFor(self, s, short_title=''):
    '''Helper for various help commands.'''
    c = self
    g.app.gui.put_help(c, s, short_title)
    # s = g.adjustTripleString(s.rstrip(), c.tab_width)
    # if s.startswith('<') and not s.startswith('<<'):
        # pass # how to do selective replace??
    # if g.app.gui.guiName() == 'curses':
        # g.app.gui.put_help(s, short_title)
        # return
    # pc = g.app.pluginsController
    # table = (
        # 'viewrendered3.py',
        # 'viewrendered2.py',
        # 'viewrendered.py',
    # )
    # for name in table:
        # if pc.isLoaded(name):
            # vr = pc.loadOnePlugin(name)
            # break
    # else:
        # vr = pc.loadOnePlugin('viewrendered.py')
    # if g.unitTesting:
        # assert vr # For unit testing.
    # if vr:
        # kw = {
            # 'c': c,
            # 'flags': 'rst',
            # 'kind': 'rst',
            # 'label': '',
            # 'msg': s,
            # 'name': 'Apropos',
            # 'short_title': short_title,
            # 'title': ''}
        # vr.show_scrolled_message(tag='Apropos', kw=kw)
        # c.bodyWantsFocus()
        # if g.unitTesting:
            # vr.close_rendering_pane(event={'c': c})
    # else:
        # g.es(s)
.. @+node:ekr.20170624151245.3929: *6* qt_gui.put_help
def put_help(self, c, s, short_title=''):
    '''Put the help command.'''
    s = g.adjustTripleString(s.rstrip(), c.tab_width)
    if s.startswith('<') and not s.startswith('<<'):
        pass # how to do selective replace??
    pc = g.app.pluginsController
    table = (
        'viewrendered3.py',
        'viewrendered2.py',
        'viewrendered.py',
    )
    for name in table:
        if pc.isLoaded(name):
            vr = pc.loadOnePlugin(name)
            break
    else:
        vr = pc.loadOnePlugin('viewrendered.py')
    if g.unitTesting:
        assert vr # For unit testing.
    if vr:
        kw = {
            'c': c,
            'flags': 'rst',
            'kind': 'rst',
            'label': '',
            'msg': s,
            'name': 'Apropos',
            'short_title': short_title,
            'title': ''}
        vr.show_scrolled_message(tag='Apropos', kw=kw)
        c.bodyWantsFocus()
        if g.unitTesting:
            vr.close_rendering_pane(event={'c': c})
    else:
        g.es(s)
.. @+node:ekr.20170624151245.4621: *6* c.redraw
def redraw(self, p=None, setFocus=False):
    '''Redraw the screen immediately.'''
    trace = False and not g.unitTesting
    c = self
    if not p:
        p = c.p or c.rootPosition()
    if not p:
        return
    c.expandAllAncestors(p)
    if p:
        # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1183855
        # This looks redundant, but it is probably the only safe fix.
        c.frame.tree.select(p)
    # 2012/03/10: tree.redraw will change the position if p is a hoisted @chapter node.
    p2 = c.frame.tree.redraw(p)
    # Be careful.  NullTree.redraw returns None.
    c.selectPosition(p2 or p)
    if trace:
        g.trace(p2 and p2.h)
        # g.trace('setFocus', setFocus, p2 and p2.h or p and p.h)
    if setFocus: c.treeFocusHelper()
# Compatibility with old scripts

force_redraw = redraw
redraw_now = redraw
.. @+node:ekr.20170624151245.3931: *6* qtree.full_redraw & helpers
def full_redraw(self, p=None, scroll=True, forceDraw=False):
    '''
    Redraw all visible nodes of the tree.
    Preserve the vertical scrolling unless scroll is True.
    '''
    trace = False and not g.app.unitTesting
    verbose = False
    if False and g.app.unitTesting:
        return ### Experimental
    c = self.c
    if g.app.disable_redraw:
        if trace: g.trace('*** disabled', g.callers())
        return
    if self.busy():
        return g.trace('*** full_redraw: busy!', g.callers())
    if not p:
        p = c.currentPosition()
    elif c.hoistStack and p.h.startswith('@chapter') and p.hasChildren():
        # Make sure the current position is visible.
        # Part of fix of bug 875323: Hoist an @chapter node leaves a non-visible node selected.
        p = p.firstChild()
        if trace: g.trace('selecting', p.h)
        c.frame.tree.select(p)
        c.setCurrentPosition(p)
    else:
        c.setCurrentPosition(p)
    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p)
    finally:
        self.redrawing = False
    self.setItemForCurrentPosition(scroll=scroll)
    c.requestRedrawFlag = False
    if trace:
        if verbose:
            theTime = g.timeSince(t1)
            g.trace('** %s: scroll %5s drew %3s nodes in %s' % (
                self.redrawCount, scroll, self.nodeDrawCount, theTime), g.callers())
        else:
            g.trace('**', self.redrawCount, g.callers())
    return p # Return the position, which may have changed.
# Compatibility

redraw = full_redraw
redraw_now = full_redraw
.. @+node:ekr.20170624151245.3942: *7* qtree.clear_visual_icons
def clear_visual_icons(self, tag, keywords):
    """clear_visual_icons - remove 'declutter' icons before save

    this method must return None to tell Leo to continue normal processing

    :param str tag: 'save1'
    :param dict keywords: Leo hook keywords
    """

    if not self.use_declutter:
        return None

    c = keywords['c']
    if c != self.c:
        return None

    if c.config.getBool('tree-declutter', default=False):
        com = c.editCommands
        for nd in c.all_unique_positions():
            icons = [i for i in com.getIconList(nd) if 'visualIcon' not in i]
            com.setIconList(nd, icons, False)

    self.declutter_update = True

    return None
.. @+node:ekr.20170624151245.3943: *7* qtree.declutter_node
def declutter_node(self, c, p, item):
    """declutter_node - change the appearance of a node

    :param commander c: commander containing node
    :param position p: position of node
    :param QWidgetItem item: tree node widget item
    """
    if self.declutter_patterns is None:
        self.declutter_patterns = []
        lines = c.config.getData("tree-declutter-patterns")
        while lines:
            line = lines.pop(0)
            cmd, arg = line.split(None, 1)
            if cmd == 'RULE':
                self.declutter_patterns.append((re.compile(arg), []))
                continue
            self.declutter_patterns[-1][1].append((cmd, arg))

    text = str(item.text(0)) if g.isPython3 else g.u(item.text(0))
    new_icons = []
    for pattern, cmds in self.declutter_patterns:
        if pattern.match(text):

            for cmd, arg in cmds:
                if cmd == 'REPLACE':
                    text = pattern.sub(arg, text)
                    item.setText(0, text)
                    continue
                arg = c.styleSheetManager.expand_css_constants(arg).split()[0]
                if cmd == 'ICON':
                    new_icons.append(arg)
                elif cmd == 'BG':
                    item.setBackground(0, QtGui.QBrush(QtGui.QColor(arg)))
                elif cmd == 'FG':
                    item.setForeground(0, QtGui.QBrush(QtGui.QColor(arg)))
                elif cmd == 'FONT':
                    item.setFont(0, QtGui.QFont(arg))
                elif cmd == 'ITALIC':
                    font = item.font(0)
                    font.setItalic(bool(int(arg)))
                    item.setFont(0, font)
                elif cmd == 'WEIGHT':
                    arg = getattr(QtGui.QFont, arg, 75)
                    font = item.font(0)
                    font.setWeight(arg)
                    item.setFont(0, font)
                elif cmd == 'PX':
                    font = item.font(0)
                    font.setPixelSize(int(arg))
                    item.setFont(0, font)
                elif cmd == 'PT':
                    font = item.font(0)
                    font.setPointSize(int(arg))
                    item.setFont(0, font)

    com = c.editCommands
    allIcons = com.getIconList(p)
    icons = [i for i in allIcons if 'visualIcon' not in i]
    if len(allIcons) != len(icons) or new_icons:
        for icon in new_icons:
            com.appendImageDictToList(
                icons, self.declutter_iconDir,
                g.app.gui.getImageImageFinder(icon), 2,
                on='vnode', visualIcon='1'
            )
        com.setIconList(p, icons, False)
.. @+node:ekr.20170624151245.3944: *7* qtree.drawChildren
def drawChildren(self, p, parent_item):
    '''Draw the children of p if they should be expanded.'''
    trace = False and not g.unitTesting
    # if trace: g.trace('children: %5s expanded: %5s %s childIndex: %s' % (
        # p.hasChildren(),p.isExpanded(),p.h,p._childIndex))
    if not p:
        return g.trace('can not happen: no p')
    if p.hasChildren():
        if p.isExpanded():
            if trace: g.trace('expanded', p, p._childIndex)
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child, parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child, parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
.. @+node:ekr.20170624151245.3945: *7* qtree.drawNode
def drawNode(self, p, parent_item):
    '''Draw the node p.'''
    trace = False
    c = self.c
    self.nodeDrawCount += 1
    # Allocate the item.
    item = self.createTreeItem(p, parent_item)
    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p, item)
    # Set the headline and maybe the icon.
    self.setItemText(item, p.h)

    if self.use_declutter:
        self.declutter_node(c, p, item)

    if p:
        self.drawItemIcon(p, item)
    if trace: g.trace(self.traceItem(item))

    return item
.. @+node:ekr.20170624151245.3946: *7* qtree.drawTopTree
def drawTopTree(self, p):
    '''Draw the tree rooted at p.'''
    trace = False and not g.unitTesting
    c = self.c
    hPos, vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        if trace: g.trace(p)
        while p:
            self.drawTree(p)
            p.moveToNext()
    # This method always retains previous scroll position.
    self.setHScroll(hPos)
    self.setVScroll(vPos)
    self.repaint()
.. @+node:ekr.20170624151245.3947: *7* qtree.drawTree
def drawTree(self, p, parent_item=None):
    if g.app.gui.isNullGui:
        return
    # Draw the (visible) parent node.
    item = self.drawNode(p, parent_item)
    # Draw all the visible children.
    self.drawChildren(p, parent_item=item)
.. @+node:ekr.20170624151245.3948: *7* qtree.initData
def initData(self):
    # g.trace('*****')
    self.item2positionDict = {}
    self.item2vnodeDict = {}
    self.position2itemDict = {}
    self.vnode2itemsDict = {}
    self.editWidgetsDict = {}
.. @+node:ekr.20170624151245.3949: *7* qtree.rememberItem
def rememberItem(self, p, item):
    trace = False and not g.unitTesting
    if trace: g.trace('id', id(item), p)
    v = p.v
    # Update position dicts.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy() # was item
    # Update item2vnodeDict.
    self.item2vnodeDict[itemHash] = v # was item
    # Update vnode2itemsDict.
    d = self.vnode2itemsDict
    aList = d.get(v, [])
    if item in aList:
        g.trace('*** ERROR *** item already in list: %s, %s' % (item, aList))
    else:
        aList.append(item)
    d[v] = aList
.. @+node:ekr.20170624151245.3950: *7* qtree.update_appearance
def update_appearance(self, tag, keywords):
    """clear_visual_icons - update appearance, but can't call
    self.full_redraw() now, so just set a flag to do it on idle.

    :param str tag: 'headkey2'
    :param dict keywords: Leo hook keywords
    """
    if not self.use_declutter:
        return None
    c = keywords['c']
    if c != self.c:
        return None
    self.declutter_update = True
    return None
.. @+node:ekr.20170624151245.3951: *7* qtree.update_appearance_idle
def update_appearance_idle(self, tag, keywords):
    """clear_visual_icons - update appearance now we're safely out of
    the redraw loop.

    :param str tag: 'idle'
    :param dict keywords: Leo hook keywords
    """
    if not self.use_declutter:
        return None
    c = keywords['c']
    if c != self.c:
        return None

    if isinstance(QtWidgets.QApplication.focusWidget(), QtWidgets.QLineEdit):
        # when search results are found in headlines headkey2 fires
        # (on the second search hit in a headline), and full_redraw()
        # below takes the headline out of edit mode, and Leo crashes,
        # probably because the find code didn't expect to leave edit
        # mode.  So don't update when a QLineEdit has focus
        return None

    if self.declutter_update:
        self.declutter_update = False
        self.full_redraw(scroll=False)
    return None
.. @+node:ekr.20170624151245.3942: *7* qtree.clear_visual_icons
def clear_visual_icons(self, tag, keywords):
    """clear_visual_icons - remove 'declutter' icons before save

    this method must return None to tell Leo to continue normal processing

    :param str tag: 'save1'
    :param dict keywords: Leo hook keywords
    """

    if not self.use_declutter:
        return None

    c = keywords['c']
    if c != self.c:
        return None

    if c.config.getBool('tree-declutter', default=False):
        com = c.editCommands
        for nd in c.all_unique_positions():
            icons = [i for i in com.getIconList(nd) if 'visualIcon' not in i]
            com.setIconList(nd, icons, False)

    self.declutter_update = True

    return None
.. @+node:ekr.20170624151245.3943: *7* qtree.declutter_node
def declutter_node(self, c, p, item):
    """declutter_node - change the appearance of a node

    :param commander c: commander containing node
    :param position p: position of node
    :param QWidgetItem item: tree node widget item
    """
    if self.declutter_patterns is None:
        self.declutter_patterns = []
        lines = c.config.getData("tree-declutter-patterns")
        while lines:
            line = lines.pop(0)
            cmd, arg = line.split(None, 1)
            if cmd == 'RULE':
                self.declutter_patterns.append((re.compile(arg), []))
                continue
            self.declutter_patterns[-1][1].append((cmd, arg))

    text = str(item.text(0)) if g.isPython3 else g.u(item.text(0))
    new_icons = []
    for pattern, cmds in self.declutter_patterns:
        if pattern.match(text):

            for cmd, arg in cmds:
                if cmd == 'REPLACE':
                    text = pattern.sub(arg, text)
                    item.setText(0, text)
                    continue
                arg = c.styleSheetManager.expand_css_constants(arg).split()[0]
                if cmd == 'ICON':
                    new_icons.append(arg)
                elif cmd == 'BG':
                    item.setBackground(0, QtGui.QBrush(QtGui.QColor(arg)))
                elif cmd == 'FG':
                    item.setForeground(0, QtGui.QBrush(QtGui.QColor(arg)))
                elif cmd == 'FONT':
                    item.setFont(0, QtGui.QFont(arg))
                elif cmd == 'ITALIC':
                    font = item.font(0)
                    font.setItalic(bool(int(arg)))
                    item.setFont(0, font)
                elif cmd == 'WEIGHT':
                    arg = getattr(QtGui.QFont, arg, 75)
                    font = item.font(0)
                    font.setWeight(arg)
                    item.setFont(0, font)
                elif cmd == 'PX':
                    font = item.font(0)
                    font.setPixelSize(int(arg))
                    item.setFont(0, font)
                elif cmd == 'PT':
                    font = item.font(0)
                    font.setPointSize(int(arg))
                    item.setFont(0, font)

    com = c.editCommands
    allIcons = com.getIconList(p)
    icons = [i for i in allIcons if 'visualIcon' not in i]
    if len(allIcons) != len(icons) or new_icons:
        for icon in new_icons:
            com.appendImageDictToList(
                icons, self.declutter_iconDir,
                g.app.gui.getImageImageFinder(icon), 2,
                on='vnode', visualIcon='1'
            )
        com.setIconList(p, icons, False)
.. @+node:ekr.20170624151245.3944: *7* qtree.drawChildren
def drawChildren(self, p, parent_item):
    '''Draw the children of p if they should be expanded.'''
    trace = False and not g.unitTesting
    # if trace: g.trace('children: %5s expanded: %5s %s childIndex: %s' % (
        # p.hasChildren(),p.isExpanded(),p.h,p._childIndex))
    if not p:
        return g.trace('can not happen: no p')
    if p.hasChildren():
        if p.isExpanded():
            if trace: g.trace('expanded', p, p._childIndex)
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child, parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child, parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
.. @+node:ekr.20170624151245.3945: *7* qtree.drawNode
def drawNode(self, p, parent_item):
    '''Draw the node p.'''
    trace = False
    c = self.c
    self.nodeDrawCount += 1
    # Allocate the item.
    item = self.createTreeItem(p, parent_item)
    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p, item)
    # Set the headline and maybe the icon.
    self.setItemText(item, p.h)

    if self.use_declutter:
        self.declutter_node(c, p, item)

    if p:
        self.drawItemIcon(p, item)
    if trace: g.trace(self.traceItem(item))

    return item
.. @+node:ekr.20170624151245.3946: *7* qtree.drawTopTree
def drawTopTree(self, p):
    '''Draw the tree rooted at p.'''
    trace = False and not g.unitTesting
    c = self.c
    hPos, vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        if trace: g.trace(p)
        while p:
            self.drawTree(p)
            p.moveToNext()
    # This method always retains previous scroll position.
    self.setHScroll(hPos)
    self.setVScroll(vPos)
    self.repaint()
.. @+node:ekr.20170624151245.3947: *7* qtree.drawTree
def drawTree(self, p, parent_item=None):
    if g.app.gui.isNullGui:
        return
    # Draw the (visible) parent node.
    item = self.drawNode(p, parent_item)
    # Draw all the visible children.
    self.drawChildren(p, parent_item=item)
.. @+node:ekr.20170624151245.3948: *7* qtree.initData
def initData(self):
    # g.trace('*****')
    self.item2positionDict = {}
    self.item2vnodeDict = {}
    self.position2itemDict = {}
    self.vnode2itemsDict = {}
    self.editWidgetsDict = {}
.. @+node:ekr.20170624151245.3949: *7* qtree.rememberItem
def rememberItem(self, p, item):
    trace = False and not g.unitTesting
    if trace: g.trace('id', id(item), p)
    v = p.v
    # Update position dicts.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy() # was item
    # Update item2vnodeDict.
    self.item2vnodeDict[itemHash] = v # was item
    # Update vnode2itemsDict.
    d = self.vnode2itemsDict
    aList = d.get(v, [])
    if item in aList:
        g.trace('*** ERROR *** item already in list: %s, %s' % (item, aList))
    else:
        aList.append(item)
    d[v] = aList
.. @+node:ekr.20170624151245.3950: *7* qtree.update_appearance
def update_appearance(self, tag, keywords):
    """clear_visual_icons - update appearance, but can't call
    self.full_redraw() now, so just set a flag to do it on idle.

    :param str tag: 'headkey2'
    :param dict keywords: Leo hook keywords
    """
    if not self.use_declutter:
        return None
    c = keywords['c']
    if c != self.c:
        return None
    self.declutter_update = True
    return None
.. @+node:ekr.20170624151245.3951: *7* qtree.update_appearance_idle
def update_appearance_idle(self, tag, keywords):
    """clear_visual_icons - update appearance now we're safely out of
    the redraw loop.

    :param str tag: 'idle'
    :param dict keywords: Leo hook keywords
    """
    if not self.use_declutter:
        return None
    c = keywords['c']
    if c != self.c:
        return None

    if isinstance(QtWidgets.QApplication.focusWidget(), QtWidgets.QLineEdit):
        # when search results are found in headlines headkey2 fires
        # (on the second search hit in a headline), and full_redraw()
        # below takes the headline out of edit mode, and Leo crashes,
        # probably because the find code didn't expect to leave edit
        # mode.  So don't update when a QLineEdit has focus
        return None

    if self.declutter_update:
        self.declutter_update = False
        self.full_redraw(scroll=False)
    return None
.. @+node:ekr.20170624151245.4023: *5* TM.doTests & helpers (local tests)
def doTests(self, all=None, marked=None, verbosity=1):
    '''
    Run any kind of local unit test.

    Important: this is also called from dynamicUnitTest.leo
    to run external tests "locally" from dynamicUnitTest.leo
    '''
    trace = False
    c, tm = self.c, self
    # Clear the screen before running multiple unit tests locally.
    # if all or marked: g.cls()
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    # This seems a bit risky when run in unitTest.leo.
    if not c.fileName().endswith('unitTest.leo'):
        if c.isChanged():
            c.save() # Eliminate the need for ctrl-s.
    if trace: g.trace('marked', marked, 'c', c)
    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.runningAllUnitTests = all and not marked # Bug fix: 2012/12/20
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = c.p.copy()
        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        aList = tm.findAllUnitTestNodes(all, marked)
        setup_script = None
        found = False
        for p in aList:
            if tm.isTestSetupNode(p):
                setup_script = p.b
                test = None
            elif tm.isTestNode(p):
                if trace: g.trace('adding', p.h)
                test = tm.makeTestCase(p, setup_script)
            elif tm.isSuiteNode(p): # @suite
                if trace: g.trace('adding', p.h)
                test = tm.makeTestSuite(p, setup_script)
            elif tm.isTestClassNode(p):
                if trace: g.trace('adding', p.h)
                test = tm.makeTestClass(p) # A suite of tests.
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            if trace: g.trace('not found: running raw body')
            test = tm.makeTestCase(c.p, setup_script)
            if test:
                suite.addTest(test)
                found = True
        if found:
            if g.app.gui.guiName() == 'curses':
                logger, handler, stream = self.create_logging_stream()
                runner = unittest.TextTestRunner(
                    stream=stream,
                    failfast=g.app.failFast,
                    verbosity=verbosity,
                )
            else:
                stream = None
                runner = unittest.TextTestRunner(
                    # stream=stream, # Careful: doesn't work with Python 2.
                    failfast=g.app.failFast,
                    verbosity=verbosity,
                )
            result = runner.run(suite)
            if stream:
                if stream.aList:
                    logger.info('\n'+''.join(stream.aList))
                logger.removeHandler(handler)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace2) for(t, trace2) in result.errors]
                c.cacher.db[key] = archive
        else:
            g.error('no %s@test or @suite nodes in %s outline' % (
                'marked ' if marked else '',
                'entire' if all else 'selected'))
    finally:
        c.setChanged(changed) # Restore changed state.
        g.unitTesting = g.app.unitTesting = False
        if True: # g.app.unitTestDict.get('restoreSelectedNode', True):
            # This is more natural, and more useful.
            c.contractAllHeadlines()
            c.redraw(p1)
        else:
            c.recolor() # Needed when coloring is disabled in unit tests.
.. @+node:ekr.20170624151245.4031: *6* class LoggingLog
class LoggingStream:
    '''A class that can searve as a logging stream.'''

    def __init__(self, logger):
        self.aList = []
        self.logger = logger

    def write(self, s):
        '''Called from pr and also unittest.addSuccess/addFailure.'''
        if 0: # Write everything on a new line.
            if not s.isspace():
                self.logger.info(s.rstrip())
        else:
            s = s.strip()
            if len(s) == 1:
                self.aList.append(s)
            elif s:
                if self.aList:
                    self.logger.info(''.join(self.aList))
                    self.aList = []
                self.logger.info(s.rstrip())
    def flush(self):
        pass
.. @+node:ekr.20170624151245.4032: *6* create_logging_stream
def create_logging_stream(self):

    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

        # Don't use debug: it includes Qt debug messages.
    for handler in logger.handlers or []:
        if isinstance(handler, logging.handlers.SocketHandler):
            break
    else:
        handler = logging.handlers.SocketHandler(
            'localhost',
            logging.handlers.DEFAULT_TCP_LOGGING_PORT,
        )
        logger.addHandler(handler)
    stream = self.LoggingStream(logger)
    return logger, handler, stream
.. @+node:ekr.20170624151245.4033: *6* get_suite_script
def get_suite_script(self):
    s = '''

try:
    g.app.scriptDict['suite'] = suite
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4034: *6* get_test_class_script
def get_test_class_script(self):
    s = '''

try:
    g.app.scriptDict['testclass'] = testclass
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4035: *6* makeTestCase
def makeTestCase(self, p, setup_script):
    c = self.c
    p = p.copy()
    if p.b.strip():
        return GeneralTestCase(c, p, setup_script)
    else:
        return None
.. @+node:ekr.20170624151245.4036: *6* makeTestClass
def makeTestClass(self, p):
    """Create a subclass of unittest.TestCase"""
    c, tm = self.c, self
    fname = 'makeTestClass'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("nothing in %s" % p.h)
        return None
    try:
        script = script + tm.get_test_class_script()
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p, 'unittest': unittest}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        testclass = g.app.scriptDict.get('testclass')
        suite = g.app.scriptDict.get('suite')
        if suite and testclass:
            print("\n%s: both 'suite' and 'testclass defined in %s" % (
                fname, p.h))
        elif testclass:
            suite = unittest.TestLoader().loadTestsFromTestCase(testclass)
            return suite
        elif suite:
            return suite
        else:
            print("\n%s: neither 'suite' nor 'testclass' defined in %s" % (
                fname, p.h))
            return None
    except Exception:
        print('\n%s: exception creating test class in %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4037: *6* makeTestSuite
# This code executes the script in an @suite node.
# This code assumes that the script sets the 'suite' var to the test suite.

def makeTestSuite(self, p, setup_script):
    """Create a suite of test cases by executing the script in an @suite node."""
    c, tm = self.c, self
    fname = 'makeTestSuite'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("no script in %s" % p.h)
        return None
    if setup_script:
        script = setup_script + script
    try:
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\n%s: %s script did not set suite var" % (fname, p.h))
        return suite
    except Exception:
        print('\n%s: exception creating test cases for %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4031: *6* class LoggingLog
class LoggingStream:
    '''A class that can searve as a logging stream.'''

    def __init__(self, logger):
        self.aList = []
        self.logger = logger

    def write(self, s):
        '''Called from pr and also unittest.addSuccess/addFailure.'''
        if 0: # Write everything on a new line.
            if not s.isspace():
                self.logger.info(s.rstrip())
        else:
            s = s.strip()
            if len(s) == 1:
                self.aList.append(s)
            elif s:
                if self.aList:
                    self.logger.info(''.join(self.aList))
                    self.aList = []
                self.logger.info(s.rstrip())
    def flush(self):
        pass
.. @+node:ekr.20170624151245.4032: *6* create_logging_stream
def create_logging_stream(self):

    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

        # Don't use debug: it includes Qt debug messages.
    for handler in logger.handlers or []:
        if isinstance(handler, logging.handlers.SocketHandler):
            break
    else:
        handler = logging.handlers.SocketHandler(
            'localhost',
            logging.handlers.DEFAULT_TCP_LOGGING_PORT,
        )
        logger.addHandler(handler)
    stream = self.LoggingStream(logger)
    return logger, handler, stream
.. @+node:ekr.20170624151245.4033: *6* get_suite_script
def get_suite_script(self):
    s = '''

try:
    g.app.scriptDict['suite'] = suite
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4034: *6* get_test_class_script
def get_test_class_script(self):
    s = '''

try:
    g.app.scriptDict['testclass'] = testclass
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4035: *6* makeTestCase
def makeTestCase(self, p, setup_script):
    c = self.c
    p = p.copy()
    if p.b.strip():
        return GeneralTestCase(c, p, setup_script)
    else:
        return None
.. @+node:ekr.20170624151245.4036: *6* makeTestClass
def makeTestClass(self, p):
    """Create a subclass of unittest.TestCase"""
    c, tm = self.c, self
    fname = 'makeTestClass'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("nothing in %s" % p.h)
        return None
    try:
        script = script + tm.get_test_class_script()
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p, 'unittest': unittest}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        testclass = g.app.scriptDict.get('testclass')
        suite = g.app.scriptDict.get('suite')
        if suite and testclass:
            print("\n%s: both 'suite' and 'testclass defined in %s" % (
                fname, p.h))
        elif testclass:
            suite = unittest.TestLoader().loadTestsFromTestCase(testclass)
            return suite
        elif suite:
            return suite
        else:
            print("\n%s: neither 'suite' nor 'testclass' defined in %s" % (
                fname, p.h))
            return None
    except Exception:
        print('\n%s: exception creating test class in %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4037: *6* makeTestSuite
# This code executes the script in an @suite node.
# This code assumes that the script sets the 'suite' var to the test suite.

def makeTestSuite(self, p, setup_script):
    """Create a suite of test cases by executing the script in an @suite node."""
    c, tm = self.c, self
    fname = 'makeTestSuite'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("no script in %s" % p.h)
        return None
    if setup_script:
        script = setup_script + script
    try:
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\n%s: %s script did not set suite var" % (fname, p.h))
        return suite
    except Exception:
        print('\n%s: exception creating test cases for %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.3967: *5* Copies
.. @+node:ekr.20170624151245.3968: *6* Unused code
.. @+node:ekr.20170624151245.3969: *7* NullBody: Utils (no longer used)
.. @+node:ekr.20170624151245.3970: *8* NullBody.findStartOfLine
def findStartOfLine(self, lineNumber):
    lines = g.splitLines(self.s)
    i = 0; index = 0
    for line in lines:
        if i == lineNumber: break
        i += 1
        index += len(line)
    return index
.. @+node:ekr.20170624151245.3971: *8* NullBody.scanToStartOfLine
def scanToStartOfLine(self, i):
    if i <= 0:
        return 0
    assert(self.s[i] != '\n')
    while i >= 0:
        if self.s[i] == '\n':
            return i + 1
    return 0
.. @+node:ekr.20170624151245.3972: *8* NullBody.scanToEndOfLine
def scanToEndOfLine(self, i):
    if i >= len(self.s):
        return len(self.s)
    assert(self.s[i] != '\n')
    while i < len(self.s):
        if self.s[i] == '\n':
            return i - 1
    return i
.. @+node:ekr.20170624151245.3973: *6* COPY from TM.doTests

            if 1: ### Experimental: use the null gui for all unit tests.
                import leo.core.leoFrame as leoFrame
                old_gui = g.app.gui
                old_frame = c.frame
                old_k_w = c.k.w
                try:
                    g.app.gui = leoGui.NullGui(c=c)
                    c.frame = leoFrame.NullFrame(c, title='<title>', gui=g.app.gui)
                    c.k.w = None
                        # A huge switcheroo.
                    result = runner.run(suite)
                finally:
                    g.app.gui = old_gui
                    c.frame = old_frame
                    c.k.w = old_k_w
            else:
                g.trace(g.app.gui)
                result = runner.run(suite)
.. @+node:ekr.20170624151245.3974: *6* COPY g.os_path_join
def os_path_join(*args, **keys):
    '''
    The same as os.path.join, but safe for unicode.
    In addition, it supports the !! and . conventions.
    '''
    trace = False and not g.unitTesting
    c = keys.get('c')
    expanduser = keys.get('expanduser', True)
        # 2014/09/17: Allow expanduser to be False.
    uargs = [g.toUnicodeFileEncoding(arg) for arg in args]
    if trace: g.trace('1', uargs)
    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)
    if expanduser:
        uargs = [g.os_path_expanduser(z) for z in uargs if z]
    if trace: g.trace('2', uargs)
    try:
        path = os.path.join(*uargs)
    except TypeError:
        g.trace(uargs, args, keys, g.callers())
        raise
    if trace: g.trace('3', path)
    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00','') # Fix Pytyon 3 bug on Windows 10.
    return path
.. @+node:ekr.20170624151245.3975: *6* COPY class NullMiniBuffer (StringTextWrapper)
class NullMiniBuffer (StringTextWrapper): ### QMinibufferWrapper(QLineEditWrapper):

    def __init__(self, c):
        '''Ctor for NullMiniBuffer class.'''
        self.c = c
        StringTextWrapper.__init__(self, c=c, name='minibuffer')
        assert self.widget is None
        self.widget = g.NullObject()
        ### g.app.gui.setFilter(c, w, self, tag='minibuffer')

    def setStyleClass(self, style_class):
        pass
        ###
            # self.widget.setProperty('style_class', style_class)
            # self.widget.setStyleSheet(self.c.frame.top.styleSheet())
.. @+node:ekr.20170624151245.3976: *6* COPY reverted nodes
.. @+node:ekr.20170624151245.3977: *7* Resurrected Nodes
.. @+node:ekr.20170624151245.3978: *8* From @file leoGui.py
.. @+node:ekr.20170624151245.3979: *9* UnitTestGui.simulateDialog
def simulateDialog(self, key, defaultVal):
    val = self.theDict.get(key)
    return defaultVal if val is None else val

.. @+node:ekr.20170624151245.3980: *7* Recovered Nodes
.. @+node:ekr.20170624151245.3981: *8* Recovered node "class NullColorizer (BaseColorizer)" from @file leoFrame.py
(uncached) ekr.20031218072017.2218
Diff...
  class NullColorizer(leoColorizer.BaseColorizer):
      '''A colorizer class that doesn't color.'''
-     pass
+     recolorCount = 0
+         # A bit of a kludge.
+ 
.. @+node:ekr.20170624151245.3982: *9* old:class NullColorizer (BaseColorizer)
class NullColorizer(leoColorizer.BaseColorizer):
    '''A colorizer class that doesn't color.'''
    recolorCount = 0
        # A bit of a kludge.

.. @+node:ekr.20170624151245.3983: *9* new:class NullColorizer (BaseColorizer)
class NullColorizer(leoColorizer.BaseColorizer):
    '''A colorizer class that doesn't color.'''
    pass
.. @+node:ekr.20170624151245.3984: *8* Recovered node "NullFrame.ctor" from @file leoFrame.py
(uncached) ekr.20040327105706
Diff...
  def __init__(self, c, title, gui):
      '''
      Ctor for the NullFrame class.
      Creates Null body, log, menu, tree.
      '''
-     # g.trace('NullFrame')
+     # g.trace('NullFrame', repr(c))
?                          +++++++++
      LeoFrame.__init__(self, c, gui)
          # Init the base class.
-     assert self.c
+     assert self.c is not None
?                  ++++++++++++
+         # May be a NullObject.
      self.wrapper = None
      self.iconBar = NullIconBarClass(self.c, self)
      self.isNullFrame = True
      self.outerFrame = None
      self.ratio = self.secondary_ratio = 0.5
      self.statusLineClass = NullStatusLineClass
      self.title = title
-     self.top = None # Always None.
+     self.top = None
      # Create the component objects.
      self.body = NullBody(frame=self, parentFrame=None)
      self.log = NullLog(frame=self, parentFrame=None)
      self.menu = LeoMenu.NullMenu(frame=self)
+     ### self.miniBufferWidget = NullMiniBuffer(c)
      self.tree = NullTree(frame=self)
      # Default window position.
      self.w = 600
      self.h = 500
      self.x = 40
      self.y = 40
.. @+node:ekr.20170624151245.3985: *9* old:NullFrame.ctor
def __init__(self, c, title, gui):
    '''
    Ctor for the NullFrame class.
    Creates Null body, log, menu, tree.
    '''
    # g.trace('NullFrame', repr(c))
    LeoFrame.__init__(self, c, gui)
        # Init the base class.
    assert self.c is not None
        # May be a NullObject.
    self.wrapper = None
    self.iconBar = NullIconBarClass(self.c, self)
    self.isNullFrame = True
    self.outerFrame = None
    self.ratio = self.secondary_ratio = 0.5
    self.statusLineClass = NullStatusLineClass
    self.title = title
    self.top = None
    # Create the component objects.
    self.body = NullBody(frame=self, parentFrame=None)
    self.log = NullLog(frame=self, parentFrame=None)
    self.menu = LeoMenu.NullMenu(frame=self)
    ### self.miniBufferWidget = NullMiniBuffer(c)
    self.tree = NullTree(frame=self)
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
.. @+node:ekr.20170624151245.3986: *9* new:NullFrame.ctor
def __init__(self, c, title, gui):
    '''
    Ctor for the NullFrame class.
    Creates Null body, log, menu, tree.
    '''
    # g.trace('NullFrame')
    LeoFrame.__init__(self, c, gui)
        # Init the base class.
    assert self.c
    self.wrapper = None
    self.iconBar = NullIconBarClass(self.c, self)
    self.isNullFrame = True
    self.outerFrame = None
    self.ratio = self.secondary_ratio = 0.5
    self.statusLineClass = NullStatusLineClass
    self.title = title
    self.top = None # Always None.
    # Create the component objects.
    self.body = NullBody(frame=self, parentFrame=None)
    self.log = NullLog(frame=self, parentFrame=None)
    self.menu = LeoMenu.NullMenu(frame=self)
    self.tree = NullTree(frame=self)
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
.. @+node:ekr.20170624151245.3987: *8* Recovered node "NullFrame.do nothings" from @file leoFrame.py
(uncached) ekr.20061109124552
Diff...
  def bringToFront(self): pass
  def cascade(self, event=None): pass
  def contractBodyPane(self, event=None): pass
  def contractLogPane(self, event=None): pass
  def contractOutlinePane(self, event=None): pass
  def contractPane(self, event=None): pass
  def deiconify(self): pass
  def destroySelf(self): pass
  def equalSizedPanes(self, event=None): pass
  def expandBodyPane(self, event=None): pass
  def expandLogPane(self, event=None): pass
  def expandOutlinePane(self, event=None): pass
  def expandPane(self, event=None): pass
  def finishCreate(self): pass
+ def finishCreateLogPane(self): pass
  def fullyExpandBodyPane(self, event=None): pass
  def fullyExpandLogPane(self, event=None): pass
  def fullyExpandOutlinePane(self, event=None): pass
  def fullyExpandPane(self, event=None): pass
  def get_window_info(self): return 600, 500, 20, 20
  def hideBodyPane(self, event=None): pass
  def hideLogPane(self, event=None): pass
  def hideLogWindow(self, event=None): pass
  def hideOutlinePane(self, event=None): pass
  def hidePane(self, event=None): pass
  def leoHelp(self, event=None): pass
  def lift(self): pass
  def minimizeAll(self, event=None): pass
  def oops(self): g.trace("NullFrame", g.callers(4))
  def resizePanesToRatio(self, ratio, secondary_ratio): pass
  def resizeToScreen(self, event=None): pass
  def setInitialWindowGeometry(self): pass
  def setTopGeometry(self, w, h, x, y, adjustSize=True): return 0, 0, 0, 0
  def setWrap(self, flag, force=False): pass
  def toggleActivePane(self, event=None): pass
  def toggleSplitDirection(self, event=None): pass
  def update(self): pass
.. @+node:ekr.20170624151245.3988: *9* old:NullFrame.do nothings
def bringToFront(self): pass
def cascade(self, event=None): pass
def contractBodyPane(self, event=None): pass
def contractLogPane(self, event=None): pass
def contractOutlinePane(self, event=None): pass
def contractPane(self, event=None): pass
def deiconify(self): pass
def destroySelf(self): pass
def equalSizedPanes(self, event=None): pass
def expandBodyPane(self, event=None): pass
def expandLogPane(self, event=None): pass
def expandOutlinePane(self, event=None): pass
def expandPane(self, event=None): pass
def finishCreate(self): pass
def finishCreateLogPane(self): pass
def fullyExpandBodyPane(self, event=None): pass
def fullyExpandLogPane(self, event=None): pass
def fullyExpandOutlinePane(self, event=None): pass
def fullyExpandPane(self, event=None): pass
def get_window_info(self): return 600, 500, 20, 20
def hideBodyPane(self, event=None): pass
def hideLogPane(self, event=None): pass
def hideLogWindow(self, event=None): pass
def hideOutlinePane(self, event=None): pass
def hidePane(self, event=None): pass
def leoHelp(self, event=None): pass
def lift(self): pass
def minimizeAll(self, event=None): pass
def oops(self): g.trace("NullFrame", g.callers(4))
def resizePanesToRatio(self, ratio, secondary_ratio): pass
def resizeToScreen(self, event=None): pass
def setInitialWindowGeometry(self): pass
def setTopGeometry(self, w, h, x, y, adjustSize=True): return 0, 0, 0, 0
def setWrap(self, flag, force=False): pass
def toggleActivePane(self, event=None): pass
def toggleSplitDirection(self, event=None): pass
def update(self): pass
.. @+node:ekr.20170624151245.3989: *9* new:NullFrame.do nothings
def bringToFront(self): pass
def cascade(self, event=None): pass
def contractBodyPane(self, event=None): pass
def contractLogPane(self, event=None): pass
def contractOutlinePane(self, event=None): pass
def contractPane(self, event=None): pass
def deiconify(self): pass
def destroySelf(self): pass
def equalSizedPanes(self, event=None): pass
def expandBodyPane(self, event=None): pass
def expandLogPane(self, event=None): pass
def expandOutlinePane(self, event=None): pass
def expandPane(self, event=None): pass
def finishCreate(self): pass
def fullyExpandBodyPane(self, event=None): pass
def fullyExpandLogPane(self, event=None): pass
def fullyExpandOutlinePane(self, event=None): pass
def fullyExpandPane(self, event=None): pass
def get_window_info(self): return 600, 500, 20, 20
def hideBodyPane(self, event=None): pass
def hideLogPane(self, event=None): pass
def hideLogWindow(self, event=None): pass
def hideOutlinePane(self, event=None): pass
def hidePane(self, event=None): pass
def leoHelp(self, event=None): pass
def lift(self): pass
def minimizeAll(self, event=None): pass
def oops(self): g.trace("NullFrame", g.callers(4))
def resizePanesToRatio(self, ratio, secondary_ratio): pass
def resizeToScreen(self, event=None): pass
def setInitialWindowGeometry(self): pass
def setTopGeometry(self, w, h, x, y, adjustSize=True): return 0, 0, 0, 0
def setWrap(self, flag, force=False): pass
def toggleActivePane(self, event=None): pass
def toggleSplitDirection(self, event=None): pass
def update(self): pass
.. @+node:ekr.20170624151245.3990: *8* Recovered node "NullLog.__init__" from @file leoFrame.py
(uncached) ekr.20041012083237
Diff...
  def __init__(self, frame=None, parentFrame=None):
      # Init the base class.
      LeoLog.__init__(self, frame, parentFrame)
+     self.contentsDict = {}
+         # Used by unit tests.
      self.isNull = True
      self.logNumber = 0
      self.widget = self.createControl(parentFrame)
          # self.logCtrl is now a property of the base LeoLog class.
.. @+node:ekr.20170624151245.3991: *9* old:NullLog.__init__
def __init__(self, frame=None, parentFrame=None):
    # Init the base class.
    LeoLog.__init__(self, frame, parentFrame)
    self.contentsDict = {}
        # Used by unit tests.
    self.isNull = True
    self.logNumber = 0
    self.widget = self.createControl(parentFrame)
        # self.logCtrl is now a property of the base LeoLog class.
.. @+node:ekr.20170624151245.3992: *9* new:NullLog.__init__
def __init__(self, frame=None, parentFrame=None):
    # Init the base class.
    LeoLog.__init__(self, frame, parentFrame)
    self.isNull = True
    self.logNumber = 0
    self.widget = self.createControl(parentFrame)
        # self.logCtrl is now a property of the base LeoLog class.
.. @+node:ekr.20170624151245.3993: *8* Recovered node " NullTree.__init__" from @file leoFrame.py
(uncached) ekr.20031218072017.2234
Diff...
  def __init__(self, frame):
      '''Ctor for NullTree class.'''
      LeoTree.__init__(self, frame) # Init the base class.
      assert(self.frame)
      self.c = frame.c
      self.editWidgetsDict = {}
          ### To be deleted?
          # Keys are tnodes, values are StringTextWidgets.
      self.canvas = None
      self.redrawCount = 0
+     self.treeWidget = None
+         # Used by unit tests.
.. @+node:ekr.20170624151245.3994: *9* old: NullTree.__init__
def __init__(self, frame):
    '''Ctor for NullTree class.'''
    LeoTree.__init__(self, frame) # Init the base class.
    assert(self.frame)
    self.c = frame.c
    self.editWidgetsDict = {}
        ### To be deleted?
        # Keys are tnodes, values are StringTextWidgets.
    self.canvas = None
    self.redrawCount = 0
    self.treeWidget = None
        # Used by unit tests.
.. @+node:ekr.20170624151245.3995: *9* new: NullTree.__init__
def __init__(self, frame):
    '''Ctor for NullTree class.'''
    LeoTree.__init__(self, frame) # Init the base class.
    assert(self.frame)
    self.c = frame.c
    self.editWidgetsDict = {}
        ### To be deleted?
        # Keys are tnodes, values are StringTextWidgets.
    self.canvas = None
    self.redrawCount = 0
.. @+node:ekr.20170624151245.3996: *5* Failures (do not delete)
@killcolor

----------------------------------------------------------------------
Ran 902 tests in 23.487s

FAILED (failures=25, errors=14, skipped=14)
.. @+node:ekr.20170624151245.3997: *6* was_control_drag

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test illegal drag gives warning

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 15, in <module>
    for w.was_control_drag in (True,False):
AttributeError: 'NoneType' object has no attribute 'was_control_drag'

.. @+node:ekr.20170624151245.3998: *6* 'NoneType' object has no attribute 'h'

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test can't open message in g.openWithFileName

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 18, in <module>
    c2 = g.openWithFileName(filename,old_c=old_c)
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 3244, in openWithFileName
    return g.app.loadManager.loadLocalFile(fileName, gui, old_c)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2887, in loadLocalFile
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2931, in openFileByName
    lm.initWrapperLeoFile(c, fn)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 3008, in initWrapperLeoFile
    p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
AttributeError: 'NoneType' object has no attribute 'h'

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test open non-existent non-ascii directory

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 18, in <module>
    c2 = g.openWithFileName(path,old_c=c)
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 3244, in openWithFileName
    return g.app.loadManager.loadLocalFile(fileName, gui, old_c)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2887, in loadLocalFile
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2931, in openFileByName
    lm.initWrapperLeoFile(c, fn)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 3008, in initWrapperLeoFile
    p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
AttributeError: 'NoneType' object has no attribute 'h'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 20, in <module>
    if c2:
NameError: name 'c2' is not defined
.. @+node:ekr.20170624151245.3999: *6* 'NoneType' object has no attribute 'leo_colorizer'

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test bc.scanLanguageDirectives

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 9, in <module>
    x = leoColorizer.JEditColorizer(c, widget, wrapper)
  File "c:\leo.repo\leo-editor\leo\core\leoColorizer.py", line 181, in __init__
    widget.leo_colorizer = self
AttributeError: 'NoneType' object has no attribute 'leo_colorizer'

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test bc.useSyntaxColoring

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 9, in <module>
    x = leoColorizer.JEditColorizer(c, widget, wrapper)
  File "c:\leo.repo\leo-editor\leo\core\leoColorizer.py", line 181, in __init__
    widget.leo_colorizer = self
AttributeError: 'NoneType' object has no attribute 'leo_colorizer'
.. @+node:ekr.20170624151245.4000: *6* join() missing 1 required positional argument: 'path'
======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test rst3Test unicode characters

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 10, in <module>
    rst3Test(c,p)
  File "<string>", line 14, in __init__
  File "<string>", line 52, in run
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 556, in processTree
    self.write_rst_tree(p, ext, fn, toString=toString, justOneFile=justOneFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 601, in write_rst_tree
    writeIntermediateFile=writeIntermediateFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1532, in write_files
    self.stringOutput = s = self.writeToDocutils(p, self.source, ext)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1640, in writeToDocutils
    openDirectory, rel_stylesheet_path)
  File "leoGlobals.py", line 6082, in os_path_finalize_join
    g.os_path_join(*args, **keys))) # Handles expanduser
  File "leoGlobals.py", line 6134, in os_path_join
    path = os.path.join(*uargs)
TypeError: join() missing 1 required positional argument: 'path'


======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test rst3Test show_leo_directives=False

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 7, in <module>
    rst3Test(c,p)
  File "<string>", line 14, in __init__
  File "<string>", line 52, in run
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 556, in processTree
    self.write_rst_tree(p, ext, fn, toString=toString, justOneFile=justOneFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 601, in write_rst_tree
    writeIntermediateFile=writeIntermediateFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1532, in write_files
    self.stringOutput = s = self.writeToDocutils(p, self.source, ext)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1640, in writeToDocutils
    openDirectory, rel_stylesheet_path)
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 6082, in os_path_finalize_join
    g.os_path_join(*args, **keys))) # Handles expanduser
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 6134, in os_path_join
    path = os.path.join(*uargs)
TypeError: join() missing 1 required positional argument: 'path'

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test rst3Test doc_only_mode (set in headline)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 7, in <module>
    rst3Test(c,p)
  File "<string>", line 14, in __init__
  File "<string>", line 52, in run
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 556, in processTree
    self.write_rst_tree(p, ext, fn, toString=toString, justOneFile=justOneFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 601, in write_rst_tree
    writeIntermediateFile=writeIntermediateFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1532, in write_files
    self.stringOutput = s = self.writeToDocutils(p, self.source, ext)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1640, in writeToDocutils
    openDirectory, rel_stylesheet_path)
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 6082, in os_path_finalize_join
    g.os_path_join(*args, **keys))) # Handles expanduser
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 6134, in os_path_join
    path = os.path.join(*uargs)
TypeError: join() missing 1 required positional argument: 'path'

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test rst3Test doc_only_mode (set in options doc part)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 7, in <module>
    rst3Test(c,p)
  File "<string>", line 14, in __init__
  File "<string>", line 52, in run
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 556, in processTree
    self.write_rst_tree(p, ext, fn, toString=toString, justOneFile=justOneFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 601, in write_rst_tree
    writeIntermediateFile=writeIntermediateFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1532, in write_files
    self.stringOutput = s = self.writeToDocutils(p, self.source, ext)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1640, in writeToDocutils
    openDirectory, rel_stylesheet_path)
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 6082, in os_path_finalize_join
    g.os_path_join(*args, **keys))) # Handles expanduser
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 6134, in os_path_join
    path = os.path.join(*uargs)
TypeError: join() missing 1 required positional argument: 'path'

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test rst3Test @no-head

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 6, in <module>
    rst3Test(c,p)
  File "<string>", line 14, in __init__
  File "<string>", line 52, in run
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 556, in processTree
    self.write_rst_tree(p, ext, fn, toString=toString, justOneFile=justOneFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 601, in write_rst_tree
    writeIntermediateFile=writeIntermediateFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1532, in write_files
    self.stringOutput = s = self.writeToDocutils(p, self.source, ext)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1640, in writeToDocutils
    openDirectory, rel_stylesheet_path)
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 6082, in os_path_finalize_join
    g.os_path_join(*args, **keys))) # Handles expanduser
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 6134, in os_path_join
    path = os.path.join(*uargs)
TypeError: join() missing 1 required positional argument: 'path'

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test rst3Test default

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 6, in <module>
    rst3Test(c,p)
  File "<string>", line 14, in __init__
  File "<string>", line 52, in run
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 556, in processTree
    self.write_rst_tree(p, ext, fn, toString=toString, justOneFile=justOneFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 601, in write_rst_tree
    writeIntermediateFile=writeIntermediateFile)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1532, in write_files
    self.stringOutput = s = self.writeToDocutils(p, self.source, ext)
  File "c:\leo.repo\leo-editor\leo\core\leoRst.py", line 1640, in writeToDocutils
    openDirectory, rel_stylesheet_path)
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 6082, in os_path_finalize_join
    g.os_path_join(*args, **keys))) # Handles expanduser
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 6134, in os_path_join
    path = os.path.join(*uargs)
TypeError: join() missing 1 required positional argument: 'path'
.. @+node:ekr.20170624151245.4001: *6* 'tuple' object has no attribute 'split'

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test insert node

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 35, in <module>
    c.undoer.redo()
  File "c:\leo.repo\leo-editor\leo\core\leoUndo.py", line 1211, in redo
    u.redoHelper()
  File "c:\leo.repo\leo-editor\leo\core\leoUndo.py", line 1408, in redoNodeContents
    w.setSelectionRange(i, j)
  File "c:\leo.repo\leo-editor\leo\core\leoFrame.py", line 200, in setSelectionRange
    i, j = self.toPythonIndex(i), self.toPythonIndex(j)
  File "c:\leo.repo\leo-editor\leo\core\leoFrame.py", line 207, in toPythonIndex
    return g.toPythonIndex(self.s, index)
  File "c:\leo.repo\leo-editor\leo\core\leoGlobals.py", line 4652, in toPythonIndex
    data = index.split('.')
AttributeError: 'tuple' object has no attribute 'split'
.. @+node:ekr.20170624151245.4002: *6* Batch mode
======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test batch mode

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 38, in <module>
    assert(g.os_path_exists(test_file))
AssertionError
.. @+node:ekr.20170624151245.4003: *6* Real failures

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test expand/contract-pane

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 12, in <module>
    assert not isinstance(c.frame,leoFrame.NullFrame)
AssertionError

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test cycle-all-focus

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 24, in <module>
    assert len(seen) >2, "expected >2, got %s" % len(seen)
AssertionError: expected >2, got 1

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test cycle-tab-focus

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 18, in <module>
    assert log.tabName == tab,'expected %s, got %s' % (tab,log.tabName)
AssertionError: expected Log, got None

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test move-marked-nodes

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 30, in <module>
    test(p)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 14, in test
    assert c.p.h == 'Moved marked nodes'
AssertionError

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test paste from menu to body recolors the body

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 20, in <module>
    assert c.frame.body.colorizer.recolorCount > n
AssertionError

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test c.frame.minimize-all

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 14, in <module>
    assert d.get(tag) is True
AssertionError

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test c.frame.resize-to-screen

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 15, in <module>
    assert d.get(tag) is True
AssertionError

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test move-outline-right

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 17, in <module>
    assert moved.h == 'B', 'fail 1'
AssertionError: fail 1

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test move-outline-up

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 19, in <module>
    assert moved.h == 'C',          'fail 1'
AssertionError: fail 1

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test paste-node

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 19, in <module>
    assert c.p.h == 'child','fail 1'
AssertionError: fail 1

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test paste-retaining-clones

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 21, in <module>
    assert v in oldVnodes, 'fail 3'
AssertionError: fail 3

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test promote

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 22, in <module>
    assert p == p3,         'fail 1'
AssertionError: fail 1

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test pd.find_representative_node

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 24, in <module>
    assert rep == clone,(repr(rep),repr(clone))
AssertionError: ('<pos 187351664 childIndex: 0 lvl: 6 key: 147307728:13.147307792:0.174725616:6.155876112:20.155877200:6.155877168:0.155877264:0 clone>', '<pos 187353136 childIndex: 1 lvl: 5 key: 147307728:4.147307792:0.174725616:6.155876112:20.155877200:6.155877264:1 clone>')

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: addComments
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 105, in runTest
    self.editBody()
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: addComments: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: convertAllBlanks
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 105, in runTest
    self.editBody()
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: convertAllBlanks: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: convertAllTabs
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 105, in runTest
    self.editBody()
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: convertAllTabs: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: convertBlanks
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 105, in runTest
    self.editBody()
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: convertBlanks: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: convertTabs
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 105, in runTest
    self.editBody()
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: convertTabs: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: dedentBody
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 105, in runTest
    self.editBody()
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: dedentBody: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: deleteComments
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 105, in runTest
    self.editBody()
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: deleteComments: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: deleteComments
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 105, in runTest
    self.editBody()
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: deleteComments: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: extract test1
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 105, in runTest
    self.editBody()
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: extract: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: extractSection test1
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 105, in runTest
    self.editBody()
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: extractSection: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test c.vnode2position

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 8, in <module>
    assert p2
AssertionError
.. @+node:ekr.20170624151245.4004: *7* list.remove(x): x not in list

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test move-outline-down & undo/redo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 26, in <module>
    c.undoer.undo()
  File "c:\leo.repo\leo-editor\leo\core\leoUndo.py", line 1498, in undo
    u.undoHelper()
  File "c:\leo.repo\leo-editor\leo\core\leoUndo.py", line 1596, in undoDemote
    sib.parents.remove(u.p.v)
ValueError: list.remove(x): x not in list

======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test move-outline-left

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\leo.repo\leo-editor\leo\test\scriptFile.py", line 16, in <module>
    c.undoer.undo()
  File "c:\leo.repo\leo-editor\leo\core\leoUndo.py", line 1498, in undo
    u.undoHelper()
  File "c:\leo.repo\leo-editor\leo\core\leoUndo.py", line 1596, in undoDemote
    sib.parents.remove(u.p.v)
ValueError: list.remove(x): x not in list
.. @+node:ekr.20170624151245.4005: *5* recent string-gui changes
.. @+node:ekr.20170624151245.5268: *6* g.os_path_join
def os_path_join(*args, **keys):
    '''
    The same as os.path.join, but safe for unicode.
    In addition, it supports the !! and . conventions.
    '''
    trace = False and not g.unitTesting
    c = keys.get('c')
    expanduser = keys.get('expanduser', True)
        # 2014/09/17: Allow expanduser to be False.
    uargs = [g.toUnicodeFileEncoding(arg) for arg in args]
    if trace: g.trace('1', uargs)
    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)
    if expanduser:
        uargs = [g.os_path_expanduser(z) for z in uargs if z]
    if trace: g.trace('2', uargs)
    path = os.path.join(*uargs)
    if trace: g.trace('3', path)
    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00','') # Fix Pytyon 3 bug on Windows 10.
    return path
.. @+node:ekr.20170624151245.4023: *6* TM.doTests & helpers (local tests)
def doTests(self, all=None, marked=None, verbosity=1):
    '''
    Run any kind of local unit test.

    Important: this is also called from dynamicUnitTest.leo
    to run external tests "locally" from dynamicUnitTest.leo
    '''
    trace = False
    c, tm = self.c, self
    # Clear the screen before running multiple unit tests locally.
    # if all or marked: g.cls()
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    # This seems a bit risky when run in unitTest.leo.
    if not c.fileName().endswith('unitTest.leo'):
        if c.isChanged():
            c.save() # Eliminate the need for ctrl-s.
    if trace: g.trace('marked', marked, 'c', c)
    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.runningAllUnitTests = all and not marked # Bug fix: 2012/12/20
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = c.p.copy()
        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        aList = tm.findAllUnitTestNodes(all, marked)
        setup_script = None
        found = False
        for p in aList:
            if tm.isTestSetupNode(p):
                setup_script = p.b
                test = None
            elif tm.isTestNode(p):
                if trace: g.trace('adding', p.h)
                test = tm.makeTestCase(p, setup_script)
            elif tm.isSuiteNode(p): # @suite
                if trace: g.trace('adding', p.h)
                test = tm.makeTestSuite(p, setup_script)
            elif tm.isTestClassNode(p):
                if trace: g.trace('adding', p.h)
                test = tm.makeTestClass(p) # A suite of tests.
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            if trace: g.trace('not found: running raw body')
            test = tm.makeTestCase(c.p, setup_script)
            if test:
                suite.addTest(test)
                found = True
        if found:
            if g.app.gui.guiName() == 'curses':
                logger, handler, stream = self.create_logging_stream()
                runner = unittest.TextTestRunner(
                    stream=stream,
                    failfast=g.app.failFast,
                    verbosity=verbosity,
                )
            else:
                stream = None
                runner = unittest.TextTestRunner(
                    # stream=stream, # Careful: doesn't work with Python 2.
                    failfast=g.app.failFast,
                    verbosity=verbosity,
                )
            result = runner.run(suite)
            if stream:
                if stream.aList:
                    logger.info('\n'+''.join(stream.aList))
                logger.removeHandler(handler)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace2) for(t, trace2) in result.errors]
                c.cacher.db[key] = archive
        else:
            g.error('no %s@test or @suite nodes in %s outline' % (
                'marked ' if marked else '',
                'entire' if all else 'selected'))
    finally:
        c.setChanged(changed) # Restore changed state.
        g.unitTesting = g.app.unitTesting = False
        if True: # g.app.unitTestDict.get('restoreSelectedNode', True):
            # This is more natural, and more useful.
            c.contractAllHeadlines()
            c.redraw(p1)
        else:
            c.recolor() # Needed when coloring is disabled in unit tests.
.. @+node:ekr.20170624151245.4031: *7* class LoggingLog
class LoggingStream:
    '''A class that can searve as a logging stream.'''

    def __init__(self, logger):
        self.aList = []
        self.logger = logger

    def write(self, s):
        '''Called from pr and also unittest.addSuccess/addFailure.'''
        if 0: # Write everything on a new line.
            if not s.isspace():
                self.logger.info(s.rstrip())
        else:
            s = s.strip()
            if len(s) == 1:
                self.aList.append(s)
            elif s:
                if self.aList:
                    self.logger.info(''.join(self.aList))
                    self.aList = []
                self.logger.info(s.rstrip())
    def flush(self):
        pass
.. @+node:ekr.20170624151245.4032: *7* create_logging_stream
def create_logging_stream(self):

    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

        # Don't use debug: it includes Qt debug messages.
    for handler in logger.handlers or []:
        if isinstance(handler, logging.handlers.SocketHandler):
            break
    else:
        handler = logging.handlers.SocketHandler(
            'localhost',
            logging.handlers.DEFAULT_TCP_LOGGING_PORT,
        )
        logger.addHandler(handler)
    stream = self.LoggingStream(logger)
    return logger, handler, stream
.. @+node:ekr.20170624151245.4033: *7* get_suite_script
def get_suite_script(self):
    s = '''

try:
    g.app.scriptDict['suite'] = suite
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4034: *7* get_test_class_script
def get_test_class_script(self):
    s = '''

try:
    g.app.scriptDict['testclass'] = testclass
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4035: *7* makeTestCase
def makeTestCase(self, p, setup_script):
    c = self.c
    p = p.copy()
    if p.b.strip():
        return GeneralTestCase(c, p, setup_script)
    else:
        return None
.. @+node:ekr.20170624151245.4036: *7* makeTestClass
def makeTestClass(self, p):
    """Create a subclass of unittest.TestCase"""
    c, tm = self.c, self
    fname = 'makeTestClass'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("nothing in %s" % p.h)
        return None
    try:
        script = script + tm.get_test_class_script()
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p, 'unittest': unittest}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        testclass = g.app.scriptDict.get('testclass')
        suite = g.app.scriptDict.get('suite')
        if suite and testclass:
            print("\n%s: both 'suite' and 'testclass defined in %s" % (
                fname, p.h))
        elif testclass:
            suite = unittest.TestLoader().loadTestsFromTestCase(testclass)
            return suite
        elif suite:
            return suite
        else:
            print("\n%s: neither 'suite' nor 'testclass' defined in %s" % (
                fname, p.h))
            return None
    except Exception:
        print('\n%s: exception creating test class in %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4037: *7* makeTestSuite
# This code executes the script in an @suite node.
# This code assumes that the script sets the 'suite' var to the test suite.

def makeTestSuite(self, p, setup_script):
    """Create a suite of test cases by executing the script in an @suite node."""
    c, tm = self.c, self
    fname = 'makeTestSuite'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("no script in %s" % p.h)
        return None
    if setup_script:
        script = setup_script + script
    try:
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\n%s: %s script did not set suite var" % (fname, p.h))
        return suite
    except Exception:
        print('\n%s: exception creating test cases for %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4031: *7* class LoggingLog
class LoggingStream:
    '''A class that can searve as a logging stream.'''

    def __init__(self, logger):
        self.aList = []
        self.logger = logger

    def write(self, s):
        '''Called from pr and also unittest.addSuccess/addFailure.'''
        if 0: # Write everything on a new line.
            if not s.isspace():
                self.logger.info(s.rstrip())
        else:
            s = s.strip()
            if len(s) == 1:
                self.aList.append(s)
            elif s:
                if self.aList:
                    self.logger.info(''.join(self.aList))
                    self.aList = []
                self.logger.info(s.rstrip())
    def flush(self):
        pass
.. @+node:ekr.20170624151245.4032: *7* create_logging_stream
def create_logging_stream(self):

    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

        # Don't use debug: it includes Qt debug messages.
    for handler in logger.handlers or []:
        if isinstance(handler, logging.handlers.SocketHandler):
            break
    else:
        handler = logging.handlers.SocketHandler(
            'localhost',
            logging.handlers.DEFAULT_TCP_LOGGING_PORT,
        )
        logger.addHandler(handler)
    stream = self.LoggingStream(logger)
    return logger, handler, stream
.. @+node:ekr.20170624151245.4033: *7* get_suite_script
def get_suite_script(self):
    s = '''

try:
    g.app.scriptDict['suite'] = suite
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4034: *7* get_test_class_script
def get_test_class_script(self):
    s = '''

try:
    g.app.scriptDict['testclass'] = testclass
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4035: *7* makeTestCase
def makeTestCase(self, p, setup_script):
    c = self.c
    p = p.copy()
    if p.b.strip():
        return GeneralTestCase(c, p, setup_script)
    else:
        return None
.. @+node:ekr.20170624151245.4036: *7* makeTestClass
def makeTestClass(self, p):
    """Create a subclass of unittest.TestCase"""
    c, tm = self.c, self
    fname = 'makeTestClass'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("nothing in %s" % p.h)
        return None
    try:
        script = script + tm.get_test_class_script()
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p, 'unittest': unittest}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        testclass = g.app.scriptDict.get('testclass')
        suite = g.app.scriptDict.get('suite')
        if suite and testclass:
            print("\n%s: both 'suite' and 'testclass defined in %s" % (
                fname, p.h))
        elif testclass:
            suite = unittest.TestLoader().loadTestsFromTestCase(testclass)
            return suite
        elif suite:
            return suite
        else:
            print("\n%s: neither 'suite' nor 'testclass' defined in %s" % (
                fname, p.h))
            return None
    except Exception:
        print('\n%s: exception creating test class in %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4037: *7* makeTestSuite
# This code executes the script in an @suite node.
# This code assumes that the script sets the 'suite' var to the test suite.

def makeTestSuite(self, p, setup_script):
    """Create a suite of test cases by executing the script in an @suite node."""
    c, tm = self.c, self
    fname = 'makeTestSuite'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("no script in %s" % p.h)
        return None
    if setup_script:
        script = setup_script + script
    try:
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\n%s: %s script did not set suite var" % (fname, p.h))
        return suite
    except Exception:
        print('\n%s: exception creating test cases for %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4022: *5* re: more flexible logging with curses gui
.. @+node:ekr.20170624151245.4023: *6* TM.doTests & helpers (local tests)
def doTests(self, all=None, marked=None, verbosity=1):
    '''
    Run any kind of local unit test.

    Important: this is also called from dynamicUnitTest.leo
    to run external tests "locally" from dynamicUnitTest.leo
    '''
    trace = False
    c, tm = self.c, self
    # Clear the screen before running multiple unit tests locally.
    # if all or marked: g.cls()
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    # This seems a bit risky when run in unitTest.leo.
    if not c.fileName().endswith('unitTest.leo'):
        if c.isChanged():
            c.save() # Eliminate the need for ctrl-s.
    if trace: g.trace('marked', marked, 'c', c)
    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.runningAllUnitTests = all and not marked # Bug fix: 2012/12/20
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = c.p.copy()
        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        aList = tm.findAllUnitTestNodes(all, marked)
        setup_script = None
        found = False
        for p in aList:
            if tm.isTestSetupNode(p):
                setup_script = p.b
                test = None
            elif tm.isTestNode(p):
                if trace: g.trace('adding', p.h)
                test = tm.makeTestCase(p, setup_script)
            elif tm.isSuiteNode(p): # @suite
                if trace: g.trace('adding', p.h)
                test = tm.makeTestSuite(p, setup_script)
            elif tm.isTestClassNode(p):
                if trace: g.trace('adding', p.h)
                test = tm.makeTestClass(p) # A suite of tests.
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            if trace: g.trace('not found: running raw body')
            test = tm.makeTestCase(c.p, setup_script)
            if test:
                suite.addTest(test)
                found = True
        if found:
            if g.app.gui.guiName() == 'curses':
                logger, handler, stream = self.create_logging_stream()
                runner = unittest.TextTestRunner(
                    stream=stream,
                    failfast=g.app.failFast,
                    verbosity=verbosity,
                )
            else:
                stream = None
                runner = unittest.TextTestRunner(
                    # stream=stream, # Careful: doesn't work with Python 2.
                    failfast=g.app.failFast,
                    verbosity=verbosity,
                )
            result = runner.run(suite)
            if stream:
                if stream.aList:
                    logger.info('\n'+''.join(stream.aList))
                logger.removeHandler(handler)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace2) for(t, trace2) in result.errors]
                c.cacher.db[key] = archive
        else:
            g.error('no %s@test or @suite nodes in %s outline' % (
                'marked ' if marked else '',
                'entire' if all else 'selected'))
    finally:
        c.setChanged(changed) # Restore changed state.
        g.unitTesting = g.app.unitTesting = False
        if True: # g.app.unitTestDict.get('restoreSelectedNode', True):
            # This is more natural, and more useful.
            c.contractAllHeadlines()
            c.redraw(p1)
        else:
            c.recolor() # Needed when coloring is disabled in unit tests.
.. @+node:ekr.20170624151245.4031: *7* class LoggingLog
class LoggingStream:
    '''A class that can searve as a logging stream.'''

    def __init__(self, logger):
        self.aList = []
        self.logger = logger

    def write(self, s):
        '''Called from pr and also unittest.addSuccess/addFailure.'''
        if 0: # Write everything on a new line.
            if not s.isspace():
                self.logger.info(s.rstrip())
        else:
            s = s.strip()
            if len(s) == 1:
                self.aList.append(s)
            elif s:
                if self.aList:
                    self.logger.info(''.join(self.aList))
                    self.aList = []
                self.logger.info(s.rstrip())
    def flush(self):
        pass
.. @+node:ekr.20170624151245.4032: *7* create_logging_stream
def create_logging_stream(self):

    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

        # Don't use debug: it includes Qt debug messages.
    for handler in logger.handlers or []:
        if isinstance(handler, logging.handlers.SocketHandler):
            break
    else:
        handler = logging.handlers.SocketHandler(
            'localhost',
            logging.handlers.DEFAULT_TCP_LOGGING_PORT,
        )
        logger.addHandler(handler)
    stream = self.LoggingStream(logger)
    return logger, handler, stream
.. @+node:ekr.20170624151245.4033: *7* get_suite_script
def get_suite_script(self):
    s = '''

try:
    g.app.scriptDict['suite'] = suite
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4034: *7* get_test_class_script
def get_test_class_script(self):
    s = '''

try:
    g.app.scriptDict['testclass'] = testclass
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4035: *7* makeTestCase
def makeTestCase(self, p, setup_script):
    c = self.c
    p = p.copy()
    if p.b.strip():
        return GeneralTestCase(c, p, setup_script)
    else:
        return None
.. @+node:ekr.20170624151245.4036: *7* makeTestClass
def makeTestClass(self, p):
    """Create a subclass of unittest.TestCase"""
    c, tm = self.c, self
    fname = 'makeTestClass'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("nothing in %s" % p.h)
        return None
    try:
        script = script + tm.get_test_class_script()
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p, 'unittest': unittest}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        testclass = g.app.scriptDict.get('testclass')
        suite = g.app.scriptDict.get('suite')
        if suite and testclass:
            print("\n%s: both 'suite' and 'testclass defined in %s" % (
                fname, p.h))
        elif testclass:
            suite = unittest.TestLoader().loadTestsFromTestCase(testclass)
            return suite
        elif suite:
            return suite
        else:
            print("\n%s: neither 'suite' nor 'testclass' defined in %s" % (
                fname, p.h))
            return None
    except Exception:
        print('\n%s: exception creating test class in %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4037: *7* makeTestSuite
# This code executes the script in an @suite node.
# This code assumes that the script sets the 'suite' var to the test suite.

def makeTestSuite(self, p, setup_script):
    """Create a suite of test cases by executing the script in an @suite node."""
    c, tm = self.c, self
    fname = 'makeTestSuite'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("no script in %s" % p.h)
        return None
    if setup_script:
        script = setup_script + script
    try:
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\n%s: %s script did not set suite var" % (fname, p.h))
        return suite
    except Exception:
        print('\n%s: exception creating test cases for %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4031: *7* class LoggingLog
class LoggingStream:
    '''A class that can searve as a logging stream.'''

    def __init__(self, logger):
        self.aList = []
        self.logger = logger

    def write(self, s):
        '''Called from pr and also unittest.addSuccess/addFailure.'''
        if 0: # Write everything on a new line.
            if not s.isspace():
                self.logger.info(s.rstrip())
        else:
            s = s.strip()
            if len(s) == 1:
                self.aList.append(s)
            elif s:
                if self.aList:
                    self.logger.info(''.join(self.aList))
                    self.aList = []
                self.logger.info(s.rstrip())
    def flush(self):
        pass
.. @+node:ekr.20170624151245.4032: *7* create_logging_stream
def create_logging_stream(self):

    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

        # Don't use debug: it includes Qt debug messages.
    for handler in logger.handlers or []:
        if isinstance(handler, logging.handlers.SocketHandler):
            break
    else:
        handler = logging.handlers.SocketHandler(
            'localhost',
            logging.handlers.DEFAULT_TCP_LOGGING_PORT,
        )
        logger.addHandler(handler)
    stream = self.LoggingStream(logger)
    return logger, handler, stream
.. @+node:ekr.20170624151245.4033: *7* get_suite_script
def get_suite_script(self):
    s = '''

try:
    g.app.scriptDict['suite'] = suite
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4034: *7* get_test_class_script
def get_test_class_script(self):
    s = '''

try:
    g.app.scriptDict['testclass'] = testclass
except NameError:
    pass

'''
    return g.adjustTripleString(s, self.c.tab_width)
.. @+node:ekr.20170624151245.4035: *7* makeTestCase
def makeTestCase(self, p, setup_script):
    c = self.c
    p = p.copy()
    if p.b.strip():
        return GeneralTestCase(c, p, setup_script)
    else:
        return None
.. @+node:ekr.20170624151245.4036: *7* makeTestClass
def makeTestClass(self, p):
    """Create a subclass of unittest.TestCase"""
    c, tm = self.c, self
    fname = 'makeTestClass'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("nothing in %s" % p.h)
        return None
    try:
        script = script + tm.get_test_class_script()
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p, 'unittest': unittest}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        testclass = g.app.scriptDict.get('testclass')
        suite = g.app.scriptDict.get('suite')
        if suite and testclass:
            print("\n%s: both 'suite' and 'testclass defined in %s" % (
                fname, p.h))
        elif testclass:
            suite = unittest.TestLoader().loadTestsFromTestCase(testclass)
            return suite
        elif suite:
            return suite
        else:
            print("\n%s: neither 'suite' nor 'testclass' defined in %s" % (
                fname, p.h))
            return None
    except Exception:
        print('\n%s: exception creating test class in %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4037: *7* makeTestSuite
# This code executes the script in an @suite node.
# This code assumes that the script sets the 'suite' var to the test suite.

def makeTestSuite(self, p, setup_script):
    """Create a suite of test cases by executing the script in an @suite node."""
    c, tm = self.c, self
    fname = 'makeTestSuite'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("no script in %s" % p.h)
        return None
    if setup_script:
        script = setup_script + script
    try:
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\n%s: %s script did not set suite var" % (fname, p.h))
        return suite
    except Exception:
        print('\n%s: exception creating test cases for %s' % (fname, p.h))
        g.es_print_exception()
        return None
.. @+node:ekr.20170624151245.4038: *6* debug.listenToLog
@cmd('listen-to-log')
@cmd('log-listen')
def listenToLog(self, event=None):
    '''
    A socket listener, listening on localhost. See:
    https://docs.python.org/2/howto/logging-cookbook.html#sending-and-receiving-logging-events-across-a-network
    
    Start this listener first, then start the broadcaster.
    
    leo/plugins/cursesGui2.py is a typical broadcaster.
    '''
    # Kill any previous listener.
    if g.app.log_listener:
        g.es_print('Killing previous listener')
        try:
            g.app.log_listener.kill()
        except Exception:
            g.es_exception()
        g.app.log_listener = None
    # Start a new listener.
    g.es_print('Starting log_listener.py')
    path = g.os_path_finalize_join(g.app.loadDir,
        '..', 'external', 'log_listener.py')
    g.app.log_listener = subprocess.Popen(
        [sys.executable, path],
        shell=False,
        universal_newlines=True,
    )
.. @+node:ekr.20170624151245.4039: *4* re: Indicate branch in Window title
.. @+node:ekr.20170624151245.5061: *5* g.computeWindowTitle
def computeWindowTitle(fileName):

    branch = g.gitBranchName(path=g.os_path_dirname(fileName))
    if not fileName:
        return branch + ": untitled" if branch else 'untitled'
    else:
        path, fn = g.os_path_split(fileName)
        if path:
            title = fn + " in " + path
        else:
            title = fn
        # Yet another fix for bug 1194209: regularize slashes.
        if os.sep in '/\\':
            title = title.replace('/', os.sep).replace('\\', os.sep)
        if branch:
            title = branch + ": " + title
        return title
.. @+node:ekr.20170624151245.5536: *3* ----- re 505: new-read branch
@language rest
@wrap
https://github.com/leo-editor/leo-editor/issues/505

Clone precedence
    
- 1 (top): clones in external files not containing @all
- 2 (medium): clones in external files containing @all.
- 3 (bottom): clones existing only in the .leo file.

Design

- Leo should warn about clone conflicts (and create recovered nodes) only when the conflict arises from two conflicting external files of the same priority. Otherwise, the **data in the higher-priority external file must rule**.
- The "last clone wins" rule must go. Position within the outline is unimportant.
- Headlines must *always* come from sentinels (for @file nodes).
- Leo should *never* report resurrected nodes.

@language python
.. @+node:ekr.20170624151245.5537: *4* re: write files only once in at.writeAll
.. @+node:ekr.20170624151245.5538: *5* at.writeAll & helpers (changed)
def writeAll(self,
    writeAtFileNodesFlag=False,
    writeDirtyAtFileNodesFlag=False,
    toString=False
):
    """Write @file nodes in all or part of the outline"""
    trace = False and not g.unitTesting
    at = self; c = at.c
    if trace: scanAtPathDirectivesCount = c.scanAtPathDirectivesCount
    writtenFiles = [] # Files that might be written again.
    force = writeAtFileNodesFlag
    # This is the *only* place where these are set.
    # promptForDangerousWrite sets cancelFlag only if canCancelFlag is True.
    at.canCancelFlag = True
    at.cancelFlag = False
    at.yesToAll = False
    if writeAtFileNodesFlag:
        # The Write @<file> Nodes command.
        # Write all nodes in the selected tree.
        root = c.p
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        root = c.rootPosition()
        p = c.rootPosition()
        after = None
    at.clearAllOrphanBits(p)
    # Leo 5.6: write files only once.
    seen = set()
    while p and p != after:
        if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
            if p.isAnyAtFileNode():
                c.ignored_at_file_nodes.append(p.h)
            # Note: @ignore not honored in @asis nodes.
            p.moveToNodeAfterTree() # 2011/10/08: Honor @ignore!
        elif p.isAnyAtFileNode():
            if p.v not in seen:
                seen.add(p.v)
                try:
                    self.writeAllHelper(p, root, force, toString, writeAtFileNodesFlag, writtenFiles)
                except Exception:
                    # Fix bug 1260415: https://bugs.launchpad.net/leo-editor/+bug/1260415
                    # Give a more urgent, more specific, more helpful message.
                    g.es_exception()
                    g.es('Internal error writing: %s' % (p.h), color='red')
                    g.es('Please report this error to:', color='blue')
                    g.es('https://groups.google.com/forum/#!forum/leo-editor', color='blue')
                    g.es('Warning: changes to this file will be lost', color='red')
                    g.es('unless you can save the file successfully.', color='red')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    # Make *sure* these flags are cleared for other commands.
    at.canCancelFlag = False
    at.cancelFlag = False
    at.yesToAll = False
    # say the command is finished.
    if not g.unitTesting:
        if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
            if writtenFiles:
                g.es("finished")
            elif writeAtFileNodesFlag:
                g.warning("no @<file> nodes in the selected tree")
                # g.es("to write an unchanged @auto node,\nselect it directly.")
            else:
                g.es("no dirty @<file> nodes")
    if c.isChanged():
        # Save the outline if only persistence data nodes are dirty.
        self.saveOutlineIfPossible()
    if trace: g.trace('%s calls to c.scanAtPathDirectives()' % (
        c.scanAtPathDirectivesCount - scanAtPathDirectivesCount))
.. @+node:ekr.20170624151245.5539: *6* at.clearAllOrphanBits
def clearAllOrphanBits(self, p):
    '''Clear orphan bits for all nodes *except* orphan @file nodes.'''
    # 2011/06/15: Important bug fix: retain orphan bits for @file nodes.
    for p2 in p.self_and_subtree():
        if p2.isOrphan():
            if p2.isAnyAtFileNode():
                # g.trace('*** retaining orphan bit',p2.h)
                pass
            else:
                p2.clearOrphan()
.. @+node:ekr.20170624151245.5540: *6* at.writeAllHelper & helper
def writeAllHelper(self, p, root,
    force, toString, writeAtFileNodesFlag, writtenFiles
):
    '''
    Write one file for the at.writeAll.
    Do *not* write @auto files unless p == root.
    This prevents the write-all command from needlessly updating
    the @persistence data, thereby annoyingly changing the .leo file.
    '''
    trace = False and not g.unitTesting
    at, c = self, self.c
    at.root = root # 2014/10/21
    if not force and p.v not in writtenFiles:
        at.autoBeautify(p)
    if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
        pathChanged = False
    else:
        oldPath = g.os_path_normcase(at.getPathUa(p))
        newPath = g.os_path_normcase(g.fullPath(c, p))
        pathChanged = oldPath and oldPath != newPath
        # 2010/01/27: suppress this message during save-as and save-to commands.
        if pathChanged and not c.ignoreChangedPaths:
            # g.warning('path changed for',p.h)
            # if trace: g.trace('p %s\noldPath %s\nnewPath %s' % (
                # p.h,repr(oldPath),repr(newPath)))
            ok = self.promptForDangerousWrite(
                fileName=None,
                kind=None,
                message='%s\n%s' % (
                    g.tr('path changed for %s' % (p.h)),
                    g.tr('write this file anyway?')))
            if ok:
                at.setPathUa(p, newPath) # Remember that we have changed paths.
            else:
                return
    if (p.v.isDirty() or
        # p.v.isOrphan() or # 2011/06/17.
        pathChanged or
        writeAtFileNodesFlag or
        p.v in writtenFiles
    ):
        # Tricky: @ignore not recognised in @asis nodes.
        if p.isAtAsisFileNode():
            at.asisWrite(p, toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtIgnoreNode():
            pass # Handled in caller.
        elif p.isAtAutoNode():
            at.writeOneAtAutoNode(p, toString=toString, force=force)
            writtenFiles.append(p.v)
            # Do *not* clear the dirty bits the entries in @persistence tree here!
        elif p.isAtCleanNode():
            at.write(p, kind='@clean', nosentinels=True, toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtEditNode():
            at.writeOneAtEditNode(p, toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtNoSentFileNode():
            at.write(p, kind='@nosent', nosentinels=True, toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtShadowFileNode():
            at.writeOneAtShadowNode(p, toString=toString, force=force or pathChanged)
            writtenFiles.append(p.v)
        elif p.isAtThinFileNode():
            at.write(p, kind='@thin', toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtFileNode():
            at.write(p, kind='@file', toString=toString) 
            writtenFiles.append(p.v)
        if p.v in writtenFiles:
            # Clear the dirty bits in all descendant nodes.
            # However, persistence data may still have to be written.
            # This can not be helped.
            if trace: g.trace('clearing', p.h)
            for p2 in p.self_and_subtree():
                p2.v.clearDirty()
.. @+node:ekr.20170624151245.5541: *7* at.autoBeautify
def autoBeautify(self, p):
    '''Auto beautify p's tree if allowed by settings and directives.'''
    c = self.c
    try:
        if not p.isDirty():
            return
        if leoBeautify.should_kill_beautify(p):
            return
        if c.config.getBool('tidy-autobeautify'):
            # g.trace(p.h)
            leoBeautify.beautifyPythonTree(event={'c': c, 'p0': p.copy()})
    except Exception:
        g.es('unexpected exception')
        g.es_exception()
.. @+node:ekr.20170624151245.5542: *6* at.saveOutlineIfPossible
def saveOutlineIfPossible(self):
    '''Save the outline if only persistence data nodes are dirty.'''
    trace = False and not g.unitTesting
    c = self.c
    changed_positions = [p for p in c.all_unique_positions() if p.v.isDirty()]
    at_persistence = c.persistenceController and c.persistenceController.has_at_persistence_node()
    if at_persistence:
        changed_positions = [p for p in changed_positions
            if not at_persistence.isAncestorOf(p)]
    if changed_positions:
        if trace: g.trace('still changed', [p.h for p in changed_positions])
    else:
        # g.warning('auto-saving @persistence tree.')
        c.setChanged(False)
        c.redraw()
.. @+node:ekr.20170624151245.5543: *4* re: update cache when writing @file nodes
.. @+node:ekr.20170624151245.5544: *5* at.write & helpers (changed)
def write(self,
    root,
    kind='@unknown', # Should not happen.
    nosentinels=False,
    toString=False,
):
    """Write a 4.x derived file.
    root is the position of an @<file> node"""
    trace = False and not g.unitTesting
    at = self; c = at.c
    c.endEditing() # Capture the current headline.
    at.setTargetFileName(root, toString)
    at.initWriteIvars(
        root,
        at.targetFileName,
        nosentinels=nosentinels,
        toString=toString,
    )
    # "look ahead" computation of eventual fileName.
    eventualFileName = c.os_path_finalize_join(
        at.default_directory, at.targetFileName)
    if trace:
        g.trace('default_dir',
            g.os_path_exists(at.default_directory),
            at.default_directory)
        g.trace('eventual_fn', eventualFileName)
    if not toString:
        if at.shouldPromptForDangerousWrite(eventualFileName, root):
            # Prompt if writing a new @file or @thin node would
            # overwrite an existing file.
            ok = self.promptForDangerousWrite(eventualFileName, kind)
            if ok:
                at.rememberReadPath(eventualFileName, root)
            else:
                g.es("not written:", eventualFileName)
                at.setDirtyOrphanBits(root)
                return
    if not at.openFileForWriting(root, at.targetFileName, toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        if trace: g.trace('open failed', eventualFileName)
        return
    try:
        at.writeOpenFile(root, nosentinels=nosentinels, toString=toString)
        assert root == at.root, 'write'
        if toString:
            at.closeWriteFile()
                # sets at.stringOutput and at.outputContents
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            if hasattr(self.root.v, 'tnodeList'):
                delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        else:
            at.closeWriteFile()
            if at.errors > 0 or root.isOrphan():
                at.setDirtyOrphanBits(root)
                g.es("not written:", g.shortFileName(at.targetFileName))
            else:
                # Fix bug 889175: Remember the full fileName.
                at.rememberReadPath(eventualFileName, root)
                at.replaceTargetFileIfDifferent(root)
                    # Sets/clears dirty and orphan bits.
                # Leo 5.6: update the cache *here*, not just when reading.
                fileKey = c.cacher.fileKey(eventualFileName, at.outputContents)
                if trace: g.trace(g.shortFileName(eventualFileName), fileKey)
                c.cacher.writeFile(at.root, fileKey)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        if toString:
            at.exception("exception preprocessing script")
            root.v._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
.. @+node:ekr.20170624151245.5545: *6* at.setTargetFileName
def setTargetFileName(self, root, toString):
    '''Set the target file name for at.write.'''
    at = self
    if toString:
        at.targetFileName = "<string-file>"
    else:
        at.targetFileName = root.anyAtFileNodeName()
.. @+node:ekr.20170624151245.5546: *6* at.setDirtyOrphanBits
def setDirtyOrphanBits(self, root):
    '''
    Setting the orphan and dirty flags tells Leo to write the tree.
    However, the dirty bits get cleared if we are called from the save command.
    '''
    at = self
    root.setOrphan()
    root.setDirty()
    # Delete the temp file.
    if at.outputFileName:
        self.remove(at.outputFileName)
.. @+node:ekr.20170624151245.5547: *4* re: Creating resurrected notes
.. @+node:ekr.20170624151245.5548: *5* at.deleteUnvisitedNodes & helpers
def deleteUnvisitedNodes(self, root):
    '''
    Delete unvisited nodes in root's subtree, not including root.

    Before Leo 5.6: Move unvisited node to be children of the 'Resurrected
    Nodes'.
    '''
    at = self
    # Find the unvisited nodes.
    aList = [z for z in root.subtree() if not z.isVisited()]
    if aList:
        if new_read:
            # Never create resurrected nodes.
            at.c.deletePositionsInList(aList)
        else:
            r = at.createResurrectedNodesNode()
            assert r not in aList
            callback = at.defineResurrectedNodeCallback(r, root)
            # Move the nodes using the callback.
            at.c.deletePositionsInList(aList, callback)
.. @+node:ekr.20170624151245.5549: *6* createResurrectedNodesNode
def createResurrectedNodesNode(self):
    '''Create a 'Resurrected Nodes' node as the last top-level node.'''
    at = self; c = at.c; tag = 'Resurrected Nodes'
    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()
    # Create the node after last if it doesn't exist.
    if last.h == tag:
        p = last
    else:
        p = last.insertAfter()
        p.setHeadString(tag)
    p.expand()
    return p
.. @+node:ekr.20170624151245.5550: *6* defineResurrectedNodeCallback
def defineResurrectedNodeCallback(self, r, root):
    '''Define a callback that moves node p as r's last child.'''
    trace = False and not g.unitTesting

    def callback(p, r=r.copy(), root=root):
        '''The resurrected nodes callback.'''
        child = r.insertAsLastChild()
        child.h = 'From %s' % root.h
        v = p.v
        if 1: # new code: based on vnodes.
            import leo.core.leoNodes as leoNodes
            for parent_v in v.parents:
                assert isinstance(parent_v, leoNodes.VNode), parent_v
                if v in parent_v.children:
                    childIndex = parent_v.children.index(v)
                    if trace: g.trace('*moving*', parent_v, childIndex, v)
                    v._cutLink(childIndex, parent_v)
                    v._addLink(len(child.v.children), child.v)
                else:
                    # This would be surprising.
                    g.trace('**already deleted**', parent_v, v)
        else: # old code, based on positions.
            p.moveToLastChildOf(child)
        if not g.unitTesting:
            g.error('resurrected node:', v.h)
            g.blue('in file:', root.h)

    return callback
.. @+node:ekr.20170624151245.5551: *4* Update headlines
.. @+node:ekr.20170624151245.5552: *5* at.createNewThinNode & helpers
def createNewThinNode(self, gnx, headline, level):
    '''Create a new (new-style) vnode.'''
    at = self
    testFile = at.targetFileName.endswith('clone-revert-test.txt')
    trace = (False and testFile) and not g.unitTesting
    if trace:
        g.trace('v5: %s level: %2s %-24s %s' % (at.readVersion5, level, gnx, headline))
        g.trace(at.thinNodeStack)
    if at.thinNodeStack:
        if at.readVersion5: # Expected.
            v = self.createV5ThinNode(gnx, headline, level)
        else: # Legacy files.
            at.thinNodeStack.append(at.lastThinNode)
            v = at.old_createThinChild4(gnx, headline)
    else:
        v = at.root.v
        if at.readVersion5:
            at.thinChildIndexStack.append(0)
        at.thinNodeStack.append(v)
    at.lastThinNode = v
    return v
.. @+node:ekr.20170624151245.5553: *6* at.createV5ThinNode
def createV5ThinNode(self, gnx, headline, level):
    '''Create a version 5 vnode.'''
    at = self
    trace = False and not g.unitTesting
    oldLevel = len(at.thinNodeStack)
    newLevel = level
    assert oldLevel >= 1
    assert newLevel >= 1
    # The invariant: top of at.thinNodeStack after changeLevel is the parent.
    at.changeLevel(oldLevel, newLevel - 1)
    parent = at.thinNodeStack[-1]
    n = at.thinChildIndexStack[-1]
    if trace: g.trace(oldLevel, newLevel - 1, n, parent.h, headline)
    v = at.new_createThinChild4(gnx, headline, n, parent)
    at.thinChildIndexStack[-1] = n + 1
    at.thinNodeStack.append(v)
    at.thinChildIndexStack.append(0)
    at.lastThinNode = v
    # Ensure that the body text is set only once.
    # Huh?
    if v.isVisited():
        if hasattr(v, 'tempBodyList'):
            delattr(v, 'tempBodyList')
    else:
        # This is the only place we call v.setVisited in the read logic.
        v.setVisited()
    return v
.. @+node:ekr.20170624151245.5556: *6* at.new_createThinChild4 (changed)
def new_createThinChild4(self, gnxString, headline, n, parent):
    """
    Find or create a new *vnode* whose parent (also a vnode)
    is at.lastThinNode. This is called only for @thin trees.
    """
    trace = False and not g.unitTesting
    trace_tree = False
    c = self.c
    if trace and trace_tree:
        g.trace(n, len(parent.children), parent.h, ' -> ', headline)
        # at.thinChildIndexStack,[z.h for z in at.thinNodeStack],
    gnx = gnxString = g.toUnicode(gnxString)
    gnxDict = c.fileCommands.gnxDict
    v = gnxDict.get(gnxString)
    if v and gnx != v.fileIndex:
        g.internalError('v.fileIndex: %s gnx: %s' % (v.fileIndex, gnx))
        return None
    if v:
        if new_read:
            if hasattr(v, 'tempRoots') and v.h != headline:
                g.trace('changed headline', list(v.tempRoots))
            # Honor the headline.
            v.h = headline
        else:
            # Always use v.h, regardless of headline.
            if trace and v.h != headline:
                g.trace('read error v.h: %s headline: %s' % (v.h, headline))
        child = v # The return value.
        if n >= len(parent.children):
            child._linkAsNthChild(parent, n)
            if trace and trace_tree:
                g.trace('OLD n: %s parent: %s -> %s' % (n, parent.h, child.h))
        elif trace:
            if trace_tree: g.trace('DUP n: %s parent: %s -> %s' % (
                n, parent.h, child.h))
            else:
                g.trace('CLONE', id(v), v.gnx, v.h)
    else:
        v = leoNodes.VNode(context=c, gnx=gnx)
        v._headString = headline # Allowed use of v._headString.
        gnxDict[gnxString] = v
        if g.trace_gnxDict: g.trace(c.shortFileName(), gnxString, v)
        child = v
        child._linkAsNthChild(parent, n)
        if trace and v.h == 'clone-test':
            g.trace('NEW n: %s parent: %s -> %s' % (n, parent.h, child.h))
    return child
.. @+node:ekr.20170624151245.5555: *6* at.old_createThinChild4
def old_createThinChild4(self, gnxString, headline):
    """
    Find or create a new *vnode* whose parent (also a vnode)
    is at.lastThinNode. This is called only for @thin trees.
    """
    trace = False and not g.unitTesting
    verbose = True
    at = self; c = at.c
    gnx = gnxString = g.toUnicode(gnxString)
    gnxDict = c.fileCommands.gnxDict
    last = at.lastThinNode # A VNode.
    lastIndex = last.fileIndex
    if trace and verbose: g.trace("last %s, gnx %s %s" % (
        last and last.h, gnxString, headline))
    parent = last
    children = parent.children
    for child in children:
        if gnx == child.fileIndex:
            break
    else:
        child = None
    if at.cloneSibCount > 1:
        n = at.cloneSibCount; at.cloneSibCount = 0
        if child: clonedSibs, junk = at.scanForClonedSibs(parent, child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        if trace: g.trace(copies, headline)
    else:
        if gnx == lastIndex:
            last.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace: g.trace('found last', last)
            return last
        if child:
            child.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace: g.trace('found child', child)
            return child
        copies = 1 # Create exactly one copy.
    while copies > 0:
        copies -= 1
        # Create the VNode only if it does not already exist.
        v = gnxDict.get(gnxString)
        if v:
            if gnx != v.fileIndex:
                g.internalError('v.fileIndex: %s gnx: %s' % (
                    v.fileIndex, gnx))
        else:
            v = leoNodes.VNode(context=c, gnx=gnx)
            v._headString = headline # Allowed use of v._headString.
            gnxDict[gnxString] = v
            if g.trace_gnxDict: g.trace(c.shortFileName(), gnxString, v)
        child = v
        child._linkAsNthChild(parent, parent.numberOfChildren())
    if trace: g.trace('new node: %s' % child.h)
    child.setVisited() # Supress warning/deletion of unvisited nodes.
    return child
.. @+node:ekr.20170624151245.5556: *5* at.new_createThinChild4 (changed)
def new_createThinChild4(self, gnxString, headline, n, parent):
    """
    Find or create a new *vnode* whose parent (also a vnode)
    is at.lastThinNode. This is called only for @thin trees.
    """
    trace = False and not g.unitTesting
    trace_tree = False
    c = self.c
    if trace and trace_tree:
        g.trace(n, len(parent.children), parent.h, ' -> ', headline)
        # at.thinChildIndexStack,[z.h for z in at.thinNodeStack],
    gnx = gnxString = g.toUnicode(gnxString)
    gnxDict = c.fileCommands.gnxDict
    v = gnxDict.get(gnxString)
    if v and gnx != v.fileIndex:
        g.internalError('v.fileIndex: %s gnx: %s' % (v.fileIndex, gnx))
        return None
    if v:
        if new_read:
            if hasattr(v, 'tempRoots') and v.h != headline:
                g.trace('changed headline', list(v.tempRoots))
            # Honor the headline.
            v.h = headline
        else:
            # Always use v.h, regardless of headline.
            if trace and v.h != headline:
                g.trace('read error v.h: %s headline: %s' % (v.h, headline))
        child = v # The return value.
        if n >= len(parent.children):
            child._linkAsNthChild(parent, n)
            if trace and trace_tree:
                g.trace('OLD n: %s parent: %s -> %s' % (n, parent.h, child.h))
        elif trace:
            if trace_tree: g.trace('DUP n: %s parent: %s -> %s' % (
                n, parent.h, child.h))
            else:
                g.trace('CLONE', id(v), v.gnx, v.h)
    else:
        v = leoNodes.VNode(context=c, gnx=gnx)
        v._headString = headline # Allowed use of v._headString.
        gnxDict[gnxString] = v
        if g.trace_gnxDict: g.trace(c.shortFileName(), gnxString, v)
        child = v
        child._linkAsNthChild(parent, n)
        if trace and v.h == 'clone-test':
            g.trace('NEW n: %s parent: %s -> %s' % (n, parent.h, child.h))
    return child
.. @+node:ekr.20170624151245.5557: *4* Found:nodeConflictList (Keep)
# flattened, word, ignore-case, head, body

# found 7 nodes
.. @+node:ekr.20170624151245.5558: *5* Init nodeConflicList
.. @+node:ekr.20170624151245.5559: *6* c.initDocumentIvars
def initDocumentIvars(self):
    '''Init per-document ivars.'''
    self.expansionLevel = 0
        # The expansion level of this outline.
    self.expansionNode = None
        # The last node we expanded or contracted.
    self.nodeConflictList = []
        # List of nodes with conflicting read-time data.
    self.nodeConflictFileName = None
        # The fileName for c.nodeConflictList.
    self.user_dict = {}
        # Non-persistent dictionary for free use by scripts and plugins.
.. @+node:ekr.20170624151245.5560: *6* c.refreshFromDisk
# refresh_pattern = re.compile('^(@[\w-]+)')

@cmd('refresh-from-disk')
def refreshFromDisk(self, event=None):
    '''Refresh an @<file> node from disk.'''
    trace = False and not g.unitTesting
    c, p, u = self, self.p, self.undoer
    c.nodeConflictList = []
    fn = p.anyAtFileNodeName()
    if fn:
        b = u.beforeChangeTree(p)
        redraw_flag = True
        at = c.atFileCommands
        c.recreateGnxDict()
            # Fix bug 1090950 refresh from disk: cut node ressurection.
        i = g.skip_id(p.h, 0, chars='@')
        word = p.h[0: i]
        if word == '@auto':
            # This includes @auto-*
            p.deleteAllChildren()
            # Fix #451: refresh-from-disk selects wrong node.
            p = at.readOneAtAutoNode(fn, p)
        elif word in ('@thin', '@file'):
            p.deleteAllChildren()
            at.read(p, force=True)
        elif word in ('@clean',):
            # Wishlist 148: use @auto parser if the node is empty.
            if p.b.strip() or p.hasChildren():
                at.readOneAtCleanNode(p)
            else:
                # Fix #451: refresh-from-disk selects wrong node.
                p = at.readOneAtAutoNode(fn, p)
        elif word == '@shadow ':
            p.deleteAllChildren()
            at.read(p, force=True, atShadow=True)
        elif word == '@edit':
            p.deleteAllChildren()
            at.readOneAtEditNode(fn, p)
        else:
            g.es_print('can not refresh from disk\n%r' % p.h)
            redraw_flag = False
    else:
        g.warning('not an @<file> node:\n%r' % (p.h))
        redraw_flag = False
    if redraw_flag:
        # Fix #451: refresh-from-disk selects wrong node.
        c.selectPosition(p)
        u.afterChangeTree(p, command='refresh-from-disk', bunch=b)
        # Create the 'Recovered Nodes' tree.
        c.fileCommands.handleNodeConflicts()
        t1 = time.clock()
        c.redraw()
        t2 = time.clock()
        if trace:
            n = sum([1 for z in p.self_and_subtree()])
            h = sum([hash(z.h) for z in p.self_and_subtree()])
            g.trace('%s nodes, hash: %s in %5.2f sec. %r' % (n, h, (t2-t1), p.h))
.. @+node:ekr.20170624151245.5561: *6* fc.initReadIvars
def initReadIvars(self):
    self.descendentTnodeUaDictList = []
    self.descendentVnodeUaDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
        # 2011/12/10: never re-init this dict.
        # self.gnxDict = {}
        # g.trace('*** clearing gnxDict',g.callers())
    self.c.nodeConflictList = [] # 2010/01/05
    self.c.nodeConflictFileName = None # 2010/01/05
.. @+node:ekr.20170624151245.5580: *5* at.terminateBody (test)
def terminateBody(self, v, postPass=False):
    '''Terminate scanning of body text for node v. Set v.b.'''
    trace = False and not g.unitTesting
    at = self
    if at.readVersion5:
        new = ''.join(v.tempBodyList) if hasattr(v, 'tempBodyList') else ''
    else:
        new = ''.join(at.out)
    new = g.toUnicode(new)
    if new_read:
        # at.createThinChild4 creates v.tempRoots.
        # *Do* allow changes to the root node.
        if hasattr(v, 'tempRoots'):
            pass
            ###
                # g.trace('=====', list(v.tempRoots))
                # old = v.bodyString()
                # at.indicateNodeChanged(old, new, postPass, v)
        else:
            # No other @file node has set this node.
            # Just replace the body string
            v.tempRoots = set()
            v.setBodyString(new)
        v.tempRoots.add(self.root.h)
    else:
        old = v.bodyString()
        # Warn if the body text has changed. Don't warn about the root node.
        if v != at.root.v and at.bodyIsInited(v) and new != old:
            at.indicateNodeChanged(old, new, postPass, v)
        v.setBodyString(new)
    at.bodySetInited(v)
        # Note: the sax code also sets this, so we can't use
        # this "bit" in place of v.tempRoots.
    if trace:
        g.trace('%25s old %3s new %3s' % (v.gnx, len(old), len(new)), v.h)
.. @+node:ekr.20170624151245.5563: *5* Create g.Bunch entries
.. @+node:ekr.20170624151245.5574: *6* cacher.createOutlineFromCacheList & helpers
def createOutlineFromCacheList(self, parent_v, aList, fileName, top=True):
    '''
    Create outline structure from recursive aList built by makeCacheList.
    '''
    trace = False and not g.unitTesting
    c = self.c
    if not c:
        g.internalError('no c')
    if top:
        if trace: g.trace(g.shortFileName(fileName))
        c.cacheListFileName = fileName
    if not aList:
        if trace: g.trace('no list')
        return
    h, b, gnx, children = aList
    if h is not None:
        v = parent_v
        v._headString = g.toUnicode(h)
        v._bodyString = g.toUnicode(b)
    for child_tuple in children:
        h, b, gnx, grandChildren = child_tuple
        if trace:
            g.trace('%9s %3s %s' % (gnx, len(grandChildren), h.strip()))
        isClone, child_v = self.fastAddLastChild(fileName, gnx, parent_v)
        if isClone:
            self.checkForChangedNodes(child_tuple, fileName, parent_v)
        else:
            self.createOutlineFromCacheList(child_v, child_tuple, fileName, top=False)
.. @+node:ekr.20170624151245.5575: *7* cashe.fastAddLastChild
# Similar to createThinChild4

def fastAddLastChild(self, fileName, gnxString, parent_v):
    '''
    Create new VNode as last child of the receiver.
    If the gnx exists already, create a clone instead of new VNode.
    '''
    trace = False and not g.unitTesting
    c = self.c
    gnxString = g.toUnicode(gnxString)
    gnxDict = c.fileCommands.gnxDict
    if gnxString is None: v = None
    else: v = gnxDict.get(gnxString)
    is_clone = v is not None
    if trace: g.trace(
        'clone', '%-5s' % (is_clone),
        'parent_v', parent_v, 'gnx', gnxString, 'v', repr(v))
    if is_clone:
        pass
    else:
        if gnxString:
            assert g.isUnicode(gnxString)
            v = leoNodes.VNode(context=c, gnx=gnxString)
            if g.trace_gnxDict: g.trace(c.shortFileName(), gnxString, v)
        else:
            v = leoNodes.VNode(context=c)
            # This is not an error: it can happen with @auto nodes.
            # g.trace('**** no gnx for',v,parent_v)
        # Indicate that this node came from an external file.
        v.tempRoots = set()
        v.tempRoots.add(fileName)
    child_v = v
    child_v._linkAsNthChild(parent_v, parent_v.numberOfChildren())
    child_v.setVisited() # Supress warning/deletion of unvisited nodes.
    return is_clone, child_v
.. @+node:ekr.20170624151245.5576: *7* casher.reportChangedNode
def reportChangedNode(self, child_tuple, child_v, fileName, parent_v):
    '''
    Report changes in a node child_v.
    
    Nodes can be out-of-synch with other nodes in two ways:
    
    Common: When switching git branches.
    Rare:   When external files have been changed outside Leo.
    
    It is only essential to warn of the rare case.
    '''
    trace = (True or g.app.debug) and not g.unitTesting
    always_warn = True # True always warn about changed nodes.
    c = self.c
    h, b, gnx, grandChildren = child_tuple
    old_b, new_b = child_v.b, b
    old_h, new_h = child_v.h, h
    # Leo 5.6: test headlines.
    same_head = old_h == new_h
    same_body = (
        old_b == new_b or
        new_b.endswith('\n') and old_b == new_b[: -1] or
        old_b.endswith('\n') and new_b == old_b[: -1]
    )
    if same_head and same_body:
        return
    if trace:
        g.trace('==========', repr(old_h), repr(new_h))
        g.trace('old %4s new %s %s' % (len(old_b), len(new_b), h))
    must_warn = hasattr(child_v, 'tempRoots') or not child_v.isCloned()
    if not hasattr(child_v, 'tempRoots'):
        child_v.tempRoots = set()
    child_v.tempRoots.add(fileName)
    if must_warn:
        self.warning('Warning: out-of-synch node: %s' % (h))
        g.es_print('Retaining node in %s' % (fileName))
    if always_warn or must_warn:
        c.nodeConflictList.append(g.bunch(
            tag='(cached)',
            fileName=fileName,
            gnx=gnx,
            b_old=child_v.b,
            h_old=child_v.h,
            b_new=b,
            h_new=h,
            root_v=parent_v,
        ))
    # Always update the node.
    child_v.h, child_v.b = h, b
    child_v.setDirty()
    c.changed = True # Tell getLeoFile to propegate dirty nodes.
.. @+node:ekr.20170624151245.5577: *7* cacher.checkForChangedNodes
update_warning_given = False

def checkForChangedNodes(self, child_tuple, fileName, parent_v):
    '''
    Update the outline described by child_tuple, including all descendants.
    '''
    junk_h, junk_b, gnx, grand_children = child_tuple
    child_v = self.c.fileCommands.gnxDict.get(gnx)
    if child_v:
        self.reportChangedNode(child_tuple, child_v, fileName, parent_v)
        for grand_child in grand_children:
            self.checkForChangedNodes(grand_child, fileName, child_v)
    elif not self.update_warning_given:
        self.update_warning_given = True
        g.internalError('no vnode', child_tuple)
.. @+node:ekr.20170624151245.5576: *6* casher.reportChangedNode
def reportChangedNode(self, child_tuple, child_v, fileName, parent_v):
    '''
    Report changes in a node child_v.
    
    Nodes can be out-of-synch with other nodes in two ways:
    
    Common: When switching git branches.
    Rare:   When external files have been changed outside Leo.
    
    It is only essential to warn of the rare case.
    '''
    trace = (True or g.app.debug) and not g.unitTesting
    always_warn = True # True always warn about changed nodes.
    c = self.c
    h, b, gnx, grandChildren = child_tuple
    old_b, new_b = child_v.b, b
    old_h, new_h = child_v.h, h
    # Leo 5.6: test headlines.
    same_head = old_h == new_h
    same_body = (
        old_b == new_b or
        new_b.endswith('\n') and old_b == new_b[: -1] or
        old_b.endswith('\n') and new_b == old_b[: -1]
    )
    if same_head and same_body:
        return
    if trace:
        g.trace('==========', repr(old_h), repr(new_h))
        g.trace('old %4s new %s %s' % (len(old_b), len(new_b), h))
    must_warn = hasattr(child_v, 'tempRoots') or not child_v.isCloned()
    if not hasattr(child_v, 'tempRoots'):
        child_v.tempRoots = set()
    child_v.tempRoots.add(fileName)
    if must_warn:
        self.warning('Warning: out-of-synch node: %s' % (h))
        g.es_print('Retaining node in %s' % (fileName))
    if always_warn or must_warn:
        c.nodeConflictList.append(g.bunch(
            tag='(cached)',
            fileName=fileName,
            gnx=gnx,
            b_old=child_v.b,
            h_old=child_v.h,
            b_new=b,
            h_new=h,
            root_v=parent_v,
        ))
    # Always update the node.
    child_v.h, child_v.b = h, b
    child_v.setDirty()
    c.changed = True # Tell getLeoFile to propegate dirty nodes.
.. @+node:ekr.20170624151245.5579: *6* at.indicateNodeChanged (To do)
def indicateNodeChanged(self, old, new, postPass, v):
    '''
    Add an entry to c.nodeConflictList.
    Called only from at.terminateBody.
    '''
    at, c = self, self.c
    debug = False # Debug perfect import.
    if at.perfectImportRoot:
        if not postPass:
            at.correctedLines += 1
            if debug:
                at.reportCorrection(old, new, v)
            v.setDirty()
                # Just mark the vnode dirty.
                # Ancestors will be marked dirty later.
            c.setChanged(True)
    else:
        # Do nothing if only trailing whitespace is involved.
        if new.endswith('\n') and old == new[: -1]: return
        if old.endswith('\n') and new == old[: -1]: return
        c.nodeConflictList.append(g.bunch(
            tag='(uncached)',
            gnx=v.gnx,
            fileName=at.root.h,
            b_old=old,
            b_new=new,
            h_old=v._headString,
            h_new=v._headString,
            root_v = at.root and at.root.v,
        ))
        v.setDirty()
            # Just set the dirty bit. Ancestors will be marked dirty later.
        c.changed = True
            # Important: the dirty bits won't stick unless we set c.changed here.
            # Do *not* call c.setChanged(True) here: that would be too slow.
.. @+node:ekr.20170624151245.5570: *5* Use nodeConflictList
.. @+node:ekr.20170624151245.5572: *6* fc.handleNodeConflicts
def handleNodeConflicts(self):
    '''Create a 'Recovered Nodes' node for each entry in c.nodeConflictList.'''
    c = self.c
    if not c.nodeConflictList:
        return
    if not c.make_node_conflicts_node:
        g.es_print('suppressed node conflicts', color='red')
        return None
    # Create the 'Recovered Nodes' node.
    last = c.lastTopLevel()
    root = last.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()
    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn = bunch.get('fileName') or ''
        b1, h1 = bunch.get('b_old'), bunch.get('h_old')
        b2, h2 = bunch.get('b_new'), bunch.get('h_new')
        root_v = bunch.get('root_v') or ''
        child = root.insertAsLastChild()
        h = 'Recovered node "%s" from %s' % (h1, g.shortFileName(fn))
        child.setHeadString(h)
        if b1 == b2:
            lines = [
                'Headline changed...'
                '%s gnx: %s root: %r' % (tag, gnx, root_v and root.v),
                'old headline: %s' % (h1),
                'new headline: %s' % (h2),
            ]
            child.setBodyString('\n'.join(lines))
        else:
            line1 = '%s gnx: %s root: %r\nDiff...\n' % (tag, gnx, root_v and root.v)
            d = difflib.Differ().compare(g.splitLines(b1), g.splitLines(b2))
                # 2017/06/19: reverse comparison order.
            diffLines = [z for z in d]
            lines = [line1]
            lines.extend(diffLines)
            # There is less need to show trailing newlines because
            # we don't report changes involving only trailing newlines.
            child.setBodyString(''.join(lines))
            n1 = child.insertAsNthChild(0)
            n2 = child.insertAsNthChild(1)
            n1.setHeadString('old:' + h1)
            n1.setBodyString(b1)
            n2.setHeadString('new:' + h2)
            n2.setBodyString(b2)
    return root
.. @+node:ekr.20170624151245.5572: *4* fc.handleNodeConflicts
def handleNodeConflicts(self):
    '''Create a 'Recovered Nodes' node for each entry in c.nodeConflictList.'''
    c = self.c
    if not c.nodeConflictList:
        return
    if not c.make_node_conflicts_node:
        g.es_print('suppressed node conflicts', color='red')
        return None
    # Create the 'Recovered Nodes' node.
    last = c.lastTopLevel()
    root = last.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()
    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn = bunch.get('fileName') or ''
        b1, h1 = bunch.get('b_old'), bunch.get('h_old')
        b2, h2 = bunch.get('b_new'), bunch.get('h_new')
        root_v = bunch.get('root_v') or ''
        child = root.insertAsLastChild()
        h = 'Recovered node "%s" from %s' % (h1, g.shortFileName(fn))
        child.setHeadString(h)
        if b1 == b2:
            lines = [
                'Headline changed...'
                '%s gnx: %s root: %r' % (tag, gnx, root_v and root.v),
                'old headline: %s' % (h1),
                'new headline: %s' % (h2),
            ]
            child.setBodyString('\n'.join(lines))
        else:
            line1 = '%s gnx: %s root: %r\nDiff...\n' % (tag, gnx, root_v and root.v)
            d = difflib.Differ().compare(g.splitLines(b1), g.splitLines(b2))
                # 2017/06/19: reverse comparison order.
            diffLines = [z for z in d]
            lines = [line1]
            lines.extend(diffLines)
            # There is less need to show trailing newlines because
            # we don't report changes involving only trailing newlines.
            child.setBodyString(''.join(lines))
            n1 = child.insertAsNthChild(0)
            n2 = child.insertAsNthChild(1)
            n1.setHeadString('old:' + h1)
            n1.setBodyString(b1)
            n2.setHeadString('new:' + h2)
            n2.setBodyString(b2)
    return root
.. @+node:ekr.20170624151245.5576: *4* casher.reportChangedNode
def reportChangedNode(self, child_tuple, child_v, fileName, parent_v):
    '''
    Report changes in a node child_v.
    
    Nodes can be out-of-synch with other nodes in two ways:
    
    Common: When switching git branches.
    Rare:   When external files have been changed outside Leo.
    
    It is only essential to warn of the rare case.
    '''
    trace = (True or g.app.debug) and not g.unitTesting
    always_warn = True # True always warn about changed nodes.
    c = self.c
    h, b, gnx, grandChildren = child_tuple
    old_b, new_b = child_v.b, b
    old_h, new_h = child_v.h, h
    # Leo 5.6: test headlines.
    same_head = old_h == new_h
    same_body = (
        old_b == new_b or
        new_b.endswith('\n') and old_b == new_b[: -1] or
        old_b.endswith('\n') and new_b == old_b[: -1]
    )
    if same_head and same_body:
        return
    if trace:
        g.trace('==========', repr(old_h), repr(new_h))
        g.trace('old %4s new %s %s' % (len(old_b), len(new_b), h))
    must_warn = hasattr(child_v, 'tempRoots') or not child_v.isCloned()
    if not hasattr(child_v, 'tempRoots'):
        child_v.tempRoots = set()
    child_v.tempRoots.add(fileName)
    if must_warn:
        self.warning('Warning: out-of-synch node: %s' % (h))
        g.es_print('Retaining node in %s' % (fileName))
    if always_warn or must_warn:
        c.nodeConflictList.append(g.bunch(
            tag='(cached)',
            fileName=fileName,
            gnx=gnx,
            b_old=child_v.b,
            h_old=child_v.h,
            b_new=b,
            h_new=h,
            root_v=parent_v,
        ))
    # Always update the node.
    child_v.h, child_v.b = h, b
    child_v.setDirty()
    c.changed = True # Tell getLeoFile to propegate dirty nodes.
.. @+node:ekr.20170624151245.5574: *4* cacher.createOutlineFromCacheList & helpers
def createOutlineFromCacheList(self, parent_v, aList, fileName, top=True):
    '''
    Create outline structure from recursive aList built by makeCacheList.
    '''
    trace = False and not g.unitTesting
    c = self.c
    if not c:
        g.internalError('no c')
    if top:
        if trace: g.trace(g.shortFileName(fileName))
        c.cacheListFileName = fileName
    if not aList:
        if trace: g.trace('no list')
        return
    h, b, gnx, children = aList
    if h is not None:
        v = parent_v
        v._headString = g.toUnicode(h)
        v._bodyString = g.toUnicode(b)
    for child_tuple in children:
        h, b, gnx, grandChildren = child_tuple
        if trace:
            g.trace('%9s %3s %s' % (gnx, len(grandChildren), h.strip()))
        isClone, child_v = self.fastAddLastChild(fileName, gnx, parent_v)
        if isClone:
            self.checkForChangedNodes(child_tuple, fileName, parent_v)
        else:
            self.createOutlineFromCacheList(child_v, child_tuple, fileName, top=False)
.. @+node:ekr.20170624151245.5575: *5* cashe.fastAddLastChild
# Similar to createThinChild4

def fastAddLastChild(self, fileName, gnxString, parent_v):
    '''
    Create new VNode as last child of the receiver.
    If the gnx exists already, create a clone instead of new VNode.
    '''
    trace = False and not g.unitTesting
    c = self.c
    gnxString = g.toUnicode(gnxString)
    gnxDict = c.fileCommands.gnxDict
    if gnxString is None: v = None
    else: v = gnxDict.get(gnxString)
    is_clone = v is not None
    if trace: g.trace(
        'clone', '%-5s' % (is_clone),
        'parent_v', parent_v, 'gnx', gnxString, 'v', repr(v))
    if is_clone:
        pass
    else:
        if gnxString:
            assert g.isUnicode(gnxString)
            v = leoNodes.VNode(context=c, gnx=gnxString)
            if g.trace_gnxDict: g.trace(c.shortFileName(), gnxString, v)
        else:
            v = leoNodes.VNode(context=c)
            # This is not an error: it can happen with @auto nodes.
            # g.trace('**** no gnx for',v,parent_v)
        # Indicate that this node came from an external file.
        v.tempRoots = set()
        v.tempRoots.add(fileName)
    child_v = v
    child_v._linkAsNthChild(parent_v, parent_v.numberOfChildren())
    child_v.setVisited() # Supress warning/deletion of unvisited nodes.
    return is_clone, child_v
.. @+node:ekr.20170624151245.5576: *5* casher.reportChangedNode
def reportChangedNode(self, child_tuple, child_v, fileName, parent_v):
    '''
    Report changes in a node child_v.
    
    Nodes can be out-of-synch with other nodes in two ways:
    
    Common: When switching git branches.
    Rare:   When external files have been changed outside Leo.
    
    It is only essential to warn of the rare case.
    '''
    trace = (True or g.app.debug) and not g.unitTesting
    always_warn = True # True always warn about changed nodes.
    c = self.c
    h, b, gnx, grandChildren = child_tuple
    old_b, new_b = child_v.b, b
    old_h, new_h = child_v.h, h
    # Leo 5.6: test headlines.
    same_head = old_h == new_h
    same_body = (
        old_b == new_b or
        new_b.endswith('\n') and old_b == new_b[: -1] or
        old_b.endswith('\n') and new_b == old_b[: -1]
    )
    if same_head and same_body:
        return
    if trace:
        g.trace('==========', repr(old_h), repr(new_h))
        g.trace('old %4s new %s %s' % (len(old_b), len(new_b), h))
    must_warn = hasattr(child_v, 'tempRoots') or not child_v.isCloned()
    if not hasattr(child_v, 'tempRoots'):
        child_v.tempRoots = set()
    child_v.tempRoots.add(fileName)
    if must_warn:
        self.warning('Warning: out-of-synch node: %s' % (h))
        g.es_print('Retaining node in %s' % (fileName))
    if always_warn or must_warn:
        c.nodeConflictList.append(g.bunch(
            tag='(cached)',
            fileName=fileName,
            gnx=gnx,
            b_old=child_v.b,
            h_old=child_v.h,
            b_new=b,
            h_new=h,
            root_v=parent_v,
        ))
    # Always update the node.
    child_v.h, child_v.b = h, b
    child_v.setDirty()
    c.changed = True # Tell getLeoFile to propegate dirty nodes.
.. @+node:ekr.20170624151245.5577: *5* cacher.checkForChangedNodes
update_warning_given = False

def checkForChangedNodes(self, child_tuple, fileName, parent_v):
    '''
    Update the outline described by child_tuple, including all descendants.
    '''
    junk_h, junk_b, gnx, grand_children = child_tuple
    child_v = self.c.fileCommands.gnxDict.get(gnx)
    if child_v:
        self.reportChangedNode(child_tuple, child_v, fileName, parent_v)
        for grand_child in grand_children:
            self.checkForChangedNodes(grand_child, fileName, child_v)
    elif not self.update_warning_given:
        self.update_warning_given = True
        g.internalError('no vnode', child_tuple)
.. @+node:ekr.20170624151245.5578: *4* Found:indicateNodeChanged
# flattened, word, ignore-case, head, body

# found 4 nodes
.. @+node:ekr.20170624151245.5579: *5* at.indicateNodeChanged (To do)
def indicateNodeChanged(self, old, new, postPass, v):
    '''
    Add an entry to c.nodeConflictList.
    Called only from at.terminateBody.
    '''
    at, c = self, self.c
    debug = False # Debug perfect import.
    if at.perfectImportRoot:
        if not postPass:
            at.correctedLines += 1
            if debug:
                at.reportCorrection(old, new, v)
            v.setDirty()
                # Just mark the vnode dirty.
                # Ancestors will be marked dirty later.
            c.setChanged(True)
    else:
        # Do nothing if only trailing whitespace is involved.
        if new.endswith('\n') and old == new[: -1]: return
        if old.endswith('\n') and new == old[: -1]: return
        c.nodeConflictList.append(g.bunch(
            tag='(uncached)',
            gnx=v.gnx,
            fileName=at.root.h,
            b_old=old,
            b_new=new,
            h_old=v._headString,
            h_new=v._headString,
            root_v = at.root and at.root.v,
        ))
        v.setDirty()
            # Just set the dirty bit. Ancestors will be marked dirty later.
        c.changed = True
            # Important: the dirty bits won't stick unless we set c.changed here.
            # Do *not* call c.setChanged(True) here: that would be too slow.
.. @+node:ekr.20170624151245.5580: *5* at.terminateBody (test)
def terminateBody(self, v, postPass=False):
    '''Terminate scanning of body text for node v. Set v.b.'''
    trace = False and not g.unitTesting
    at = self
    if at.readVersion5:
        new = ''.join(v.tempBodyList) if hasattr(v, 'tempBodyList') else ''
    else:
        new = ''.join(at.out)
    new = g.toUnicode(new)
    if new_read:
        # at.createThinChild4 creates v.tempRoots.
        # *Do* allow changes to the root node.
        if hasattr(v, 'tempRoots'):
            pass
            ###
                # g.trace('=====', list(v.tempRoots))
                # old = v.bodyString()
                # at.indicateNodeChanged(old, new, postPass, v)
        else:
            # No other @file node has set this node.
            # Just replace the body string
            v.tempRoots = set()
            v.setBodyString(new)
        v.tempRoots.add(self.root.h)
    else:
        old = v.bodyString()
        # Warn if the body text has changed. Don't warn about the root node.
        if v != at.root.v and at.bodyIsInited(v) and new != old:
            at.indicateNodeChanged(old, new, postPass, v)
        v.setBodyString(new)
    at.bodySetInited(v)
        # Note: the sax code also sets this, so we can't use
        # this "bit" in place of v.tempRoots.
    if trace:
        g.trace('%25s old %3s new %3s' % (v.gnx, len(old), len(new)), v.h)
.. @-all
.. @@nosearch
.. @@killbeautify
.. @@language rest
.. @@wrap
.. @@pagewidth 60
.. @-leo
