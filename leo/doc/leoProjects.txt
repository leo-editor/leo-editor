.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @@language rest

.. @+all
.. @+node:ekr.20131225061403.16376: ** 4.11.1
.. @+node:ekr.20140702131031.16726: *3* Bugs
.. @+node:ekr.20131224124822.16717: *4* Fixed problems with clone-expansion
@language rest

Alt-End when the last top-level node was a clone caused all clones to expand.

The fix was in p.isAncestorOf.

Also, changed p.all_unique_positions() to p.all_positions() in places where p.contract was called.

I started this project by doing a clone-find-all for isExpanded.

@language python
.. @+node:ekr.20131225061403.16378: *4* Fixed bug 1264350
@language rest

Up-arrow on the first node in a chapter switches to another chapter 
https://bugs.launchpad.net/leo-editor/+bug/1264350

Solution:

1. The "fix" at rev 6472 was wrong: The original code was correct.
2. Added a unit test.
.. @+node:ekr.20131225045014.16398: *4* Fixed problem with 1-character reverse searches!
The problem was an off-by-one test in regexHelper.
.. @+node:ekr.20140114145953.16693: *4* Fixed important security hole in mod_scripting plugin
The ctor of the scriptingController does not allow::

    @bool scripting-at-script-nodes = True
    
in local .leo files. 
.. @+node:ekr.20140205074001.16358: *4* Fixed a startup error involving --ipython
Fixed a bug that caused Leo to exit during startup when
--python given on the command line but IPython is not installed.
.. @+node:ekr.20140209065845.16766: *4* Fixed unicode problem in the log pane

@language rest

Fixed bug: https://bugs.launchpad.net/leo-editor/+bug/1276236

g.insertCodingLine adds coding line to start of all python scripts, except when unit testing.
.. @+node:ekr.20140313100328.16828: *4* Fixed serious c.deletePositionsInList bug
@nocolor-node

https://groups.google.com/forum/#!topic/leo-editor/Uoa7ifVV_Aw

I selected ALL nodes, and deleted them. (I think I used the context menu
delete) Then the outline window was red, could not insert any nodes, could
not Undo. Todd. Had to abandon the outline and start again.

# Breaks Leo HARD:
# c.deletePositionsInList(c.all_positions())
.. @+node:ekr.20140424102007.16873: *4* Fixed clone-find-all command
Changed find.findAll and helpers as follows:
    
- findAll inits onlyPosition for the clone-find-all commands.
    
- createCloneFindAllNode does not link the node into the outline.
  To do this, leoFind.py imports leo.core.leoNodes.

- linkCloneFindAllNode does this *after* the command completes. This keeps
  all positions unchanged while they are being scanned.
   
- The code now tests for either clone_find_all or clone_find_all_flattened
  in various places.
.. @+node:ekr.20140313100328.16825: *4* Fixed leoGlobals bug (per Reinhard Engle)
@language rest

Reinhard Engel reinhard.engel.de@googlemail.com

There seems to be a subtle bug in leoGlobals.py:

In the 'globalDirectiveList', the directive 'command' is missing. This
seems not to cause problems, because of the way 'aList' in
'compute_directives_re' is constructed. Then in 'get_directives_dict' the
directive is silently skipped.

The following pattern in 'compute_directives_re' solves this problem:

@language python

aList = [x for x in globalDirectiveList if z != 'others']
aList.sort(lambda a,b: len(b)-len(a))
    # Sort by length, longest first
pat = "^@(%s)(?=( |\t|\n)+)" % "|".join(aList)
.. @+node:ekr.20140531073052.16701: *4* find-all now uses exising find pattern
.. @+node:ekr.20131124060334.16469: *4* Fixed bug 1228458: Inconsistency between Find-forward and Find-backward
https://bugs.launchpad.net/leo-editor/+bug/1228458

The fix was made to firstSearchPane:

In a Leo-Editor file containing exactly one node, there is no way to search
the headline.

Suggested fix: Backward search should search the body and then the headline.
.. @+node:ekr.20131124060912.16474: *4* Fixed bug 1228312: Find tab selected in log pane disables Minibuffer
https://bugs.launchpad.net/leo-editor/+bug/1228312

When the find tab is selected in the log pane, Alt-X complements the Regexp
flag--instead of enabling use of the Minibuffer. It doesn't matter where
focus is. Focus can be in the outline pane or body pane, Alt-X still just
complements the Regexp flag.

Fixed at rev 6351.

This was the so-called "greedy checkbox bug".
.. @+node:ekr.20131124060912.16476: *4* Fixed doc bug 1228452: related to the radio buttons in the Find pane
https://bugs.launchpad.net/leo-editor/+bug/1228452

.. @+node:ekr.20140702131031.16725: *4* Fixed bug 1254861: Ctrl-f doesn't ensure find input field visible
https://bugs.launchpad.net/leo-editor/+bug/1254861

The fix was to LeoQtLog.selectHelper.
.. @+node:ekr.20131124060912.16477: *4* Cleared bug 1228713: Find-backward skips headlines under some conditions
https://bugs.launchpad.net/leo-editor/+bug/1228713

This appears to have been fixed at some time in the past, possibly as the result of fixing another bug.
.. @+node:ekr.20140702131031.16723: *4* Cleared bug 1254864: Can't search from current cursor position downward in body text
https://bugs.launchpad.net/leo-editor/+bug/1254864
.. @+node:ekr.20131124060912.16475: *4* Cleared bug 1228457: Beginning find at the current node's body cursor when that cursor is not displayed
https://bugs.launchpad.net/leo-editor/+bug/1228457

This appears to have been fixed.
.. @+node:ekr.20130502102046.10578: *4* Fixed Crash deleting body editor
# Trying to delete a second body editor.

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 560, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\plugins\qtGui.py", line 2980, in deleteEditor
    name = w.leo_name
AttributeError: 'LeoQTextBrowser' object has no attribute 'leo_name'
.. @+node:ekr.20140714090832.17762: *4* Fixed bug 1090950: refresh from disk - cut node resurrection
Fixed bug 1090950: refresh from disk - cut node resurrection.
https://bugs.launchpad.net/leo-editor/+bug/1090950

refresh_rclick_cb in contextmenu.py now just calls c.refreshFromDisk,
which calls c.recreateGnxDict() before reading any file.

Also created the new refresh-from-disk command and the corresponding item in the File menu.
.. @+node:ekr.20140718092511.17736: *5* print gnxs & gnxDict
@language python
'''A script used while investigating this bug.'''
# g.cls()
d = {}
x = g.app.nodeIndices
result = []
for v in c.all_unique_nodes():
    gnx = v.fileIndex
    assert g.isUnicode(gnx),gnx
    d [gnx] = v
    result.append('%s %s' % (gnx,v))
print('%s v.fileIndex\'s...' % len(result))
print('\n'.join(sorted(result)))
if 1:
    d = c.fileCommands.gnxDict
    print('old: %s fc.gnxDict keys...' % len(list(d.keys())))
    for key in sorted(d.keys()): 
        print('%s %s' % (key,d.get(key)))
if 1:
    c.recreateGnxDict()
    d = c.fileCommands.gnxDict
    print('new: %s fc.gnxDict keys...' % len(list(d.keys())))
    for key in sorted(d.keys()): 
        print('%s %s' % (key,d.get(key)))
.. @+node:ekr.20140727055826.18129: *4* Fixed annoyance: shift-ctrl-w leaves .leo file as dirty
@language rest
  
- pd.update_before_write_foreign_file tells when an @data node has been
  changed. This explains why the .leo file is now dirty.
- at.saveOutlineIfPossible automatically saves the .leo file if only
  unchanged persistence nodes remain.
  
at.saveOutlineIfPossible makes the following hacks unnecessary:
    
- at.writeAllHelper writes an unchanged @auto file only if it is
  selected explicitly.
- Changed at.writeAll so that the no @<file> node written message now says
  that you must selected an unchanged @auto node directly in order to write
  it with the write-at-files-nodes command.

@language python
.. @+node:ekr.20140729055228.17976: *4* Fixed modes/md.py
import glob
pattern = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
for fn in glob.glob(pattern):
    sfn = g.shortFileName(fn)
    f = open(fn)
    s = f.read()
    f.close()
    if s.find(r'regexp="\\') > -1:
        g.es(sfn)

@

Possible automatic computation of First sets:
http://stackoverflow.com/questions/787134/can-i-determine-the-set-of-first-chars-matched-by-regex-pattern
http://www.cs.uky.edu/~lewis/texts/theory/automata/reg-sets.pdf

found: Rules indicated are dubious or broken

md.py:
    disabled: 6,7,
    changed: 8,12,20,21,23,24,25,47
    [ \t]   leadins: 8,20,24,25,50,51
    space   leadins: 23,46,49
    [=-]    leadins: 21,47
    [\\_]   leadins: 54,55
    other   leadins: 12,19,53

moin.py:
    [ \t]           rule 3.
    single-quote    rule 6.

erlang.py:  no obvious problem.
lilypond.py:no obvious problem.
perl.py:    no obvious problem.
pl1.py:     no obvious problm.
rest.py:    no obvious problem.
rtf.py:     no obvious problem.
scala.py:   no obvious problem.
yaml.py:    fixed
.. @+node:ekr.20140809063010.18177: *4* Fixed autocompleter bug
@language rest

The problem was in ic.createImporterData, not at.createWritesData.
A trace in get_leo_namespace pinpointed the problem.

 
.. @+node:ekr.20140702131031.16727: *3* Features
.. @+node:ekr.20131105020211.18059: *4* Added per-node expansions!
@language rest
https://groups.google.com/forum/#!topic/leo-editor/Wd0NtBLEZZk

What I did:

- Added v.expandedPositions ivar.
- Wrote c.shouldBeExpanded.
- p.isExpanded calls c.shouldBeExpanded if p is a clone.
  This is important: it means that most code does not have to be aware of c.shouldBeExpanded.
- p.expand & p.contract maintain p.v.expandedPositions list.
- Rewrote & simplified p.isVisible.
- Left c.positionExists and p.isAncestorOf unchanged.
.. @+node:ekr.20131222112420.16373: *5* Notes
The idea is store "ephemeral" or position-related data **in vnodes*. This
is a completely new idea in Leo's history!

Suppose every vnode contains a new ivar: v.expandedPositions, a list of
(copies of) positions at which v is to be expanded. This would work as
follows:

1. Contracting a node at position p clears p.v.expandedPositions. The happy
   side effects is that contracting any clone will contract them all.

2. Expanding a node at position appends p.copy() to p.v.expandedPositions,
   and purges any no-longer-existing positions from that list.

3. nativeTree.drawChildren will expand nodes using c.shouldBeExpanded(p) instead of
   p.isExpanded(p).

As always, changing outline structure will invalidate positions. Because
c.p and all it's ancestors are always expanded, the worst that can happen
when an outline changes is that some positions that *aren't* the present
position will contract unexpectedly. Most such contraction will occur off
screen.
.. @+node:ekr.20131223064351.16352: *4* Improved p.isAncestorOf and c.positionExists
- Added test for c.positionExists to p.isAncestorOf.
- Added v.isNthChildOf
- Rewrote c.positionsExists using v.isNthChildOf
.. @+node:ekr.20140114145953.16692: *4* Added c.config.isLocalSetting
.. @+node:ekr.20140212082408.16406: *4* Added spell-as-you-type commands
Thanks to Terry Brown for these commands::

spell-as-you-type-toggle
  Enable / disable spell as you type mode.  When enabled, word ending
  keystrokes will put a short list of suggestions in the log window, if
  the word is unknown to the speller.  Only shows the first 5
  suggestions, even if there are more.

spell-as-you-type-next
  Cycle the word behind (left of, for ltr languages) the cursor through
  the full list of suggestions.

spell-as-you-type-undo
  Change the word behind (left of, for ltr languages) the cursor to
.. @+node:ekr.20140218040104.16759: *4* added p.nosentinels
.. @+node:ekr.20140401054342.16845: *4* Created g.run_pylint so pylint can run unmodified
@language rest

This runs pylint (with optional Sherlock tracing) in
a separate process, thereby allowing Leo to run
pylint unchanged.

What I did:

1. pylint-leo.py: run now runs the following command in a separate process::

    <python> -c "import leo.core.leoGlobals as g; g.run_pylint(<args>)"
    
2. g.run_pylint uses Sherlock tracing if requested.

    
.. @+node:ekr.20140426052603.18136: *4* Removed g.choose from Leo's core & plugins
This function is deprecated: use Python's ternary operator instead.
.. @+node:ekr.20140426105101.16868: *4* Converted all class names to pep8 style
Capitalized, no underscores.
.. @+node:ekr.20140601151054.17620: *4* Improved find/replace-all commands
@nocolor-node

These commands now get their arguments from the Find Panel.

Changed the following methods:

generalChangeHelper,
minibufferFind/ReplaceAll,
searchWithPresentOptions,
setReplaceString,

Also fixed the bindings in create_find_buttons so buttons
are bound to the proper button-related methods. As a result,
the find-all and change-all buttons now work as expected.
.. @+node:ekr.20140427131738.16870: *4* Added support for qt5
@language rest

It is not possible to use both the PyQt4 and PyQt5 installers at the same
time. But this is no big deal on Windows: just install PyQt5 for Python 3.4
only.
.. @+node:ekr.20140702091137.16754: *4* Improved idle-time handling and added new commands
@language rest

Added the following commands:
    
disable-idle-time-tracing
enable-idle-time-tracing
toggle-idle-time-tracing
disable-idle-time-events
enable-idle-time-events
toggle-idle-time-events

Simplified and generalized idle-time handling as follows:
    
- Removed g.app.afterHandler: g.app.idleTimeHook does the same thing now.
- The timer callback now calls g.app.idleTimeHook() if it exists.
- g.enableIdleTimeHook now has the following signature::
    
    def enableIdleTimeHook(idleTimeDelay=500,idleTimeHandler=None):
        
  The two args set g.app.idleTimeDelay and g.app.idleTimeHandler respectively.
  g.idleTimeHookHandler is used if idleTimeHandler is None.

The new code has these properties:
    
1. g.app.idleTimeHook() actually gets called only at idle-time,
2. There is no busy waiting, and
3. There is at least g.app.idleTimeDelay msec. between calls to g.app.idleTimeHook()

Here is an script illustrating the possibilities::

@language python

'''
A script illustrating interacting idle-time handlers.
Do Alt-x enable-idle-time-tracing before executing this script
'''
class Handlers:
    def h1(self):
        g.trace()
        g.enableIdleTimeHook(1000,self.h2)
    def h2(self):
        g.trace()
        g.enableIdleTimeHook(500,self.h1)
h = Handlers()
if g.app.idleTimeHook:
    g.disableIdleTimeHook()
else:
    g.enableIdleTimeHook(1000,h.h1)
.. @+node:ekr.20140702124615.16727: *4* Added support for html handlebar syntax coloring
These are colored with the previously unused literal3 tag,
so you specify the color with:

    @color html_literal3_color = pink
.. @+node:ekr.20140402091953.16865: *4* Added pylint command
@language rest

When pylint is available on your machine, Leo's pylint
command will execute run pylint on all @<file> nodes in the
selected tree. This command is now available from the popup
menus created by the contextmenu plugin.

This command is a dynamic way of selecting files to check
with pylint. It is *much* easier to use than the old pylint
-r option in pylint-leo.py. There is no longer any need to
update a list of "recent" files. Hooray.

The command has significantly changed my work flow. I use
pylint much more often.

The details of the search process are as follows:

1. The command looks down the tree of the selected node,
   looking for @<file> nodes.
2. If now @<file> nodes are found, it looks up the tree,
   looking for @<file> nodes.
3. If the selected node is a clone, and no @<file> nodes
   have yet been found, it expands the search to all
   ancestors of all positions cloned to the selected node.

This means that you can check a file by selecting any
(possibly clone) node of the file.

**Important**: running pylint-leo.py is still often very
useful. In particular, I often run python pylint-leo.py -a
to check all files. Here is the recently improved docstring
for pylint-leo.py::

    '''
    This file runs pylint on predefined lists of files.
    
    The -r option no longer exists. Instead, use Leo's pylint command to run
    pylint on all Python @<file> nodes in a given tree.
    
    On windows, the following .bat file runs this file::
        python27 pylint-leo.py %*
    
    On Ubuntu, the following alias runs this file::
        pylint="python27 pylint-leo.py"
    '''
.. @+node:ekr.20140720065949.17739: *4* Created @auto-org-mode
@language rest

Note: persistence applies to @auto-vimoutline-mode and @auto-org-mode

Done:
- Added @auto-org-mode to list of valid @auto nodes.
- Created org-mode importer.
- Create at.writeOneOrgModeNode, called from at.writeOneAtAutoNode

@language python
.. @+node:ekr.20140727180847.17989: *4* Completed generalization of importers
@language rest

- ic.createOutline and its helper, ic.dispatch, now use tables
  created by ic.createImporterData and its helper.

- Eliminated odious special cases involving self.treeType in
  ic.create_top_node and ic.init_import.
  
- self.treeType is used only in a limited way in the scanner classes:
  The only tests are against '@root' and '@file'.
  
- For now, the unit-tests wrappers are hard-coded.
.. @+node:ekr.20140723120730.17921: *4* The @auto write code now uses writer plugins
@language rest

What I did:
- at.createWritersData inits tables using the writers_dict in each plugin.
- at.writeOnAtAutoNode calls at.dispatch to find writers.
  An important escape hatch: at.writeOnAtAutoNode calls the *existing* rst.writer
  if the user deletes plugins/writers/rst.py.

Won't do:
- at.writeAllHelper has lots of special-case code, but that probably can't be helped.
- It would be way too dangerous to refactor the write code for @file, @shadow, etc.
    
@language python
.. @+node:ekr.20140729162415.18088: *4* Leo now supports dynamic @auto names
@language rest

The leo/plugins/importers folders now contains importer plugins.

The leo/plugins/writers folders now contain writer plugins.

Both importer and writer plugins can defined new kinds of @auto nodes.

Importers and writers can register either @auto-names or
file extensions. I have just verified that @auto x.xyzzy
will use both the importer and the writer for the .xyzzy
extension, that is, importers/test.py and writers/test.py.
So, for *unique* extensions, there is no need to use a
separate @auto name, you can just use @auto.

What I did:

- atFile.ctor sets two sets of spellings of @auto names: g.app.atAutoNames
  & g.app.atFileNames

- Loading importer & writer plugins updates g.app.atAutoNames:
    - at.parse_writer_dict sets at.atAutoWritersDict & at.writersDispatchDict
    - ic.parse_importer_dict sets ic.atAutoDict and ic.classDispatchDict

@language python
.. @+node:ekr.20140730072544.17981: *4* Leo imports importers & writers from home/.leo
@language rest

Leo now imports from ~/.leo/plugins before importing from leo/plugins.

The new code is in at.createWritersData & helper and ic.at.createImportersData & their helpers.
.. @+node:ekr.20140730081842.17990: *5*  demo script
'''Load each plugins ~/.leo/plugins if possible, then from leo/plugins.'''
import glob
def report(message,kind,folder,name):
    g.trace('%7s: %5s %9s %s' % (message,kind,folder,name))
g.cls()
plugins1 = g.os_path_finalize_join(g.app.homeDir,'.leo','plugins')
plugins2 = g.os_path_finalize_join(g.app.loadDir,'..','plugins')
seen = set() # set of (folder,sfn)
for kind,plugins in (('home',plugins1),('leo',plugins2)):
    if g.os_path_exists(plugins):
        for folder in ('importers','writers'):
            path = g.os_path_finalize_join(plugins,folder)
            pattern = g.os_path_finalize_join(plugins,folder,'*.py')
            for fn in glob.glob(pattern):
                sfn = g.shortFileName(fn)
                if g.os_path_exists(fn) and sfn != '__init__.py':
                    moduleName = sfn[:-3]
                    if moduleName:
                        data = (folder,sfn)
                        if data in seen:
                            report('seen',kind,folder,sfn)
                        else:
                            m = g.importFromPath(moduleName,path) # Uses imp.
                            if m:
                                seen.add(data)
                                report('loaded',kind,folder,m.__name__)
                            else:
                                report('error',kind,folder,sfn)
                # else: report('skipped',kind,folder,sfn)
.. @+node:ekr.20140801121720.18064: *3* Vim: documented in commit logs
@language rest
- The f,F,t,T commands now work regardless of repeat count or vc.cross_lines.
- Fixed recent bug in vim_T.

- Fixed a major bug affecting visual mode:
  vc.done now sets v.handler = vc.do_visual_mode if mode was 'visual'.
- Added very effective debugging trace to vc.ignore.
- Used vc.do(leo-command-name) wherever possible to simplify code.
  vc.vim_T fails at present.
- Added back-to-home-extend-selection command, for use by vc.do :-)
* Added code to check for missing motions in normal and visual mode dispatch dicts.
  Added several missing motions.
- The / and ? commands now update the selection range properly in visual mode.
  This required a new callback, vc.update_selection_after_search,
  called from leoFind.showSuccess.
- Added the :print-dot command.
- The / and ? commands now update the dot.
    - Added callbacks to vc.update_dot_before_search in
      leoFind.generalSearch/ChangeHelper.    
- Added ge,gb,gh commands: same as $,0,^.
- h,j,k,l in outline work like the corresponding arrow keys in the tree pane.
- 0 in outline pane: goto-first-visible-node
- e in outline pane: goto-last-visible-node.
.. @-all

# Put this @language after the @all as a kind of permanent unit test.

.. @@language python # Override the default .txt coloring.

.. @@pagewidth 60
.. @-leo
