.. @+leo-ver=5-thin
.. @+node:ekr.20101028110015.8271: * @file slideshows.txt
.. @+all
.. @+node:ekr.20101021092135.5431: **  Drafts
.. @+node:ekr.20101115152915.4930: *3* 1. External files (draft)
@nocolor-node

===== Intro

Trees whose root headline starts with \@file, \@auto or \@edit create **external
files** on your file system.  Here are some example headlines::

  @file myClass.py
  @auto ../graphics/circles.cpp
  @edit ~/.leo/.leoID.txt

As you can see, these nodes specify file names, which can be an absolute
path or a path relative to the directory containing the Leo outline.

Collectively, nodes that create external files are known as **@<file> nodes.**
Leo defines several other kinds of @<file> nodes, but this slideshow will not
discuss them.

===== Automatic load/store make Leo an IDE

Leo automatically loads all @<file> trees when you open a Leo outline, and Leo
writes any modified @<file> tree when you save an outline. Reading external
files is very fast because of an efficient file-caching scheme.

A single Leo outline may be connected to dozens of external files: this makes
Leo work like an Integrated Development Environment (IDE). Leo outlines act like
project files. For example, one Leo outline, leoPyRef.leo, contains \@file trees
for all of Leo's core source files. Another Leo outline, leoPluginsRef.leo,
creates the external files for all of Leo's plugins, and LeoDocs.leo contains
all of Leo's documentation.

===== Using sentinel lines, or not

Leo stores the structure of \@file trees in external files themselves using
comment lines called **sentinel lines**. Sentinel lines allow Leo to keep track
of outlines structure, including clone relationships. Using \@file is **highly
recommended** whenever possible. In particular, using \@file allows you to
**share outline structure** with others merely by sharing external files.
External files created from \@file nodes contain **all** essential data: The
.leo file contains only the headline of the \@file node. All the data resides in
the external files.

However, in some situations it is not appropriate to use sentinel comments in
external files. In that case you use \@auto and \@edit trees to connect Leo
outlines to existing external files without creating sentinel files. Not all of
Leo's features can be used with \@auto and \@edit trees, but that can't be
helped. In particular, Leo can not preserve outline structure exactly. Leo's
"degraded" operation for such trees is similar to that found in all other
editors and IDE's.

The rest of this slide show will discuss \@file trees and their capabilities. We
will then discuss \@auto and \@edit.

===== Using @file trees.

To repeat, it's best to use \@file to create external files if at all possible.
The next series of slides will show you how to create external files with \@file
trees.

To create a new external file, create an \@file node giving the path to the
external file. This path can be a full, absolute path, but usually it is more
convenient to use a relative path. All relative paths in @<file> nodes are
relative to Leo's **load directory**, the directory containing the .leo file for
the present outline. In most cases, we can ignore the path prefix entirely. For
example::

    @file myFile.py

===== The top-level body text: section references & @others

Here is the body text for a typical @file node that defines a single Python class::

    << imports >>

    class MyDemoClass:

        @others

Informally, it says that external file consists of import statements,
followed by the class MyDemoClass.  We expect to see the following:

- A child node whose headline << imports >>.

- The methods of MyDemoClass in all the **other** child nodes.

The next few slides will discuss this pattern line by line.

===== << imports >>

    The << imports >> line is a **section reference**.
    "Imports" is the **section name**.
    This line tells Leo to insert the **section definition**
    into the output file at the place where section reference occurs.

===== Section definitions

    **Section definition nodes** create section definitions.
    Section definition nodes contain a section name in the headline.
    The body text contains the section definition.

    Therefore, the definition of << imports >> are the lines::

        import os
        import sys

    Each section definition node must be a descendant of the node
    containing the section reference.

===== @others definitions

    The \@others directive is similar to a section reference;
    \@others tells Leo to insert text into the output file.

    However, instead of inserting the body text of one particular node,
    as in a section reference, \@others tells Leo to insert the
    body text of all node that **aren't** section definition nodes.
    That's where the name comes from: it inserts all the **other** nodes.

===== Simple expansion of @others.

    Here we have added two children of the root node, named, as usual
    in Python examples, spam and eggs.  The expansion of the \@others directive
    will be the body text of those two nodes.  Each line of the expansion is
    indented with the leading whitespace that occurs before the \@others directive.

===== Indentation

    Let us use the term **reference** to mean either a section reference or an
    \@others directive. The **expansion** of a reference is the set of all lines
    that Leo writes to the output file as the result of that reference.

    The indentation of references is significant. Leo indents each line of the
    expansion of a reference by the total amount of leading whitespace that is
    in effect at the point of the reference. This allows Leo handle languages
    like Python in which indentation is especially important.

    In our example, there is no leading whitespace before the reference to
    << imports >>, but there are four spaces before the \@others directives.
    This means that Leo writes the import statements without additional indentation,
    but Leo adds 4 spaces before all nodes written as the result of the @other directive.

    **Important**: Indentation is controlled **only** by the indentation of
    references. The outline level of nodes in expansions does not affect
    indentation in any way.

    This **decoupling** of outline structure from indentation is very important:
    it allows you to create **organizer nodes** without affecting the external
    file in any significant way (other than sentinel comments).

===== Expansion

    In our first example, the expansions of references are straightforward.
    However, any node may contain one or more section references, and any node
    may also contain a single \@others directive.

    Every line of an expansion is written as the result of exactly one
    reference.

    A. The expansion of a section reference is just exactly the expansion of the
       body of the section definition node. That expansion may include
       expansions of *other* references appearing in that node.

    B. The expansion of an @others directive is the expansion of all descendant
       nodes that aren't section definition nodes and are not included in the
       expansion of \@others nodes deeper in the tree. This means that no node
       is ever included in the expansion of more than one \@other directive.
       Non-section-definition nodes are included in the expansion of the nearest
       \@others directive.

    When writing an \@file tree, Leo ensures all of the following:

    1. Each section must be defined. There must be a section reference in an
        ancestor of each section defition node.

    2. There must be no **orphan nodes**.  A section definition node is an
       orphan if no ancestor node contains a reference to that node.
       A non-definition node is an orphan if no ancestor node contains an
       \@others directive.

    Leo will issue an error if these checks are not satisifed.

    In short, each node in an \@file tree, except the \@file node itself, must
    be part of the expansion of exactly one reference. 

    In practice, these rules are much easier to use than to describe!


===== Multiple @others nodes: top-level node

    ((
    << imports >>
    @others
    ))

    An example will clarify matters.  Here is a common pattern for a file that
    defines two classes, SpamClass and EggsClass.  The top-level node includes imports,
    and then uses \@others to include the expansion of the rest of the outline.

===== Multiple @others nodes: SpamClass

    ((
    class SpamClass:
        @others
    ))

    The first child node creates the expansion of SpamClass.
    The line::

        class SpamClass:

    has no extra indentation, because the \@others in the top-level
    node has no leading whitespace.

    However, all the methods of the class will have 4 spaces of indentation
    because the \@others directive in *this* node is indented by 4 spaces.

===== Multiple @others nodes: EggsClass

    ((
    class EggsClass:
        @others
    ))

    The second child node creates the expansion of EggsClass in a similar manner.
    It's always perfectly clear what nodes are included in \@others directives.

    Here, \@others refers to all descendant nodes of *this* node.

===== Multiple @others nodes: @if 0:

    ((
    if 0:
        @others
    ))

    You can use @others to "comment out" all descendant nodes as shown. This
    works in Python because the indentation of the \@others directive cause the
    expansion of all descendant nodes to have 4 extra spaces.

===== Using @auto nodes.

    When Leo reads an **@auto node**, Leo will automatically create an outline
    that shows the class, functions or other units of the external file.

    Leo can only do this if Leo has an **importer** for the external file. At
    present, Leo has importers for C, elisp, HTML, .ini files, Java, Javascript,
    Pascal, PHP, Python and xml. Leo determines the language using the file's
    extension. If no parser exists for a language, Leo copies the entire body of
    the external file into the \@auto node.

===== Using @edit nodes

    When Leo reads and **@edit node**, Leo reads the entire contents of the
    external file into the body text of the \@edit node.
.. @+node:ekr.20101115152915.4931: *3* 2. Clones & views
@nocolor-node

Clones focus attention.

===== Intro

    Clones are one of Leo's most unusual and most useful features.

    A **clone** is a node that appears in more than one place in a Leo outline.

====== Create clone of A

    Here, we have cloned node A by selecting A and doing Ctrl=` (clone-node)

    Clones are marked with a small red *clone arrow** in the icon box.
    Deleting the penultimate clone removes the red arrow from the node.

====== Clones are identical

    Changing the headline or body text of a clone changes the headline or body
    text of all other clones of that node. Furthermore, changing any descendants
    of a clone, including inserting, deleting or moving nodes, results in the
    same changes being made to all other clones.

    In fact, all clones of a node are actually *the exactly the same node*, so
    any change to one clone inevitably affects all other clones.

===== Changing the headline of a clone.

    Here, I am beginning to change the headline of Node A.
    The headline doesn't actually change until we hit return,
    so the headline of these clone of A hasn't changed yet.

===== Change complete.

    After typing <return> the headlines of both nodes changes.

===== Node b.

    Here we have created a node B following the first clone of B.

===== Move B right

    Moving B right makes B a child of node A.
    As you can see, B appears as a child of both cloned nodes.

    Even the expansion state of cloned nodes are identical:
    both clones are now expanded.

===== Create another child (newheadline)

    Here, I have created a new node with Ctrl-I (insert-node).

    The node appears in the same place in both nodes.

===== Auto update

    Changing a node marks all clones of that node as changed. When I save the
    Leo outline, Leo automatically writes all the external files that contain
    dirty nodes.

===== Clones create views

    Clones are important because they allow you to create as many views of the
    data in the outline as you like. In effect, Leo becomes a supremely flexible
    filing cabinet. Any ordinary node can act like a folder in the filing
    cabinet. Using clones, you can "file" a node in as many folders as you like.

    In Leo, a **view** is simply a subset of the nodes of the outline. We
    represent a view as **ordinary** node, called a **view node**, whose nodes
    can contain both regular nodes and clones. The children of the view node are
    the subset of nodes that define the view. It's that simple.

    With Leo, you can have as many view nodes as you like. There is no such
    thing as a single, "correct" view of data. 


===== Using view nodes

    I use view nodes to focus attention on a set of disparate nodes.

    For example, when I fix a bug in Leo, I create a **bug node** containing
    all the data in Leo's source code that relates to the bug. As I discover
    code related to the bug, I clone nodes and move them under the bug node.
    I'll also add ordinary nodes as children of the bug node. These nodes
    contain the original bug report, descriptions of how I fixed the bug, test
    data, or any other notes I might want to keep.

    Once I have created the bug node, I concentrate *only* on that node and its
    children. I can examine the bug node and its children without having to jump
    around the outline. Everything I need is in one place. This extremely narrow
    focus makes it *much* easier to fix bugs. to jump around the outline. It
    doesn't matter how big or complex the outline is: I am only dealing with the
    bug node and its children.

    **Important**: I can fix the bug by changing the clones in the view node.
    When I save the Leo file, Leo will save all the @<file> nodes that contain any
    changed clone.  Everything "just works".
.. @+node:ekr.20101115152915.4936: *3* 3. Scripting Leo
@language rest

===== Intro

For me, scripting is the most fun part of Leo.

Leo can execute any body text as a **Leo script**, Python scripts that have full
access to all data in any open Leo outline, as well as full access to all parts
of Leo's source code.

Leo's Ctrl-B (execute-script) command runs the body text of a node as a Leo script.

===== c, g, p

Leo's execute script command predefines the c, g and p constants
when it runs any script inside Leo:

    **g** is Leo's leo.core.leoGlobals module. This module contains several
    dozen utility functions and classes.

    **g.app** is the **application object** representing the entire Leo
    application. The instance variables (ivars) of g.app represent Leo's global
    variables.

    **c** is the **commander** of the outline containing the script. A commander
    gives Leo scripts all access to all data present while Leo is running,
    including all data in all open outlines and all of Leo's source code.

    **p** is the **position** of the presently selected node. Positions
    represent positions in the traversal of Leo outlines.

    **p.v** is the **vnode** at position p. A vnode represents an outline node.
    Because of clones, a vnode may appear in several places in a traversal.
    Vnodes hold most of the data in Leo outlines. For any vnode v, v.h is the
    node's headline, and v.b is the node's body text. As a convenience, for any
    position p, p.h and p.b are synonyms for p.v.h and p.v.b.

This slide show will show how to use c, g and p.

===== g.es

g.es is a function that prints its arguments to Leo's log pane.

Here is the hello world program as a Leo script::

    g.es('Hello world!')

.. show "Hello world!" in the log pane.

===== Creating scripts from trees

The Execute Script command **preprocesses** the script before executing it, in
exactly the same way that Leo writes external files. Leo expands section
references and processes \@others directives before executing the script. This
allows you to use all of Leo's outlining capabilities to organize your scripts.

===== p.h and p.b (as getters)

Given any position p, **p.h** is the headline text of p.v, and **p.b** is the
body text of p.v.

===== p.h and p.b (as setters)

p.h and p.b are `Python properties`_, which means you can set the headline and
body text by assigning to them::

    p.h = p.h + ' more'

In order to see the result of changing a headline, you will have to redraw the outline::

    c.redraw()

===== c.p (as getter and setter)

**c.p** is presently selected postion. Like p.b and p.h, c.p is a Python
Property, so you can change the presently selected position by assigning to c.p.
Just remember to call c.redraw() so that the change becomes visible.

===== iterators

Leo scripts use the commander to get access to all nodes of the outline.

c.all_positions() is a `Python iterator`_ that returns all the positions of the outline in order.

    ((
    for p in c.all_positions():
        print ' '*p.level(),p.h
    ))

Note that this sample code redefines one of the predefined constants.  That's perfectly
fine.

===== g.openWithFileName

===== g.pdb

.. @+node:ekr.20101118091038.5355: *4* Traversing outlines
Leo scripts can easily access any node of an outline with generators. Leo's
generators return positions or nodes, one after another. Generators do not
return lists, but you can make lists from generators easily. For example, the
c.all_positions() generator returns every position in c's tree, one after
another. You can use the generator directly, like this::

    for p  in c.all_positions():
        print(p.h)

You can create actual lists from generators in several ways::

    aList = list(c.all_positions()] # Use the list built-in function.
    print(aList)

or::

    aList = [p.copy() for p in c.all_positions()] # Use list comprehension.
    print(aList)


Using the list is simpler, but list comprehensions can be more flexible.  For example::

    aList = [p.copy().h for p in c.all_positions() if p.h.startswith('@file')]
    print(aList)
.. @+node:ekr.20101118091038.5356: *5* c.all_positions & c.all_unique_positions
The c.all_positions generator returns a list of all positions in the outline.
This script makes a list of all the nodes in an outline::

    nodes = list(c.all_positions())
    print("This outline contains %d nodes" % len(nodes))

The c.all_unique_positions generator returns a list of all unique positions in the outline.
For each vnode v in the outline, exactly one position p is returned such that p.v == v.

This script prints the *distinct* vnodes of an outline::

    for p in c.all_unique_positions():
        sep = g.choose(p.hasChildren(),'+','-')
        print('%s%s %s' % (' '*p.level(),sep,p.h))
.. @+node:ekr.20101118091038.5357: *5* p.children
The p.children generator returns a list of all children of position p::

    parent = p.parent()
    print("children of %s" % parent.h)
    for p in parent.children():
        print(p.h)
.. @+node:ekr.20101118091038.5358: *5* p.parents & p.self_and_parents
The p.parents generator returns a list of all parents of position p,
excluding p::

    current = p.copy()
    print("exclusive of %s" % (current.h),color="purple")
    for p in current.parents():
        print(p.h)

The p.self_and_parents generator returns a list of all parents of position
p, including p::

    current = p.copy()
    print("inclusive parents of %s" % (current.h),color="purple")
    for p in current.self_and_parents():
        print(p.h)    
.. @+node:ekr.20101118091038.5359: *5* p.siblings & p.following_siblings
The p.siblings generator returns a list of all siblings of position p::

    current = c.p
    print("all siblings of %s" % (current.h),color="purple")
    for p in current.self_and_siblings():
        print(p.h)

The p.following_siblings generator returns a list of all siblings that
follow position p::

    current = c.p
    print("following siblings of %s" % (current.h),color="purple")
    for p in current.following_siblings():
        print(p.h)
.. @+node:ekr.20101118091038.5360: *5* p.subtree & p.self_and_subtree
The p.subtree generator returns a list of all positions in p's subtree, excluding p::

    parent = p.parent()
    print("exclusive subtree of %s" % (parent.h),color="purple")
    for p in parent.subtree():
        print(p.h)

The p.self_and_subtree generator returns a list of all positions in p's subtree, including p::

    parent = p.parent()
    print("inclusive subtree of %s" % (parent.h),color="purple")
    for p in parent.self_and_subtree():
        print(p.h)
.. @+node:ekr.20101118091038.5361: *5* Testing whether a position is valid
The tests::

    if p:       # Right
    if not p:   # Right

are the **only** correct ways to test whether a position p is valid.
In particular, the following **will not work**::

    if p is None:       # Wrong
    if p is not None:   # Wrong
.. @+node:ekr.20101118091038.5387: *4* Creating script buttons
Creating a script button should be your first thought whenever you want to
automate any task. The scripting plugin, mod_scripting.py, puts two buttons
in the icon menu, a pink Run Script button and a yellow Script Button
button. The Run Script button does the same thing as the Execute Script
command. The Script Button button is the interesting one. It creates a
button, confusingly called a **script button** in the icon area. A script button
executes a script when you push it.

Suppose node N is selected. When you press the Script Button button a new
(pink) script button is created. The name of the new button is N's headline
text. The script associated with the new button is N's body text. Now whenever
you press the new button, N's script is executed on the **presently** selected
node. Script buttons are extraordinarily useful. In effect, each script button
defines an instant command! For example, sometimes my fingers get tired of
saving a file. I simply put Save in a node's headline and c.save() in
the body text. I hit the Script Button button and I get a new button called
Save that will save the outline when I press it.

Here's a more interesting example. The following script searches the present
node and its ancestors looking for an @rst node. When such a node is found the
script uses Leo's core c.rstCommands.processTree method to format it. I don't have
to select the actual \@rst node; I can select any of its children::

    for p in p.self_and_parents():
        if p.h.startswith('@rst '):
            c.rstCommands.processTree(p)
            break

**Notes**:

- The scripting plugin pre-defines the c, g and p symbols just as the Execute
  Script command does.

- By default a script button executes the **present** body text of the node that
  original created the script button. This is very handy: you can modify a
  script button's script at any time without having to recreate the script
  button.

- You can delete any script button by right-clicking on it.

- On startup, the scripting plugin scans the entire .leo file and creates a
  script button for every node whose headline starts with @button scriptName.
  **Warning**: this is indeed a security risk of the kind discussed later. This
  feature can be disabled by setting atButtonNodes = True at the start of
  mod_scripting.py.
.. @+node:ekr.20101118091038.5404: *4* Details
.. @+node:ekr.20101118091038.5353: *5* Ensuring that positions are valid
Positions become invalid whenever the outline changes. Plugins and scripts that
can make sure the position p is still valid by calling c.positionExists(p).

.. @+node:ekr.20101118091038.5354: *5* About copying positions
Scripts must wary of saving positions because positions become invalid
whenever the user moves, inserts or deletes nodes.  It is valid to store
positions **only** when a script knows that the stored position will be used
before the outline's structure changes.

To store a position, the script must use the p.copy() method::

    p2 = p.copy()   # Correct: p2 will not change when p changes later.

The following **will not work**::

    p2 = p  # Wrong.  p2 will change if p changes later.

For example, the following creates a dictionary of saved positions::

    d = {}
    for p in c.all_positions():
        d[p.v] = p.copy()

.. @+node:ekr.20101118091038.5363: *5* Invoking commands from scripts
Leo dispatches commands using c.doCommand,
which calls the "command1" and "command2" hook routines for the given label.
c.doCommand catches all exceptions thrown by the command::

    c.doCommand(c.markHeadline,label="markheadline")

You can also call command handlers directly so that hooks will not be called::

    c.markHeadline()

You can invoke minibuffer commands by name.  For example::

    c.executeMinibufferCommand('open-outline')

c.keyHandler.funcReturn contains the value returned from the command.
In many cases, as above, this value is simply 'break'.
.. @+node:ekr.20101118091038.5364: *5* Getting settings from @settings trees
Any .leo file may contain an @settings tree, so settings may be different for each commander.
Plugins and other scripts can get the value of settings as follows::

    format_headlines = c.config.getBool('rst3_format_headlines')
    print('format_headlines',format_headlines)

The c.config class has the following getters.
See the configSettings in leoCommands.py for details::

    c.config.getBool(settingName,default=None)
    c.config.getColor(settingName)
    c.config.getDirectory(settingName)
    c.config.getFloat(settingName)
    c.config.getInt(settingName)
    c.config.getLanguage(settingName)
    c.config.getRatio(settingName)
    c.config.getShortcut(settingName)
    c.config.getString(settingName)

These methods return None if no setting exists.
The getBool 'default' argument to getBool gives the value to be returned if the setting does not exist.

You can set any *existing* item in an @settings tree with c.config.set(p,setting,val).
For example::

    for val in (False,True):
        c.config.set(p,'rst3_format_headlines',val)
        format_headlines = c.config.getBool('rst3_format_headlines')
        print('format_headlines',format_headlines)

c.config.set does not change the @settings tree; it simply changes the values returned by the getters.
.. @+node:ekr.20101118091038.5365: *5* Getting and setting preferences
Each commander maintains its own preferences.
Your scripts can get the following ivars::

    ivars = (
        'output_doc_flag',
        'page_width',
        'page_width',
        'tab_width',
        'target_language',
        'use_header_flag',
    )

    print("Prefs ivars...\n",color="purple")
    for ivar in ivars:
        print(getattr(c,ivar))

If your script sets c.tab_width your script may call f.setTabWidth to redraw the screen::

    c.tab_width = -4    # Change this and see what happens.
    c.frame.setTabWidth(c.tab_width)
.. @+node:ekr.20101118091038.5366: *5* Functions for finding and changing text from scripts
The file leoFindScript.py contains functions for finding and changing text
from within scripts.  See leoFindScript.py in LeoPy.leo for full details.

The findall function returns a list of tuples (v,pos) describing matches in
c's entire tree::

    import leo.scripts.leoFindScript as leoFindScript

    pattern="import leo.core.leoGlobals as g"
    result = leoFindScript.findAll(c,pattern,bodyFlag=1)

    print("%-3d instances of: '%s'...\n" % (len(result),pattern),color="purple")

    for v,pos in result:
        body = v.b
        print('\n%-4d %s' % (pos,v.h))
        print(g.get_line_after(body,pos))

The reFindall function returns a list of tuples (v,mo,pos), where mo
is a MatchObject. The reFlags argument are flags to re.search::

    import leo.scripts.leoFindScript as leoFindScript

    pattern="from .* import"
    result = leoFindScript.reFindAll(c,pattern,bodyFlag=1,reFlags=None)

    print("%-3d instances of: '%s'...\n" % (len(result),pattern),color="purple")
    for v,mo,pos in result:
        body = v.b
        print('\n%-4d %s' % (pos,v.h))
        print(g.get_line_after(body,pos))
.. @+node:ekr.20101118091038.5367: *5* Functions defined in leoGlobals.py
leoGlobals.py contains many utility functions and constants.
The following script prints all the names defined in leoGlobals.py::

    print("Names defined in leoGlobals.py",color="purple")
    names = g.__dict__.keys()
    names.sort()
    for name in names:
        print(name)
.. @+node:ekr.20101118091038.5368: *5* Event handlers
Plugins and other scripts can register event handlers (also known as hooks) with code such as::

    leoPlugins.registerHandler("after-create-leo-frame",onCreate)
    leoPlugins.registerHandler("idle", on_idle) 
    leoPlugins.registerHandler(("start2","open2","command2"), create_open_with_menu) 

As shown above, a plugin may register one or more event handlers with a single call to
leoPlugins.registerHandler. Once a hook is registered, Leo will call the
registered function' at the named **hook time**. For example::

    leoPlugins.registerHandler("idle", on_idle)

causes Leo to call on_idle at "idle" time.

Event handlers must have the following signature::

    def myHook (tag, keywords):
        whatever

-   tag is the name of the hook (a string).
-   keywords is a Python dictionary containing additional information.
    The following section describes the contents of the keywords dictionary in detail.

**Important**: hooks should get the proper commander this way::

    c = keywords.get('c')
.. @+node:ekr.20101118091038.5369: *6* @rst-no-head Summary of event handlers
The following table tells about each event handler: its name, when it is called,
and the additional arguments passed to the hook in the keywords dictionary.
For some kind of hooks, Leo will skip its own normal processing if the hook
returns anything *other* than None. The table indicates such hooks with 'yes' in
the 'Stop?' column.

**Important**: Ever since Leo 4.2, the v, old_v and new_v keys in
the keyword dictionary contain *positions*, not vnodes. These keys are
deprecated. The new_c key is also deprecated. Plugins should use the c key instead.

============================= ======== =================================== =============================
Event name (tag argument)     Stop?    When called                         Keys in keywords dict
============================= ======== =================================== =============================
'after-auto'                           after each @auto file loaded        c,p (note 13)
'after-create-leo-frame'               after creating any frame            c
'after-redraw-outline'                 end of tree.redraw                  c (note 6)
'before-create-leo-frame'              before frame.finishCreate           c
'bodyclick1'                   yes     before normal click in body         c,p,v,event
'bodyclick2'                           after normal click in body          c,p,v,event
'bodydclick1'                  yes     before double click in body         c,p,v,event
'bodydclick2'                          after  double click in body         c,p,v,event
'bodykey1'                     yes     before body keystrokes              c,p,v,ch,oldSel,undoType
'bodykey2'                             after  body keystrokes              c,p,v,ch,oldSel,undoType
'bodyrclick1'                  yes     before right click in body          c,p,v,event
'bodyrclick2'                          after  right click in body          c,p,v,event
'boxclick1'                    yes     before click in +- box              c,p,v,event
'boxclick2'                            after  click in +- box              c,p,v,event
'clear-all-marks'                      after clear-all-marks command       c,p,v
'clear-mark'                           when mark is set                    c,p,v
'close-frame'                          in app.closeLeoWindow               c
'color-optional-markup'        yes *   (note 7)                            colorer,p,v,s,i,j,colortag (note 7)
'command1'                     yes     before each command                 c,p,v,label (note 2)
'command2'                             after  each command                 c,p,v,label (note 2)
'create-optional-menus'                (note 8)                            c (note 8)
'create-popup-menu-items'              in tree.OnPopup                     c,p,v,event (new)
'draw-outline-box'             yes     when drawing +- box                 tree,p,v,x,y
'draw-outline-icon'            yes     when drawing icon                   tree,p,v,x,y
'draw-outline-node'            yes     when drawing node                   tree,p,v,x,y
'draw-outline-text-box'        yes     when drawing headline               tree,p,v,x,y
'drag1'                        yes     before start of drag                c,p,v,event
'drag2'                                after  start of drag                c,p,v,event
'dragging1'                    yes     before continuing to drag           c,p,v,event
'dragging2'                            after  continuing to drag           c,p,v,event
'enable-popup-menu-items'              in tree.OnPopup                     c,p,v,event
'end1'                                 start of app.quit()                 None
'enddrag1'                     yes     before end of drag                  c,p,v,event
'enddrag2'                             after  end of drag                  c,p,v,event
'headclick1'                   yes     before normal click in headline     c,p,v,event
'headclick2'                           after  normal click in headline     c,p,v,event
'headrclick1'                  yes     before right click in headline      c,p,v,event
'headrclick2'                          after  right click in headline      c,p,v,event
'headkey1'                     yes     before headline keystrokes          c,p,v,ch (note 12)
'headkey2'                             after  headline keystrokes          c,p,v,ch (note 12)
'hoist-changed'                        whenever the hoist stack changes    c
'hypercclick1'                 yes     before control click in hyperlink   c,p,v,event
'hypercclick2'                         after  control click in hyperlink   c,p,v,event
'hyperenter1'                  yes     before entering hyperlink           c,p,v,event
'hyperenter2'                          after  entering hyperlink           c,p,v,event
'hyperleave1'                  yes     before leaving  hyperlink           c,p,v,event
'hyperleave2'                          after  leaving  hyperlink           c,p,v,event
'iconclick1'                   yes     before single click in icon box     c,p,v,event
'iconclick2'                           after  single click in icon box     c,p,v,event
'iconrclick1'                  yes     before right click in icon box      c,p,v,event
'iconrclick2'                          after  right click in icon box      c,p,v,event
'icondclick1'                  yes     before double click in icon box     c,p,v,event
'icondclick2'                          after  double click in icon box     c,p,v,event
'idle'                                 periodically (at idle time)         c
'init-color-markup'                    (note 7)                            colorer,p,v (note 7)
'menu1'                        yes     before creating menus               c,p,v (note 3)
'menu2'                        yes     during creating menus               c,p,v (note 3)
'menu-update'                  yes     before updating menus               c,p,v
'new'                                  start of New command                c,old_c,new_c (note 9)
'open1'                        yes     before opening any file             c,old_c,new_c,fileName (note 4)
'open2'                                after  opening any file             c,old_c,new_c,fileName (note 4)
'openwith1'                    yes     before Open With command            c,p,v,openType,arg,ext
'openwith2'                            after  Open With command            c,p,v,openType,arg,ext
'recentfiles1'                 yes     before Recent Files command         c,p,v,fileName,closeFlag
'recentfiles2'                         after  Recent Files command         c,p,v,fileName,closeFlag
'redraw-entire-outline'        yes     start of tree.redraw                c (note 6)
'save1'                        yes     before any Save command             c,p,v,fileName
'save2'                                after  any Save command             c,p,v,fileName
'scan-directives'                      in scanDirectives                   c,p,v,s,old_dict,dict,pluginsList (note 10)
'select1'                      yes     before selecting a position         c,new_p,old_p,new_v,new_v
'select2'                              after  selecting a position         c,new_p,old_p,new_v,old_v
'select3'                              after  selecting a position         c,new_p,old_p,new_v,old_v
'set-mark'                             when a mark is set                  c,p,v
'show-popup-menu'                      in tree.OnPopup                     c,p,v,event
'start1'                               after app.finishCreate()            None
'start2'                               after opening first Leo window      c,p,v,fileName
'unselect1'                    yes     before unselecting a vnode          c,new_p,old_p,new_v,old_v
'unselect2'                            after  unselecting a vnode          c,new_p,old_p,old_v,old_v
'\@url1'                        yes     before double-click @url node       c,p,v,url (note 5)
'\@url2'                                after  double-click @url node       c,p,v(note 5)
============================= ======== =================================== =============================

**Notes**:

1.  'activate' and 'deactivate' hooks have been removed because they do not work as expected.

2.  'commands' hooks: The label entry in the keywords dict contains the
    'canonicalized' form of the command, that is, the lowercase name of the command
    with all non-alphabetic characters removed.
    Commands hooks now set the label for undo and redo commands 'undo' and 'redo'
    rather than 'cantundo' and 'cantredo'.

3.  'menu1' hook: Setting g.app.realMenuNameDict in this hook is an easy way of
    translating menu names to other languages. **Note**: the 'new' names created this
    way affect only the actual spelling of the menu items, they do *not* affect how
    you specify shortcuts settings, nor do they affect the 'official'
    command names passed in g.app.commandName. For example::

        app().realMenuNameDict['Open...'] = 'Ouvre'.

4.  'open1' and 'open2' hooks: These are called with a keywords dict containing the following entries:

    - c:          The commander of the newly opened window.
    - old_c:      The commander of the previously open window.
    - new_c:      (deprecated: use 'c' instead) The commander of the newly opened window.
    - fileName:   The name of the file being opened.

    You can use old_c.p and c.p to get the current position in the old and new windows.
    Leo calls the 'open1' and 'open2' hooks only if the file is not already open. Leo
    will also call the 'open1' and 'open2' hooks if: a) a file is opened using the
    Recent Files menu and b) the file is not already open.

5.  '\@url1' and '\@url2' hooks are only executed if the 'icondclick1' hook returns None.

6.  These hooks are useful for testing.

7.  These hooks allow plugins to parse and handle markup within doc parts,
    comments and Python ''' strings. Note that these hooks are *not* called in
    Python ''' strings. See the color_markup plugin for a complete example of how to
    use these hooks.

8.  Leo calls the 'create-optional-menus' hook when creating menus. This hook need
    only create new menus in the correct order, without worrying about the placement
    of the menus in the menu bar. See the plugins_menu and scripts_menu plugins for
    examples of how to use this hook.

9.  The New command calls 'new'.
    The 'new_c' key is deprecated.  Use the 'c' key instead.

10. g.scanDirectives calls 'scan-directives' hook.
    g.scanDirectives returns a dictionary, say d.
    d.get('pluginsList') is an a list of tuples (d,v,s,k) where:

    - d is the spelling of the @directive, without the leading @.
    - v is the vnode containing the directive, _not_ the original vnode.
    - s[k:] is a string containing whatever follows the @directive.
      k has already been moved past any whitespace that follows the @directive.

    See the add_directives plugins directive for a complete example of how to use
    the 'scan-directives' hook.

11. g.app.closeLeoWindow calls the 'close-frame' hook just before
    removing the window from g.app.windowList. The hook code may remove the window
    from app.windowList to prevent g.app.closeLeoWindow from destroying the window.

12. Leo calls the 'headkey1' and 'headkey2' when the headline *might* have changed.

13. p is the new node (position) containing '@auto filename.ext'
.. @+node:ekr.20101118091038.5370: *6* Enabling idle time event handlers
Two methods in leoGlobals.py allow scripts and plugins to enable and disable 'idle' events.
**g.enableIdleTimeHook(idleTimeDelay=100)** enables the "idle" hook.
Afterwards, Leo will call the "idle" hook approximately every idleTimeDelay milliseconds.
Leo will continue to call the "idle" hook periodically until disableIdleTimeHook is called.
**g.disableIdleTimeHook()** disables the "idle" hook.
.. @+node:ekr.20101118091038.5371: *5* How to make operations undoable
Plugins and scripts should call u.beforeX and u.afterX methods ato
describe the operation that is being performed. **Note**: u is shorthand for
c.undoer. Most u.beforeX methods return undoData that the client
code merely passes to the corresponding u.afterX method. This data contains
the 'before' snapshot. The u.afterX methods then create a bead containing
both the 'before' and 'after' snapshots.

u.beforeChangeGroup and u.afterChangeGroup allow multiple calls to
u.beforeX and u.afterX methods to be treated as a single undoable entry.
See the code for the Change All, Sort, Promote and Demote
commands for examples. The u.beforeChangeGroup and u.afterChangeGroup
methods substantially reduce the number of u.beforeX and afterX methods
needed.

Plugins and scripts may define their own u.beforeX and afterX methods. Indeed,
u.afterX merely needs to set the bunch.undoHelper and
bunch.redoHelper ivars to the methods used to undo and redo the operation.
See the code for the various u.beforeX and afterX methods for guidance.

p.setDirty and p.setAllAncestorAtFileNodesDirty now return a
dirtyVnodeList that all vnodes that became dirty as the result of an
operation. More than one list may be generated: client code is responsible for
merging lists using the pattern dirtyVnodeList.extend(dirtyVnodeList2)

See the section << How Leo implements unlimited undo >> in leoUndo.py
for more details. In general, the best way to see how to implement undo is to
see how Leo's core calls the u.beforeX and afterX methods.
.. @+node:ekr.20101118091038.5372: *5* Redirecting output from scripts
leoGlobals.py defines 6 convenience methods for redirecting stdout and stderr::

    g.redirectStderr() # Redirect stderr to the current log pane.
    g.redirectStdout() # Redirect stdout to the current log pane.
    g.restoreStderr()  # Restores stderr so it prints to the console window.
    g.restoreStdout()  # Restores stdout so it prints to the console window.
    g.stdErrIsRedirected() # Returns True if the stderr stream is redirected to the log pane.
    g.stdOutIsRedirected() # Returns True if the stdout stream is redirected to the log pane.

Calls need *not* be paired. Redundant calls are ignored and the last call made
controls where output for each stream goes.
**Note**: you must execute Leo in a console window to see non-redirected output from the print statement::

    print("stdout isRedirected: %s" % g.stdOutIsRedirected())
    print("stderr isRedirected: %s" % g.stdErrIsRedirected())

    g.redirectStderr()
    print("stdout isRedirected: %s" % g.stdOutIsRedirected())
    print("stderr isRedirected: %s" % g.stdErrIsRedirected())

    g.redirectStdout()
    print("stdout isRedirected: %s" % g.stdOutIsRedirected())
    print("stderr isRedirected: %s" % g.stdErrIsRedirected())

    g.restoreStderr()
    print("stdout isRedirected: %s" % g.stdOutIsRedirected())
    print("stderr isRedirected: %s" % g.stdErrIsRedirected())

    g.restoreStdout()
    print("stdout isRedirected: %s" % g.stdOutIsRedirected())
    print("stderr isRedirected: %s" % g.stdErrIsRedirected())
.. @+node:ekr.20101118091038.5373: *5* Writing to different log tabs
Plugins and scripts can create new tabs in the log panel.
The following creates a tab named test or make it visible if it already exists::

    c.frame.log.selectTab('Test')

g.es, g.enl, g.ecnl, g.ecnls write to the log tab specified by the optional
tabName argument. The default for tabName is 'Log'. The put and putnl methods of
the tkinterLog class also take an optional tabName argument which defaults to
'Log'.

Plugins and scripts may call the
c.frame.canvas.createCanvas method to create a log tab containing a Tk.Canvas
widget. Here is an example script::

    log = c.frame.log ; tag = 'my-canvas'
    w = log.canvasDict.get(tag)
    if not w:
        w = log.createCanvas(tag)
        w.configure(bg='yellow')
    log.selectTab(tag)
.. @+node:ekr.20101118091038.5374: *5* Invoking dialogs using the g.app.gui class
Scripts can invoke various dialogs using the following methods of the g.app.gui object.
Here is a partial list. You can use typing completion(default bindings: Alt-1 and Alt-2) to get the full list!
::

    g.app.gui.runAskOkCancelNumberDialog(c,title,message)
    g.app.gui.runAskOkCancelStringDialog(c,title,message)
    g.app.gui.runAskOkDialog(c,title,message=None,text='Ok')
    g.app.gui.runAskYesNoCancelDialog(c,title,message=None,
        yesMessage='Yes',noMessage='No',defaultButton='Yes')
    g.app.gui.runAskYesNoDialog(c,title,message=None)

The values returned are in ('ok','yes','no','cancel'), as indicated by the
method names. Some dialogs also return strings or numbers, again as indicated by
their names.

Scripts can run File Open and Save dialogs with these methods::

    g.app.gui.runOpenFileDialog(title,filetypes,defaultextension,multiple=False)
    g.app.gui.runSaveFileDialog(initialfile,title,filetypes,defaultextension)

For details about how to use these file dialogs, look for examples in Leo's own
source code. The runOpenFileDialog returns a list of file names.
.. @+node:ekr.20101118091038.5375: *5* Inserting and deleting icons
You can add an icon to the presently selected node with
c.editCommands.insertIconFromFile(path). path is an absolute path or a path
relative to the leo/Icons folder. A relative path is recommended if you plan to
use the icons on machines with different directory structures.

For example::

    path = 'rt_arrow_disabled.gif' 
    c.editCommands.insertIconFromFile(path) 

Scripts can delete icons from the presently selected node using the following methods::

    c.editCommands.deleteFirstIcon() 
    c.editCommands.deleteLastIcon() 
    c.editCommands.deleteNodeIcons() 
.. @+node:ekr.20101118091038.5376: *5* Customizing panes with different widgets
Tk/Tkinter make it easy to customize the contents of any of Leo's panes. The
following sections will discuss the 'official' ivars that make it possible for
scripts to access and alter the contents of panes. The next three sections will
give examples of modifying each pane.
.. @+node:ekr.20101118091038.5377: *6* Official ivars
The c.frame.log class contains the following 'official' ivars::

    g.es('tabName',c.frame.log.tabName)     # The name of the active tab.
    g.es('tabFrame',c.frame.log.tabFrame)   # The Tk.Frame containing all the other widgets of the tab.
    g.es('logCtrl',c.frame.log.logCtrl)     # Tk.Text widget containing the log text.

The following ivars provide access to the body pane::

    g.es('bodyFrame',c.frame.body.frame)    # The Tk.Frame widget containing the c.frame.body.bodyCtrl

The following ivars provide access to the outline pane::

    g.es('canvas',c.frame.tree.canvas) # The Tk.Canvas on which Leo's outline is drawn.

Tkinter provides a way of determining the enclosing widget of any widget.
The body text is enclosed in a Pmw.PanedWidget to support multiple editors.

    w = c.frame.body.bodyCtrl
    parent = w.pack_info().get('in') 
    g.es('bodyCtrl.parent',parent) # The Tk.Frame containing the body text.
.. @+node:ekr.20101118091038.5378: *6* Common operations on Tk.Text widgets
The following is no substitute for a full discussion of programming the Tk.Text
widget: it can do lots.

To clear the log::

    w = c.frame.log.logCtrl
    w.delete('1.0','end')

To write a line to the end of the log::

    w = c.frame.log.logCtrl
    w.insert('end','This is a test\n')

To get the entire contents of the log::

    w = c.frame.log.logCtrl
    g.es(w.get('1.0','end')+'\n')
.. @+node:ekr.20101118091038.5379: *6* Customizing the log pane
The following line removes the initial text widget::

    c.frame.log.logCtrl.pack_forget()

To make the text widget visible again::

    c.frame.log.logCtrl.pack(side='top',expand=1,fill='both')

Plugins and scripts can pack any other widgets into c.frame.log.tabFrame.
For example, the following replaces the default text widget with a red box::

    import Tkinter as Tk

    # Remove the old contents.
    w = c.frame.log.logCtrl
    parent =  w.pack_info().get('in')
    w.pack_forget()

    # Replace with a red frame.
    f = c.frame.newLog = Tk.Frame(parent,background='red')
    f.pack(side='left',expand=1,fill='both')

And the following will restore the original pane::

    c.frame.newLog.pack_forget()
    w = c.frame.log.logCtrl
    w.pack(side='left',expand=1,fill='both')
.. @+node:ekr.20101118091038.5380: *6* Customizing the body pane
Warning: you will find it hard to execute scripts after removing the body pane,
so you had best make the following two scripts into script buttons before
executing them :-)

Plugins and scripts can pack any other widgets into c.frame.log.tabFrame.
For example, the following replaces the default text widget with a red box::

    import Tkinter as Tk

    w = c.frame.body.bodyCtrl
    parent =  w.pack_info().get('in')
    w.pack_forget()

    f = c.frame.newBody = Tk.Frame(parent,background='red')
    f.pack(side='left',expand=1,fill='both')

To restore::

    c.frame.newBody.pack_forget()
    w = c.frame.body.bodyCtrl
    w.pack(side='left',expand=1,fill='both')
.. @+node:ekr.20101118091038.5381: *6* Customizing the outine pane
The following replaces the outline pane with a red frame::

    import Tkinter as Tk

    w = c.frame.tree.canvas
    parent =  w.pack_info().get('in')
    w.pack_forget()

    f = c.frame.newTree = Tk.Frame(parent,background='red')
    f.pack(side='left',expand=1,fill='both')

And this script restores the outline::

    c.frame.newTree.pack_forget()
    c.frame.tree.canvas.pack(side='left',expand=1,fill='both')
.. @+node:ekr.20101118091038.5382: *5* Working with directives and paths
Scripts can easily determine what directives are in effect at a particular
position in an outline. c.scanAllDirectives(p) returns a Python dictionary whose
keys are directive names and whose values are the value in effect at position p.
For example::

    d = c.scanAllDirectives(p)
    g.es(g.dictToString(d))

In particular, d.get('path') returns the full, absolute path created by all
\@path directives that are in ancestors of node p. If p is any kind of @file node
(including @file, @auto, @nosent, @shadow, etc.), the following script will
print the full path to the created file::

    path = d.get('path')
    name = p.anyAtFileNodeName()
    if name:
       name = g.os_path_finalize_join(path,name)
       g.es(name)
.. @+node:ekr.20101118091038.5383: *5* Summary of the vnode and position classes
Most scripts will use methods of the position class to access information in an
outline. The following sections summarizes the most useful methods that your
scripts can use. For a complete list, see the leoNodes.py in of LeoPy.leo.
.. @+node:ekr.20101118091038.5384: *6* generators
Here is the list of Leo's generators::

    c.all_nodes             # all vnodes in c.
    c.all_unique_nodes      # all unique vnodes in c.
    c.all_positions         # all positions in c.
    c.all_unique_positions  # all unique positions in c.

    p.children              # all children of p.
    p.following_siblings    # all siblings of p that follow p.
    p.nodes                 # all vnodes in p's subtree.
    p.parents               # all parents of p.
    p.self_and_parents      # p and all parents of p.
    p.siblings              # all siblings of p, including p.
    p.subtree               # all positions in p's subtree, excluding p.
    p.self_and_subtree      # all positions in p's subtree, including p.
    p.unique_nodes          # all unique vnodes in p's subtree.
    p.unique_subtree        # all unique positions in p's subtree.

**Note**: A generator that returns **unique positions** is a generator that returns
a list of positions such that p.v == v at most once for any vnode v.
Similarly, a generator that returns **unique nodes** is a generator that returns
a list that contains any vnode at most once.

**Note**: The names given above are the recommended names for Leo's generators.
Leo continues to support the names of iterators used before Leo 4.7.
These names typically end with the _iter suffix.
.. @+node:ekr.20101118091038.5385: *6* Getters
Here are the most useful getters of the vnode and position classes.

Returning strings::

    p.b # the body string of p.
    p.h # the headline string of p. A property.

Returning ints::

    p.childIndex()
    p.numberOfChildren()
    p.level()

Returning bools representing property bits::

    p.hasChildren()
    p.isAncestorOf(v2) # True if v2 is a child, grandchild, etc. of p.
    p.isCloned()
    p.isDirty()
    p.isExpanded()
    p.isMarked()
    p.isVisible()
    p.isVisited()
.. @+node:ekr.20101118091038.5386: *6* Setters
Here are the most useful setters of the Commands and position classes.
The following setters of the position class regardless of whether
p is the presently selected position::

    c.setBodyString(p,s)  # Sets the body text of p.
    c.setHeadString(p,s)  # Sets the headline text of p.

Moving nodes::

    p.moveAfter(v2)           # move p after v2
    p.moveToNthChildOf(v2,n)  # move p to the n'th child of v2
    p.moveToRoot(oldRoot)     # make p the root position.
                              # oldRoot must be the old root position if it exists.

The "visited" bit may be used by commands or scripts for any purpose.
Many commands use this bits for tree traversal, so these bits do not persist::

    c.clearAllVisited() # Clears all visited bits in c's tree.
    p.clearVisited()
    p.setVisited()
.. @+node:ekr.20101116103056.5272: *3* Using the minibuffer
@nocolor-node

>> You can use the print-commands command.

> How can I run this command? Do I use the minibuffer?

Yes. Type <alt-x> to put the cursor in the minibuffer. Then use tab
completion to avoid having to do much typing. Something like this:

Type "pr<tab>". This will show open the completion pane. The pane shows you all
the commands that start with pr. There are too many, so type i<tab>. Now you
will see "print-" in the minibuffer and only commands that start with "print-"
in the completion tab. Now just type "c<tab>" and you will see the full
print-commands command in the minibuffer. Finally, type <return> to execute the
command.

*Important*: you can use <backspace> in the minibuffer to show more alternatives,
and you can hit <ctrl-g> at any time in Leo to put focus in the body pane.
.. @+node:ekr.20101116152804.5285: *3* Nutshell
@nocolor-node

The experience of using Leo is quite a bit different from using other editors or
IDE's.

- The unit of work is different: I work with nodes, not files or text.
- The workflow is different: I create clones rather than searching.
- Scripts are much more important: it's easy to manipulate code because less parsing is needed.
.. @+node:ekr.20101025080245.5540: ** To do: slideshows
@nocolor-node

- Make sure to upload all slides.

Later:

- Create slides_toc for slides, separate from the main toc document.

- Eliminate Sphinx warnings:
    Can probably be done by changing the slides page.
.. @+node:ekr.20101115152915.4928: *3*  Unused
.. @+node:ekr.20101013072903.5218: *4* Not good stories
.. @+node:ekr.20101007082321.4357: *5* @slideshow What is Leo? (Joe Orr)
@language rest
.. @+node:ekr.20101009171445.4637: *6* @title_pattern = What is Leo? Slide %(slide_number)s
.. @+node:ekr.20101008061729.4372: *6* @slide 001
Leo is a unique, powerful computer program that you can use to **organize**,
**analyze** and **describe** text and text files. Leo is a free and open
software written by Edward K. Ream. For information about downloading Leo, see
the **installation** tutorial in this series. Leo runs on Windows, Mac, or
Linux.

Use Leo:

- To brainstorm a new project.
- As a Personal Information Manager.
- To add multiple outlines and commentary to any text file.
- To create and organize computer programs.
- To apply computer scripts to any kind of data.

Because Leo is unlike other tools you may have used, a series of examples may be
the best way to demonstrate what can be done with Leo.
.. @+node:ekr.20101010121134.4703: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-001.html
.. @+node:ekr.20101008061729.4373: *6* @slide 002
From one perspective, Leo is an **outlining editor**. This is a screenshot of
Leo. The arrow shows the outline pane. (A later tutorial explains how to create
an outline like the one in the screenshot).

.. image:: slide-002.png

.. @+node:ekr.20101008061729.4384: *7* @screenshot
.. @+node:ekr.20101008061729.4385: *8* To Do List
.. @+node:ekr.20101008061729.4386: *9* Urgent
.. @+node:ekr.20101008061729.4387: *9* Important
.. @+node:ekr.20101008061729.4388: *9* Soon
.. @+node:ekr.20101008061729.4389: *9* Whenever
.. @+node:ekr.20101008061729.4390: *8* Diary
.. @+node:ekr.20101008061729.4391: *9* 2009
.. @+node:ekr.20101008061729.4392: *10* Jan 1
.. @+node:ekr.20101008061729.4393: *9* 2010
.. @+node:ekr.20101008061729.4396: *7* @select To Do List
.. @+node:ekr.20101010121134.4704: *7* @edit
.. @+node:ekr.20101010121134.4716: *7* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-002.png
.. @+node:ekr.20101010121134.4717: *7* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-002.svg
.. @+node:ekr.20101010121134.4718: *7* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-002.png
.. @+node:ekr.20101010121134.4719: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-002.html
.. @+node:ekr.20101008061729.4398: *6* @slide 003
Clicking on the open triangle will open the indicated node.

.. image:: slide-003.png

.. @+node:ekr.20101009115705.4583: *7* @screenshot
.. @+node:ekr.20101009115705.4584: *8* To Do List
My to-do list.
.. @+node:ekr.20101009115705.4585: *9* Urgent
.. @+node:ekr.20101009115705.4586: *9* Important
.. @+node:ekr.20101009115705.4587: *9* Soon
.. @+node:ekr.20101009115705.4588: *9* Whenever
.. @+node:ekr.20101009115705.4589: *8* Diary
.. @+node:ekr.20101009115705.4590: *9* 2009
.. @+node:ekr.20101009115705.4591: *10* Jan 1
.. @+node:ekr.20101009115705.4592: *9* 2010
.. @+node:ekr.20101008061729.4420: *7* @select 2009
.. @+node:ekr.20101010121134.4731: *7* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-003.png
.. @+node:ekr.20101010121134.4732: *7* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-003.svg
.. @+node:ekr.20101010121134.4746: *7* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-003.png
.. @+node:ekr.20101010121134.4747: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-003.html
.. @+node:ekr.20101008061729.4522: *6* @slide 004
Here the node has been opened. Clicking on the box again will close the node.

.. image:: slide-004.png

.. @+node:ekr.20101009124842.4595: *7* @screenshot
.. @+node:ekr.20101009124842.4596: *8* To Do List
@nocolor-node

My to-do list.
.. @+node:ekr.20101009124842.4597: *9* Urgent
.. @+node:ekr.20101009124842.4598: *9* Important
.. @+node:ekr.20101009124842.4599: *9* Soon
.. @+node:ekr.20101009124842.4600: *9* Whenever
.. @+node:ekr.20101009124842.4601: *8* Diary
@nocolor-node

.. @+node:ekr.20101009124842.4602: *9* 2009
.. @+node:ekr.20101009124842.4603: *10* Aug
.. @+node:ekr.20101009211009.4624: *10* Jul
.. @+node:ekr.20101009211009.4623: *10* Jun
.. @+node:ekr.20101009211009.4625: *10* May
.. @+node:ekr.20101009211009.4626: *10* Apr
.. @+node:ekr.20101009211009.4627: *10* Mar
.. @+node:ekr.20101009211009.4628: *10* Feb
.. @+node:ekr.20101009211009.4629: *10* Jan
.. @+node:ekr.20101009124842.4604: *9* 2010
.. @+node:ekr.20101009124842.4606: *7* @select 2009
.. @+node:ekr.20101009124842.4607: *7* @edit
.. @+node:ekr.20101010121134.4766: *7* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-004.png
.. @+node:ekr.20101010121134.4767: *7* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-004.svg
.. @+node:ekr.20101010121134.4768: *7* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-004.png
.. @+node:ekr.20101010121134.4769: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-004.html
.. @+node:ekr.20101008061729.4518: *6* @slide 005
Here the indicated node has been closed.

.. image:: slide-005.png

.. @+node:ekr.20101009212539.4682: *7* @screenshot
.. @+node:ekr.20101009212539.4683: *8* To Do List
My to-do list.
.. @+node:ekr.20101009212539.4684: *9* Urgent
.. @+node:ekr.20101009212539.4685: *9* Important
.. @+node:ekr.20101009212539.4686: *9* Soon
.. @+node:ekr.20101009212539.4687: *9* Whenever
.. @+node:ekr.20101009212539.4688: *8* Diary
.. @+node:ekr.20101009212539.4689: *9* 2009
.. @+node:ekr.20101009212539.4690: *10* Aug
.. @+node:ekr.20101009212539.4691: *10* Jul
.. @+node:ekr.20101009212539.4692: *10* Jun
.. @+node:ekr.20101009212539.4693: *10* May
.. @+node:ekr.20101009212539.4694: *10* Apr
.. @+node:ekr.20101009212539.4695: *10* Mar
.. @+node:ekr.20101009212539.4696: *10* Feb
.. @+node:ekr.20101009212539.4697: *10* Jan
.. @+node:ekr.20101009212539.4698: *9* 2010
.. @+node:ekr.20101009212539.4746: *7* @select 2009
.. @+node:ekr.20101009212539.4699: *7* @edit
.. @+node:ekr.20101009213545.4670: *7* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-005.png
.. @+node:ekr.20101009213545.4671: *7* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-005.svg
.. @+node:ekr.20101009213545.4672: *7* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-005.png
.. @+node:ekr.20101010121134.4814: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-005.html
.. @+node:ekr.20101008061729.4521: *6* @slide 006
Clicking on a node headline (1) will show the text for that node in the body
pane (2) below. The body pane is a text editor--you can enter, delete or change
text here by typing it in.

.. image:: slide-006.png

.. @+node:ekr.20101009213545.4692: *7* @screenshot
.. @+node:ekr.20101009213545.4693: *8* To Do List
@nocolor

My to-do list.
.. @+node:ekr.20101009213545.4694: *9* Urgent
1. Make Leo tutorials.  The world is waiting.

2. Pay phone bill or the world will never know.
.. @+node:ekr.20101009213545.4695: *9* Important
.. @+node:ekr.20101009213545.4696: *9* Soon
.. @+node:ekr.20101009213545.4697: *9* Whenever
.. @+node:ekr.20101009213545.4698: *8* Diary
@nocolor
.. @+node:ekr.20101009213545.4699: *9* 2009
.. @+node:ekr.20101009213545.4700: *10* Aug
.. @+node:ekr.20101009213545.4701: *10* Jul
.. @+node:ekr.20101009213545.4702: *10* Jun
.. @+node:ekr.20101009213545.4703: *10* May
.. @+node:ekr.20101009213545.4704: *10* Apr
.. @+node:ekr.20101009213545.4705: *10* Mar
.. @+node:ekr.20101009213545.4706: *10* Feb
.. @+node:ekr.20101009213545.4707: *10* Jan
.. @+node:ekr.20101009213545.4708: *9* 2010
.. @+node:ekr.20101009213545.4709: *7* @edit
.. @+node:ekr.20101009213545.4710: *7* @select Urgent
.. @+node:ekr.20101010121134.4810: *7* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-006.png
.. @+node:ekr.20101010121134.4811: *7* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-006.svg
.. @+node:ekr.20101010121134.4812: *7* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-006.png
.. @+node:ekr.20101010121134.4813: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-006.html
.. @+node:ekr.20101008061729.4523: *6* @slide 007
You can save the outline in a .leo file.  Click File:Save (or Ctrl-S).

.. image:: slide-007.png

.. @+node:ekr.20101010121134.4832: *7* @screenshot
.. @+node:ekr.20101010121134.4833: *8* To Do List
@nocolor

My to-do list.
.. @+node:ekr.20101010121134.4834: *9* Urgent
1. Make Leo tutorials.  The world is waiting.

2. Pay phone bill or the world will never know.
.. @+node:ekr.20101010121134.4835: *9* Important
.. @+node:ekr.20101010121134.4836: *9* Soon
.. @+node:ekr.20101010121134.4837: *9* Whenever
.. @+node:ekr.20101010121134.4838: *8* Diary
@nocolor
.. @+node:ekr.20101010121134.4839: *9* 2009
.. @+node:ekr.20101010121134.4840: *10* Aug
.. @+node:ekr.20101010121134.4841: *10* Jul
.. @+node:ekr.20101010121134.4842: *10* Jun
.. @+node:ekr.20101010121134.4843: *10* May
.. @+node:ekr.20101010121134.4844: *10* Apr
.. @+node:ekr.20101010121134.4845: *10* Mar
.. @+node:ekr.20101010121134.4846: *10* Feb
.. @+node:ekr.20101010121134.4847: *10* Jan
.. @+node:ekr.20101010121134.4848: *9* 2010
.. @+node:ekr.20101010141334.4791: *7* @select Urgent
.. @+node:ekr.20101010121134.4849: *7* @pause
.. @+node:ekr.20101010121134.4868: *7* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-007.png
.. @+node:ekr.20101010121134.4869: *7* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-007.svg
.. @+node:ekr.20101010140842.4755: *7* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-007.png
.. @+node:ekr.20101010140842.4756: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-007.html
.. @+node:ekr.20101008061729.4524: *6* @slide 008
Here we will save our outline in a file named "pim.leo"

.. image:: slide-008.png

.. @+node:ekr.20101010141334.4772: *7* @screenshot
.. @+node:ekr.20101010141334.4773: *8* To Do List
@nocolor

My to-do list.
.. @+node:ekr.20101010141334.4774: *9* Urgent
1. Make Leo tutorials.  The world is waiting.

2. Pay phone bill or the world will never know.
.. @+node:ekr.20101010141334.4775: *9* Important
.. @+node:ekr.20101010141334.4776: *9* Soon
.. @+node:ekr.20101010141334.4777: *9* Whenever
.. @+node:ekr.20101010141334.4778: *8* Diary
@nocolor
.. @+node:ekr.20101010141334.4779: *9* 2009
.. @+node:ekr.20101010141334.4780: *10* Aug
.. @+node:ekr.20101010141334.4781: *10* Jul
.. @+node:ekr.20101010141334.4782: *10* Jun
.. @+node:ekr.20101010141334.4783: *10* May
.. @+node:ekr.20101010141334.4784: *10* Apr
.. @+node:ekr.20101010141334.4785: *10* Mar
.. @+node:ekr.20101010141334.4786: *10* Feb
.. @+node:ekr.20101010141334.4787: *10* Jan
.. @+node:ekr.20101010141334.4788: *9* 2010
.. @+node:ekr.20101010141334.4793: *7* @select Urgent
.. @+node:ekr.20101010141334.4789: *7* @pause
.. @+node:ekr.20101010141953.4835: *7* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-008.png
.. @+node:ekr.20101010141953.4836: *7* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-008.svg
.. @+node:ekr.20101010141953.4837: *7* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-008.png
.. @+node:ekr.20101010141953.4838: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-008.html
.. @+node:ekr.20101008061729.4525: *6* @slide 009
The file is now saved, and the file appears in the title bar.

.. image:: slide-009.png

.. @+node:ekr.20101010141953.4856: *7* @screenshot
.. @+node:ekr.20101010141953.4857: *8* To Do List
@nocolor

My to-do list.
.. @+node:ekr.20101010141953.4858: *9* Urgent
1. Make Leo tutorials.  The world is waiting.

2. Pay phone bill or the world will never know.
.. @+node:ekr.20101010141953.4859: *9* Important
.. @+node:ekr.20101010141953.4860: *9* Soon
.. @+node:ekr.20101010141953.4861: *9* Whenever
.. @+node:ekr.20101010141953.4862: *8* Diary
@nocolor
.. @+node:ekr.20101010141953.4863: *9* 2009
.. @+node:ekr.20101010141953.4864: *10* Aug
.. @+node:ekr.20101010141953.4865: *10* Jul
.. @+node:ekr.20101010141953.4866: *10* Jun
.. @+node:ekr.20101010141953.4867: *10* May
.. @+node:ekr.20101010141953.4868: *10* Apr
.. @+node:ekr.20101010141953.4869: *10* Mar
.. @+node:ekr.20101010141953.4870: *10* Feb
.. @+node:ekr.20101010141953.4871: *10* Jan
.. @+node:ekr.20101010141953.4872: *9* 2010
.. @+node:ekr.20101010141953.4873: *7* @select Urgent
.. @+node:ekr.20101010141953.4896: *7* @pause
.. @+node:ekr.20101010141953.4897: *7* @edit
.. @+node:ekr.20101010141953.4916: *7* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-009.png
.. @+node:ekr.20101010141953.4917: *7* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-009.svg
.. @+node:ekr.20101010141953.4918: *7* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-009.png
.. @+node:ekr.20101010141953.4919: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-009.html
.. @+node:ekr.20101008061729.4526: *6* @slide 010
You've just seen an introduction to Leo as an outlining editor. You can use Leo
to make an outline, with optional text for each outline element. You can save
the outline to a file. Outlines are explained more in a later tutorial in this
series.

  *The outlining capability of Leo goes far beyond what has just been demonstrated,
  including multipath outlines, and multiple outlines in one file.*

What we've shown so far is no different from other outlining editors. What makes
Leo unique is the addition of a new feature. **Using simple directives, you can
instruct Leo to extract text from any number of nodes, in any order, and write
the text to a new file**. We call files created or managed from within a Leo
outline **external file**. You can also embed outline information in the
external file, giving Leo the ability to read the text pieces back into the Leo
outline, even if they have been changed.

In effect, Leo is a **meta-text** editor. It gives you the ability to create a
structural document for a non structured document, or a document that is
structured in some other way.

What does this mean in practice? Some examples should help clarify things...
.. @+node:ekr.20101010141953.4922: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-010.html
.. @+node:ekr.20101008061729.4527: *6* @slide 011
Here is the "pim.leo" file again. We have:

1. Selected the "Diary" node.
2. Typed Ctrl-H to start editing the headline.
   (You can also edit headlines with the Edit:Edit Headline...:Edit Headline command.

.. image:: slide-011.png

.. @+node:ekr.20101010141953.4940: *7* @screenshot
.. @+node:ekr.20101010141953.4941: *8* To Do List
@nocolor

My to-do list.
.. @+node:ekr.20101010141953.4942: *9* Urgent
1. Make Leo tutorials.  The world is waiting.

2. Pay phone bill or the world will never know.
.. @+node:ekr.20101010141953.4943: *9* Important
.. @+node:ekr.20101010141953.4944: *9* Soon
.. @+node:ekr.20101010141953.4945: *9* Whenever
.. @+node:ekr.20101010141953.4946: *8* Diary
@nocolor

This is my diary.
.. @+node:ekr.20101010141953.4947: *9* 2009
.. @+node:ekr.20101010141953.4948: *10* Aug
.. @+node:ekr.20101010141953.4949: *10* Jul
.. @+node:ekr.20101010141953.4950: *10* Jun
.. @+node:ekr.20101010141953.4951: *10* May
.. @+node:ekr.20101010141953.4952: *10* Apr
.. @+node:ekr.20101010141953.4953: *10* Mar
.. @+node:ekr.20101010141953.4954: *10* Feb
.. @+node:ekr.20101010141953.4955: *10* Jan
.. @+node:ekr.20101010141953.4956: *9* 2010
.. @+node:ekr.20101010141953.4958: *7* @pause
.. @+node:ekr.20101010141953.4957: *7* @select Diary
.. @+node:ekr.20101010141953.5023: *7* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-011.png
.. @+node:ekr.20101010141953.5024: *7* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-011.svg
.. @+node:ekr.20101008061729.4528: *6* @slide 012
.. @+node:ekr.20101008061729.4529: *6* @slide 013
.. @+node:ekr.20101008061729.4530: *6* @slide 014
.. @+node:ekr.20101008061729.4531: *6* @slide 015
.. @+node:ekr.20101008061729.4532: *6* @slide 016
.. @+node:ekr.20101008061729.4533: *6* @slide 017
.. @+node:ekr.20101008061729.4534: *6* @slide 018
.. @+node:ekr.20101008061729.4535: *6* @slide 019
.. @+node:ekr.20101008061729.4536: *6* @slide 020
.. @+node:ekr.20101008061729.4537: *6* @slide 021
.. @+node:ekr.20101008061729.4539: *6* @slide 022
.. @+node:ekr.20101008061729.4540: *6* @slide 023
.. @+node:ekr.20101011071655.4919: *5* @slideshow Whetting Your Appetite
@language rest
@pagewidth 50
.. @+node:ekr.20101013072903.5219: *6* @slide What you can do with Leo
This slideshow shows some of the things you can do
with Leo
.. @+node:ekr.20101013072903.5220: *7* @no-screenshot
.. @+node:ekr.20101013072903.5221: *6* @slide Leo's main window
Leo's main window consists of an **outline pane**
(1), a **body pane** (2) and a **log pane** (3).
All data in Leo resides in **nodes**. A node
consists of **headline text** and **body text**.
The outline pane shows headlines. The body pane
pane shows the body text of the presently selected
node. Messages from Leo appear in the log pane.

.. @+node:ekr.20101011071655.4920: *6* @slide A Personal Information Manager
You can use Leo as a PIM.

As with other outliners, Leo outlines show 
.. @+node:ekr.20101011103613.4930: *6* @slide A Better PIM
Leo is a better pim.
.. @+node:ekr.20101011103613.4942: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-003.html
.. @+node:ekr.20101012083118.5245: *6* @slide External Files
.. @+node:ekr.20101011103613.4933: *6* @slide A Scripting Environment
The body text of any node can contain a Python script.

You execute the script with (Ctrl-B) Leo's execute-script command.
.. @+node:ekr.20101011103613.4943: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-005.html
.. @+node:ekr.20101011103613.4934: *6* @slide Better Scripting
All Leo scripts have access to three predefined constants: c, g and p.
.. @+node:ekr.20101011103613.4944: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-006.html
.. @+node:ekr.20101011103613.4938: *6* @slide Better Scripting, Part Deux
All Leo scripts have full access to the outline in which the scripts reside. The
following scripts, executed from Leo's body pane, will print the headlines of
all the nodes of the outline, properly indented::

    for p in c.all_positions():
        print '%s%s' % (' '*p.level(),p.h)
.. @+node:ekr.20101011103613.4945: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-007.html
.. @+node:ekr.20101011103613.4935: *6* @slide Outlines Create New Leo Commands
Discuss @button nodes
.. @+node:ekr.20101011103613.4946: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-008.html
.. @+node:ekr.20101011103613.4936: *6* @slide Outlines Create Unit tests
Discuss @test nodes
.. @+node:ekr.20101011103613.4947: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-009.html
.. @+node:ekr.20101011103613.4937: *6* @slide Outlines Create Restructured Text
Leo outlines make it easy to create Restructured Text (rST) documents.

Within @rst trees, nodes correspond to rST sections. Naturally, the outline
level of a node in the Leo outline determines the section's level in the
resulting document.
.. @+node:ekr.20101011111455.4965: *7* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-010.html
.. @+node:ekr.20101011103613.4939: *6* @slide Outlines Create HTML
.. @+node:ekr.20101011165412.5011: *5* nutshell (copy)
Unifying scripting, data and outline structure creates a new world. We use the
term **Leonine** to denote the Leo-centric (outline-centric) view of
programming, data and scripting. Here are some of the implications of this
new world:

**Data organization**: Leo's clones allow unprecedented flexibility in
organizing data. Leo outlines have been used as an entirely new kind of
database. It is easily scriptable. As my brother has shown, it is possible to
design Leo outlines so that parts of the outline *are* SQL queries!

**Design**: With Leo, you always see the big picture, and as many of the details
as you like. But this makes outlines ideal for representing designs. In fact,
Leo outlines don't just represent designs, they *are* the designs. For example,
all of Leo's source code reside in just a few Leo outlines. And Leo outlines can
represent input data to other design tools.

**Programming/Coding**: It's much easier to program when the design is always
easily visible. Nodes provide the perfect way to organize large modules, classes
and functions. Nodes also provide unlimited room to save as many details as you
like, *without* cluttering your overall view of the task, or rather tasks, at
hand.

**Testing**: Leo is a supremely powerful unit-testing framework:

1. You can make a node a unit test simply by putting @test at the start of its
   headline. Leo will then automatically generate all the blah-blah-blah needed
   to turn the node's script into a fully-functional unit test. Oh yes,
   the headline becomes the name of the unit test.

2. Unit tests can use data in children of @test nodes. Typical tests put input
   data in one child node, and the expected results of running the test in another
   child node. The test simply compares the actual and expected results.

3. You can easily run tests in the entire outline or just in the selected
   outline. Because tests reside in nodes, you can use clones to organize tests
   in as many ways as you like. For example, it is trivial to run only those
   tests that are failing.

**Maintenance and support**: Leo's ability to contain multiple views of data is
*precisely* what is needed while maintaining any large project. For every new
support task and every new bug, a new (plain) **task node** will contain all the
data needed for that task, notes, test data, whatever. Furthermore, when fixing
bugs, the task node can contain clones of all classes, methods or functions
related to the bug. Fixing a node in the task node fixes the node in the
external file! And as always, you can use all of Leo's outlining features
(including clones) to organize your task nodes.

**Organization everywhere**: Have you noticed that Leo's organizational prowess
applies to *everything*? Indeed, you can use outlines and clones in new ways to
organize files, projects, data, design, programs, testing, and tasks. Leo
doesn't need lots of features--outlines, clones and scripts suffice.  The more
complex your data, designs, program and tasks, the better Leo is suited to them.

It's time to mention one of Leo's most unique features.  Simple, *optional*
markup makes it possible to synthesize (build) scripts and entire computer programs
from outlines. Leo is more than a filing cabinet for scripts and programs, Leo
is a build tool for scripts and outlines!

**Scripting everything**: Let's step back a moment. A single outline can contain
databases, designs, actual computer code, unit tests, test scripts and task
nodes. But Leo scripts will work on any kind of node. Thus, it is *easy* to run
scripts on *anything*! Examples:

- Scripting itself: @button nodes creates a **script button**, a Python script
  that can be applied to any node in an outline! Script buttons have been
  written (in Python) that will execute Leo scripts in other languages.

- Data: The @kind convention for headlines tells scripts what a node contains
  without having to parse the node's contents.  The possibilities are endless.

- Design: scripts can verify properties of design based on either the contents
  of design nodes or their outline structure.

- Coding: scripts routinely make massive changes to outlines. Scripts and unit
  tests can (and do!) verify arbitrarily complex properties of outlines.

- Scientific programming: Leo scripts can run experiments many times using
  different starting points. Nodes are the perfect place to store results and
  notes. Many scientists use the IPython shell-- Using Leo's **IPython bridge**,
  Leo can execute IPython scripts, and scripts in IPython have full access to
  all nodes in Leo outlines.

- Testing: scripts can (and do!) create @test nodes themselves.

- Maintenance: scripts could gather statistics about tasks using simple @kind
  conventions.

The Leo Aha is just this: Leo outlines are far more than eye candy. Leo outlines
revolutionize your view of data--Leo outlines can organize *anything*. Leo
outlines create a new kind of programming environment, one in which outline
structure and user-defined data types create totally new opportunities.
.. @+node:ekr.20101012083118.5246: *5* @@slide Leo
Leo is a unique, powerful computer program that you can use to organize, analyze
and describe text and text files.

Use Leo:

- To brainstorm a new project.
- As a Personal Information Manager.
- As a new kind of programming too.

Because Leo is unlike other tools you may have used, a series of examples may be
the best way to demonstrate what can be done with Leo.
.. @+node:ekr.20101011103613.4940: *5* @@slide The Leo way
Leo is a new way of working with complex data like computer programs,
books, web sites and data bases. The term **Leonine** refers to the Leo
way of viewing the world and its data.

In Leo, **outline structure is significant everywhere**. Leos users speak of an
Aha! moment when they see what this statement means.

People say Leo is **fun to use**, even additive.
.. @+node:ekr.20101012083118.5242: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-001.html
.. @+node:ekr.20101013072903.5238: *5* Don't describe the window!
.. @+node:ekr.20101013072903.5228: *6* @slide ((file name: workbook2.leo
.. Arrow points to window title.

The name of the Leo outline appears in the window's title.

Here, the name is workbook.leo, the default file name.
.. @+node:ekr.20101013072903.5229: *6* @slide ((3 panes
Leo's main window consists of an **outline pane**
(1), a **body pane** (2) and a **log pane** (3).

.. @+node:ekr.20101013072903.5230: *6* @slide ((outline pane
The outline pane shows **headlines**.

Here, we see the a "startup" headline and a "workbook" headline.
.. @+node:ekr.20101115152915.4933: *3* Maybe
.. @+node:ekr.20101115152915.4935: *4* Leo's Dom
.. @+node:ekr.20101113110328.4947: *4* Using @button nodes
.. @+node:ekr.20101115152915.4932: *4* Using @test nodes
.. @+node:ekr.20101115152915.4934: *4* Using @url nodes
.. @+node:ekr.20101113110328.4945: *4* Top 10 coolest features
.. @+node:ekr.20101113110328.4946: *4* How to make slide shows
.. @+node:ekr.20101014034526.5294: *4* IPython
- Execute IPython scripts from Leo.
- Execute Leo scripts from IPython.
.. @+node:ekr.20101014034526.5295: *4* Vim & Emacs
.. @+node:ekr.20101025080245.5529: *4* leoremote plugin
@nocolor-node

Ville's server code to interact with a running Leo
http://mail.google.com/mail/#inbox/12adebe2ffe80572

Reusing Emacs instances with gnuserv
http://www.debian-administration.org/articles/257

.. @+node:ekr.20101025080245.5546: *4* @url Document Ville's server
http://mail.google.com/mail/#inbox/12adebe2ffe80572
.. @+node:ekr.20101014034526.5280: *3* @slideshow External files
@language rest
@pagewidth 60
.. @+node:ekr.20101014034526.5287: *4*   Topics
sentinels

With \@file, you also **share outline structure**.

Leo opens external files automatically.

Leo is an IDE
.. @+node:ekr.20101014110348.5256: *4* @slide ((no-ss intro
Leo nodes whose headline starts with \@file, \@auto or
\@edit create **external files**, files outside of Leo on
your file system::

  @file myClass.py
  @auto ../graphics/circles.cpp
  @edit ~/.leo/.leoID.txt

The headline contains a file name, which can be an absolute
path or a path relative to the directory containing the Leo
outline.

**@file** embeds outline structure directly into external
files using comments called **sentinel lines**. This is the
recommended way to share external files among Leo users.

**@auto** and **@edit** allow you to read and edit external
files without inserting sentinel lines. The cost of avoiding
sentinel lines is that Leo can not preserve outline
structure exactly.
.. @+node:ekr.20101020082858.5420: *5* @no-screenshot
.. @+node:ekr.20101021092135.5430: *5* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\external-files\_build\html\slide-001.html
.. @+node:ekr.20101020082858.5441: *4* @slide ((no-ss auto read/write
Collectively, \@file, \@auto or \@edit trees are called
**@<file> trees**.

**Leo automatically reads and writes \@<file> trees**

When you open a Leo outline, Leo recreates all \@<file>
trees from the corresponding external files.

When you save a Leo outline, Leo writes all changed \@<file>
trees to the corresponding external files.

A single Leo outline may be connected to dozens of external
files. Reading external files is very fast because of an
efficient file-caching scheme.

As a result, Leo acts like an IDE (Integrated Development
Environment). For example, a single Leo outline contains
@file trees for all of Leo's core source files.
.. @+node:ekr.20101020082858.5443: *5* @no-screenshot
.. @+node:ekr.20101020082858.5446: *5* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\external-files\_build\html\slide-002.html
.. @+node:ekr.20101014110348.5278: *4* at-thin
.. @+node:ekr.20101019085517.5424: *5* @slide ((@file
\@file trees are the most flexible way of creating and editing external files.

Here, we have created an **@file node**, a node
whose headline start with @file.
.. @+node:ekr.20101014110348.5270: *4* at-edit
**@edit nodes** contain the entire contents of an
external file.

.. @+node:ekr.20101014110348.5275: *5* @slide ((@edit intro
Within a Leo outline, an @edit node contains
the entire contents of an external file.
.. @+node:ekr.20101014110348.5257: *5* @slide ((@edit
Here, created a node called @edit spam.py.

This represents the file spam.py in the same
directory as the Leo outline.
.. @+node:ekr.20101014110348.5261: *5* @slide ((simple body text
I've typed some text into the body pane.

The @language python line is a Leo directive. It
tells Leo to syntax color the body text as Python
source code.
.. @+node:ekr.20101014110348.5260: *5* @slide ((save, creating the file
I save the Leo outline file with Ctrl-S or the File:Save menu.

When I do that, Leo automatically saves any @edit node that
is new or has been changed.

In this case, the @edit node was new, so the log window says::

    created: c:\Users\edreamleo\.leo\spam.py
    saved: workbook.leo

Leo tells you the full path to created files, and
the short path to updated files like workbook.leo.
.. @+node:ekr.20101014110348.5262: *5* @slide ((change the text
Now I've added some more text.

The icon box shows that the @edit node is "dirty" (has been changed).
.. @+node:ekr.20101014110348.5263: *5* @slide ((save again, updating the file
I save the Leo outline again.

Once again, Leo saves spam.py.

This time, the log window says::

    wrote: spam.py
    saved: workbook.leo
.. @+node:ekr.20101014110348.5265: *5* @slide ((here is the actual file
.. @+node:ekr.20101014110348.5264: *5* @slide ((close the file
Let's close the file and reopen it.

We get exactly the same information,
with the same node selected, with the same information.

.. @+node:ekr.20101014110348.5266: *5* @slide ((edit the file outside of Leo
We can edit spam.py outside of Leo.

Let's add a comment.
.. @+node:ekr.20101014110348.5267: *5* @slide ((close Leo file and reopen
If we close the Leo file and reopen it,
we see the new text.
.. @+node:ekr.20101014110348.5274: *5* @slide ((@edit with existing files
Rather than creating new files with @edit, it is more common
to use @edit to connect Leo with files that already exist on your file system.
.. @+node:ekr.20101014110348.5271: *4* at-auto
.. @+node:ekr.20101014110348.5272: *5* ((@auto
..  At present, there are **importers** for
..  C, elisp, HTML, .ini files, Java, Javascript,
..  Pascal, PHP, Python and xml. 


**@auto** trees cause Leo to automatically create
an outline based on the structure of the external
file. 

**@auto trees** cause Leo to **import**
a file into a tree of Leo nodes, based on the
file's extension. Leo's **importers** create Leo
outlines based on the structure of the imported
language. The importer for unknown languages reads
the entire contents of the external file into the
\@auto node. **@edit nodes** cause Leo to read the
entire contents of an external file into the @edit
node.

Leo contains **importers** for common
languages. These importers split the external file
into outline nodes.
.. @+node:ekr.20101014110348.5293: *3* @slideshow Clones and views
.. @+node:ekr.20101014034526.5296: *3* @slideshow Leo's minibuffer
@ Discuss tab completion.
.. @+node:ekr.20101010141953.5028: *3* @slideshow Leo's NSIS Installer
@language rest
.. @+node:ekr.20101010141953.5029: *4* @title_pattern = Leo's NSIS Installer: Slide %(slide_number)s
.. @+node:ekr.20101010141953.5030: *4* @slide 001
.. _`here`:     http://www.nullsoft.com/free/nsis/
.. _`Winamp`:   http://www.winamp.com/

Nullsoft, the makers of the `Winamp`_ MP3 software, have released a powerful free
installer called NSIS, available `here`_. This application allows you to make
installation packages for Windows applications.

You create NSIS packages by writing a NSIS script and then compiling it.
Depending on the application, NSIS can often be a better choice than more
expensive installation generators, since NSIS installations are easy to create,
are small and fast, and yet can be configured with many features.

.. @+node:ekr.20101010141953.5031: *4* @slide 002
When you install Leo, you'll find that it comes with a script for generating an
installer for Leo. This script is called leo-<version>.nsi, and is distributed
in the Leo file leo/dist/leoDist.leo.

If you have NSIS installed, right-clicking on a .nsi file will give you the
option of compiling the script to create a package.

.. image:: slide-002.png

.. @+node:ekr.20101010141953.5032: *5* @screenshot
.. @+node:ekr.20101010141953.5033: *6* Take screenshot of the compile .nsi dialog in a Windows folder
.. @+node:ekr.20101010141953.5034: *5* @pause
.. @+node:ekr.20101010141953.5038: *5* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/leos-nsis-installer/screenshot-002.png
.. @+node:ekr.20101010141953.5039: *5* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/leos-nsis-installer/screenshot-002.svg
.. @+node:ekr.20101010141953.5040: *5* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leos-nsis-installer/slide-002.png
.. @+node:ekr.20101011071655.4918: *5* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leos-nsis-installer\_build\html\slide-002.html
.. @+node:ekr.20101011092154.4923: *4* @slide 003
Since the NSIS script for the Leo installation is included in the Leo
distribution in the nsis.leo file, it is easy to understand the how the script
works. This .nsi file creates an installer that packages all of the Leo program
files, and creates a desktop shortcut, a Program Menu item, and the file
association for .leo files.
.. @+node:ekr.20101011092154.4924: *4* @slide 004
In this screenshot we're looking at the code that checks to see whether Python
has been installed.

Since Leo is a Python application, modifying this installation script to create
a script to build a Windows installer for your own Python application is
relatively simple. You would leave this section alone, and check other sections
for the program name "Leo", and change these to your program name.
.. @+node:ekr.20101011092154.4925: *4* @slide 005
.. @+node:ekr.20101011165412.5154: *4* @@button make leo.nsi
@language python

# **Important**
#   Before running this script you must create bzr-manifest as follows::
#       cd to trunk
#       bzr ls -R >bzr-manifest.txt

'''Create the installer script using bzr-manifest.txt.'''

import os,string,sys
<< define version >>
<< define inLeo >>

if inLeo:
    # The root directory contains the leo directory.
    rootDir  = g.os_path_finalize_join(g.app.loadDir,'..','..')
    manifest = g.os_path_finalize_join(rootDir,'bzr-manifest.txt')
else:
    rootDir = os.path.abspath(os.curdir)
    manifest = os.path.normpath(os.path.join(rootDir,'bzr-manifest.txt'))

<< define application constants >>
@others

nsi = nsiWriter()
nsi.run(manifest)
.. @+node:ekr.20101011165412.5155: *5* << define version >>
# Used by both @button make leo.nsi and @button make leo.zip.
app_version = version = '4.8-d1'
.. @+node:ekr.20101011165412.5156: *5* << define inLeo >>
try:
    inLeo = g is not None
except AttributeError:
    inLeo = False

# print('inLeo',inLeo)
.. @+node:ekr.20101011165412.5157: *5* << define application constants >>
app_doc_icon = r'Icons\LeoDoc.ico'
app_extension = '.leo'
app_hkey_local_machine = r'SOFTWARE\EKR\leo'
app_icon = r"%s\leo\Icons\leo_inst.ico" % rootDir
app_icon2 = r'leo\Icons\LeoApp.ico' # Relative to install dir.
app_license = r'%s\License.txt' % rootDir
app_lower_case_name = 'leo'
app_name = 'Leo'
app_publisher = 'Edward K. Ream'
app_python_executable = 'launchLeo.py'
app_uninst_key = r"Software\Microsoft\Windows\CurrentVersion\Uninstall\leo"
app_uninst_root_key = 'HKLM'
app_web_site = 'http://webpages.charter.net/edreamleo/front.html'

nsi_name = 'leo-%s.nsi' % app_version
target_file = 'LeoSetup-%s.exe' % app_version

substitutionDict = {
    'doc_icon': app_doc_icon,
    'ext': app_extension,
    'exe': app_python_executable,
    'hkey_local_machine': app_hkey_local_machine,
    'icon': app_icon,
    'icon2': app_icon2,
    'license': app_license,
    'lower_name': app_lower_case_name,
    'name': app_name,
    'nsi_name': nsi_name,
    'publisher': app_publisher,

    'site': app_web_site,
    'target_file': target_file,
    'uninst_key': app_uninst_key,
    'uninst_root_key': app_uninst_root_key,
    'version': app_version,
    # Leave these unchanged.
    'DESKTOP': '$DESKTOP',
    'INSTDIR': '$INSTDIR',
    'NSISDIR': '${NSISDIR}',
    'PROGRAMFILES': '$PROGRAMFILES',
    'PythonExecutable': '$PythonExecutable',
    'SMPROGRAMS': '$SMPROGRAMS'
}
.. @+node:ekr.20101011165412.5158: *5* class nsiWriter
class nsiWriter:

    '''A class to write .nsi scripts.'''

    @others
.. @+node:ekr.20101011165412.5159: *6* genScript & helpers
def genScript (self,dirs,dirDict,filesDict):

    '''Generate the .nsi installer script.'''

    self.f = f = self.openNsi()
    if not f: return

    try:
        self.genHead()
        self.genInstallData(dirs,dirDict,filesDict)
        self.genMiddle()
        self.genUninstallData(dirs,dirDict,filesDict)
    finally:
        f.close()

    g.es_print('make-leo-nsi done. no errors')
.. @+node:ekr.20101011165412.5160: *7* genHead
def genHead (self):

    '''Generate the boilerplate appearing before
    the manifest-specific install data.'''

    self.put('!include MUI2.nsh\n')
    self.putSettings()
    self.putOnInit()
.. @+node:ekr.20101011165412.5161: *8* putSettings
def putSettings (self):

    s = r'''
; Location of Pythonw.exe. Set by .onInit.
var PythonExecutable

SetCompressor bzip2
Caption "${name} Installer"
AutoCloseWindow false 
SilentInstall normal
CRCCheck on ; FIXME shouldn't this be CRCCheck force ? Why give user option of using corrupted installer?
SetCompress auto ; FIXME this is disabled for solid compression, which comes with BZip2 and LZMA compression
SetDatablockOptimize on
; SetOverwrite ifnewer
WindowIcon off
OutFile "${target_file}"
LoadLanguageFile "${NSISDIR}\Contrib\Language files\English.nlf"
; Default location.  May be changed in .onInit.
InstallDir "${PROGRAMFILES}\${name}-${version}"
Icon "${icon}"
DirText "Setup will install ${name}-${version} in the following folder. $$\n\
To install in a different folder, click Browse and select another folder."
LicenseText "You must accept the agreement to install ${name}-${version}."
LicenseData "${license}"
ShowInstDetails show
ShowUnInstDetails show

'''
    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5162: *8* putOnInit
def putOnInit (self):

    s = r'''

; Set PythonExecutable to full path to Pythonw.exe.
Function .onInit
    ReadRegStr $9 HKLM "SOFTWARE\Python\PythonCore\2.6\InstallPath" ""
    StrCmp $9 "" tryPython31 ok

tryPython31:
    ReadRegStr $9 HKLM "SOFTWARE\Python\PythonCore\3.1\InstallPath" ""
    StrCmp $9 "" oops ok

oops:
    MessageBox MB_OK "Python not found: using c:\python26"
    ; Guess where Python 26 is.
    StrCpy $PythonExecutable "c:\Python26\pythonw.exe"
    ; Fallback installation directory is "Program Files"
    Goto done
ok:
    MessageBox MB_OK "Found Python at $9"
    StrCpy $PythonExecutable "$9\pythonw.exe"
    ; Normal installation directory 
    StrCpy $INSTDIR "$9\Lib\site-packages\${name}-${version}"
done:

; End .onInit
FunctionEnd
'''
    s = s.replace('${name}',app_name).replace('${version}',app_version)
    self.put(s,substitute=False)
.. @+node:ekr.20101011165412.5163: *7* genInstallData & helpers
def genInstallData(self,dirs,dirDict,filesDict):

    '''Generate the manifest-specific install data.'''

    self.put('\nSection "%s" SEC01\n\n' % (app_name))

    self.put(self.getInstallVariableData(
        dirs,dirDict,filesDict),adjust=False)

    self.put('\n; end %s section\n' % (app_name))
    self.put('SectionEnd\n')
.. @+node:ekr.20101011165412.5164: *8* getInstallVariableData
def getInstallVariableData (self,dirs,dirDict,filesDict):

    global rootDir
    result = []

    # Top level
    theDir = '**top'
    result.append('; top-level\n')
    result.append('SetOutPath "$INSTDIR"\n')
    result.append('SetOverwrite ifnewer\n')
    aList = dirDict.get(theDir,[])
    for fn in aList:
        result.append('File "%s"\n' % fn)

    for theDir in dirs:
        if theDir != '**top':
            aList = dirDict.get(theDir,[])
            if aList:
                theDir2 = theDir.replace('/','\\').rstrip('\\')
                result.append('\n')
                result.append('SetOutPath $INSTDIR\\%s\n' % theDir2)
                for fn in aList:
                    # Fix bug 425369: quote file names.
                    result.append('File "%s\\%s\\%s"\n' % (
                        rootDir,theDir2,fn))

    result = [self.indent(z) for z in result]
    return ''.join(result)
.. @+node:ekr.20101011165412.5165: *7* genMiddle
def genMiddle (self):

    '''Generate the boilerplate appearing between
    the manifest-specific install data and
    the manifest-specific uninstall data.'''

    self.genMenuShortcuts()
    self.genDesktopShortcuts()
    self.genFileAssociation()
    self.genAdditionalIcons()
    self.genPost()
    self.genUninstallSettings()
    self.genMiddleFunctions()
.. @+node:ekr.20101011165412.5166: *8* genAdditionalIcons
def genAdditionalIcons(self):

    s = r'''
Section -AdditionalIcons
  SetOutPath $INSTDIR
  CreateDirectory "${SMPROGRAMS}\${name}"
  CreateShortCut "${SMPROGRAMS}\${name}\Uninstall.lnk" "$INSTDIR\uninst.exe"
SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5167: *8* genDesktopShortcuts
def genDesktopShortcuts(self):

    s = r'''
Section "Desktop Shortcut" SEC03
  CreateShortCut "${DESKTOP}\${name}.lnk" '"${PythonExecutable}"' '"$INSTDIR\${exe}"' "$INSTDIR\${icon2}" 0
SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5168: *8* genFileAssociation
def genFileAssociation(self):

    s = r'''
Section "${ext} File Association"
  SectionIn 1
  SectionIn 2
  SectionIn 3

  # back up old value of extension in case some other program was using it
  ReadRegStr $$1 HKCR "${ext}" ""
  StrCmp $$1 "" Label1
  StrCmp $$1 "${name}File" Label1
  WriteRegStr HKCR "${ext}" "backup_val" $$1

Label1:
  WriteRegStr HKCR "${ext}" "" "${name}File"
  WriteRegStr HKCR "${name}File" "" "${name} File"
  WriteRegStr HKCR "${name}File\shell" "" "open"
  WriteRegStr HKCR "${name}File\DefaultIcon" "" ${INSTDIR}\${doc_icon}
  WriteRegStr HKCR "${name}File\shell\open\command" "" '"${PythonExecutable}" "${INSTDIR}\${exe}" "%1"'

SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5169: *8* genMenuShortcuts
def genMenuShortcuts (self):

    s = r'''
; FIXME $SMPROGRAMS depends on the value of SetShellVarContext. Since that defaults to 'current'
; that means that this installer will make the app available for the current user only.
; Unless I am grossly mistaken this is a needless hindrance, and a Bad Thing since
; security concerns are such that it would be best to not run the app with the Administrator privileges
; of the account used to install the software.
;
; Sure enough, the Start Menu Shortcuts and Desktop Shortcut work for the installer account only. 
;
; Question is -- do we want the app always available for any log-in on this computer?
;
; My guesses:
; Ideally, Uninstall.lnk should appear only for the current user, and the uninstaller should refuse to run
; if run by a user who lacks Admin privileges on Windows NT and its descendants
;
; How will Windows XP Home deal with that? 

Section "Start Menu Shortcuts" SEC02
    CreateDirectory "${SMPROGRAMS}\${name}"
    CreateShortCut "${SMPROGRAMS}\${name}\Uninstall.lnk" "${INSTDIR}\uninst.exe" "" "${INSTDIR}\uninst.exe" 0
    CreateShortCut "${SMPROGRAMS}\${name}\${name}.lnk" '"${PythonExecutable}"' '"${INSTDIR}\${exe}"' "${INSTDIR}\${icon2}" 0
SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5170: *8* genMiddleFunctions
def genMiddleFunctions (self):

    s = r'''
Function un.onUninstSuccess
  HideWindow
  MessageBox MB_ICONINFORMATION|MB_OK "${name}-${version} was successfully removed from your computer."
FunctionEnd

Function un.onInit
  MessageBox MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2 \
  "Are you sure you want to completely remove ${name}-${version} and all of its components?" IDYES +2
  Abort
FunctionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5171: *8* genPost
def genPost (self):

    s = r'''
Section -Post
  WriteRegStr HKEY_LOCAL_MACHINE "${hkey_local_machine}" "" "$INSTDIR"
  WriteUninstaller "$INSTDIR\uninst.exe"
  WriteRegStr ${uninst_root_key} "${uninst_key}" "DisplayName" "${name}-${version} (remove only)"
  WriteRegStr ${uninst_root_key} "${uninst_key}" "UninstallString" "${INSTDIR}\uninst.exe"
  WriteRegStr ${uninst_root_key} "${uninst_key}" "DisplayVersion" "${version}"
  WriteRegStr ${uninst_root_key} "${uninst_key}" "URLInfoAbout" "${site}"
  WriteRegStr ${uninst_root_key} "${uninst_key}" "Publisher" "${publisher}"
SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5172: *8* genUninstallSettings
def genUninstallSettings(self):

    path = g.os_path_finalize_join(
        g.app.loadDir,'..','Icons','uninst.ico')

    s = r'''
UninstallCaption "Uninstall ${name}"
UninstallIcon "${path}"
'''

    s = s.replace('${path}',path)
    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5173: *7* genUninstallData & helpers
def genUninstallData(self,dirs,dirDict,filesDict):

    '''Generate the manifest-specific uninstall data.'''

    s = r'''
Section Uninstall

    DeleteRegKey HKEY_LOCAL_MACHINE "${hkey_local_machine}"

    ; Delete files & directories only if we own them!
    ReadRegStr $$1 HKCR "${ext}" ""
    StrCmp $$1 "${name}File" 0 FinishUninstall

    ; Delete files & directories only if there is no backup_val key.
    ReadRegStr $$1 HKCR "${ext}" "backup_val"
    StrCmp $$1 "" 0 DeleteLeoKeysAndFiles
      DeleteRegKey HKCR "${ext}"
    Goto FinishUninstall

DeleteLeoKeysAndFiles:
    WriteRegStr HKCR "${ext}" "" $$1
    DeleteRegValue HKCR "${ext}" "backup_val"

    ; ---- Start of manifest-related data...
'''

    self.put(s,substitute=True)

    # Does all the hard work.
    self.put(
        self.getUninstallVariableData(dirs,dirDict,filesDict),
        adjust = False)

    s = r'''
    ; ---- End of manifest related data.

FinishUninstall:
    ; MessageBox MB_YESNO|MB_ICONQUESTION \
    ;    "Delete all files in ${INSTDIR}?" IDNO NoDelete
; NoDelete:

  Delete "${SMPROGRAMS}\${name}\Uninstall.lnk"
  RMDir "${SMPROGRAMS}\${name}-${version}"
  Delete "${DESKTOP}\${name}.lnk"

  DeleteRegKey ${uninst_root_key} "${uninst_key}"
  SetAutoClose false

; end Uninstall section
SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5174: *8* getDeleteDirectories
def getDeleteDirectories (self,dirs,dirDict):

    reverseDirs = dirs[:]
    reverseDirs.reverse()

    result = []
    result.append('; Uninstall directories in reverse order\n')
    for theDir in reverseDirs:
        # Delete the directory even if it has no files.
        if theDir and theDir != '**top':
            if not theDir.startswith('.bzr'):
                result.append('RMDir "$INSTDIR\\%s"\n' % (
                    theDir.replace('/','\\')))

    # top-level folder.
    result.append('RMDir "$INSTDIR"\n')

    result = [self.indent(z) for z in result]
    return ''.join(result)
.. @+node:ekr.20101011165412.5175: *8* getDeleteFiles
def getDeleteFiles (self,dirs,dirDict,filesDict):

    wildcard_delete = True
    result = []
    result.append('; Uninstall files...\n\n')

    # top-level files.
    result.append('; Delete top-level files...\n')
    aList = dirDict.get('**top',[])
    # special case.
    aList.append('uninst.exe')
    # Warning: **never** delete all files in the top-level directory.
    for fn in aList:
        result.append('Delete "$INSTDIR\\%s"\n' % fn)
    if wildcard_delete:
        result.append('\n')

    for theDir in dirs:
        if theDir:
            dir2 = theDir.replace('/','\\')
            if wildcard_delete:
                result.append('Delete "$INSTDIR\\%s\\*.*"\n' % (dir2))
            else:
                aList = dirDict.get(theDir,[])
                if aList:
                    result.append('\n')
                    result.append('Delete "$INSTDIR\\%s\\*.pyc"\n' % (dir2))
                    result.append('Delete "$INSTDIR\\%s\\*.pyo"\n' % (dir2))
                for fn in aList:
                    result.append('Delete "$INSTDIR\\%s\\%s"\n' % (
                        dir2,fn))

    result = [self.indent(z) for z in result]
    return ''.join(result)
.. @+node:ekr.20101011165412.5176: *8* getUninstallVariableData
def getUninstallVariableData(self,dirs,dirDict,filesDict):

    s1 = self.getDeleteFiles(dirs,dirDict,filesDict)
    s2 = self.getDeleteDirectories(dirs,dirDict)
    return '%s\n%s' % (s1,s2)
.. @+node:ekr.20101011165412.5177: *7* indent
def indent(self,s):

    if s.strip():
        return '    ' + s
    else:
        return s
.. @+node:ekr.20101011165412.5178: *7* openNsi
def openNsi (self):

    path = g.os_path_finalize_join(
        g.app.loadDir,'..','..',nsi_name)

    try:
        f = open(path,'w')
    except IOError:
        f = None
        g.es_print('Can not open',path,color='red')

    return f
.. @+node:ekr.20101011165412.5179: *7* put
def put (self,s,adjust=True,substitute=False):

    '''Output s to the nsi file, optionally making
    the substitutions given in substitutionDict.'''

    trace = False
    if adjust:
        s = self.adjustTripleString(s)

    if substitute:
        if 0:
            n = 1
            for z in g.splitLines(s):
                print('%3s %s' % (n,z.rstrip()))
                n += 1
        s = string.Template(s)
        s = s.substitute(substitutionDict)

    if trace: g.trace(s,g.callers(4))
    self.f.write(s)
.. @+node:ekr.20101011165412.5180: *6* run & helpers
def run (self,fn):

    '''The top-level logic.'''

    # Create and filter the list of files from the manifest.
    s = open(fn).read()
    lines = g.splitLines(s)
    files = self.filterLines(lines)

    # Compute the list of all the directories.
    dirs = self.directoryList(rootDir)

    # Compute dictionaries of directories and files.
    dirDict,filesDict = self.makeDicts(dirs,files)

    # Print manifest lines not in either dict.
    # This is a crucial check.
    errors = self.printMissing(files,dirDict,filesDict)
    if errors: return

    # Generate the script!
    self.genScript(dirs,dirDict,filesDict)
.. @+node:ekr.20101011165412.5181: *7* directoryList
def directoryList (self,rootDir):

    '''Compute a top-down list of all directories.
       These directories start at the top-level directory.'''

    trace = False
    ignoreDirs = ('.bzr',)
    # Important: this adds all directories on EKR's machine,
    # regardless of whether they appear in the manifest!
    result = [] ; n = len(rootDir)
    for z in os.walk(rootDir): # top-down traversal.
        dirpath, dirnames, filenames = z
        assert dirpath.startswith(rootDir),z
        if len(dirpath) > n:
            path = dirpath[n+1:].replace('\\','/')
            result.append(path)
    for z2 in ignoreDirs:
        result = [ z for z in result if not z.startswith(z2)]
    if trace:
        g.trace('-' * 40)
        g.trace(g.listToString(result))
    return result
.. @+node:ekr.20101011165412.5182: *7* filterLines & helpers
def filterLines (self,lines):

    '''Filter lines from the input manifest file.'''

    trace = False

    # Remove blank lines, comments, and .pyc and .pyo files.
    lines = self.deleteBlankLines(lines)
    lines = self.deleteComments(lines)
    lines = self.deleteExt(lines,'.pyc')
    lines = self.deleteExt(lines,'.pyo')
    lines = self.deleteExt(lines,'.zip') # Don't include the zip file.
    lines = self.deleteExt(lines,'.exe') # Don't include the installer.

    # Remove specific files.
    deleteList = (
        '.bzrignore',
        'bzr-manifest.txt',
        'bzr-small-manifest.txt',
        'setup.py',
        'leo/test/unittest/.leo_shadow/',
        'nsi.log.txt', # Can't write log while we are creating it.
        'leo/core/leoPy.leo',
        'leo/core/ekrLeoPy.leo',
    )
    lines = self.deleteFiles(lines,deleteList)
    if lines and lines[0].endswith('bzr ls -R'):
        lines = lines[1:]

    if trace:
        g.trace('=' * 40)
        g.trace(g.listToString(lines))

    return lines
.. @+node:ekr.20101011165412.5183: *8* delete...
def deleteBlankLines (self,lines):

    return [z.strip() for z in lines if z.strip()]

def deleteComments (self,lines):

    return [z for z in lines if not z.startswith('#')]

def deleteExt (self,lines,ext):

    return [z for z in lines if not z.endswith(ext)]

def deleteFiles (self,lines,deleteList):

    return [z for z in lines if not z in deleteList]
.. @+node:ekr.20101011165412.5184: *7* makeDicts
def makeDicts (self,dirs,lines):

    trace = False ; verbose = False

    # Create the dirDict.
    # Keys are directories.
    # Values are files contained in each directory.
    dirDict = {}
    dirDict['**top'] = [] # Create an entry for the root directory.
    for z in dirs:
        dirDict[z] = []

    # Assign files to dirDict.
    for line in lines:
        line = line.strip().replace('\\','/')
        if line in dirDict.keys():
            path,fn = None,None
        elif line.startswith('leo/'):
            path,fn = g.os_path_split(line)
        else:
            path,fn = '**top',line.strip()

        # Don't include top-level leo directory,
        # Do include leo/scripts/leo file.
        if fn and (path != '**top**' or fn != 'leo'):
            aList = dirDict.get(path,[])
            assert line not in aList,repr(line)
            aList.append(fn)
            dirDict[path]=aList

    for theDir in sorted(dirDict):
        aList = dirDict.get(theDir)
        if aList and trace:
            if verbose:
                print() ; print(theDir)
                print(g.listToString(aList))
            else:
                print(theDir)

    # Create the inverse dict.
    filesDict = {}
    for theDir in sorted(dirDict):
        aList = dirDict.get(theDir)
        for fn in aList:
            path = g.choose(theDir=='**top',
                fn,'%s/%s' % (theDir,fn))
            filesDict[path] = theDir

    return dirDict,filesDict
.. @+node:ekr.20101011165412.5185: *7* printMissing
def printMissing (self,files,dirDict,filesDict):

    errors = 0

    for fn in files:
        fn = fn.rstrip('/')
        if fn and fn not in dirDict and fn not in filesDict:
            g.es_print('missing',fn,color='red')
            errors += 1

    if errors:
        g.es_print('%s errors' % (errors),color='red')

    return errors
.. @+node:ekr.20101011165412.5186: *6* whitespace
# These are adapted from the corresponding functions in leoPy.leo
# They are defined here to make this script independent of Leo
.. @+node:ekr.20101011165412.5187: *7* adjustTripleString
def adjustTripleString (self,s):

    '''Remove leading indentation from a triple-quoted string.'''

    # Compute the minimum leading whitespace of all non-blank lines.
    lines = self.splitLines(s)
    w = 0 ; val = -1
    for line in lines:
        if line.strip():
            lws = self.get_leading_ws(line)
            w2 = self.computeWidth(lws)
            # The sign of w does not matter.
            if w == 0 or abs(w2) < w:
                w = abs(w2)

    if w == 0: return s

    # Remove the leading whitespace.
    result = [self.removeLeadingWhitespace(line,w) for line in lines]
    result = ''.join(result)
    return result
.. @+node:ekr.20101011165412.5188: *7* get_leading_ws
def get_leading_ws(self,s):

    """Returns the leading whitespace of 's'."""

    i = 0 ; n = len(s)
    while i < n and s[i] in (' ','\t'):
        i += 1
    return s[0:i]
.. @+node:ekr.20101011165412.5189: *7* computeWidth
def computeWidth (self,s):

    '''Return the width of s, assuming s starts a line.'''

    tabwidth = 4
    w = 0
    for ch in s:
        if ch == '\t':
            w += tab_width - (w % tab_width)
        else:
            w += 1
    return w
.. @+node:ekr.20101011165412.5190: *7* removeLeadingWhitespace
def removeLeadingWhitespace (self,s,first_ws):

    '''Remove whitespace up to first_ws wide in s.'''

    j = 0 ; ws = 0
    tabwidth = 4
    first_ws = abs(first_ws)
    for ch in s:
        if ws >= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += tab_width - (ws % tab_width)
        else: break
    if j > 0:
        s = s[j:]
    return s
.. @+node:ekr.20101011165412.5191: *7* splitLines
def splitLines (self,s):

    '''Split s into lines, preserving the number of lines and the ending of the last line.'''

    return s and s.splitlines(True) or []
.. @+node:ekr.20100821182153.4345: ** @slideshow Installation
@language rest
.. @+node:ekr.20101014034526.5299: *3* @slide ((using Leo's installer
.. _`Download Python`: http://www.python.org/download/
.. _`packaged version`: https://sourceforge.net/projects/leo/files/Leo/
.. _`Leo's download page`: https://sourceforge.net/projects/leo/files/Leo/
.. _`next slide`: slide-002.html

**Installing on Windows: using Leo's single-click installer** 

1. Install Python: `Download Python`_, save to your desktop, then
   double-click on the saved file.

   Python is software for creating and running computer programs.
   Leo requires Python 2.6 or later, or Python 3.0 or later.

2. Install Qt. Get the binary package of PyQt from: 
   http://www.riverbankcomputing.co.uk/software/pyqt/download

   The version of PyQt that you download must match the version of your Python.

3. Download the latest Leo's installer from `Leo's download page`_.
   It will be called something like LeoSetup-<version>.exe

4. Run the installer.

**Installing Leo from Linux packages**

Linux users are best served by the `packaged version`_ available at
SourceForge. You can also install Leo manually, as discussed in the
`next slide`_.

**Installing Leo from sources**

See the `next slide`_.
.. @+node:ekr.20101113132111.4924: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-001.html
.. @+node:ekr.20100821182153.4348: *3* @slide ((installing from sources
.. _`Download Python`: http://www.python.org/download/
.. _`Leo's download page`: https://sourceforge.net/projects/leo/files/Leo/

**Installing Leo from sources**

1. Install Python: `Download Python`_, save to your desktop, then
   double-click on the saved file.

   Leo requires Python 2.6 or later, or Python 3.0 or later.

2. Install Qt. Install Qt. Get PyQt from: 
   http://www.riverbankcomputing.co.uk/software/pyqt/download

   The version of PyQt that you download must match the version of your Python.

3. Install Leo: Download the most recent .zip file from `Leo's
   download page`_ to your desktop or other location. Unzip the .zip
   file to the folder of your choice.
.. @+node:ekr.20101113132111.4925: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-002.html
.. @+node:ekr.20101014034526.5302: *3* @slide ((running Leo from a console
**Running Leo from a console**

To run Leo directly from a console, do the following:

1. Go to the Leo directory::

    cd <path-to-leo-directory>

2. Start launchLeo.py using Python::

    python launchLeo.py %*

.. @+node:ekr.20101014105353.5258: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-003.html
.. @+node:ekr.20101014034526.5303: *3* @slide ((scripts & .bat files
Using shell scripts (Linux) or .bat files (Windows)
can make it easier to open Leo files.

**Linux**

Put this in a shell script called leo::

    #!/bin/sh 
    python <path-to-leo-directory>launchLeo.py $1

**Windows**

Put this in leo.bat::

    cd <path-to-leo-folder>
    python <path-to-leo-folder>launchLeo.py %*

On either platform, the following will open x.leo::

    leo x.leo
.. @+node:ekr.20101014105353.5259: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-004.html
.. @+node:ekr.20101014034526.5304: *3* @slide ((.leoID.txt
The first time you start Leo, a dialog will ask you for a unique
identifier. This string helps ensure that each Leo node has a
unique identity.

This identifier can be any string 3 characters or more in length.
In a shared environment, a cvs or bzr login name works well.

Pick a string you don't mind making public: it will appear in
files that Leo creates.

Leo stores this identifier in the file ~/.leo/.leoID.txt.
You can change this identifier at any time by editing .leoID.txt.
.. @+node:ekr.20101014105353.5260: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-005.html
.. @+node:ekr.20100821182153.4350: *3* @slide ((free software
.. _`Edward K. Ream`:   http://webpages.charter.net/edreamleo/ekr.html
.. _`leo-editor`:       http://groups.google.com/group/leo-editor
.. _`Python Tutorial`:  http://docs.python.org/tutorial/

Leo is a free program distributed under the MIT license. This means that not
only can you use the program freely including commercially, the full
installation comes with source code that you can modify as you wish, as long as
you give credit to the author of the program, `Edward K. Ream`_.

Leo is written in Python--a full featured, powerful programming language that
is comparatively easy to learn and use. For an excellent introduction to Python
for non-programmers, see the `Python Tutorial`_. Not only is Leo written in Python, it is
scriptable via Python, meaning that you can embed Python commands in your
outlines and execute them.

Leo is under active development and all are welcome to contribute. For more
information, see the `leo-editor`_ Google Group.

Not only is Leo free software, it is supported software. Post questions and bug
reports to `leo-editor`_ Google Group.
.. @+node:ekr.20101014105353.5261: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-006.html
.. @+node:ekr.20101013072903.5224: ** @slideshow Leo basics step by step
@language rest
@pagewidth 50

(done) slide 5: could do with the same arrow as slide7
(done) slide 7:
  'one again' -> 'once again'
   if a node is no longer 'dirty', what is it - clean?
slide 13: 'ctrl-z' (lower-case), but elsewhere 'ctrl-H' (upper-case).
Stick with upper case for consistency?
.. @+node:ekr.20101113202201.4920: *3* @wink_path = ../doc/html/slides/leo-basics-step-by-step/_files
@nocolor-node

The directory containing the wink screenshots.
This will usually be <slideshow_dir>/_files.

**Important** You generate these screenshots using Wink's 
Export As Html command (!)
.. @+node:ekr.20101013072903.5225: *3* @slide ((no-slide
This is a step-by-step introduction to show you
how to use Leo outlines.

.. @+node:ekr.20101018190057.5370: *4* @no-screenshot
.. @+node:ekr.20101113211531.4918: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-001.html
.. @+node:ekr.20101013072903.5226: *3* @slide ((Open notebook file
.. The workbook.leo window.

Leo opens the **workbook file** when you start
Leo without a filename.

The body has focus--it is colored a pale pink, and
contains a blinking cursor.

**Note**: on some monitors the colors will be almost
invisible.  You can choose such colors to suit your
taste.

.. image:: slide-002.png

.. @+node:ekr.20101018190057.5441: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-002.png
.. @+node:ekr.20101113211531.4919: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-002.html
.. @+node:ekr.20101014110348.5286: *3* @slide ((Ctrl-H edits headline
Ctrl-H edits the presently selected headline.

You can type Ctrl-H at any time, regardless of
where the focus is.

The body pane is now blue, indicating that it no
longer has focus.

.. image:: slide-003.png

.. @+node:ekr.20101018190057.5442: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-003.png
.. @+node:ekr.20101113211531.4920: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-003.html
.. @+node:ekr.20101013072903.5234: *3* @slide (("to do" node
I typed "to do" in the headline.

.. image:: slide-004.png

.. @+node:ekr.20101018190057.5443: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-004.png
.. @+node:ekr.20101113211531.4921: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-004.html
.. @+node:ekr.20101018061243.5392: *3* @slide ((Return ends editing
Typing the <return> key ends editing of the headline
and puts focus back in the body pane.

Notice that the **icon box** to the left of the
headline now has a darker outline that it had
before. This indicates that the contents of the
node has been changed. We say the node is
**dirty**.

.. image:: slide-005.png

.. @+node:ekr.20101018190057.5444: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-005.png
.. @+node:ekr.20101113211531.4922: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-005.html
.. @+node:ekr.20101018061243.5393: *3* @slide ((no-slide focus keys
You can use Leo without ever using the mouse. For
instance, you can select any Leo pane by using
keystrokes instead of clicking the pane:

- Regardless of where the focus is, Alt-D puts
  focus in the body pane and Alt-T puts focus in
  the outline pane.

- With the focus in the tree pane, hitting the
  return key puts the focus in the body pane.

.. @+node:ekr.20101018190057.5373: *4* @no-screenshot
.. @+node:ekr.20101113211531.4923: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-006.html
.. @+node:ekr.20101014110348.5325: *3* @slide ((Ctrl-S saves outline
Ctrl-S saves the outline.

Notice that the icon box once again has a gray outline,
indicating that the node has not been changed since
the file was last saved.

.. Arrow to icon box.

.. image:: slide-007.png

.. @+node:ekr.20101018190057.5445: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-007.png
.. @+node:ekr.20101113211531.4924: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-007.html
.. @+node:ekr.20101013072903.5236: *3* @slide ((Ctrl-I inserts a new node
Ctrl-I inserts a new node.

.. image:: slide-008.png

.. @+node:ekr.20101018190057.5446: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-008.png
.. @+node:ekr.20101113211531.4925: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-008.html
.. @+node:ekr.20101013072903.5237: *3* @slide (("go shopping"
I typed "go shopping" followed by a return.

The focus is now in the body pane.

.. image:: slide-009.png

.. @+node:ekr.20101018190057.5447: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-009.png
.. @+node:ekr.20101113211531.4926: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-009.html
.. @+node:ekr.20101014110348.5305: *3* @slide ((typing text (icon box has blue square)
Whatever I type will appear in the body pane.

I added a shopping list.

The blue square in the icon area indicates that the body pane contains text.

.. Arrow at icon box.

.. buy milk
.. buy eggs.

.. image:: slide-010.png

.. @+node:ekr.20101018190057.5448: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-010.png
.. @+node:ekr.20101113211531.4927: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-010.html
.. @+node:ekr.20101013072903.5244: *3* @slide ((Ctrl-R
Ctrl-R moves a node right.

The "go shopping" node becomes a **child**
of the "to do" node.

The "to do" node is the **parent** node.

.. image:: slide-011.png

.. @+node:ekr.20101018190057.5449: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-011.png
.. @+node:ekr.20101113211531.4928: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-011.html
.. @+node:ekr.20101014110348.5290: *3* @slide ((Ctrl-L
Ctrl-L moves the "go shopping" node left.

The "go shopping" node becomes a **sibling**
of the "to do" node.

.. image:: slide-012.png

.. @+node:ekr.20101018190057.5450: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-012.png
.. @+node:ekr.20101113211531.4929: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-012.html
.. @+node:ekr.20101013072903.5245: *3* @slide ((undo/redo
Leo has unlimited undo/redo capabilities.

Here, I typed Ctrl-Z to undo the previous move.
The "go shopping" node is once again a child of
the "to do" node.

**Note**: Ctrl-Shift-Z redoes a previous undo.

.. image:: slide-013.png

.. @+node:ekr.20101018190057.5451: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-013.png
.. @+node:ekr.20101113211531.4930: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-013.html
.. @+node:ekr.20101014110348.5294: *3* @slide ((new node
Let's add a new node.  I hit Ctrl-I.

.. image:: slide-014.png

.. @+node:ekr.20101018190057.5452: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-014.png
.. @+node:ekr.20101113211531.4931: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-014.html
.. @+node:ekr.20101014110348.5295: *3* @slide (("fix car"
I type "fix car" followed by the <return> key.

.. image:: slide-015.png

.. @+node:ekr.20101018190057.5453: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-015.png
.. @+node:ekr.20101113211531.4932: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-015.html
.. @+node:ekr.20101014110348.5296: *3* @slide ((Ctrl-U
I decide that fixing the car should have first priority.

I type Ctrl-U to move the "fix car" node up.
It becomes the first child of the "to do" node.

.. image:: slide-016.png

.. @+node:ekr.20101018190057.5454: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-016.png
.. @+node:ekr.20101113211531.4933: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-016.html
.. @+node:ekr.20101014110348.5297: *3* @slide ((contracting nodes
After creating the to-do list, I want to hide it
by **collapsing** the "to do" node.

I could do that by clicking the black triangle
to the left of the "to do" node.

However, using the mouse is not recommended--
there are much easier ways.

.. arrow points to black triangle.

.. image:: slide-017.png

.. @+node:ekr.20101018190057.5455: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-017.png
.. @+node:ekr.20101113211531.4934: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-017.html
.. @+node:ekr.20101014110348.5298: *3* @slide ((Up-Arrow
The focus is in the tree pane, so I can select the "to do"
node merely by using the Up-Arrow key.

If, for some reason, the focus is in the body pane,
I can select the previous node in either of two ways:

1. Type Alt-T to put focus in the tree pane
   followed by the Up-Arrow key.

2. Type Alt-Up-Arrow.  This selects the previous
   node and also puts focus in the tree pane.

Now the "to do" node is selected.

.. image:: slide-018.png

.. @+node:ekr.20101018190057.5456: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-018.png
.. @+node:ekr.20101113211531.4935: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-018.html
.. @+node:ekr.20101014110348.5299: *3* @slide ((Left-Arrow
With the "to-do" node selected,
hitting the Left-Arrow key will contract the node.

.. "to do" contracted.

.. image:: slide-019.png

.. @+node:ekr.20101018190057.5457: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-019.png
.. @+node:ekr.20101113211531.4936: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-019.html
.. @+node:ekr.20101014110348.5300: *3* @slide ((20 Right-Arrow
To expand the "to do" node,
I merely hit the Right-Arrow key.

We can now see the entire to-do list.

.. image:: slide-020.png

.. @+node:ekr.20101018190057.5458: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-020.png
.. @+node:ekr.20101113211531.4937: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-020.html
.. @+node:ekr.20101014110348.5309: *3* @slide ((no-slide Arrow keys: summary
The arrow keys do different things depending on
which pane has focus. Using arrow keys is **much**
easier than using the mouse.

**Focus in outline pane**

    The **plain** arrow keys **select** nodes,
    expanding or contracting nodes as needed.

    The **shift** arrow keys **move** nodes. The
    Shift-Left-Arrow and Shift-Up-Arrow contract
    nodes as needed. **Note**: the
    Shift-Down-Arrow and Shift-Right-Arrow keys
    never expand nodes.

**Focus in body pane**

    As usual, the **plain** arrow keys move the
    cursor and the **shift** arrow keys move the
    cursor and extend the solution.

    The **alt** arrow keys move the focus to the
    outline pane and then select nodes. The
    **alt-shift** arrow keys move the focus to the
    outline pane and then move nodes.

..  - The Up-Arrow and Down-Arrow keys select
..  the previous or next visible nodes.

..  - The Right-Arrow key contracts a node if the node
..  is expanded. Otherwise the Right-Arrow key
..  selects the node's parent.

..  - The Left-Arrow key does nothing if the selected
..  node has no children.  If the node does have
..  children, the Left-Arrow key expands the node
..  (if the children or invisible) or selects the
..  first child (if the children are visible).

..  This is exactly how Windows explorer works, and
..  it quickly becomes second nature.

.. @+node:ekr.20101014110348.5323: *4* @no-screenshot
.. @+node:ekr.20101113211531.4938: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-021.html
.. @+node:ekr.20101014110348.5326: *3* @slide ((Shift-Ctrl-C copies
We can copy and paste nodes and all their descendants.

Using the arrow keys as necessary, I select the
"to do" node.

The Shift-Ctrl-C key copies the selected outline.

I want to do the paste *after* the to-do list, so I collapse
the original node before doing the paste:

.. image:: slide-022.png

.. @+node:ekr.20101018190057.5459: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-022.png
.. @+node:ekr.20101113211531.4939: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-022.html
.. @+node:ekr.20101018061243.5397: *3* @slide ((The pasted node
And here is the pasted node.

.. image:: slide-023.png

.. @+node:ekr.20101018190057.5460: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-023.png
.. @+node:ekr.20101113211531.4940: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-023.html
.. @+node:ekr.20101018061243.5394: *3* @slide ((expanding the pasted node
Expanding the node shows that the copy operation
copied the node and all its descendants.

.. image:: slide-024.png

.. @+node:ekr.20101018190057.5461: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-024.png
.. @+node:ekr.20101113211531.4941: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-024.html
.. @+node:ekr.20101014110348.5336: *3* @slide ((no-slide end slide
This concludes the step-by-step introduction to
Leo's outlines.

You now know how to do the following:

- Create new nodes.
- Edit the headline and body text of any node.
- Reorganize nodes. 
- Expand and contract nodes.
- Copy and paste nodes and their descendants.

Mastering these skills is essential to using Leo
effectively and enjoyably.

.. @+node:ekr.20101018061243.5395: *4* @no-screenshot
.. @+node:ekr.20101113211531.4942: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-025.html
.. @-all
.. @-leo
