.. @+leo-ver=5-thin
.. @+node:ekr.20101028110015.8271: * @file slideshows.txt
.. @+all
.. @+node:ekr.20101009111520.4525: **  Slideshow Buttons
.. @+node:ekr.20101009114655.4531: *3* @button make-slide @key=Alt-8
m = g.loadOnePlugin('screenshots')
m.make_slide_command(event={'c':c})
.. @+node:ekr.20101109053515.4915: *3* Unused
.. @+node:ekr.20101008061729.4425: *4* @@button ins-@slide-nodes
'''Create @slide nodes under p, an @slideshow node.'''

n = 23 # Number of last slide to be created.

existing = [z.copy().h for z in p.children() 
    if g.match_word(z.h,0,'@slide')]

if g.match_word(p.h,0,'@slideshow'):
    b = c.undoer.beforeChangeTree(p)
    changed = False
    for n in range(1,n+1):
        h = '@slide %03d' % n
        if h not in existing:
            changed = True
            child = p.insertAsLastChild()
            child.h = h
            g.note('created %s' % h)
    if changed:
        c.undoer.afterChangeTree(p,'ins-@slide-nodes',b)
    else:
        g.note('no @slide nodes inserted')
    c.redraw()
else:
    g.error('not an @slideshow node',p.h)
.. @+node:ekr.20101008061729.4443: *4* @@button copy-@screenshot-node
'''
Copy the @screenshot node (a child of this node)
to all @slide nodes under p, (an @slideshow node),
that do not contain an @screenshot node.
'''

error = None
# Find this node:
h = '@button copy-@screenshot-node'
p2 = g.findNodeAnywhere(c,h)
if not p2:
    error = 'Can not find',p.h
# Find the @screenshot tree and the optional @select node.
if not error:
    select,template = None,None
    for child in p2.children():
        if g.match_word(child.h,0,'@screenshot'):
            template = child.copy()
        if g.match_word(child.h,0,'@select'):
            select = child.copy()
    if not template:
        error = 'No template @slideshow node in %s' % p2.h
if not error:
    if not g.match_word(p.h,0,'@slideshow'):
        error = 'not an @slideshow node',p.h
if error:
    g.error(error)
else:
    c.selectPosition(template)
    c.copyOutline()
    changed = False
    b = c.undoer.beforeChangeTree(p)
    for child in p.children():
        if not g.match_word(child.h,0,'@slide'):
            continue
        for grandChild in child.children():
            if g.match_word(grandChild.h,0,'@screenshot'):
                break
        else:
            changed = True
            p3 = child.insertAsLastChild()
            c.selectPosition(p3)
            c.pasteOutline()
            g.note('copied @screenshot to %s' % child.h)
            if select:
                c.selectPosition(p3)
                p4 = child.insertAsLastChild()
                p4.h = select.h
                g.note('copied %s to %s' % (select.h,child.h))
            c.selectPosition(p3)
            c.deleteOutline(p3)
            child.contract()
    if changed:
        c.undoer.afterChangeTree(p,'copy-@screenshot',b)
    c.redraw()
.. @+node:ekr.20101008061729.4552: *5* @screenshot
.. @+node:ekr.20101008061729.4553: *6* To Do List
My to-do list.
.. @+node:ekr.20101008061729.4554: *7* Urgent
1. Make Leo tutorials.  The world is waiting.
2. Pay phone bill or the world will never know.
.. @+node:ekr.20101008061729.4555: *7* Important
.. @+node:ekr.20101008061729.4556: *7* Soon
.. @+node:ekr.20101008061729.4557: *7* Whenever
.. @+node:ekr.20101008061729.4558: *6* Diary
.. @+node:ekr.20101008061729.4559: *7* 2009
@language rest

This is my diary.
.. @+node:ekr.20101008061729.4567: *8* Jul 2009
July 1
    Started writing in my diary.
July 2
    Wrote another sentence in my diary.
July 3
    Keeping my diary very regularly.
July 5
    Oops...Yesterday I forgot towrite in my diary.
.. @+node:ekr.20101008061729.4568: *8* Aug 2009
.. @+node:ekr.20101008061729.4569: *8* Sep 2009
.. @+node:ekr.20101008061729.4570: *8* Oct 2009
.. @+node:ekr.20101008061729.4571: *8* Nov 2009
.. @+node:ekr.20101008061729.4572: *8* Dec 2009
.. @+node:ekr.20101008061729.4561: *7* 2010
.. @+node:ekr.20101008061729.4637: *5* @select Urgent
.. @+node:ekr.20101008061729.4538: *4* @@button renumber nodes
'''Renumber @slide nodes under p, an @slideshow node.'''

if g.match_word(p.h,0,'@slideshow'):
    n = 1
    for child in p.children():
        if g.match(child.h,0,'@slide'):
            child.h = '@slide %03d' % n
            n += 1
    c.redraw()
else:
    g.error('not an @slideshow node',p.h)
.. @+node:ekr.20101007100904.4371: *4* @@button make-slide-show @key=Alt-8
m = g.loadOnePlugin('screenshots')
m.make_slide_show_command(event={'c':c})
.. @+node:ekr.20101021092135.5431: **  Slideshows to create
.. @+node:ekr.20101113110328.4947: *3* Using @button nodes
.. @+node:ekr.20101113110328.4945: *3* Top 10 coolest features
.. @+node:ekr.20101113110328.4946: *3* How to make slide shows
.. @+node:ekr.20101014034526.5298: *3* User-defined types
.. @+node:ekr.20101014034526.5292: *4* \@button nodes
.. @+node:ekr.20101014034526.5291: *4* @test nodes
.. @+node:ekr.20101014034526.5293: *4* @url nodes
.. @+node:ekr.20101014034526.5294: *3* IPython
- Execute IPython scripts from Leo.
- Execute Leo scripts from IPython.
.. @+node:ekr.20101014034526.5295: *3* Vim & Emacs
.. @+node:ekr.20101010141953.5027: *3* Examples
.. @+node:ekr.20101010141953.5028: *3* @slideshow Leo's NSIS Installer
@language rest
.. @+node:ekr.20101010141953.5029: *4* @title_pattern = Leo's NSIS Installer: Slide %(slide_number)s
.. @+node:ekr.20101010141953.5030: *4* @slide 001
.. _`here`:     http://www.nullsoft.com/free/nsis/
.. _`Winamp`:   http://www.winamp.com/

Nullsoft, the makers of the `Winamp`_ MP3 software, have released a powerful free
installer called NSIS, available `here`_. This application allows you to make
installation packages for Windows applications.

You create NSIS packages by writing a NSIS script and then compiling it.
Depending on the application, NSIS can often be a better choice than more
expensive installation generators, since NSIS installations are easy to create,
are small and fast, and yet can be configured with many features.

.. @+node:ekr.20101010141953.5031: *4* @slide 002
When you install Leo, you'll find that it comes with a script for generating an
installer for Leo. This script is called leo-<version>.nsi, and is distributed
in the Leo file leo/dist/leoDist.leo.

If you have NSIS installed, right-clicking on a .nsi file will give you the
option of compiling the script to create a package.

.. image:: slide-002.png

.. @+node:ekr.20101010141953.5032: *5* @screenshot
.. @+node:ekr.20101010141953.5033: *6* Take screenshot of the compile .nsi dialog in a Windows folder
.. @+node:ekr.20101010141953.5034: *5* @pause
.. @+node:ekr.20101010141953.5038: *5* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/leos-nsis-installer/screenshot-002.png
.. @+node:ekr.20101010141953.5039: *5* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/leos-nsis-installer/screenshot-002.svg
.. @+node:ekr.20101010141953.5040: *5* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leos-nsis-installer/slide-002.png
.. @+node:ekr.20101011071655.4918: *5* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leos-nsis-installer\_build\html\slide-002.html
.. @+node:ekr.20101011092154.4923: *4* @slide 003
Since the NSIS script for the Leo installation is included in the Leo
distribution in the nsis.leo file, it is easy to understand the how the script
works. This .nsi file creates an installer that packages all of the Leo program
files, and creates a desktop shortcut, a Program Menu item, and the file
association for .leo files.
.. @+node:ekr.20101011092154.4924: *4* @slide 004
In this screenshot we're looking at the code that checks to see whether Python
has been installed.

Since Leo is a Python application, modifying this installation script to create
a script to build a Windows installer for your own Python application is
relatively simple. You would leave this section alone, and check other sections
for the program name "Leo", and change these to your program name.
.. @+node:ekr.20101011092154.4925: *4* @slide 005
.. @+node:ekr.20101011165412.5154: *4* @@button make leo.nsi
@language python

# **Important**
#   Before running this script you must create bzr-manifest as follows::
#       cd to trunk
#       bzr ls -R >bzr-manifest.txt

'''Create the installer script using bzr-manifest.txt.'''

import os,string,sys
<< define version >>
<< define inLeo >>

if inLeo:
    # The root directory contains the leo directory.
    rootDir  = g.os_path_finalize_join(g.app.loadDir,'..','..')
    manifest = g.os_path_finalize_join(rootDir,'bzr-manifest.txt')
else:
    rootDir = os.path.abspath(os.curdir)
    manifest = os.path.normpath(os.path.join(rootDir,'bzr-manifest.txt'))

<< define application constants >>
@others

nsi = nsiWriter()
nsi.run(manifest)
.. @+node:ekr.20101011165412.5155: *5* << define version >>
# Used by both @button make leo.nsi and @button make leo.zip.
app_version = version = '4.8-d1'
.. @+node:ekr.20101011165412.5156: *5* << define inLeo >>
try:
    inLeo = g is not None
except AttributeError:
    inLeo = False

# print('inLeo',inLeo)
.. @+node:ekr.20101011165412.5157: *5* << define application constants >>
app_doc_icon = r'Icons\LeoDoc.ico'
app_extension = '.leo'
app_hkey_local_machine = r'SOFTWARE\EKR\leo'
app_icon = r"%s\leo\Icons\leo_inst.ico" % rootDir
app_icon2 = r'leo\Icons\LeoApp.ico' # Relative to install dir.
app_license = r'%s\License.txt' % rootDir
app_lower_case_name = 'leo'
app_name = 'Leo'
app_publisher = 'Edward K. Ream'
app_python_executable = 'launchLeo.py'
app_uninst_key = r"Software\Microsoft\Windows\CurrentVersion\Uninstall\leo"
app_uninst_root_key = 'HKLM'
app_web_site = 'http://webpages.charter.net/edreamleo/front.html'

nsi_name = 'leo-%s.nsi' % app_version
target_file = 'LeoSetup-%s.exe' % app_version

substitutionDict = {
    'doc_icon': app_doc_icon,
    'ext': app_extension,
    'exe': app_python_executable,
    'hkey_local_machine': app_hkey_local_machine,
    'icon': app_icon,
    'icon2': app_icon2,
    'license': app_license,
    'lower_name': app_lower_case_name,
    'name': app_name,
    'nsi_name': nsi_name,
    'publisher': app_publisher,

    'site': app_web_site,
    'target_file': target_file,
    'uninst_key': app_uninst_key,
    'uninst_root_key': app_uninst_root_key,
    'version': app_version,
    # Leave these unchanged.
    'DESKTOP': '$DESKTOP',
    'INSTDIR': '$INSTDIR',
    'NSISDIR': '${NSISDIR}',
    'PROGRAMFILES': '$PROGRAMFILES',
    'PythonExecutable': '$PythonExecutable',
    'SMPROGRAMS': '$SMPROGRAMS'
}
.. @+node:ekr.20101011165412.5158: *5* class nsiWriter
class nsiWriter:

    '''A class to write .nsi scripts.'''

    @others
.. @+node:ekr.20101011165412.5159: *6* genScript & helpers
def genScript (self,dirs,dirDict,filesDict):

    '''Generate the .nsi installer script.'''

    self.f = f = self.openNsi()
    if not f: return

    try:
        self.genHead()
        self.genInstallData(dirs,dirDict,filesDict)
        self.genMiddle()
        self.genUninstallData(dirs,dirDict,filesDict)
    finally:
        f.close()

    g.es_print('make-leo-nsi done. no errors')
.. @+node:ekr.20101011165412.5160: *7* genHead
def genHead (self):

    '''Generate the boilerplate appearing before
    the manifest-specific install data.'''

    self.put('!include MUI2.nsh\n')
    self.putSettings()
    self.putOnInit()
.. @+node:ekr.20101011165412.5161: *8* putSettings
def putSettings (self):

    s = r'''
; Location of Pythonw.exe. Set by .onInit.
var PythonExecutable

SetCompressor bzip2
Caption "${name} Installer"
AutoCloseWindow false 
SilentInstall normal
CRCCheck on ; FIXME shouldn't this be CRCCheck force ? Why give user option of using corrupted installer?
SetCompress auto ; FIXME this is disabled for solid compression, which comes with BZip2 and LZMA compression
SetDatablockOptimize on
; SetOverwrite ifnewer
WindowIcon off
OutFile "${target_file}"
LoadLanguageFile "${NSISDIR}\Contrib\Language files\English.nlf"
; Default location.  May be changed in .onInit.
InstallDir "${PROGRAMFILES}\${name}-${version}"
Icon "${icon}"
DirText "Setup will install ${name}-${version} in the following folder. $$\n\
To install in a different folder, click Browse and select another folder."
LicenseText "You must accept the agreement to install ${name}-${version}."
LicenseData "${license}"
ShowInstDetails show
ShowUnInstDetails show

'''
    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5162: *8* putOnInit
def putOnInit (self):

    s = r'''

; Set PythonExecutable to full path to Pythonw.exe.
Function .onInit
    ReadRegStr $9 HKLM "SOFTWARE\Python\PythonCore\2.6\InstallPath" ""
    StrCmp $9 "" tryPython31 ok

tryPython31:
    ReadRegStr $9 HKLM "SOFTWARE\Python\PythonCore\3.1\InstallPath" ""
    StrCmp $9 "" oops ok

oops:
    MessageBox MB_OK "Python not found: using c:\python26"
    ; Guess where Python 26 is.
    StrCpy $PythonExecutable "c:\Python26\pythonw.exe"
    ; Fallback installation directory is "Program Files"
    Goto done
ok:
    MessageBox MB_OK "Found Python at $9"
    StrCpy $PythonExecutable "$9\pythonw.exe"
    ; Normal installation directory 
    StrCpy $INSTDIR "$9\Lib\site-packages\${name}-${version}"
done:

; End .onInit
FunctionEnd
'''
    s = s.replace('${name}',app_name).replace('${version}',app_version)
    self.put(s,substitute=False)
.. @+node:ekr.20101011165412.5163: *7* genInstallData & helpers
def genInstallData(self,dirs,dirDict,filesDict):

    '''Generate the manifest-specific install data.'''

    self.put('\nSection "%s" SEC01\n\n' % (app_name))

    self.put(self.getInstallVariableData(
        dirs,dirDict,filesDict),adjust=False)

    self.put('\n; end %s section\n' % (app_name))
    self.put('SectionEnd\n')
.. @+node:ekr.20101011165412.5164: *8* getInstallVariableData
def getInstallVariableData (self,dirs,dirDict,filesDict):

    global rootDir
    result = []

    # Top level
    theDir = '**top'
    result.append('; top-level\n')
    result.append('SetOutPath "$INSTDIR"\n')
    result.append('SetOverwrite ifnewer\n')
    aList = dirDict.get(theDir,[])
    for fn in aList:
        result.append('File "%s"\n' % fn)

    for theDir in dirs:
        if theDir != '**top':
            aList = dirDict.get(theDir,[])
            if aList:
                theDir2 = theDir.replace('/','\\').rstrip('\\')
                result.append('\n')
                result.append('SetOutPath $INSTDIR\\%s\n' % theDir2)
                for fn in aList:
                    # Fix bug 425369: quote file names.
                    result.append('File "%s\\%s\\%s"\n' % (
                        rootDir,theDir2,fn))

    result = [self.indent(z) for z in result]
    return ''.join(result)
.. @+node:ekr.20101011165412.5165: *7* genMiddle
def genMiddle (self):

    '''Generate the boilerplate appearing between
    the manifest-specific install data and
    the manifest-specific uninstall data.'''

    self.genMenuShortcuts()
    self.genDesktopShortcuts()
    self.genFileAssociation()
    self.genAdditionalIcons()
    self.genPost()
    self.genUninstallSettings()
    self.genMiddleFunctions()
.. @+node:ekr.20101011165412.5166: *8* genAdditionalIcons
def genAdditionalIcons(self):

    s = r'''
Section -AdditionalIcons
  SetOutPath $INSTDIR
  CreateDirectory "${SMPROGRAMS}\${name}"
  CreateShortCut "${SMPROGRAMS}\${name}\Uninstall.lnk" "$INSTDIR\uninst.exe"
SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5167: *8* genDesktopShortcuts
def genDesktopShortcuts(self):

    s = r'''
Section "Desktop Shortcut" SEC03
  CreateShortCut "${DESKTOP}\${name}.lnk" '"${PythonExecutable}"' '"$INSTDIR\${exe}"' "$INSTDIR\${icon2}" 0
SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5168: *8* genFileAssociation
def genFileAssociation(self):

    s = r'''
Section "${ext} File Association"
  SectionIn 1
  SectionIn 2
  SectionIn 3

  # back up old value of extension in case some other program was using it
  ReadRegStr $$1 HKCR "${ext}" ""
  StrCmp $$1 "" Label1
  StrCmp $$1 "${name}File" Label1
  WriteRegStr HKCR "${ext}" "backup_val" $$1

Label1:
  WriteRegStr HKCR "${ext}" "" "${name}File"
  WriteRegStr HKCR "${name}File" "" "${name} File"
  WriteRegStr HKCR "${name}File\shell" "" "open"
  WriteRegStr HKCR "${name}File\DefaultIcon" "" ${INSTDIR}\${doc_icon}
  WriteRegStr HKCR "${name}File\shell\open\command" "" '"${PythonExecutable}" "${INSTDIR}\${exe}" "%1"'

SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5169: *8* genMenuShortcuts
def genMenuShortcuts (self):

    s = r'''
; FIXME $SMPROGRAMS depends on the value of SetShellVarContext. Since that defaults to 'current'
; that means that this installer will make the app available for the current user only.
; Unless I am grossly mistaken this is a needless hindrance, and a Bad Thing since
; security concerns are such that it would be best to not run the app with the Administrator privileges
; of the account used to install the software.
;
; Sure enough, the Start Menu Shortcuts and Desktop Shortcut work for the installer account only. 
;
; Question is -- do we want the app always available for any log-in on this computer?
;
; My guesses:
; Ideally, Uninstall.lnk should appear only for the current user, and the uninstaller should refuse to run
; if run by a user who lacks Admin privileges on Windows NT and its descendants
;
; How will Windows XP Home deal with that? 

Section "Start Menu Shortcuts" SEC02
    CreateDirectory "${SMPROGRAMS}\${name}"
    CreateShortCut "${SMPROGRAMS}\${name}\Uninstall.lnk" "${INSTDIR}\uninst.exe" "" "${INSTDIR}\uninst.exe" 0
    CreateShortCut "${SMPROGRAMS}\${name}\${name}.lnk" '"${PythonExecutable}"' '"${INSTDIR}\${exe}"' "${INSTDIR}\${icon2}" 0
SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5170: *8* genMiddleFunctions
def genMiddleFunctions (self):

    s = r'''
Function un.onUninstSuccess
  HideWindow
  MessageBox MB_ICONINFORMATION|MB_OK "${name}-${version} was successfully removed from your computer."
FunctionEnd

Function un.onInit
  MessageBox MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2 \
  "Are you sure you want to completely remove ${name}-${version} and all of its components?" IDYES +2
  Abort
FunctionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5171: *8* genPost
def genPost (self):

    s = r'''
Section -Post
  WriteRegStr HKEY_LOCAL_MACHINE "${hkey_local_machine}" "" "$INSTDIR"
  WriteUninstaller "$INSTDIR\uninst.exe"
  WriteRegStr ${uninst_root_key} "${uninst_key}" "DisplayName" "${name}-${version} (remove only)"
  WriteRegStr ${uninst_root_key} "${uninst_key}" "UninstallString" "${INSTDIR}\uninst.exe"
  WriteRegStr ${uninst_root_key} "${uninst_key}" "DisplayVersion" "${version}"
  WriteRegStr ${uninst_root_key} "${uninst_key}" "URLInfoAbout" "${site}"
  WriteRegStr ${uninst_root_key} "${uninst_key}" "Publisher" "${publisher}"
SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5172: *8* genUninstallSettings
def genUninstallSettings(self):

    path = g.os_path_finalize_join(
        g.app.loadDir,'..','Icons','uninst.ico')

    s = r'''
UninstallCaption "Uninstall ${name}"
UninstallIcon "${path}"
'''

    s = s.replace('${path}',path)
    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5173: *7* genUninstallData & helpers
def genUninstallData(self,dirs,dirDict,filesDict):

    '''Generate the manifest-specific uninstall data.'''

    s = r'''
Section Uninstall

    DeleteRegKey HKEY_LOCAL_MACHINE "${hkey_local_machine}"

    ; Delete files & directories only if we own them!
    ReadRegStr $$1 HKCR "${ext}" ""
    StrCmp $$1 "${name}File" 0 FinishUninstall

    ; Delete files & directories only if there is no backup_val key.
    ReadRegStr $$1 HKCR "${ext}" "backup_val"
    StrCmp $$1 "" 0 DeleteLeoKeysAndFiles
      DeleteRegKey HKCR "${ext}"
    Goto FinishUninstall

DeleteLeoKeysAndFiles:
    WriteRegStr HKCR "${ext}" "" $$1
    DeleteRegValue HKCR "${ext}" "backup_val"

    ; ---- Start of manifest-related data...
'''

    self.put(s,substitute=True)

    # Does all the hard work.
    self.put(
        self.getUninstallVariableData(dirs,dirDict,filesDict),
        adjust = False)

    s = r'''
    ; ---- End of manifest related data.

FinishUninstall:
    ; MessageBox MB_YESNO|MB_ICONQUESTION \
    ;    "Delete all files in ${INSTDIR}?" IDNO NoDelete
; NoDelete:

  Delete "${SMPROGRAMS}\${name}\Uninstall.lnk"
  RMDir "${SMPROGRAMS}\${name}-${version}"
  Delete "${DESKTOP}\${name}.lnk"

  DeleteRegKey ${uninst_root_key} "${uninst_key}"
  SetAutoClose false

; end Uninstall section
SectionEnd
'''

    self.put(s,substitute=True)
.. @+node:ekr.20101011165412.5174: *8* getDeleteDirectories
def getDeleteDirectories (self,dirs,dirDict):

    reverseDirs = dirs[:]
    reverseDirs.reverse()

    result = []
    result.append('; Uninstall directories in reverse order\n')
    for theDir in reverseDirs:
        # Delete the directory even if it has no files.
        if theDir and theDir != '**top':
            if not theDir.startswith('.bzr'):
                result.append('RMDir "$INSTDIR\\%s"\n' % (
                    theDir.replace('/','\\')))

    # top-level folder.
    result.append('RMDir "$INSTDIR"\n')

    result = [self.indent(z) for z in result]
    return ''.join(result)
.. @+node:ekr.20101011165412.5175: *8* getDeleteFiles
def getDeleteFiles (self,dirs,dirDict,filesDict):

    wildcard_delete = True
    result = []
    result.append('; Uninstall files...\n\n')

    # top-level files.
    result.append('; Delete top-level files...\n')
    aList = dirDict.get('**top',[])
    # special case.
    aList.append('uninst.exe')
    # Warning: **never** delete all files in the top-level directory.
    for fn in aList:
        result.append('Delete "$INSTDIR\\%s"\n' % fn)
    if wildcard_delete:
        result.append('\n')

    for theDir in dirs:
        if theDir:
            dir2 = theDir.replace('/','\\')
            if wildcard_delete:
                result.append('Delete "$INSTDIR\\%s\\*.*"\n' % (dir2))
            else:
                aList = dirDict.get(theDir,[])
                if aList:
                    result.append('\n')
                    result.append('Delete "$INSTDIR\\%s\\*.pyc"\n' % (dir2))
                    result.append('Delete "$INSTDIR\\%s\\*.pyo"\n' % (dir2))
                for fn in aList:
                    result.append('Delete "$INSTDIR\\%s\\%s"\n' % (
                        dir2,fn))

    result = [self.indent(z) for z in result]
    return ''.join(result)
.. @+node:ekr.20101011165412.5176: *8* getUninstallVariableData
def getUninstallVariableData(self,dirs,dirDict,filesDict):

    s1 = self.getDeleteFiles(dirs,dirDict,filesDict)
    s2 = self.getDeleteDirectories(dirs,dirDict)
    return '%s\n%s' % (s1,s2)
.. @+node:ekr.20101011165412.5177: *7* indent
def indent(self,s):

    if s.strip():
        return '    ' + s
    else:
        return s
.. @+node:ekr.20101011165412.5178: *7* openNsi
def openNsi (self):

    path = g.os_path_finalize_join(
        g.app.loadDir,'..','..',nsi_name)

    try:
        f = open(path,'w')
    except IOError:
        f = None
        g.es_print('Can not open',path,color='red')

    return f
.. @+node:ekr.20101011165412.5179: *7* put
def put (self,s,adjust=True,substitute=False):

    '''Output s to the nsi file, optionally making
    the substitutions given in substitutionDict.'''

    trace = False
    if adjust:
        s = self.adjustTripleString(s)

    if substitute:
        if 0:
            n = 1
            for z in g.splitLines(s):
                print('%3s %s' % (n,z.rstrip()))
                n += 1
        s = string.Template(s)
        s = s.substitute(substitutionDict)

    if trace: g.trace(s,g.callers(4))
    self.f.write(s)
.. @+node:ekr.20101011165412.5180: *6* run & helpers
def run (self,fn):

    '''The top-level logic.'''

    # Create and filter the list of files from the manifest.
    s = open(fn).read()
    lines = g.splitLines(s)
    files = self.filterLines(lines)

    # Compute the list of all the directories.
    dirs = self.directoryList(rootDir)

    # Compute dictionaries of directories and files.
    dirDict,filesDict = self.makeDicts(dirs,files)

    # Print manifest lines not in either dict.
    # This is a crucial check.
    errors = self.printMissing(files,dirDict,filesDict)
    if errors: return

    # Generate the script!
    self.genScript(dirs,dirDict,filesDict)
.. @+node:ekr.20101011165412.5181: *7* directoryList
def directoryList (self,rootDir):

    '''Compute a top-down list of all directories.
       These directories start at the top-level directory.'''

    trace = False
    ignoreDirs = ('.bzr',)
    # Important: this adds all directories on EKR's machine,
    # regardless of whether they appear in the manifest!
    result = [] ; n = len(rootDir)
    for z in os.walk(rootDir): # top-down traversal.
        dirpath, dirnames, filenames = z
        assert dirpath.startswith(rootDir),z
        if len(dirpath) > n:
            path = dirpath[n+1:].replace('\\','/')
            result.append(path)
    for z2 in ignoreDirs:
        result = [ z for z in result if not z.startswith(z2)]
    if trace:
        g.trace('-' * 40)
        g.trace(g.listToString(result))
    return result
.. @+node:ekr.20101011165412.5182: *7* filterLines & helpers
def filterLines (self,lines):

    '''Filter lines from the input manifest file.'''

    trace = False

    # Remove blank lines, comments, and .pyc and .pyo files.
    lines = self.deleteBlankLines(lines)
    lines = self.deleteComments(lines)
    lines = self.deleteExt(lines,'.pyc')
    lines = self.deleteExt(lines,'.pyo')
    lines = self.deleteExt(lines,'.zip') # Don't include the zip file.
    lines = self.deleteExt(lines,'.exe') # Don't include the installer.

    # Remove specific files.
    deleteList = (
        '.bzrignore',
        'bzr-manifest.txt',
        'bzr-small-manifest.txt',
        'setup.py',
        'leo/test/unittest/.leo_shadow/',
        'nsi.log.txt', # Can't write log while we are creating it.
        'leo/core/leoPy.leo',
        'leo/core/ekrLeoPy.leo',
    )
    lines = self.deleteFiles(lines,deleteList)
    if lines and lines[0].endswith('bzr ls -R'):
        lines = lines[1:]

    if trace:
        g.trace('=' * 40)
        g.trace(g.listToString(lines))

    return lines
.. @+node:ekr.20101011165412.5183: *8* delete...
def deleteBlankLines (self,lines):

    return [z.strip() for z in lines if z.strip()]

def deleteComments (self,lines):

    return [z for z in lines if not z.startswith('#')]

def deleteExt (self,lines,ext):

    return [z for z in lines if not z.endswith(ext)]

def deleteFiles (self,lines,deleteList):

    return [z for z in lines if not z in deleteList]
.. @+node:ekr.20101011165412.5184: *7* makeDicts
def makeDicts (self,dirs,lines):

    trace = False ; verbose = False

    # Create the dirDict.
    # Keys are directories.
    # Values are files contained in each directory.
    dirDict = {}
    dirDict['**top'] = [] # Create an entry for the root directory.
    for z in dirs:
        dirDict[z] = []

    # Assign files to dirDict.
    for line in lines:
        line = line.strip().replace('\\','/')
        if line in dirDict.keys():
            path,fn = None,None
        elif line.startswith('leo/'):
            path,fn = g.os_path_split(line)
        else:
            path,fn = '**top',line.strip()

        # Don't include top-level leo directory,
        # Do include leo/scripts/leo file.
        if fn and (path != '**top**' or fn != 'leo'):
            aList = dirDict.get(path,[])
            assert line not in aList,repr(line)
            aList.append(fn)
            dirDict[path]=aList

    for theDir in sorted(dirDict):
        aList = dirDict.get(theDir)
        if aList and trace:
            if verbose:
                print() ; print(theDir)
                print(g.listToString(aList))
            else:
                print(theDir)

    # Create the inverse dict.
    filesDict = {}
    for theDir in sorted(dirDict):
        aList = dirDict.get(theDir)
        for fn in aList:
            path = g.choose(theDir=='**top',
                fn,'%s/%s' % (theDir,fn))
            filesDict[path] = theDir

    return dirDict,filesDict
.. @+node:ekr.20101011165412.5185: *7* printMissing
def printMissing (self,files,dirDict,filesDict):

    errors = 0

    for fn in files:
        fn = fn.rstrip('/')
        if fn and fn not in dirDict and fn not in filesDict:
            g.es_print('missing',fn,color='red')
            errors += 1

    if errors:
        g.es_print('%s errors' % (errors),color='red')

    return errors
.. @+node:ekr.20101011165412.5186: *6* whitespace
# These are adapted from the corresponding functions in leoPy.leo
# They are defined here to make this script independent of Leo
.. @+node:ekr.20101011165412.5187: *7* adjustTripleString
def adjustTripleString (self,s):

    '''Remove leading indentation from a triple-quoted string.'''

    # Compute the minimum leading whitespace of all non-blank lines.
    lines = self.splitLines(s)
    w = 0 ; val = -1
    for line in lines:
        if line.strip():
            lws = self.get_leading_ws(line)
            w2 = self.computeWidth(lws)
            # The sign of w does not matter.
            if w == 0 or abs(w2) < w:
                w = abs(w2)

    if w == 0: return s

    # Remove the leading whitespace.
    result = [self.removeLeadingWhitespace(line,w) for line in lines]
    result = ''.join(result)
    return result
.. @+node:ekr.20101011165412.5188: *7* get_leading_ws
def get_leading_ws(self,s):

    """Returns the leading whitespace of 's'."""

    i = 0 ; n = len(s)
    while i < n and s[i] in (' ','\t'):
        i += 1
    return s[0:i]
.. @+node:ekr.20101011165412.5189: *7* computeWidth
def computeWidth (self,s):

    '''Return the width of s, assuming s starts a line.'''

    tabwidth = 4
    w = 0
    for ch in s:
        if ch == '\t':
            w += tab_width - (w % tab_width)
        else:
            w += 1
    return w
.. @+node:ekr.20101011165412.5190: *7* removeLeadingWhitespace
def removeLeadingWhitespace (self,s,first_ws):

    '''Remove whitespace up to first_ws wide in s.'''

    j = 0 ; ws = 0
    tabwidth = 4
    first_ws = abs(first_ws)
    for ch in s:
        if ws >= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += tab_width - (ws % tab_width)
        else: break
    if j > 0:
        s = s[j:]
    return s
.. @+node:ekr.20101011165412.5191: *7* splitLines
def splitLines (self,s):

    '''Split s into lines, preserving the number of lines and the ending of the last line.'''

    return s and s.splitlines(True) or []
.. @+node:ekr.20101013072903.5218: *3* Not good stories
.. @+node:ekr.20101007082321.4357: *4* @slideshow What is Leo? (Joe Orr)
@language rest
.. @+node:ekr.20101009171445.4637: *5* @title_pattern = What is Leo? Slide %(slide_number)s
.. @+node:ekr.20101008061729.4372: *5* @slide 001
Leo is a unique, powerful computer program that you can use to **organize**,
**analyze** and **describe** text and text files. Leo is a free and open
software written by Edward K. Ream. For information about downloading Leo, see
the **installation** tutorial in this series. Leo runs on Windows, Mac, or
Linux.

Use Leo:

- To brainstorm a new project.
- As a Personal Information Manager.
- To add multiple outlines and commentary to any text file.
- To create and organize computer programs.
- To apply computer scripts to any kind of data.

Because Leo is unlike other tools you may have used, a series of examples may be
the best way to demonstrate what can be done with Leo.
.. @+node:ekr.20101010121134.4703: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-001.html
.. @+node:ekr.20101008061729.4373: *5* @slide 002
From one perspective, Leo is an **outlining editor**. This is a screenshot of
Leo. The arrow shows the outline pane. (A later tutorial explains how to create
an outline like the one in the screenshot).

.. image:: slide-002.png

.. @+node:ekr.20101008061729.4384: *6* @screenshot
.. @+node:ekr.20101008061729.4385: *7* To Do List
.. @+node:ekr.20101008061729.4386: *8* Urgent
.. @+node:ekr.20101008061729.4387: *8* Important
.. @+node:ekr.20101008061729.4388: *8* Soon
.. @+node:ekr.20101008061729.4389: *8* Whenever
.. @+node:ekr.20101008061729.4390: *7* Diary
.. @+node:ekr.20101008061729.4391: *8* 2009
.. @+node:ekr.20101008061729.4392: *9* Jan 1
.. @+node:ekr.20101008061729.4393: *8* 2010
.. @+node:ekr.20101008061729.4396: *6* @select To Do List
.. @+node:ekr.20101010121134.4704: *6* @edit
.. @+node:ekr.20101010121134.4716: *6* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-002.png
.. @+node:ekr.20101010121134.4717: *6* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-002.svg
.. @+node:ekr.20101010121134.4718: *6* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-002.png
.. @+node:ekr.20101010121134.4719: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-002.html
.. @+node:ekr.20101008061729.4398: *5* @slide 003
Clicking on the open triangle will open the indicated node.

.. image:: slide-003.png

.. @+node:ekr.20101009115705.4583: *6* @screenshot
.. @+node:ekr.20101009115705.4584: *7* To Do List
My to-do list.
.. @+node:ekr.20101009115705.4585: *8* Urgent
.. @+node:ekr.20101009115705.4586: *8* Important
.. @+node:ekr.20101009115705.4587: *8* Soon
.. @+node:ekr.20101009115705.4588: *8* Whenever
.. @+node:ekr.20101009115705.4589: *7* Diary
.. @+node:ekr.20101009115705.4590: *8* 2009
.. @+node:ekr.20101009115705.4591: *9* Jan 1
.. @+node:ekr.20101009115705.4592: *8* 2010
.. @+node:ekr.20101008061729.4420: *6* @select 2009
.. @+node:ekr.20101010121134.4731: *6* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-003.png
.. @+node:ekr.20101010121134.4732: *6* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-003.svg
.. @+node:ekr.20101010121134.4746: *6* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-003.png
.. @+node:ekr.20101010121134.4747: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-003.html
.. @+node:ekr.20101008061729.4522: *5* @slide 004
Here the node has been opened. Clicking on the box again will close the node.

.. image:: slide-004.png

.. @+node:ekr.20101009124842.4595: *6* @screenshot
.. @+node:ekr.20101009124842.4596: *7* To Do List
@nocolor-node

My to-do list.
.. @+node:ekr.20101009124842.4597: *8* Urgent
.. @+node:ekr.20101009124842.4598: *8* Important
.. @+node:ekr.20101009124842.4599: *8* Soon
.. @+node:ekr.20101009124842.4600: *8* Whenever
.. @+node:ekr.20101009124842.4601: *7* Diary
@nocolor-node

.. @+node:ekr.20101009124842.4602: *8* 2009
.. @+node:ekr.20101009124842.4603: *9* Aug
.. @+node:ekr.20101009211009.4624: *9* Jul
.. @+node:ekr.20101009211009.4623: *9* Jun
.. @+node:ekr.20101009211009.4625: *9* May
.. @+node:ekr.20101009211009.4626: *9* Apr
.. @+node:ekr.20101009211009.4627: *9* Mar
.. @+node:ekr.20101009211009.4628: *9* Feb
.. @+node:ekr.20101009211009.4629: *9* Jan
.. @+node:ekr.20101009124842.4604: *8* 2010
.. @+node:ekr.20101009124842.4606: *6* @select 2009
.. @+node:ekr.20101009124842.4607: *6* @edit
.. @+node:ekr.20101010121134.4766: *6* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-004.png
.. @+node:ekr.20101010121134.4767: *6* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-004.svg
.. @+node:ekr.20101010121134.4768: *6* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-004.png
.. @+node:ekr.20101010121134.4769: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-004.html
.. @+node:ekr.20101008061729.4518: *5* @slide 005
Here the indicated node has been closed.

.. image:: slide-005.png

.. @+node:ekr.20101009212539.4682: *6* @screenshot
.. @+node:ekr.20101009212539.4683: *7* To Do List
My to-do list.
.. @+node:ekr.20101009212539.4684: *8* Urgent
.. @+node:ekr.20101009212539.4685: *8* Important
.. @+node:ekr.20101009212539.4686: *8* Soon
.. @+node:ekr.20101009212539.4687: *8* Whenever
.. @+node:ekr.20101009212539.4688: *7* Diary
.. @+node:ekr.20101009212539.4689: *8* 2009
.. @+node:ekr.20101009212539.4690: *9* Aug
.. @+node:ekr.20101009212539.4691: *9* Jul
.. @+node:ekr.20101009212539.4692: *9* Jun
.. @+node:ekr.20101009212539.4693: *9* May
.. @+node:ekr.20101009212539.4694: *9* Apr
.. @+node:ekr.20101009212539.4695: *9* Mar
.. @+node:ekr.20101009212539.4696: *9* Feb
.. @+node:ekr.20101009212539.4697: *9* Jan
.. @+node:ekr.20101009212539.4698: *8* 2010
.. @+node:ekr.20101009212539.4746: *6* @select 2009
.. @+node:ekr.20101009212539.4699: *6* @edit
.. @+node:ekr.20101009213545.4670: *6* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-005.png
.. @+node:ekr.20101009213545.4671: *6* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-005.svg
.. @+node:ekr.20101009213545.4672: *6* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-005.png
.. @+node:ekr.20101010121134.4814: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-005.html
.. @+node:ekr.20101008061729.4521: *5* @slide 006
Clicking on a node headline (1) will show the text for that node in the body
pane (2) below. The body pane is a text editor--you can enter, delete or change
text here by typing it in.

.. image:: slide-006.png

.. @+node:ekr.20101009213545.4692: *6* @screenshot
.. @+node:ekr.20101009213545.4693: *7* To Do List
@nocolor

My to-do list.
.. @+node:ekr.20101009213545.4694: *8* Urgent
1. Make Leo tutorials.  The world is waiting.

2. Pay phone bill or the world will never know.
.. @+node:ekr.20101009213545.4695: *8* Important
.. @+node:ekr.20101009213545.4696: *8* Soon
.. @+node:ekr.20101009213545.4697: *8* Whenever
.. @+node:ekr.20101009213545.4698: *7* Diary
@nocolor
.. @+node:ekr.20101009213545.4699: *8* 2009
.. @+node:ekr.20101009213545.4700: *9* Aug
.. @+node:ekr.20101009213545.4701: *9* Jul
.. @+node:ekr.20101009213545.4702: *9* Jun
.. @+node:ekr.20101009213545.4703: *9* May
.. @+node:ekr.20101009213545.4704: *9* Apr
.. @+node:ekr.20101009213545.4705: *9* Mar
.. @+node:ekr.20101009213545.4706: *9* Feb
.. @+node:ekr.20101009213545.4707: *9* Jan
.. @+node:ekr.20101009213545.4708: *8* 2010
.. @+node:ekr.20101009213545.4709: *6* @edit
.. @+node:ekr.20101009213545.4710: *6* @select Urgent
.. @+node:ekr.20101010121134.4810: *6* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-006.png
.. @+node:ekr.20101010121134.4811: *6* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-006.svg
.. @+node:ekr.20101010121134.4812: *6* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-006.png
.. @+node:ekr.20101010121134.4813: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-006.html
.. @+node:ekr.20101008061729.4523: *5* @slide 007
You can save the outline in a .leo file.  Click File:Save (or Ctrl-S).

.. image:: slide-007.png

.. @+node:ekr.20101010121134.4832: *6* @screenshot
.. @+node:ekr.20101010121134.4833: *7* To Do List
@nocolor

My to-do list.
.. @+node:ekr.20101010121134.4834: *8* Urgent
1. Make Leo tutorials.  The world is waiting.

2. Pay phone bill or the world will never know.
.. @+node:ekr.20101010121134.4835: *8* Important
.. @+node:ekr.20101010121134.4836: *8* Soon
.. @+node:ekr.20101010121134.4837: *8* Whenever
.. @+node:ekr.20101010121134.4838: *7* Diary
@nocolor
.. @+node:ekr.20101010121134.4839: *8* 2009
.. @+node:ekr.20101010121134.4840: *9* Aug
.. @+node:ekr.20101010121134.4841: *9* Jul
.. @+node:ekr.20101010121134.4842: *9* Jun
.. @+node:ekr.20101010121134.4843: *9* May
.. @+node:ekr.20101010121134.4844: *9* Apr
.. @+node:ekr.20101010121134.4845: *9* Mar
.. @+node:ekr.20101010121134.4846: *9* Feb
.. @+node:ekr.20101010121134.4847: *9* Jan
.. @+node:ekr.20101010121134.4848: *8* 2010
.. @+node:ekr.20101010141334.4791: *6* @select Urgent
.. @+node:ekr.20101010121134.4849: *6* @pause
.. @+node:ekr.20101010121134.4868: *6* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-007.png
.. @+node:ekr.20101010121134.4869: *6* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-007.svg
.. @+node:ekr.20101010140842.4755: *6* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-007.png
.. @+node:ekr.20101010140842.4756: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-007.html
.. @+node:ekr.20101008061729.4524: *5* @slide 008
Here we will save our outline in a file named "pim.leo"

.. image:: slide-008.png

.. @+node:ekr.20101010141334.4772: *6* @screenshot
.. @+node:ekr.20101010141334.4773: *7* To Do List
@nocolor

My to-do list.
.. @+node:ekr.20101010141334.4774: *8* Urgent
1. Make Leo tutorials.  The world is waiting.

2. Pay phone bill or the world will never know.
.. @+node:ekr.20101010141334.4775: *8* Important
.. @+node:ekr.20101010141334.4776: *8* Soon
.. @+node:ekr.20101010141334.4777: *8* Whenever
.. @+node:ekr.20101010141334.4778: *7* Diary
@nocolor
.. @+node:ekr.20101010141334.4779: *8* 2009
.. @+node:ekr.20101010141334.4780: *9* Aug
.. @+node:ekr.20101010141334.4781: *9* Jul
.. @+node:ekr.20101010141334.4782: *9* Jun
.. @+node:ekr.20101010141334.4783: *9* May
.. @+node:ekr.20101010141334.4784: *9* Apr
.. @+node:ekr.20101010141334.4785: *9* Mar
.. @+node:ekr.20101010141334.4786: *9* Feb
.. @+node:ekr.20101010141334.4787: *9* Jan
.. @+node:ekr.20101010141334.4788: *8* 2010
.. @+node:ekr.20101010141334.4793: *6* @select Urgent
.. @+node:ekr.20101010141334.4789: *6* @pause
.. @+node:ekr.20101010141953.4835: *6* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-008.png
.. @+node:ekr.20101010141953.4836: *6* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-008.svg
.. @+node:ekr.20101010141953.4837: *6* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-008.png
.. @+node:ekr.20101010141953.4838: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-008.html
.. @+node:ekr.20101008061729.4525: *5* @slide 009
The file is now saved, and the file appears in the title bar.

.. image:: slide-009.png

.. @+node:ekr.20101010141953.4856: *6* @screenshot
.. @+node:ekr.20101010141953.4857: *7* To Do List
@nocolor

My to-do list.
.. @+node:ekr.20101010141953.4858: *8* Urgent
1. Make Leo tutorials.  The world is waiting.

2. Pay phone bill or the world will never know.
.. @+node:ekr.20101010141953.4859: *8* Important
.. @+node:ekr.20101010141953.4860: *8* Soon
.. @+node:ekr.20101010141953.4861: *8* Whenever
.. @+node:ekr.20101010141953.4862: *7* Diary
@nocolor
.. @+node:ekr.20101010141953.4863: *8* 2009
.. @+node:ekr.20101010141953.4864: *9* Aug
.. @+node:ekr.20101010141953.4865: *9* Jul
.. @+node:ekr.20101010141953.4866: *9* Jun
.. @+node:ekr.20101010141953.4867: *9* May
.. @+node:ekr.20101010141953.4868: *9* Apr
.. @+node:ekr.20101010141953.4869: *9* Mar
.. @+node:ekr.20101010141953.4870: *9* Feb
.. @+node:ekr.20101010141953.4871: *9* Jan
.. @+node:ekr.20101010141953.4872: *8* 2010
.. @+node:ekr.20101010141953.4873: *6* @select Urgent
.. @+node:ekr.20101010141953.4896: *6* @pause
.. @+node:ekr.20101010141953.4897: *6* @edit
.. @+node:ekr.20101010141953.4916: *6* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-009.png
.. @+node:ekr.20101010141953.4917: *6* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-009.svg
.. @+node:ekr.20101010141953.4918: *6* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/slide-009.png
.. @+node:ekr.20101010141953.4919: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-009.html
.. @+node:ekr.20101008061729.4526: *5* @slide 010
You've just seen an introduction to Leo as an outlining editor. You can use Leo
to make an outline, with optional text for each outline element. You can save
the outline to a file. Outlines are explained more in a later tutorial in this
series.

  *The outlining capability of Leo goes far beyond what has just been demonstrated,
  including multipath outlines, and multiple outlines in one file.*

What we've shown so far is no different from other outlining editors. What makes
Leo unique is the addition of a new feature. **Using simple directives, you can
instruct Leo to extract text from any number of nodes, in any order, and write
the text to a new file**. We call files created or managed from within a Leo
outline **external file**. You can also embed outline information in the
external file, giving Leo the ability to read the text pieces back into the Leo
outline, even if they have been changed.

In effect, Leo is a **meta-text** editor. It gives you the ability to create a
structural document for a non structured document, or a document that is
structured in some other way.

What does this mean in practice? Some examples should help clarify things...
.. @+node:ekr.20101010141953.4922: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\what-is-leo\_build\html\slide-010.html
.. @+node:ekr.20101008061729.4527: *5* @slide 011
Here is the "pim.leo" file again. We have:

1. Selected the "Diary" node.
2. Typed Ctrl-H to start editing the headline.
   (You can also edit headlines with the Edit:Edit Headline...:Edit Headline command.

.. image:: slide-011.png

.. @+node:ekr.20101010141953.4940: *6* @screenshot
.. @+node:ekr.20101010141953.4941: *7* To Do List
@nocolor

My to-do list.
.. @+node:ekr.20101010141953.4942: *8* Urgent
1. Make Leo tutorials.  The world is waiting.

2. Pay phone bill or the world will never know.
.. @+node:ekr.20101010141953.4943: *8* Important
.. @+node:ekr.20101010141953.4944: *8* Soon
.. @+node:ekr.20101010141953.4945: *8* Whenever
.. @+node:ekr.20101010141953.4946: *7* Diary
@nocolor

This is my diary.
.. @+node:ekr.20101010141953.4947: *8* 2009
.. @+node:ekr.20101010141953.4948: *9* Aug
.. @+node:ekr.20101010141953.4949: *9* Jul
.. @+node:ekr.20101010141953.4950: *9* Jun
.. @+node:ekr.20101010141953.4951: *9* May
.. @+node:ekr.20101010141953.4952: *9* Apr
.. @+node:ekr.20101010141953.4953: *9* Mar
.. @+node:ekr.20101010141953.4954: *9* Feb
.. @+node:ekr.20101010141953.4955: *9* Jan
.. @+node:ekr.20101010141953.4956: *8* 2010
.. @+node:ekr.20101010141953.4958: *6* @pause
.. @+node:ekr.20101010141953.4957: *6* @select Diary
.. @+node:ekr.20101010141953.5023: *6* @url screenshot
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-011.png
.. @+node:ekr.20101010141953.5024: *6* @url working file
c:/leo.repo/trunk/leo/doc/html/slides/what-is-leo/screenshot-011.svg
.. @+node:ekr.20101008061729.4528: *5* @slide 012
.. @+node:ekr.20101008061729.4529: *5* @slide 013
.. @+node:ekr.20101008061729.4530: *5* @slide 014
.. @+node:ekr.20101008061729.4531: *5* @slide 015
.. @+node:ekr.20101008061729.4532: *5* @slide 016
.. @+node:ekr.20101008061729.4533: *5* @slide 017
.. @+node:ekr.20101008061729.4534: *5* @slide 018
.. @+node:ekr.20101008061729.4535: *5* @slide 019
.. @+node:ekr.20101008061729.4536: *5* @slide 020
.. @+node:ekr.20101008061729.4537: *5* @slide 021
.. @+node:ekr.20101008061729.4539: *5* @slide 022
.. @+node:ekr.20101008061729.4540: *5* @slide 023
.. @+node:ekr.20101011071655.4919: *4* @slideshow Whetting Your Appetite
@language rest
@pagewidth 50
.. @+node:ekr.20101013072903.5219: *5* @slide What you can do with Leo
This slideshow shows some of the things you can do
with Leo
.. @+node:ekr.20101013072903.5220: *6* @no-screenshot
.. @+node:ekr.20101013072903.5221: *5* @slide Leo's main window
Leo's main window consists of an **outline pane**
(1), a **body pane** (2) and a **log pane** (3).
All data in Leo resides in **nodes**. A node
consists of **headline text** and **body text**.
The outline pane shows headlines. The body pane
pane shows the body text of the presently selected
node. Messages from Leo appear in the log pane.

.. @+node:ekr.20101011071655.4920: *5* @slide A Personal Information Manager
You can use Leo as a PIM.

As with other outliners, Leo outlines show 
.. @+node:ekr.20101011103613.4930: *5* @slide A Better PIM
Leo is a better pim.
.. @+node:ekr.20101011103613.4942: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-003.html
.. @+node:ekr.20101012083118.5245: *5* @slide External Files
.. @+node:ekr.20101011103613.4933: *5* @slide A Scripting Environment
The body text of any node can contain a Python script.

You execute the script with (Ctrl-B) Leo's execute-script command.
.. @+node:ekr.20101011103613.4943: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-005.html
.. @+node:ekr.20101011103613.4934: *5* @slide Better Scripting
All Leo scripts have access to three predefined constants: c, g and p.
.. @+node:ekr.20101011103613.4944: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-006.html
.. @+node:ekr.20101011103613.4938: *5* @slide Better Scripting, Part Deux
All Leo scripts have full access to the outline in which the scripts reside. The
following scripts, executed from Leo's body pane, will print the headlines of
all the nodes of the outline, properly indented::

    for p in c.all_positions():
        print '%s%s' % (' '*p.level(),p.h)
.. @+node:ekr.20101011103613.4945: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-007.html
.. @+node:ekr.20101011103613.4935: *5* @slide Outlines Create New Leo Commands
Discuss @button nodes
.. @+node:ekr.20101011103613.4946: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-008.html
.. @+node:ekr.20101011103613.4936: *5* @slide Outlines Create Unit tests
Discuss @test nodes
.. @+node:ekr.20101011103613.4947: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-009.html
.. @+node:ekr.20101011103613.4937: *5* @slide Outlines Create Restructured Text
Leo outlines make it easy to create Restructured Text (rST) documents.

Within @rst trees, nodes correspond to rST sections. Naturally, the outline
level of a node in the Leo outline determines the section's level in the
resulting document.
.. @+node:ekr.20101011111455.4965: *6* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-010.html
.. @+node:ekr.20101011103613.4939: *5* @slide Outlines Create HTML
.. @+node:ekr.20101011165412.5011: *4* nutshell (copy)
Unifying scripting, data and outline structure creates a new world. We use the
term **Leonine** to denote the Leo-centric (outline-centric) view of
programming, data and scripting. Here are some of the implications of this
new world:

**Data organization**: Leo's clones allow unprecedented flexibility in
organizing data. Leo outlines have been used as an entirely new kind of
database. It is easily scriptable. As my brother has shown, it is possible to
design Leo outlines so that parts of the outline *are* SQL queries!

**Design**: With Leo, you always see the big picture, and as many of the details
as you like. But this makes outlines ideal for representing designs. In fact,
Leo outlines don't just represent designs, they *are* the designs. For example,
all of Leo's source code reside in just a few Leo outlines. And Leo outlines can
represent input data to other design tools.

**Programming/Coding**: It's much easier to program when the design is always
easily visible. Nodes provide the perfect way to organize large modules, classes
and functions. Nodes also provide unlimited room to save as many details as you
like, *without* cluttering your overall view of the task, or rather tasks, at
hand.

**Testing**: Leo is a supremely powerful unit-testing framework:

1. You can make a node a unit test simply by putting @test at the start of its
   headline. Leo will then automatically generate all the blah-blah-blah needed
   to turn the node's script into a fully-functional unit test. Oh yes,
   the headline becomes the name of the unit test.

2. Unit tests can use data in children of @test nodes. Typical tests put input
   data in one child node, and the expected results of running the test in another
   child node. The test simply compares the actual and expected results.

3. You can easily run tests in the entire outline or just in the selected
   outline. Because tests reside in nodes, you can use clones to organize tests
   in as many ways as you like. For example, it is trivial to run only those
   tests that are failing.

**Maintenance and support**: Leo's ability to contain multiple views of data is
*precisely* what is needed while maintaining any large project. For every new
support task and every new bug, a new (plain) **task node** will contain all the
data needed for that task, notes, test data, whatever. Furthermore, when fixing
bugs, the task node can contain clones of all classes, methods or functions
related to the bug. Fixing a node in the task node fixes the node in the
external file! And as always, you can use all of Leo's outlining features
(including clones) to organize your task nodes.

**Organization everywhere**: Have you noticed that Leo's organizational prowess
applies to *everything*? Indeed, you can use outlines and clones in new ways to
organize files, projects, data, design, programs, testing, and tasks. Leo
doesn't need lots of features--outlines, clones and scripts suffice.  The more
complex your data, designs, program and tasks, the better Leo is suited to them.

It's time to mention one of Leo's most unique features.  Simple, *optional*
markup makes it possible to synthesize (build) scripts and entire computer programs
from outlines. Leo is more than a filing cabinet for scripts and programs, Leo
is a build tool for scripts and outlines!

**Scripting everything**: Let's step back a moment. A single outline can contain
databases, designs, actual computer code, unit tests, test scripts and task
nodes. But Leo scripts will work on any kind of node. Thus, it is *easy* to run
scripts on *anything*! Examples:

- Scripting itself: @button nodes creates a **script button**, a Python script
  that can be applied to any node in an outline! Script buttons have been
  written (in Python) that will execute Leo scripts in other languages.

- Data: The @kind convention for headlines tells scripts what a node contains
  without having to parse the node's contents.  The possibilities are endless.

- Design: scripts can verify properties of design based on either the contents
  of design nodes or their outline structure.

- Coding: scripts routinely make massive changes to outlines. Scripts and unit
  tests can (and do!) verify arbitrarily complex properties of outlines.

- Scientific programming: Leo scripts can run experiments many times using
  different starting points. Nodes are the perfect place to store results and
  notes. Many scientists use the IPython shell-- Using Leo's **IPython bridge**,
  Leo can execute IPython scripts, and scripts in IPython have full access to
  all nodes in Leo outlines.

- Testing: scripts can (and do!) create @test nodes themselves.

- Maintenance: scripts could gather statistics about tasks using simple @kind
  conventions.

The Leo Aha is just this: Leo outlines are far more than eye candy. Leo outlines
revolutionize your view of data--Leo outlines can organize *anything*. Leo
outlines create a new kind of programming environment, one in which outline
structure and user-defined data types create totally new opportunities.
.. @+node:ekr.20101012083118.5246: *4* @@slide Leo
Leo is a unique, powerful computer program that you can use to organize, analyze
and describe text and text files.

Use Leo:

- To brainstorm a new project.
- As a Personal Information Manager.
- As a new kind of programming too.

Because Leo is unlike other tools you may have used, a series of examples may be
the best way to demonstrate what can be done with Leo.
.. @+node:ekr.20101011103613.4940: *4* @@slide The Leo way
Leo is a new way of working with complex data like computer programs,
books, web sites and data bases. The term **Leonine** refers to the Leo
way of viewing the world and its data.

In Leo, **outline structure is significant everywhere**. Leos users speak of an
Aha! moment when they see what this statement means.

People say Leo is **fun to use**, even additive.
.. @+node:ekr.20101012083118.5242: *5* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-001.html
.. @+node:ekr.20101013072903.5238: *4* Don't describe the window!
.. @+node:ekr.20101013072903.5228: *5* @slide ((file name: workbook2.leo
.. Arrow points to window title.

The name of the Leo outline appears in the window's title.

Here, the name is workbook.leo, the default file name.
.. @+node:ekr.20101013072903.5229: *5* @slide ((3 panes
Leo's main window consists of an **outline pane**
(1), a **body pane** (2) and a **log pane** (3).

.. @+node:ekr.20101013072903.5230: *5* @slide ((outline pane
The outline pane shows **headlines**.

Here, we see the a "startup" headline and a "workbook" headline.
.. @+node:ekr.20101026082911.5535: *3* Document plugins & other cool things
.. @+node:ekr.20101025080245.5529: *4* Document leoremote plugin
@nocolor-node

Ville's server code to interact with a running Leo
http://mail.google.com/mail/#inbox/12adebe2ffe80572

Reusing Emacs instances with gnuserv
http://www.debian-administration.org/articles/257

.. @+node:ekr.20101025080245.5543: *4* Document screenshots plugin
.. @+node:ekr.20101025080245.5546: *4* @url Document Ville's server
http://mail.google.com/mail/#inbox/12adebe2ffe80572
.. @+node:ekr.20101025080245.5539: *3* External Files & Clones slideshows
.. @+node:ekr.20100821182153.4345: ** @slideshow Installation
@language rest
.. @+node:ekr.20101014034526.5299: *3* @slide ((using Leo's installer
.. _`Download Python`: http://www.python.org/download/
.. _`packaged version`: https://sourceforge.net/projects/leo/files/Leo/
.. _`Leo's download page`: https://sourceforge.net/projects/leo/files/Leo/
.. _`next slide`: slide-002.html

**Installing on Windows: using Leo's single-click installer** 

1. Install Python: `Download Python`_, save to your desktop, then
   double-click on the saved file.

   Python is software for creating and running computer programs.
   Leo requires Python 2.6 or later, or Python 3.0 or later.

2. Install Qt. Get the binary package of PyQt from: 
   http://www.riverbankcomputing.co.uk/software/pyqt/download

   The version of PyQt that you download must match the version of your Python.

3. Download the latest Leo's installer from `Leo's download page`_.
   It will be called something like LeoSetup-<version>.exe

4. Run the installer.

**Installing Leo from Linux packages**

Linux users are best served by the `packaged version`_ available at
SourceForge. You can also install Leo manually, as discussed in the
`next slide`_.

**Installing Leo from sources**

See the `next slide`_.
.. @+node:ekr.20101113132111.4924: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-001.html
.. @+node:ekr.20100821182153.4348: *3* @slide ((installing from sources
.. _`Download Python`: http://www.python.org/download/
.. _`Leo's download page`: https://sourceforge.net/projects/leo/files/Leo/

**Installing Leo from sources**

1. Install Python: `Download Python`_, save to your desktop, then
   double-click on the saved file.

   Leo requires Python 2.6 or later, or Python 3.0 or later.

2. Install Qt. Install Qt. Get PyQt from: 
   http://www.riverbankcomputing.co.uk/software/pyqt/download

   The version of PyQt that you download must match the version of your Python.

3. Install Leo: Download the most recent .zip file from `Leo's
   download page`_ to your desktop or other location. Unzip the .zip
   file to the folder of your choice.
.. @+node:ekr.20101113132111.4925: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-002.html
.. @+node:ekr.20101014034526.5302: *3* @slide ((running Leo from a console
**Running Leo from a console**

To run Leo directly from a console, do the following:

1. Go to the Leo directory::

    cd <path-to-leo-directory>

2. Start launchLeo.py using Python::

    python launchLeo.py %*

.. @+node:ekr.20101014105353.5258: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-003.html
.. @+node:ekr.20101014034526.5303: *3* @slide ((scripts & .bat files
Using shell scripts (Linux) or .bat files (Windows)
can make it easier to open Leo files.

**Linux**

Put this in a shell script called leo::

    #!/bin/sh 
    python <path-to-leo-directory>launchLeo.py $1

**Windows**

Put this in leo.bat::

    cd <path-to-leo-folder>
    python <path-to-leo-folder>launchLeo.py %*

On either platform, the following will open x.leo::

    leo x.leo
.. @+node:ekr.20101014105353.5259: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-004.html
.. @+node:ekr.20101014034526.5304: *3* @slide ((.leoID.txt
The first time you start Leo, a dialog will ask you for a unique
identifier. This string helps ensure that each Leo node has a
unique identity.

This identifier can be any string 3 characters or more in length.
In a shared environment, a cvs or bzr login name works well.

Pick a string you don't mind making public: it will appear in
files that Leo creates.

Leo stores this identifier in the file ~/.leo/.leoID.txt.
You can change this identifier at any time by editing .leoID.txt.
.. @+node:ekr.20101014105353.5260: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-005.html
.. @+node:ekr.20100821182153.4350: *3* @slide ((free software
.. _`Edward K. Ream`:   http://webpages.charter.net/edreamleo/ekr.html
.. _`leo-editor`:       http://groups.google.com/group/leo-editor
.. _`Python Tutorial`:  http://docs.python.org/tutorial/

Leo is a free program distributed under the MIT license. This means that not
only can you use the program freely including commercially, the full
installation comes with source code that you can modify as you wish, as long as
you give credit to the author of the program, `Edward K. Ream`_.

Leo is written in Python--a full featured, powerful programming language that
is comparatively easy to learn and use. For an excellent introduction to Python
for non-programmers, see the `Python Tutorial`_. Not only is Leo written in Python, it is
scriptable via Python, meaning that you can embed Python commands in your
outlines and execute them.

Leo is under active development and all are welcome to contribute. For more
information, see the `leo-editor`_ Google Group.

Not only is Leo free software, it is supported software. Post questions and bug
reports to `leo-editor`_ Google Group.
.. @+node:ekr.20101014105353.5261: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\installation\_build\html\slide-006.html
.. @+node:ekr.20101013072903.5224: ** @slideshow Leo basics step by step
@language rest
@pagewidth 50

(done) slide 5: could do with the same arrow as slide7
(done) slide 7:
  'one again' -> 'once again'
   if a node is no longer 'dirty', what is it - clean?
slide 13: 'ctrl-z' (lower-case), but elsewhere 'ctrl-H' (upper-case).
Stick with upper case for consistency?
.. @+node:ekr.20101013072903.5225: *3* @slide ((no-slide
This is a step-by-step introduction to show you
how to use Leo outlines.

.. @+node:ekr.20101018190057.5370: *4* @no-screenshot
.. @+node:ekr.20101018190057.5462: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-001.html
.. @+node:ekr.20101013072903.5226: *3* @slide ((Open notebook file
.. The workbook.leo window.

Leo opens the **workbook file** when you start
Leo without a filename.

The body has focus--it is colored a pale pink, and
contains a blinking cursor.

**Note**: on some monitors the colors will be almost
invisible.  You can choose such colors to suit your
taste.

.. image:: slide-002.png

.. @+node:ekr.20101018190057.5441: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-002.png
.. @+node:ekr.20101021093614.5432: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-002.html
.. @+node:ekr.20101014110348.5286: *3* @slide ((Ctrl-H edits headline
Ctrl-H edits the presently selected headline.

You can type Ctrl-H at any time, regardless of
where the focus is.

The body pane is now blue, indicating that it no
longer has focus.

.. image:: slide-003.png

.. @+node:ekr.20101018190057.5442: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-003.png
.. @+node:ekr.20101018190057.5464: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-003.html
.. @+node:ekr.20101013072903.5234: *3* @slide (("to do" node
I typed "to do" in the headline.

.. image:: slide-004.png

.. @+node:ekr.20101018190057.5443: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-004.png
.. @+node:ekr.20101018203754.5424: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-004.html
.. @+node:ekr.20101018061243.5392: *3* @slide ((Return ends editing
Typing the <return> key ends editing of the headline
and puts focus back in the body pane.

Notice that the **icon box** to the left of the
headline now has a darker outline that it had
before. This indicates that the contents of the
node has been changed. We say the node is
**dirty**.

.. image:: slide-005.png

.. @+node:ekr.20101018190057.5444: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-005.png
.. @+node:ekr.20101021093614.5433: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-005.html
.. @+node:ekr.20101018061243.5393: *3* @slide ((no-slide focus keys
You can use Leo without ever using the mouse. For
instance, you can select any Leo pane by using
keystrokes instead of clicking the pane:

- Regardless of where the focus is, Alt-D puts
  focus in the body pane and Alt-T puts focus in
  the outline pane.

- With the focus in the tree pane, hitting the
  return key puts the focus in the body pane.

.. @+node:ekr.20101018190057.5373: *4* @no-screenshot
.. @+node:ekr.20101019053718.5422: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-006.html
.. @+node:ekr.20101014110348.5325: *3* @slide ((Ctrl-S saves outline
Ctrl-S saves the outline.

Notice that the icon box once again has a gray outline,
indicating that the node has not been changed since
the file was last saved.

.. Arrow to icon box.

.. image:: slide-007.png

.. @+node:ekr.20101018190057.5445: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-007.png
.. @+node:ekr.20101021101327.5432: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-007.html
.. @+node:ekr.20101013072903.5236: *3* @slide ((Ctrl-I inserts a new node
Ctrl-I inserts a new node.

.. image:: slide-008.png

.. @+node:ekr.20101018190057.5446: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-008.png
.. @+node:ekr.20101018190057.5469: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-008.html
.. @+node:ekr.20101013072903.5237: *3* @slide (("go shopping"
I typed "go shopping" followed by a return.

The focus is now in the body pane.

.. image:: slide-009.png

.. @+node:ekr.20101018190057.5447: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-009.png
.. @+node:ekr.20101018190057.5470: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-009.html
.. @+node:ekr.20101014110348.5305: *3* @slide ((typing text (icon box has blue square)
Whatever I type will appear in the body pane.

I added a shopping list.

The blue square in the icon area indicates that the body pane contains text.

.. Arrow at icon box.

.. buy milk
.. buy eggs.

.. image:: slide-010.png

.. @+node:ekr.20101018190057.5448: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-010.png
.. @+node:ekr.20101018203754.5426: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-010.html
.. @+node:ekr.20101013072903.5244: *3* @slide ((Ctrl-R
Ctrl-R moves a node right.

The "go shopping" node becomes a **child**
of the "to do" node.

The "to do" node is the **parent** node.

.. image:: slide-011.png

.. @+node:ekr.20101018190057.5449: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-011.png
.. @+node:ekr.20101018203754.5427: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-011.html
.. @+node:ekr.20101014110348.5290: *3* @slide ((Ctrl-L
Ctrl-L moves the "go shopping" node left.

The "go shopping" node becomes a **sibling**
of the "to do" node.

.. image:: slide-012.png

.. @+node:ekr.20101018190057.5450: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-012.png
.. @+node:ekr.20101018190057.5473: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-012.html
.. @+node:ekr.20101013072903.5245: *3* @slide ((undo/redo
Leo has unlimited undo/redo capabilities.

Here, I typed Ctrl-Z to undo the previous move.
The "go shopping" node is once again a child of
the "to do" node.

**Note**: Ctrl-Shift-Z redoes a previous undo.

.. image:: slide-013.png

.. @+node:ekr.20101018190057.5451: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-013.png
.. @+node:ekr.20101021093614.5435: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-013.html
.. @+node:ekr.20101014110348.5294: *3* @slide ((new node
Let's add a new node.  I hit Ctrl-I.

.. image:: slide-014.png

.. @+node:ekr.20101018190057.5452: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-014.png
.. @+node:ekr.20101018203754.5428: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-014.html
.. @+node:ekr.20101014110348.5295: *3* @slide (("fix car"
I type "fix car" followed by the <return> key.

.. image:: slide-015.png

.. @+node:ekr.20101018190057.5453: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-015.png
.. @+node:ekr.20101018190057.5476: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-015.html
.. @+node:ekr.20101014110348.5296: *3* @slide ((Ctrl-U
I decide that fixing the car should have first priority.

I type Ctrl-U to move the "fix car" node up.
It becomes the first child of the "to do" node.

.. image:: slide-016.png

.. @+node:ekr.20101018190057.5454: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-016.png
.. @+node:ekr.20101018190057.5477: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-016.html
.. @+node:ekr.20101014110348.5297: *3* @slide ((contracting nodes
After creating the to-do list, I want to hide it
by **collapsing** the "to do" node.

I could do that by clicking the black triangle
to the left of the "to do" node.

However, using the mouse is not recommended--
there are much easier ways.

.. arrow points to black triangle.

.. image:: slide-017.png

.. @+node:ekr.20101018190057.5455: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-017.png
.. @+node:ekr.20101018203754.5423: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-017.html
.. @+node:ekr.20101014110348.5298: *3* @slide ((Up-Arrow
The focus is in the tree pane, so I can select the "to do"
node merely by using the Up-Arrow key.

If, for some reason, the focus is in the body pane,
I can select the previous node in either of two ways:

1. Type Alt-T to put focus in the tree pane
   followed by the Up-Arrow key.

2. Type Alt-Up-Arrow.  This selects the previous
   node and also puts focus in the tree pane.

Now the "to do" node is selected.

.. image:: slide-018.png

.. @+node:ekr.20101018190057.5456: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-018.png
.. @+node:ekr.20101018203754.5429: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-018.html
.. @+node:ekr.20101014110348.5299: *3* @slide ((Left-Arrow
With the "to-do" node selected,
hitting the Left-Arrow key will contract the node.

.. "to do" contracted.

.. image:: slide-019.png

.. @+node:ekr.20101018190057.5457: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-019.png
.. @+node:ekr.20101018203754.5430: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-019.html
.. @+node:ekr.20101014110348.5300: *3* @slide ((20 Right-Arrow
To expand the "to do" node,
I merely hit the Right-Arrow key.

We can now see the entire to-do list.

.. image:: slide-020.png

.. @+node:ekr.20101018190057.5458: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-020.png
.. @+node:ekr.20101018190057.5481: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-020.html
.. @+node:ekr.20101014110348.5309: *3* @slide ((no-slide Arrow keys: summary
The arrow keys do different things depending on
which pane has focus. Using arrow keys is **much**
easier than using the mouse.

**Focus in outline pane**

    The **plain** arrow keys **select** nodes,
    expanding or contracting nodes as needed.

    The **shift** arrow keys **move** nodes. The
    Shift-Left-Arrow and Shift-Up-Arrow contract
    nodes as needed. **Note**: the
    Shift-Down-Arrow and Shift-Right-Arrow keys
    never expand nodes.

**Focus in body pane**

    As usual, the **plain** arrow keys move the
    cursor and the **shift** arrow keys move the
    cursor and extend the solution.

    The **alt** arrow keys move the focus to the
    outline pane and then select nodes. The
    **alt-shift** arrow keys move the focus to the
    outline pane and then move nodes.

..  - The Up-Arrow and Down-Arrow keys select
..  the previous or next visible nodes.

..  - The Right-Arrow key contracts a node if the node
..  is expanded. Otherwise the Right-Arrow key
..  selects the node's parent.

..  - The Left-Arrow key does nothing if the selected
..  node has no children.  If the node does have
..  children, the Left-Arrow key expands the node
..  (if the children or invisible) or selects the
..  first child (if the children are visible).

..  This is exactly how Windows explorer works, and
..  it quickly becomes second nature.

.. @+node:ekr.20101014110348.5323: *4* @no-screenshot
.. @+node:ekr.20101018190057.5482: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-021.html
.. @+node:ekr.20101014110348.5326: *3* @slide ((Shift-Ctrl-C copies
We can copy and paste nodes and all their descendants.

Using the arrow keys as necessary, I select the
"to do" node.

The Shift-Ctrl-C key copies the selected outline.

I want to do the paste *after* the to-do list, so I collapse
the original node before doing the paste:

.. image:: slide-022.png

.. @+node:ekr.20101018190057.5459: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-022.png
.. @+node:ekr.20101018190057.5483: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-022.html
.. @+node:ekr.20101018061243.5397: *3* @slide ((The pasted node
And here is the pasted node.

.. image:: slide-023.png

.. @+node:ekr.20101018190057.5460: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-023.png
.. @+node:ekr.20101018190057.5484: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-023.html
.. @+node:ekr.20101018061243.5394: *3* @slide ((expanding the pasted node
Expanding the node shows that the copy operation
copied the node and all its descendants.

.. image:: slide-024.png

.. @+node:ekr.20101018190057.5461: *4* @url final output file
c:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/slide-024.png
.. @+node:ekr.20101018190057.5485: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-024.html
.. @+node:ekr.20101014110348.5336: *3* @slide ((no-slide end slide
This concludes the step-by-step introduction to
Leo's outlines.

You now know how to do the following:

- Create new nodes.
- Edit the headline and body text of any node.
- Reorganize nodes. 
- Expand and contract nodes.
- Copy and paste nodes and their descendants.

Mastering these skills is essential to using Leo
effectively and enjoyably.

.. @+node:ekr.20101018061243.5395: *4* @no-screenshot
.. @+node:ekr.20101018190057.5486: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-025.html
.. @+node:ekr.20101014110348.5293: ** @slideshow Clones and views
.. @+node:ekr.20101011165412.4968: ** @slideshow Scripting Leo
@language rest
@pagewidth 50

.. @+node:ekr.20101014034526.5296: ** @slideshow Leo's minibuffer
@ Discuss tab completion.
.. @+node:ekr.20101014110348.5338: ** @button meld
'''Meld Wink slides into an @slideshow folder.

   Copy screenshot files from the wink_dir to slideshow_dir, numbering
   the destination files to reflect "holes" created by @no-screenshot
   nodes.

   This script carefully checks that the number of screenshot files
   matches the number of screenshots referenced by the @slide nodes.
   No copying takes place if the numbers are not as expected.'''

@language python

import glob
import os
import shutil

slideshow_dir = 'C:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step'

wink_dir = 'C:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/_files'
    # The directory containing the wink screenshots.
    # This will usually be <slideshow_dir>/_files.
    # **Important** You generate these screenshots using Wink's 
    # Export As Html command (!)

@others

mc = MeldController(c,p,slideshow_dir,wink_dir)
mc.run()
.. @+node:ekr.20101014110348.5339: *3* class MeldController
class MeldController:

    def __init__ (self,c,p,slideshow_dir,wink_dir):

        self.c = c
        self.slideshow_dir = slideshow_dir
        self.slideshow_node = p
        self.wink_dir = wink_dir

    @others
.. @+node:ekr.20101016043116.5353: *4* utils
.. @+node:ekr.20101016043116.6224: *5* finalize & fix
def fix (self,fn):
    return os.path.normcase(fn).replace('\\','/')

def finalize (self,fn):
    return self.fix(g.os_path_finalize_join(self.slideshow_dir,fn))
.. @+node:ekr.20101015151959.5301: *5* has_at_no_screenshot_node
def has_at_no_screenshot_node (self,p):

    for p in p.children():
        if self.match(p,'@no-screenshot'):
            return True
    else:
        return False
.. @+node:ekr.20101015151959.5302: *5* match
def match (self,p,pattern):

    '''Return True if p.h matches the pattern.'''

    return g.match_word(p.h,0,pattern)
.. @+node:ekr.20101014110348.5341: *4* run & helpers
def run (self):

    print('='*20)

    aList = self.get_wink_screenshots()
    if not aList:
        return

    if not self.check(aList):
        return

    # Pass 1: copy files for @slide nodes w/o @no-screenshot nodes.
    self.copy_files(aList)

    # Pass 2: adjust children of @slide nodes.
    self.adjust_slideshow()

    print('meld done')
.. @+node:ekr.20101014110348.5344: *5* adjust_slideshow & helper
def adjust_slideshow(self):

    '''Adjust all @slide nodes in the slideshow.'''

    # Traverse the tree as in the screenshot plugin.
    # That is, ignore @ignore trees and nested @slide nodes.
    # This ensures that the slide number, n, is correct.
    p = self.slideshow_node
    after = p.nodeAfterTree()
    p = p.firstChild()
    n = 1
    while p and p != after:
        if self.match(p,'@slide'):
            self.adjust_slide_node(p,n)
            n += 1
            p.moveToNodeAfterTree()
        elif self.match(p,'@ignore'):
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
.. @+node:ekr.20101015151959.5300: *6* adjust_slide_node & helpers
def adjust_slide_node (self,p,slide_number):

    '''Adjust p, an @slide node.'''

    trace = True

    # Delete the first "@url built slide" node.
    self.delete_at_url_built_slide_node(p)

    # Do nothing more if there is an @no-screenshot node.
    if self.has_at_no_screenshot_node(p):
        return

    # Add or update the "@url final output file" node.
    p2 = self.add_at_url_final_output_file(p,slide_number)

    # Add the .. image:: directive.
    self.add_image_directive(p,slide_number)
.. @+node:ekr.20101016043116.6226: *7* add_at_url_final_output_file
def add_at_url_final_output_file (self,p,slide_number):

    '''Create or update the "@url final output file" node.'''

    trace = True
    tag ='@url final output file'

    for child in p.children():
        if self.match(child,tag):
            p2 = child ; break
    else:
        if trace: g.es('add %s' % tag)
        p2 = p.insertAsLastChild()
        p2.h = tag

    p2.b = self.finalize(
        'slide-%03d.png' % (slide_number))

    return p2
.. @+node:ekr.20101016043116.6223: *7* add_image_directive
def add_image_directive (self,p,slide_number):

    '''Add an image directive in p if it is not there.'''

    s = '.. image:: slide-%03d.png' % (slide_number)

    if p.b.find(s) == -1:
        p.b = p.b.rstrip() + '\n\n%s\n\n' % (s)
.. @+node:ekr.20101016043116.6225: *7* delete_at_url_built_slide_node
def delete_at_url_built_slide_node (self,p):

    '''Delete any "@url built slide" node in p's children.'''

    trace = True
    tag = '@url built slide'

    for child in p.children():
        if self.match(child,tag):
            if trace: g.es('del %s in %s' % (tag,p.h))
            child.doDelete()
            break
.. @+node:ekr.20101014110348.5342: *5* check & helpers
def check (self,aList):

    '''
    Check that len(aList) matches the number of @slide nodes in the
    slideshow. Don't count @slide nodes containing an @no-screenshot node.
    '''

    p = self.slideshow_node
    n1 = len(aList)
    n2,n3 = self.count_slide_nodes()

    if not self.check_dir(self.wink_dir):
        return False
    if not self.check_dir(self.slideshow_dir):
        return False
    if not self.match(p,'@slideshow'):
        return g.error('not a @slideshow node: %s',p.h)

    if n1 != (n2-n3):
        return g.error(
            '%s wink slides\n'
            '%s @slide nodes\n'
            '%s @no_screenshot nodes' % (
                n1,n2,n3))

    return True
.. @+node:ekr.20101016043116.5349: *6* check_dir
def check_dir (self,theDir):

    if not g.os_path_exists(theDir):
        return g.error('not found: %s' % (theDir))

    if not g.os_path_isdir(theDir):
        return g.error('not a directory: %s' % (theDir))

    return True
.. @+node:ekr.20101014110348.5347: *6* count_slide_nodes
def count_slide_nodes (self):

    '''Return n1,n2

    n1 is the total number of @slide nodes in the @slideshow tree.
    n2 is number of @slide nodes containing an @no-slideshow child.
    '''

    p = self.slideshow_node
    after = p.nodeAfterTree()
    p = p.firstChild()
    n1,n2 = 0,0
    while p and p != after:
        if self.match(p,'@slide'):
            n1 += 1
            if self.has_at_no_screenshot_node(p):
                n2 += 1
            p.moveToNodeAfterTree()
        elif self.match(p,'@ignore'):
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    g.trace(n1,n2)
    return n1,n2
.. @+node:ekr.20101014110348.5343: *5* copy_files & helper
def copy_files (self,aList):

    '''Copy files from the wink_dir to slideshow_dir,
    numbering the destination files to reflect "holes"
    created by @no-screenshot nodes.'''

    # Traverse the tree as in the screenshot plugin.
    # That is, ignore @ignore trees and nested @slide nodes.
    # This ensures that the slide number, n, is correct.
    p = self.slideshow_node
    after = p.nodeAfterTree()
    p = p.firstChild()
    wink_n = 0 # Wink screenshot numbers start at 0.
    slide_n = 1 # Slide numbers start at 1.
    while p and p != after:
        if self.match(p,'@slide'):
            if not self.has_at_no_screenshot_node(p):
                self.copy_file(aList,slide_n,wink_n)
                wink_n += 1
            slide_n += 1
            p.moveToNodeAfterTree()
        elif self.match(p,'@ignore'):
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
.. @+node:ekr.20101016043116.5352: *6* copy_file
def copy_file (self,aList,slide_n,wink_n):

    trace = True

    if wink_n >= len(aList):
        return g.trace('can not happen: '
            'len(aList): %s, n: %s' % (
                len(aList),wink_n))

    fn_src = aList[wink_n]
    fn_dst = 'slide-%03d.png' % (slide_n)

    if trace:
        g.trace('%7s -> %s' % (g.shortFileName(fn_src),fn_dst))

    shutil.copyfile(fn_src,fn_dst)
.. @+node:ekr.20101014110348.5346: *5* get_wink_screenshots
def get_wink_screenshots (self):

    '''Return the properly sorted list of wink screenshots.'''

    trace = False

    aList = glob.glob(self.wink_dir + '/*.png')

    def key(s):
        path,ext = g.os_path_splitext(s)
        junk,n = g.os_path_split(path)
        n = n.strip()
        if n.isdigit():
            return int(n)
        else:
            g.error('bad wink screenshot: %s' % (s))
            raise KeyError

    aList.sort(key=key) # Essential.

    if trace:
        for z in aList:
            print(z)

    return aList
.. @+node:ekr.20101018183640.5360: ** @button remove-image-directives
@language python

changed = 0
b = c.undoer.beforeChangeTree(p)

for child in p.children():
    s = child.b
    i = s.find('.. image::')
    if i > -1:
        i,j = g.getLine(s,i)
        child.b = s[:i] + s[j+1:]
        # g.es(child.h)
        changed += 1

if changed:
    g.es('changed %s nodes' % changed)
    c.undoer.afterChangeTree(p,'remove-image-directives',b)

.. @+node:ekr.20101018185243.5368: ** @button remove-final-output
@language python

changed = 0
b = c.undoer.beforeChangeTree(p)
for child in p.children():
    for child2 in child.children():
        if g.match_word(child2.h,0,'@url final output file'):
            child2.doDelete()
            changed += 1
            break

if changed:
    g.es('deleted %s nodes' % (changed))
    c.undoer.afterChangeTree(p,'remove-@url-final-output',b)
    c.redraw()
.. @+node:ekr.20101014034526.5280: ** @slideshow External files
@language rest
@pagewidth 60

.. @+node:ekr.20101014034526.5287: *3*   Topics
sentinels

With \@file, you also **share outline structure**.

Leo opens external files automatically.

Leo is an IDE
.. @+node:ekr.20101014110348.5256: *3* @slide ((no-ss intro
Leo nodes whose headline starts with \@file, \@auto or
\@edit create **external files**, files outside of Leo on
your file system::

  @file myClass.py
  @auto ../graphics/circles.cpp
  @edit ~/.leo/.leoID.txt

The headline contains a file name, which can be an absolute
path or a path relative to the directory containing the Leo
outline.

**@file** embeds outline structure directly into external
files using comments called **sentinel lines**. This is the
recommended way to share external files among Leo users.

**@auto** and **@edit** allow you to read and edit external
files without inserting sentinel lines. The cost of avoiding
sentinel lines is that Leo can not preserve outline
structure exactly.
.. @+node:ekr.20101020082858.5420: *4* @no-screenshot
.. @+node:ekr.20101021092135.5430: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\external-files\_build\html\slide-001.html
.. @+node:ekr.20101020082858.5441: *3* @slide ((no-ss auto read/write
Collectively, \@file, \@auto or \@edit trees are called
**@<file> trees**.

**Leo automatically reads and writes \@<file> trees**

When you open a Leo outline, Leo recreates all \@<file>
trees from the corresponding external files.

When you save a Leo outline, Leo writes all changed \@<file>
trees to the corresponding external files.

A single Leo outline may be connected to dozens of external
files. Reading external files is very fast because of an
efficient file-caching scheme.

As a result, Leo acts like an IDE (Integrated Development
Environment). For example, a single Leo outline contains
@file trees for all of Leo's core source files.
.. @+node:ekr.20101020082858.5443: *4* @no-screenshot
.. @+node:ekr.20101020082858.5446: *4* @url built slide
c:\leo.repo\trunk\leo\doc\html\slides\external-files\_build\html\slide-002.html
.. @+node:ekr.20101014110348.5278: *3* at-thin
.. @+node:ekr.20101019085517.5424: *4* @slide ((@file
\@file trees are the most flexible way of creating and editing external files.

Here, we have created an **@file node**, a node
whose headline start with @file.
.. @+node:ekr.20101014110348.5270: *3* at-edit
**@edit nodes** contain the entire contents of an
external file.

.. @+node:ekr.20101014110348.5275: *4* @slide ((@edit intro
Within a Leo outline, an @edit node contains
the entire contents of an external file.
.. @+node:ekr.20101014110348.5257: *4* @slide ((@edit
Here, created a node called @edit spam.py.

This represents the file spam.py in the same
directory as the Leo outline.
.. @+node:ekr.20101014110348.5261: *4* @slide ((simple body text
I've typed some text into the body pane.

The @language python line is a Leo directive. It
tells Leo to syntax color the body text as Python
source code.
.. @+node:ekr.20101014110348.5260: *4* @slide ((save, creating the file
I save the Leo outline file with Ctrl-S or the File:Save menu.

When I do that, Leo automatically saves any @edit node that
is new or has been changed.

In this case, the @edit node was new, so the log window says::

    created: c:\Users\edreamleo\.leo\spam.py
    saved: workbook.leo

Leo tells you the full path to created files, and
the short path to updated files like workbook.leo.
.. @+node:ekr.20101014110348.5262: *4* @slide ((change the text
Now I've added some more text.

The icon box shows that the @edit node is "dirty" (has been changed).
.. @+node:ekr.20101014110348.5263: *4* @slide ((save again, updating the file
I save the Leo outline again.

Once again, Leo saves spam.py.

This time, the log window says::

    wrote: spam.py
    saved: workbook.leo
.. @+node:ekr.20101014110348.5265: *4* @slide ((here is the actual file
.. @+node:ekr.20101014110348.5264: *4* @slide ((close the file
Let's close the file and reopen it.

We get exactly the same information,
with the same node selected, with the same information.

.. @+node:ekr.20101014110348.5266: *4* @slide ((edit the file outside of Leo
We can edit spam.py outside of Leo.

Let's add a comment.
.. @+node:ekr.20101014110348.5267: *4* @slide ((close Leo file and reopen
If we close the Leo file and reopen it,
we see the new text.
.. @+node:ekr.20101014110348.5274: *4* @slide ((@edit with existing files
Rather than creating new files with @edit, it is more common
to use @edit to connect Leo with files that already exist on your file system.
.. @+node:ekr.20101014110348.5271: *3* at-auto
.. @+node:ekr.20101014110348.5272: *4* ((@auto
..  At present, there are **importers** for
..  C, elisp, HTML, .ini files, Java, Javascript,
..  Pascal, PHP, Python and xml. 


**@auto** trees cause Leo to automatically create
an outline based on the structure of the external
file. 

**@auto trees** cause Leo to **import**
a file into a tree of Leo nodes, based on the
file's extension. Leo's **importers** create Leo
outlines based on the structure of the imported
language. The importer for unknown languages reads
the entire contents of the external file into the
\@auto node. **@edit nodes** cause Leo to read the
entire contents of an external file into the @edit
node.

Leo contains **importers** for common
languages. These importers split the external file
into outline nodes.
.. @-all
.. @-leo
