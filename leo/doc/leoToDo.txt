#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20071211093011:4.7 One-node world, Leo3K
@nocolor-node

- Support for Python 3.x.
- autocompleter
- Code completion.
- Refactoring: rope, etc.
- Flexitble file format.
#@nonl
#@+node:ekr.20091005145253.6059:Before b2
#@+node:ekr.20100112051224.6243:Run unit tests on Linux
#@-node:ekr.20100112051224.6243:Run unit tests on Linux
#@+node:ekr.20100112051224.6244:Ask Qt people about Ctrl-) bug
#@-node:ekr.20100112051224.6244:Ask Qt people about Ctrl-) bug
#@+node:ekr.20100112051224.6245:Help install qt on MacOS
#@-node:ekr.20100112051224.6245:Help install qt on MacOS
#@+node:ekr.20100110064516.6229:Fix bug: overwrite modified file message
#@+node:ekr.20100107064059.6199:Set read bit when writing @auto/@shadow files
@nocolor-node

Leo warns about "externally changed" file after writing the file for the first time.

The solution was to change the at_auto_read ivar to the at_read ivar.
#@nonl
#@-node:ekr.20100107064059.6199:Set read bit when writing @auto/@shadow files
#@+node:ekr.20091227085627.6538:Removed unsettling @auto warning
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    # New in Leo 4.4.7: honor @path directives.
    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>
    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Remember that we have read this file.
        # Fixes bug 488894: unsettling dialog when saving Leo file
        # after creating and populating an @auto node
        p.v.at_read = True # Create the attribute

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ville.20090701144325.14942:g.guessExternalEditor
def guessExternalEditor():
    """ Return a 'sensible' external editor """

    editor = (
        os.environ.get("LEO_EDITOR") or
        os.environ.get("EDITOR") or
        g.app.db.get("LEO_EDITOR"))

    if editor: return editor

    # fallbacks
    platform = sys.platform.lower()
    if platform.startswith('win'):
        return "notepad"
    elif platform.startswith('linux'):
        return 'gedit'
    else:
        g.es('''No editor set.
Please set LEO_EDITOR or EDITOR environment variable,
or do g.app.db['LEO_EDITOR'] = "gvim"''')
        return None
#@-node:ville.20090701144325.14942:g.guessExternalEditor
#@+node:ekr.20070806105721.1:readAtAutoNodes (commands)
def readAtAutoNodes (self,event=None):

    '''Read all @auto nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.p
    c.endEditing()

    undoData = u.beforeChangeTree(p)
    c.importCommands.readAtAutoNodes()
    u.afterChangeTree(p,'Read @auto Nodes',undoData)
    c.redraw()
#@-node:ekr.20070806105721.1:readAtAutoNodes (commands)
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    try:
        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(p, fileContent)
    except IOError:
        cachefile = None

    # Remember that we have read this file.
    p.v.at_read = True # Create the attribute

    # Disable caching for test.leo.
    if c.shortFileName() != 'test.leo':
        if cachefile is not None and cachefile in c.db:        
            # g.es('uncache:',p.h)
            aList = c.db[cachefile]
            p.v.createOutlineFromCacheList(c,aList)
            return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        # c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        self.writeCachedTree(p, cachefile)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.p ; after = p.nodeAfterTree()

    found = False
    while p and p != after:
        if p.isAtAutoNode():
            if p.isAtIgnoreNode():
                g.es_print('ignoring',p.h,color='blue')
                p.moveToThreadNext()
            else:
                self.readOneAtAutoNode(p)
                found = True
                p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    message = g.choose(found,'finished','no @auto nodes in the selected tree')
    g.es(message,color='blue')
    c.redraw()

#@+node:ekr.20070807084545:readOneAtAutoNode (leoImport)
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # Force an update of the body pane.
    self.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20070807084545:readOneAtAutoNode (leoImport)
#@-node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
#@-node:ekr.20091227085627.6538:Removed unsettling @auto warning
#@-node:ekr.20100110064516.6229:Fix bug: overwrite modified file message
#@+node:ekr.20100111094359.6208:Fix goto-line bugs
@nocolor-node

goto global line doesn't seem to be working in @auto files
https://bugs.launchpad.net/leo-editor/+bug/363406

goto-global-line doesn't work with @edit nodes
https://bugs.launchpad.net/leo-editor/+bug/399720
#@nonl
#@-node:ekr.20100111094359.6208:Fix goto-line bugs
#@+node:ekr.20080603052650.466:Fix vim problems
@nocolor
#@nonl
#@+node:ekr.20090709133307.6040:Top vim improvements
http://groups.google.com/group/leo-editor/browse_thread/thread/141690c553bfde55

Vim mode users: your top 3 complaints, please
#@nonl
#@+node:ekr.20080626081829.1:Fix headline undo problem (with vim bindings)
http://groups.google.com/group/leo-editor/browse_thread/thread/794ca596f7c58ae5

Running the latest trunk with the Vim key bindings shows the following
behavior:

Note: all steps below should leave current node in the Command state
(light blue background)

1. Select a node
2. Delete a character ('x' key)
  ! Undo menu item dimmed
3. Go to next node ('Ctrl-J' key)
  ! Undo menu item active
4. Delete a character ('x' key)
5. undo delete ('u' key)
  ! Restores previous node's character

In summary, it appears that any changes to a node's headline are not
placed in the edit history used by the undo command until after
another node has been selected.
#@nonl
#@-node:ekr.20080626081829.1:Fix headline undo problem (with vim bindings)
#@+node:ekr.20080616110054.2:Support vim dot command
The ability to repeat the last editing related command by pressing the period
key is not supported and there is no workaround in place.

Binding keys within nodes:

Some commands can be "easily" repeated by having the command's mode
bind itself to the period key.  This is not currently working.

Support commands requesting input:

Add companion commands that reuse input.  For example, a zap-to-
character-again command could exist which will reuse the key entered
in the last zap-to-character command.  With this support, the mode
that performs the initial command would assign the period key to a
companion mode that is identical to the initial mode but with the zap-
to-character command replaced by the zap-to-character-again command.

Commands requiring companion commands are:
  zap-to-character
  find-character
  backward-find-character
  (Any others?)

Notes:

- The copy of the character should be saved somewhere that does NOT affect the
  contents of the clipboard.

- The same or a separate storage location can be used for all commands to retain
  a copy of the character entered by the user. It doesn't matter since only the
  last command is assigned to the period key to be re-executed.
#@nonl
#@-node:ekr.20080616110054.2:Support vim dot command
#@-node:ekr.20090709133307.6040:Top vim improvements
#@+node:ekr.20090628190015.6003:Other problems, from leoSettings.leo

#@+node:ekr.20100112051224.6222:Commands requesting user input
Commands requesting user input must be the last command executed within an @mode
node. This prevents the implementation of commands such as "yank to <character>"
that requires a "copy to clipboard" operation after the "find-character"
command.
#@nonl
#@-node:ekr.20100112051224.6222:Commands requesting user input
#@+node:ekr.20100112051224.6223:Editing node headlines using @mode nodes
Commands modifying or selecting headline text do not work correctly within a
@mode node.

This eliminates accurate implementation of vi's delete/change/substitute/yank
object commands. As a workaround, the commands are currently written to only
select the text. The user must perform the subsequent delete, change,
substitute, and yank.
#@nonl
#@-node:ekr.20100112051224.6223:Editing node headlines using @mode nodes
#@+node:ekr.20100112051224.6225:Repeat last cursor movement command
The ability to repeat the last "To character" or "Find character" command by
selecting the ";" key is not supported and there is no workaround in place.
#@nonl
#@-node:ekr.20100112051224.6225:Repeat last cursor movement command
#@+node:ekr.20100112051224.6226:Range prefix to commands
The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

#@-node:ekr.20100112051224.6226:Range prefix to commands
#@+node:ekr.20100112051224.6227:Range prefix to objects
The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
#@nonl
#@-node:ekr.20100112051224.6227:Range prefix to objects
#@+node:ekr.20100112051224.6228:Binding numeric keys
Mapping a number to a command or an @mode node works but can not be used as it
prevents the number from being entered as text while in Vi's insert state.
#@nonl
#@-node:ekr.20100112051224.6228:Binding numeric keys
#@+node:ekr.20100112051224.6229:Binding Arrow keys
Binding arrow keys, with or without Shift, Ctrl, Alt, and their combinations, to
commands or @mode nodes have no effect.
#@nonl
#@-node:ekr.20100112051224.6229:Binding Arrow keys
#@+node:ekr.20100112051224.6230:Binding 'bksp' key
Binding 'bksp' key to back-char to move back a character in command mode
prevents 'bksp' from deleting characters in text edit mode.
#@nonl
#@-node:ekr.20100112051224.6230:Binding 'bksp' key
#@+node:ekr.20100112051224.6231:Undo command
Using the "undo" command (key 'u') to undo a change to a node's headline text
only works correctly after another node has been selected. It appears that
changes made to a node's headline text are not recorded in Leo's change history
until the edited node has lost focus.
#@nonl
#@-node:ekr.20100112051224.6231:Undo command
#@-node:ekr.20090628190015.6003:Other problems, from leoSettings.leo
#@+node:ekr.20100112051224.6246:Missing commands
#@+node:ekr.20090629183608.8445:Current character
Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
#@nonl
#@-node:ekr.20090629183608.8445:Current character
#@+node:ekr.20100112051224.6232:Toggle case command
Leo provides support for switching to upper or lower case but no method exists
to toggle between cases (used by Vi's "~" command).

#@-node:ekr.20100112051224.6232:Toggle case command
#@+node:ekr.20100112051224.6233:Replace current character command
Vi's "r" command allows user to replace the current character with the next
entered character.
#@nonl
#@-node:ekr.20100112051224.6233:Replace current character command
#@+node:ekr.20100112051224.6234:Move current line
Vi has a collection of "z<movement>" commands that will move the
current line to the top, middle, and bottom of the screen.  They are
not supported in Leo.
#@nonl
#@-node:ekr.20100112051224.6234:Move current line
#@+node:ekr.20100112051224.6235:Move buffer up/down
Vi maps keys to scroll the text up/down one line and by half the
number of visible lines.  Leo does not support this.

#@-node:ekr.20100112051224.6235:Move buffer up/down
#@+node:ekr.20100112051224.6236:Word-related commands
Vi supports two types of words in its commands: Words that consist
of only a subset of the character set and words that considers all
characters except the space and tab characters as part of a word.

Leo's always considers a word to consist of a subset of characters
although some word related commands include different characters
than others.
#@nonl
#@-node:ekr.20100112051224.6236:Word-related commands
#@+node:ekr.20100112051224.6237:Forward and backward by sentences
Leo's sentence related functions do not stop at empty lines nor do
they skip over periods within words nor do they stop at sentences
ending in non-periods nor do they stop at the end or beginning of
the buffer. Note: see forwardSentenceHelper and backSentenceHelper
functions.
#@nonl
#@-node:ekr.20100112051224.6237:Forward and backward by sentences
#@+node:ekr.20100112051224.6238:Focus to body pane
Leo functions exist which unconditionally set focus to the body pane
regardless of the active pane.

For example, bracket matching commands ("%" key) do not work within
a node's headline text.  Instead, the command is performed on the
node's body text.
#@nonl
#@-node:ekr.20100112051224.6238:Focus to body pane
#@+node:ekr.20100112051224.6239:Displaying mode help
The "--> mode-help" command has the following issues related to the
display of the "Help" tab:

1. Key label always capitalized.

Vim commands are mapped to both lower-case and upper-case keys but always appear
mapped to upper-case keys within the "Help" tab.

2. Layout of tab's contents.

To improve readability and better support narrow tab cards, display the mode's
label without the "enter-" and "-mode" text and place the key label before the
mode label.

For example, the following entries would change from::
    enter-vi-delete-line-mode d
    enter-vi-delete-to-begin-of-word-mode b
to::
    d : vi-delete-line
    b : vi-delete-to-begin-of-word
#@nonl
#@-node:ekr.20100112051224.6239:Displaying mode help
#@+node:ekr.20090629183608.8446:Notes about commands
Yank vs. Yank:
Vi's "yank" commands copy the selected text TO the clipboard.
Leo's "yank" commands insert text FROM the clipboard.

copy-text in modes:
Leo's copy-text command does not work within a mode.  As a result,
all "copy to clipboard" capability is being implemented using the
kill-<object> command followed by Leo's "yank" command to put the
text back.

paste-text in modes:
The paste-text command does not work within an @mode node.  Leo's
"yank" command is used instead.

delete-node does not copy node to clipboard:
A copy-node command is issued to copy the node to the clipboard
followed by the delete-node command.
#@-node:ekr.20090629183608.8446:Notes about commands
#@-node:ekr.20100112051224.6246:Missing commands
#@-node:ekr.20080603052650.466:Fix vim problems
#@+node:ekr.20100111164531.6226:Minor...
#@-node:ekr.20100111164531.6226:Minor...
#@+node:ekr.20100111094359.6210:Fix bug: 420988 (low) @tabwith 8 not honored, but -8 is ok
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/420988

Creating new insert-tab commands may help

======

Leo shows @tabwith 8 always as indents of 4 and only pushes tabs of 4, but works
ok with spaces of -8 at pushing indents of -8. This bug also renders poorly when
then code block consists of the Tabs and Spaces indent type, also known as Soft
tab support in some other editors, where Hard tabs are 8 and soft tabs are -4
and the mixture ends up in Leo with the soft tabbed blocks not indented into
their container code.

Leo 4.6.2 final, build 2278, August 3, 2009
Python 2.6.2, qt version 263426
linux2
#@-node:ekr.20100111094359.6210:Fix bug: 420988 (low) @tabwith 8 not honored, but -8 is ok
#@+node:ekr.20100111094359.6211:Finish bug: 486433 non-breaking space (and other invisible characters) are invisible
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/486433

Allow font specs for colorizer.
#@nonl
#@-node:ekr.20100111094359.6211:Finish bug: 486433 non-breaking space (and other invisible characters) are invisible
#@+node:ekr.20090907080624.6076:Documentation suggestions from Geoff Evans
@nocolor-node

Following Edward's suggestion that I could suggest where the
documentation might be hard to follow:

"If you are using Debian/Ubuntu, find and install the debian package."
is a bit too abbreviated.  It would help to say where it can be found
(not, as far as  I can see, in packages.ubuntu.com).

I find the bits on literate programming hard to follow. (Far from being turned
off by LP I have been using it for over 15 years, mainly FWEB but trying noweb
for Python.) Chapter 6 says that Leo is great for LP, but is short on details of
how to make it work. One of the attractions of noweb or FWEB is that the natural
order for describing a program need have nothing to do with syntactically
correct order. Leo appears to require syntactically correct order -- though I
guess this is where clones come in: if I want a view of a few sections "out of
order" then I create a view to do just that. But I seem to lose the automatic
cross-referencing that *web offers.

A related point, there seems to be no documentation on how Export to noweb is
supposed to work. If I have two classes, and I use @others for assembling
methods within each, then Export to noweb seems to produce a single @others
section which is not what was wanted. So, some more explanation of what is
supposed to happen and how to make it happen would be useful.

====== Ville's comments

> "If you are using Debian/Ubuntu, find and install the debian package."
> is a bit too abbreviated.  It would help to say where it can be found
> (not, as far as  I can see, in packages.ubuntu.com).

That's because it was not obvious at the time this snippet was written
where the user would get the deb file :-).

Currently, it's available at the leo download page. I've been trying
to get it to debian official repos (that's the way to get it to
Ubuntu), but so far nobody on debian side has picked up the
sponsorship (which means the task of uploading it to official debian
archive). I figure I'll make a new upload to "debian mentors" when we
get 4.6.3 out, and try to attract some attention by hanging on IRC.

However, getting your hands on the .deb is as easy as getting the
other installers

With any luck, 4.6.3 will have exe installer for windows, deb for
debian/ubuntu, and the rest can run launchLeo.py. We can mostly forget
that section of the docs.
#@nonl
#@-node:ekr.20090907080624.6076:Documentation suggestions from Geoff Evans
#@+node:ekr.20100108101415.6196:Create insert-tab commands (not urgent)
# insert-tab-or-indent-region, insert-hard-tab, insert-soft-tab.
#@nonl
#@-node:ekr.20100108101415.6196:Create insert-tab commands (not urgent)
#@-node:ekr.20091005145253.6059:Before b2
#@+node:ekr.20090811090022.6029:Bugs
#@+node:ekr.20080517102922.1:File bugs & features
#@+node:ekr.20081204091750.4:Fix inconsistency in how @path works
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/6d87d95ecbc3b986

If a @path directive is within the body text of an @thin node then the
file write uses the @path directive but the file read does not.  Since
the file read cannot know of the @path directive until after it has
read the file it has no choice but to not use it.  The @thin file
write code should not use any @path declarations found in its body
text.
#@nonl
#@-node:ekr.20081204091750.4:Fix inconsistency in how @path works
#@+node:ekr.20080406075855.2:Fix problem with already-existing .leo.bak files
@nocolor

I also unhappily discovered that any file named somedoc.leo.bak will
get deleted whenever you save a file named somedoc.leo.

@color
#@nonl
#@-node:ekr.20080406075855.2:Fix problem with already-existing .leo.bak files
#@+node:ekr.20080815063811.1:Write fixed-window size when writing .leo files
#@-node:ekr.20080815063811.1:Write fixed-window size when writing .leo files
#@+node:ekr.20080918164844.14:Protect @shadow and @auto files from overwriting external changes
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/bac65cb75484f7cb

BTW, I think we should prevent shadow files from accidentally
overwriting valuable stuff:

- Store modification time of the file on shadow import

- When you "save", check if modification time has changed and ask the
user if they really want to overwrite the changes. Or, reuse to do it
altogether and require explicit save-at-shadow-nodes in those
occasions. That's considered "good form" in editors in general, and
since pressing ctrl+S in leo has even more significant implications we
should be absolutely certain everything happens safely. 
#@nonl
#@-node:ekr.20080918164844.14:Protect @shadow and @auto files from overwriting external changes
#@+node:ekr.20080412053100.1:Look into undefined-section behavior
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/db797dd1d4dddffb

1) Create an @thin file based outline.
2) In the @thin file, create an unreferenced section (something like a
  header <<This Section Is Bogus>>).
3) Now, File->Exit
4) A dialog box pops up
  (Save changes to leo_file.leo before quitting? Yes/No/Cancel)
5) Click "Yes"
6) In the log pane, you will see: "undefined section" and "saved: leo_file.leo"
  and in the console window, you see "undefined section: ..."

However, the application is still running. The only way to really quit
is to click "No" to the Save dialog.

> Iirc, this is the intended behavior.  It would be possible to build in some
> state behavior to only ask once, but I'd rather not do that.

The point is that I can't kill Leo if I keep saying "Yes" to the
"Save change before quitting" dialog. This is definitely not the
intended behavior. The correct behavior would be to save the file,
give me the warning about the undefined section, and exit.
#@nonl
#@-node:ekr.20080412053100.1:Look into undefined-section behavior
#@-node:ekr.20080517102922.1:File bugs & features
#@+node:ekr.20100109214940.6227:Other bugs
#@+node:ekr.20090907080624.6081:Spell checker should check headlines
#@-node:ekr.20090907080624.6081:Spell checker should check headlines
#@+node:ekr.20090813112405.5980:Delete resurrected nodes
@nocolor-node

https://sourceforge.net/forum/message.php?msg_id=3525277

This problem is hard.
It may be simpler in the one-node world.
#@nonl
#@-node:ekr.20090813112405.5980:Delete resurrected nodes
#@+node:ekr.20090131200406.11:Remove remaining tk-isms from Leo's core
@nocolor-node

Eliminate all tk-indices from leoEditCommands.py

(found) wordend, wordstart
(found) lineend, linestart
(found) sel.first, sel.last
(found) w.insert, w.delete
#@+node:ekr.20060529184652.1:transposeWords (doesn't work)
def transposeWords (self,event):

    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='transpose-words')
    self.swapWords(event,self.swapSpots)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20060529184652.1:transposeWords (doesn't work)
#@+node:ekr.20050920084036.123:swapWords
def swapWords (self,event,swapspots):

    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('swap-words command not ready yet',color='blue')

    s = w.getAllText()

    txt = w.get('insert wordstart','insert wordend') ###
    if not txt: return

    i = w.index('insert wordstart') ###

    self.beginCommand(undoType='swap-words')

    if len(swapspots):
        if i > swapspots[1]:
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif i < swapspots[1]:
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.123:swapWords
#@+node:ekr.20060529184652:swapHelper
def swapHelper (self,w,find,ftext,lind,ltext):

    w.delete(find,'%s wordend' % find) ###
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
#@-node:ekr.20060529184652:swapHelper
#@+node:ekr.20050920084036.27:expandAbbrev
def expandAbbrev (self,event):

    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.'''

    k = self.k ; c = self.c ; ch = event.char.strip()
    w = self.editWidget(event)
    if not w: return

    word = w.get('insert -1c wordstart','insert -1c wordend') ###
    g.trace('ch',repr(ch),'word',repr(word))
    if ch:
        # We must do this: expandAbbrev is called from Alt-x and Control-x,
        # we get two differnt types of data and w states.
        word = '%s%s'% (word,ch)

    val = self.abbrevs.get(word)
    if val is not None:
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Typing')

    return val is not None
#@-node:ekr.20050920084036.27:expandAbbrev
#@+node:ekr.20050920084036.238:appendToRegister
def appendToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('append-to-reg')

    if state == 0:
        k.setLabelBlue('Append to register: ',protect=True)
        k.setState('append-to-reg',1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = val + w.get('sel.first','sel.last') ###
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.238:appendToRegister
#@+node:ekr.20050920084036.237:prependToRegister
def prependToRegister (self,event):

    '''Prompt for a register name and prepend the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('prepend-to-reg')

    if state == 0:
        k.setLabelBlue('Prepend to register: ',protect=True)
        k.setState('prepend-to-reg',1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = w.get('sel.first','sel.last') + val ###
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.237:prependToRegister
#@+node:ekr.20050920084036.240:copyToRegister
def copyToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-to-reg')

    if state == 0:
        k.commandName = 'copy-to-register'
        k.setLabelBlue('Copy to register: ',protect=True)
        k.setState('copy-to-reg',1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                key = event.keysym.lower()
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                try:
                    val = w.get('sel.first','sel.last') ###
                except Exception:
                    g.es_exception()
                    val = ''
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.240:copyToRegister
#@-node:ekr.20090131200406.11:Remove remaining tk-isms from Leo's core
#@+node:ekr.20081208102356.1:Threading colorizer doesn't handle multiple body editors
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/5be7a099b299327e

> Tk only colorizes one body editor, and if you delete that editor it
> colorizes no editor.

Thanks for this report.  This is a problem, never noticed until now,
with the threading colorizer.  A workaround is to disable the
threading colorizer plugin. 
#@nonl
#@-node:ekr.20081208102356.1:Threading colorizer doesn't handle multiple body editors
#@+node:ekr.20080509065556.2:Fix mod_tempfname plugin
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/ad23258d1a46234c

On Fri, May 9, 2008 at 5:56 AM, bobjack <bobjack@post.com> wrote:

> If a headline ending in ... (ellipses) is an ancestor of a node to be edited
the file path formed is invalid (at least on windows vista), so the node can not
be edited.


Hmm.  mod_tempfname has a problem.  If it filters out non-ascii unicode characters it will have problem with, say, Chinese file names.  So the naive plan of filtering all characters *except* the valid ascii characters is flawed.

Drat.  I suppose building in unicode smarts: filtering 'general punctuation' characters is needed.  See:

http://www.fileformat.info/info/unicode/char/2026/index.htm
#@nonl
#@-node:ekr.20080509065556.2:Fix mod_tempfname plugin
#@-node:ekr.20100109214940.6227:Other bugs
#@-node:ekr.20090811090022.6029:Bugs
#@-node:ekr.20071211093011:4.7 One-node world, Leo3K
#@+node:ekr.20100109214940.6225:4.8 Autocompletion, vim
#@+node:ekr.20090131200406.14:autocompletion
#@+node:ekr.20081005065934.12:Links from Ville re Scintilla
@nocolor-node

It seems Scintilla relies on externally generated api description
files to provide autocompletion. Links that may be of interest:

http://www.riverbankcomputing.co.uk/static/Docs/QScintilla2/classQsciAPIs.html#b0f824492bb0f3ca54edb4d46945a3de

http://www.burgaud.com/scite-java-api/

http://scintilla.sourceforge.net/tags2api.py

http://www.koders.com/python/fid7000B9C96CF2C6FB5BCE9DF700365C5B2A1F36A7.aspx?s=gtk#L53
#@-node:ekr.20081005065934.12:Links from Ville re Scintilla
#@+node:ekr.20080113165010:About auto completion
@nocolor

Summary: inspect when possible, ask for types otherwise.

    os.? gives a list of all instances of os module.
    x.? gives a list of all known classes.
    x.# gives list of all known functions.
    self.? gives all known methods and ivars of the enclosing class.
    The user will be able to specify type conventsions, like Leo's c,g,p,t,v vars.

Completed (mostly): user interface stuff.

Performance isn't too hard:
    - Do all scanning in separate threads.
    - Associate node info with tnodes.
    - Update node info when deselecting a node (in tree base class)

Parsing:
    - Forgiving parser is essentially complete.
    - It's easy to parse python def lines.
#@nonl
#@-node:ekr.20080113165010:About auto completion
#@+node:ekr.20080110082845:pyxides: code completion
@nocolor

Python code completion module


From: "Tal Einat" <talei...@gmail.com>
Date: Wed, 6 Jun 2007 20:57:18 +0300

I've been developing IDLE over the past 2 years or so. Even before
that, I helped a friend of mine, Noam Raphael, write IDLE's
auto-completion, which is included in recent versions of IDLE.

Noam wrote the original completion code from scratch, and AFAIK every
Python IDE which features code completion has done the same. Surely
there is -some- functionality which could be useful cross-IDE?
Retrieving possible completions from the namespace, for example. And
we should be learning from each-others' ideas and experiences.

So how about we design a generic Python completion module, that
each IDE could extend, and use for the completion logic?



From: "Ali Afshar" <aafs...@gmail.com>
Date: Wed, 6 Jun 2007 19:06:01 +0100

I am very keen for this. I will help where it is required. PIDA
currently has no code completion (outside what vim/emacs provide),



From: "phil jones" <inters...@gmail.com>
Date: Wed, 6 Jun 2007 11:07:33 -0700

What functions would we ask for a code completion module?

Presumably recognition of the beginnings of
- a) python keywords
- b) classes and functions defined earlier in this file?
- c) in scope variables?

As python is dynamically typed, I guess we can't expect to know the
names of methods of objects?



From: "Ali Afshar" <aafs...@gmail.com>
Date: Wed, 6 Jun 2007 19:13:10 +0100

> Presumably recognition of the beginnings of
> - a) python keywords
> - b) classes and functions defined earlier in this file?
> - c) in scope variables?

does c) include: d) imported modules



From: Nicolas Chauvat <nicolas.chau...@logilab.fr>
Date: Wed, 6 Jun 2007 20:17:30 +0200

> >Presumably recognition of the beginnings of
> >- a) python keywords
> >- b) classes and functions defined earlier in this file?
> >- c) in scope variables?

> does c) include: d) imported modules

For code-completion, I suppose astng[1] could be useful.

1: http://www.logilab.org/project/eid/856



From: Stani's Python Editor <spe.stani...@gmail.com>
Date: Wed, 06 Jun 2007 20:48:41 +0200

A good point. I think we all have been thinking about this. Important
issues for the design is the extraction method and the sources.

*the method*
Importing is a lazy, but accurate way of importing, but is security wise
not such a good idea. Parsing throught an AST compiler is better,
however more difficult. Here are two options.

From version 2.5 the standard Python compiler converts internally the
source code to an abstract syntax tree (AST) before producing the
bytecode. So probably that is a good way to go as every python
distribution has this battery included.

As Nicolas suggested earlier on this mailing list, there is another
option: the AST compiler in python or PyPy:

On Mar 14 2006, 12:16 am, Nicolas Chauvat <nicolas.chau...@logilab.fr>
wrote:

> > WingIDE use anASTgenerator written in C (but cross-platform),
> > lightningly quick, and open sourced. This could be a potential
> > starting point.

> > Additionally isn't Python2.5 planned to have a C-written compiler?

> PyPy also produced an improved parser/compiler.

> http://codespeak.net/pypy/dist/pypy/doc/index.html
> http://codespeak.net/pypy/dist/pypy/module/recparser/

But if it could be done with the standard one it is one dependency less.

*the sources*
In the design we could define first the sources:
1 external imported modules from the pythonpath
2 local modules relative to the current file or context dependent
(Blender, Gimp, ...)
3 inner code

For 1:
It might be a good idea to have a function which scans all the modules
from the pythonpath or one specific module to cache all autocompletion
and calltip information of all classes, methods and doc strings. Why?
Modules in the pythonpath don't change so often. With some criteria
(file name, time stamp, size, ...) you could check if updates are
necessary at startup. Having a readymade 'database' (could be python
dictionary or sqlite database) for autocompletion/call tips would speed
up things (and is also more secure if you are importing rather than
parsing. For example trying to provide gtk autocompletion in a wxPython
by importing is problematic).

For 2:
Here you load the parser on demand. Autocompletion/calltip information
can be added to the database.

For 3:
A different kind of parser needs to be used here as per definition code
you edit contains errors while typing. External modules are retrieved
from 1 and 2, for internal code you can scan all the words and add them
to the autocomplete database. As a refinement you can give special
attention to 'self'. Also for calltips you can inherit when there are
assignments, eg
frame = Frame()
than frame inherits autocomplete & calltip information from Frame.

So autocompletion & calltips deals with two steps: extraction and
'database'. If someone has a good parser already, we could use it.
Otherwise we can define an API for the extraction and maybe lazily
implement it first with importing and concentrate first on the
'database'. When the database is ready we can implement the parsing. You
could also implement the parsing first, but than it takes longer before
you have results. Of course the library is GUI independent, it only
works with strings or lists.

What concerns SPE, it uses importing for autocompletion (1+2) and does
internal code analysis for local code (however without the inheriting).

Tal, how does IDLE's autocompletion works?

Stani



From: Stani's Python Editor <spe.stani...@gmail.com>
Date: Wed, 06 Jun 2007 20:53:10 +0200

Nicolas Chauvat wrote:
> On Wed, Jun 06, 2007 at 07:13:10PM +0100, Ali Afshar wrote:
>>> Presumably recognition of the beginnings of
>>> - a) python keywords
>>> - b) classes and functions defined earlier in this file?
>>> - c) in scope variables?
>> does c) include: d) imported modules

> For code-completion, I suppose astng[1] could be useful.

> 1: http://www.logilab.org/project/eid/856

How dependent/independent is this from the standard AST compiler or
PyPy? Is it more IDE friendly? Is it based on it or a total independent
implementation?



From: "Ali Afshar" <aafs...@gmail.com>
Date: Wed, 6 Jun 2007 19:59:13 +0100

> A good point. I think we all have been thinking about this. Important
> issues for the design is the extraction method and the sources.

> *the method*
> Importing is a lazy, but accurate way of importing, but is security wise
> not such a good idea. Parsing throught an AST compiler is better,
> however more difficult. Here are two options.

> From version 2.5 the standard Python compiler converts internally the
> source code to an abstract syntax tree (AST) before producing the
> bytecode. So probably that is a good way to go as every python
> distribution has this battery included.

> As Nicolas suggested earlier on this mailing list, there is another
> option: the AST compiler in python or PyPy:

What concerns me about these is whether they would work in a module
which has a syntax error.

I believe Wing's compiler bit of their code completion is open source.
I remember having seen the code.



From: Stani <spe.stani...@gmail.com>
Date: Wed, 06 Jun 2007 12:08:00 -0700

> What concerns me about these is whether they would work in a module
> which has a syntax error.

> I believe Wing's compiler bit of their code completion is open source.
> I remember having seen the code.

It is indeed, but is implemented in C, which means an extra dependency
and not a 100% python solution. Normally modules (especially in the
pythonpath) which you import don't have syntax errors. Maybe logilabs
implementation handles syntax errors well as it is developed for
PyLint. Nicolas?



From: "Tal Einat" <talei...@gmail.com>
Date: Wed, 6 Jun 2007 22:34:41 +0300

> As python is dynamically typed, I guess we can't expect to know the
> names of methods of objects?

Well, the dir() builtin does just that, though there can be attributes
which won't be included therein. However, the builtin dir() can be
overridden... and ignoring it can break libraries like RPyC which
define a custom dir() function just for this purpose.

This issue has already been run in to by RPyC (an Python RPC lib). The
main developr went ahead and suggested adding a __dir__ method which
will return a list of attributes, and IIRC he has already implemented
a patch for this, and it will likely enter Python2.6.

Until then, I guess we're going to have to rely on dir for this.



From: "Josiah Carlson" <josiah.carl...@gmail.com>
Date: Wed, 6 Jun 2007 12:42:01 -0700

For reference, PyPE auto-parses source code in the background, generating
(among other things) a function/class/method hierarchy.  Its autocomplete
generally sticks to global functions and keywords, but when doing
self.method lookups, it checks the current source code line, looks up in its
index of classes/methods, and trims the results based on known methods in
the current class in the current source file.

It certainly isn't complete (it should try to check base classes of the
class in the same file, it could certainly pay attention to names assigned
in the current scope, the global scope, imports, types of objects as per
WingIDE's assert isinstance(obj, type), etc.), but it also makes the
computation fairly straightforward, fast, and only in reference to the
current document.



From: "Tal Einat" <talei...@gmail.com>
Date: Wed, 6 Jun 2007 22:52:08 +0300

> Tal, how does IDLE's autocompletion works?

Much like Stani said, since Python is interpreted, collection of
possible completions splits into two methods:
1) source code analysis
2) dynamic introspection

Of course, we could do either or a combination of both.

IDLE just uses introspection: since IDLE always has a python shell
running, it just completes according to the shell's state (plus
built-in keywords and modules). This is a very simple method,
obviously lacking. It does allow the user some control of the
completion, though - just import whatever you want to be completable
in the shell. However, introspection is all that is needed in a Python
shell, which is the major reason this is the method used in IDLE.



From: Nicolas Chauvat <nicolas.chau...@logilab.fr>
Date: Wed, 6 Jun 2007 23:59:32 +0200


> How dependent/independent is this from the standard AST compiler or
> PyPy? Is it more IDE friendly? Is it based on it or a total independent
> implementation?

It is independent from PyPy.

The above web page says:

"""
Python Abstract Syntax Tree New Generation

The aim of this module is to provide a common base representation of
python source code for projects such as pychecker, pyreverse,
pylint... Well, actually the development of this library is essentialy
governed by pylint's needs.

It extends class defined in the compiler.ast [1] module with some
additional methods and attributes. Instance attributes are added by a
builder object, which can either generate extended ast (let's call
them astng ;) by visiting an existant ast tree or by inspecting living
object. Methods are added by monkey patching ast classes.Python
Abstract Syntax Tree New Generation

The aim of this module is to provide a common base representation of
python source code for projects such as pychecker, pyreverse,
pylint... Well, actually the development of this library is essentialy
governed by pylint's needs.

It extends class defined in the compiler.ast [1] module with some
additional methods and attributes. Instance attributes are added by a
builder object, which can either generate extended ast (let's call
them astng ;) by visiting an existant ast tree or by inspecting living
object. Methods are added by monkey patching ast classes.
"""

From: "Sylvain Th√©nault" <thena...@gmail.com>
Date: Wed, 13 Jun 2007 10:51:04 +0200

> Please let me involve Sylvain in the discussion. As the main author of
> pylint and astng, he will provide better answers.

well logilab-astng is basically a big monkey patching of the compiler
package from the stdlib, so you can't get an astng representation from a
module with syntax errors in. However inference and most others
navigation methods (which are basically the value added by astng) are
"syntax error resilient" : if a dependency module (direct or indirect)
contains a syntax error, you don't get any exception, though since some
information is missing you can miss some results you'ld get if the
faulting module were parseable.



From: "Tal Einat" <talei...@gmail.com>
Date: Tue, 31 Jul 2007 10:33:33 +0300

Since astng already does some inference (which we definitely want!)
and is based on the standard Python AST compiler, it sounds like our
#1 candidate. I think we should give the code a serious once-over and
see how well it fits our requirements, and if it can be adapted to
better handle errors. Any volunteers?

Also, has anyone used astng for completion, calltips, or something
similar? Or the standard AST compiler, for that matter?



From: "Tal Einat" <talei...@gmail.com>
Date: Tue, 31 Jul 2007 10:40:11 +0300

How does PyPE parse code? Home-rolled, standard AST compiler, something else?

It seems to me we should try to come up with an algorithm for parsing,
before getting to the code. All of the details you mentioned -
noticing assignments, using base-class methods, etc. - could be better
defined and organized this way. Perhaps we could brainstorm on this in
a wiki?



From: "Tal Einat" <talei...@gmail.com>
Date: Tue, 31 Jul 2007 11:38:40 +0300

Sorry for being away for such a long time. I hope we can get this
conversation rolling again, and get started with the actual work.

I'll try to sum up what has been said so far, and how I see things.

== Top Priorities ==
* Can we implement a parser based on the standard Python AST compiler
(or astng)? For example, can syntax errors be handled well?
* Is importing reasonable security-wise? If not, can it be made secure?

== General issues ==
* Do we aim for just completion, or also calltips? Perhaps also other
meta-data, e.g. place defined, source code, ... (see IPython's '??')
* Dependencies - do we want to allow C-extensions, or are we going for
a Python-only solution? (IDLE would only use such a Python-only tool.)
It seems that we want to pre-process most of the data in the
background, so I don't see why we would want to do this in C for
efficiency reasons.

== Completion sources ==
1) Importing "external" modules
2) Importing/Parsing "local" modules
3) Parsing the current file
4) Using objects/modules from the shell (e.g. IDLE has both editor
windows and a Python shell)

== Importing ==
* Stani mentioned that importing is problematic from a security point
of view. What are the security issues? Are they really an issue for an
IDE? If so, perhaps we could overcome this by importing in some kind
of "sandbox"?
* What are the pros and cons of Importing vs. Parsing?
* If importing is always preferable to parsing unless there's a syntax
error, perhaps try to import and parse on failure?

== Parsing ==
* This is going to be the most complex method - I think we should have
a general idea of how this should work before starting an
implementation. I suggest hashing ideas out on a wiki, since there a
lot of details to consider.
* Can a parser based on the standard AST compiler (or astng) work? Is
there a way to deal with errors? (HIGH PRIORITY!)
* There are other existing, open-source implementations out there -
WingIDE, PyPE have been mentioned. Any others? We should collect these
so we can use the code for learning, and perhaps direct use (if
possible license-wise).

== Shell ==
This is relatively straight-forward - just use dir(). This should be
optional, for use by IDEs which have a shell (support multiple
shells?).

Some known issues from IDLE and PyCrust:
* Handle object proxies such as RPC proxies (e.g. RPyC)
* Handle ZODB "ghost" objects
* Watch out for circular references
* Watch out for objects with special __getattr__/__hasattr__
implementations (for example xmlrpc, soap)

== Persistence ==
* Stani mentioned a 'database'. I feel Sqlite should be at most
optional, to reduce dependencies.
* Do we really want to have the data persistent (between IDE
sessiosns)? If so, we need to support simultaneous instances of the
IDE so they don't corrupt the data. Any other issues? (I have a
feeling this would better be left for later stages of development.)



From: "Tal Einat" <talei...@gmail.com>
Date: Tue, 31 Jul 2007 12:22:59 +0300

One more note: We should distinguish between completion in an editor
and completion in a shell. The conversation up until now has focused
on editors, which is reasonable since that is the problematic scene. I
think a generic Python completion library should support completion in
both contexts, especially if it uses can use a shell's namespace for
completion in the editor.



From: "Ali Afshar" <aafs...@gmail.com>
Date: Tue, 31 Jul 2007 11:20:19 +0100

I have just implemented a completion mockup using Rope (which is a
refactoring library). It works quite nicely, and definitely worth a
look.

http://rope.sourceforge.net/

It even achieves this kind of completion:

class Banana(object):
    def do_something(self):
         return

def foo():
    return [Banana(), Banana()]

foo()[0].<complete> includes do_something

Which seems pretty impressive to me.



From: "Tal Einat" <talei...@gmail.com>
Date: Tue, 31 Jul 2007 20:12:50 +0300

Wow, Rope does look very impressive! A quick look at the code tells me
that a lot of work has been invested in it.

So we have one existing Python-only solution. We should evaluate it -
see what it can and can't do, and perhaps take a look at the overall
design.

I'm CC-ing Rope's developer, Ali. Hopefully Ali can help us quickly
understand Rope's code analysis capabilities.

Ali, could you elaborate a bit on what kinds of completion Rope can
do, and the methods it uses? We would especially like to know how your
static and dynamic inference work, what they can accomplish, and what
their limitations are.



From: "Ali Afshar" <aafs...@gmail.com>
Date: Tue, 31 Jul 2007 19:45:15 +0100

> Ali, could you elaborate a bit on what kinds of completion Rope can
> do, and the methods it uses? We would especially like to know how your
> static and dynamic inference work, what they can accomplish, and what
> their limitations are.

Well, I haven't really looked at the code. But I can tell you this:

from rope.ide.codeassist import PythonCodeAssist
from rope.base.project import Project
for compl in PythonCodeAssist(Project(package_root)).assist(buffer,
offset).completions:
    print compl

And that is as far as I really got. I expect to get a better look at
it later in the week though...


From: "Josiah Carlson" <josiah.carl...@gmail.com>
Date: Wed, 1 Aug 2007 00:26:14 -0700

> How does PyPE parse code? Home-rolled, standard AST compiler, something else?

The compiler for syntactically correct Python, a line-based compiler
for broken Python.  TO generate a method list for self.methods, using
the current line number, I discover the enclosing class, check the
listing of methods for that class (generated by the compiler or
line-based parsers), and return a valid list for the specified prefix.
 It doesn't walk the inheritance tree, it doesn't do imports, etc.

> It seems to me we should try to come up with an algorithm for parsing,
> before getting to the code. All of the details you mentioned -
> noticing assignments, using base-class methods, etc. - could be better
> defined and organized this way. Perhaps we could brainstorm on this in
> a wiki?

A wiki would be fine, the one for this mailing list would likely be
best (if it is still up and working).  Then again, Rope looks quite
nifty.  I may have to borrow some of that source ;)


Discussion subject changed to "Fwd: Python code completion module" by Tal Einat

From: Ali Gholami Rudi <aligr...@gmail.com>
Date: Aug 1, 2007 5:50 PM

First of all I should note that rope's main goal was being a
refactoring tool and a refactoring tool needs to know a lot about
python modules.  `rope.base` package provides information about python
modules.

Actually what ropeide provides as auto-completion is defined in
`rope.ide.codeassist` module.  This module almost does nothing but use
`rope.base`.  Since `rope.ide` package is not included in the rope
library (which has been separated from ropeide since 0.6m4) it lacks
good documentation and the API might not be easy to use (most of it is
written in the first months of rope's birth).

> ..., could you elaborate a bit on what kinds of completion Rope can
> do, ...

I don't know what to say here.  Well, actually it tries to use the
source code as much as possible and infer things from it.  So I can
say that it can complete any obvious thing that can be inferred by a
human.  Like this is the first parameter of a method and after dots
its attributes can appear or these modules are imported so their names
and contents are available or this is an instance of some known type
and we know its attributes and ... .  Try ropeide (it uses emacs-like
keybinding, C-/ for completion; see ~/.rope if you want to change
that); it completes common cases (and sometimes completes things you
don't expect it to!).

> ..., and the methods it uses?

Rope analyzes python source code and AST.  Rope used to use the
`compiler` module till 0.5 and now it uses `_ast` module.

> We would especially like to know how your
> static and dynamic inference work, what they can accomplish

There are a few examples in docs/overview.txt.  Unit-test modules like
`ropetest.base.objectinfertest` and `advanced_oi_test` might help,
too.  Also have a look at `rope.base.oi.__init__` pydoc for an
overview of how they work; (I'm afraid it is a bit out of date and
carelessly written.)  The idea behind rope's object inference is to
guess what references (names in source-code) hold.  They collect
information about code when they can and use them later.

>..., and what their limitations are.

Many things in rope are approximations that might be exact if some
conditions hold.  For instance rope might assume that every normal
reference in module scope holds only one kind of object.  Apart from
these assumptions both SOI and DOI have their own disadvantages; For
instance SOI fails when dynamic code is evaluated while DOI does not.
Or DOI is slower than SOI.  (Well, after recent enhancements to rope's
SOI I rarely use DOI).

I tried to answer as short as possible.  If there are questions on
specific parts of rope, I'll be happy to answer.

By the way, I tried to reply this mail to the group, but it seems that
your group requires subscription for posting, so I've sent it to you,
instead.
#@nonl
#@-node:ekr.20080110082845:pyxides: code completion
#@+node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
@nocolor

Disabled these binding:

auto-complete-force = None # This command needs work before it is useful. Ctrl-period
show-calltips-force = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
#@nonl
#@-node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
#@+node:ekr.20071106083149:Recent post
@killcolor

In general, autocompletion is a tricky problem. Consider:

- There may be no 'clean' version of the source code that you want to
auto-complete: you may be creating a new node, or a new file, and the source
code, being incomplete, will not parse correctly.

- Except in special circumstances, there is no 'real' object corresponding to s,
so there is no way to use Python's inspect module on s. Modules are an
exception: the autocompleter can handle existing modules fairly well. Try "os."
or "os.path." for example.


It might be possible to generalize c.k.defineObjectDict so that the user
could specify autocompleter conventions, say in an @autocompleter node in an
@settings tree.
#@nonl
#@-node:ekr.20071106083149:Recent post
#@-node:ekr.20090131200406.14:autocompletion
#@+node:ekr.20080603052650.466:Fix vim problems
@nocolor
#@nonl
#@+node:ekr.20090709133307.6040:Top vim improvements
http://groups.google.com/group/leo-editor/browse_thread/thread/141690c553bfde55

Vim mode users: your top 3 complaints, please
#@nonl
#@+node:ekr.20080626081829.1:Fix headline undo problem (with vim bindings)
http://groups.google.com/group/leo-editor/browse_thread/thread/794ca596f7c58ae5

Running the latest trunk with the Vim key bindings shows the following
behavior:

Note: all steps below should leave current node in the Command state
(light blue background)

1. Select a node
2. Delete a character ('x' key)
  ! Undo menu item dimmed
3. Go to next node ('Ctrl-J' key)
  ! Undo menu item active
4. Delete a character ('x' key)
5. undo delete ('u' key)
  ! Restores previous node's character

In summary, it appears that any changes to a node's headline are not
placed in the edit history used by the undo command until after
another node has been selected.
#@nonl
#@-node:ekr.20080626081829.1:Fix headline undo problem (with vim bindings)
#@+node:ekr.20080616110054.2:Support vim dot command
The ability to repeat the last editing related command by pressing the period
key is not supported and there is no workaround in place.

Binding keys within nodes:

Some commands can be "easily" repeated by having the command's mode
bind itself to the period key.  This is not currently working.

Support commands requesting input:

Add companion commands that reuse input.  For example, a zap-to-
character-again command could exist which will reuse the key entered
in the last zap-to-character command.  With this support, the mode
that performs the initial command would assign the period key to a
companion mode that is identical to the initial mode but with the zap-
to-character command replaced by the zap-to-character-again command.

Commands requiring companion commands are:
  zap-to-character
  find-character
  backward-find-character
  (Any others?)

Notes:

- The copy of the character should be saved somewhere that does NOT affect the
  contents of the clipboard.

- The same or a separate storage location can be used for all commands to retain
  a copy of the character entered by the user. It doesn't matter since only the
  last command is assigned to the period key to be re-executed.
#@nonl
#@-node:ekr.20080616110054.2:Support vim dot command
#@-node:ekr.20090709133307.6040:Top vim improvements
#@+node:ekr.20090628190015.6003:Other problems, from leoSettings.leo

#@+node:ekr.20100112051224.6222:Commands requesting user input
Commands requesting user input must be the last command executed within an @mode
node. This prevents the implementation of commands such as "yank to <character>"
that requires a "copy to clipboard" operation after the "find-character"
command.
#@nonl
#@-node:ekr.20100112051224.6222:Commands requesting user input
#@+node:ekr.20100112051224.6223:Editing node headlines using @mode nodes
Commands modifying or selecting headline text do not work correctly within a
@mode node.

This eliminates accurate implementation of vi's delete/change/substitute/yank
object commands. As a workaround, the commands are currently written to only
select the text. The user must perform the subsequent delete, change,
substitute, and yank.
#@nonl
#@-node:ekr.20100112051224.6223:Editing node headlines using @mode nodes
#@+node:ekr.20100112051224.6225:Repeat last cursor movement command
The ability to repeat the last "To character" or "Find character" command by
selecting the ";" key is not supported and there is no workaround in place.
#@nonl
#@-node:ekr.20100112051224.6225:Repeat last cursor movement command
#@+node:ekr.20100112051224.6226:Range prefix to commands
The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

#@-node:ekr.20100112051224.6226:Range prefix to commands
#@+node:ekr.20100112051224.6227:Range prefix to objects
The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
#@nonl
#@-node:ekr.20100112051224.6227:Range prefix to objects
#@+node:ekr.20100112051224.6228:Binding numeric keys
Mapping a number to a command or an @mode node works but can not be used as it
prevents the number from being entered as text while in Vi's insert state.
#@nonl
#@-node:ekr.20100112051224.6228:Binding numeric keys
#@+node:ekr.20100112051224.6229:Binding Arrow keys
Binding arrow keys, with or without Shift, Ctrl, Alt, and their combinations, to
commands or @mode nodes have no effect.
#@nonl
#@-node:ekr.20100112051224.6229:Binding Arrow keys
#@+node:ekr.20100112051224.6230:Binding 'bksp' key
Binding 'bksp' key to back-char to move back a character in command mode
prevents 'bksp' from deleting characters in text edit mode.
#@nonl
#@-node:ekr.20100112051224.6230:Binding 'bksp' key
#@+node:ekr.20100112051224.6231:Undo command
Using the "undo" command (key 'u') to undo a change to a node's headline text
only works correctly after another node has been selected. It appears that
changes made to a node's headline text are not recorded in Leo's change history
until the edited node has lost focus.
#@nonl
#@-node:ekr.20100112051224.6231:Undo command
#@-node:ekr.20090628190015.6003:Other problems, from leoSettings.leo
#@+node:ekr.20100112051224.6246:Missing commands
#@+node:ekr.20090629183608.8445:Current character
Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
#@nonl
#@-node:ekr.20090629183608.8445:Current character
#@+node:ekr.20100112051224.6232:Toggle case command
Leo provides support for switching to upper or lower case but no method exists
to toggle between cases (used by Vi's "~" command).

#@-node:ekr.20100112051224.6232:Toggle case command
#@+node:ekr.20100112051224.6233:Replace current character command
Vi's "r" command allows user to replace the current character with the next
entered character.
#@nonl
#@-node:ekr.20100112051224.6233:Replace current character command
#@+node:ekr.20100112051224.6234:Move current line
Vi has a collection of "z<movement>" commands that will move the
current line to the top, middle, and bottom of the screen.  They are
not supported in Leo.
#@nonl
#@-node:ekr.20100112051224.6234:Move current line
#@+node:ekr.20100112051224.6235:Move buffer up/down
Vi maps keys to scroll the text up/down one line and by half the
number of visible lines.  Leo does not support this.

#@-node:ekr.20100112051224.6235:Move buffer up/down
#@+node:ekr.20100112051224.6236:Word-related commands
Vi supports two types of words in its commands: Words that consist
of only a subset of the character set and words that considers all
characters except the space and tab characters as part of a word.

Leo's always considers a word to consist of a subset of characters
although some word related commands include different characters
than others.
#@nonl
#@-node:ekr.20100112051224.6236:Word-related commands
#@+node:ekr.20100112051224.6237:Forward and backward by sentences
Leo's sentence related functions do not stop at empty lines nor do
they skip over periods within words nor do they stop at sentences
ending in non-periods nor do they stop at the end or beginning of
the buffer. Note: see forwardSentenceHelper and backSentenceHelper
functions.
#@nonl
#@-node:ekr.20100112051224.6237:Forward and backward by sentences
#@+node:ekr.20100112051224.6238:Focus to body pane
Leo functions exist which unconditionally set focus to the body pane
regardless of the active pane.

For example, bracket matching commands ("%" key) do not work within
a node's headline text.  Instead, the command is performed on the
node's body text.
#@nonl
#@-node:ekr.20100112051224.6238:Focus to body pane
#@+node:ekr.20100112051224.6239:Displaying mode help
The "--> mode-help" command has the following issues related to the
display of the "Help" tab:

1. Key label always capitalized.

Vim commands are mapped to both lower-case and upper-case keys but always appear
mapped to upper-case keys within the "Help" tab.

2. Layout of tab's contents.

To improve readability and better support narrow tab cards, display the mode's
label without the "enter-" and "-mode" text and place the key label before the
mode label.

For example, the following entries would change from::
    enter-vi-delete-line-mode d
    enter-vi-delete-to-begin-of-word-mode b
to::
    d : vi-delete-line
    b : vi-delete-to-begin-of-word
#@nonl
#@-node:ekr.20100112051224.6239:Displaying mode help
#@+node:ekr.20090629183608.8446:Notes about commands
Yank vs. Yank:
Vi's "yank" commands copy the selected text TO the clipboard.
Leo's "yank" commands insert text FROM the clipboard.

copy-text in modes:
Leo's copy-text command does not work within a mode.  As a result,
all "copy to clipboard" capability is being implemented using the
kill-<object> command followed by Leo's "yank" command to put the
text back.

paste-text in modes:
The paste-text command does not work within an @mode node.  Leo's
"yank" command is used instead.

delete-node does not copy node to clipboard:
A copy-node command is issued to copy the node to the clipboard
followed by the delete-node command.
#@-node:ekr.20090629183608.8446:Notes about commands
#@-node:ekr.20100112051224.6246:Missing commands
#@-node:ekr.20080603052650.466:Fix vim problems
#@+node:ekr.20090811141250.5955:Other features
#@+node:ekr.20090724081340.5987:Improve recursive import script and @auto
@nocolor-node

Instead of adding an @ignore directive, it might be better
to change @auto to @@auto.

Should @auto be more lenient with C files?

Improve the recursive import script.
    - Minimize the path names
    - Option to include/exclude the @auto itself

#@-node:ekr.20090724081340.5987:Improve recursive import script and @auto
#@+node:ekr.20090714085914.5991:Add drag and drop to qt gui
#@-node:ekr.20090714085914.5991:Add drag and drop to qt gui
#@+node:ekr.20090804105939.5993:Possibly redo how plugins are loaded
#@-node:ekr.20090804105939.5993:Possibly redo how plugins are loaded
#@+node:ekr.20090526102407.10033:Can Leo delete empty resurrected nodes?
This probably should wait until the one-node world works.
#@nonl
#@-node:ekr.20090526102407.10033:Can Leo delete empty resurrected nodes?
#@+node:ekr.20090801103907.6018:Add entries to global dicts for more languages
http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780

Especially languages in leo/modes.
#@nonl
#@+node:ekr.20090816125009.5993:@url http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780
#@-node:ekr.20090816125009.5993:@url http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780
#@+node:ekr.20090814190307.5983:print all modes/*.py files
import glob

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')

aList = glob.glob(theDir)

for z in aList:
    print g.os_path_basename(z)

@
Exist:

    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
"w"     : "cweb",
"xml"   : "xml",
"xsl"   : "xslt",

Add first:


ada95.py
antlr.py
apacheconf.py
apdl.py
applescript.py
asp.py
aspect_j.py
assembly_macro32.py
assembly_mcs51.py
assembly_parrot.py
assembly_r2000.py
assembly_x86.py
awk.py
b.py
batch.py
bbj.py
bcel.py
bibtex.py
c.py
chill.py
cobol.py
coldfusion.py
cplusplus.py
csharp.py
css.py
cvs_commit.py
d.py
doxygen.py
dsssl.py
eiffel.py
embperl.py
erlang.py
factor.py
forth.py
fortran.py
fortran90.py
foxpro.py
freemarker.py
gettext.py
groovy.py
haskell.py
hex.py
html.py
i4gl.py
icon.py
idl.py
inform.py
ini.py
inno_setup.py
interlis.py
io.py
java.py
javascript.py
jcl.py
jhtml.py
jmk.py
jsp.py
latex.py
lilypond.py
lisp.py
lotos.py
lua.py
mail.py
makefile.py
maple.py
matlab.py
ml.py
modula3.py
moin.py
mqsc.py
netrexx.py
nqc.py
nsis2.py
objective_c.py
objectrexx.py
occam.py
omnimark.py
pascal.py
patch.py
perl.py
php.py
phpsection.py
pike.py
pl1.py
plain.py
plsql.py
pop11.py
postscript.py
povray.py
powerdynamo.py
progress.py
prolog.py
props.py
psp.py
ptl.py
pvwave.py
pyrex.py
python.py
r.py
rebol.py
redcode.py
relax_ng_compact.py
rest.py
rhtml.py
rib.py
rpmspec.py
rtf.py
ruby.py
rview.py
sas.py
scheme.py
sdl_pr.py
sgml.py
shell.py
shellscript.py
shtml.py
smalltalk.py
smi_mib.py
splus.py
sqr.py
squidconf.py
ssharp.py
svn_commit.py
swig.py
tcl.py
tex.py
texinfo.py
text.py
tpl.py
tsql.py
uscript.py
vbscript.py
velocity.py
verilog.py
vhdl.py
xml.py
xsl.py
zpt.py
__init__.py
#@-node:ekr.20090814190307.5983:print all modes/*.py files
#@+node:ekr.20031218072017.368:<< define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lua"           : "--",  # ddm 13/02/06
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--', # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    "rst"           : "rst",
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
#@-node:ekr.20031218072017.368:<< define global data structures >> (leoApp.py)
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    # New in Leo 4.4.7: honor @path directives.
    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>
    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Remember that we have read this file.
        # Fixes bug 488894: unsettling dialog when saving Leo file
        # after creating and populating an @auto node
        p.v.at_read = True # Create the attribute

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20070713075352:scanUnknownFileType (default scanner) & helper
def scanUnknownFileType (self,s,p,ext,atAuto=False):

    c = self.c
    changed = c.isChanged()
    body = g.choose(atAuto,'','@ignore\n')
    if ext in ('.html','.htm'):   body += '@language html\n'
    elif ext in ('.txt','.text'): body += '@nocolor\n'
    else:
        language = self.languageForExtension(ext)
        if language: body += '@language %s\n' % language

    self.setBodyString(p,body + self.rootLine + self.escapeFalseSectionReferences(s))
    if atAuto:
        for p in p.self_and_subtree():
            p.clearDirty()
        if not changed:
            c.setChanged(False)

    g.app.unitTestDict = {'result':True}
#@+node:ekr.20080811174246.1:languageForExtension
def languageForExtension (self,ext):

    '''Return the language corresponding to the extensiion ext.'''

    unknown = 'unknown_language'

    if ext.startswith('.'): ext = ext[1:]

    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None,'none','None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None,'none','None'):
            language = unknown
    else:
        language = unknown

    # g.trace(ext,repr(language))

    # Return the language even if there is no colorizer mode for it.
    return language
#@-node:ekr.20080811174246.1:languageForExtension
#@-node:ekr.20070713075352:scanUnknownFileType (default scanner) & helper
#@-node:ekr.20090801103907.6018:Add entries to global dicts for more languages
#@+node:ekr.20090730134219.6010:Help Tismer with XP install of psyco
@nocolor-node

I use Visual Studio 2008, the same that is used for Python 2.5/2.6.

A few days ago, I submitted a patch that allows you to use Mingw32 as a
compiler, too. If you use it, then you need to produce libpython26.a.

For doing this, there is a tool pexport.exe which can do that. I found a website
with those hints, but lost that, again :-) pexport is not included with mingw32.
#@nonl
#@+node:ekr.20090730165955.6014:Notes
http://www.emmestech.com/software/pexports-0.43/download_pexports.html
#@nonl
#@-node:ekr.20090730165955.6014:Notes
#@-node:ekr.20090730134219.6010:Help Tismer with XP install of psyco
#@-node:ekr.20090811141250.5955:Other features
#@+node:ekr.20080730212711.7:Improve config & plugins
@nocolor-node

- Don't repeat "can not load <plugin>" messages.

- Unify print-plugins and print-plugins-info commands, and make them more informative.

- Fix the plugin mess.

    - Create a way to unload a plugin.  This should be relatively easy.
#@+node:ekr.20090402072059.11:What should be done about @enabled-plugins nodes?
# It's very confusing.
#@nonl
#@-node:ekr.20090402072059.11:What should be done about @enabled-plugins nodes?
#@+node:ekr.20080313032655.2:Once a plugin is enabled, it is always enabled
#@-node:ekr.20080313032655.2:Once a plugin is enabled, it is always enabled
#@+node:ekr.20080923200153.1:Support scan-directives hook again?
# This affects the add_directives plugin.
# Also, the color_markup plugin doesn't work with the threading colorizer.
#@nonl
#@-node:ekr.20080923200153.1:Support scan-directives hook again?
#@+node:ekr.20080604060150.1:Clean up plugins
Some scripting says the following are in .../plugins/ but not
leoPluginsRef.leo:

dyna_menu.py
dynacommon.py
exampleTemacsExtension.py
gtkDialogs.py
gtkGui.py
initinclass.py
leoOPML.py
leo_interface.py
leo_pdf.py
mod_leo2ascd.py
override_commands.py
rst.py
rst2.py
temacs.py
threading_colorizer.py
threading_colorizer.py
usetemacs.py
zenity_file_dialogs.py
#@-node:ekr.20080604060150.1:Clean up plugins
#@+node:ekr.20080421140032.1:Fix multiple controllers problem in all plugins
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/663e1f9d8e2d1c24

@color
#@nonl
#@-node:ekr.20080421140032.1:Fix multiple controllers problem in all plugins
#@-node:ekr.20080730212711.7:Improve config & plugins
#@+node:ekr.20090714085914.5993:Most important features
#@+node:ekr.20071001052501:Versioning for nodes
@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
#@nonl
#@-node:ekr.20071001052501:Versioning for nodes
#@+node:ekr.20090601083544.6051:Add expand_noweb_references for rst3 plugin
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

> What would work for me is if named sections in a @rst subtree
> would work exactly as they work for other derived files: they
> get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references: default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
#@+node:ekr.20090601083544.6052:post
@nocolor-node

I want to write the documentation for the source program in a @rst3 subtree. In
this @rst3 subtree I want to refer to fragments of the program, like:

In the following code fragment::

  <<code fragment>>

Unfortunately, <<code fragment>> will not be expanded. Furthermore, in order to
get to this work, I should have <<code fragment>> under the @rst3 subtree as
well, but this is then also treated as @rst3 input (which in this case, is not
what I want).
#@nonl
#@-node:ekr.20090601083544.6052:post
#@+node:ekr.20090502071837.71:writeBody
def writeBody (self,p):

    # g.trace(p.h,p.b)

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
#@-node:ekr.20090502071837.71:writeBody
#@-node:ekr.20090601083544.6051:Add expand_noweb_references for rst3 plugin
#@+node:ekr.20080918164844.12:Improve headline navigation
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/bce1065d9a332fcd

Now that the leo is more "modeless" (I'm speaking of switching between
outline navigation and body editing modes), which btw is a clear improvement
to how leo used to behave, here are some things that still feel a bit
un-intuitive:

- ctrl+H (edit-headline) "locks" the user into the mode way too much.

   * The headline editing mode should be cancelled when the user does:
      - cursor up/down
      - ESC

   * Even better alternative: I find myself constantly thinking that "ok,
now I need to edit a headline (typically not the current headline), so now
I'll press ctrl+H". I think perhaps pressing up/down should cancel the
current headline editing, and select the next/previous headline for editing.
That is, I wouldn't need to navigate to the headline I want to edit before I
start editing it.

  - cut-node (ctrl+shift+x) selects the wrong node after the cut. The
intuitive assumption is that cut will select the node that "took the place
of the
    current node", instead of starting to travel upwards the set of nodes.

   * Typical use case is the way you usually start deleting a set of items.
You move to the first item and start cutting repeatedly. This wont work with
the current behaviour. 
#@nonl
#@-node:ekr.20080918164844.12:Improve headline navigation
#@-node:ekr.20090714085914.5993:Most important features
#@+node:ekr.20091005145253.6058:Optional...
#@+node:ekr.20090131200406.15:Optional file features
#@+node:ekr.20090622020908.6058:Add lite sentinels
http://groups.google.com/group/leo-editor/browse_thread/thread/c4f2cf250600e4a9
#@nonl
#@-node:ekr.20090622020908.6058:Add lite sentinels
#@+node:ekr.20080311135649.2:Allow different .leo formats
@nocolor

On Tue, Mar 11, 2008 at 7:03 AM, Kent Tenney <kten...@gmail.com> wrote:

> On 3/11/08, derwisch <johannes.hues...@med.uni-heidelberg.de> wrote:

> >  On 11 Mrz., 08:03, "Ville M. Vainio" <vivai...@gmail.com> wrote:
> >  > It could also be argued that

> >  > - Referring to previous cloned vnodes explicitly in XML does not
> >  > necessarily obscure DAG - it follows the "do not repeat yourself"
> rule
> >  > - It will speed up reading
> >  > - Wouldn't it be better for preserving the integrity of the XML file?

> > I would lean towards this line of argumentation. A couple of days I
> >  had my Leo extension destroy the Leo ODM file (which was still valid
> >  according to Leo, but unreadable wrt the extension and broken uAs). I
> >  resorted to editing the Leo file with Emacs, and was quite surprised
> >  to see that the headStrings were attributes of vnodes.

> I'll chime in with my pet peeve re: .leo file structure::

> I think that putting the headstrings on vnodes and body strings on tnodes
> obscures the informational content of the .leo file, and makes the .leo
> file
> format less attractive as a generalized solution to the problem of how to
> manage head/body pairs which live in a hierarchal structure.

> Thanks,
> Kent

> >  I think that
> >  editing the file might have been a bit easier if there had been no
> >  such redundancy. But this is more a feeling rather than a qualified
> >  opinion.

Thanks for all these comments.  I'll respond to them all here.

Clearly, we should be using a standard xml parser to read .leo files.

My present thoughts:

- I personally like human-readable headlines in <v> elements.

- I am open to putting headlines in <t> elements, as an indication that
tnodes do indeed contain headlines and body text.

- I am willing to consider only writing shared subtrees once.

Oh! (An Aha)  All these are preferences.  We can allow any combination of
these provided that headlines appear somewhere.

So that's clean.  This will happen in Leo 4.5. 
#@nonl
#@-node:ekr.20080311135649.2:Allow different .leo formats
#@+node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    g.doHook("new",old_c=self,c=c,new_c=c)
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c,forceLog=True) # Force a new signon message.
    c.redraw()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:c.new
#@+node:ekr.20031218072017.2821:c.open & helper
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>
    table = [("All files","*"),("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            ok, frame = g.openWithFileName(fileName,c)
            if ok:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if ok and closeFlag:
                g.app.destroyWindow(c.frame)
        else:
            ok = c.createNodeFromExternalFile(fileName)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@+node:ekr.20090212054250.9:c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    f = None
    try:
        f = open(fn)
        s = f.read()
        f.close()
    except IOError:
        g.es('can not open %s' % fn)
        return

    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
#@nonl
#@-node:ekr.20090212054250.9:c.createNodeFromExternalFile
#@-node:ekr.20031218072017.2821:c.open & helper
#@+node:ekr.20031218072017.2823:openWith and helpers
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.p
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=500)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    # if node is part of @<file> tree, get ext from file name
    for p2 in p.self_and_parents():
        if p2.isAnyAtFileNode():
            fn = p2.h.split(None,1)[1]
            ext = g.os_path_splitext(fn)[1]
            g.trace(ext)
            break

if not ext:
    theDict = c.scanAllDirectives()
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # g.trace(language,ext)

if not ext:
    ext = ".txt"

if ext[0] != ".":
    ext = "."+ext

# g.trace("ext",ext)
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.b
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening:",g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec(arg+path,{},{})
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        os.spawnl(os.P_NOWAIT,arg,filename,path)
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        os.spawnv(os.P_NOWAIT,arg[0],vtuple)
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        use_shell = True
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
            use_shell = False
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            try:
                subprocess.Popen(vtuple, shell=use_shell)
            except OSError:
                g.es_print("vtuple",repr(vtuple))
                g.es_exception()
        else:
            g.trace('Can not import subprocess.  Skipping: "%s"' % command)
    elif callable(openType):
        # Invoke openWith like this:
        # c.openWith(data=[f,None,None])
        # f will be called with one arg, the filename
        openType(shortPath)

    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing:",command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    c = self
    theFile = None # pylint complains if this is inited to ''.
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  ",g.shortFileName(path),color="red")
        else:
            g.es("creating:  ",g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.b
        theDict = c.scanAllDirectives(p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v == p2.v:
        # g.pr("removing previous entry in g.app.openWithFiles for",p.h)
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    name = "%s_LeoTemp_%s%s" % (
        g.sanitize_filename(p.headString()),
        str(id(p.v)),ext)

    name = g.toUnicode(name,g.app.tkEncoding)

    td = g.os_path_finalize(tempfile.gettempdir())

    path = g.os_path_join(td,name)

    return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and helpers
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; p = c.currentPosition()
    w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    # Done in fileCommands.save.
    # c.redraw_after_icons_changed()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        g.trace(fileName)
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
            # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)

    # Done in fileCommands.saveAs.
    # c.redraw_after_icons_changed()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
        g.chdir(fileName)

    # Does not change icons status.
    # c.redraw_after_icons_changed()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20071003104917:Make http://edreamleo.org/namespaces/leo-python-editor/1.1 Leo's official namespace
xmlns:leo="http://edreamleo.org/namespaces/leo-python-editor/1.1"
#@nonl
#@-node:ekr.20071003104917:Make http://edreamleo.org/namespaces/leo-python-editor/1.1 Leo's official namespace
#@+node:ekr.20090218115025.3:Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
#@nonl
#@-node:ekr.20090218115025.3:Why are attributes pickled by default?
#@+node:ekr.20080626081829.2:Allow headline comments for @nosent files
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/eb718b4c6d478ac0

I'm just getting started learning how to use Leo. Now, I'd like to use
it for some of my projects, but there's no chance that I can convert
everyone at work to using it, so putting sentinel-filled files in our
repository is out of the question. At the same time, my code looks
awfully bare without sentinels because the documentation ends up in
the section names, not the comments!

So, I was wondering if there's a convenient way to pull the section
names into a comment at the start of each section?

===============

Interesting question.  Am I correct in assuming you are using @nosent trees
to generate your files?  If so, it would be easy to add support for the
following options:

@bool write_section_comments_in_at_nosent_trees
@bool write_node_name_comments_in_at_nosent_trees

The first would write a sentinel consisting of only the section name;
the second would write a sentinel consisting only of the node's headline
(for nodes whose headline is not a section name).

These seem like they would be useful additions.  One can even imagine
corresponding Leo directives so that the comments could be turned on or off
within an @nosent tree.

What do you think?

=====================

> Interesting question.  Am I correct in assuming you are using @nosent trees
> to generate your files?  If so, it would be easy to add support for the
> following options:

> @bool write_section_comments_in_at_nosent_trees
> @bool write_node_name_comments_in_at_nosent_trees

> The first would write a sentinel consisting of only the section name;
> the second would write a sentinel consisting only of the node's headline
> (for nodes whose headline is not a section name).

> These seem like they would be useful additions.  One can even imagine
> corresponding Leo directives so that the comments could be turned on or off
> within an @nosent tree.

That sounds like an excellent solution. Particularly the last bit --
if you could turn section-comments on and off as required, it would
become very convenient to use Leo to produce source that is intended
to also be read by non Leo users. 
#@nonl
#@-node:ekr.20080626081829.2:Allow headline comments for @nosent files
#@-node:ekr.20090131200406.15:Optional file features
#@+node:ekr.20090210093316.1:Optional features
#@+node:ekr.20080922115725.1:Minor @shadow stuff
#@+node:ekr.20081004102201.2:Create a log file for @shadow?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/5e7bd3af2d1fbf51

How about a shadow.log file which Leo told what it thought of the relationship
between the node, file and shadow? It might provide useful clues.
#@-node:ekr.20081004102201.2:Create a log file for @shadow?
#@+node:ekr.20081001062423.1:Can @shadow mark externally changed nodes?
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/c46eabe8a9fe6e8

@color
#@nonl
#@+node:ekr.20080708094444.38:x.propagate_changed_lines (the main loop)
def propagate_changed_lines(self,new_public_lines,old_private_lines,marker,p=None):

    '''Propagate changes from 'new_public_lines' to 'old_private_lines.

    We compare the old and new public lines, create diffs and
    propagate the diffs to the new private lines, copying sentinels as well.

    We have two invariants:
    1. We *never* delete any sentinels.
       New at 2010/01/07: Replacements preserve sentinel locations.
    2. Insertions that happen at the boundary between nodes will be put at
       the end of a node.  However, insertions must always be done within sentinels.
    '''

    trace = False and not g.unitTesting
    verbose = True
    x = self ; 
    # mapping tells which line of old_private_lines each line of old_public_lines comes from.
    old_public_lines, mapping = self.strip_sentinels_with_map(old_private_lines,marker)

    << init vars >>
    << define print_tags >>

    delim1,delim2 = marker.getDelims()
    sm = difflib.SequenceMatcher(None,old_public_lines,new_public_lines)
    prev_old_j = 0 ; prev_new_j = 0

    for tag,old_i,old_j,new_i,new_j in sm.get_opcodes():

        << About this loop >>

        # Verify that SequenceMatcher never leaves gaps.
        if old_i != prev_old_j: # assert old_i == prev_old_j
            x.error('can not happen: gap in old:',old_i,prev_old_j)
        if new_i != prev_new_j: # assert new_i == prev_new_j
            x.error('can not happen: gap in new:',new_i,prev_new_j)

        << Handle the opcode >>

        # Remember the ends of the previous tag ranges.
        prev_old_j = old_j
        prev_new_j = new_j

    # Copy all unwritten sentinels.
    self.copy_sentinels(
        old_private_lines_rdr,
        new_private_lines_wtr,
        marker,
        limit = old_private_lines_rdr.size())

    # Get the result.
    result = new_private_lines_wtr.getlines()
    if 1:
        << do final correctness check>>
    return result
#@+node:ekr.20080708094444.40:<< init vars >>
new_private_lines_wtr = self.sourcewriter(self)
# collects the contents of the new file.

new_public_lines_rdr = self.sourcereader(self,new_public_lines)
    # Contains the changed source code.

old_public_lines_rdr = self.sourcereader(self,old_public_lines)
    # this is compared to new_public_lines_rdr to find out the changes.

old_private_lines_rdr = self.sourcereader(self,old_private_lines) # lines_with_sentinels)
    # This is the file which is currently produced by Leo, with sentinels.

# Check that all ranges returned by get_opcodes() are contiguous
old_old_j, old_i2_modified_lines = -1,-1

tag = old_i = old_j = new_i = new_j = None
#@nonl
#@-node:ekr.20080708094444.40:<< init vars >>
#@+node:ekr.20080708094444.39:<< define print_tags >>
def print_tags(tag, old_i, old_j, new_i, new_j, message):

    sep1 = '=' * 10 ; sep2 = '-' * 20

    g.pr('\n',sep1,message,sep1,p and p.h)

    g.pr('\n%s: old[%s:%s] new[%s:%s]' % (tag,old_i,old_j,new_i,new_j))

    g.pr('\n',sep2)

    table = (
        (old_private_lines_rdr,'old private lines'),
        (old_public_lines_rdr,'old public lines'),
        (new_public_lines_rdr,'new public lines'),
        (new_private_lines_wtr,'new private lines'),
    )

    for f,tag in table:
        f.dump(tag)
        g.pr(sep2)


#@-node:ekr.20080708094444.39:<< define print_tags >>
#@+node:ekr.20080708192807.2:<< about this loop >>
@

This loop writes all output lines using a single writer: new_private_lines_wtr.

The output lines come from two, and *only* two readers:

1. old_private_lines_rdr delivers the complete original sources. All
   sentinels and unchanged regular lines come from this reader.

2. new_public_lines_rdr delivers the new, changed sources. All inserted or
   replacement text comes from this reader.

Each time through the loop, the following are true:

- old_i is the index into old_public_lines of the start of the present SequenceMatcher opcode.

- mapping[old_i] is the index into old_private_lines of the start of the same opcode.

At the start of the loop, the call to copy_sentinels effectively skips (deletes)
all previously unwritten non-sentinel lines in old_private_lines_rdr whose index
is less than mapping[old_i].

As a result, the opcode handlers do not need to delete elements from the
old_private_lines_rdr explicitly. This explains why opcode handlers for the
'insert' and 'delete' opcodes are identical.
#@-node:ekr.20080708192807.2:<< about this loop >>
#@+node:ekr.20080708192807.5:<< Handle the opcode >>
# Do not copy sentinels if a) we are inserting and b) limit is at the end of the old_private_lines.
# In this special case, we must do the insert before the sentinels.
limit=mapping[old_i]

if trace: g.trace('tag',tag,'old_i',old_i,'limit',limit)

if tag == 'equal':
    # Copy sentinels up to the limit = mapping[old_i]
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)

    # Copy all lines (including sentinels) from the old private file to the new private file.
    start = old_private_lines_rdr.index() # Only used for tag.
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        line = old_private_lines_rdr.get()
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (
            tag,start,mapping[old_j-1]))

    # Ignore all new lines up to new_j: the same lines (with sentinels) have just been written.
    new_public_lines_rdr.sync(new_j)

elif tag == 'insert':
    if limit < old_private_lines_rdr.size():
        self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Copy lines from new_public_lines_rdr up to new_j.
    start = new_public_lines_rdr.index() # Only used for tag.
    while new_public_lines_rdr.index() < new_j:
        line = new_public_lines_rdr.get()
        if marker.isSentinel(line):
            new_private_lines_wtr.put(
                '%s@verbatim%s\n' % (delim1,delim2),
                tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag == 'replace':
    # 2010/01/07: This case is new: it was the same as the 'insert' case.
    start = old_private_lines_rdr.index() # Only used for tag.
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        old_line = old_private_lines_rdr.get()
        if marker.isSentinel(old_line):
            # Important: this should work for @verbatim sentinels
            # because the next line will also be replaced.
            new_private_lines_wtr.put(old_line,tag='%s %s:%s' % (
                'replace: copy sentinel',start,new_j))
        else:
            new_line = new_public_lines_rdr.get()
            new_private_lines_wtr.put(new_line,tag='%s %s:%s' % (
                'replace: new line',start,new_j))

elif tag=='delete':
    # Copy sentinels up to the limit = mapping[old_i]
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)
    # Leave new_public_lines_rdr unchanged.

else: g.trace('can not happen: unknown difflib.SequenceMather tag: %s' % repr(tag))

if trace and verbose:
    print_tags(tag, old_i, old_j, new_i, new_j, "After tag")
#@-node:ekr.20080708192807.5:<< Handle the opcode >>
#@+node:ekr.20080708094444.45:<< do final correctness check >>
t_sourcelines, t_sentinel_lines = self.separate_sentinels(
    new_private_lines_wtr.lines, marker)

self.check_the_final_output(
    new_private_lines   = result,
    new_public_lines    = new_public_lines,
    sentinel_lines      = t_sentinel_lines,
    marker              = marker)
#@-node:ekr.20080708094444.45:<< do final correctness check >>
#@-node:ekr.20080708094444.38:x.propagate_changed_lines (the main loop)
#@-node:ekr.20081001062423.1:Can @shadow mark externally changed nodes?
#@+node:ekr.20090402072059.13:Create a general mechanism for aux (shadow, _db) files
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/4ec30df3f1db8db3

On Sat, Mar 28, 2009 at 3:24 AM, VR <viktor.ransmayr@gmail.com> wrote:


    When I tried to de-install Leo-4.6b1 I succeeded, but the program
    reported that 5 directories
    were not removed.

    Three of the directories where

    1) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\config
    2) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\doc
    3) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\plugins

    [containing]


    a) .leoSettings.leo_db
    b) .leoDocs.leo_db
    c) .leo_shadow
    d) .leoPluginsRef.leo_db


Thanks for this report. I think it is important, and needs a good solution.

I dislike all these files being sprayed around the file system. I'd like to see
these files placed somewhere the ~/.leo directory. Is there a reason why this
would be a bad idea?

Similarly, we might also prefer to have shadow files place in, say,
~/.leo/shadow_files.

In both cases, I think we want to create files that indicate their location.
Either that, or mirror their location in (subdirectories) ~/.leo. In other
words, this is a general problem, and it would be good to have a robust, general
solution.
#@nonl
#@-node:ekr.20090402072059.13:Create a general mechanism for aux (shadow, _db) files
#@-node:ekr.20080922115725.1:Minor @shadow stuff
#@+node:ekr.20090601083544.6067:Make all commands available to all commanders
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/a83082cec5ad3df8

QQQ (Ville)
So to create command you would do

import leoPlugins

def mycmd(c,p, event):
  print c,p

leoPlugins.expose_command('my-command', mycmd)
leoPlugins.expose_button('press-this',mycmd)

[EKR: I would rather use g.app.exposeCommand, g.app.exposeButton].

These would be available on *all* new commanders, and the current
commander as well (for easy testing). Plugins would not have to
contain more code than what is presented above.

The idea is to have a global command dict, [EKR: g.app.commandsDict]
and global button dict.
There is one after-create-frame handler that introduces all the
entries in this dict to the commander command dict.
QQQ

============


QQQ
g.app.global_commands_dict, which gets copied to c on commander
creation. it's rev 1889, you'll note that it's a simple
implementation. I didn't add g.button yet. An example:

@g.command('bookmark')
def bookmark(event):
    c = event.get('c')
    p = c.currentPosition()
    bookmarks.append(p.gnx)
    g.es('bookmarked') 
QQQ
#@nonl
#@-node:ekr.20090601083544.6067:Make all commands available to all commanders
#@+node:ekr.20070624135822:Templates for common code fragments
@
Use completion to show fragments.
Allow settings to create fragments:
    - @fragments
        - @fragment name
            body contains actual fragment.

@c

# Invent a way for simple keystrokes to insert fragments, such as:

Fragment 1:

c.beginUpdate()
try:
    pass
finally:
    endUpdate()

Fragment 2:

for p in c.all_positions():
    pass
#@-node:ekr.20070624135822:Templates for common code fragments
#@+node:ekr.20081119132758.2:Support @ifgui in settings trees
#@-node:ekr.20081119132758.2:Support @ifgui in settings trees
#@+node:ekr.20080803063553.4:Allow translation/abbreviation for any Leo directive, including headline directives
#@-node:ekr.20080803063553.4:Allow translation/abbreviation for any Leo directive, including headline directives
#@+node:ekr.20080826074455.1:Look into ttk for Python 2.6
@nocolor

I've just became aware of this project to upgrade TK's look and feel
in python (http://gpolo.ath.cx:81/projects/ttk_to_tkinter/). I presume
this can only have positive implications on leo (-:

Here's are some screen shots of the newly themed widgets: (http://
code.google.com/p/python-ttk/wiki/Screenshots)

@color
#@nonl
#@-node:ekr.20080826074455.1:Look into ttk for Python 2.6
#@+node:ekr.20080919085541.3:Use sqlite data base as an alternative representation for .leo files
http://groups.google.com/group/leo-editor/browse_thread/thread/dff0c165e2211691
#@nonl
#@-node:ekr.20080919085541.3:Use sqlite data base as an alternative representation for .leo files
#@+node:ekr.20080727122007.1:Allow user to set background colors of nodes
What uA should be used to specify node colors?

if the foreground / background color API uses uAs,
would/should the uAs use the reserved "leo_&lt;something&gt;" namespace?
#@-node:ekr.20080727122007.1:Allow user to set background colors of nodes
#@+node:ekr.20080813064908.8:Find a way to limit length of lines in indented nodes
#@-node:ekr.20080813064908.8:Find a way to limit length of lines in indented nodes
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
# Or give a better message.
#@nonl
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20080802070659.11:Make node attributes visible, and supported by Leo's core
#@-node:ekr.20080802070659.11:Make node attributes visible, and supported by Leo's core
#@+node:ekr.20080806054207.3:Auto scroll outline pane if headline would become invisible
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/76789df8aac08c70

When using leo as outliner, I often use only node headlines to write
down some data. If the headline string is too long, the cursor goes
beyond the visible area. When modifying a node headline, is it
possible to make leo to auto-scroll, so the cursor is always visible? 
#@-node:ekr.20080806054207.3:Auto scroll outline pane if headline would become invisible
#@+node:ekr.20070521105645:Improve api docs with epydoc?
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319363
By: ktenney

I think there is room for improvement in documenting Leo's
API, making it easier to write these kind of scripts.
I'm not sure of the best way to do that.

Epydoc seems to be the most active project in this realm.
http://epydoc.sourceforge.net/epydoc.html
#@-node:ekr.20070521105645:Improve api docs with epydoc?
#@+node:ekr.20061116054917.6:Remove blanks in calltips
#@-node:ekr.20061116054917.6:Remove blanks in calltips
#@+node:ekr.20080628095358.1:Make each Leo command a class
http://groups.google.com/group/leo-editor/browse_thread/thread/5688ed9aaa39be2e#

@nocolor

The main difficulty I see in the migration is creating the tables in the getPublicCommands methods in the various classes in leoEditCommands.py.  At present, these tables associate command names (strings) with corresponding methods.  The form of getPublicCommands is always:

def getPublicCommands (self):
  return {
    'command-name1': self.methodName1,
    'command-name2': self.methodName2,
    ...
  }

Thinking out loud, let's see whether the migration can be done easily.  We would change the entry:

    'command-name1': self.methodNameN,

to:

    'command-name1': self.classNameN(self),

That is, the table creates an instance of the class by calling the class's ctor, with self (the container object) as the ctor's only argument.  To make this work, all we need to do is give the class a __call__ method whose signature matches the signature of methodNameN, that is, the signature used to call methods previously.

Well, isn't this nice.  We can transition gradually, as needed.  No need *ever* to do a mass migration.  It should be easy to verify this scheme with one or two examples.  Please report your experiences if you decide to play around with this.

Edward

P.S.  I think it would be good style to append "Class" to the name of each command class. This makes it clear that self.myCommandClass(self) is a ctor.
#@-node:ekr.20080628095358.1:Make each Leo command a class
#@-node:ekr.20090210093316.1:Optional features
#@+node:ekr.20090714085914.5994:Optional new commands
#@+node:ekr.20071004120359.2:Do expand-region-abbrevs from
See: regionalExpandAbbrev.
#@nonl
#@-node:ekr.20071004120359.2:Do expand-region-abbrevs from
#@+node:ekr.20090402072059.2:clone-find-all-once
@

First do a normal clone-find-all for the word "clone". Then click the script
button and do it again. Notice that children of previously found nodes don't get
added again in the modified version.
#@nonl
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
        c.treeWantsFocus()
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060128075225:cloneFindAllCommand
def cloneFindAllCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@-node:ekr.20060128075225:cloneFindAllCommand
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v not in clones:
            # g.trace(self.p.v,self.p.h)
            if not clones:
                undoData = u.beforeInsertNode(c.p)
                << create the found node >>
            clones.append(self.p.v)
            << create a clone of p under the find node >>

    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")
#@+node:ekr.20051113110735:<< create the found node >>
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
#@-node:ekr.20051113110735:<< create the found node >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
q = self.p.clone()
q.moveToLastChildOf(found)
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20090402072059.4:@@@button my clone find all
import leo.core.leoFind as leoFind 

def new_find_all(self):
    << do some initial stuff >>


    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break

        if count % 10 == 0 and count > 0:
            g.es("still searching, matches found: ", count)

        << Skip node if it's a child of a previously found node >>

        count += 1

        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.h)
            if not clones:
                undoData = u.beforeInsertNode(c.p)
                << create the found node >>
            clones.append(self.p.v.t)
            positions.append(self.p)
            << create a clone of p under the find node >>

    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")


leoFind.leoFind.findAll = new_find_all

c.executeMinibufferCommand("clone-find-all") 
#@+node:ekr.20090402072059.5:<< do some initial stuff >>
g.es("findAll..., self: ", self)

c = self.c ; w = self.s_ctrl ; u = c.undoer
undoType = 'Clone Find All'
if not self.checkArgs():
    return
self.initInHeadline()
if self.clone_find_all:
    self.p = None # Restore will select the root position.
data = self.save()
self.initBatchCommands()
count = 0 ; clones = []; positions = []
#@nonl
#@-node:ekr.20090402072059.5:<< do some initial stuff >>
#@+node:ekr.20090402072059.6:<< create the found node >>
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
#@-node:ekr.20090402072059.6:<< create the found node >>
#@+node:ekr.20090402072059.7:<< create a clone of p under the find node >>
q = self.p.clone()
q.moveToLastChildOf(found)
#@-node:ekr.20090402072059.7:<< create a clone of p under the find node >>
#@+node:ekr.20090402072059.8:<< Skip node if it's a child of a previously found node >>
<< def: is a child of b >>

is_child_of_previous = False
for previously_found in positions:
    if is_a_child_of_b(self.p, previously_found):
        is_child_of_previous = True
        break

if is_child_of_previous:
    continue
#@nonl
#@+node:ekr.20090402072059.9:<< def: is a child of b >>

def is_a_child_of_b(a, b):
    for child in b.children_iter():
        if a.t == child.t:
            return True
        if is_a_child_of_b(a, child):
            return True
    return False
#@nonl
#@-node:ekr.20090402072059.9:<< def: is a child of b >>
#@-node:ekr.20090402072059.8:<< Skip node if it's a child of a previously found node >>
#@-node:ekr.20090402072059.4:@@@button my clone find all
#@-node:ekr.20090402072059.2:clone-find-all-once
#@+node:ekr.20090512080015.5801:import-files-recursively command?
How would the command specify settings?

A line added to test bzr push.
#@-node:ekr.20090512080015.5801:import-files-recursively command?
#@+node:ekr.20090201122309.5:Improve macro commands
@nocolor-node

- The recording logic now returns the entire event.
- The leoKeyEvent ctor now gets the stroke from self.actualEvent.
- Recording ends with ctrl-g: a small changed to k.masterKeyHandler.
- Playing back the macro just calls k.masterKeyHandler.
- Pickle the minimal representation of a key event, namely the stroke.

#@+node:ekr.20070228160107:class leoKeyEvent (leoGui)
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c,stroke=None):

        # g.trace('leoKeyEvent(leoGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.state  = hasattr(event,'state') and event.state or 0
        self.stroke = hasattr(event,'stroke') and event.stroke or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        if stroke and not self.stroke:
            self.stroke = self.actualEvent.stroke = stroke

        self.widget = self.w

    def __repr__ (self):

        if self.stroke:
            return 'leoGui.leoKeyEvent: stroke: %s' % (repr(self.stroke))
        else:
            return 'leoGui.leoKeyEvent: char: %s, keysym: %s' % (
                repr(self.char),repr(self.keysym))
#@nonl
#@-node:ekr.20070228160107:class leoKeyEvent (leoGui)
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace: g.trace('stroke:',repr(stroke),'keysym:',
        repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        done,b = k.doPlainKey(event,stroke,w)
        if b: k.masterCommand(event,b.func,b.stroke,b.commandName)
        if done: return 'break'

    b = k.getPaneBinding(stroke,w)
    if b:
        if traceGC: g.printNewObjects('masterKey 3')
        return k.masterCommand(event,b.func,b.stroke,b.commandName)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20091230094319.6244:doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return True,'break'
#@-node:ekr.20091230094319.6244:doMode
#@+node:ekr.20091230094319.6242:doPlainKey
def doPlainKey (self,event,stroke,w):

    '''Handle a plain key.  Return done,b.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # Important: only keys bound somewhere have a stroke.
    # All unbound plain keys will be handled by handleUnboundKeys.
    if k.unboundKeyAction in ('insert','overwrite'):
        for key in (k.unboundKeyAction,'body','log','text','all'):
            # Ignore bindings for all plain keys in insert/overwrite mode
            # *except* auto-complete.
            d = k.masterBindingsDict.get(key,{})
            if d:
                b = d.get(stroke)
                if b and b.commandName == 'auto-complete':
                    if trace: g.trace('%s: auto-complete key in %s mode' % (
                        stroke,k.unboundKeyAction))
                    return True,b

        if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
        return True,g.bunch(func=None,stroke=stroke,commandName=None)

    # Ignore all command-state keys if we are not in a text widget.
    elif k.unboundKeyAction == 'command':
        if g.app.gui.isTextWidget(w):
            return False,None
        else:
            c.onCanvasKey(event)
            return True,None
    else:
        return False,None
#@-node:ekr.20091230094319.6242:doPlainKey
#@+node:ekr.20091230094319.6240:getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    k = self ; w_name = k.c.widget_name(w)
    keyStatesTuple = ('command','insert','overwrite')

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace:
                g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                    return b
#@-node:ekr.20091230094319.6240:getPaneBinding
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20061031131434.105:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@nonl
#@+node:ekr.20061031131434.106:<< define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@nonl
#@-node:ekr.20061031131434.106:<< define specialKeysyms >>
#@+node:ekr.20061031131434.107:<< add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@-node:ekr.20061031131434.107:<< add character to history >>
#@+node:ekr.20061031131434.109:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
#@-node:ekr.20061031131434.109:callKeystrokeFunction (not used)
#@+node:ekr.20061031131434.110:k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if stroke and not (stroke.startswith('Alt+Ctrl') and not self.enable_alt_ctrl_bindings) and (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    elif name.startswith('log'):
        if g.app.gui.guiName() == 'tkinter':
            return None
        else:
            if trace: g.trace(w)
            i = w.logCtrl.getInsertPoint()
            if stroke.lower() == 'return': stroke = '\n'
            elif stroke.lower() == 'tab': stroke = '\t'
            elif stroke.lower() == 'backspace': stroke = '\b'
            w.logCtrl.insert(i,stroke)
            return None
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(stroke))
        return None
#@nonl
#@-node:ekr.20061031131434.110:k.handleDefaultChar
#@-node:ekr.20061031131434.105:masterCommand & helpers
#@+node:ekr.20050920084036.190:macroCommandsClass
class macroCommandsClass (baseEditCommandsClass):

    '''Define the following commands:

    call-kbd-macro
    call-last-kbd-macro
    load-kbd-macros
    name-last-kbd-macro
    print-macros
    save-kbd-macros
    start-kbd-macro
    '''

    @others
#@nonl
#@+node:ekr.20050920084036.191: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.lastMacro = None
    self.macros = []
    self.macro = []
    self.namedMacros = {}

    # Important: we must not interfere with k.state in startKbdMacro!
    self.recordingMacro = False
#@-node:ekr.20050920084036.191: ctor
#@+node:ekr.20050920084036.192: getPublicCommands
def getPublicCommands (self):

    return {
        'call-last-kbd-macro':  self.callLastKeyboardMacro,
        'call-kbd-macro':       self.callNamedMacro,
        'print-macros':         self.printMacros,
        'name-last-kbd-macro':  self.nameLastKbdMacro,
        'load-kbd-macros':      self.loadFile,
        'save-kbd-macros':      self.saveMacros,
        'start-kbd-macro':      self.startKbdMacro,
    }
#@-node:ekr.20050920084036.192: getPublicCommands
#@+node:ekr.20050920085536.15:addToDoAltX (common helper)
# Called from loadFile and nameLastKbdMacro.

def addToDoAltX (self,name,macro):

    '''Adds macro to Alt-X commands.'''

    k= self ; c = k.c

    g.trace(name,macro)

    if name in c.commandsDict:
        return False

    def func (event,macro=macro):
        return self.executeMacro(macro)

    c.commandsDict [name] = func
    self.namedMacros [name] = macro
    return True
#@-node:ekr.20050920085536.15:addToDoAltX (common helper)
#@+node:ekr.20050920084036.202:callLastKeyboardMacro
# Called from universal-command.

def callLastKeyboardMacro (self,event):

    '''Call the last recorded keyboard macro.'''

    if self.lastMacro:
        self.executeMacro(self.lastMacro)
#@nonl
#@-node:ekr.20050920084036.202:callLastKeyboardMacro
#@+node:ekr.20050920084036.194:callNamedMacro
def callNamedMacro (self,event):

    '''Prompts for a macro name to save, then executes it.'''

    k = self.k ; tag = 'macro-name'
    state = k.getState(tag)
    prompt = 'Call macro named: '

    if state == 0:
        k.setLabelBlue(prompt,protect=True)
        k.getArg(event,tag,1,self.callNamedMacro)
    else:
        macro = self.namedMacros.get(k.arg)
        # Must do this first!
        k.clearState()
        if macro:
            self.executeMacro(macro)
        else:
            g.es('no macro named %s' % k.arg)
        k.resetLabel()

#@-node:ekr.20050920084036.194:callNamedMacro
#@+node:ekr.20050920084036.206:endKbdMacro
def endKbdMacro (self,event=None):

    '''Stop recording a keyboard macro.'''

    k = self.k
    self.recordingMacro = False
        # Tell k.masterKeyHandler and masterCommandHandler we are done.

    if self.macro:
        # self.macro = self.macro [: -4]
        self.macros.insert(0,self.macro)
        self.lastMacro = self.macro[:]
        self.macro = []
        k.setLabelBlue('Keyboard macro defined, not named')
    else:
        k.setLabelBlue('Empty keyboard macro')
#@-node:ekr.20050920084036.206:endKbdMacro
#@+node:ekr.20050920084036.203:executeMacro
def executeMacro (self,macro):

    c = self.c ; k = self.k

    c.bodyWantsFocusNow()

    for event in macro:
        # New in Leo 4.6: macro entries are leoKeyEvents.
        g.trace(event.stroke)
        k.masterKeyHandler(event,stroke=event.stroke)
#@-node:ekr.20050920084036.203:executeMacro
#@+node:ekr.20050920084036.196:loadFile & helper
def loadFile (self,event):

    '''Asks for a macro file name to load.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Macro File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName)
        self.loadMacros(f)
    except IOError:
        g.es('can not open',fileName)
#@+node:ekr.20050920084036.197:loadMacros
def loadMacros (self,f):

    '''Loads a macro file into the macros dictionary.'''

    c = self.c ; w = c.frame.body.bodyCtrl
    try:
        d = pickle.load(f)
    except pickle.UnpicklingError:
        g.es('error unpickling %s' % f.name)
        return

    # g.trace(f.name,d)

    for name in d:
        aList = d.get(name)
        macro = []
        for stroke in aList:
            # Create a dummy event with just enough attribute
            # to keep k.masterKeyHandler happy
            actualEvent = g.Bunch(stroke=stroke,char=stroke,widget=w)
            event = g.app.gui.leoKeyEvent(actualEvent,c)
            macro.append(event)
        self.addToDoAltX(name,macro)
            # sets self.namedMacros[name]=macro


#@-node:ekr.20050920084036.197:loadMacros
#@-node:ekr.20050920084036.196:loadFile & helper
#@+node:ekr.20050920084036.198:nameLastKbdMacro
def nameLastKbdMacro (self,event):

    '''Prompt for the name to be given to the last recorded macro.'''

    k = self.k ; state = k.getState('name-macro')

    if state == 0:
        k.setLabelBlue('Name of macro: ',protect=True)
        k.getArg(event,'name-macro',1,self.nameLastKbdMacro)
    else:
        k.clearState()
        name = k.arg
        self.addToDoAltX(name,self.lastMacro)
        k.setLabelGrey('Macro defined: %s' % name)
#@-node:ekr.20050920084036.198:nameLastKbdMacro
#@+node:ekr.20090201152408.1:printMacros
def printMacros (self,event=None):

    names = [z for z in self.namedMacros]
    g.es(''.join(names),tabName='Macros')
#@-node:ekr.20090201152408.1:printMacros
#@+node:ekr.20050920084036.199:saveMacros & helpers
def saveMacros (self,event=None):

    '''Asks for a file name and saves it.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Save Macros',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName,'a+')
        f.seek(0)
        if f:
            self.saveMacrosHelper(f)
    except IOError:
        g.es('can not create',fileName)

#@+node:ekr.20050920084036.200:saveMacrosHelper
def saveMacrosHelper( self,f):

    '''Saves all named macros.'''

    # fname = f.name
    # try:
        # macros = pickle.load( f )
    # except Exception:
        # macros = {}
    # f.close()

    d = {}
    for name in self.namedMacros:
        macro = self.namedMacros.get(name)
        # Just save the essential part of the event.
        # It must be picklable.
        aList = [event.stroke for event in macro]
        g.trace(name,aList)
        d[name] = aList
        # f = open( fname, 'w' )
        pickle.dump(d, f )
        f.close()
#@-node:ekr.20050920084036.200:saveMacrosHelper
#@-node:ekr.20050920084036.199:saveMacros & helpers
#@+node:ekr.20050920084036.204:startKbdMacro
def startKbdMacro (self,event):

    '''Start recording a keyboard macro.'''

    k = self.k

    if not self.recordingMacro:
        self.recordingMacro = True
            # A flag for k.masterCommandHandler & k.masterKeyHandler.
        k.setLabelBlue('Recording macro. ctrl-g to end...',protect=True)
    else:
        g.trace(event)
        self.macro.append(event)
#@-node:ekr.20050920084036.204:startKbdMacro
#@-node:ekr.20050920084036.190:macroCommandsClass
#@-node:ekr.20090201122309.5:Improve macro commands
#@-node:ekr.20090714085914.5994:Optional new commands
#@-node:ekr.20091005145253.6058:Optional...
#@-node:ekr.20100109214940.6225:4.8 Autocompletion, vim
#@+node:ekr.20060306194040:Leo Video & slide show
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20091006063434.16252:A slide show for newbies
#@-node:ekr.20091006063434.16252:A slide show for newbies
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.

-------------------

https://sourceforge.net/forum/message.php?msg_id=4396251
By: ktenney

2 good screencasts on making screencasts;

http://murl.se/26296
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:Leo Video & slide show
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
