.. @+leo-ver=5-thin
.. @+node:ekr.20100119205347.6015: * @file ../doc/leoToDo.txt
.. @@language rest # override the default .txt coloring.

.. @+all
.. @+node:ekr.20110609102702.16471: ** To do: 4.10
Top 10:

* Fix all significant bugs.
    - Fix key bindings after redefining keys.
    - Fix serious clone bug
    - Eliminate (somehow!) spellpyx.txt from bzr repo
* Rendering to tex,pdf, etc.
* Use c.db for marks and expansion bits.
* Restart vim project
.. @+node:ekr.20120212095313.10377: *3* To do first
.. @+node:ekr.20120228111337.10054: *4* Fix failing clone unit test
.. @+node:ekr.20120203053243.10111: *4* Fix OpenWith menu
@nocolor-node

This affects bindings.
.. @+node:ekr.20120227073551.11666: *5* @test c.openTempFileInExternalEditor
arg = ''
arg0 = 'one'
fn = '<fn>'
filename = '' # g.os.path.basename(arg)
vtuple = [arg0,fn]

table = (
    #('os.system',       'os.system(%s)' % (arg+fn)),
    #('os.startfile',    'os.startfile(%s)' % (arg+fn)),
    #('exec',            'exec(%s)' % (arg+fn)),
    #('os.spawnl',       'os.spawnl(%s,%s,%s)' % (arg,filename,fn)),
    #('os.spawnv',       'os.spawnv(%s,%s)' % (arg0,vtuple)),
    ('subprocess.Popen', 'subprocess.Popen(%s %s)' % (arg0,fn)),
    ('huh?',             'bad command:'+'huh?'),
)

for openType,result in table:
    if openType in ('os.spawnv','subprocess.Popen'):
        arg2 = ['one']
    else:
        arg2 = None
    result2 = c.openTempFileInExternalEditor(arg2,fn,openType,testing=True)
    assert result==result2,'expected %s, got %s' % (
        result,result2)
.. @+node:ekr.20120205022040.17745: *5* @openwith docs (copy)
@language rest

@openwith nodes in @settings trees create menu items. The openWith
plugin must be active for these settings to have any effect.

The headline of an @openwith node has the form::

    @openwith name = shortcut
    
name is name of the menu item. shortcut specifies the shortcut used to invoke
the menu item. shortcut may be None.

The body text @openwith nodes should contain a single line contain a tuple of the form::

    command,arg,ext

For example::
    
    'subprocess.Popen',['pythonw','C:/Python24/Lib/idlelib/idle.pyw'],'.py'
    
When the user selects this menu item Leo executes command(arg+path) where path
is the full path to the temp file. The ext argument specifies the extension of
the temp file. Notes:

- command is a string.  Valid values are::
    
  'subprocess.Popen'
  'os.system'
  'os.startfile'
  'os.spawnl'
  'os.spawnv'
  'exec'
  
- arg is either a single string or a list of strings.

- ext is a string or None. If None, Leo computes a file extension base on what
  \@language directive is in effect.
  
- If the .leo file being loaded contains @openwith nodes, the File:Open With
menu contains only the items created by those nodes. Similarly, @openwith nodes
in myLeoSettings.leo override entries in leoSettings.leo.

- If no @openwith nodes are found anywhere the openWith plugin uses hard-coded
tables in the plugin itself.
.. @+node:ekr.20120227073551.10919: *5* Creating the open with table
.. @+node:ekr.20031218072017.2832: *6* c.openWithTempFilePath (may be over-ridden)
def openWithTempFilePath (self,p,ext):

    '''Return the path to the temp file corresponding to p and ext.

    This is overridden in mod_tempfname plugin
    '''

    fn = '%s_LeoTemp_%s%s' % (
        g.sanitize_filename(p.h),
        str(id(p.v)),ext)
    if g.isPython3: # 2010/02/07
        fn = g.toUnicode(fn)
    td = g.os_path_finalize(tempfile.gettempdir())
    path = g.os_path_join(td,fn)

    return path
.. @+node:ekr.20031218072017.2823: *6* c.openWith and helpers
def openWith(self,event=None,data=None):

    '''This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    '''
    
    trace = False and not g.unitTesting
    if trace: g.trace('data',data)

    c = self ; p = c.p
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook('openwith1',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            ext = c.getOpenWithExt(p,ext)
            fn = c.openWithHelper(p,ext)
            if fn:
                g.enableIdleTimeHook(idleTimeDelay=500)
                c.openTempFileInExternalEditor(arg,fn,openType)
        g.doHook('openwith2',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es('unexpected exception in c.openWith')
        g.es_exception()

    return # (for Tk) 'break'
.. @+node:ekr.20031218072017.2824: *7* c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    if trace: g.trace(ext)
    
    c = self
    
    if ext:
        for ch in ("'",'"'):
            if ext.startswith(ch): ext = ext.strip(ch)

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext
        
    if trace: g.trace(ext)

    return ext
.. @+node:ekr.20031218072017.2829: *7* c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,arg,fn,openType,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False # and not g.unitTesting
    verbose = False
    testing = testing or g.unitTesting
    if arg is None: arg = ''
    
    def quote(s):
        return '"%s"' % s if s else ''
    def join(s1,s2):
        return '%s %s' % (s1,s2)
    
    # 2012/02/27: Carefully enclose arg and fn in double quotes.
    # This is tricky because these values come from the user.
    for ch in ("'",'"'):
        if openType.startswith(ch):
            openType = openType.strip(ch)
        if fn.startswith(ch):
            fn = fn.strip(ch)
        if type(arg) in (type((),),type([])):
            arg = [z.strip(ch) if z.startswith(ch) else z for z in arg]
        else:
            arg = arg.strip(ch) if arg.startswith(ch) else arg

    # Must be done *after* the loop.
    if type(arg) in (type((),),type([])):
        arg_tuple = arg
        arg = ' '.join(arg) # Do *not* quote the args.
    else:
        arg_tupe = []
        arg = quote(arg) # *Do* quote the arg.
    
    if trace:
        print()
        g.trace()
        print('%s(' % openType)
        print('  %s' % arg)
        print(')')
        
    # Do not quote the temp file name.

    try:
        command = '<no command>'
        # if openType == 'os.system':
            # command = '%s %s' % (arg,fn)
            # if trace:
                # g.trace()
                # print('  %s' % (arg))
                # print('  %s' % (fn))
            # if not testing:
                # os.system(command)
        # el
        if openType == 'os.startfile':
            command = 'os.startfile(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: os.startfile(join(arg,fn))
        elif openType == 'exec':
            command = 'exec(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: exec(join(arg,fn),{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg_tuple[0]) 
            vtuple = arg_tuple[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s,%s)' % (arg[0],repr(vtuple))
            if trace: g.trace(command)
            if not testing: os.spawnv(os.P_NOWAIT,arg[0],vtuple)
        elif openType == 'subprocess.Popen':
            use_shell = True
            c_arg = join(arg,fn)
            command = 'subprocess.Popen(%s)' % c_arg
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(c_arg,shell=use_shell)
                except OSError:
                    g.es_print('c_arg',repr(c_arg))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
.. @+node:ekr.20100203050306.5797: *7* c.openWithHelper
def openWithHelper (self,p,ext):

    '''create or reopen a temp file for p,
    testing for conflicting changes.
    '''

    c = self

    # May be over-ridden by mod_tempfname plugin.
    searchPath = c.openWithTempFilePath(p,ext)
    if not searchPath:
        # Check the mod_tempfname plugin.
        return g.trace('c.openWithTempFilePath failed',color='red')

    # Set d and path if a temp file already refers to p.v
    path = None
    if g.os_path_exists(searchPath):
        for d in g.app.openWithFiles:
            if p.v == d.get('v') and searchPath == d.get('path'):
                path = searchPath ; break

    if path:
        assert d.get('path') == searchPath
        fn = c.createOrRecreateTempFileAsNeeded(p,d,ext)
    else:
        fn = c.createOpenWithTempFile(p,ext)

    return fn # fn may be None.
.. @+node:ekr.20031218072017.2827: *8* c.createOrRecreateTempFileAsNeeded
conflict_message = '''
Conflicting changes in outline and temp file.
Do you want to use the data in the outline?
Yes: use the data in the outline.
No: use the data in the temp file.
Cancel or Escape or Return: do nothing.
'''

def createOrRecreateTempFileAsNeeded (self,p,d,ext):

    '''test for changes in both p and the temp file:

    - If only p's body text has changed, we recreate the temp file.
    - If only the temp file has changed, do nothing here.
    - If both have changed we must prompt the user to see which code to use.

    Return the file name.
    '''
    c = self

    fn = d.get('path')
    # Get the old & new body text and modification times.
    encoding = d.get('encoding')
    old_body = d.get('body')
    new_body = g.toEncodedString(p.b,encoding,reportErrors=True)
    old_time = d.get('time')
    try:
        new_time = g.os_path_getmtime(fn)
    except Exception:
        new_time = None
    body_changed = old_body != new_body
    time_changed = old_time != new_time

    if body_changed and time_changed:
        g.es_print('Conflict in temp file for',p.h,color='red')
        result = g.app.gui.runAskYesNoCancelDialog(c,
            'Conflict!', c.conflict_message,
            yesMessage = 'Outline',
            noMessage = 'File',
            defaultButton = 'Cancel')
        if result is None or result.lower() == 'cancel':
            return False
        rewrite = result.lower() == 'yes'
    else:
        rewrite = body_changed

    if rewrite:
        # May be overridden by the mod_tempfname plugin.
        fn = c.createOpenWithTempFile(p,ext)
    else:
        g.es('reopening:',g.shortFileName(fn),color='blue')

    return fn
.. @+node:ekr.20100203050306.5937: *8* c.createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    trace = False and not g.unitTesting
    c = self ; f = None

    # May be over-ridden by mod_tempfname plugin.
    fn = c.openWithTempFilePath(p,ext)

    try:
        if not g.unitTesting:
            if g.os_path_exists(fn):
                g.es('recreating:  ',g.shortFileName(fn),color='red')
            else:
                g.es('creating:  ',g.shortFileName(fn),color='blue')
        f = open(fn,'w')
        # Convert s to whatever encoding is in effect.
        d = c.scanAllDirectives(p)
        encoding = d.get('encoding',None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        if g.isPython3: # 2010/02/09
            s = p.b
        else:
            s = g.toEncodedString(p.b,encoding,reportErrors=True) 
        f.write(s)
        f.flush()
        f.close()
        try:
            time = g.os_path_getmtime(fn)
            if time and not g.unitTesting:
                g.es('time: ',time)
        except:
            time = None

        # Remove previous entry from app.openWithFiles if it exists.
        for d in g.app.openWithFiles[:]:
            if p.v == d.get('v'):
                if trace: g.trace('removing',d.get('path'))
                g.app.openWithFiles.remove(d)

        d = {
            # Used by app.destroyOpenWithFilesForFrame.
            'c':c,
            # Used here and by app.destroyOpenWithFileWithDict.
            'path':fn,
            # Used by c.testForConflicts.
            'body':s,
            'encoding':encoding,
            'time':time,
            # Used by the open_with plugin.
            'p':p.copy(),
            # Used by c.openWithHelper, and below.
            'v':p.v,
        }
        g.app.openWithFiles.append(d)
        return fn
    except:
        if f: f.close()
        g.es('exception creating temp file',color='red')
        g.es_exception()
        return None
.. @+node:ekr.20031218072017.2832: *7* c.openWithTempFilePath (may be over-ridden)
def openWithTempFilePath (self,p,ext):

    '''Return the path to the temp file corresponding to p and ext.

    This is overridden in mod_tempfname plugin
    '''

    fn = '%s_LeoTemp_%s%s' % (
        g.sanitize_filename(p.h),
        str(id(p.v)),ext)
    if g.isPython3: # 2010/02/07
        fn = g.toUnicode(fn)
    td = g.os_path_finalize(tempfile.gettempdir())
    path = g.os_path_join(td,fn)

    return path
.. @+node:ekr.20120215072959.12535: *6* c.config.getOpenWith
def getOpenWith (self):

    '''Return a list of dictionaries corresponding to @openwith nodes.'''

    val = self.get('openwithtable','openwithtable')

    return val
.. @+node:ekr.20070411101643.1: *6* doOpenWith (ParserBaseClass)
def doOpenWith (self,p,kind,name,val):

    # g.trace(self.c.shortFileName(),'kind',kind,'name',name,'val',val)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    # g.trace('command',d.get('command'))
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
.. @+node:ekr.20070411101643.2: *6* parseOpenWith & helper
def parseOpenWith (self,p):

    d = {'command': None}

    for line in g.splitLines(p.b):
        self.parseOpenWithLine(line,d)

    return d
.. @+node:ekr.20070411101643.4: *7* parseOpenWithLine
def parseOpenWithLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if not g.match(s,0,'#'):
        d['command'] = s
.. @+node:ekr.20110605121601.18357: *6* createOpenWithMenu (QtMenu)
def createOpenWithMenu(self,parent,label,index,amp_index):

    '''Create the File:Open With submenu.

    This is called from leoMenu.createOpenWithMenuFromTable.'''

    # Use the existing Open With menu if possible.
    # g.trace(parent,label,index)

    menu = self.getMenu('openwith')

    if not menu:
        menu = self.new_menu(parent,tearoff=False,label=label)
        menu.insert_cascade(parent,index,
            label,menu,underline=amp_index)

    return menu
.. @+node:ekr.20070926135612: *6* createMenusFromConfigList & helpers (leoMenu)
def createMenusFromConfigList (self,aList):

    '''Create menus from aList instead of 'hard coded' menus.
    The 'top' menu has already been created.'''

    c = self.c
    tag = '@menu'
    for z in aList:
        kind,val,val2 = z
        if kind.startswith(tag):
            name = kind[len(tag):].strip()
            if not self.handleSpecialMenus(name,parentName=None):
                self.createNewMenu(name) # Create top-level menu.
                self.createMenuFromConfigList(name,val,level=0)
        else:
            self.error('%s %s not valid outside @menu tree' % (kind,val))

    table = c.config.getOpenWith()
    if table:
        self.createOpenWithMenuFromTable(table)
.. @+node:ekr.20070927082205: *7* createMenuFromConfigList
def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
            if not self.handleSpecialMenus(name,parentName,table):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
            table = []
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)
.. @+node:ekr.20070927172712: *7* handleSpecialMenus
def handleSpecialMenus (self,name,parentName,table=None):

    '''Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.'''

    c = self.c
    if table is None: table = []
    name2 = name.replace('&','').replace(' ','').lower()

    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus",c=c)
        return True
    elif name2.startswith('recentfiles'):
        # Just create the menu.
        # createRecentFilesMenuItems will create the contents later.
        self.createNewMenu(name,parentName)
        return True
    elif name2 == 'help' and sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu(table)
        return helpMenu is not None
    else:
        return False
.. @+node:ekr.20031218072017.4116: *6* createOpenWithMenuFromTable & helpers (leoMenu)
def createOpenWithMenuFromTable (self,table):

    '''table is a lists of dicts:
    
    - d.get('command'):  one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
    - d.get('shortcut'): the stroke (??)
    - d.get('name'):     the menu label.
    
    Leo executes command(arg+path) where path is the full path to the temp file.
    If ext is not None, the temp file has the given extension.
    Otherwise, Leo computes an extension based on the @language directive in effect.
'''

    trace = False and not g.unitTesting
    c,k = self.c,self.c.k
    if not table: return
    
    #### ?????
    g.app.openWithTable = table # Override any previous table.
    
    
    # Delete the previous entry.
    parent = self.getMenu("File")
    # if trace: g.trace('parent',parent)
    if not parent:
        if not g.app.batchMode:
            g.es('','createOpenWithMenuFromTable:','no File menu',color="red")
        return

    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except:
            g.trace('unexpected exception')
            g.es_exception()
            return
    
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    if not openWithMenu:
        g.trace('openWithMenu returns None')
        return
    
    self.setMenu("Open With...",openWithMenu)
    
    # Create the menu items in of the Open With menu.
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)

    for d in table:
        # k.bindOpenWith (shortcut,name,data)
        k.bindOpenWith(
            d.get('shortcut'),
            d.get('name'),
            self.getCommandList(d.get('command')))
.. @+node:ekr.20051022043608.1: *7* createOpenWithMenuItemsFromTable & callback (leoMenu)
def createOpenWithMenuItemsFromTable (self,menu,table):

    '''Create an entry in the Open with Menu from the table.

    Each entry should be a sequence with 2 or 3 elements.'''

    trace = False and not g.unitTesting
    # if trace: g.trace(g.callers())

    c = self.c ; k = c.k
    if g.app.unitTesting: return

    for d in table:
        label = d.get('name')
        command = self.getCommandList(d.get('command'))
        if trace:
            print()
            g.trace('d...len(command)',len(command))
            for key in sorted(list(d.keys())):
                print('%15s %s' % (key,d.get(key)))
            if len(command) != 3:
                print('*** oops: parts of commands...')
                for z in command: print(repr(z))

        accel = d.get('shortcut') or ''
        if label and command:
            realLabel = self.getRealMenuName(label)
            underline=realLabel.find("&")
            realLabel = realLabel.replace("&","")
            callback = self.defineOpenWithMenuCallback(command)
            c.add_command(menu,
                label=realLabel,
                accelerator=accel,
                command=callback,
                underline=underline)
.. @+node:ekr.20031218072017.4118: *8* defineOpenWithMenuCallback (leoMenu)
def defineOpenWithMenuCallback(self,data):

    # The first parameter must be event, and it must default to None.
    def openWithMenuCallback(event=None,self=self,data=data):
        return self.c.openWith(data=data)

    return openWithMenuCallback
.. @+node:ekr.20120227073551.10920: *7* getCommandList (leoMenu)
def getCommandList (self,s):
    
    '''s is a command line from parseOpenWithLine.'''
    
    if s:
        o = eval(s)
        return o
        # return s.split(',') #### Oh, so wrong.
    else:
        return ''
    
.. @+node:ekr.20031218072017.2829: *5* c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,arg,fn,openType,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False # and not g.unitTesting
    verbose = False
    testing = testing or g.unitTesting
    if arg is None: arg = ''
    
    def quote(s):
        return '"%s"' % s if s else ''
    def join(s1,s2):
        return '%s %s' % (s1,s2)
    
    # 2012/02/27: Carefully enclose arg and fn in double quotes.
    # This is tricky because these values come from the user.
    for ch in ("'",'"'):
        if openType.startswith(ch):
            openType = openType.strip(ch)
        if fn.startswith(ch):
            fn = fn.strip(ch)
        if type(arg) in (type((),),type([])):
            arg = [z.strip(ch) if z.startswith(ch) else z for z in arg]
        else:
            arg = arg.strip(ch) if arg.startswith(ch) else arg

    # Must be done *after* the loop.
    if type(arg) in (type((),),type([])):
        arg_tuple = arg
        arg = ' '.join(arg) # Do *not* quote the args.
    else:
        arg_tupe = []
        arg = quote(arg) # *Do* quote the arg.
    
    if trace:
        print()
        g.trace()
        print('%s(' % openType)
        print('  %s' % arg)
        print(')')
        
    # Do not quote the temp file name.

    try:
        command = '<no command>'
        # if openType == 'os.system':
            # command = '%s %s' % (arg,fn)
            # if trace:
                # g.trace()
                # print('  %s' % (arg))
                # print('  %s' % (fn))
            # if not testing:
                # os.system(command)
        # el
        if openType == 'os.startfile':
            command = 'os.startfile(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: os.startfile(join(arg,fn))
        elif openType == 'exec':
            command = 'exec(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: exec(join(arg,fn),{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg_tuple[0]) 
            vtuple = arg_tuple[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s,%s)' % (arg[0],repr(vtuple))
            if trace: g.trace(command)
            if not testing: os.spawnv(os.P_NOWAIT,arg[0],vtuple)
        elif openType == 'subprocess.Popen':
            use_shell = True
            c_arg = join(arg,fn)
            command = 'subprocess.Popen(%s)' % c_arg
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(c_arg,shell=use_shell)
                except OSError:
                    g.es_print('c_arg',repr(c_arg))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
.. @+node:ekr.20120208062900.10146: *4* new_modes
@nocolor-node

This will eliminate the hacks for *entry-commands* and *command-prompt keys.

ModeController: a wrapper for g.app.config.modeCommandsDict

Clean up #### in leoKeys
.. @+node:ekr.20120212060348.10374: *5*  << global switches >>
trace_startup = False
    # These traces use print instead of g.trace so that
    # the traces can add class info the method name.

new_modes = False
    # True: use ModeController and ModeInfo classes.
if new_modes: print('***** new_modes')

new_keys = False
    # This project hardly seems urgent.
    # True: Qt input methods produce a **user setting**, not a stroke.
if new_keys: print('***** new_keys')

# Traces of scrolling problems.
trace_scroll = False
    # Trace calls to get/setYScrollPosition
trace_see = False
    # Trace calls to see and setInsertPoint.

# Switches to trace the garbage collector.
trace_gc = False           
trace_gc_calls = False    
trace_gc_calls = False 
trace_gc_verbose = False
trace_gc_inited = False

trace_masterCommand = False
trace_masterKeyHandler = False
trace_masterKeyHandlerGC = False
trace_minibuffer = False
trace_modes = False

enableDB = True
    # Don't even think about eliminating this constant:
    # it is needed for debugging.
    
# These print statements have been moved to writeWaitingLog.
# This allows for better --silent operation.
if 0:
    print('*** isPython3: %s' % isPython3)
    if not enableDB:
        print('** leoGlobals.py: caching disabled')
.. @+node:ekr.20120208061308.10131: *5* Weird stroke code
@nocolor-node

isFKey and k.isPlainKey don't seem to know the types of their args.
.. @+node:ekr.20061031131434.181: *6* k.Shortcuts & bindings
.. @+node:ekr.20061031131434.176: *7* k.computeInverseBindingDict
def computeInverseBindingDict (self):

    k = self ; d = {}

    # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict.keys():
        assert g.isStroke(stroke),repr(stroke)
        aList = k.bindingsDict.get(stroke,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            shortcutList = d.get(si.commandName,[])
            
            # The shortcutList consists of tuples (pane,stroke).
            # k.inverseBindingDict has values consisting of these tuples.
            aList = k.bindingsDict.get(stroke,g.ShortcutInfo(kind='dummy',pane='all'))
                    # Important: only si.pane is required below.
            for si in aList:
                assert g.isShortcutInfo(si),si
                pane = '%s:' % (si.pane)
                data = (pane,stroke)
                if data not in shortcutList:
                    shortcutList.append(data)

            d [si.commandName] = shortcutList

    return d
.. @+node:ekr.20061031131434.179: *7* k.getShortcutForCommand/Name
def getShortcutForCommandName (self,commandName):

    k = self ; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke),repr(stroke)
            aList = k.bindingsDict.get(stroke,[])
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.commandName == commandName:
                    return stroke
    return None

def getShortcutForCommand (self,command):

    k = self ; c = k.c
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke),repr(stroke)
            aList = k.bindingsDict.get(stroke,[])
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.commandName == command.__name__:
                    return stroke
    return None
.. @+node:ekr.20090518072506.8494: *7* k.isFKey
def isFKey (self,stroke):

    k = self
    if not stroke: return False
    assert g.isString(stroke) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
.. @+node:ekr.20061031131434.182: *7* k.isPlainKey
def isPlainKey (self,stroke):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self
    if not stroke: return False

    assert g.isString(stroke) or g.isStroke(stroke)
    shortcut = stroke.s if g.isStroke(stroke) else stroke

    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True

    for z in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(z) != -1:            
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut in ('Tab','\t')
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
.. @+node:ekr.20061031131434.191: *7* k.prettyPrintKey
def prettyPrintKey (self,stroke,brief=False):

    trace = False and not g.unitTesting
    k = self
    if not stroke:
        s = ''
    elif g.isStroke(stroke):
        s = stroke.s
    else:
        s = stroke

    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields',fields)
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    if s.endswith(' '):
        s = s[:-1]+'Space' # 2010/11/06
        
    return s
.. @+node:ekr.20061031131434.184: *7* k.strokeFromSetting
def strokeFromSetting (self,setting,addKey=True):

    k = self

    trace = True and not g.unitTesting # and setting.lower().find('ctrl-x') > -1
    verbose = False
    if not setting:
        return None
    
    assert g.isString(setting)

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>

    if trace and verbose:
        g.trace('%20s %s' % (setting,shortcut),g.callers())
    
    return g.KeyStroke(shortcut) if shortcut else None

canonicalizeShortcut = strokeFromSetting # For compatibility.
### strokeFromSetting = shortcutFromSetting
.. @+node:ekr.20061031131434.185: *8* << define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
meta  = s2.find("meta") >= 0
.. @+node:ekr.20061031131434.186: *8* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
.. @+node:ekr.20061031131434.187: *8* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
.. @+node:ekr.20061031131434.188: *8* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s),repr(setting))
            g.trace(g.callers())
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
.. @+node:ekr.20061031131434.189: *8* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag,val in table if flag])
.. @+node:ekr.20110606004638.16929: *7* k.stroke2char
def stroke2char (self,stroke):
    
    '''Convert a stroke to an (insertable) char.
    
    This method allows Leo to use strokes everywhere.'''
    
    trace = False and not g.unitTesting
    k = self
    
    if not stroke: return ''
    s = stroke.s
    
    # Allow bare angle brackets for unit tests.
    if s.startswith('<') and s.endswith('>'):
        s = s[1:-1]
        
    if len(s) == 0: return ''
    if len(s) == 1: return s
        
    for z in ('Alt','Ctrl','Command','Meta'):
        if s.find(z) != -1:            
            return ''
            # This is not accurate: leoQtEventFilter retains
            # the spelling of Alt-Ctrl keys because of the
            # @bool enable_alt_ctrl_bindings setting.
            
    # Special case the gang of four, plus 'Escape',
    d = {
        'BackSpace':'\b',
        'Escape':'Escape',
        'Linefeed':'\r',
        'Return':'\n',
        'Tab':'\t',
    }
    ch = d.get(s)
    if ch: return ch
            
    # First, do the common translations.
    ch = k.guiBindNamesInverseDict.get(s)
    if ch:
        if trace: g.trace(repr(stroke),repr(ch))
        return ch
    
    # A much-simplified form of code in k.strokeFromSetting.
    shift = s.find('Shift+') > -1 or s.find('Shift-') > -1
    s = s.replace('Shift+','').replace('Shift-','')
    
    last = s #  Everything should have been stripped.
    
    if len(s) == 1 and s.isalpha():
        if shift:
            s = last.upper()
        else:
            s = last.lower()
    
    val = g.choose(len(s)==1,s,'')

    if trace: g.trace(repr(stroke),repr(val)) # 'shift',shift,
    return val
.. @+node:ekr.20061031131434.100: *5* k.addModeCommands (enterModeCallback)
def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''
    
    trace = False and not g.unitTesting
    
    if trace: g.trace('(k)')

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        if trace: g.trace(f.__name__,key,'len(c.commandsDict.keys())',len(list(c.commandsDict.keys())))
.. @+node:ekr.20120208064440.10192: *5* From leoConfig...
.. @+node:ekr.20060102103625.1: *6* doMode (ParserBaseClass)
def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-<name>-mode command.'''

    trace = False and not g.unitTesting
    c,k = self.c,self.c.k
    
    if g.new_modes:
        aList = []
        for line in g.splitLines(p.b):
            line = line.strip()
            if line and not g.match(line,0,'#'):
                name2,si = self.parseShortcutLine('*mode-setting*',line)
                aList.append((name2,si),)
        k.modeController.makeMode(name,aList)
    else:
        name1 = name

        # g.trace('%20s' % (name),c.fileName())
        modeName = self.computeModeName(name)
    
        d = g.TypedDictOfLists(
            name='modeDict for %s' % (modeName),
            keyType=type('commandName'),valType=g.ShortcutInfo)
    
        s = p.b
        lines = g.splitLines(s)
        for line in lines:
            line = line.strip()
            if line and not g.match(line,0,'#'):
                name,si = self.parseShortcutLine('*mode-setting*',line)
                assert g.isShortcutInfo(si),si
                if not name:
                    # An entry command: put it in the special *entry-commands* key.
                    d.add('*entry-commands*',si)
                elif si is not None:
                    # A regular shortcut.
                    si.pane = modeName
                    aList = d.get(name,[])
                    for z in aList:
                        assert g.isShortcutInfo(z),z
                    # Important: use previous bindings if possible.
                    key2,aList2 = c.config.getShortcut(name)
                    for z in aList2:
                        assert g.isShortcutInfo(z),z
                    aList3 = [z for z in aList2 if z.pane != modeName]
                    if aList3:
                        # g.trace('inheriting',[b.val for b in aList3])
                        aList.extend(aList3)
                    aList.append(si)
                    d.replace(name,aList)
                    
                    if 0: #### Why would we want to do this????
                        #### Old code: we have to save/restore self.shortcutsDict.
                            #### self.set(p,"shortcut",name,aList)
                        # Set the entry directly.
                        d2 = self.shortcutsDict
                        gs = d2.get(key2)
                        if gs:
                            assert g.isGeneralSetting(gs)
                            path = gs.path
                            if c.os_path_finalize(c.mFileName) != c.os_path_finalize(path):
                                g.es("over-riding setting:",name,"from",path)
        
                        # Important: we can't use c here: it may be destroyed!
                        d2 [key2] = g.GeneralSetting(
                            kind,path=c.mFileName,val=val,tag='setting')
    
            # Restore the global shortcutsDict.
            ##### self.shortcutsDict = old_d
            
            if trace: g.trace(d.dump())
        
            # Create the command, but not any bindings to it.
            self.createModeCommand(modeName,name1,d)
.. @+node:ekr.20041120112043: *6* parseShortcutLine (ParserBaseClass)
def parseShortcutLine (self,kind,s):

    '''Parse a shortcut line.  Valid forms:

    --> entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name --> mode-name = binding
    command-name --> same = binding
    '''

    trace = False and not g.unitTesting # and kind == '*mode-setting*'
    c,k = self.c,self.c.k
    assert c
    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)

    if g.match(s,i,'-->'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        if trace: g.trace('-->',entryCommandName)
        return None,g.ShortcutInfo('*entry-command*',commandName=entryCommandName)

    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name:
        if trace: g.trace('no name',repr(s))
        return None,None

    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'->'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]

    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]

    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    stroke = k.strokeFromSetting(val)
    assert g.isStrokeOrNone(stroke),stroke
    # g.trace('stroke',stroke)
    si = g.ShortcutInfo(kind=kind,nextMode=nextMode,pane=pane,stroke=stroke)
    if trace: g.trace('%25s %s' % (name,si))
    return name,si
.. @+node:ekr.20060102103625: *6* createModeCommand (ParserBaseClass)
def createModeCommand (self,modeName,name,modeDict):

    modeName = 'enter-' + modeName.replace(' ','-')

    i = name.find('::')
    if i > -1:
        # The prompt is everything after the '::'
        prompt = name[i+2:].strip()
        modeDict ['*command-prompt*'] = g.ShortcutInfo(kind=prompt)

    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    # New in 4.4.1 b2: silently allow redefinitions of modes.
    d [modeName] = modeDict
.. @+node:ekr.20120208064440.10148: *5* class ModeController
class ModeController:
    
    def __init__ (self,c):
        self.c = c
        self.d = {} # Keys are command names, values are modes.
        self.k = c.k
        g.trace(self)
            
    def __repr__(self):
        return '<ModeController %s>' % self.c.shortFileName()
        
    __str__ = __repr__
            
    @others
.. @+node:ekr.20120208064440.10161: *6* addModeCommands (ModeController)
def addModeCommands(self):
    
    g.trace(self,self.d)
    
    for mode in self.d.values():
        mode.createModeCommand()
.. @+node:ekr.20120208064440.10163: *6* getMode (ModeController)
def getMode (self,modeName):
    
    g.trace(self)
    
    mode = self.d.get(modeName)
    g.trace(modeName,mode)
    return mode
    
.. @+node:ekr.20120208064440.10164: *6* makeMode (ModeController)
def makeMode (self,name,aList):


    mode = ModeInfo(self.c,name,aList)
    
    g.trace(self,mode.name,mode)
    self.d[mode.name] = mode
    
.. @+node:ekr.20120208064440.10150: *5* class ModeInfo
class ModeInfo:
    
    def __repr__(self):
        return '<ModeInfo %s>' % self.name
        
    __str__ = __repr__
    
    @others
    
.. @+node:ekr.20120208064440.10193: *6*  ctor (ModeInfo)
def __init__ (self,c,name,aList):
    
    self.c = c
    self.d = {} # The bindings in effect for this mode.
        # Keys are names of (valid) command names, values are ShortcutInfo objects.
    self.entryCommands = []
        # A list of ShortcutInfo objects.
    self.k = c.k
    self.name = self.computeModeName(name)
    self.prompt = self.computeModePrompt(self.name)

    self.init(name,aList)
.. @+node:ekr.20120208064440.10152: *6* computeModeName (ModeInfo)
def computeModeName (self,name):

    s = name.strip().lower()
    j = s.find(' ')
    if j > -1: s = s[:j]
    if s.endswith('mode'):
        s = s[:-4].strip()
    if s.endswith('-'):
        s = s[:-1]

    i = s.find('::')
    if i > -1:
        # The actual mode name is everything up to the "::"
        # The prompt is everything after the prompt.
        s = s[:i]

    return s + '-mode'
.. @+node:ekr.20120208064440.10156: *6* computeModePrompt (ModeInfo)
def computeModePrompt (self,name):
    
    assert name == self.name
    s = 'enter-' + name.replace(' ','-')
    i = s.find('::')
    if i > -1:
        # The prompt is everything after the '::'
        prompt = s[i+2:].strip()
    else:
        prompt = s
    
    return prompt
.. @+node:ekr.20120208064440.10160: *6* createModeBindings (ModeInfo) (NOT USED)
##### k.createModeBindings is used instead????

def createModeBindings (self,w):

    '''Create mode bindings for w, a text widget.'''

    trace = True and not g.unitTesting
    c,d,k,modeName = self.c,self.d,self.k,self.name
    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command: %s Referenced from %s' % (
                commandName,modeName))
            continue
        aList = d.get(commandName,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            if trace: g.trace(si)
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None','none',None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)
                        
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.ShortcutInfo(
                    kind = 'mode<%s>' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
                if trace: g.trace(modeName,d2)
.. @+node:ekr.20120208064440.10195: *6* createModeCommand (ModeInfo)
def createModeCommand (self):
    
    g.trace(self)

    c,k = self.c,self.k
    key = 'enter-' + self.name.replace(' ','-')
   
    def enterModeCallback (event=None,self=self):
        self.enterMode()

    c.commandsDict[key] = f = enterModeCallback
    k.inverseCommandsDict [f.__name__] = key
    
    g.trace('(ModeInfo)',f.__name__,key,'len(c.commandsDict.keys())',len(list(c.commandsDict.keys())))
.. @+node:ekr.20120208064440.10180: *6* enterMode (ModeInfo)
def enterMode (self):
    
    g.trace('(ModeInfo)')

    c,k = self.c,self.k
    c.inCommand = False
        # Allow inner commands in the mode.
    event=None ####
    k.generalModeHandler(event,modeName=self.name)
.. @+node:ekr.20120208064440.10153: *6* init (ModeInfo) (Can we check command names here??)
def init (self,name,dataList):
    
    '''aList is a list of tuples (commandName,si).'''
    
    trace = True and not g.unitTesting
    c,d,k,modeName = self.c,self.d,self.c.k,self.name
    for name,si in dataList:
    
        assert g.isShortcutInfo(si),si
        if not name:
            if trace: g.trace('entry command',si)
            #### An entry command: put it in the special *entry-commands* key.
            #### d.add('*entry-commands*',si)
            self.entryCommands.append(si)
        elif si is not None:
            # A regular shortcut.
            si.pane = modeName
            aList = d.get(name,[])
            for z in aList:
                assert g.isShortcutInfo(z),z
            # Important: use previous bindings if possible.
            key2,aList2 = c.config.getShortcut(name)
            for z in aList2:
                assert g.isShortcutInfo(z),z
            aList3 = [z for z in aList2 if z.pane != modeName]
            if aList3:
                if trace: g.trace('inheriting',[si.val for si in aList3])
                aList.extend(aList3)
            aList.append(si)
            d[name] = aList
.. @+node:ekr.20120208064440.10158: *6* initMode (ModeInfo)
def initMode (self):
    
    trace = False and not g.unitTesting
    c,k = self.c,self.c.k
    
    ####
    # d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    # if not d:
        # self.badMode(modeName)
        # return
    # else:
        # k.modeBindingsDict = d
        # si = d.get('*command-prompt*')
        # if si:
            # prompt = si.kind # A kludge.
        # else:
            # prompt = modeName
        # if trace: g.trace('modeName',modeName,prompt,'d.keys()',list(d.keys()))

    k.inputModeName = self.name
    k.silentMode = False

    #### aList = d.get('*entry-commands*',[])
    for si in self.entryCommands:
        assert g.isShortcutInfo(si),si
        commandName = si.commandName
        if trace: g.trace('entry command:',commandName)
        k.simulateCommand(commandName)
        # Careful, the command can kill the commander.
        if g.app.quitting or not c.exists: return
        # New in Leo 4.5: a startup command can immediately transfer to another mode.
        if commandName.startswith('enter-'):
            if trace: g.trace('redirect to mode',commandName)
            return

    # Create bindings after we know whether we are in silent mode.
    # w = g.choose(k.silentMode,k.modeWidget,k.w)
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(self.name,self.d,w)
    #### self.createModeBindings(w)
    k.showStateAndMode(prompt=self.name)
.. @+node:ekr.20120208064440.10191: *5* From leoKeys...
.. @+node:ekr.20061031131434.76: *6* k.__init__
def __init__ (self,c):

    '''Create a key handler for c.'''
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('k.__init__')

    self.c = c
    self.dispatchEvent = None
    self.inited = False         # Set at end of finishCreate.
    self.swap_mac_keys = False  #### How to init this ????
    self.w = None
            # Note: will be None for nullGui.

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.defineSettingsIvars()
    
    if g.new_modes:
        self.modeController = ModeController(c)

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.

    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction() # 2011/02/09
.. @+node:ekr.20120208064440.10190: *6* k.Modes (no change)
.. @+node:ekr.20061031131434.100: *7* k.addModeCommands (enterModeCallback)
def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''
    
    trace = False and not g.unitTesting
    
    if trace: g.trace('(k)')

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        if trace: g.trace(f.__name__,key,'len(c.commandsDict.keys())',len(list(c.commandsDict.keys())))
.. @+node:ekr.20061031131434.157: *7* k.badMode
def badMode(self,modeName):

    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
.. @+node:ekr.20061031131434.158: *7* k.createModeBindings
def createModeBindings (self,modeName,d,w):

    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''

    trace = True and not g.unitTesting
    k = self ; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*','*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:',commandName,'Referenced from',modeName)
            continue
        aList = d.get(commandName,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None','none',None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)
                        
                assert g.isStroke(stroke)

                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.ShortcutInfo(
                    kind = 'mode<%s>' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
.. @+node:ekr.20120208064440.10179: *7* k.endMode
def endMode(self):

    k = self ; c = k.c

    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane

    k.endCommand(k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.

    if w:
        c.widgetWantsFocusNow(w)
.. @+node:ekr.20061031131434.160: *7* k.enterNamedMode
def enterNamedMode (self,event,commandName):

    k = self ; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event,modeName=modeName)
.. @+node:ekr.20061031131434.161: *7* k.exitNamedMode
def exitNamedMode (self,event=None):
    
    '''Exit an input mode.'''

    k = self

    if k.inState():
        k.endMode()

    k.showStateAndMode()
.. @+node:ekr.20061031131434.165: *7* k.modeHelp & helper (revise helper)
def modeHelp (self,event):

    '''The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''

    k = self ; c = k.c

    c.endEditing()

    # g.trace(k.inputModeName)

    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)

    if not k.silentMode:
        c.minibufferWantsFocus()

    return
.. @+node:ekr.20061031131434.166: *8* modeHelpHelper
def modeHelpHelper (self,d):

    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data,n = [],0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*','*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si),si
                stroke = si.stroke
                if stroke not in (None,'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n,len(s1))
                    data.append((s1,s2),)

    data.sort()
    modeName = k.inputModeName.replace('-',' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()
    g.es('','%s mode\n\n' % modeName,tabName=tabName)

    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
.. @+node:ekr.20061031131434.164: *7* k.reinitMode (call k.createModeBindings???)
def reinitMode (self,modeName):

    k = self ; c = k.c

    d = k.modeBindingsDict

    k.inputModeName = modeName
    w = g.choose(k.silentMode,k.modeWidget,k.w)
    k.createModeBindings(modeName,d,w)

    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName+': ',protect=True)

.. @+node:ekr.20120208064440.10199: *7* k.generalModeHandler (OLD)
def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return # (for Tk) 'break'
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                return # (for Tk) 'break'
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                if g.app.quitting or not c.exists: return # (for Tk) 'break'
.. @+node:ekr.20061031131434.156: *6* k.Modes (changed)
.. @+node:ekr.20061031131434.163: *7* k.initMode (OLD MODES)
def initMode (self,event,modeName):

    k = self ; c = k.c
    trace = (False or g.trace_modes) and not g.unitTesting

    if not modeName:
        g.trace('oops: no modeName')
        return
        
    if g.new_modes:
        mode = k.modeController.getMode(modeName)
        if mode:
            mode.initMode()
        else:
            g.trace('***** oops: no mode',modeName)
    else:

        d = g.app.config.modeCommandsDict.get('enter-'+modeName)
        if not d:
            self.badMode(modeName)
            return
        else:
            k.modeBindingsDict = d
            si = d.get('*command-prompt*')
            if si:
                prompt = si.kind # A kludge.
            else:
                prompt = modeName
            if trace: g.trace('modeName',modeName,prompt,'d.keys()',list(d.keys()))
    
        k.inputModeName = modeName
        k.silentMode = False
    
        aList = d.get('*entry-commands*',[])
        if aList:
            for si in aList:
                assert g.isShortcutInfo(si),si
                commandName = si.commandName
                if trace: g.trace('entry command:',commandName)
                k.simulateCommand(commandName)
                # Careful, the command can kill the commander.
                if g.app.quitting or not c.exists: return
                # New in Leo 4.5: a startup command can immediately transfer to another mode.
                if commandName.startswith('enter-'):
                    if trace: g.trace('redirect to mode',commandName)
                    return
    
        # Create bindings after we know whether we are in silent mode.
        w = g.choose(k.silentMode,k.modeWidget,k.w)
        k.createModeBindings(modeName,d,w)
        k.showStateAndMode(prompt=prompt)
.. @+node:ekr.20120208064440.10201: *7* k.NEWgeneralModeHandler (NEW MODES)
def NEWgeneralModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return # (for Tk) 'break'
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
        return # (for Tk) 'break'
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                return # (for Tk) 'break'
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                if g.app.quitting or not c.exists: return # (for Tk) 'break'

    return # (for Tk) 'break'
.. @+node:ekr.20120226131923.10221: *4* Allow abbreviations in minibuffer 
@nocolor-node

cfa=clone-find-all-flattened
.. @+node:ekr.20120226063218.10211: *4* Before 4.10 b1
@nocolor-node

Release 4.10 b1 after completing the following items:

- Get the Open With menu working again.

- Complete the new_modes work.

- Fix bug 844953: copy-clone-pasted node appears in other tab.

- Fix bug 869429: Undo and Redo delete from context menu does not redo properly.

- Factor the many leo-editor posts that I have marked as pre-writing into Leo's docs.
.. @+node:ekr.20120226183512.10196: *3* Before 4.10 b1
.. @+node:ekr.20111026091322.16496: *4* Bug 844953: copy-clone-pasted node appears in other tab
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/844953
.. @+node:ekr.20111026091322.16494: *4* Bug 869429: Undo and Redo delete from context menu does not redo properly
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/869429

Delete (node) in context_menu (right click on headline) has unexpected undo /
redo effects. Redo after Undo often fails, but you can Undo again, without the
ReDo taking effect, which mans an extra node is created. In essence: -1 delete,
+1 Undo (restore node), 0 ReDo (should redelete but does nothing), +1 Undo
(again) = 1 Should = 0 (delete, undelete, redelete, undo redelete) Deleting a
node through Outline menu works differently and properly. Thye undo code in the
two delete methods must be different

Terry:  The undo code in the two delete methods must be different

It's different because the context menu delete can delete multiple
nodes at once.

I wrote the context menu delete, but I don't understand the undo system
that well - it's possible it just doesn't support a redo of something
like this.
.. @+node:ekr.20110929165422.15449: *4* Test bug fix: noweb expansions in rst3 command
@nocolor-node

*** Important *** This was all done in Leo 4.9

http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

> What would work for me is if named sections in a @rst subtree
> would work exactly as they work for other derived files: they
> get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references:  default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
.. @+node:ekr.20111018104244.15918: *5* Report
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/15239f5f504cee6f

I tried it out with:

Test
.....@rst test.html
      which contains:
      This is a test (underlined)
      then the reference:
      <<test>>
...............<<test>>
                which contains: Here is some text.

In the top node Test I have:
@ @rst-options
expand_noweb_references=True
expand_noweb_recursively=True
show_headlines=False  (without this, the <<test>> headline becomes a section
heading)
@c

It sort of works:
--------------------------------------------
This is a test

<<test>>Here is some text.

Here is some text.
--------------------------------------------

The reference <<test>> does not get erased, even if the definition actually
gets inserted beside it. On the other hand, though I can suppress the
headline of the definition with the rst option, the body of the definition
gets inserted as a section anyway; definitions are not ignored by rst.

But now I can go see what happens in the code for debugging, since the
option gives a pointer into the code.

Thanks!
.. @+node:ekr.20100813041139.5920: *5* Entry points
.. @+node:ekr.20100812082517.5945: *6* code_to_rst_command & helpers
def code_to_rst_command (self,event=None,p=None,scriptSettingsDict=None,toString=False):

    '''Format the presently selected node as computer code.

    Settings from scriptSettingsDict override normal settings.

    On exit:
        self.source contains rst sources
        self.stringOutput contains docutils output if docutils called.
    '''

    trace = False and not g.unitTesting
    c = self.c
    if p: p = p.copy()
    else: p = c.p
    self.topNode = p.copy()
    self.topLevel = p.level()

    # **Important**: This command works as much like the rst3 command as possible.
    # Difference arise because there is no @rst node to specify a filename.
    # Instead we get the filename from scriptSettingsDict, or use 'code_to_rst.html'

    # Capture the settings, munging all settings.
    self.scriptSettingsDict = {}
    d = scriptSettingsDict
    if d:
        for key in d.keys():
            self.scriptSettingsDict[self.munge(key)] = d.get(key)

    # Init options...
    self.preprocessTree(p)
    self.init_write(p) # scanAllDirectives sets self.path and self.encoding.
    self.scanAllOptions(p) # Settings for p are valid after this call.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')
    fn = self.getOption('output-file-name') or 'code_to_rst.html'
    junk,ext = g.os_path_splitext(fn)

    # Write the rst sources to self.sources...
    self.outputFile = StringIO()
    self.write_code_tree(p,fn)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if callDocutils or writeIntermediateFile:
        self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
.. @+node:ekr.20100812082517.5963: *7* write_code_body & helpers
def write_code_body (self,p):

    trace = False
    self.p = p.copy() # for traces.
    if not p.b.strip():
        return # No need to write any more newlines.

    showDocsAsParagraphs = self.getOption('show_doc_parts_as_paragraphs')
    lines = g.splitLines(p.b)
    parts = self.split_parts(lines,showDocsAsParagraphs)
    result = []
    for kind,lines in parts:
        if trace: g.trace(kind,len(lines),p.h)
        if kind == '@rst-option': # Also handles '@rst-options'
            pass # The prepass has already handled the options.
        elif kind == '@rst-markup':
            lines.extend('\n')
            result.extend(lines)
        elif kind == '@doc':
            if showDocsAsParagraphs:
                result.extend(lines)
                result.append('\n')
            else:
                result.extend(self.write_code_block(lines))
        elif kind == 'code':
            result.extend(self.write_code_block(lines))
        else:
            g.trace('Can not happen',kind)

    # Write the lines with exactly two trailing newlines.
    s = ''.join(result).rstrip() + '\n\n'
    self.write(s)
.. @+node:ekr.20100812082517.5964: *8* split_parts
def split_parts (self,lines,showDocsAsParagraphs):

    '''Split a list of body lines into a list of tuples (kind,lines).'''

    kind,parts,part_lines = 'code',[],[]
    for s in lines:
        if g.match_word(s,0,'@ @rst-markup'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind = '@rst-markup'
            n = len('@ @rst-markup')
            after = s[n:].strip()
            part_lines = g.choose(after,[after],[])
        elif s.startswith('@ @rst-option'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind,part_lines = '@rst-option',[s] # part_lines will be ignored.
        elif s.startswith('@ ') or s.startswith('@\n') or s.startswith('@doc'):
            if showDocsAsParagraphs:
                if part_lines: parts.append((kind,part_lines[:]),)
                kind = '@doc'
                # Put only what follows @ or @doc
                n = g.choose(s.startswith('@doc'),4,1)
                after = s[n:].lstrip()
                part_lines = g.choose(after,[after],[])
            else:
                part_lines.append(s) # still in code mode.
        elif g.match_word(s,0,'@c') and kind != 'code':
            if kind == '@doc' and not showDocsAsParagraphs:
                part_lines.append(s) # Show the @c as code.
            parts.append((kind,part_lines[:]),)
            kind,part_lines = 'code',[]
        else:
            part_lines.append(s)

    if part_lines:
        parts.append((kind,part_lines[:]),)

    return parts
.. @+node:ekr.20100812082517.5965: *8* write_code_block
def write_code_block (self,lines):

    result = ['::\n\n'] # ['[**code block**]\n\n']

    if self.getOption('number-code-lines'):
        i = 1
        for s in lines:
            result.append('    %d: %s' % (i,s))
            i += 1
    else:
        result.extend(['    %s' % (z) for z in lines])

    s = ''.join(result).rstrip()+'\n\n'
    return g.splitLines(s)
.. @+node:ekr.20100812082517.5966: *7* write_code_headline & helper
def write_code_headline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''


    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.write_code_headline_helper(p)
.. @+node:ekr.20100812082517.5967: *8* write_code_headline_helper
def write_code_headline_helper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in ('@rst-option','@rst-options','@rst-no-head','@rst-no-headlines'):
            return

        for prefix in ('@rst-ignore-node','@rst-ignore-tree','@rst-ignore'):
            if word == prefix:
                h = h [len(word):].strip()
                break

    if not h.strip(): return

    if self.getOption('show_sections'):
        self.write(self.underline(h,p))
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
.. @+node:ekr.20100812082517.5968: *7* write_code_node
def write_code_node (self,p):

    '''Format a node according to the options presently in effect.

    Side effect: advance p'''

    h = p.h.strip()
    self.scanAllOptions(p)

    if self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.write_code_headline(p)
        self.write_code_body(p)
        p.moveToThreadNext()
.. @+node:ekr.20100812082517.5939: *7* write_code_tree
def write_code_tree (self,p,fn):

    '''Write p's tree as code to self.outputFile.'''

    self.scanAllOptions(p) # So we can get the next option.

    if self.getOption('generate_rst_header_comment'):
        self.write('.. rst3: filename: %s\n\n' % fn)

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.write_code_node(p) # Side effect: advances p.
.. @+node:ekr.20090511055302.5793: *6* rst3 command & helpers
def rst3 (self,event=None):

    '''Write all @rst nodes.'''

    self.processTopTree(self.c.p)
.. @+node:ekr.20090502071837.62: *7* processTopTree
def processTopTree (self,p,justOneFile=False):

    c = self.c ; current = p.copy()

    # This strange looking code looks up and down the tree for @rst nodes.
    for p in current.self_and_parents():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
            break
        elif h.startswith('@slides'):
            self.processTree(p,ext=None,toString=False,justOneFile=False)
            break
    else:
        self.processTree(current,ext=None,toString=False,justOneFile=justOneFile)

    g.es_print('done',color='blue')
.. @+node:ekr.20090502071837.63: *7* processTree
def processTree(self,p,ext=None,toString=False,justOneFile=False):

    '''Process all @rst nodes in a tree.
    ext is the docutils extention: it's useful for scripts and unit tests.
    '''

    trace = False and not g.unitTesting
    if trace: g.trace(p.h)
    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            fn = h[4:].strip()
            if ((fn and fn[0] != '-') or (toString and not fn)):
                if trace: g.trace('found: %s',p.h)
                found = True
                self.write_rst_tree(p,ext,fn,toString=toString,justOneFile=justOneFile)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        elif g.match(h,0,"@slides"):
            self.write_slides(p)
            found = True
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    if not found:
        g.es('No @rst or @slides nodes in selected tree',color='blue')
    return None,None
.. @+node:ekr.20090502071837.64: *7* write_rst_tree
def write_rst_tree (self,p,ext,fn,toString=False,justOneFile=False):

    '''Convert p's tree to rst sources.
    Optionally call docutils to convert rst to output.

    On exit:
        self.source contains rst sources
        self.stringOutput contains docutils output if docutils called.
    '''

    c = self.c
    self.topNode = p.copy()
    self.topLevel = p.level()
    if toString:
        ext = ext or '.html' # 2010/08/12: Unit test found this.
    else:
        junk,ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext.startswith('.'): ext = '.' + ext

    # Init options...
    self.init_write(p) # ScanAllDirectives sets self.path and self.encoding.
    self.scanAllOptions(p) # Settings for p are valid after this call.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')

    # Write the rst sources to self.source.
    self.outputFile = StringIO()
    self.writeTree(p,fn)
    self.source = self.outputFile.getvalue() # the rST sources.
    self.outputFile = None
    self.stringOutput = None

    if callDocutils or writeIntermediateFile:
        self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
.. @+node:ekr.20100822092546.5835: *7* write_slides & helper
def write_slides (self,p,toString=False):

    '''Convert p's children to slides.'''

    c = self.c ; p = p.copy() ; h = p.h
    i = g.skip_id(h,1) # Skip the '@'
    kind,fn = h[:i].strip(),h[i:].strip()
    if not fn: return g.es('%s requires file name' % (kind),color='red')
    title = p and p.firstChild().h or '<no slide>'
    title = title.strip().capitalize()
    n_tot = p.numberOfChildren()

    n = 1
    for child in p.children():
        self.init_write(p) # ScanAllDirectives sets self.path and self.encoding.
        self.scanAllOptions(child) # Settings for child are valid after this call.
        # Compute the slide's file name.
        fn2,ext = g.os_path_splitext(fn)
        fn2 = '%s-%03d%s' % (fn2,n,ext) # Use leading zeros for :glob:.
        n += 1
        # Write the rst sources to self.source.
        self.outputFile = StringIO()
        self.writeSlideTitle(title,n-1,n_tot)
        self.writeBody(child)
        self.source = self.outputFile.getvalue() # the rST sources.
        self.outputFile,self.stringOutput = None,None
        self.write_files(ext,fn2,
            callDocutils=self.getOption('call_docutils'),
            toString=toString,
            writeIntermediateFile=self.getOption('write_intermediate_file'))
.. @+node:ekr.20100822174725.5836: *8* writeSlideTitle
def writeSlideTitle (self,title,n,n_tot):

    '''Write the title, underlined with the '#' character.'''

    if n != 1:
        title = '%s (%s of %s)' % (title,n,n_tot)

    width = max(4,len(g.toEncodedString(title,
        encoding=self.encoding,reportErrors=False)))

    self.write('%s\n%s \n\n' % (title,('#'*width)))
.. @+node:ekr.20090502071837.58: *7* write methods (rst3 command)
.. @+node:ekr.20090502071837.68: *8* getDocPart
def getDocPart (self,lines,n):

    # g.trace('n',n,repr(''.join(lines)))

    result = []
    << Append whatever follows @doc or @space to result >>
    while n < len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
.. @+node:ekr.20090502071837.69: *9* << Append whatever follows @doc or @space to result >>
if n > 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
.. @+node:ekr.20090502071837.81: *8* handleSpecialDocParts
def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
.. @+node:ekr.20090502071837.77: *8* isAnyDocPart
def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
.. @+node:ekr.20090502071837.79: *8* isAnySpecialDocPart
def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
.. @+node:ekr.20090502071837.78: *8* isSpecialDocPart
def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) > 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    # g.trace('kind %s, result %s, s %s' % (
        # repr(kind),result,repr(s)))

    return result
.. @+node:ekr.20090502071837.80: *8* removeLeoDirectives
def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,1,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
.. @+node:ekr.20090502071837.82: *8* replaceCodeBlockDirectives
def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
.. @+node:ekr.20090502071837.70: *8* skip_literal_block
def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n < len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 <= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
.. @+node:ekr.20090502071837.71: *8* writeBody & helpers
def writeBody (self,p):

    trace = False and not g.unitTesting
   
    if self.getOption('ignore_noweb_definitions'):
        # 2011/06/10: Ignore section definition nodes.
        name = self.isSectionDef(p)
        if name:
            if trace: g.trace('section def: %s' % (repr(name)))
            return

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        # Important: code mode is no longer documented!
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('expand_noweb_references'):
            # 2011/06/10.
            lines = self.expandSectionRefs(lines,p,seen=[])
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
.. @+node:ekr.20110610144305.6749: *9* isSectionDef/Ref
def isSectionDef (self,p):
    
    return self.isSectionRef(p.h)
    
def isSectionRef (self,s):

    n1 = s.find("<<",0)
    n2 = s.find(">>",0)
    return -1 < n1 < n2 and s[n1+2:n2].strip()
.. @+node:ekr.20110610144305.6750: *9* expandSectionRefs
def expandSectionRefs (self,lines,p,seen):
    
    trace = False and not g.unitTesting
    
    if trace: g.trace(p.h,g.callers())

    result = []
    for s in lines:
        name = self.isSectionRef(s)
        if name:
            p2 = self.findSectionDef(name,p)
            if p2:
                g.trace('expanding: %s from %s' % (name,p2.h))
                result.append(s) # Append the section reference line.
                lines2 = g.splitLines(p2.b)
                if self.getOption('expand_noweb_recursively'):
                    if name in seen:
                        pass # Prevent unbounded recursion
                    else:
                        seen.append(name)
                        result.extend(self.expandSectionRefs(lines2,p,seen))
                else:
                    result.extend(lines2)
            else:
                # Undefined reference.
                result.append(s)
        else:
            result.append(s)

    return result
.. @+node:ekr.20110610144305.6751: *9* findSectionDef
def findSectionDef (self,name,p):
    
    for p2 in p.subtree():
        name2 = self.isSectionDef(p2)
        if name2:
            return p2
    
    return None
.. @+node:ekr.20090502071837.72: *9* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    trace = False and not g.unitTesting
    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        else:
            if not code: # Start the code block.
                result.append('')
                result.append(self.code_block_string)

            if trace: g.trace('code line: %s' % repr(s))
            code.append(s)
       
        # elif not code: # Start the code block.
            # result.append('')
            # result.append(self.code_block_string)
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)
        # else: # Continue the code block.
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        # 2010/08/27: Fix bug 618482.
        # elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
.. @+node:ekr.20090502071837.73: *10* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
.. @+node:ekr.20090502071837.74: *10* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    # 2010/08/27: fix bug 618482.
    s = ''.join(theList).rstrip()
    return s.split('\n')
.. @+node:ekr.20090502071837.75: *10* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
.. @+node:ekr.20090502071837.76: *9* handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
.. @+node:ekr.20090502071837.83: *8* writeHeadline & helper
def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    ignoreNowebDefs     = self.getOption('ignore_noweb_definitions')
    showHeadlines       = self.getOption('show_headlines')
    showOrganizers      = self.getOption('show_organizer_nodes')
    showThisHeadline    = self.getOption('show_this_headline')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers or
        ignoreNowebDefs and self.isSectionDef(p) # 2011/06/10.
    ):
        return

    self.writeHeadlineHelper(p)
.. @+node:ekr.20090502071837.84: *9* writeHeadlineHelper
def writeHeadlineHelper (self,p):

    h = p.h
    if not self.atAutoWrite:
        h = h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for these...
        if word in (
            '@rst-option','@rst-options',
            '@rst-no-head','@rst-no-headlines'
        ):
            return

        # Remove all other headline commands from the headline.
        for command in self.headlineCommands:
            if word == command:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write(self.underline(h,p)) # Used by @auto-rst.
        else:
            self.write('\n%s\n\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
.. @+node:ekr.20090502071837.85: *8* writeNode (leoRst)
def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
.. @+node:ekr.20090502071837.86: *8* writePreformat
def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''

    # g.trace(p.h,g.callers())

    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')

    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
.. @+node:ekr.20090502071837.87: *8* writeTree
def writeTree(self,p,fn):

    '''Write p's tree to self.outputFile.'''

    self.scanAllOptions(p)

    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % fn))

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p) # Side effect: advances p.
.. @+node:ekr.20090502071837.67: *6* writeNodeToString
def writeNodeToString (self,p=None,ext=None):

    '''Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period: .html, .tex or None (specifies rst output).

    Returns (p, s), where p is the position of the @rst node and s is the converted text.'''

    c = self.c ; current = p or c.p

    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    else:
        return self.processTree(current,ext=ext,toString=True,justOneFile=True)
.. @+node:ekr.20090512153903.5803: *6* writeAtAutoFile
def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
.. @+node:ekr.20090513073632.5733: *7* initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.nodeOptionDict = {}
    self.scanAllOptions(p)
    self.init_write(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) > 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    # Bug fix:  2010/05/26: pad underlines with default characters.
    default_underlines = '=+*^~"\'`-:><_'
    if underlines1:
        for ch in default_underlines[1:]:
            if ch not in underlines1:
                underlines1 = underlines1 + ch
    else:
        underlines1 = default_underlines
    self.atAutoWriteUnderlines   = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
.. @+node:ekr.20091228080620.6499: *7* isSafeWrite
def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite or not p.isAtAutoRstNode():
        return True # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
.. @+node:ekr.20090502071837.41: *5* Options
.. @+node:ekr.20090502071837.42: *6* createDefaultOptionsDict
def createDefaultOptionsDict(self):

    # Important: these must be munged names.
    self.defaultOptionsDict = {
        # Http options...
        'clear_http_attributes':   False,
        'http_server_support':     False,
        'http_attributename':      'rst_http_attribute',
        'node_begin_marker':       'http-node-marker-',
        # Path options...
        'default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'stylesheet_name': 'default.css',
        'stylesheet_path': None, # Bug fix: must be None, not ''.
        'stylesheet_embed': True,
        'publish_argv_for_missing_stylesheets': None,
        # Global options...
        'call_docutils': True, # 2010/08/05
        'code_block_string': '',
        'number_code_lines': True,
        'underline_characters': '''#=+*^~"'`-:><_''',
        'verbose':True,
        'write_intermediate_file': False, # Used only if generate_rst is True.
        'write_intermediate_extension': '.txt',
        # Mode options...
        'code_mode': False, # True: generate rst markup from @code and @doc parts.
        'doc_only_mode': False, # True: generate only from @doc parts.
        'generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'expand_noweb_references': False,
        'ignore_noweb_definitions': False,
        'expand_noweb_recursively': True,
        'show_headlines': True,  # Can be set by @rst-no-head headlines.
        'show_organizer_nodes': True,
        'show_options_nodes': False,
        'show_sections': True,
        'strip_at_file_prefixes': True,
        'show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'show_doc_parts_as_paragraphs': False,
        'show_leo_directives': True,
        'show_markup_doc_parts': False,
        'show_options_doc_parts': False,
    }
.. @+node:ekr.20090502071837.43: *6* dumpSettings (debugging)
def dumpSettings (self):

    d = self.optionsDict
    keys = sorted(d)

    g.pr('present settings...')
    for key in keys:
        g.pr('%20s %s' % (key,d.get(key)))
.. @+node:ekr.20090502071837.44: *6* getOption & setOption
def getOption (self,name):

    # 2010/08/12: munging names here is safe because setOption munges.
    # g.trace(name,self.optionsDict.get(self.munge(name)))
    return self.optionsDict.get(self.munge(name))

def setOption (self,name,val,tag=None):

    self.optionsDict [self.munge(name)] = val
.. @+node:ekr.20090502071837.45: *6* initCodeBlockString
def initCodeBlockString(self,p):

    trace = False and not g.unitTesting
    c = self.c
    # if trace: os.system('cls')
    d = c.scanAllDirectives(p)
    language = d.get('language')
    if language is None: language = 'python'
    else: language = language.lower()
    syntax = SilverCity is not None

    if trace: g.trace('language',language,'language.title()',language.title(),p.h)

    # Note: lines that end with '\n\n' are a signal to handleCodeMode.
    s = self.getOption('code_block_string')
    if s:
        self.code_block_string = s.replace('\\n','\n')
    elif syntax and language in ('python','ruby','perl','c'):
        self.code_block_string = '**code**:\n\n.. code-block:: %s\n\n' % (
            language.title())
    else:
        self.code_block_string = '**code**:\n\n.. class:: code\n..\n\n::\n\n'
.. @+node:ekr.20090502071837.46: *6* preprocessTree & helpers
def preprocessTree (self,root):

    self.nodeOptionDict = {}

    # Bug fix 12/4/05: must preprocess parents too.
    for p in root.parents():
        self.preprocessNode(p)

    for p in root.self_and_subtree():
        self.preprocessNode(p)

    if 0:
        g.trace(root.h)
        for key in self.nodeOptionDict.keys():
            g.trace(key)
            g.printDict(self.nodeOptionDict.get(key))
.. @+node:ekr.20090502071837.47: *7* preprocessNode
def preprocessNode (self,p):

    d = self.nodeOptionDict.get(p.v)
    if d is None:
        d = self.scanNodeForOptions(p)
        self.nodeOptionDict [p.v] = d
.. @+node:ekr.20090502071837.48: *7* parseOptionLine
def parseOptionLine (self,s):

    '''Parse a line containing name=val and return (name,value) or None.

    If no value is found, default to True.'''

    s = s.strip()
    if s.endswith(','): s = s[:-1]
    # Get name.  Names may contain '-' and '_'.
    i = g.skip_id(s,0,chars='-_')
    name = s [:i]
    if not name: return None
    j = g.skip_ws(s,i)
    if g.match(s,j,'='):
        val = s [j+1:].strip()
        # g.trace(val)
        return name,val
    else:
        # g.trace('*True')
        return name,'True'
.. @+node:ekr.20090502071837.49: *7* scanForOptionDocParts
def scanForOptionDocParts (self,p,s):

    '''Return a dictionary containing all options from @rst-options doc parts in p.
    Multiple @rst-options doc parts are allowed: this code aggregates all options.
    '''

    d = {} ; n = 0 ; lines = g.splitLines(s)
    while n < len(lines):
        line = lines[n] ; n += 1
        if line.startswith('@'):
            i = g.skip_ws(line,1)
            for kind in ('@rst-options','@rst-option'):
                if g.match_word(line,i,kind):
                    # Allow options on the same line.
                    line = line[i+len(kind):]
                    d.update(self.scanOption(p,line))
                    # Add options until the end of the doc part.
                    while n < len(lines):
                        line = lines[n] ; n += 1 ; found = False
                        for stop in ('@c','@code', '@'):
                            if g.match_word(line,0,stop):
                                found = True ; break
                        if found:
                            break
                        else:
                            d.update(self.scanOption(p,line))
                    break
    return d
.. @+node:ekr.20090502071837.50: *7* scanHeadlineForOptions
def scanHeadlineForOptions (self,p):

    '''Return a dictionary containing the options implied by p's headline.'''

    h = p.h.strip()

    if p == self.topNode:
        return {} # Don't mess with the root node.
    elif g.match_word(h,0,'@rst-option'):
        s = h [len('@rst-option'):]
        return self.scanOption(p,s)
    elif g.match_word(h,0,'@rst-options'):
        return self.scanOptions(p,p.b)
    else:
        # Careful: can't use g.match_word because options may have '-' chars.
        i = g.skip_id(h,0,chars='@-')
        word = h[0:i]

        for option,ivar,val in (
            ('@rst',                'code_mode',False),
            ('@rst-code',           'code_mode',True),
            ('@rst-default-path',   'default_prefix',''),
            ('@rst-doc-only',       'doc_only_mode',True),
            ('@rst-head',           'show_this_headline',True),
            # ('@rst-head' ,        'show_headlines',False),
            ('@rst-ignore',         'ignore_this_tree',True),
            ('@rst-ignore-node',    'ignore_this_node',True),
            ('@rst-ignore-tree',    'ignore_this_tree',True),
            ('@rst-no-head',        'ignore_this_headline',True),
            ('@rst-preformat',      'preformat_this_node',True),
        ):
            if word == option:
                d = { ivar: val }
                # Special case: code mode and doc-only modes are linked.
                if ivar == 'code_mode':
                    d ['doc_only_mode'] = False
                elif ivar == 'doc_only_mode':
                    d ['code_mode'] = False
                # Special case: Treat a bare @rst like @rst-no-head
                if h == '@rst':
                    d ['ignore_this_headline'] = True
                # g.trace(repr(h),d)
                return d

        if h.startswith('@rst'):
            g.trace('unknown kind of @rst headline',p.h,g.callers(4))

        return {}
.. @+node:ekr.20090502071837.51: *7* scanNodeForOptions
def scanNodeForOptions (self,p):

    '''Return a dictionary containing all the option-name:value entries in p.

    Such entries may arise from @rst-option or @rst-options in the headline,
    or from @ @rst-options doc parts.'''
    
    trace = False and not g.unitTesting

    h = p.h

    d = self.scanHeadlineForOptions(p)

    d2 = self.scanForOptionDocParts(p,p.b)

    # A fine point: body options over-ride headline options.
    d.update(d2)
    
    if trace and d:
        g.trace(h)
        for z in sorted(d):
            print('    %s: %s' % (z,d.get(z)))

    return d
.. @+node:ekr.20090502071837.52: *7* scanOption
def scanOption (self,p,s):

    '''Return { name:val } if s is a line of the form name=val.
    Otherwise return {}'''

    if not s.strip() or s.strip().startswith('..'): return {}

    data = self.parseOptionLine(s)

    if data:
        name,val = data
        if self.munge(name) in list(self.defaultOptionsDict.keys()):
            if   val.lower() == 'true': val = True
            elif val.lower() == 'false': val = False
            # g.trace('%24s %8s %s' % (self.munge(name),val,p.h))
            return { self.munge(name): val }
        else:
            g.es_print('ignoring unknown option: %s' % (name),color='red')
            return {}
    else:
        g.trace(repr(s))
        s2 = 'bad rst3 option in %s: %s' % (p.h,s)
        g.es_print(s2,color='red')
        return {}
.. @+node:ekr.20090502071837.53: *7* scanOptions
def scanOptions (self,p,s):

    '''Return a dictionary containing all the options in s.'''

    d = {}

    for line in g.splitLines(s):
        d2 = self.scanOption(p,line)
        if d2: d.update(d2)

    return d
.. @+node:ekr.20090502071837.54: *6* scanAllOptions & helpers
# Once an option is seen, no other related options in ancestor nodes have any effect.

def scanAllOptions(self,p):

    '''Scan position p and p's ancestors looking for options,
    setting corresponding ivars.
    '''

    self.initOptionsFromSettings() # Must be done on every node.
    self.handleSingleNodeOptions(p)
    seen = self.singleNodeOptions[:] # Suppress inheritance of single-node options.

    # g.trace('-'*20)
    for p in p.self_and_parents():
        d = self.nodeOptionDict.get(p.v,{})
        # g.trace(p.h,d)
        for key in d.keys():
            ivar = self.munge(key)
            if not ivar in seen:
                seen.append(ivar)
                val = d.get(key)
                self.setOption(key,val,p.h)

    if self.rst3_all:
        self.setOption("generate_rst", True, "rst3_all")
        self.setOption("generate_rst_header_comment",True, "rst3_all")
        self.setOption("http_server_support", True, "rst3_all")
        self.setOption("write_intermediate_file", True, "rst3_all")
.. @+node:ekr.20090502071837.55: *7* initOptionsFromSettings
def initOptionsFromSettings (self):

    c = self.c

    d = self.defaultOptionsDict
    keys = sorted(d)

    for key in keys:
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break

    # 2010/08/12: Script settings override everything else.
    d2 = self.scriptSettingsDict or {}
    for key in d2.keys():
        val = d2.get(key)
        # g.trace(key,val)
        self.setOption(key,val,'initOptionsFromSettings')

    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.es('No http_server_support: can not import mod_http plugin',color='red')
        self.setOption('http_server_support',False)
.. @+node:ekr.20090502071837.56: *7* handleSingleNodeOptions
def handleSingleNodeOptions (self,p):

    '''Init the settings of single-node options from the tnodeOptionsDict.

    All such options default to False.'''

    d = self.nodeOptionDict.get(p.v, {} )

    for ivar in self.singleNodeOptions:
        val = d.get(ivar,False)
        #g.trace('%24s %8s %s' % (ivar,val,p.h))
        self.setOption(ivar,val,p.h)

.. @+node:ekr.20090502071837.42: *5* createDefaultOptionsDict
def createDefaultOptionsDict(self):

    # Important: these must be munged names.
    self.defaultOptionsDict = {
        # Http options...
        'clear_http_attributes':   False,
        'http_server_support':     False,
        'http_attributename':      'rst_http_attribute',
        'node_begin_marker':       'http-node-marker-',
        # Path options...
        'default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'stylesheet_name': 'default.css',
        'stylesheet_path': None, # Bug fix: must be None, not ''.
        'stylesheet_embed': True,
        'publish_argv_for_missing_stylesheets': None,
        # Global options...
        'call_docutils': True, # 2010/08/05
        'code_block_string': '',
        'number_code_lines': True,
        'underline_characters': '''#=+*^~"'`-:><_''',
        'verbose':True,
        'write_intermediate_file': False, # Used only if generate_rst is True.
        'write_intermediate_extension': '.txt',
        # Mode options...
        'code_mode': False, # True: generate rst markup from @code and @doc parts.
        'doc_only_mode': False, # True: generate only from @doc parts.
        'generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'expand_noweb_references': False,
        'ignore_noweb_definitions': False,
        'expand_noweb_recursively': True,
        'show_headlines': True,  # Can be set by @rst-no-head headlines.
        'show_organizer_nodes': True,
        'show_options_nodes': False,
        'show_sections': True,
        'strip_at_file_prefixes': True,
        'show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'show_doc_parts_as_paragraphs': False,
        'show_leo_directives': True,
        'show_markup_doc_parts': False,
        'show_options_doc_parts': False,
    }
.. @+node:ekr.20090502071837.71: *5* writeBody & helpers
def writeBody (self,p):

    trace = False and not g.unitTesting
   
    if self.getOption('ignore_noweb_definitions'):
        # 2011/06/10: Ignore section definition nodes.
        name = self.isSectionDef(p)
        if name:
            if trace: g.trace('section def: %s' % (repr(name)))
            return

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        # Important: code mode is no longer documented!
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('expand_noweb_references'):
            # 2011/06/10.
            lines = self.expandSectionRefs(lines,p,seen=[])
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
.. @+node:ekr.20110610144305.6749: *6* isSectionDef/Ref
def isSectionDef (self,p):
    
    return self.isSectionRef(p.h)
    
def isSectionRef (self,s):

    n1 = s.find("<<",0)
    n2 = s.find(">>",0)
    return -1 < n1 < n2 and s[n1+2:n2].strip()
.. @+node:ekr.20110610144305.6750: *6* expandSectionRefs
def expandSectionRefs (self,lines,p,seen):
    
    trace = False and not g.unitTesting
    
    if trace: g.trace(p.h,g.callers())

    result = []
    for s in lines:
        name = self.isSectionRef(s)
        if name:
            p2 = self.findSectionDef(name,p)
            if p2:
                g.trace('expanding: %s from %s' % (name,p2.h))
                result.append(s) # Append the section reference line.
                lines2 = g.splitLines(p2.b)
                if self.getOption('expand_noweb_recursively'):
                    if name in seen:
                        pass # Prevent unbounded recursion
                    else:
                        seen.append(name)
                        result.extend(self.expandSectionRefs(lines2,p,seen))
                else:
                    result.extend(lines2)
            else:
                # Undefined reference.
                result.append(s)
        else:
            result.append(s)

    return result
.. @+node:ekr.20110610144305.6751: *6* findSectionDef
def findSectionDef (self,name,p):
    
    for p2 in p.subtree():
        name2 = self.isSectionDef(p2)
        if name2:
            return p2
    
    return None
.. @+node:ekr.20090502071837.72: *6* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    trace = False and not g.unitTesting
    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        else:
            if not code: # Start the code block.
                result.append('')
                result.append(self.code_block_string)

            if trace: g.trace('code line: %s' % repr(s))
            code.append(s)
       
        # elif not code: # Start the code block.
            # result.append('')
            # result.append(self.code_block_string)
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)
        # else: # Continue the code block.
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        # 2010/08/27: Fix bug 618482.
        # elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
.. @+node:ekr.20090502071837.73: *7* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
.. @+node:ekr.20090502071837.74: *7* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    # 2010/08/27: fix bug 618482.
    s = ''.join(theList).rstrip()
    return s.split('\n')
.. @+node:ekr.20090502071837.75: *7* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
.. @+node:ekr.20090502071837.76: *6* handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
.. @+node:ekr.20111017132257.15891: *3* Get IPython working again
.. @+node:ekr.20111017132257.15890: *4* Investigate how IPython hijacks event loops
http://groups.google.com/group/leo-editor/browse_thread/thread/e1dc6439bf8b17f9
.. @+node:ekr.20111009162434.7204: *4* Port ipy_leo.py to latest version of IPython
.. @+node:ekr.20111128103520.10245: *3* Finish leoInspect
create o.token_range gette
.. @+node:ekr.20111128103520.10257: *4* @test leoInspect.token_range (s)
import leo.core.leoInspect as inspect

# g.cls()

def show(o,indent=0):
    pad = ' '*4*indent
    # print('\n%s\n' % o.sd.dump_ast(o.tree()))
    print('%s%s' % (pad,o.format()))
    print('token range: %s' % (repr(o.token_range())))

<< define s >>
print('Input...\n%s\n' % (s.rstrip()))

m = inspect.module(s=s)

if 0:
    show(m,0)
    
if 1:
    print('\nAssignments to a...\n')
    for o in m.assignments_to('a'):
        # print(o.format())
        show(o)
if 0:
    print('\nAssignments using d...\n')
    for o in m.assignments_using('d'):
        # print(o.format())
        show(o)
if 0:    
    print('\nCalls to f...\n')
    for o in m.calls_to('f'):
        # print(o.format())
        show(o)
if 0:
    for s in m.statements():
        show(s)
    
    for f in m.functions():
        show(f,0)
        for z in f.statements():
            show(z,1)
    
    for cls in m.classes():
        show(cls,0)
        for d in cls.defs():
            show(d,1)
            for z in d.statements():
                show(z,1)
.. @+node:ekr.20111128103520.10258: *5* << define s >>
s = '''
# x.y = b(arg1,arg2=5,*args,**args).c[1:2:3].d
a=b+c
# f(a=1,b=2,*args,**keys)
'''


# def outer_function(a,b=99,c=88,*args,**keys):
    # print('hello')
    
# class myClass:
    # def method():
        # pass
    
.. @+node:ekr.20111129084537.10357: *4* Notes
@language rest

> All this means that it would likely be too expensive (or just too
> ugly) to compute the data needed for token_range in the base
> AstTraverser class.  Such computations will be performed by traversing
> the module's entire AST the first time "token_range" is called.

There are two parts to the problem.  Happily, neither requires a
separate tree-traversal class.

A token-info prepass
================

For each node N of a module's tree, we want to inject the following
two new ivars:

- N.end_lineno: the line number of the last character of the token.
- N.end_col_offset: the (byte) offset of the last character of the
token.

After experimenting with a few traversals last night I suddenly
realized tree structure is irrelevant when computing these fields: we
simply want a **sorted** list of (N.lineno,No.col_offset, N) tuples!

The prepass will use ast.walk(root), to generate the list.  After
sorting the list, the prepass will inject inject N.end_lineno and
N.end_col_offset ivars into each node N by stepping through the list.
The ending values of the previous node on the list are the the same as
the beginning values of the next node on the list.

This prepass need only be done once per module.

token_range
===========

To compute token_range for a *particular* N, we want to discover
values M.end_lineno and M.end_col_offset for M, the **last** token in
N's entire tree.

token_range will do the prepass on the modules tree if necessary.
token_range will then call ast.walk(N) to discover all of N's nodes,
sort the list, and return the last element of the list!

In short, token_range is clean and bullet-proof--a happy result.
.. @+node:ekr.20111116103733.10402: *4* << define class Context >>
class Context(object):

    '''The base class of all context-related semantic data.

    All types ultimately resolve to a context.'''

    def __repr__ (self):
        return 'Context: %s' % (self.context_kind)

    __str__ = __repr__

    @others
.. @+node:ekr.20111116103733.10403: *5* cx ctor
def __init__(self,tree,parent_context,sd,kind):

    self.is_temp_context = kind in ['comprehension','for','lambda','with']
    self.context_kind = kind
    # assert kind in ('class','comprehension','def','for','lambda','module','with'),kind
    self.formatter = sd.formatter
    self.parent_context = parent_context
    self.sd = sd
    self.st = SymbolTable(context=self)

    sd.n_contexts += 1

    # Public semantic data: accessed via getters.
    self._classes = [] # Classes defined in this context.
    self._defs = [] # Functions defined in this context.
    self._statements = [] # List of all statements in the context.
    self._tree = tree
    
    # Private semantic data: no getters.
    self.global_names = set() # Names that appear in a global statement in this context.
    self.temp_contexts = [] # List of inner 'comprehension','for','lambda','with' contexts.
    
    # Record the name.ctx contexts.
    self.del_names = set()      # Names with ctx == 'Del'
    self.load_names = set()     # Names with ctx == 'Load'
    self.param_names = set()    # Names with ctx == 'Param'
    self.store_names = set()    # Names with ctx == 'Store'
    
    # Data for the resolution algorithm.
    self.all_global_names = set() # Global names in all parent contexts.
    
    # Compute the class context.
    if self.context_kind == 'module':
        self.class_context = None
    elif self.context_kind == 'class':
        self.class_context = self
    else:
        self.class_context = parent_context.class_context
        
    # Compute the defining context.
    if self.is_temp_context:
        self.defining_context = parent_context.defining_context
    else:
        self.defining_context = self
    
    # Compute the module context.
    if self.context_kind == 'module':
        self.module_context = self
    else:
        self.module_context = parent_context.module_context
.. @+node:ekr.20111116103733.10404: *5* cx.ast_kind
def ast_kind (self,tree):

    return tree.__class__.__name__
.. @+node:ekr.20111116103733.10405: *5* cx.description & name
def description (self):
    
    '''Return a description of this context and all parent contexts.'''
    
    if self.parent_context:
        return  '%s:%s' % (
            self.parent_context.description(),repr(self))
    else:
        return repr(self)

# All subclasses override name.
name = description
.. @+node:ekr.20111116103733.10407: *5* cx.dump
def dump (self,level=0,verbose=False):

    if 0: # Just print the context
        print(repr(self))
    else:
        self.st.dump(level=level)

    if verbose:
        for z in self._classes:
            z.dump(level+1)
        for z in self._defs:
            z.dump(level+1)
        for z in self.temp_contexts:
            z.dump(level+1)
.. @+node:ekr.20111117031039.10099: *5* cx.format
def format(self,brief=True):
    
    cx = self
    
    # return cx.sd.dumper.dumpTreeAsString(cx._tree,brief=brief,outStream=None)
    
    # return ast.dump(cx._tree,annotate_fields=True,include_attributes=not brief)
    
    return AstFormatter().format(cx._tree)
.. @+node:ekr.20111116161118.10113: *5* cx.getters & setters
.. @+node:ekr.20111116161118.10114: *6* cx.assignments & helper
def assignments (self,all=True):
    
    if all:
        return self.all_assignments(result=None)
    else:
        return self.filter_assignments(self._statements)

def all_assignments(self,result):

    if result is None:
        result = []
    result.extend(self.filter_assignments(self._statements))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_assignments(result)
    return result
    
def filter_assignments(self,aList):
    '''Return all the assignments in aList.'''
    return [z for z in aList
        if z.context_kind in ('assn','aug-assn')]
.. @+node:ekr.20111116161118.10115: *6* cx.assignments_to
def assignments_to (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for assn in self.assignments(all=all):
        tree = assn.tree()
        kind = self.ast_kind(tree)
        if kind == 'Assign':
            for target in tree.targets:
                lhs = format(target)
                if s == lhs:
                    result.append(assn)
                    break
        else:
            assert kind == 'AugAssign',kind
            lhs = format(tree.target)
            if s == lhs:
                result.append(assn)

    return result
.. @+node:ekr.20111116161118.10116: *6* cx.assignments_using
def assignments_using (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for assn in self.assignments(all=all):
        tree = assn.tree()
        kind = self.ast_kind(tree)
        assert kind in ('Assign','AugAssign'),kind
        rhs = format(tree.value)
        i = rhs.find(s,0)
        while -1 < i < len(rhs):
            if g.match_word(rhs,i,s):
                result.append(assn)
                break
            else:
                i += len(s)

    return result
.. @+node:ekr.20111126074312.10386: *6* cx.calls & helpers
def calls (self,all=True):
    
    if all:
        return self.all_calls(result=None)
    else:
        return self.filter_calls(self._statements)

def all_calls(self,result):

    if result is None:
        result = []
    result.extend(self.filter_calls(self._statements))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_calls(result)
    return result
    
def filter_calls(self,aList):
    '''Return all the calls in aList.'''
    return [z for z in aList
        if z.context_kind == 'call']
.. @+node:ekr.20111126074312.10384: *6* cx.call_to
def calls_to (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for call in self.calls(all=all):
        tree = call.tree()
        func = format(tree.func)
        if s == func:
            result.append(call)

    return result
.. @+node:ekr.20111126074312.10400: *6* cx.call_args_of
def call_args_of (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for call in self.calls(all=all):
        tree = call.tree()
        func = format(tree.func)
        if s == func:
            result.append(call)

    return result
.. @+node:ekr.20111116161118.10163: *6* cx.classes
def classes (self,all=True):
    
    if all:
        return self.all_classes(result=None)
    else:
        return self._classes

def all_classes(self,result):

    if result is None:
        result = []
    result.extend(self._classes)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_classes(result)
    return result
.. @+node:ekr.20111116161118.10164: *6* cx.defs
def defs (self,all=True):
    
    if all:
        return self.all_defs(result=None)
    else:
        return self._defs

def all_defs(self,result):

    if result is None:
        result = []
    result.extend(self._defs)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_defs(result)
    return result
.. @+node:ekr.20111116161118.10152: *6* cx.functions & helpers
def functions (self,all=True):
    
    if all:
        return self.all_functions(result=None)
    else:
        return self.filter_functions(self._defs)

def all_functions(self,result):

    if result is None:
        result = []
    result.extend(self.filter_functions(self._defs))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_functions(result)
    return result
.. @+node:ekr.20111116161118.10223: *7* cx.filter_functions & is_function
def filter_functions(self,aList):
    return [z for z in aList if self.is_function(z)]

def is_function(self,f):
    '''Return True if f is a function, not a method.'''
    return True
.. @+node:ekr.20111126074312.10449: *6* cx.line_number
def line_number (self):
    
    return self._tree.lineno
.. @+node:ekr.20111116161118.10153: *6* cx.methods & helpers
def methods (self,all=True):
    
    if all:
        return self.all_methods(result=None)
    else:
        return self.filter_methods(self._defs)

def all_methods(self,result):

    if result is None:
        result = []
    result.extend(self.filter_methods(self._defs))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_methods(result)
    return result
.. @+node:ekr.20111116161118.10225: *7* cx.filter_functions & is_function
def filter_methods(self,aList):
    return [z for z in aList if self.is_method(z)]

def is_method(self,f):
    '''Return True if f is a method, not a function.'''
    return True
.. @+node:ekr.20111116161118.10165: *6* cx.statements
def statements (self,all=True):
    
    if all:
        return self.all_statements(result=None)
    else:
        return self._statements

def all_statements(self,result):

    if result is None:
        result = []
    result.extend(self._statements)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_statements(result)
    return result
.. @+node:ekr.20111128103520.10259: *6* cx.token_range
def token_range (self):
    
    tree = self._tree
    
    # return (
        # g.toUnicode(self.byte_array[:tree.col_offset]),
        # g.toUnicode(self.byte_array[:tree_end_col_offset]),
    # )
    
    if hasattr(tree,'col_offset') and hasattr(tree,'end_col_offset'):
        return tree.lineno,tree.col_offset,tree.end_lineno,tree.end_col_offset
    else:
        return -1,-1
.. @+node:ekr.20111116161118.10166: *6* cx.tree
def tree(self):
    
    '''Return the AST (Abstract Syntax Tree) associated with this query object
    (Context Class).  This tree can be passed to the format method for printing.
    '''
    
    return self._tree
.. @+node:ekr.20111116161118.10113: *4* cx.getters & setters
.. @+node:ekr.20111116161118.10114: *5* cx.assignments & helper
def assignments (self,all=True):
    
    if all:
        return self.all_assignments(result=None)
    else:
        return self.filter_assignments(self._statements)

def all_assignments(self,result):

    if result is None:
        result = []
    result.extend(self.filter_assignments(self._statements))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_assignments(result)
    return result
    
def filter_assignments(self,aList):
    '''Return all the assignments in aList.'''
    return [z for z in aList
        if z.context_kind in ('assn','aug-assn')]
.. @+node:ekr.20111116161118.10115: *5* cx.assignments_to
def assignments_to (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for assn in self.assignments(all=all):
        tree = assn.tree()
        kind = self.ast_kind(tree)
        if kind == 'Assign':
            for target in tree.targets:
                lhs = format(target)
                if s == lhs:
                    result.append(assn)
                    break
        else:
            assert kind == 'AugAssign',kind
            lhs = format(tree.target)
            if s == lhs:
                result.append(assn)

    return result
.. @+node:ekr.20111116161118.10116: *5* cx.assignments_using
def assignments_using (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for assn in self.assignments(all=all):
        tree = assn.tree()
        kind = self.ast_kind(tree)
        assert kind in ('Assign','AugAssign'),kind
        rhs = format(tree.value)
        i = rhs.find(s,0)
        while -1 < i < len(rhs):
            if g.match_word(rhs,i,s):
                result.append(assn)
                break
            else:
                i += len(s)

    return result
.. @+node:ekr.20111126074312.10386: *5* cx.calls & helpers
def calls (self,all=True):
    
    if all:
        return self.all_calls(result=None)
    else:
        return self.filter_calls(self._statements)

def all_calls(self,result):

    if result is None:
        result = []
    result.extend(self.filter_calls(self._statements))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_calls(result)
    return result
    
def filter_calls(self,aList):
    '''Return all the calls in aList.'''
    return [z for z in aList
        if z.context_kind == 'call']
.. @+node:ekr.20111126074312.10384: *5* cx.call_to
def calls_to (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for call in self.calls(all=all):
        tree = call.tree()
        func = format(tree.func)
        if s == func:
            result.append(call)

    return result
.. @+node:ekr.20111126074312.10400: *5* cx.call_args_of
def call_args_of (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for call in self.calls(all=all):
        tree = call.tree()
        func = format(tree.func)
        if s == func:
            result.append(call)

    return result
.. @+node:ekr.20111116161118.10163: *5* cx.classes
def classes (self,all=True):
    
    if all:
        return self.all_classes(result=None)
    else:
        return self._classes

def all_classes(self,result):

    if result is None:
        result = []
    result.extend(self._classes)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_classes(result)
    return result
.. @+node:ekr.20111116161118.10164: *5* cx.defs
def defs (self,all=True):
    
    if all:
        return self.all_defs(result=None)
    else:
        return self._defs

def all_defs(self,result):

    if result is None:
        result = []
    result.extend(self._defs)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_defs(result)
    return result
.. @+node:ekr.20111116161118.10152: *5* cx.functions & helpers
def functions (self,all=True):
    
    if all:
        return self.all_functions(result=None)
    else:
        return self.filter_functions(self._defs)

def all_functions(self,result):

    if result is None:
        result = []
    result.extend(self.filter_functions(self._defs))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_functions(result)
    return result
.. @+node:ekr.20111116161118.10223: *6* cx.filter_functions & is_function
def filter_functions(self,aList):
    return [z for z in aList if self.is_function(z)]

def is_function(self,f):
    '''Return True if f is a function, not a method.'''
    return True
.. @+node:ekr.20111126074312.10449: *5* cx.line_number
def line_number (self):
    
    return self._tree.lineno
.. @+node:ekr.20111116161118.10153: *5* cx.methods & helpers
def methods (self,all=True):
    
    if all:
        return self.all_methods(result=None)
    else:
        return self.filter_methods(self._defs)

def all_methods(self,result):

    if result is None:
        result = []
    result.extend(self.filter_methods(self._defs))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_methods(result)
    return result
.. @+node:ekr.20111116161118.10225: *6* cx.filter_functions & is_function
def filter_methods(self,aList):
    return [z for z in aList if self.is_method(z)]

def is_method(self,f):
    '''Return True if f is a method, not a function.'''
    return True
.. @+node:ekr.20111116161118.10165: *5* cx.statements
def statements (self,all=True):
    
    if all:
        return self.all_statements(result=None)
    else:
        return self._statements

def all_statements(self,result):

    if result is None:
        result = []
    result.extend(self._statements)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_statements(result)
    return result
.. @+node:ekr.20111128103520.10259: *5* cx.token_range
def token_range (self):
    
    tree = self._tree
    
    # return (
        # g.toUnicode(self.byte_array[:tree.col_offset]),
        # g.toUnicode(self.byte_array[:tree_end_col_offset]),
    # )
    
    if hasattr(tree,'col_offset') and hasattr(tree,'end_col_offset'):
        return tree.lineno,tree.col_offset,tree.end_lineno,tree.end_col_offset
    else:
        return -1,-1
.. @+node:ekr.20111116161118.10166: *5* cx.tree
def tree(self):
    
    '''Return the AST (Abstract Syntax Tree) associated with this query object
    (Context Class).  This tree can be passed to the format method for printing.
    '''
    
    return self._tree
.. @+node:ekr.20111128103520.10259: *4* cx.token_range
def token_range (self):
    
    tree = self._tree
    
    # return (
        # g.toUnicode(self.byte_array[:tree.col_offset]),
        # g.toUnicode(self.byte_array[:tree_end_col_offset]),
    # )
    
    if hasattr(tree,'col_offset') and hasattr(tree,'end_col_offset'):
        return tree.lineno,tree.col_offset,tree.end_lineno,tree.end_col_offset
    else:
        return -1,-1
.. @+node:ekr.20120226183512.10195: *3* Bugs
.. @+node:ekr.20120226183512.10197: *4* Numbered bugs
.. @+node:ekr.20111026091322.16504: *5* Bug 501636: Leo's import code should support non-ascii xml tags
https://bugs.launchpad.net/leo-editor/+bug/501636

@language rest

Leo's present @auto import code for xml files supports only ascii tags.

In particular, xmlScanner.isWordChar should allow non-ascii characters as specified in
www.w3.org/TR/2008/REC-xml-20081126/#NT-Name

@language python

NameStartChar ::= ":" | [A-Z] | "_" | [a-z] |
    [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
    [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] |
    [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

NameChar ::= NameStartChar | "-" | "." | [0-9] | #xB7 |
    [#x0300-#x036F] | [#x203F-#x2040]

The following script, presently in test.leo, may be useful:

import unicodedata as u
table = ('a','9','_',':','.',)
table2 = (
    (0xc0,0xd6),(0xd8,0xf6),(0xf8,0x2ff),(0x370,0x37d),(0x37f,0x1fff),
    (0x200c,0x200d),(0x2070,0x218f),(0x2c00,0x2fef),(0x3001,0xd7ff),
    (0xf900,0xfdcf),(0xfdf0,0xfffd),(0x10000,0xeffff),
    # Valid only after the start of a word.
    (0xb7,0xb7+1),(0x0300,0x036f),(0x203f,0x2040),
)
for ch in table:
    ch = g.u(ch)
    g.es(ch,u.category(ch))
for i,j in table2:
    g.es('*** range %xd %xd' % (i,j))
    for n in range(i,min(i+5,j)):
        if g.isPython3: ch = chr(n)
        else: ch = unichr(n)
        g.es(ch,u.category(ch))

@language rest

Clearly, however, the unicode category of these characters is not helpful.
Instead, a dictionary lookup would be appropriate.
.. @+node:ekr.20111222113610.10244: *5* Bug 613153: unable to describe root directory on thumb drive
@nocolor-node

A very complex bug

https://bugs.launchpad.net/leo-editor/+bug/613153
.. @+node:ekr.20111222113610.10245: *5* Bug 711158: Warn if same .leo file open in another Leo instance
https://bugs.launchpad.net/leo-editor/+bug/711158
.. @+node:ekr.20111026091322.16491: *5* Bug 805288: ctr - tab locks up in log pane
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/805288

if the log tab is active in the log pane ctrl-tab will toggle through the body,
tree and log panes. If any other tab is active the key combination will freeze
in the log pane.
.. @+node:ekr.20111026091322.16499: *5* Bug 824087: Alt+F4 is not the same as Alt+F, c
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/824087

The file menu has an entry with label "Close Alt+F4" with the "C" in "Close"
underlined indicating it is the shortcut.

Command print-bindings shows:
S Alt+F4 close-window

That is, the binding is set in leoSettings.leo

Left clicking this "File - Close" menu entry (or Alt+F, c) is NOT the same as Alt+F4.

Left clicking this "File - Close" menu entry (or Alt+F, c) closes the current tab only.

Alt+F4 closes the Leo-Editor application window (and of course, closes all the tabs).

Is this a bug in the implementation or a bug in the documentation? Either way, the menu entry is misleading and the print-bindings information appears to be correct.
.. @+node:ekr.20111026091322.16498: *5* Bug 869098: Context menu settings lost if save as used
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/869098

I I have a Leo file with settings for context menu:
    
@settings
   @data contextmenu_commands
       edit-headline Edit headline
          copy-node Copy Node
          cut-node Cut Node
          paste-node Paste Node

then these settings are lost if I save the leo file to a new name using
File - Save as
If I reload the leo file, they do return
.. @+node:ekr.20111025141618.16484: *5* Bug 879338: Global tables in leoApp.py should describe all languages known to the colorizer
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/879338

Having the colorizer colorize a language properly gives the false illusion that Leo "understands" the language.

Supporting the language in the global tables in leoApp.py makes the illusion a reality.
.. @+node:ekr.20111122080923.10186: *5* Bug 893223: Unpredictable slow operation state cured by writing
@nocolor-node

Leo-editor unpredictably gets into a state where Ctrl-V fails to paste
and every Leo-editor operation takes much longer than usual.  This
resulted in the following red message in the log pane:

ignoring command: already executing a command.

This bad state was ended by writing the .leo file so it was no longer
dirty.  I've noticed this problem off and on for at least several weeks.

Test Conditions:

Leo-Editor Rev 4832
Leo Log Window
Leo 4.9.1 devel, build 4669, 4Q/2011
Python 2.7.2, qt version 4.7.3
linux2
setting leoID from os.getenv('USER'): 'bob'
load dir: /home/bob/bzrWork/pluginPath/leo/core
global config dir: /home/bob/bzrWork/pluginPath/leo/config
home dir: /home/bob
reading settings in /home/bob/bzrWork/pluginPath/leo/config/leoSettings.leo
reading settings in /home/bob/.leo/myLeoSettings.leo
reading settings in /media/sda1/BobH/1/Leo/Leo.leo
reading: /media/sda1/BobH/1/Leo/Leo.leo
reading: @auto /home/bob/.leo/.leoRecentFiles.txt

EKR =======================

There is a blunder in c.executeScript.  It jams False into c.inCommand
without saving and restoring the previous value.  This has to be
wrong.  I'm not sure that this is the entire fix.  I'll put it on the
urgent list.
.. @+node:ekr.20111122080923.10188: *6* Found: inCommand
.. @+node:ekr.20031218072017.2140: *7* c.executeScript & helpers
def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False,
    namespace=None):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        oldLog = g.app.log # 2011/01/19
        log = c.frame.log
        g.app.log = log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.p
                if p: c.setCurrentDirectoryFromContext(p)
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                d['script_args'] = args or []
                if namespace: d.update(namespace)
                # if args: sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                if c.write_script_file:
                    scriptFile = self.writeScriptFile(script)
                    
                    # 2011/10/31: make g.inScript a synonym for g.app.inScript.
                    g.inScript = g.app.inScript = True
                    try:
                        if g.isPython3:
                            exec(compile(script,scriptFile,'exec'),d)
                        else:
                            execfile(scriptFile,d)
                    finally:
                        g.inScript = g.app.inScript = False
                else:
                    g.app.inScript = True
                    try:
                        exec(script,d)
                    finally:
                        g.app.inScript = False
                if 0: # This message switches panes, and can be disruptive.
                    if not script1 and not silent:
                        # Careful: the script may have changed the log tab.
                        tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                        g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        g.app.log = oldLog # 2011/01/19
        self.unredirectScriptOutput()
.. @+node:ekr.20031218072017.2143: *8* redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
.. @+node:ekr.20110522121957.18230: *8* setCurrentDirectoryFromContext
def setCurrentDirectoryFromContext(self,p):
    
    trace = False and not g.unitTesting
    c = self
    
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    
    curDir = g.os_path_abspath(os.getcwd())

    # g.trace(p.h,'\npath  ',path,'\ncurDir',curDir)
    
    if path and path != curDir:
        if trace: g.trace('calling os.chdir(%s)' % (path))
        try:
            os.chdir(path)
        except Exception:
            pass
.. @+node:EKR.20040627100424: *8* unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
.. @+node:ekr.20031218072017.2817: *7*  c.doCommand
command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""

    c = self ; p = c.p
    commandName = command and command.__name__
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_doCommand'):
        g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return # (for Tk) 'break' # Inhibit all other handlers.

    if c.exists and c.inCommand and not g.unitTesting:
        # g.trace('inCommand',c)
        g.app.commandInterruptFlag = True
        g.es('ignoring command: already executing a command.',color='red')
        return # (for Tk) 'break'

    g.app.commandInterruptFlag = False

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            if c and c.exists: # Be careful: the command could destroy c.
                c.inCommand = False
                c.k.funcReturn = val
            # else: g.pr('c no longer exists',c)
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es_print("exception executing command")
                g.es_exception(c=c)

        if c and c.exists:
            if c.requestCloseWindow:
                g.trace('Closing window after command')
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2",c=c,p=p,v=p,label=label)

    return # (for Tk) "break" # Inhibit all other handlers.
.. @+node:ekr.20061031131434.160: *7* k.enterNamedMode
def enterNamedMode (self,event,commandName):

    k = self ; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event,modeName=modeName)
.. @+node:ekr.20110605121601.18140: *7* closeEvent (DynanicWindow)
def closeEvent (self,event):

    trace = False and not g.unitTesting
    c = self.leo_c

    if not c.exists:
        # Fixes double-prompt bug on Linux.
        if trace: g.trace('destroyed')
        event.accept()
        return

    if c.inCommand:
        if trace: g.trace('in command')
        c.requestCloseWindow = True
    else:
        if trace: g.trace('closing')
        ok = g.app.closeLeoWindow(c.frame)
        if ok:
            event.accept()
        else:
            event.ignore()
.. @+node:ekr.20110605121601.18286: *7* frame.OnCloseLeoEvent
# Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):

    f = self ; c = f.c

    if c.inCommand:
        # g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
.. @+node:ekr.20111123043847.9981: *6* Found: set_trace
.. @+node:ekr.20110310093050.14293: *7* pdb (codewise)
def pdb (message=''):

    """Fall into pdb."""

    import pdb # Required: we have just defined pdb as a function!

    if message:
        print(message)
    pdb.set_trace()
.. @+node:ekr.20041105091148: *7* g.pdb
def pdb (message=''):

    """Fall into pdb."""

    import pdb # Required: we have just defined pdb as a function!

    if message:
        print(message)
    pdb.set_trace()
.. @+node:ekr.20110605121601.18134: *7* init (qtGui.py top level)
def init():
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace and g.trace_startup: print('qtGui.__init__')

    if g.app.unitTesting: # Not Ok for unit testing!
        return False

    if not QtCore:
        return False

    if g.app.gui:
        return g.app.gui.guiName() == 'qt'
    else:
        g.app.gui = leoQtGui()

        # Override g.pdb
        def qtPdb(message=''):
            if message: print(message)
            import pdb
            if not g.app.useIpython:
                QtCore.pyqtRemoveInputHook()
            pdb.set_trace()
        g.pdb = qtPdb

        g.app.gui.finishCreate()
        g.plugin_signon(__name__)
        return True
.. @+node:ekr.20111125072438.10204: *5* Bug 882243: (Wishlist) Clones sometimes not saved: change how @others works
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/882243

In Leo, I made this file:

@file test.txt
@others
.....test1
     test: these are clones
.....test2
     @others

      what is going on...?
..........test1 <--- this is cloned
          test: these are clones

The output file does not have the cloned node:

#@+leo-ver=5-thin
#@+node:bill.20111025150533.3528: * @thin test.txt
#@+others
#@+node:bill.20111025150533.3527: ** test1
test: these are clones
#@+node:bill.20111025150533.3529: ** test2
#@+others
#@-others

what is going on...?
#@-others
#@-leo

I don't think it is a conflict with @others; it is just that some files do not retain the clones that are displayed.

Here is the copied node:

<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2"/>
<vnodes>
<v t="bill.20111025150533.3528" a="E"><vh>@thin test.txt</vh>
<v t="bill.20111025150533.3527"><vh>test1</vh></v>
<v t="bill.20111025150533.3529" a="E"><vh>test2</vh>
<v t="bill.20111025150533.3527"></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="bill.20111025150533.3527">test: these are clones
</t>
<t tx="bill.20111025150533.3528">@others
</t>
<t tx="bill.20111025150533.3529">@others

what is going on...?</t>
</tnodes>
</leo_file>

Here is the copied leo file:

<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
 <global_window_position top="50" left="50" height="500" width="700"/>
 <global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="bill.20111025150533.3528" a="E"
expanded="bill.20111025150533.3529,"><vh>@thin test.txt</vh></v>
</vnodes>
<tnodes>
</tnodes>
</leo_file>
.. @+node:ekr.20111216105907.10218: *6* My response: this is a wishlist item
@nocolor-node

Reposted from http://groups.google.com/group/leo-editor/browse_thread/thread/67a28984616d09c9
About bug 882243: clones sometimes not saved

I'd like to discuss this bug here, because I would like us all to be aware of the situation, and possible changes.

The surprise
=========

To paraphrase the original bug report, suppose we have the following @file tree:

+ @file test.txt
@others
  + node 1 (cloned)
    node 1 text.
  + node 2
     @others
    + node 1 (cloned)
       node 1 text.

As usual, lines preceded by "+" denote headlines: all other lines are body text.

The surprise is that the cloned node1 node is written to the external file only once (as a child of the root node) and hence does not appear as a (cloned) child of the node2 node when Leo next loads the @file tree.

History
=====

I would like to call this a wishlist item because the present code quite intentionally writes *any* node (including cloned nodes) only once. That is, the write code sets a bit when writing a node, and @others ignores any nodes with that bit set.

You could call this a bug in the @others write logic, but at one time it was done explicitly and on purpose.

I don't remember why this was so, but I do remember it *was* so. It may have been an artifact of Leo's old representation of clones that used both vnodes and tnodes. tnodes no longer exist in the one-node world that we have been living in for several years, and it may well be time to revisit the original design, but I would rather not do that just now because there are several "real" bugs that need attention asap.

Workaround
=========

Because this is an issue involving @others, you might assume that a workaround involving sections would be possible. You would be correct. The following file works as expected::

+ @file test.txt
<< node 1 >>
<< node 2 >>
  + << node 1>> (cloned)
     node 1 text.
  + << node 2 >>
     << node 1 >>
    + << node 1 >>(cloned)
       node 1 text.
.. @+node:ekr.20111026091322.16503: *4* Other Bugs
.. @+node:ekr.20111026091322.16495: *5* Fix bug: A nest of bugs involving log, focus, chapters, quickmove
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/820019
Shift-Ctrl-F (quicksearch) Sometimes leaves focus in body

https://bugs.launchpad.net/leo-editor/+bug/823267
when a tab is closed focus may go to a tab other than the visible one

https://bugs.launchpad.net/leo-editor/+bug/831658
@url doesn't leave Chapter

https://bugs.launchpad.net/leo-editor/+bug/844940
Different behavior when clicking on @url statement written either in headline or body of a node

https://bugs.launchpad.net/leo-editor/+bug/869385
Chapters make the nav_qt.py plugin useless.

https://bugs.launchpad.net/leo-editor/+bug/875323
Hoist an @chapter node leaves a non-visible node selected.

https://bugs.launchpad.net/leo-editor/+bug/875327
Positioning outside of hoisted outline" usually causes problems

https://bugs.launchpad.net/leo-editor/+bug/875463
Enabling quickmove.py sends to error messages to console on every outline open 
.. @+node:ekr.20111125072438.10214: *5* Fix bug: Another @shadow bug (test4.leo)
@nocolor-node

email:
http://mail.google.com/mail/#label/Leo%2FBugs/133ac31add8b2c6c

see attachment, shadow file won't get written correctly, and it won't reread
correctly too. Using leo-editor-snapshot- 201111090253.

Hopefully I will be able to look on some bugs myself, but don't know when. Needs
a bit of time, I am not very familiar with python.

===== EKR

Leo doesn't understand .jsp.  @shadow should refuse to work for unknown languages.
.. @+node:ekr.20031218072017.368: *6* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "javascript"    : "// /* */", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "<%-- --%>", # EKR: 2011/11/25
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "matlab"        : "%", # EKR: 2011/10/21
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "javascript"    : "js", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "jsp", # EKR: 2011/11/25
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "matlab"        : "m", # EKR: 2011/10/21
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "js"    : "javascript", # EKR: 2011/11/12: For javascript import test.
    "jsp"   : "javaserverpage", # EKR: 2011/11/25: For @shadow.
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "m"     : "matlab", # EKR 2011/10/21
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
.. @+node:ekr.20111123095018.13632: *5* Fix bug: expand Find tab as needed for bigger fonts
.. @+node:ekr.20110605121601.18326: *6* createTab (leoQtLog)
def createTab (self,tabName,widget=None,wrap='none'):
    """ Create a new tab in tab widget

    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """

    trace = False and not g.unitTesting
    c = self.c
    
    if trace: g.trace(tabName,widget and g.app.gui.widget_name(widget) or '<no widget>')

    if widget is None:

        widget = LeoQTextBrowser(parent=None,c=c,wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = leoQTextEditWidget(widget=widget,name='log',c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
            
        if trace: g.trace('** creating',tabName,'self.widget',contents,'wrapper',widget)
        
        widget.setWordWrapMode(
            g.choose(self.wrap,
                QtGui.QTextOption.WordWrap,
                QtGui.QTextOption.NoWrap))

        widget.setReadOnly(False) # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.widget = contents # widget is an alias for logCtrl.
            widget.setObjectName('log-widget')

        if True: # 2011/05/28.
            # Set binding on all text widgets.
            theFilter = leoQtEventFilter(c,w=self,tag='log')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
            
        if True and tabName == 'Log':
    
            assert c.frame.top.__class__.__name__ == 'DynamicWindow'
            find_widget = c.frame.top.leo_find_widget
            
            # 2011/11/21: A hack: add an event filter.
            find_widget.leo_event_filter = leoQtEventFilter(c,w=widget,tag='find-widget')
            find_widget.installEventFilter(find_widget.leo_event_filter)
            if trace: g.trace('** Adding event filter for Find',find_widget)
            
            # 2011/11/21: A hack: make the find_widget an official log widget.
            self.contentsDict['Find']=find_widget
    
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget,tabName)
    else:
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        widget.leo_log_wrapper = contents
            # The leo_log_wrapper is the widget itself.
        if trace: g.trace('** using',tabName,widget)
        
        if 1: # Now seems to work.
            theFilter = leoQtEventFilter(c,w=contents,tag='tabWidget')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
    
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents,tabName)

    return contents
.. @+node:ekr.20110605121601.18166: *6* createFindTab (DynamicWindow)
def createFindTab (self,parent,tab_widget):

    c,dw = self.leo_c,self
    grid = self.createGrid(parent,'findGrid',margin=10,spacing=10)
    grid.setColumnStretch(0,100)
    grid.setColumnStretch(1,100)
    
    # Row 0: heading.
    lab1 = self.createLabel(parent,'findHeading','Find/Change Settings...')
    grid.addWidget(lab1,0,0,1,2,QtCore.Qt.AlignHCenter)
    
    # Rows 1, 2: the find/change boxes, now disabled.
    findPattern = self.createLineEdit(parent,'findPattern',disabled=True)
    findChange  = self.createLineEdit(parent,'findChange',disabled=True)
    lab2 = self.createLabel(parent,'findLabel','Find:')
    lab3 = self.createLabel(parent,'changeLabel','Change:')
    grid.addWidget(lab2,1,0)
    grid.addWidget(lab3,2,0)
    grid.addWidget(findPattern,1,1)
    grid.addWidget(findChange,2,1)
        
    # Check boxes and radio buttons.
    # Radio buttons are mutually exclusive because they have the same parent.
    def mungeName(name):
        # The value returned here is significant: it creates an ivar.
        return 'checkBox%s' % label.replace(' ','').replace('&','')

    # Rows 3 through 8...
    table = (
        ('box', 'Whole &Word',      2,0),
        ('rb',  '&Entire Outline',  2,1),
        ('box', '&Ignore Case',     3,0),
        ('rb',  '&Suboutline Only', 3,1),
        ('box', 'Wrap &Around',     4,0),
        ('rb',  '&Node Only',       4,1),
        # ('box', '&Reverse',       5,0),
        ('box', 'Search &Headline', 5,1),
        ('box', 'Rege&xp',          5,0), # was 6,0
        ('box', 'Search &Body',     6,1),
        ('box', 'Mark &Finds',      6,0), # was 7,0
        ('box', 'Mark &Changes',    7,0)) # was 7,1
        # a,b,c,e,f,h,i,n,rs,w

    for kind,label,row,col in table:
        name = mungeName(label)
        func = g.choose(kind=='box',
            self.createCheckBox,self.createRadioButton)
        w = func(parent,name,label)
        grid.addWidget(w,row+1,col)
        setattr(self,name,w)

    # Row 9: Widgets that take all additional vertical space.
    w = QtGui.QWidget()
    grid.addWidget(w,9,0)
    grid.addWidget(w,9,1)
    grid.setRowStretch(9,100)

    # Official ivars (in addition to setattr ivars).
    self.leo_find_widget = tab_widget # 2011/11/21: a scrollArea.
    self.findPattern = findPattern
    self.findChange = findChange
    # self.findLab = lab2
    # self.changeLab = lab3
.. @+node:ekr.20110605121601.18156: *6* createGrid (DynamicWindow)
def createGrid (self,parent,name,margin=0,spacing=0):

    w = QtGui.QGridLayout(parent)
    w.setMargin(margin)
    w.setSpacing(spacing)
    self.setName(w,name)
    return w
.. @+node:ekr.20110605121601.18145: *6* createLogPane
def createLogPane (self,parent):

    # Create widgets.
    logFrame = self.createFrame(parent,'logFrame',
        vPolicy = QtGui.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame,'logInnerFrame',
        hPolicy=QtGui.QSizePolicy.Preferred,
        vPolicy=QtGui.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame,'logTabWidget')

    # Pack.
    innerGrid = self.createGrid(innerFrame,'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame,'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    
    # 2011/10/01: Embed the Find tab in a QScrollArea.
    findScrollArea = QtGui.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    findTab = QtGui.QWidget()
    findTab.setObjectName('findTab')
    tabWidget.addTab(findScrollArea,'Find')
    self.createFindTab(findTab,findScrollArea)
    findScrollArea.setWidget(findTab)

    spellTab = QtGui.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab,'Spell')
    self.createSpellTab(spellTab)

    tabWidget.setCurrentIndex(1)

    # Official ivars
    self.tabWidget = tabWidget # Used by leoQtLog.
.. @+node:ekr.20111010162047.15678: *5* Fix bug: Imports to @file should put @first/@last directives in root node
@nocolor-node

Especially:
    - Shebang line.
    - Python encoding line.
    
- @auto correctly works for all Python files.
.. @+node:ekr.20111221102703.10288: *6* @test imported shbang line
def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()
        
setup(p)
child = p.insertAsNthChild(0)
child.h = 'import'
child = p.firstChild()
assert child
assert child.h == 'import'
child.b = ''
c.selectPosition(child)

fn = g.os_path_finalize_join(g.app.loadDir,'..','test','at-auto-at-first-test.py')
assert g.os_path_exists(fn),fn

try:
    c.importCommands.createOutline(fn,parent=child.copy(),atAuto=False,ext='.py')
    s = '#!/usr/bin/env python\n# -*- coding: utf-8 -*-'
    root = child.firstChild()
    assert root
    assert root.h.startswith('@file'),root.h
    assert root.h.endswith('at-auto-at-first-test.py')
    assert root.b.startswith(s),'root.b:...\n\n%s' % (root.b)
finally:
    if not g.app.isExternalUnitTest:
        setup(p)
.. @+node:ekr.20111221102703.10289: *6* @@@nosent ../test/at-auto-at-first-test.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

def spam():
    pass
    
# This is the last line.
.. @+node:ekr.20110621085435.6531: *5* Fix bug: Improve the find panel and find menu
@nocolor-node

Recently, perhaps it was today, there was a remark made about Leo's
Find panel being confusing for newbies.  I have some sympathy for the
remarks.

1.  Looking at Leo's Edit:Find menu, there is no obvious way of doing
a search/replace operation.  I'll fix this soon after 4.9 final.

2.  The Find tab should make it clearer that it is a summary/status
tab only--not a way of actually initiating or continuing searches.
Perhaps using QLabel widgets instead of (disabled) QTextEdit widgets
for the find/change patterns would help a bit.
.. @+node:ekr.20111008073427.15595: *5* Fix bug: Must have a shortcut for call-last-macro
.. @+node:ekr.20110619173515.14895: *5* Fix bug: realpath in g.openWithFileName
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/cd5e2125c9e13d8f

g.openWithFileName needs

   fileName = g.os_path_realpath(fileName)

at the start of it, otherwise

g.openWithFileName("/home/tbrown/.leo/.todo.leo", c) will open another
instance of an already open "/mnt/usr1/usr1/home/tbrown/.leo/.todo.leo"
because it doesn't recognize them as being the same.

It would be nice if the original attempt to open
"/home/tbrown/.leo/.todo.leo" was not converted to
"/mnt/usr1/usr1/home/tbrown/.leo/.todo.leo", but I think the POSIX
spec. insists on giving CPython the real path form, so this is hard to
avoid.  You see this when selecting a file using a file dialog, in the
dialog you choose /home/me/myfile.txt, but the return
is /mnt/usr1/usr1/home/me/myfile.txt.

Anyway, let me know if and when I can push that to trunk, impacts seem
to be limited to (a) not failing to detect an already opened file in
g.openWithFileName, which is a bug, and (b) sometimes less attractive
apparent paths, which is annoying, but I think better than the bug.

(this of course trips up UNLs
if /mnt/usr1/usr1/home/tbrown/.leo/.todo.leo is already loaded and the
UNL is /home/tbrown/.leo/.todo.leo#Home-->Paint roof)
.. @+node:ekr.20120219152142.34262: *5* Fix bug: Revert moves the reverted tab to the right
.. @+node:ekr.20110530063322.18333: *5* Fix bug: scala not colored properly
.. @+node:ekr.20111125072438.10217: *5* Fix bug: shell interprets characters in at-mime headings
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/07efd66847ac4a64

on linux, parenthesis or angled brackets in @mime headings prevent the file from
being opened, probably because they are interpreted specially by the shell, e.g.
they need to be escaped. Such characters should be escaped before passing the
filename to the shell.

.. @+node:ekr.20111018104244.15920: *5* Fix bug: Use QLocalSocket in LProtoClient.connect
http://groups.google.com/group/leo-editor/browse_thread/thread/fe9cddc0e7ac8199
.. @+node:ekr.20111014074810.15652: *5* Fix bug: viewrendered should work better when docutils does not exist
.. @+node:ekr.20110620083705.14901: *5* Fix or disable curses gui
leoBridge.py requires the nullGui.
.. @+node:ekr.20110620065017.14900: *4* Bugs/Can't/Won't fix
.. @+node:ekr.20111011062533.15693: *5* Make headline widgets scrollable, if possible
# It doesn't seem easy.
.. @+node:ekr.20110605121601.18422: *6* editLabelHelper (leoQtTree)
def editLabelHelper (self,item,selectAll=False,selection=None):

    '''Called by nativeTree.editLabel to do
    gui-specific stuff.'''

    trace = False and not g.unitTesting
    w = self.treeWidget
    w.setCurrentItem(item) # Must do this first.
    w.editItem(item)
        # Generates focus-in event that tree doesn't report.
    e = w.itemWidget(item,0) # A QLineEdit.

    if e:
        s = e.text() ; len_s = len(s)
        if s == 'newHeadline': selectAll=True
        if selection:
            i,j,ins = selection
            start,n = i,abs(i-j)
                # Not right for backward searches.
        elif selectAll: start,n,ins = 0,len_s,len_s
        else:           start,n,ins = len_s,0,len_s
        e.setObjectName('headline')
        e.setSelection(start,n)
        # e.setCursorPosition(ins) # Does not work.
        e.setFocus()
        wrapper = self.connectEditorWidget(e,item) # Hook up the widget.

    if trace: g.trace(e,wrapper)
    return e,wrapper # 2011/02/11
.. @+node:ekr.20110619173515.14896: *5* Fix bug: wrong modality level on autocompleter
Just noticed the autocompleter pop-up is modal globally, not just for
the Leo windows.  Probably should only block the Leo windows.
.. @+node:ekr.20111018220642.15858: *3* Docs
.. @+node:ekr.20111027103125.16542: *4* Document new features
.. @+node:ekr.20111127153202.10264: *5* Document leoInspect
.. @+node:ekr.20111017132257.15892: *5* Add short intro to scripting
@language rest

http://mail.google.com/mail/#inbox/1330f306b947656c

> Maybe I'm missing something here, probably because I've always
> dismissed scripting because I don't have the foggiest notion of how to
> write one.

As you have just discovered, Leo does have scripting docs.

However, let me say a few words about scripting in *this* context.

What makes Leo scripting so important is that the predefined c, g and
p variables give *full* and *easy* access to all the data in your
outlines, as well as hundreds, if not thousands, of useful Python
functions in Leo's core.

You could say that these variables, especially c, define a *very*
easy-to-use DOM (Document Object Model) through which you can get o
set any data in *your** outlines.

The hello world example is::

   for p in c.all_positions():
       indent = '.' * p.level()
       print('%s%s' % (indent,p.h))

Here, c.all_positions() delivers a list of positions, and p.level()
and p.h deliver the indentation level and head string of position p.

Another crucial part of Leo scripting is that you can put Leo script
*anywhere* in a Leo outline.  You can do this in three ways:

1. You can just put the script above in the body of any node and run
it with Ctrl-B (execute-script).

2. You can make a script button by putting the script in an @button node.

3. You can make a new Leo command by putting the script in an @command node.

.. @+node:ekr.20111017124557.15879: *6* Easier scripting
# aList = [z for z in dir(c) if 'hild' in z]
# aList.sort()
# for z in aList:
    # print(z)

c.insertHeadline(event=None, op_name='Insert Node', as_child=False)

x = g.BasicLeoScript()

x.insert()
x.delete()
x.node()
n.h, n.d

.. @+node:ekr.20111017132257.15884: *5* Terry added bookmark scripts
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/b17d140b7ceb8fc9

I've added web page bookmarking from your browser to Leo.

Docs., appended to the mod_http plugin, where this functionality lives,
are pasted below.

Screen shot of the form which pops up when you click the Bookmark
button in your browser attached.  The body text of the corresponding
bookmark node created in Leo is:

    Leo's Home Page
        http://webpages.charter.net/edreamleo/front.html

        Tags: leo, python

        Leo's Home Page

        Collected: Sun 02 Oct 2011 02:52:51 PM CDT

        Keep this under your pillow.

If you had some text selected on the page in your browser that would
also appear in the above, and repeatedly bookmarking the same page with
different selections incrementally adds such quotes to the bookmark
node.

Here are the docs.:

Can also be used for bookmarking directly from the browser to Leo.  To
do this, add a bookmark to the browser with the following URL / Location:

    javascript:w=window;if(w.content){w=w.content}; d=w.document; w.open('http://localhost:8130/_/add/bkmk/?&name=' + escape(d.title) + '&selection=' + escape(window.getSelection()) + '&url=' + escape(w.location.href),%22_blank%22,%22toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no, width=800, height=300, status=no%22);void(0)

and edit the port (8130 in the example above) to match the port you're using
for mod_http.

Bookmarks are created as the first node in the outline which has been opened longest.
You can set the ``@string`` ``http_bookmark_unl`` to specify an alternative location,
e.g.::

    @string http_bookmark_unl = /home/tbrown/.bookmarks.leo#@bookmarks-->Incoming

to place them in the `Incoming` node in the `@bookmarks` node in the `.bookmarks.leo` outline.

The headline is preceeded with '@url ' *unless* the ``bookmarks`` plugin is loaded.
If the ``bookmarks`` plugin is loaded the bookmark will have to be moved to a ``@bookmarks`` tree to be useful.

The browser may or may not be able to close the bookmark form window for you, depending on settings - set ``dom.allow_scripts_to_close_windows`` to true
in ``about:config`` in Firefox. 
.. @+node:ekr.20111017132257.15889: *5* Document clone/move/delete-marked commands
http://groups.google.com/group/leo-editor/browse_thread/thread/4686ebad81bb1ea1
.. @+node:ekr.20111015194452.15682: *5* Improved quicksearch plugin
@nocolor-node

- Selecting any node using arrow keys shows the node in the outline immediately.

- Clicking a node or hitting <return> puts focus in body pane.

- Still to do: support Ctrl-G in Nav Tab.
.. @+node:ekr.20111104032034.9748: *5* Use Alt-4 for all unit tests
There is a collapse in complexity here that I just discovered: use
Alt-4 for all tests.

    unitTest.leo: bind Alt-4 to run-selected-unit-tests-externally
    leoPy.leo:    bind Alt-4 to run-marked-unit-tests-locally 

run-marked-unit-tests-externally is the simplest thing that could possibly work.
Bind Alt-4 to this command, marked just the desired tests and then run them with
one keystroke. Brilliantly simple.

Experience shows that being able to run the desired unit tests
*without* selecting any particular node makes an amazingly large
difference.  Being able to run all and only marked unit tests is a big
step forward.
.. @+node:ekr.20111104032034.9746: *5* Weightless unit testsing
As of rev 4725, unit testing in leoPy.leo feels *completely*
weightless.  The last change: running any unit test externally saves
the .leo file automatically first.

Thus, Alt-4 runs all desired unit tests immediately.  To select/
deselect unit tests, just mark/unmark @test nodes.

The difference in workflow is *huge*.  There is no need to select
@test nodes in any way, except for marking them.

So I create an @test node, make changes to that node, or to the code
being tested, and hit Alt-4.  Done.

When I am satisfied with the @test node, I can leave it where it is
(unmarked) or move it to unitTest.leo.

The energy difference between weightless and heavy is astounding.  Try
the new way: you will surely like it. 
.. @+node:ekr.20111027103125.16541: *4* Revise docs
.. @+node:ekr.20111020120612.15894: *5* Review bzr instructions
.. @+node:ekr.20111017102409.15876: *5* Document new organization for @command and @button nodes
@language rest

Recent revs to to the trunk complete, with perhaps one or two small
additions to come, a grand redesign of all of Leo's @command/@button
nodes:

- Significant @command nodes now appear in:

   leoSettings.leo#@settings-->Common @command nodes
   -->@commands-->@ignore

That is, they are define in as common global @command nodes, but they
are ignored.  Move them to myLeoSettings.leo as needed.

- @buttons appear only local to specific files.  See leoSettings.leo
for check buttons and LeoDocs.leo for various preview buttons.

In other words, the new org uses @command for global scripts and
@button for local scripts.  This makes sense for two reasons.  First,
we can't use @button for global scripts because that would overwhelm
the icon area.  Second, using @button for local scripts draws
attention to scripts that only make sense in a local context.  It's
very effect.

Edward

P.S. Except for the relatively minor tweaks, Leo already had
everything needed to support this scheme.  In particular, Leo already
supported the distinction between local and global @command and
@button nodes.

P.P.S. Earlier today I correct an oversight:  Leo now properly
supports @ignore nodes in @commands and @buttons nodes.  This is very
useful: no need for @@button or @@command.
.. @+node:ekr.20111015173019.15681: *5* Document @mark-for-unit-test trees!
@language rest


I would prefer if it would be possible to launch tests externally without loading plug-ins.

As I see in Code-->Testing-->@file leoTest.py-->runUnitTestLeoFile
and in Code-->Testing-->@file leoTest.py-->class runTestExternallyHelperClass-->runTests

there is an option to set gui for testing (g.app.unitTestGui) and default is 'nullGui'.

Maybe there could be an option to disable loading of plug-ins also ?

For the tests that I mostly write and run, loading plug-ins is just wasting time.
Vitalije.

===========================

> I am not sure what happens at present, and I'm not sure whether any settings apply to these commands.

Good news (mostly): you can set up dynamic unit tests exactly the way you want.

I was going to point you at the documentation but (how can this
possibly be?) the documentation doesn't exist!  I really could have
sworn that everyone knew about what I am about to tell you ;-)  To
quote Alan Greenspan, "I'm shocked.  Shocked."

So here goes...

Let p be the presently selected node when you hit Alt-5
(run-unit-tests).  Leo, that is, the code in
runTestExternallyHelperClass, creates dynamicUnitTest.leo by
assembling all of the following nodes from p's descendants.

- All @test nodes,
- All @suite nodes, and, **most importantly**,
- All children of all @mark-for-unit-tests nodes.

You can use @mark-for-unit-test nodes to include any "supporting data"
you want, including, say, "@common test code" to be imported as
follows::

    exec(g.findTestScript(c,'@common test code'))

Hmm.  I doubt this is really written up properly, although I know for
sure at the time I did write it up on leo-editor.  It's a very cool
pattern.

Now here is the new trick.  It *should* work, but actually does *not*
work yet.  Boo hoo. Are you ready?

- @mark-for-unit-tests
  - @settings
    - @enabled-plugins

Alas, this doesn't work because the test code runs dynamicUnitTest.py,
which runs dynamicUnitTest.leo **using the leoBridge module**.  And,
as I have just verified, the leoBridge module doesn't load *any*
plugins.  Nor does it init any other settings.

So, no matter *what* @enabled-plugins contains, your code will start
off with no plugins at all.  Thus, the following unit test will always
pass when run with Alt-5::

    @test loaded-plugins

    pc = g.app.pluginsController
    aList = pc.getLoadedPlugins()
    assert not aList,aList

However, your tests *can* load plugins if they like, provided they
don't through an exception when loaded with nullGui.  For example, the
following test passes::

    @test load backlink plugin

    pc = g.app.pluginsController
    pc.loadOnePlugin('backlink.py')
    aList = pc.getLoadedPlugins()
    assert 'leo.plugins.backlink' in aList

A similar trick could probably be used to set c.config settings from
the @settings tree, but at present your code would have to do all the
work itself: the leoBridge module does **not** initialize settings.
That is, c.config.getBool(x) returns None for all (strings) x.

I hope this gives you a sense of what is going on.  For full details,
consult leoTest.py.

It has been fun tracking this down.  I'll fix the documentation immediately. 
.. @+node:ekr.20111014074810.15653: *5* Rewrite MacOs instructions using Ludvig's homebrew instructions
@language rest


http://groups.google.com/group/leo-editor/browse_thread/thread/92ae059cc5213ad3

I bear good tidings of great joy!

I recently received a new MacBook Pro and did a fresh upgrade to Mac
OS 10.7 (Lion). I then used the opportunity to test out installation
procedures of various software on a clean system. My main finding is
that the excellent Homebrew (mxcl.github.com/homebrew/) makes things
much easier these days.

Why Homebrew? It does not try to replace every single bit of
functionality on your Mac with their own version, like Macports or
fink. It reuses the existing libraries as far as possible. No need to
reinstall Python, for example (one of my pet gripes when people try to
install new software on their Macs, and the source of much confusion
and pain). It installs to /usr/local, the standard place to find
third-party libraries and headers, instead of the obscure /opt or /sw.
It's simple to use and to extend.

I last installed Leo on Mac OS 10.4 (Tiger) back in the Tk days, and
wondered what it looked like in Qt. All the horror stories of PyQT on
Mac discouraged me from trying this before, so I was keen to see if
Homebrew helps. Here is my installation write-up:

- Make sure you have Xcode installed
  (test it by confirming that "gcc" runs in the Terminal)

- In preparation for homebrew, the best option in my opinion is
  to delete /usr/local via::

  sudo rm -rf /usr/local

  and install any software in it via homebrew instead. If this step
  fills you with dread and you do not want to lose your beloved
  third-party software, the second-best option is to make sure you
  have write permission for the directory via::

  sudo chown -R <your user name>:admin /usr/local

  If you don't know your username, run "whoami". :-) This is
  useful because homebrew actually discourages you from
  installing third-party software as the superuser (the usual Mac
  apps in /Applications are also installed as the normal user,
  for that matter).

- Install Homebrew (http://mxcl.github.com/homebrew/) by running
  the following command in the Terminal::

  /usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)"

- Run "brew update" to get the latest formulas

- Now install PyQT (yes, that's it!)::

  brew install pyqt

- Run "brew doctor" and check any further suggestions to improve
  your system.

- Add the following lines to your ~/.bash_profile
  (or ~/.profile on Leopard)::

  export PATH=/usr/local/bin:$PATH
  # This is for SIP (and PyQT) as suggested by Homebrew
  export PYTHONPATH=/usr/local/lib/python:$PYTHONPATH

- Open a new Terminal tab / window so that the above settings
  take effect, and install Leo. I downloaded the Leo-4.9-final-a.zip,
  unzipped it, and ran "python launchLeo.py" inside the Leo
  directory.

We should consider adding a Homebrew formula for Leo. This will
simplify the process even further, to simply "brew install leo". I
started on this, but wasn't sure where to put the various Leo files in
the system hierarchy. The Debian package can give some clues here, but
I haven't looked at it yet.

Ludwig
.. @+node:ekr.20111016072542.15702: *5* FAQ entry: @commands Aha
@language rest

The prefix "DingDing" signifies that this post is an answer to the
lament:

    "Wouldn't it be great if we all could remember what we,
    and others, have already done :-)"

Last night I had a forehead-slapping moment: the place to put @button
nodes is in myLeoSettings.leo.

This morning, I realized that using @command rather than @button
completes the Aha.

This organization has all benefits, and no drawbacks:

- I always know here scripts are.

- No need for duplicates.

- I can organize the scripts within myLeoSettings.leo as usual using
organizer nodes.  This organization can change as needed.

- Using @command rather than @button means that I never have to
disable scripts.  No more @@button.

- Using @command saves screen real estate.  In my experience, having
buttons be visible doesn't prevent them from being hidden in full
view.

- If I use common prefixes, like c_ (for command) or edit_ (for edit-
related scripts) or ekr_ (for personal scripts), the *typing
completion* will let me zero in on the script I want to use:

    <alt-x> c_<tab>
    <alt-x> c_import<tab>

etc.  Furthermore, Ctrl-P (repeat-complex-command) will allow me to
rerun the last script run.  This is a quite common case.

Summary
=======

This Aha substitutes an *already-existing* usage (typing completion)
for a whole set of memory-intensive retrieval problems.  I'm not
likely ever to forget typing completion, although I might forget the
specif prefixes used in @command nodes.  If that happens, I'll know
where to look.

This Aha takes full advantage of Leo's organization strengths and
*concentrates* those strengths by putting all the to-be-organized
material in one place.  This allows for easy reorganization:  changing
command-name prefixes, for instance, would be straightforward.

This is another example of the assertion that Leo already has most of
what is required to handle any task. 
.. @+node:ekr.20110918204916.6811: *5* revise autocompletion docs based on recent posts
.. @+node:ekr.20110929074744.15474: *6* Autocompleter post
@language rest
@pagewidth 65

Overview of the code
====================

All notes refer to methods in class AutoCompleterClass unless otherwise noted.

- The autoComplete method is the entry point. It will be called
  when autocompletion is enabled and the user types either a period
  or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       
.. @+node:ekr.20110929074744.15475: *7* Creating ctags data
On Sep 10, 8:36 am, "Edward K. Ream" <edream...@gmail.com> wrote:

> Later posts will discuss the following:
> 
> - Setting up to use ctags/codewise completion.

This section describes how to use Ville's codewise.py
module in leo\external folder.

**Note**: I've recently made a few changes to codewise.py. The
following discussion reflects the following changes:

- Changed docstring.

- The setup command does not crash if the ~/.ctags file already
  exist.
  
- The setup command does not call the init command, and thus does
  not delete ~/.codewise.db.
  
- Revised various print statements so they look better with Python 3.x.

**Important**: Leo's core contains all necessary autocompletion
code. In particular, enable *neither* the ctagscompleter.py
plugin *nor* the codewisecompleter.py plugin. I plan to remove
these plugins immediately, unless someone gives a good reason not
to do so.

**Important**: I've taken care to with the following
instructions, but there could be oversights or misunderstandings.
I would appreciate any corrections or additions.

Creating codewise/ctags data
============================

1. Make sure you have exuberant ctags (not just regular ctags)
   installed. It's an Ubuntu package, so its easy to install if
   you're using Ubuntu.
   
2. Execute the following commands from Leo's external/codewise.py
   module. **Note**: On Windows, you can use codewise.bat to
   execute these commands. For example::

        python <path to leo>\external\codewise.py %*
    
A. [Optional] Create a custom ~/.ctags file containing default
   configuration settings for ctags::
    
        codewise setup
        
    This command will leave the ~/.ctags file unchanged if it
    exists.  Othewise, the ``codewise setup`` command will
    create a ~/.ctags file containing the following defaults::
    
        --exclude=*.html
        --exclude=*.css
    
    See: http://ctags.sourceforge.net/ctags.html#FILES for more
    details about the .ctags file.
    
B. [Optional] Delete the existing ctags database in ~/.codewise.db::
   
        codewise init
        
C. Add ctags data to the existing ctags database::

        codewise parse <path to directory>
        
   You can add data from multiple sources by running
   the ``codewise parse`` command on multiple directories.
   
.. @+node:ekr.20110929074744.15476: *7* Using Leo's autocompleter (outline form)
@language rest

Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
.. @+node:ekr.20110929074744.15477: *8* Starting autocompletions
There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
.. @+node:ekr.20110929074744.15478: *8* Displaying autocompletions
How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


.. @+node:ekr.20110929074744.15479: *8* Using the QCompleter
When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
.. @+node:ekr.20110929074744.15480: *8* Using the Log pane completer
When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
.. @+node:ekr.20110929074744.15481: *8* Showing docstrings
Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15482: *7* Using Leo's autocompleter (COPY)
@language rest

Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
Starting autocompletions
========================

There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autcompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.

Displaying autocompletions
==========================

How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.

Using the QCompleter
====================

When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.

Using the Log pane completer
============================

When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.

Showing docstrings
==================

Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15483: *8* Starting autocompletions
There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
.. @+node:ekr.20110929074744.15484: *8* Displaying autocompletions
How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


.. @+node:ekr.20110929074744.15485: *8* Using the QCompleter
When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
.. @+node:ekr.20110929074744.15486: *8* Using the Log pane completer
When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
.. @+node:ekr.20110929074744.15487: *8* Showing docstrings
Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15488: *7* Code notes
Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.



.. @+node:ekr.20110929074744.15489: *7* Minor settings
Minor Autocompletion settings
=============================

These are found in leoSettings.leo: @settings-->Autocompleter

- @bool use_codewise = False

True: use codewise completions.
False: use Leo-specific completions.

- @bool use_qcompleter = True

True:  show completions in a QCompleter popup.
False: show completions in Leo's Completions tab.
This option has effect only when using the qt or qttabs gui's.

The following options specify minor user preferences: they have little or no effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
.. @+node:ekr.20110929074744.15490: *7* Appearance
Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

.. @+node:ekr.20110929074744.15491: *7* Codewise notes
Why the codewise module
=======================

- This module supports modern code completion for the Leo editor.

- Exuberant ctags is an excellent code scanner, but TAGS file
  lookup sucks for "find methods of this class".
  
- This module puts all data in a single file, ~/.codewise.db by
  default. In contrast, TAGS files can exist all over the file
  system.

- The code in codewise.py is usable as a python module, or a
  command line tool.


Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.
.. @+node:ekr.20110929074744.15492: *7* Performance
Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

.. @+node:ekr.20110929074744.15493: *7* Completions
os.path.splitdrive.d_rule
os.path.join
.. @+node:ekr.20110929074744.15494: *8* Docs
@language rest


Creating codewise/ctags data
============================

This is adapted from the thread:
http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e/ca01e7a803d2b546
"HOWTO: make Ville's autocompleter work.

1. Make sure you have exuberant ctags (not just regular ctags) installed.  It's an Ubuntu package, so it's easy to install if you're using Ubuntu.

2. All recent versions of Leo contain Ville's codewise module: leo/external/codewise.py

@pagewidth 60

Overview of the code
====================

All notes refer to methods in class AutoCompleterClass
unless otherwise noted.

- The autoComplete method is the entry point.  It will be called when autocompletion is enabled and the user types either a period or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       


Here are the contents of the discussion of autocompletion from the 4.9 release notes in LeoDocs.leo.  These should be folded into Leo's Users Guide: I'll do that today.

QQQQQ
 
Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.

Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.

Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

QQQQQ

Part 2: New documentation

As I reread the release notes, I see that they are too code-oriented for the general reader.  What is needed are the following:

1. A discussion of Autocompletion settings in 
.. @+node:ekr.20110929074744.15495: *9* Additional options
The following options specify minor user preferences: they have little or no
effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
.. @+node:ekr.20110929074744.15496: *8* Existing docs
@language rest
@pagewidth 65

Typing a period when @language python is in effect starts
autocompletion. Typing Return or Control-g (keyboard-quit) exits
autocompletion.

Autocompletion shows what may follow a period in code. (Actually
you can specify any character using the auto-complete shortcut
setting.) For example, after typing g. Leo will show a list of
all the global functions in leoGlobals.py. Autocompletion works
much like tab completion in the minibuffer. Unlike the
minibuffer, the presently selected completion appears directly in
the body pane.

A leading period brings up Autocomplete Modules. (The period
goes away.) You can also get any module by typing its name. If
more than 25 items would appear in the Autocompleter tab, Leo
shows only the valid starting characters. At this point, typing
an exclamation mark shows the complete list. Thereafter, typing
further exclamation marks toggles between full and abbreviated
modes.

If x is a list x.! shows all its elements, and if x is a Python
dictionary, x.! shows x.keys(). For example, sys.modules.!
Again, further exclamation marks toggles between full and
abbreviated modes.

During autocompletion, typing a question mark shows the docstring
for the object. For example: g.app? shows the docstring for
g.app. This doesnt work (yet) directly for Python globals, but
__builtin__.f? does. Example: __builtin__.pow? shows the
docstring for pow.

Autocompletion works in the Find tab; you can use <Tab> to cycle
through the choices. The Completion tab appears while you are
doing this; the Find tab reappears once the completion is
finished. Calltips

Calltips appear after you type an open parenthesis in code.
Calltips shows the expected arguments to a function or method.
Calltips work for any Python function or method, including
Pythons global functions. Typing Return or Control-g
(keyboard-quit) exits calltips.

Examples:

    g.toUnicode( gives g.toUnicode(s, encoding, reportErrors=False
    c.widgetWantsFocusNow gives c.widgetWantsFocusNow(w
    reduce( gives reduce(function, sequence[, initial]) -> value

The calltips appear directly in the text and the argument list is highlighted so you can just type to replace it. The calltips appear also in the status line for reference after you have started to replace the args.

Options

Both autocompletion and calltips are initially enabled or disabled by the enable_autocompleter and enable_calltips settings in leoSettings.leo. You may enable or disable these features at any time with these commands: enable-auto-completer-command, enable-calltips-command, disable-auto-completer-command and disable-calltips-command.
The minibuffer

The mini-buffer is a text area at the bottom of the body pane. You use it like the Emacs mini-buffer to invoke commands by their so-called long name. The following commands affect the minibuffer:

    full-command: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a full command name, then hit <Return> to execute the command. Tab completion works, but not yet for file names.

    universal-argument: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat count for later command. Ctrl-u 999 a adds 999 as.
    keyboard-quit: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts the focus in the body pane.

For example, to print a list of all commands type Alt-X print-commands <Return>.

The following sections list the various commands that you can invoke from the minibuffer. Important: you may bind keystrokes to any of these commands. See Customizing Leo for full details.
.. @+node:ekr.20111017132257.15886: *5* Add tip: How to restore focus without the mouse
@language rest

It sometimes happens that the focus gets left in a Leo in a widget
that doesn't support Leo's key bindings.  You would think that you
would have to use the mouse to click in, say, the body pane so that
you can use Leo's key bindings again.

But you don't have to do that.  Instead, use Alt-tab once to change
away from Leo, and then use Alt-tab again to change back to Leo.  When
you do this, Leo puts focus in the body pane and you are all set. This
will work either on Windows or Ubuntu.  A similar trick works on
MacOS.

Edward

P.S. One of the requirements of the recent bug fix was that doing Alt-
tab twice would put the focus in the body pane.  If you think that was
easy, you are sadly mistaken :-) 
.. @+node:ekr.20111018104244.15926: *5* Document loading plugins when running unit tests externally
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b560a3b84e7ec7a8

Good news (mostly): you can set up dynamic unit tests exactly the way you want.

I was going to point you at the documentation but (how can this
possibly be?) the documentation doesn't exist!  I really could have
sworn that everyone knew about what I am about to tell you ;-)  To
quote Alan Greenspan, "I'm shocked.  Shocked."

So here goes...

Let p be the presently selected node when you hit Alt-5
(run-unit-tests).  Leo, that is, the code in
runTestExternallyHelperClass, creates dynamicUnitTest.leo by
assembling all of the following nodes from p's descendants.

- All @test nodes,
- All @suite nodes, and, **most importantly**,
- All children of all @mark-for-unit-tests nodes.

You can use @mark-for-unit-test nodes to include any "supporting data"
you want, including, say, "@common test code" to be imported as
follows::

    exec(g.findTestScript(c,'@common test code'))

Hmm.  I doubt this is really written up properly, although I know for
sure at the time I did write it up on leo-editor.  It's a very cool
pattern.

Now here is the new trick.  It *should* work, but actually does *not*
work yet.  Boo hoo. Are you ready?

- @mark-for-unit-tests
  - @settings
    - @enabled-plugins

Alas, this doesn't work because the test code runs dynamicUnitTest.py,
which runs dynamicUnitTest.leo **using the leoBridge module**.  And,
as I have just verified, the leoBridge module doesn't load *any*
plugins.  Nor does it init any other settings.

So, no matter *what* @enabled-plugins contains, your code will start
off with no plugins at all.  Thus, the following unit test will always
pass when run with Alt-5::

    @test loaded-plugins

    pc = g.app.pluginsController
    aList = pc.getLoadedPlugins()
    assert not aList,aList

However, your tests *can* load plugins if they like, provided they
don't through an exception when loaded with nullGui.  For example, the
following test passes::

    @test load backlink plugin

    pc = g.app.pluginsController
    pc.loadOnePlugin('backlink.py')
    aList = pc.getLoadedPlugins()
    assert 'leo.plugins.backlink' in aList

A similar trick could probably be used to set c.config settings from
the @settings tree, but at present your code would have to do all the
work itself: the leoBridge module does **not** initialize settings.
That is, c.config.getBool(x) returns None for all (strings) x.

I hope this gives you a sense of what is going on.  For full details,
consult leoTest.py.

It has been fun tracking this down.  I'll fix the documentation immediately. 
.. @+node:ekr.20111026083456.16489: *5* Move UNL.py plugins docs somewhere else: it's no longer a plugin.
.. @+node:ekr.20111027103125.16537: *5* Revise Leo's docs re import commands
@nocolor-node

Terry:

I don't think the OP was trying to import MORE data, I think Leo is
incorrectly trying to apply MORE rules on loading a .txt file.

The File->Import command gives no indication it expects MORE data.

OTOH, the simple workaround is to use File->Open.

So perhaps it's a documentation / ui bug to clarify what File->Import
is for.


==============

Rob:
    
I would agree the documentation could be updated to reflect current
practice. The online docs (under the heading 'Importing Files Into Leo
Outlines':

The Import commands do not attempt to do perfect translations; they
merely automate the bulk of the drudgery:

   The Import to @file command creates an @file node from a file.
   The Import CWEB Files command creates an @file node from a CWEB file.
   The Import noweb Files command creates an @file node from a noweb file.
   The Import External File command imports all the nodes in a external file into the outline. Unlike the read commands, the command preserves no outline structure.
   The Import Flattened Outline command converts plain text written in MORE format to an outline.

The Import Flattened Outline command brings up a
dialog.................(more info about MORE spec)

I would say most/all of this has been deprecated as there's only one
Import command.
.. @+node:ekr.20111018104244.15922: *5* Leo on Mac OSX: new installation instructions
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/92ae059cc5213ad3

I bear good tidings of great joy! 

I recently received a new MacBook Pro and did a fresh upgrade to Mac
OS 10.7 (Lion). I then used the opportunity to test out installation
procedures of various software on a clean system. My main finding is
that the excellent Homebrew (mxcl.github.com/homebrew/) makes things
much easier these days.

Why Homebrew? It does not try to replace every single bit of
functionality on your Mac with their own version, like Macports or
fink. It reuses the existing libraries as far as possible. No need to
reinstall Python, for example (one of my pet gripes when people try to
install new software on their Macs, and the source of much confusion
and pain). It installs to /usr/local, the standard place to find
third-party libraries and headers, instead of the obscure /opt or /sw.
It's simple to use and to extend.

I last installed Leo on Mac OS 10.4 (Tiger) back in the Tk days, and
wondered what it looked like in Qt. All the horror stories of PyQT on
Mac discouraged me from trying this before, so I was keen to see if
Homebrew helps. Here is my installation write-up:

- Make sure you have Xcode installed
  (test it by confirming that "gcc" runs in the Terminal)

- In preparation for homebrew, the best option in my opinion is
  to delete /usr/local via::

  sudo rm -rf /usr/local

  and install any software in it via homebrew instead. If this step
  fills you with dread and you do not want to lose your beloved
  third-party software, the second-best option is to make sure you
  have write permission for the directory via::

  sudo chown -R <your user name>:admin /usr/local

  If you don't know your username, run "whoami". :-) This is
  useful because homebrew actually discourages you from
  installing third-party software as the superuser (the usual Mac
  apps in /Applications are also installed as the normal user,
  for that matter).

- Install Homebrew (http://mxcl.github.com/homebrew/) by running
  the following command in the Terminal::

  /usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)"

- Run "brew update" to get the latest formulas

- Now install PyQT (yes, that's it!)::

  brew install pyqt

- Run "brew doctor" and check any further suggestions to improve
  your system.

- Add the following lines to your ~/.bash_profile
  (or ~/.profile on Leopard)::

  export PATH=/usr/local/bin:$PATH
  # This is for SIP (and PyQT) as suggested by Homebrew
  export PYTHONPATH=/usr/local/lib/python:$PYTHONPATH

- Open a new Terminal tab / window so that the above settings
  take effect, and install Leo. I downloaded the Leo-4.9-final-a.zip,
  unzipped it, and ran "python launchLeo.py" inside the Leo
  directory.

We should consider adding a Homebrew formula for Leo. This will
simplify the process even further, to simply "brew install leo". I
started on this, but wasn't sure where to put the various Leo files in
the system hierarchy. The Debian package can give some clues here, but
I haven't looked at it yet.

Now I just have to start using Leo after all these years of checking
it out... :-)

.. @+node:ekr.20110930174206.15470: *4* ** Urgent: Bring screen shots up to date
> While doing so I noted that on the sourceforge project
> page some screenshots are bit old, such as touting Tk.
>
> shows tk - http://webpages.charter.net/edreamleo/screen-shots.html
    Fixed
    
> uses @thin - http://webpages.charter.net/edreamleo/PCWindow.gif

> screenshots shows deprecated plugin manager -
> http://sourceforge.net/projects/leo/
    All souce-forge screenshots need to be replaced.


.. @+node:ekr.20111027103125.16544: *4* Add screen shot to Leo's home page
@nocolor-node

In downloads folder: leo-4.9_viewrendered-layout.png
.. @+node:ekr.20120225072226.10199: *4* Add to scripting chapter
@language rest

I want to learn about PyQt and leo's qtGui. As a first step,
I'm trying to execute a script from within a leo body::

    from PyQt4 import QtGui
    w = QtGui.QWidget()
    w.resize(250, 150)
    w.move(300, 300)
    w.setWindowTitle('Simple test')
    w.show()

Q. When I try the above, I see a window appear and then
immediately disappear. How can I keep the window visible?

A. When the script exits the sole reference to the window,
w, ceases to exist, so the window is destroyed (garbage
collected). To keep the window open, add the following code
as the last line to keep the reference alive::

    g.app.scriptsDict['my-script_w'] = w

Note that this reference will persist until the next time
the execute-script command is run.  If you want something even
more permanent, you can do something like::

    g.app.my_script_w = w
.. @+node:ekr.20120225072226.10200: *4* Code for displaying a function call hierarchy in Leo
@language rest

@pagewidth 80

From Brian Theado

The other day I stumbled across Ville's code in scripts.leo which displays the
output of python's trace module in a leo outline. The output of the trace module
is not very friendly and I didn't find the result very usable. I was inspired to
write some code to translate the output so the tree of function calls is
displayed via Leo headlines. Thanks to Ville for sharing that code. I never
would have figure this out without that starting point.

Just copy (Ctrl-Shift-V) the child outline into a leo outline and hit ctrl-b on
the "call tree" node. The execution tree of the 'scroll-outline-up-line'
minibuffer command will be displayed to stdout and also as a tree of leo
headlines.
.. @+node:ekr.20120225072226.10203: *5* call tree
import trace

@language python
@others

# see http://docs.python.org/library/trace.html for documentation
# on the trace module
tracer = trace.Trace(countcallers=1)

# Trace a minibuffer command.

# Any function call will work. Leo's minibuffer commands are easily discoverable
# via tab completion and the 'print-commands' command.

#tracer.runfunc(c.executeMinibufferCommand, 'goto-prev-node')
tracer.runfunc(c.executeMinibufferCommand, 'scroll-outline-up-line')

top = p.insertAsLastChild().copy()
top.h = 'trace session'
displayCalltree(top, tracer.results().callers.keys())
c.redraw()
.. @+node:ekr.20120225072226.10204: *6* displayCalltree
def displayCalltree(p, callinfo):
   '''
   Converts the function call hierarchy in 'callinfo' into a tree of function
   calls.  The function call tree is displayed to stdout as indented text
   and is inserted as a tree of leo nodes rooted at the given position 'p'
   '''
   callers = [k[0] for k in callinfo]
   callees = [k[1] for k in callinfo]

   # The first set of children will be those that don't have any callers
   # listed in callinfo
   toplevels = list(set(callers) - set(callees))
   positions = {}
   path = []

   # Depth-first traversal of the call hierarchy represented by 'callinfo'
   # 'levels' is a stack which grows during descend and shrinks
   # during ascend.  Each element of 'levels' is a list of unprocessed
   # siblings of each other
   levels = [toplevels]
   while len(levels) > 0:
       while len(levels[-1]) > 0:
           # Process the first element in the 'deepest' (i.e. last) list of siblings
           cur = levels[-1][0]
           levels[-1] = levels[-1][1:]
           indent = " " * 4 * (len(levels)-1)
           if cur not in path:
               if cur in positions.keys():
                   # Function already seen, so make a clone
                   clone = positions[cur].clone()
                   clone.moveToLastChildOf(p)
                   print (indent + "%s %s ..." % cur[1:])
               else:
                   # Haven't seen this function, so insert a new headline
                   p = p.insertAsLastChild().copy()
                   p.h = "%s %s" % cur[1:]
                   print (indent + p.h)

                   # Remember the position so it can be cloned if seen again
                   positions[cur] = p

                   # Find all callees of this function and descend
                   levels.append([c[1] for c in callinfo if c[0] == cur])
                   path.append(cur)
           else:
               r = p.insertAsLastChild().copy()
               r.h = "(recursive call) %s %s" % (cur[1], cur[2])
               print(indent + r.h + "...")

       # Ascend back up one level
       path = path[0:-1]
       p = p.parent()
       levels = levels[0:-1]
.. @+node:ekr.20120225072226.10205: *6* trace session
.. @+node:ekr.20120225072226.10282: *4* The leoInspect module
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/f13fadac68eec41b/9124ba6d733ecbad
leoInspect: a hobby with a future?

http://groups.google.com/group/leo-editor/browse_thread/thread/62f0e7b84a25e0d0/39f848ad8a96bcbc
leoInspect: remarkable collapse in complexity and attempted assessment

.. @+node:ekr.20120226095657.10213: *4* Issue: @path @auto - strange behaviour
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b49d23010703aa61/32e1271d25ba2cfb

> In short, I am now willing, on an experimental basis, to have Leo put
> up a dialog when inserting an @ignore, and also when writing an
> @<file> node containing @ignore.

> In the past, I have always found read/write dialogs to be a) intrusive
> and b) panic-inducing, but this may be a tolerable exception.  We
> shall see.
.. @+node:ekr.20120226095657.10214: *4* How to upgrade properly
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/61019e45d75a6f18/71ee770ee4421222


Once you have the 4.9 "official release" working, then further updates are simply:

(ongoing practice - keep your folder containing your leo
code - separate from your .mySettings.leo and any data
files, .leo and otherwise.)

1. archive and remove that app folder
2. download the nightly snapshot zip file
3. unzip it into the same place
4. enjoy your up-to-date Leo code. . .
.. @+node:ekr.20120226095657.10215: *4* version.py now uses bzr_version.py
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/5fdadfba113e12d9/fa329534654ecfec

Leo now reports bzr version numbers and dates more accurately.
.. @+node:ekr.20120226183512.10193: *4* Changed calling signatures of g.openWithFileName and g.app.newCommander


Note: in rev 4990, the g.app.newCommander method (formerly called
g.app.newLeoCommanderAndFrame) also returns a single value (a
Commander) rather than the tuple (c,c.frame). 
.. @+node:ekr.20120228111337.10040: *4* Open with problems and proposed solutions
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/dd5907529208ee98

Revs 5037/8 contain fixes that allow the open-with command to start to
work, at least in 'subprocess.Popen' mode.

However, I think it is time for a complete rethink of how users
specify open-with settings.

===== The problems

1. The format of settings in @openwith nodes is way too wonky.  At
present, the body text of such nodes consists of a single line, which
contains a 3-tuple of elements. Let us call this line the **open-with
line**.

The entire open-with line must be a valid Python tuple.  This causes
problems for both user and implementation, as discussed more fully
below.

2. openTempFileInExternalEditor is the method that translates the
settings in @openwith nodes into code that actually open the temp file
with the desired editor.  At present, this method has to do an
**eval** of the single @openwith line, which has lots bad
consequences:

- eval is a slight security problem, although there are a gazillion
worse problems.

- The user has to quote strings, and those quotes are removed by eval,
so there is no easy way to specify quoted strings (the user has to
*doubly* quote strings.)

- There is no indication of what the parts of the open-with line mean.

3. At present, openTempFileInExternalEditor does some ridiculously-
complicated munging of the *eval'd* open-with line in order to get
produce the correct call to subprocess.Popen.  It's possible that
there is an easier way, but I haven't found it yet.

===== A proposed solution

1. We need a much more user-friendly format for @openwith nodes.  Let
us suppose that the body of @openwith nodes contains one or more lines
of the following form::

   tag: value

The possible tags will be::

- kind: <a string>

The value specifies the **opener logic**, that is, the method used to
launch the external editor, one of
('subprocess.Popen','os.system','os.startfile','os.spawnl','os.spawnv',
'exec')

- arg: <a string>

There may be many such arg lines. Each line will be a string to be
passed as an argument to the opener logic, in a format that is
compatible with the specified opener logic.

**Important**: quotes in <a string> will be *retained* (not eval'd),
allowing the user to specify exactly the arguments to be passed to
opener logic.

- custom: <a string>

Here, <a string> *will* be eval'd, yielding an object to be used as
the opener logic.

It's likely that either the "custom" tag or the "exec" opener value is
redundant.

===== Summary

The present scheme is wonky, confusing, inflexible and extremely
difficult to implement. It should be replaced immediately.
.. @+node:ekr.20120228111337.10041: *4* Understanding Leo's load process
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/28e544d052aeac2b

The original beautiful plan to read each local .leo file once has
fallen prey to an ugly fact :-)  Indeed, it doesn't seem possible to
call event handlers like open0, open1 and open2 without having inited
settings.  As a result, the 5-Phase load process in g.openWithFileName
is dead.  I won't morn it's loss.

Today's work has been valuable.  I've refactored the code in ways that
will survive the failure of the first plan.

The second plan will simplify code using another strategy, as
follows::

1. Leo will, as at present, read local files twice.  The first load
will discover the settings to be used in the second load.  This will
ensure that proper settings are *available* during the second load.

2. Instead of initing settings "late" in the finishCreate methods, all
ctors will init settings "early", before calling the ctors for
subsidiary objects.  This will ensure that proper settings are *in
effect* for the subsidiary ctors.

3. There is a clever way of using the fact that c.__init__ creates
*all* subsidiary objects (directly or indirectly).  After creating all
such objects, c.__init__ can simply call c.finishCreate!  It's
beautiful, and it should work. "Internalizing" the call to
c.finishCreate will help eliminate newLeoCommanderAndFrame, something
that I very much want to do.

At least one difficult puzzle remains, namely how to communicate the
settings discovered in the first load to the c.config object created
in the second load. Trust me, this is much harder than you might
expect.  But such problems *can* be solved cleanly.  It just takes
lots of work. 

=====

Hurray! The new plan is a *spectacular* success!

===== The unification of Leo's startup code

Creating Commands objects is now completely self-contained.  In
particular, c.__init__ now creates the fully-inited gui frame.  This
is a revolution in Leo's startup code!

Indeed, the old code inited Leo windows in several places, and in
several phases:

Places: c.__init__, the end of g.app.newLeoCommanderAndFrame and the
end of g.openWithFileName.

Phases: g.app.newCommanderAndFrame, g.openWithFileName and
c.finishCreate.

The new code has c.__init__ do *all* the work, in one place, and in
one phase.

This will be supremely important for future maintainers.  The old code
was difficult for me to understand yesterday, even after a full week
of study.  The new code is a simple as could possibly be imagined.
This is a gigantic step forward for Leo.

This spectacular collapse in complexity will have all sorts of
excellent consequences...

===== More cleanups

A number of possibilities for cleaner code now present themselves:

- c.__init__ no longer needs a frame argument, a surprisingly
important conceptual simplification.

- All calls to g.app.openWithFileName will be replaced by a call to
Commands(...), that is, c.__init__.  Because this code happens at
startup, it may still be useful to wrap this in a method that imports
the leo.core.leoCommands module, but this is a nit.  It will now be
perfectly clear that c.__init__ does all the work.

- I now see that having g.openWithFileName "fail" causes needless
complications.  It should simply create a new Leo window if it is
given no fileName argument, or if the file does not exist.  This will
eliminate a lot of "if" statements ;-)

Note: I have already removed the switches that enabled the new code.
This makes the code much easier to read.

I'll be upping these simplification later today.

===== The final phases

Once the code base has been cleaned, I'll turn my attention to the
"new_load" and "new_config" schemes.

new_load: simplifies the infamous readSettingsFiles methods into
several cleaner methods.

new_config: uses a much simpler per-commander c.config.get method
instead of delegating to the horribly complex g.app.config.get method.

There is significant coordination between these two schemes.  In fact,
they are really two aspects of the same problem.  I'll probably merge
these two switches into one.

Developmental unit testing has already proven both schemes.  It should
be relatively straightforward to fold the new code into the new code
base, but that is not guaranteed--there are still hidden complexities
to be dealt with.  Still, I expect the code to be fully tested in a
day or three.

Once all the new code is complete, it will be time to repackage all
the recent work as methods of the LoadManager class.  This promises to
eliminate significant code duplication in the leoBridge module.  We'll
see about that...

Finally, g.openWithFileName will do nothing but call a corresponding
LoadManager method. The details of loading do not belong in
leoGlobals.py! 
.. @+node:ekr.20120228111337.10042: *4* Leo's new classes
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/808ba29fec64e590

For almost 15 years Leo has been written using a limited set of
classes.  These were "big" classes, implementing major modules of
Leo.  There is nothing wrong with these classes, and they will remain
unchanged, except insofar as they will be simplified by the classes I
am about to discuss.

Recently, I have become aware that Leo's code could be considerably
simplified by adding "smallish" classes.  Indeed, I now think the
distinction between big and small classes is unhelpful.  The most
important part of the design of a class is simply whether a class
implements an understandable concept.

With this introduction, here is a short summary of Leo's new classes.
Some have not been fully implemented.  Getting them all to work is a
big part of the rewrite of Leo's config, loading and key-handling
code.

===== LoadManager

This class handles all the messy details of loading .leo files at
startup.  That's its *purpose*.

At the code level, it encapsulates almost all the code in runLeo.py,
as well as some methods in leoGlobals.py that really belong somewhere
else.  Creating a class simplifies the code to a surprising degree: 5
or 6 ivars of the class represent command-line options.  These ivars
are always available: there is no need to pass them around as
arguments.

Defining a new class means that it might be possible to reuse this
code in the leoBridge module, which would eliminate a lot of duplicate
code.

===== ModeController and ModeInfo

The ModeController class represents a collection of modes.  The
ModeInfo class represents a single mode.

Without these classes, the code in leoKeys.py is extremely hard to
understand.  In fact, the present code is a perfect example of the
problems with procedural programming: client code is burdened with
knowing way too many details about matters that it shouldn't have to
know about.  Furthermore, that data itself is hard to understand:
it's too "raw".  These classes provide "identity" for data.  The value
of repr(aModeInfo) is surprisingly large.

===== LogManager

This class represents the global log.  It hides the details of the log
from the g.app class and several other pieces of code.

At present, the interface to this class is procedural.  That is, the
present g.app methods that will be moved into this class have a
procedural rather than descriptive nature.  I'm not sure how much this
will change, but creating this class may create opportunities that
were not apparently previously.

===== KeyStroke and ShortcutInfo

I've discussed these previously.  The KeyStroke class is a wrapper for
plain strings.  It's most important attribute is its *identity*.  It
announces that its contents is a canonicalized value, not a raw user
settings string or any other kind of data associated with key
handling.

Similar remarks apply to ShortcutInfo objects.  Their identity
clarifies the code.  The former code used g.bunches.  In complex code
such as leoKeys.py, such anonymous objects really obfuscate matters.

===== EditCommandsManager

I wrote and tested this class last night.  It solves a problem that
has been annoying me ever since I created leoEditCommands.py.  The
problem is this:  without this class the classesList has to be defined
at the end of the module, after all classes have been imported.
Worse, several module-level methods were needed to manage the
classesList.

In the new scheme, each Commander creates an EditCommandsManager, and
the code that previously had to call the module-level method
leoEditCommands.x(c) now simply calls c.editCommandManager.x().  This
is much cleaner and avoids several very ugly imports.  Which brings me
to...

===== Avoiding imports of Leo files

I would like to avoid having Leo's modules import each other wherever
possible.  This would simplify Leo's startup process considerably.

At present, the ctor for the Commands class imports many modules.
This is essential to break what would otherwise be circular
dependencies among Python imports.  We can extend this pattern by
creating more classes, as was done with the EditCommandsManager class.

I'm not sure exactly how this will play out, but removing circular
imports between Leo's module seems like a worthy goal.  The leoGlobals
module is an important exception.  All of Leo's modules do::

   import leo.core.leoGlobals as g

To make this work, it is *essential* that leoGlobals.py import *no*
other Leo modules.

===== A new (limited!) use for section references

I am going to create a new section in leoGlobals.py called << global
switches >>  It will contain code such as:

   new_load = False # True: .leo files are loaded at most once.
   if new_load: print('***** new_load')

   new_modes = False # True: use ModeController and ModeInfo classes.
   if new_modes: print('***** new_modes')

This section is useful because I can clone it.  I can then enable and
disable switches in the clone, without having to keep "@file
leoGlobals.py" visible.  Very handy.
.. @+node:ekr.20120228111337.10043: *4* Eliminated the -c option
.. @+node:ekr.20120228111337.10044: *4* New search order for leoSettings.leo & myLeoSettings.leo
@language rest

leoSettings.leo:

table = (
        # First, leoSettings.leo in the home directories.
        join(g.app.homeDir,     settings_fn),
        join(g.app.homeLeoDir,  settings_fn),

        # Next, <machine-name>leoSettings.leo in the home directories.
        # join(g.app.homeDir,     machine_fn),
        # join(g.app.homeLeoDir,  machine_fn),

        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn)
    )

myLeoSettings.leo:

    table = (
        # First, myLeoSettings.leo in the local directory
        join(localDir,          settings_fn),

        # Next, myLeoSettings.leo in the home directories.
        join(g.app.homeDir,     settings_fn),
        join(g.app.homeLeoDir,  settings_fn),
    
        # Next, <machine-name>myLeoSettings.leo in the home directories.
        join(g.app.homeDir,     machine_fn),
        join(g.app.homeLeoDir,  machine_fn),

        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn),
    )
.. @+node:ekr.20120228111337.10045: *4* About key handling
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/86593fb9543afb66

Rev 4972 demonstrates that the KeyStroke class can indeed distinguish
between "raw" user settings and the "canonicalized" form used
throughout Leo.  Indeed, the ability to explicitly distinguish between
the two, using type checking, has already substantially clarified and
simplified the code.

BTW, this is in no way a violation of OO principles.  The code is not
dispatching on the type of objects, it is merely enforcing vital
consistency checks.  This code is complex: confusion about the types
of objects is intolerable.  Happily, the resulting clarity allows the
code to be substantially simpler than it would otherwise be, which in
turn clarifies the code further, and so on...

Part 1: This work is vital

As described below, the forthcoming work will lead to a cascade of
other simplification.  These simplifications are important for at
least three, reasons:

1. The code must be simplified so that future maintainers (including
me) will have an easier time of it.

2. The present code provides no real help in creating unit tests that
test how Leo handles keystrokes.

3. Simplifying the code will provide a more solid foundation for vim-
related bindings.

Part 2: Notes about the KeyStroke class

Objects of the KeyStroke class can be used *exactly* as a strings may
be used:

A.  KeyStroke objects may be used as dictionary keys, because they
have __hash__ methods and all the so-called rich comparison methods:
__eq__, __ne__, __ge__, __gt__, __le__ and __lt__.  Note that
KeyStroke objects may be compared with other KeyStroke objects,
strings and None.

B. At present, KeyStroke objects supports the find, lower and
startswith methods.  This simplifies the code substantially: we can
apply these methods to either strings or KeyStroke objects, so there
is no need to create different versions of the code depending on the
value of g.new_strokes.

However, having the KeyStroke class support string methods is bad
design.  Indeed, it is a symptom that the client code that uses
KeyStroke objects knows too much about the internals of KeyStroke
objects.  Instead, the KeyStroke class should have higher-level
methods that use s.find, s.lower and s.startswith internally.

You could say that the fact that code in leoKeys.py calls s.find,
s.lower and s.startswith is a symptom of non OO programming.  The
internal details of settings and strokes "pollutes" the code.  This
must be fixed.  This will likely create opportunities for further
simplifications.

Part 3: Other design changes

The present work, enabled and disabled with g.new_strokes, has been a
resounding success.  The next steps will be as follows:

Better packaging.

g.new_strokes, g.isStroke and g.isStrokeOrNone should be defined in
leoKeys.py, not leoGlobals.py.
I knew from the start that such global names were only a temporary
expedient.

Now I know where they should go. leoKeys.py, not leoConfig.py, is the
proper place to handle all the details about key bindings.  Indeed the
code in leoConfig.py simply parses user key settings into *strings*.
These raw strings must be converted to KeyStroke objects by
leoKeys.py.

As a result, the KeyStroke class (and the ShortcutInfo class?) should
be defined in leoKeys.py, not leoConfig.py.  To make this work, we'll
want to create several factory methods: k.makeKeyStroke and
k.makeShortcutInfo.

Better separation of concerns.

The Qt key input code can be hugely simplified by calling a new
k.makeKeyStrokeFromData factory method.  At present, the Qt key input
code knows *all* the details of  the format of *canonicalized*
settings. This is absolutely wretched design.

Instead, the Qt input key code should simply pass the key modifiers
and other key information to k.makeKeyStrokeFromData, in a some kind
of "easy" format.  For example, the Qt input key code would represent
the internal Qt modifiers as lists of strings like "alt", "ctrl",
"meta", "shift".  k.makeKeyStrokeFromData would then create a *user*
setting from the components, and then call k.strokeFromSetting to
complete the transformation.

As I said in another thread, the present Qt input key code is
entangled with other code.  I'll have to disentangle the code before
putting this scheme into effect.

Other classes

The easiest next step will be to integrate the presently unused
ShortcutsDict class into the code. This will eliminate the wretched
special cases for the _hash key.

Part 4: Conclusions

I have high hopes that we will see wave after wave of
simplifications.  Much of the difficult work presently scattered in a
non-OO fashion throughout leoKeys.py, leoConfig.py and leoQtGui.py
will migrate to become KeyStroke methods (or methods of other
classes).

The KeyStroke class has already made possible vital type-related
assertions.  Knowing *for sure* exactly what crucial data is and what
it means is a huge step forward.   More steps are coming. 

=====

> > Why not just have .s attribute in KeyStroke, that contains the string
> > version?

> A good question.  Indeed, all Keystroke objects ks do have an s ivar.

I forgot the most important reason in my reply.  The reasons I gave
all were code-level responses, but the most important reason is that
is truly impossible to understand the key code without knowing whether
an object is a string representing a user setting or the canonicalized
version used in Leo's core, that is, a KeyStroke object.  Using ks.s
instead of ks destroys precisely the information needed to understand
the code.

Again, this is not a theoretical concern.  The key code now contains
assertions of the form::

    assert g.isStroke(stroke)
or
    assert g.isStrokeOrNone(stroke)

Getting these assertions to pass in *all* situations required several
important revisions of the code.  The code that makes the assertions
pass is "innocuous", that is, almost invisible in the mass of code,
but obviously, these small pieces of code are vital.

The present code highlights these changes: look for g.new_strokes,
especially lines marked with ####.  These markers will be cleaned away
eventually, but the asserts will remain forever.

Furthermore, the asserts suggested further simplifications.  It was a
tricky process, and it will be ongoing as I simplify the code further. 

=====

> I am about to convert many of Leo's key-handling dictionaries to
> g.TypedDict objects.  Using TypedDicts will make it impossible to make
> invalid assignments to Leo's crucial key dictionaries.

This has been a great success.  I also defined the g.TypedDictOfLists
class, where the values are lists of a known type.  These classes are
useful for more than type checking:  they have unique names and a dump
method that dumps the dict in an easy-to-read format that includes the
name, and valid types for keys and values.

At present, these dicts are *not* subclasses of {}, which has its
pluses and minuses.  These are quite simple classes, so at present
only the "for key in d.keys()" idiom is supported, the "for key in d"
idiom is not supported.

Plain dicts do have their uses, but for "long-lived" dicts, and dicts
passed around between methods, I am beginning to regard plain dicts as
being as ill-advised as g.Bunches.

Leo's key dictionaries will always be complex, but basing them on the
TypedDict class is a major improvement. 
.. @+node:ekr.20120228111337.10046: *4* rev 4952 fixes bug 87933 with major key reorg
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/c933b28c27d3b9a7

Ref 4952 of the trunk fixes bug 87933:
"Redefining a key binding breaks menu items with same binding"

This was a difficult bug to fix--I rewrote significant parts of Leo's
code that deals with settings for key binding.

All unit tests pass, and I have been using this code happily for a few
days, but significant problems could be lurking.  Please use caution
and please report any problems immediately, especially settings-
related problems.

Besides fixing the bug, Leo computes accelerators, in menu items
dynamically when the user activates a menu.  The accelerator shows
*all* keys bound to the command associated with the menu item.

In the next few days I'll be simplifying the new code further, so if
you want more stable code please stay away from the trunk and the
nightly builds for the next several days.

Here is the checkin log:

A major reorganization of the configuration code that fixes bug 87933
Redefining a key binding breaks menu items with same binding

- Replaced g.bunches with ShortcutInfo objects, and bunchList name by
aList followed by
  assert isinstance(si,ShortcutInfo),si

  Using ShortcutInfo objects rather than g.bunch was a big win.

- Wrote and tested make_settings_dict and its helpers,
merge_settings_dicts, invert and uninvert.

- Leo computes menu texts dynamically in onAboutToShow.

- leo_update_shortcut now shows all shortcuts for a command.

- leoMenu.define_enable_dict encapsulates data used to enable/disable
commands regardless
  of where those commands appear in Leo's menu. The old code assumed
that a fixed menu
  location for all commands that could be enabled or disabled.

- Removed dynamic_menus "compile-time" constant.

- Created << define global key dicts >> in leoApp.py.

  This is a duplicate of dicts in leoKeys.py: they will be merged
later today
  in a location to be determined.

- Added unused ShortcutName and ShortcutsDict classes.

  The ShortcutName class will go away: it's methods may become methods
of the ShortcutInfo class.
  Alternatively, the methods might stay where they are.

  The ShortcutsDict class *will* become functional: it's the only way
to eliminate the wretched
  _hash hack used in the present raw key dictionaries. Furthermore,
the ShortcutsDict class
  will probably encapsulate inverted dicts. 
  
=====

> Ref 4952 of the trunk fixes bug 87933:
> "Redefining a key binding breaks menu items with same binding"

> This was a difficult bug to fix--I rewrote significant parts of Leo's
> code that deals with settings for key binding.

I am now in the midst of some long-overdue simplification that has
been made possible with the new code:

1. Leo now (provably) no longer uses the very complex g.app.config.get/
set code for shortcuts.

2. The new k.kill_one_shortcut allows k.registerCommand to properly
override settings.  For example, File:New is no longer bound to Ctrl-N
when the following becomes active::

    @button test @key=Ctrl-N

k.kill_one_shortcut uses the invert/uninvert trick used in
merge_settings_dict.  Only this kind of elegant code has a chance of
working reliably.

3. As mentioned in another thread, k.tkbindingFromStroke is about to
make its exit.

4. I'll be making several other simplifications to the config code in
the next several days.  It is important to do it now while all the
complexities are fresh in my mind. 
.. @+node:ekr.20120228111337.10047: *4* Fix bug: End only goes to physical line 
@language rest

End going to only physical line and not to the logical (wrapped) one)... 
.. @+node:ekr.20120228111337.10048: *4* BibTeX citations from Leo
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/d36d76174dcd6786

Currently I am using Leo as an outliner for the elaboration of
documents with LaTeX. For this, I work with @rst nodes and Sphinx. It
works really wonderful.

When using citations, Sphinx and RsT offer a certain syntax that, as
far as I have understood, does allow only for the generation of
"simple", Leo-self-contained citation references (inside of say a "Leo
References Section" node).

So I use a citation of the form   [CITBook001]_ inline in the text.
Somewhere else in the same Leo outline I have the corresponding
description as:

.. [CITBook001] A citation as well-known

When using LaTeX and BibTeX, I would like to use inside of Leo a kind
of LaTeX-inline-markup, that after generation of the RsT file through
Sphinx as well as after  running of "make latex", it generates a LaTeX
file containing the citation call of the form \cite{CITBook001} as
described in a file *.bib.  The only way I follow today is the later
editing by hand of the LaTeX file. This is of course not the best way.
How to convince Leo/Sphinx/RsT to generate the inline raw latex
syntax? It could be very simple, but ... I haven not been able to see
it.

Any hints? 

=====

> How to convince Leo/Sphinx/RsT to generate the inline raw latex
> syntax?

http://docutils.sourceforge.net/docs/ref/rst/directives.html#raw-data...

?

Cheers -Terry 

=====

I followed the recommendations of Terry. It was much easier
as I thought! Here a summary of the use of custom roles in
Leo to generate LaTeX "inline markup" from Leo:

+ @ rst-no head Defining the custom role, here applicable to html and
latex syntax
   .. role:: raw-role(raw)
      :format: html latex

+ @A document section
   This is my text including an example of inline markup for
generating :raw-role:`\LaTeX\` from Leo. For more details see
:raw-role:`\cite{rstDocumentation}`. Of course, my bib database below will
describe this citation with plenty of details.

+ @rst-no-head Including the bib database
   .. raw:: latex

      \bibliographystyle{acm}
      \bibliography{myBibliography}

It worked really fine! 
.. @+node:ekr.20120228111337.10049: *4* Replacing Qt stylesheets on the fly
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/ba9eb63337467d42/a3f3750d0ce6e847

> Here's a one line @button node you can add to myLeoSettings.leo
>
> @button set-style
>    c.frame.top.leo_ui.setStyleSheet(p.b)

Cool.  I've added this to my "pre-writing" pile of things to be
included in the next set of docs.

Important:  setStyleSheet *replaces* the previous stylesheet with the
new stylesheet, so you had best set all the attributes of Leo's
default stylesheet.

As an alternative, if w is any Qt widget, w.setStyleSheet(p.b) will
set the stylesheet for that widget only: the top-level stylesheet (the
stylesheet for c.frame.top.leo_ui) remains unchanged.
.. @+node:ekr.20120228111337.10050: *4* Eliminated v.bat
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/6c0a05306fb9b18f

I'd like to start a new thread here, rather than continue the
discussion for bug "911521: Help about and --version should be
accurate" so that more people might see it.

Here is my present summary of the situation:

The v.bat way is not acceptable: it effectively doubles the number of
commits needed, which adds a lot of cruft to the bzr log.

But how to fix matters?  There are three cases, two of which are
almost identical:

1. Running Leo from a bzr repository.  This is the easy case.
leoVersion.py should get the version from the .bzr/branch/last-
revision file.  I am going to add this code today.

2. Running Leo from a nightly snapshot.

3. Running Leo from an official release.

Cases 2 and 3 are almost identical.  The only difference is that for
case 3 we could consider running a distribution script to update
leoVersion.py.  We could also run such a script for nightly snapshots,
but that would not be automatic.

In short, the essential question is how to update leoVersion.py for
nightly snapshots.

Terry, I don't recall whether you have ever published the script that
builds the snapshots.  I think maybe you did, but I have no
recollection of it.  Would it be possible for this script to update
the source code of leoVersion.py?  If so, leoVersion.py would get the
version from the last-revision file if it exists, and otherwise use
the hard coded version inserted by your script.

I suppose the essential point here is that updated leoVersion.py would
*not* be committed to bzr: it would exist only for the nightly build.
This should be safe enough.

Any other comments or ideas? 

=====

In short, all that needs to be done is to have leoVersion.py look in
Leo's core folder for bzr_version.py if last-revision does not exist.
The core folder is as good a place as any, imo, so there should be no
need to change your daily build script. 
.. @+node:ekr.20120228111337.10051: *4* Leo will now raise a dialog on @ignore @<file> nodes
.. @+node:ekr.20120228111337.10052: *4* All about clone conflicts
@language rest

groups.google.com/group/leo-editor/browse_thread/thread/5da0de4502154b2c/1b077a8bb8e65811

Some people seem to think that it is difficult to understand how Leo
handles "clone wars":  differing values for a cloned nodes that appear
in several external files.  That's not true.  The rule is::

    **The last clone that Leo reads wins.**

That is, for any cloned node C, Leo takes the value of C.h and C.b to
be the values specified by the last copy that Leo reads.

There is only one complication::

    **Leo reads the entire outline before reading any external
files.**

Thus, if C appears in x.leo, y.py and z.py, Leo will choose the value
for C in x.py or y.py, depending on which @<file> node appears later
in the outline.

Notes:

1. Whenever Leo detects multiple values for C when opening an outline,
Leo creates a "Recovered nodes" tree.  This tree contains all the
various values for C, nicely formatted so that it is easy to determine
where the differences are.

2. I've just refreshed my memory by looking at the code.  The relevant
methods are:

    fc.getLeoFile # Reads the outline, then calls at.readAll to read
all external files.
    at.indicateNodeChanged # Adds data to c.nodeConflictList
    cacher.reportChangedClone # Adds data to c.nodeConflictList
    fc.handleNodeConflicts # Creates "Recovered Nodes" node and its
children.

3. The present code is the simplest code that could possibly work.
There is no way Leo is going to do AI in order to implement complex
rules for which clones are "more important" than others.  Thus, if you
use cross-file clones, it is up to *you* to know these rules and
handle any resulting conflicts.  Imo, the "Recovered Nodes" feature is
a big step forward for Leo, and makes it impossible to lose data
unless you willfully refuse to examine the data. 
.. @+node:ekr.20120228111337.10053: *4* Detached windows
@language rest

groups.google.com/group/leo-editor/browse_thread/thread/3666397da2a0d05f/758071d6d9516ab9

The right-click context menu on the tabs in the tabbed window mode (the
default) has a 'Detach' option, if there's more than one outline / tab,
and a Re-attach all option, if there's a detached outline window
out there.

Now there's also 'Horizontal tile', and 'Vertical tile', which detach
the tab and then tile its window with the window from which it was
detached.

This is very helpful for moving nodes between outlines, I was
rearranging the windows by hand and setting one to 'always on top' with
the window manager before.  Note: there's a @setting to determine
whether dragging nodes between outlines copies or moves them.

Depending on your OS / window manager, tiling / placement may be
somewhat off, and may work better with or without the window being
maximized before tiling, you'll have to experiment.

You'd think it would be straight forward for Qt to ask the
window-manager where the window is now, and then tell it to put it
somewhere specific, but apparently a lot of window-managers regard this
as none of Qt's business.

=====

> Now there's also 'Horizontal tile', and 'Vertical tile', which detach
> the tab and then tile its window with the window from which it was
> detached.

BEHAVIOR CHANGE: to make the above new feature more useful, I've
changed what happens when you close an outline window created by
detaching a tab.  Before the outline was closed (with prompt for save
in necessary).  Now the outline's just re-attached as a tab.  This
means it's now possible to reattach just one outline, rather than
having to use the 'reattach all' option. 
.. @+node:ekr.20110921094450.6956: ** To do: 4.10.1
3. Bridges


.. @+node:ekr.20111027103125.16540: *3* *Leo's home page and web site
.. @+node:ekr.20111018104244.15919: *4* Follow up on "Leo as a static site generator
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/840b0998de6c83e8

A long thread, full on interesting things.
.. @+node:ekr.20111027103125.16545: *4* Make sure you can get from TOC to home page
@nocolor-node

AFAICT - once you get below the homepage there is no way to get back to
the home page. Clicking the[ Lion] gets to the TOC. Maybe a link on the
TOC identified as [Home] back to http://webpages.charter.net/edreamleo/ ? 
.. @+node:ekr.20111020120612.15896: *4* Add link to glossary from Leo's home page
@nocolor-node

> Looks good, how about a link "Search", leading to
> http://webpages.charter.net/edreamleo/genindex.html or some other page
> where there's a search box.

Good idea.  I'll do it today.
.. @+node:ekr.20111027103125.16539: *4* Add link to search box from Leo's home page
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/eabbc401bbb9bf0/a705ad30d7900727

how about a link "Search", leading to
> http://webpages.charter.net/edreamleo/genindex.html or some other page
> where there's a search box.

Good idea.  I'll do it today. 
.. @+node:ekr.20111018104244.15924: *4* Revise Leo's wiki
.. @+node:ekr.20111011175652.15696: *4* Register a domain name like leo-editor.org
.. @+node:ekr.20120226183512.10199: *3* Features
.. @+node:ekr.20111109083738.9796: *4* Next
.. @+node:ekr.20120226180525.10191: *5* Run unit tests interactively?
@nocolor-node

Getting value from Bret Victor's video

http://groups.google.com/group/leo-editor/browse_thread/thread/9e1785ba4f57faf8

Thus, to associate code with unit tests, we need only create a
convention for associating source code with nodes.  But clones make
this trivial to do!

- @interactive-unit-tests
 - @itest
   - @test spam
   - (clone of) spam

This is all we would need to "declare" that @test spam should be run
whenever the spam node changes!

These are just first thoughts, made up as I am writing this post.  But
clearly, Leo can do more in this area.
.. @+node:ekr.20111028195854.16607: *5* Allow ruleset-specific colors
@nocolor-node

Like @color html::tags_markup_color = blue
.. @+node:ekr.20111027195140.16561: *5* Create session commands
# http://groups.google.com/group/leo-editor/browse_thread/thread/d5522e1075e746de

def get_session():
   """Return a list of UNLs for open tabs.
   """
   tabs = g.app.windowList
   UNLs = []
   for tab in tabs:
       current = tab.c.currentPosition()
       UNLs.append(current.get_UNL())
   return UNLs

def load_session(c, UNLs):
   """Open a tab for each item in UNLs.
   """
   for UNL in UNLs:
       fname, unl = UNL.split("#")
       c2 = g.openWithFileName(fname,old_c=c)
       if c2:
           for p in c2.all_positions():
               if p.get_UNL() == unl:
                   c2.setCurrentPosition(p)
                   c2.redraw()
                   break

def clear_session(c):
   """Close other tabs.
   The other session functions don't require parameters, use leotools.g
   I don't know how to get this filename from g, hence the ``c`` arg.
   """
   this_fname = c.fileName()
   tabs = g.app.windowList
   cmdrs = [tab.c for tab in tabs]
   for cmdr in cmdrs:
       if cmdr.fileName() !=this_fname:
           cmdr.close()

def session_save_snapshot():
   import json
   session = get_session()
   with file('leo.session', 'w') as f:
       json.dump(session, f)
       f.close()

def session_load_snapshot():
   import json
   with file('leo.session') as f:
       session = json.loads(f.read())
   return session
.. @+node:ekr.20111101050427.16716: *5* Make g.openWithFileName "reentrant"
@nocolor-node

That is, make sure it works when called from within itself.
.. @+node:ekr.20111125072438.10219: *5* Open file dialogs starting with @path directory
@nocolor-node

File 'Open' or 'Import File' command to follow @path directive
http://groups.google.com/group/leo-editor/browse_thread/thread/7e508921c85d18bc

Suppose my focus node is under a @path directive, say @path E:
\Documents\Some Folder\

Is there a setting that would cause the 'File>Open' or 'File>Import
File' commands to begin the search dialog in the directory, E:
\Documents\Some Folder\ instead of the last directory used?

Would others find this a useful feature?
.. @+node:ekr.20111221114145.10217: *6* Found: runOpenFileDialog
# Important: many plugins use g.app.gui.openFileDialog.
.. @+node:ekr.20031218072017.2821: *7* c.open & helper
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>
    table = [
        # 2010/10/09: Fix an interface blunder. Show all files by default.
        ("All files","*"),
        ("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()
    
    c.init_error_dialogs()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            c2 = g.openWithFileName(fileName,old_c=c)
            if c2:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if c2 and closeFlag:
                g.app.destroyWindow(c.frame)
        elif c.looksLikeDerivedFile(fileName):
            # 2011/10/09: A smart open makes Leo lighter:
            # Create an @file node for files containing Leo sentinels.
            ok = c.importCommands.importDerivedFiles(parent=c.p,
                paths=[fileName],command='Open')
        else:
            # otherwise, create an @edit node.
            ok = c.createNodeFromExternalFile(fileName)
            
    c.raise_error_dialogs(kind='write')

    # openWithFileName sets focus if ok.
    if not ok:
        c.initialFocusHelper()
.. @+node:ekr.20031218072017.2822: *8* << Set closeFlag if the only open window is empty >>
@
If this is the only open window was opened when the app started, and
the window has never been written to or saved, then we will
automatically close that window if this open command completes
successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfUntitledWindows == 1) # Only one untitled window has ever been opened
.. @+node:ekr.20090212054250.9: *8* c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
.. @+node:ekr.20111009162434.7206: *7* Regularized slashes in @edit/@file
@nocolor-node

Examples:
    
    @edit C:/leo.repo/ipython-0.12/IPython/frontend/qt/console/pygments_highlighter.py
        # The filename comes from g.app.gui.runOpenFileDialog
    
    @file C:\leo.repo\ipython-0.12\IPython\frontend\qt\console\pygments_highlighter.py
        # Created by import.
        
The problem was the call to g.os_path_normpath in importDerived files:
    it converts slashes to backslashes on windows (!!)
.. @+node:ekr.20110530124245.18245: *7* c.importAnyFile & helper
def importAnyFile (self,event=None):

    '''Import one or more files.'''

    c = self ; ic = c.importCommands

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()
    
    if names:
        g.chdir(names[0])
    else:
        names = []

    if not names:
        if g.unitTesting:
            # a kludge for unit testing.
            c.init_error_dialogs()
            c.raise_error_dialogs(kind='read')
        return
        
    
    
    # New in Leo 4.9: choose the type of import based on the extension.
    
    c.init_error_dialogs()
    
    derived = [z for z in names if c.looksLikeDerivedFile(z)]
    others = [ z for z in names if not z in derived]
    
    if derived:
        ic.importDerivedFiles(parent=c.p,paths=derived)
    
    for fn in others:
        junk,ext = g.os_path_splitext(fn)
        if ext.startswith('.'): ext = ext[1:]
    
        if ext in ('cw','cweb'):
            ic.importWebCommand([fn],"cweb")
        elif ext in ('nw','noweb'):
            ic.importWebCommand([fn],"noweb")
        elif ext == 'txt':
            ic.importFlattenedOutline([fn])
        else:
            ic.importFilesCommand([fn],"@file")
            
        # No longer supported.
        # c.importCommands.importFilesCommand (names,"@root")
        
    c.raise_error_dialogs(kind='read')
        
# Compatibility
importAtFile = importAnyFile
importAtRoot = importAnyFile
importCWEBFiles = importAnyFile
importDerivedFile = importAnyFile
importFlattenedOutline = importAnyFile
importNowebFiles = importAnyFile
.. @+node:ekr.20110530124245.18248: *8* c.looksLikeDerivedFile
def looksLikeDerivedFile (self,fn):
    
    '''Return True if fn names a file that looks like an
    external file written by Leo.'''
    
    c = self
    
    try:
        f = open(fn,'r')
    except IOError:
        return False
        
    s = f.read()
    f.close()
    
    val = s.find('@+leo-ver=') > -1
    # g.trace(val,fn)
    return val
.. @+node:ekr.20031218072017.2839: *7* c.readOutlineOnly
def readOutlineOnly (self,event=None):

    '''Open a Leo outline from a .leo file, but do not read any derived files.'''

    c = self
    c.endEditing()

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        g.chdir(fileName)
        c = g.app.newCommander(fileName)
        frame = c.frame
        frame.deiconify()
        frame.lift()
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:",fileName)
.. @+node:ekr.20070915134101: *7* c.readFileIntoNode
def readFileIntoNode (self,event=None):

    '''Read a file into a single node.'''

    c = self ; undoType = 'Read File Into Node'
    c.endEditing()

    filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Read File Into Node",filetypes=filetypes,defaultextension=None)
    if not fileName:return
    s,e = g.readFileIntoString(fileName)
    if s is None: return

    g.chdir(fileName)
    s = '@nocolor\n' + s
    w = c.frame.body.bodyCtrl
    p = c.insertHeadline(op_name=undoType)
    p.setHeadString('@read-file-into-node ' + fileName)
    p.setBodyString(s)
    w.setAllText(s)
    c.redraw(p)
.. @+node:ekr.20031218072017.2859: *7* c.removeSentinels
def removeSentinels (self,event=None):

    '''Import one or more files, removing any sentinels.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.removeSentinelsCommand (names)
.. @+node:ekr.20050920084036.20: *7* readAbbreviations & helper
def readAbbreviations (self,event=None):

    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if fileName:
        self.readAbbreviationsFromFile(fileName)
.. @+node:ekr.20100901080826.6156: *8* readAbbreviationsFromFile
def readAbbreviationsFromFile(self,fileName):

    k = self.c.k

    try:
        f = open(fileName)
        for s in f:
            self.addAbbrevHelper(s,'file')
        f.close()
        k.abbrevOn = True
        g.es("Abbreviations on")
        # self.listAbbrevs()
    except IOError:
        g.es('can not open',fileName)
.. @+node:ekr.20071114081313.1: *7* insertIcon
def insertIcon (self,event=None):
    
    '''Prompt for an icon, and insert it into the node's icon list.'''

    trace = False and not g.unitTesting
    c = self.c ; p = c.p

    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)

    paths = g.app.gui.runOpenFileDialog(
        title='Get Icons',
        filetypes=[('All files','*'),('Gif','*.gif'), ('Bitmap','*.bmp'),('Icon','*.ico'),],
        defaultextension=None,
        multiple=True)

    if not paths: return

    aList = [] ; xoffset = 2
    for path in paths:
        xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset)

    aList2 = self.getIconList(p)
    aList2.extend(aList)
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw_after_icons_changed()
.. @+node:ekr.20070920104110: *7* compareLeoFiles
def compareLeoFiles (self,event):
    
    '''Compare two .leo files.'''

    c = c1 = self.c ; w = c.frame.body.bodyCtrl

    # Prompt for the file to be compared with the present outline.
    filetypes = [("Leo files", "*.leo"),("All files", "*"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Compare .leo Files",filetypes=filetypes,defaultextension='.leo')
    if not fileName: return

    # Read the file into the hidden commander.
    c2 = self.createHiddenCommander(fileName)
    if not c2: return

    # Compute the inserted, deleted and changed dicts.
    d1 = self.createFileDict(c1)
    d2 = self.createFileDict(c2)  
    inserted, deleted, changed = self.computeChangeDicts(d1,d2)
    self.dumpCompareNodes(fileName,c1.mFileName,inserted,deleted,changed)

    # Create clones of all inserted, deleted and changed dicts.
    self.createAllCompareClones(inserted,deleted,changed)
    c2.frame.destroySelf()
    g.app.gui.set_focus(c,w)


.. @+node:ekr.20070921072608: *8* computeChangeDicts
def computeChangeDicts (self,d1,d2):

    '''Compute inserted, deleted, changed dictionaries.'''

    inserted = {}
    for key in d2:
        if not d1.get(key):
            inserted[key] = d2.get(key)

    deleted = {}
    for key in d1:
        if not d2.get(key):
            deleted[key] = d1.get(key)

    changed = {}
    for key in d1:
        if d2.get(key):
            p1 = d1.get(key)
            p2 = d2.get(key)
            if p1.h != p2.h or p1.b != p2.b:
                changed[key] = p1

    return inserted, deleted, changed
.. @+node:ekr.20070921072910: *8* createAllCompareClones & helper
def createAllCompareClones(self,inserted,deleted,changed):

    c = self.c # Always use the visible commander
    # Create parent node at the start of the outline.
    u = c.undoer ; undoType = 'Compare .leo Files'
    u.beforeChangeGroup(c.p,undoType)
    undoData = u.beforeInsertNode(c.p)
    parent = c.p.insertAfter()
    parent.setHeadString(undoType)
    u.afterInsertNode(parent,undoType,undoData,dirtyVnodeList=[])
    for d,kind in (
        (deleted,'deleted'),(inserted,'inserted'),(changed,'changed')
    ):
        self.createCompareClones(d,kind,parent)
    c.selectPosition(parent)
    u.afterChangeGroup(parent,undoType,reportFlag=True) 
    c.redraw()
.. @+node:ekr.20070921074410: *9* createCompareClones
def createCompareClones (self,d,kind,parent):

    c = self.c # Always use the visible commander.

    if d:
        parent = parent.insertAsLastChild()
        parent.setHeadString(kind)

        for key in d:
            p = d.get(key)
            clone = p.clone()
            clone.moveToLastChildOf(parent)
.. @+node:ekr.20070921070101: *8* createHiddenCommander (editFileCommandsClass)
def createHiddenCommander(self,fn):

    '''Read the file into a hidden commander (Similar to g.openWithFileName).'''
    
    import leo.core.leoCommands as leoCommands
    lm = g.app.loadManager

    c2 = leoCommands.Commands(fn,gui=g.app.nullGui)
    theFile = lm.openLeoOrZipFile(fn)

    if theFile:
        c2.fileCommands.openLeoFile(theFile,fn,
            readAtFileNodesFlag=True,silent=True)
        return c2
    else:
        return None
.. @+node:ekr.20070921070101.1: *8* createFileDict
def createFileDict (self,c):

    '''Create a dictionary of all relevant positions in commander c.'''

    d = {}
    for p in c.all_positions():
        try:
            # fileIndices for pre-4.x versions of .leo files have a different format.
            i,j,k = p.v.fileIndex
            d[str(i),str(j),str(k)] = p.copy()
        except Exception:
            pass
    return d
.. @+node:ekr.20070921072608.1: *8* dumpCompareNodes
def dumpCompareNodes (self,fileName1,fileName2,inserted,deleted,changed):

    for d,kind in (
        (inserted,'inserted (only in %s)' % (fileName1)),
        (deleted, 'deleted  (only in %s)' % (fileName2)),
        (changed, 'changed'),
    ):
        g.pr('\n',kind)
        for key in d:
            p = d.get(key)
            if g.isPython3:
                g.pr('%-32s %s' % (key,p.h))
            else:
                g.pr('%-32s %s' % (key,g.toEncodedString(p.h,'ascii')))
.. @+node:ekr.20050920084036.166: *7* getReadableTextFile
def getReadableTextFile (self):

    fn = g.app.gui.runOpenFileDialog(
        title = 'Open Text File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    return fn
.. @+node:ekr.20031218072017.3731: *7* app.gui file dialogs
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an open file dialog ."""

    self.oops()

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run a save file dialog ."""

    self.oops()
.. @+node:ekr.20031218072017.3744: *7* dialogs (nullGui)
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message):
    return self.simulateDialog("numberDialog",-1)

def runAskOkCancelStringDialog(self,c,title,message):
    return self.simulateDialog("stringDialog",'')

def runCompareDialog(self,c):
    return self.simulateDialog("compareDialog",'')

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
.. @+node:ekr.20110605121601.18500: *7* runOpenFileDialog (qtGui)
def runOpenFileDialog(self,title,filetypes,defaultextension='',multiple=False,startpath=None):

    """Create and run an Qt open file dialog ."""
    
    if g.unitTesting:
        return ''
    else:
        if startpath is None:
            startpath = os.curdir
            
        parent = None
        filter = self.makeFilter(filetypes)
    
        if multiple:
            lst = QtGui.QFileDialog.getOpenFileNames(parent,title,startpath,filter)
            return [g.u(s) for s in lst]
        else:
            s = QtGui.QFileDialog.getOpenFileName(parent,title,startpath,filter)
            return g.u(s)
.. @+node:ekr.20111125072438.10216: *5* Regularize slashes and back-slashes
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/0d48b507bc8ffc05

v4.9.1 build 4669
WinXP

If I 'Open' a file, I get the following node header:

@edit E:/Documents/index.html

If I 'Import' the same file, I get the following:

@file E:\Documents\index.html

Just wondering why the difference between

E:/ and E:\

This is probably trivial and of no consequence, but I thought it
curious. 
.. @+node:ekr.20111108081936.12524: *6* Create unit tests illustrating path ops
@nocolor-node

viewrendered - file not found
https://groups.google.com/forum/#!topic/leo-editor/kotyIs6_G3w

This would be part of a redesign of Leo's path operations.
.. @+node:ekr.20031218072017.2145: *7* os.path wrappers (leoGlobals.py)
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
.. @+node:ekr.20031218072017.2146: *8* os_path_abspath
def os_path_abspath(path):

    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.abspath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20031218072017.2147: *8* os_path_basename
def os_path_basename(path):

    """Return the second half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.basename(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20031218072017.2148: *8* os_path_dirname
def os_path_dirname(path):

    """Return the first half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.dirname(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20031218072017.2149: *8* os_path_exists
def os_path_exists(path):

    """Return True if path exists."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.exists(path)
.. @+node:ekr.20080922124033.6: *8* os_path_expandExpression
def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    trace = False
    
    s1 = s
    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    if not s:
        if trace: g.trace('no s')
        return ''

    i = s.find('{{')
    j = s.find('}}')
    if -1 < i < j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.p
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
                if trace: g.trace(s1,s)
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

    return s
.. @+node:ekr.20080921060401.13: *8* os_path_expanduser
def os_path_expanduser(path):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path)

    result = os.path.normpath(os.path.expanduser(path))

    return result
.. @+node:ekr.20080921060401.14: *8* g.os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c = keys.get('c')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path)
    path = os.path.abspath(path)
    path = os.path.normpath(path)
    return path

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c = keys.get('c')

    if c:
        args = [g.os_path_expandExpression(z,**keys)
            for z in args if z]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
.. @+node:ekr.20031218072017.2150: *8* os_path_getmtime
def os_path_getmtime(path):

    """Return the modification time of path."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.getmtime(path)
.. @+node:ekr.20080729142651.2: *8* os_path_getsize
def os_path_getsize (path):

    '''Return the size of path.'''

    path = g.toUnicodeFileEncoding(path)

    return os.path.getsize(path)
.. @+node:ekr.20031218072017.2151: *8* os_path_isabs
def os_path_isabs(path):

    """Return True if path is an absolute path."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isabs(path)
.. @+node:ekr.20031218072017.2152: *8* os_path_isdir
def os_path_isdir(path):

    """Return True if the path is a directory."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isdir(path)
.. @+node:ekr.20031218072017.2153: *8* os_path_isfile
def os_path_isfile(path):

    """Return True if path is a file."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isfile(path)
.. @+node:ekr.20031218072017.2154: *8* os_path_join
def os_path_join(*args,**keys):

    trace = False and not g.unitTesting
    c = keys.get('c')

    uargs = [g.toUnicodeFileEncoding(arg) for arg in args]

    if trace: g.trace('1',uargs)

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z) for z in uargs if z]

    if trace: g.trace('2',uargs)

    path = os.path.join(*uargs)

    if trace: g.trace('3',path)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path)
    return path
.. @+node:ekr.20031218072017.2156: *8* os_path_normcase
def os_path_normcase(path):

    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.normcase(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20031218072017.2157: *8* os_path_normpath
def os_path_normpath(path):

    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.normpath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20080605064555.2: *8* os_path_realpath
def os_path_realpath(path):


    path = g.toUnicodeFileEncoding(path)

    path = os.path.realpath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20031218072017.2158: *8* os_path_split
def os_path_split(path):

    path = g.toUnicodeFileEncoding(path)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)

    return head,tail
.. @+node:ekr.20031218072017.2159: *8* os_path_splitext
def os_path_splitext(path):

    path = g.toUnicodeFileEncoding(path)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)

    return head,tail
.. @+node:ekr.20090829140232.6036: *8* os_startfile
def os_startfile(fname):
    if sys.platform.startswith('win'):
        os.startfile(fname)
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            subprocess.call(['open', fname])
        except OSError:
            pass # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system("open '%s'" % (fname,))
    else:
        os.system('xdg-open "%s"'%fname)
.. @+node:ekr.20031218072017.2160: *8* toUnicodeFileEncoding
def toUnicodeFileEncoding(path):

    if path: path = path.replace('\\', os.sep)

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path)
.. @+node:ekr.20111108081936.9750: *7* @test path computations
fj = g.os_path_finalize_join
f  = g.os_path_finalize
eu = g.os_path_expanduser

if g.app.isExternalUnitTest:
    loadDir = fj(g.app.loadDir,'..','test')
else:
    loadDir = g.app.loadDir

table = (
    (fj,'@@file fj-test-1',fj(loadDir,'rel-path')),
)

for func,h,expected in table:
    p = g.findNodeAnywhere(c,h)
    assert p,'not found: "%s"' % (h)
    assert p.h.startswith('@@')
    p.h = p.h[1:] # Remove the first @ sign.
    
    try:
        d = c.scanAllDirectives(p)
        result = d.get('path')
        assert result == expected,'expected "%s", got "%s"' % (
            expected,result)
    finally:
        p.h = '@' + p.h
        c.redraw()
.. @+node:ekr.20111108081936.9768: *8* @path rel-path
.. @+node:ekr.20111108081936.9751: *9* @@file fj-test-1
.. @+node:ekr.20031218072017.3213: *6* createImportParent (importCommands)
def createImportParent (self,current,files):
    
    '''Create a parent node for nodes with a common prefix: x.h & x.cpp.'''

    name0,name1 = files
    prefix0, junk = g.os_path_splitext(name0)
    prefix1, junk = g.os_path_splitext(name1)
    
    if prefix0 and prefix0 == prefix1:
        current = current.insertAsLastChild()
        name,junk = g.os_path_splitext(prefix1)
        name = name.replace('\\','/') # 2011/11/25
        current.initHeadString(name)

    return current
.. @+node:ekr.20031218072017.3210: *6* ic.createOutline
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    at = c.atFileCommands

    self.default_directory = g.setDefaultDirectory(c,parent,importing=False)
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    fileName = fileName.replace('\\','/') # 2011/11/25
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        if atShadow: kind = '@shadow '
        elif atAuto: kind = '@auto '
        else: kind = ''
        s,e = g.readFileIntoString(fileName,encoding=self.encoding,kind=kind)
        if s is None: return None
        if e: self.encoding = e

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        elif self.treeType is None:
            # 2010/09/29: by convention, we use the short file name.
            p.initHeadString(g.shortFileName(fileName))
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    if self.treeType == '@root': # 2010/09/29.
        self.rootLine = "@root-code "+self.fileName+'\n'
    else:
        self.rootLine = ''

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        s = s.replace('\r','')
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        s = s.replace('\r','')
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Fix bug 488894: unsettling dialog when saving Leo file
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName,p)

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
.. @+node:ekr.20081001062423.9: *6* g.setDefaultDirectory & helper
def setDefaultDirectory(c,p,importing=False):

    ''' Return a default directory by scanning @path directives.'''

    name = p.anyAtFileNodeName()
    if name:
        # An absolute path overrides everything.
        d = g.os_path_dirname(name)
        if d and g.os_path_isabs(d):
            return d

    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
        # Returns g.getBaseDirectory(c) by default.
        # However, g.getBaseDirectory can return ''
    if path:
        path = g.os_path_finalize(path)
    else:
        g.checkOpenDirectory(c)
        for d in (c.openDirectory,g.getBaseDirectory(c)):
            # Errors may result in relative or invalid path.
            if d and g.os_path_isabs(d):
                path = d
                break
        else:
            path = ''

    if not importing and not path:
        # This should never happen, but is not serious if it does.
        g.warning("No absolute directory specified anywhere.")

    return path
.. @+node:ekr.20101022124309.6132: *7* g.checkOpenDirectory
def checkOpenDirectory (c):

    if c.openDirectory != c.frame.openDirectory:
        g.error(
            'c.openDirectory != c.frame.openDirectory\n'
            'c.openDirectory: %s\n'
            'c.frame.openDirectory: %s' % (
                c.openDirectory,c.frame.openDirectory))

    if not g.os_path_isabs(c.openDirectory):
        g.error ('relative c.openDirectory: %s' % (
            c.openDirectory))
.. @+node:ekr.20080921060401.14: *6* g.os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c = keys.get('c')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path)
    path = os.path.abspath(path)
    path = os.path.normpath(path)
    return path

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c = keys.get('c')

    if c:
        args = [g.os_path_expandExpression(z,**keys)
            for z in args if z]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
.. @+node:ekr.20111019080436.15848: *4* Easy
.. @+node:ekr.20111019104425.15869: *5* Convert @command nodes to official commands
@nocolor-node

May require command-related settings.

Example:
    @path create-at-auto-nodes-path=C:\apps\pygments\pygments
    @string create-at-auto-nodes-types=.py,
    @bool create-at-auto-nodes-is-recursive=True
.. @+node:ekr.20111012061216.15698: *5* Complete expand/contract commands
.. @+node:ekr.20111017102409.15875: *5* Create print-buttons command
@nocolor-node

- Create print-buttons command, showing source of all @command and @button nodes.
.. @+node:ekr.20111010122531.15569: *5* print-bindings/commands/settings create nodes
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/d302b2715b3ace96

A reminder, the opposite of "light" is "heavy", not "dark" :-)

Leo's print-settings, print-commands and print-bindings commands
create too much text.

Suppose they created outline nodes instead, replacing existing nodes
if they exist.  Something like this:

- Reference (Anywhere you like)
 - @print-settings
    etc.
 - @print-bindings
   etc
 - @print commands
   etc

Doh!  This uses Leo's power.  The subnodes can be as voluminous as
desired, and there can be organizer nodes in each case.  The actual
tree could be specified as in @menus.

Etc., etc.  This could moot the need for separate apropos commands.
Conversely, apropos commands could create their own trees, or
subtrees.

This could be the tip of an iceberg.

The more I think about the light/heavy distinction, the more I think
it is getting close to what makes Leo special.  For example, clones
(and nodes, for that matter) drastically lighten the apparent
complexity of programs or data.
.. @+node:ekr.20111010093113.15547: *5* Add support for ! in minibuffer
.. @+node:ekr.20061031131434.145: *6* k.Master event handlers
.. @+node:ekr.20061031131434.105: *7* k.masterCommand & helpers
def masterCommand (self,commandName=None,event=None,func=None,stroke=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or g.trace_masterCommand) and not g.unitTesting
    verbose = True
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')
    
    if event: c.check_event(event)

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.

    char = ch = event and event.char or ''
    w = event and event.w
    
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
        
    # Important: it is *not* an error for func to be None.
    k.func = func
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke,repr(ch),func and func.__name__))

    if inserted:
        k.setLossage(ch,stroke)

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startRecordingMacro(event)
        # 2011/06/06: Show the key, if possible.
        # return # (for Tk) 'break'

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return # (for Tk) 'break'

    if special: # Don't pass these on.
        return # (for Tk) 'break' 

    # if k.regx.iter:
        # try:
            # k.regXKey = char
            # k.regx.iter.next() # EKR: next() may throw StopIteration.
        # except StopIteration:
            # pass
        # return # (for Tk) 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return # (for Tk) 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return # (for Tk) 'break'
    elif k.inState():
        return # (for Tk) 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
.. @+node:ekr.20061031131434.106: *8* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
.. @+node:ekr.20061031131434.110: *8* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting
    verbose = False

    if trace and verbose:
        g.trace('widget_name',name,'stroke',stroke,'enable alt-ctrl',self.enable_alt_ctrl_bindings)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
        return # (for Tk) 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return # (for Tk) 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return # (for Tk) 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return # (for Tk) 'break'
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        import leo.core.leoFrame as leoFrame
        if issubclass(w.__class__,leoFrame.HighLevelInterface):
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                w.logCtrl.insert(i,s)
        else:
            if trace: g.trace('Not a HighLevelInterface object',w)
        return # None
    else:
        # Let the widget handle the event.
        return # None
.. @+node:ekr.20061031131434.146: *7* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event):

    '''This is the handler for almost all key bindings.'''
    
    trace = (False or g.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = g.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True
    
    k,c = self,self.c ; gui = g.app.gui
    c.check_event(event)
    << define vars >>
    
    assert g.isStrokeOrNone(stroke)

    if char in special_keys:
        if trace and verbose: g.trace('char',char)
        return None
    
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'char:',
        repr(event and event.char),
        'ch:',repr(event and event.char),
        'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endMacro()
            return # (for Tk) 'break'
        else:
            return k.masterCommand(commandName='keyboard-quit',
                event=event,func=k.keyboardQuit,stroke=stroke)

    if k.inState():
        if trace: g.trace('   state %-10s %s' % (stroke,state))
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')
            
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            return k.handleUnboundKeys(event,char,stroke)

    # 2011/02/08: Use getPandBindings for *all* keys.
    si = k.getPaneBinding(stroke,w)
    if si:
        assert g.isShortcutInfo(si),si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke,si.func.__name__)
        return k.masterCommand(event=event,
            commandName=si.commandName,func=si.func,stroke=si.stroke)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        return k.handleUnboundKeys(event,char,stroke)
.. @+node:ekr.20061031131434.147: *8* << define vars >>
w = event and event.widget
char = event and event.char or ''
stroke = event and event.stroke or None
w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
.. @+node:ekr.20061031131434.108: *8* callStateFunction
def callStateFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; val = None 
    ch = event and event.char or ''
    stroke = event and event.stroke or ''

    if trace: g.trace(k.state.kind,'ch',ch,'stroke',stroke,
        'ignore_unbound_non_ascii_keys',k.ignore_unbound_non_ascii_keys)
        
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns',repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
.. @+node:ekr.20091230094319.6244: *8* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns',repr(val))
        if val == 'do-standard-keys':
            return False,None # 2011/06/17.
        else:
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si),si
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=si.commandName,func=si.func,
                modeName=state,nextMode=si.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode()
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
.. @+node:ekr.20091230094319.6240: *8* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction
    
    assert g.isStroke(stroke)

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case',si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(si.stroke),si.commandName))
                        return si

    return None
.. @+node:ekr.20061031131434.152: *8* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or g.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
        
    assert g.isStroke(stroke)

    if state in ('getArg','full-command'):
        if stroke in ('\b','BackSpace','\r','Linefeed','\n','Return','\t','Tab','Escape',):
            return False
        if k.isFKey(stroke):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane),si.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName,event=event,func=si.func,stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
.. @+node:ekr.20110209083917.16004: *8* isAutoCompleteChar
def isAutoCompleteChar (self,stroke):
    
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction
    
    assert g.isStrokeOrNone(stroke)
    
    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20080510095819.1: *8* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,stroke):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    
    assert g.isStroke(stroke)

    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return None
        
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key',stroke)
        return None

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event=event,stroke=stroke)

    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char),repr(stroke))
        return None

    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char),repr(stroke))
        return None

    elif (
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return None

    else:
        if trace: g.trace('no func',repr(char),repr(stroke))
        return k.masterCommand(event=event,stroke=stroke)
.. @+node:ekr.20111017132257.15888: *5* Is there a script to diff 2 Leo files & create a tree?
.. @+node:ekr.20111018104244.15927: *5* Allow {{expr}} in URL's (and UNL's?)
.. @+node:ekr.20111018104244.15925: *5* Improve leo.leo by making bookmarks more useful
@nocolor-node

- Some kinds of relative bookmarks don't work.
- Allow {{exp}}
- Convert back slashes to forward slashes.
.. @+node:ekr.20031218072017.2312: *6* tree.OnIconDoubleClick (@url) & helper
# Several plugins handle url's, especially UNL.py.

def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.h.strip()
    if g.match_word(s,0,"@url"): 
        if p.b.strip():
            lines = p.b.split('\n',1)
            url = lines and lines[0].strip() or ''
        else:
            url = s[4:].strip()
        # g.trace(url,g.callers())

        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            g.handleUrlInUrlNode(url, c=c, p=p)
        g.doHook("@url2",c=c,p=p,v=p)

    return # (for Tk) 'break' # 11/19/06
.. @+node:tbrown.20090219095555.61: *6* g.handleUrlInUrlNode
def handleUrlInUrlNode(url, c=None, p=None):
    
    # Note 1: the UNL plugin has its own notion of what a good url is.

    # Note 2: tree.OnIconDoubleClick now uses the body text of an @url
    #         node if it exists.

    if g.unitTesting: return
    
    << check the url; return if bad >>
    << pass the url to the web browser >>
.. @+node:tbrown.20090219095555.62: *7* << check the url; return if bad >>
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

# urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

if not url:
    g.es("no url following @url")
    return

# Add http:// if required.
# if not re.match('^([a-z]{3,}:)',url):
#     url = 'http://' + url
# if not re.match(urlPattern,url):
#     g.es("invalid url:",url)
#     return
.. @+node:tbrown.20090219095555.63: *7* << pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    
    parsed = urlparse(url)
    
    leo_path = parsed.path
    if parsed.netloc:
        leo_path = os.path.join(parsed.netloc, parsed.path)
        # "readme.txt" gets parsed into .netloc...
    
    if c and parsed.scheme in ('', 'file'):
        
        # local UNLs like "node-->subnode", "-->node", and "#node"
        if '-->' in parsed.path:
            g.recursiveUNLSearch(parsed.path.split("-->"), c)
            return
        if not parsed.path and parsed.fragment:
            g.recursiveUNLSearch(parsed.fragment.split("-->"), c)
            return

        # leo aware path
        leo_path = os.path.expanduser(leo_path)
        leo_path = g.os_path_expandExpression(leo_path, c=c)
        if p and not os.path.isabs(leo_path):
            leo_path = os.path.normpath(
                os.path.join(c.getNodePath(p), leo_path))

        # .leo file
        if leo_path.lower().endswith('.leo') and os.path.exists(leo_path):
            # 2011/07/28: Immediately end editing, so that
            # typing in the new window works properly.
            c.endEditing()
            c.redraw_now()
            c2 = g.openWithFileName(leo_path,old_c=c)
            
            # with UNL after path
            if c2 and parsed.fragment:
                g.recursiveUNLSearch(parsed.fragment.split("-->"),c2)
            if c2:
                c2.bringToFront()
                return
                
    if parsed.scheme in ('', 'file'):
        if os.path.exists(leo_path):
            g.os_startfile(leo_path)
            return
        if parsed.scheme == 'file':
            g.es("File '%s' does not exist"%leo_path)
            return
        
    import webbrowser
    # Mozilla throws a weird exception, then opens the file!
    try: webbrowser.open(url)
    except: pass
    
except:
    g.es("exception opening",url)
    g.es_exception()
.. @+node:ekr.20111026075003.16481: *5* Support ~/.leo_config.py
@language rest

1. Imo, it is time to consider adding a typical "startup" file to Leo,
~/leo_config.py, similar to ~/.emacs or ipython_config.py.  This will
make Leo "thicker", that is more professional/standard.

IPython adds lots of bells and whistles to configuration.  Leo
emulates most of them, but .leo_config.py would be a good addition.
Think of .leo_config.py as a lightweight plugin.

leo_config.py should execute after settings have been parsed, but
before plugins have been loaded.  If desired, leo_config.py may
register "start2" event handlers, which execute after all plugins have
been loaded, just before starting the main Qt event loop.

2. Leo commands form a good framework for other solutions to Qt
stylesheet issues.  Consider the following commands::

- qt-stylesheet-set-global-stylesheet
- qt-stylesheet-append-to-global-stylesheet
- qt-stylesheet-set-widget-stylesheet
- qt-stylesheet-append-to-widget-stylesheet

@language python
.. @+node:ekr.20111021105253.9478: *4* Most important
.. @+node:ekr.20111010122531.15568: *5* * @render-rest, @render-html trees
@language rest

The free_layout and viewrendered plugins are a huge step forward.  But
the lighter/heavier distinction suggests a new way to use them.

Suppose Leo supports @render-rest or @render-html.

This means that all nodes in the tree will have the body pane become a
rendering pane for rST or html.

Imagine LeoDocs completely rendered at all times.

Of course, for specific purposes, say in Leo's scripting chapter, we
might want to override these rendering directives (which should be
allowed in headlines too) with @no-render.

The point is that having *both* the original text *and* the rendered
text be visible is often too heavy: the user usually does not want to
know about the sources: the rendering is good enough.

I suppose for sophisticated users, something like show/hide-body pane
would be good commands to have, but that doesn't matter: those
commands to not increase the burden on the user while she is reading
the (rendered) docs.
.. @+node:ekr.20111019104425.15868: *5* * Render to tex, pdf, rst, etc.
.. @+node:ekr.20111003232155.6988: *5* * Use c.db for marks & expansion bits
This would allow us to eliminate @bool put_expansion_bits_in_leo_files.
.. @+node:ekr.20110921094450.6957: *5* Restart vim project
This requires commands that can be composed.
.. @+node:ekr.20111027103125.16538: *6* * Look at vim video
http://video.google.com/videoplay?docid=8810772602188234059
.. @+node:ekr.20111021035504.9467: *5* Play with PyQt Qtest framework
http://groups.google.com/group/leo-editor/browse_thread/thread/b851e7d9855a57c2

http://www.voom.net/pyqt-qtest-example
.. @+node:ekr.20111027143736.16558: *5* Work-flow improvements
@nocolor-node

Considering leo.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/e3ddbe650fc9525b/290e97c593ee950a

> > I think there's a way to search across Leo files: quicksearch multiple
> > files ... ?

> http://groups.google.com/group/leo-editor/browse_thread/thread/cf5ab5...

Leo has to have this :-)  It's on my list.  It would be a great way to
find @button nodes.

Furthermore, global searches for attributes in docstrings have
immediate uses.

On the urgent to-do list: drive all aspects of the Nav pane using
keystrokes.

I just reviewed @bookmarks--it's perfect for leo.leo.  The following
would replace all.bat:

- @bookmarks
  - leoPy.leo (url in body)
  - leoPlugins.leo
  - leoSettings.leo
  - myLeoSettings.leo
  - leoDocs.leo
  - leoDist.leo
  - scripts.leo

This way could be said to be much better than all.bat: nothing gets
loaded until needed.  Therefore, even more files could be added.

Imo, URL's in bookmark trees should support {{expression}} notations.

For example, I want the following to work in the body text of a node
in an @bookmarks tree::

file://{{g.os_path_finalize_join(g.app.loadDir,'..','doc','LeoDocs.leo').replace('\\','/')}}

Not bad, eh?  Or maybe the URL logic should do the replace('\\','/')
automatically...

Got to go.  We are nearing a tipping point in Leo's workflow... 
.. @+node:ekr.20110921094450.6954: *4* Important
.. @+node:ekr.20110921094450.6955: *5* Windows
Leo should support more new windows.


Terry's plugins have also created nifty new windows.

Here are some other ideas:

A.  Hosting the PyQt demo inside Leo.

B. Making an OpenGl window an official Leo window. This might be the start of a
   prototype for "Blender in a Leo Window".
.. @+node:ekr.20110528034751.18272: *6* Support for tabifying Leo's core panes
Collaborate with Terry.

A. Place separate body editors in free_layout areas. This should *easy* to
   do! Almost nothing changes in the code, but the visual effect should be
   much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane) and
   "untabified." There are a few details to be handled, but nothing major.
   
C. Labels for panes.
.. @+node:ekr.20110525112110.18402: *6* Ideas:
.. @+node:ekr.20101104191857.5820: *7* QWebView makes Leo a presentation tool
http://groups.google.com/group/leo-editor/browse_thread/thread/4ea2d3f7d2c68106#

Ville:

Create one QWebView window, zoom it in to have large fonts.

Create @button that converts current node containing restructuredtext to html,
and pushes that html to QWebView.

Voila', instant presentation tool. The webview window would be on projector, and
leo would be in your private computer. You can easily edit the text, or find new
interesting slides to present in privacy of your own screen.

.. @+node:ekr.20060227123536: *7* Tiddlywiki and related comments about rendering body text (Mulder)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3578252
By: bwmulder

I have been thinking for a while that it ought to be possible to somehow  to
unite Leo with wiki features (my thinking is still vague at this point).

If you look at systems like Tiddlywiki (http://www.tiddlywiki.com/) you will
find that they already pretty much provide all the formatting features mentioned
in the article.

MoinMoin, another wiki (http://moinmoin.wikiwikiweb.de), has started to use
a graphical interface for editing in the latest version.

Maybe Leo can be split up into three components:

1. A storage component is responsible for storing nodes. Currently, this is
just memory, but databases like shelve, Zope or sqllite should also be possible.

2. The control component is responsible for converting from the internal format
to external files which can be processed by existing compilers, searching within
a document, and the like.

3. A display component is responsible for interfacing with the user. If can
be TK, but it can also be something like the Tiddlywiki interface, which immediately
shows the formatting applied to text.

I don't know much about javascript, so I would have to learn more about this
language before doing anything in this direction.

As an intermediate step, maybe we could allow mixing RST processing with regular
program text.  Leo would produce two documents out of a source file: a version
for the compiler in plain ascii, and an HTML file for reading the source.
.. @+node:ekr.20110921094450.6958: *5* Bridges
There are already bridges for vim, emacs, ipython and docutils, but I think more
can be done.

The first thought is to improve Leo's inter-process communication capabilities.
I'm not sure what that entails...

As a blue-sky project, could Leo interact with the window manager in order to
resize vim, say, to it automatically tracks Leo's body pane (or any other pane).
.. @+node:ekr.20110921094450.6959: *5* Code tools
Analysis, checking, refactoring and other code-level tools are a natural for
Leo. When the new-lint project is mature, it could be folded into Leo.

* Rewrite the beautify-python command using a much simpler tokenizer.

.. @+node:ekr.20110921094450.6960: *5* Documentation tools
Perhaps Leo's documentation could be built primarily from docstrings. In any
event, documentation tools are always needed.
.. @+node:ekr.20111009230326.7036: *4* Important/Later
.. @+node:ekr.20120226183512.10202: *5* Use QSignalSpy?
QSignalSpy: doesn't exist on PyQt?
.. @+node:ekr.20111019104425.15863: *5* Use pygments for syntax coloring?
.. @+node:ekr.20111009080647.15614: *6* pygments test
from pygments import highlight
from pygments.lexers import PythonLexer
from pygments.formatters import HtmlFormatter
import time

fn = g.os_path_finalize_join(g.app.loadDir,'leoCommands.py')
s = open(fn).read()

# s = 'print "Hello World"'

t1 = time.time()

s2 = highlight(s,PythonLexer(),HtmlFormatter())

t2 = time.time()

print(len(s),len(s2),'%2.2f sec' % (t2-t1))
.. @+node:ekr.20111009080647.15615: *6* pygments install error on pthon26 (python3.2 no problem)
@nocolor-node

c:\apps\pygments>python26 setup.py install

c:\apps\pygments>c:\python26\python.exe setup.py install
running install
running bdist_egg
running egg_info
creating Pygments.egg-info
writing Pygments.egg-info\PKG-INFO
writing top-level names to Pygments.egg-info\top_level.txt
writing dependency_links to Pygments.egg-info\dependency_links.txt
writing entry points to Pygments.egg-info\entry_points.txt
writing manifest file 'Pygments.egg-info\SOURCES.txt'
reading manifest file 'Pygments.egg-info\SOURCES.txt'
reading manifest template 'MANIFEST.in'
writing manifest file 'Pygments.egg-info\SOURCES.txt'
installing library code to build\bdist.win32\egg
running install_lib
running build_py
creating build\bdist.win32
creating build\bdist.win32\egg
creating build\bdist.win32\egg\pygments
copying build\lib\pygments\cmdline.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\console.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\filter.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\filters
copying build\lib\pygments\filters\__init__.py -> build\bdist.win32\egg\pygments\filters
copying build\lib\pygments\formatter.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\bbcode.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\html.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\img.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\latex.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\other.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\rtf.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\svg.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\terminal.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\terminal256.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\_mapping.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\__init__.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\lexer.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\agile.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\asm.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\compiled.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\dotnet.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\functional.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\hdl.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\math.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\other.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\parsers.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\postgres.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\pypylog.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\special.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\templates.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\text.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\web.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_asybuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_clbuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_luabuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_mapping.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_phpbuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_postgres_builtins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_vimbuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\__init__.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\plugin.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\scanner.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\style.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\autumn.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\borland.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\bw.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\colorful.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\default.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\emacs.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\friendly.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\fruity.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\manni.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\monokai.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\murphy.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\native.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\pastie.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\perldoc.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\tango.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\trac.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\vim.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\vs.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\__init__.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\token.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\unistring.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\util.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\__init__.py -> build\bdist.win32\egg\pygments
byte-compiling build\bdist.win32\egg\pygments\cmdline.py to cmdline.pyc

SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\cmdline.py', 133, 43,
'print("%s not found!" % what, file=sys.stderr)\n'))

byte-compiling build\bdist.win32\egg\pygments\console.py to console.pyc
byte-compiling build\bdist.win32\egg\pygments\filter.py to filter.pyc
byte-compiling build\bdist.win32\egg\pygments\filters\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\formatter.py to formatter.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\bbcode.py to bbcode.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\html.py to html.pyc

SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\formatters\\html.py', 472, 88, "
       'using current directory as base for the CSS file name', file=sys.stderr)\n"))

byte-compiling build\bdist.win32\egg\pygments\formatters\img.py to img.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\latex.py to latex.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\other.py to other.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\rtf.py to rtf.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\svg.py to svg.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\terminal.py to terminal.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\terminal256.py to terminal256.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\_mapping.py to _mapping.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\lexer.py to lexer.pyc
SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\lexer.py', 40, 30, 'class Lexer(object, metaclass=L
exerMeta):\n'))

byte-compiling build\bdist.win32\egg\pygments\lexers\agile.py to agile.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\asm.py to asm.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\compiled.py to compiled.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\dotnet.py to dotnet.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\functional.py to functional.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\hdl.py to hdl.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\math.py to math.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\other.py to other.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\parsers.py to parsers.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\postgres.py to postgres.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\pypylog.py to pypylog.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\special.py to special.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\templates.py to templates.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\text.py to text.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\web.py to web.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_asybuiltins.py to _asybuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_clbuiltins.py to _clbuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_luabuiltins.py to _luabuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_mapping.py to _mapping.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_phpbuiltins.py to _phpbuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_postgres_builtins.py to _postgres_builtins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_vimbuiltins.py to _vimbuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\plugin.py to plugin.pyc
byte-compiling build\bdist.win32\egg\pygments\scanner.py to scanner.pyc
byte-compiling build\bdist.win32\egg\pygments\style.py to style.pyc

SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\style.py', 107, 30,

'class Style(object, metaclass=StyleMeta):\n'))

byte-compiling build\bdist.win32\egg\pygments\styles\autumn.py to autumn.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\borland.py to borland.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\bw.py to bw.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\colorful.py to colorful.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\default.py to default.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\emacs.py to emacs.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\friendly.py to friendly.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\fruity.py to fruity.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\manni.py to manni.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\monokai.py to monokai.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\murphy.py to murphy.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\native.py to native.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\pastie.py to pastie.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\perldoc.py to perldoc.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\tango.py to tango.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\trac.py to trac.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\vim.py to vim.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\vs.py to vs.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\token.py to token.pyc
byte-compiling build\bdist.win32\egg\pygments\unistring.py to unistring.pyc
byte-compiling build\bdist.win32\egg\pygments\util.py to util.pyc
byte-compiling build\bdist.win32\egg\pygments\__init__.py to __init__.pyc
creating build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\PKG-INFO -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\SOURCES.txt -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\dependency_links.txt -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\entry_points.txt -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\not-zip-safe -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\top_level.txt -> build\bdist.win32\egg\EGG-INFO
creating dist
creating 'dist\Pygments-1.4dev_20111009-py2.6.egg' and adding 'build\bdist.win32\egg' to it
removing 'build\bdist.win32\egg' (and everything under it)
Processing Pygments-1.4dev_20111009-py2.6.egg
creating c:\python26\lib\site-packages\Pygments-1.4dev_20111009-py2.6.egg
Extracting Pygments-1.4dev_20111009-py2.6.egg to c:\python26\lib\site-packages

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\cmdlin
e.py', 133, 43, '        print("%s not found!" % what, file=sys.stderr)\n'))

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\lexer.
py', 40, 30, 'class Lexer(object, metaclass=LexerMeta):\n'))

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\style.
py', 107, 30, 'class Style(object, metaclass=StyleMeta):\n'))

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\format
ters\\html.py', 472, 88, "                          'using current directory as base for the CSS file name', file=sys.st
derr)\n"))

Removing pygments 1.1.1 from easy-install.pth file
Adding Pygments 1.4dev-20111009 to easy-install.pth file
Installing pygmentize-script.py script to c:\python26\Scripts
Installing pygmentize.exe script to c:\python26\Scripts
Installing pygmentize.exe.manifest script to c:\python26\Scripts

Installed c:\python26\lib\site-packages\pygments-1.4dev_20111009-py2.6.egg
Processing dependencies for Pygments==1.4dev-20111009
Finished processing dependencies for Pygments==1.4dev-20111009

c:\apps\pygments>
.. @+node:ekr.20110930075237.15472: *5* * Improving Leo: think inside the box
@language rest,
.. @+node:ekr.20111019104425.15886: *6* Windows
Terry's work is an enabler.  Just as Blender supports many kinds of
windows, so too should Leo.  Up until now, the outline, body and log
panes have been the only "official" panes.  The rendering pane soon
will be fully official.
.. @+node:ekr.20111019104425.15890: *6* Bridges
This could be an important "new" direction.  True, there are already
bridges for vim, emacs, ipython and docutils, but I think more can be
done.

The first thought is to improve Leo's inter-process communication
capabilities.  I'm not sure what that entails...

As a blue-sky project, could Leo interact with the window manager in
order to resize vim, say, to it automatically tracks Leo's body pane
(or any other pane).
.. @+node:ekr.20111019104425.15887: *6* Host the PyQt demo inside Leo
.. @+node:ekr.20111019104425.15888: *6* Support an openGL window in Leo
.. @+node:ekr.20111019104425.15891: *6* Code tools
Analysis, checking, refactoring and other code-level tools are a
natural for Leo.  When the new-lint project is mature, it could be
folded into Leo.

.. @+node:ekr.20110930075237.15473: *6* Kent's suggestions
@nocolor-node


- 
.. @+node:ekr.20111019104425.15892: *7* Buttons
Enhance the button machinery to allow mixed case, spaces, colors.
Provide cascading rclick capability: rclick on an rclick list ...
.. @+node:ekr.20111019104425.15893: *7* Templating
Solid, simple implementation of one of the standard template engines
providing intuitive template nodes, variable definitions, and rendering options.

.. @+node:ekr.20111019104425.15894: *7* Wizards
Leverage the template capability to offer form-based content creation:
- create a plugin
- generate a test node
- generate a wizard :-]
.. @+node:ekr.20111019104425.15895: *7* LeoFS
- create a Leo implementation of pyfilesystem
http://packages.python.org/fs/implementersguide.html

.. @+node:ekr.20111019104425.15896: *7* Enhansed node attributes: ctime, atime, mtime
.. @+node:ekr.20111019104425.15897: *7* Persistent tab status
Resume editing with same tabs open when using tabbed gui.

.. @+node:ekr.20111019104425.15898: *7* Persistent pane layout
.. @+node:ekr.20110930075237.15474: *6* Matt Wilkie
@nocolor-node

As for user interface, I'd love to see myLeoSettings with a checkbox
interface and filter bar at the top, and a feature to "merge or reset
from LeoSettings".
... or maybe something like Firefox's "about:config" would be better
suited (and probably faster to build).
.. @+node:ekr.20111027103125.16546: *5* What's next
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/19bfe6daf2b324/c50a750606d64f77

Fossil (SCCS) and Leo.

> I think that the interaction of Fossil + Leo could
> solve the idea of having external files in a single "Leo document" that
> would be really a fossil sqlite repository with all the external files in
> it, but syncronizable with the outside world. This kind of instantiated
> image of files in a moment of time in Fossil + Leo, would be like the
> instantiated image of objects in a moment of time of Smalltalk.
.. @+node:ekr.20111014134653.15672: *5* Search across multiple Leo files
http://groups.google.com/group/leo-editor/browse_thread/thread/cf5ab54f29a6c128
.. @+node:ekr.20110929074744.15449: *5* generalize show/hide/select gui elements commands
@nocolor-node

tab-cycle-next makes the following not so important

There is a relationship here with mouseless
programming.  It would seem that all visual elements, especially those
that may exist in multiple versions, must have a name or other
description suitable for generalized commands.

The user might want multiple rendering panes, especially if
one or more are locked.  Without a description, there is no way to
specify exactly what show/hide-rendering pane does.

I haven't forgotten the autocompleter docs.  I'll get to them next.
It looks like autocompletion would be the way to generalize the not-
very-effect commands that switch focus from one ui element to
another.  A related benefit is one generalized command might be more
convenient to use than the present flavors of (buggy) cycle-focus
commands.

In short, contemplating generalized windows leads us to generalized
select/delete/show/hide commands, based on autocompletion, that work
on various ui elements.  This looks like the next project. 
.. @+node:ekr.20110621085435.6532: *5* Request: have equal-sized-panes resize vr pane
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/583bc0a31a6c7979

I noticed that when the renderpane is active it is not affected by the
Window>Equal Sized Panes command. Only the Outline and Body Panes are affected -
just as described in
http://webpages.charter.net/edreamleo/outlines.html#resizing-panes. However from
the user perspective the current behaviour appears as though the command is only
partially successful. Since there are specific commands to contract/expand the
log pane, shouldn't the log and render panes also be affected by the
Window>Equal Sized Panes command?


I suppose so.  I would prefer to wait for Terry to finish his
pane-generalization code before dealing with this.
.. @+node:ekr.20111018104244.15928: *5* Improve Find panel
@nocolor-node

- All open files.
- Show all results as in quicksearch.
.. @+node:ekr.20111017132257.15883: *5* Possible to use IPython completion?
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/014fe61ff9480b2b

I don't know if this is relevant or not, but the IPython autocompletion
capability is awesome.

If I'm investigating code I tend to do the following.

list the modules in a package:
In [1]: from fs import <tab>

this lists the modules, in a package so I pick one
In [1]: from fs import osfs
<the osfs entry is tab-completable>

now I can check the usage of fs.osfs
In [2]: osfs? <enter>

or the source:
In [2]: osfs?? <enter>

or the contents of the module
In [2]: osfs. <tab>

I can instantiate a class:
In [3]: myfs = osfs.OSFS('/')

and examine the ivars and methods:
In [4]: myfs. <tab>

It is such an efficient way to learn and remember the details of code.

I know a bunch of work was done on Leo/IPython integration, don't
know the current status, my wish of synchronized IPython and Leo
may well be one of the many granted wishes I have forgotten about.

I certainly think IPython autocompletion is the gold standard. 
.. @+node:ekr.20110929074744.15499: *5* Allow more panes to be part of the free_layout "action" buttons
.. @+node:ekr.20111009230326.7037: *5* Leo-to-json script for IPython?
.. @+node:ekr.20110527084258.18378: *6* New file format
@nocolor-node

** remove window state, expansion status etc.
   stuff from .leo file, and move that over to c.db

- <attr> solves pickle problem.

* Treat gnx's as strings: don't parse them.
  http://mail.google.com/mail/#inbox/12f3d4950fbabeea
  
* Don't save expansion bits in uA if not saving expansion bits. It's illogical
  to save bits in uA's if they aren't save in in the <v> elements.
  
    @bool put_expansion_bits_in_leo_files = False

- Use uuid's?

- Remove spaces from user names.

.. @+node:ekr.20110609042343.16546: *7* Notes
.. @+node:ekr.20110609042343.16548: *8* File format, v3 draft 5
@language rest
@pagewidth 65

http://groups.google.com/group/leo-editor/browse_thread/thread/2ddb57c62e67825c

Leo's file format: version 3, draft 5

This draft is intended to reflect minimal changes from Leo's
present file format, but with improvements mentioned at the
Ashland sprint and developed afterward.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

This draft contains significant invention by EKR. See the next
section. Don't panic: it can be changed :-)

Summary of changes from draft 4
===============================

- Elements will be renamed as follows::

    old         new
    ====        ====
    <vnodes>    <directed-acyclic-graph>
    <tnodes>    <data-list>
    <v>         <node>
    <t>         <data>

- Nesting of <node> elements represents the structure of the DAG,
  just as nesting of <v> elements does at present.
  
- Thus, there will be no <edge> elements.

- Headlines will move from <v> elements to <data> elements.
  This "normalizes" the data: headlines will appear only once.
  
- <attr> elements will represent uA's.  A full discussion below.

  Ideally, I would like to support only string and json formats
  for <attr> elements.  This is open to discussion. 

- Only <node> elements will contain <attr> elements.

- <node> elements for @file nodes will contain
  <at-file-attributes> elements, representing Leo's "hidden
  machinery" attributes.  <at-file-attributes> will contain
  <attr> elements. 

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear within
<node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <directed-acyclic-graph>
        <node id="gnx">
            <!-- contained node elements, if any.
        </node>
        <node id="gnx">
            <!-- contained v elements, if any.
        </node>
        ...
    </directed-acyclic-graph>
    <data-list>
        <data id="gnx">
            <!-- marked attribute appears only if the tnode/vnode is marked -->
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </data>
        ...
    </data-list>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
The value will be a string by default.

If possible, I would like to support only the string and json
formats. This would make the data as transparent as possible.
Please mentally amend the following discussion...

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may optionally be contained in
the <node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
.. @+node:ekr.20110421132230.6107: *8* File format, v3 draft 4
@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in <attr> elements (and "type" in <edge> elements.)

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <at-file-attributes>
                <attr>key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx">value
                </attr>
                ...
            </at-file-attributes>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may be contained in the
<node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20110419083918.6104: *8* File format, v3 graphml
@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in <edge> elements if that
would be preferable.

Recent changes
==============

- Added <graphml> element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed <leo_file> to <leo:outline>
    - Renamed <descendant-attributes> to <leo:at-file-attributes>

- Used <leo:at-file-attributes> for marks, removing the special case.

- Enclosed <leo:descendant-attributes> in a (graphml) <data> element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <data>
                <leo:at-file-attributes>
                    <attr>key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx">value
                    </attr>
                    ...
                </leo:at-file-attributes>
            </data>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </graphml>
    </leo:outline>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <leo:at-file-attributes> element may be contained in the
<node> element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    <data>
        <leo:at-file-attributes>
            <attr>key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx">value
            </attr>
            ...
        </leo:at-file-attributes>
    </data>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20090218115025.3: *8* Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
.. @+node:ekr.20110415173840.6098: *7* Code related to uA's
.. @+node:ekr.20040701065235.2: *8* putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
.. @+node:ekr.20080805071954.2: *8* putDescendentVnodeUas
def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
.. @+node:EKR.20040526202501: *8* putUnknownAttributes
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
.. @+node:ekr.20090130114732.6: *8* v.u Property
def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
.. @+node:ekr.20120205022040.15412: *5* Refactor the key code (not urgent)
@nocolor-node
    
* Define k factory methods:
    
    k.makeKeyStroke(user_setting_string)
    k.makeKeyStrokeFromData(data)
    k.makeShortcutInfo(...)

* Refactor the Qt input code so it calls k.makeKeyStrokeFromData(data).
  This will require untangling the input code from event handling code.
.. @+node:ekr.20110605121601.18847: *6* create_key_event (leoGui)
def create_key_event (self,c,char,stroke,w,x=None,y=None,x_root=None,y_root=None):
    
    # Do not call strokeFromSetting here!
    # For example, this would wrongly convert Ctrl-C to Ctrl-c,
    # in effect, converting a user binding from Ctrl-Shift-C to Ctrl-C.

    return leoKeyEvent(c,char,stroke,w,x,y,x_root,y_root)
.. @+node:ekr.20110605121601.18537: *6* class leoQtEventFilter
class leoQtEventFilter(QtCore.QObject):

    << about internal bindings >>

    @others
.. @+node:ekr.20110605121601.18538: *7* << about internal bindings >>
@nocolor-node
@

Here are the rules for translating key bindings (in leoSettings.leo) into keys
for k.bindingsDict:

1.  The case of plain letters is significant:  a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore (with a
warning) the shift prefix applied to any other binding, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant. Thus, the Shift- prefix is required if you want an upper-case
letter (with the exception of 'bare' uppercase letters.)

The following table illustrates these rules. In each row, the first entry is the
key (for k.bindingsDict) and the other entries are equivalents that the user may
specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is consistent
with Tk's key-event specifiers). It is also, I think, the least confusing set of
rules.
.. @+node:ekr.20110605121601.18539: *7*  ctor (leoQtEventFilter)
def __init__(self,c,w,tag=''):

    # g.trace('leoQtEventFilter',tag,w)

    # Init the base class.
    QtCore.QObject.__init__(self)

    self.c = c
    self.w = w      # A leoQtX object, *not* a Qt object.
    self.tag = tag

    # Debugging.
    self.keyIsActive = False

    # Pretend there is a binding for these characters.
    close_flashers = c.config.getString('close_flash_brackets') or ''
    open_flashers  = c.config.getString('open_flash_brackets') or ''
    self.flashers = open_flashers + close_flashers
    
    # Support for ctagscompleter.py plugin.
    self.ctagscompleter_active = False
    self.ctagscompleter_onKey = None
.. @+node:ekr.20110605121601.18540: *7* eventFilter
def eventFilter(self, obj, event):

    trace = (False or g.trace_masterKeyHandler) and not g.unitTesting
    verbose = True
    traceEvent = False # True: call self.traceEvent.
    traceKey = (True or g.trace_masterKeyHandler)
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    gui = g.app.gui
    aList = []

    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]

    # Hack: QLineEdit generates ev.KeyRelease only on Windows,Ubuntu
    lineEditKeyKinds = [ev.KeyPress,ev.KeyRelease]

    # Important:
    # QLineEdit: ignore all key events except keyRelease events.
    # QTextEdit: ignore all key events except keyPress events.
    if eventType in lineEditKeyKinds:
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        self.keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        self.keyIsActive = False

    if eventType == ev.WindowActivate:
        gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType == ev.WindowDeactivate:
        gui.onDeactivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])
        # g.trace('instate',k.inState(),'tkKey',tkKey,'ignore',ignore,'len(aList)',len(aList))
        if ignore:
            override = False
        # This is extremely bad.
        # At present, it is needed to handle tab properly.
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        else:
            override = len(aList) > 0
    else:
        override = False ; tkKey = '<no key>'
        if self.tag == 'body':
            if eventType == ev.FocusIn:
                g.app.gui.add_border(c,obj)
                c.frame.body.onFocusIn(obj)
            elif eventType == ev.FocusOut:
                g.app.gui.remove_border(c,obj)
                c.frame.body.onFocusOut(obj)
        if self.tag in ('tree','log'):
            if eventType == ev.FocusIn:
                g.app.gui.add_border(c,obj)
            elif eventType == ev.FocusOut:
                g.app.gui.remove_border(c,obj)

    if self.keyIsActive:
        shortcut = self.toStroke(tkKey,ch) # ch is unused.

        if override:
            # Essentially *all* keys get passed to masterKeyHandler.
            if trace and traceKey:
                g.trace('ignore',ignore,'bound',repr(shortcut),repr(aList))
            w = self.w # Pass the wrapper class, not the wrapped widget.
            event = self.create_key_event(event,c,w,ch,tkKey,shortcut)
            ret = k.masterKeyHandler(event)
            c.outerUpdate()
        else:
            if trace and traceKey and verbose:
                g.trace(self.tag,'unbound',tkKey,shortcut)
        
        if trace and traceEvent:
            # Trace key events.
            self.traceEvent(obj,event,tkKey,override)

    elif trace and traceEvent:
        # Trace non-key events.
        self.traceEvent(obj,event,tkKey,override)

    return override
.. @+node:ekr.20110605195119.16937: *7* create_key_event (leoQtEventFilter)
def create_key_event (self,event,c,w,ch,tkKey,shortcut):

    trace = True and not g.unitTesting ; verbose = False
    
    if trace and verbose: g.trace('ch: %s, tkKey: %s, shortcut: %s' % (
        repr(ch),repr(tkKey),repr(shortcut)))
        
    # Last-minute adjustments...
    if shortcut == 'Return':
        ch = '\n' # Somehow Qt wants to return '\r'.
    elif shortcut == 'Escape':
        ch = 'Escape'

    # Switch the Shift modifier to handle the cap-lock key.
    if len(ch) == 1 and len(shortcut) == 1 and ch.isalpha() and shortcut.isalpha():
        if ch != shortcut:
            if trace and verbose: g.trace('caps-lock')
            shortcut = ch

    # Patch provided by resi147.
    # See the thread: special characters in MacOSX, like '@'.
    if sys.platform.startswith('darwin'):
        darwinmap = {
            'Alt-Key-5': '[',
            'Alt-Key-6': ']',
            'Alt-Key-7': '|',
            'Alt-slash': '\\',
            'Alt-Key-8': '{',
            'Alt-Key-9': '}',
            'Alt-e': '',
            'Alt-l': '@',
        }
        if tkKey in darwinmap:
            shortcut = darwinmap[tkKey]
            
    char = ch
    # Auxiliary info.
    x      = hasattr(event,'x') and event.x or 0
    y      = hasattr(event,'y') and event.y or 0
    # Support for fastGotoNode plugin
    x_root = hasattr(event,'x_root') and event.x_root or 0
    y_root = hasattr(event,'y_root') and event.y_root or 0
    
    if trace and verbose: g.trace('ch: %s, shortcut: %s printable: %s' % (
        repr(ch),repr(shortcut),ch in string.printable))
                
    return leoGui.leoKeyEvent(c,char,shortcut,w,x,y,x_root,y_root)
.. @+node:ekr.20120204061120.10088: *7* Key construction...
.. @+node:ekr.20110605121601.18543: *8* toTkKey & helpers (must not change!)
def toTkKey (self,event):
    
    '''Return tkKey,ch,ignore:
        
    tkKey: the Tk spelling of the event used to look up
           bindings in k.masterGuiBindingsDict.
           **This must not ever change!**
           
    ch:    the insertable key, or ''.
    
    ignore: True if the key should be ignored.
            This is **not** the same as 'not ch'.
    '''

    mods = self.qtMods(event)

    keynum,text,toString,ch = self.qtKey(event)

    tkKey,ch,ignore = self.tkKey(
        event,mods,keynum,text,toString,ch)

    return tkKey,ch,ignore
.. @+node:ekr.20110605121601.18546: *9* tkKey & helper
def tkKey (self,event,mods,keynum,text,toString,ch):

    '''Carefully convert the Qt key to a 
    Tk-style binding compatible with Leo's core
    binding dictionaries.'''

    trace = False and not g.unitTesting
    ch1 = ch # For tracing.
    use_shift = (
        'Home','End','Tab',
        'Up','Down','Left','Right',
        'Next','Prior', # 2010/01/10: Allow Shift-PageUp and Shift-PageDn.
        # 2011/05/17: Fix bug 681797.
        # There is nothing 'dubious' about these provided that they are bound.
        # If they are not bound, then weird characters will be inserted.
        'Delete','Ins','Backspace',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
    )

    # Convert '&' to 'ampersand', etc.
    # *Do* allow shift-bracketleft, etc.
    ch2 = self.char2tkName(ch or toString)
    if ch2: ch = ch2 
    if not ch: ch = ''

    if 'Shift' in mods:
        if trace: g.trace(repr(ch))
        if len(ch) == 1 and ch.isalpha():
            mods.remove('Shift')
            ch = ch.upper()
        elif len(ch) > 1 and ch not in use_shift:
            # Experimental!
            mods.remove('Shift')
        # 2009/12/19: Speculative.
        # if ch in ('parenright','parenleft','braceright','braceleft'):
            # mods.remove('Shift')
    elif len(ch) == 1:
        ch = ch.lower()

    if ('Alt' in mods or 'Control' in mods) and ch and ch in string.digits:
        mods.append('Key')

    # *Do* allow bare mod keys, so they won't be passed on.
    tkKey = '%s%s%s' % ('-'.join(mods),mods and '-' or '',ch)

    if trace: g.trace(
        'text: %s toString: %s ch1: %s ch: %s' % (
        repr(text),repr(toString),repr(ch1),repr(ch)))

    ignore = not ch # Essential
    ch = text or toString
    return tkKey,ch,ignore
.. @+node:ekr.20110605121601.18547: *10* char2tkName
char2tkNameDict = {
    # Part 1: same as g.app.guiBindNamesDict
    "&" : "ampersand",
    "^" : "asciicircum",
    "~" : "asciitilde",
    "*" : "asterisk",
    "@" : "at",
    "\\": "backslash",
    "|" : "bar",
    "{" : "braceleft",
    "}" : "braceright",
    "[" : "bracketleft",
    "]" : "bracketright",
    ":" : "colon",  
    "," : "comma",
    "$" : "dollar",
    "=" : "equal",
    "!" : "exclam",
    ">" : "greater",
    "<" : "less",
    "-" : "minus",
    "#" : "numbersign",
    '"' : "quotedbl",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright", 
    "%" : "percent",
    "." : "period",     
    "+" : "plus",
    "?" : "question",
    "`" : "quoteleft",
    ";" : "semicolon",
    "/" : "slash",
    " " : "space",      
    "_" : "underscore",
    # Part 2: special Qt translations.
    'Backspace':'BackSpace',
    'Backtab':  'Tab', # The shift mod will convert to 'Shift+Tab',
    'Esc':      'Escape',
    'Del':      'Delete',
    'Ins':      'Insert', # was 'Return',
    # Comment these out to pass the key to the QTextWidget.
    # Use these to enable Leo's page-up/down commands.
    'PgDown':    'Next',
    'PgUp':      'Prior',
    # New entries.  These simplify code.
    'Down':'Down','Left':'Left','Right':'Right','Up':'Up',
    'End':'End',
    'F1':'F1','F2':'F2','F3':'F3','F4':'F4','F5':'F5',
    'F6':'F6','F7':'F7','F8':'F8','F9':'F9',
    'F10':'F10','F11':'F11','F12':'F12',
    'Home':'Home',
    # 'Insert':'Insert',
    'Return':'Return',
    'Tab':'Tab',
    # 'Tab':'\t', # A hack for QLineEdit.
    # Unused: Break, Caps_Lock,Linefeed,Num_lock
}

# Called only by tkKey.

def char2tkName (self,ch):
    val = self.char2tkNameDict.get(ch)
    # g.trace(repr(ch),repr(val))
    return val
.. @+node:ekr.20120204061120.10087: *8* Common key construction helpers
.. @+node:ekr.20110605121601.18541: *9* isSpecialOverride
def isSpecialOverride (self,tkKey,ch):

    '''Return True if tkKey is a special Tk key name.
    '''

    return tkKey or ch in self.flashers
.. @+node:ekr.20110605121601.18542: *9* toStroke (leoQtEventFilter)
def toStroke (self,tkKey,ch):  # ch is unused
    
    '''Convert the official tkKey name to a stroke.'''

    trace = False and not g.unitTesting
    k = self.c.k ; s = tkKey

    table = (
        ('Alt-','Alt+'),
        ('Ctrl-','Ctrl+'),
        ('Control-','Ctrl+'),
        # Use Alt+Key-1, etc.  Sheesh.
        # ('Key-','Key+'),
        ('Shift-','Shift+')
    )
    for a,b in table:
        s = s.replace(a,b)

    if trace: g.trace('tkKey',tkKey,'-->',s)
    return s
.. @+node:ekr.20110605121601.18544: *9* qtKey
def qtKey (self,event):

    '''Return the components of a Qt key event.

    Modifiers are handled separately.
    
    Return keynum,text,toString,ch
    
    keynum: event.key()
    ch:     g.u(chr(keynum)) or '' if there is an exception.
    toString:
        For special keys: made-up spelling that become part of the setting.
        For all others:   QtGui.QKeySequence(keynum).toString()
    text:   event.text()
    '''

    trace = False and not g.unitTesting
    keynum = event.key()
    text   = event.text() # This is the unicode text.

    qt = QtCore.Qt
    d = {
        qt.Key_Shift:   'Key_Shift',
        qt.Key_Control: 'Key_Control',  # MacOS: Command key
        qt.Key_Meta:	'Key_Meta',     # MacOS: Control key, Alt-Key on Microsoft keyboard on MacOs.
        qt.Key_Alt:	    'Key_Alt',	 
        qt.Key_AltGr:	'Key_AltGr',
            # On Windows, when the KeyDown event for this key is sent,
            # the Ctrl+Alt modifiers are also set.
    }

    if d.get(keynum):
        toString = d.get(keynum)
    else:
        toString = QtGui.QKeySequence(keynum).toString()

    try:
        ch1 = chr(keynum)
    except ValueError:
        ch1 = ''

    try:
        ch = g.u(ch1)
    except UnicodeError:
        ch = ch1

    text     = g.u(text)
    toString = g.u(toString)

    if trace and self.keyIsActive:
        mods = '+'.join(self.qtMods(event))
        g.trace(
            'keynum %7x ch %3s toString %s %s' % (
            keynum,repr(ch),mods,repr(toString)))

    return keynum,text,toString,ch
.. @+node:ekr.20120204061120.10084: *9* qtMods
def qtMods (self,event):

    '''Return the text version of the modifiers of the key event.'''

    modifiers = event.modifiers()

    # The order of this table must match the order created by k.strokeFromSetting.
    # When g.new_keys is True, k.strokeFromSetting will canonicalize the setting.

    qt = QtCore.Qt
    
    if sys.platform.startswith('darwin'):
        # Yet another MacOS hack:
        table = (
            (qt.AltModifier,     'Alt'), # For Apple keyboard.
            (qt.MetaModifier,    'Alt'), # For Microsoft keyboard.
            (qt.ControlModifier, 'Control'),
            # No way to generate Meta.
            (qt.ShiftModifier,   'Shift'),
        )
        
    else:
        table = (
            (qt.AltModifier,     'Alt'),
            (qt.ControlModifier, 'Control'),
            (qt.MetaModifier,    'Meta'),
            (qt.ShiftModifier,   'Shift'),
        )

    mods = [b for a,b in table if (modifiers & a)]
    return mods
.. @+node:ekr.20110605121601.18548: *7* traceEvent
def traceEvent (self,obj,event,tkKey,override):

    if g.unitTesting: return
    
    traceFocus = False
    traceKey   = True
    traceLayout = False
    traceMouse = False
    
    c,e = self.c,QtCore.QEvent
    eventType = event.type()
    
    show = []
    
    ignore = [
        e.MetaCall, # 43
        e.Timer, # 1
        e.ToolTip, # 110
    ]
    
    focus_events = (
        (e.Enter,'enter'),
        (e.Leave,'leave'),
        (e.FocusIn,'focus-in'),
        (e.FocusOut,'focus-out'),
        (e.Hide,'hide'), # 18
        (e.HideToParent, 'hide-to-parent'), # 27
        (e.HoverEnter, 'hover-enter'), # 127
        (e.HoverLeave,'hover-leave'), # 128
        (e.HoverMove,'hover-move'), # 129
        (e.Show,'show'), # 17
        (e.ShowToParent,'show-to-parent'), # 26
        (e.WindowActivate,'window-activate'), # 24
        (e.WindowBlocked,'window-blocked'), # 103
        (e.WindowUnblocked,'window-unblocked'), # 104
        (e.WindowDeactivate,'window-deactivate'), # 25
    )
    key_events = (
        (e.KeyPress,'key-press'),
        (e.KeyRelease,'key-release'),
        (e.ShortcutOverride,'shortcut-override'),
    )
    layout_events = (
        (e.ChildPolished,'child-polished'), # 69
        #(e.CloseSoftwareInputPanel,'close-sip'), # 200
            # Event does not exist on MacOS.
        (e.ChildAdded,'child-added'), # 68
        (e.DynamicPropertyChange,'dynamic-property-change'), # 170
        (e.FontChange,'font-change'),# 97
        (e.LayoutRequest,'layout-request'),
        (e.Move,'move'), # 13 widget's position changed.
        (e.PaletteChange,'palette-change'),# 39
        (e.ParentChange,'parent-change'), # 21
        (e.Paint,'paint'), # 12
        (e.Polish,'polish'), # 75
        (e.PolishRequest,'polish-request'), # 74
        # (e.RequestSoftwareInputPanel,'sip'), # 199
            # Event does not exist on MacOS.
        (e.Resize,'resize'), # 14
        (e.StyleChange,'style-change'), # 100
        (e.ZOrderChange,'z-order-change'), # 126
    )
    mouse_events = (
        (e.MouseMove,'mouse-move'), # 155
        (e.MouseButtonPress,'mouse-press'), # 2
        (e.MouseButtonRelease,'mouse-release'), # 3
        (e.Wheel,'mouse-wheel'), # 31
    )
    
    option_table = (
        (traceFocus,focus_events),
        (traceKey,key_events),
        (traceLayout,layout_events),
        (traceMouse,mouse_events),
    )
    
    for option,table in option_table:
        if option:
            show.extend(table)
        else:
            for n,tag in table:
                ignore.append(n)

    for val,kind in show:
        if eventType == val:
            g.trace(
                '%5s %18s in-state: %5s key: %s override: %s: obj: %s' % (
                self.tag,kind,repr(c.k and c.k.inState()),tkKey,override,obj))
            return

    if eventType not in ignore:
        g.trace('%3s:%s obj:%s' % (eventType,'unknown',obj))
.. @+node:ekr.20110605195119.16937: *6* create_key_event (leoQtEventFilter)
def create_key_event (self,event,c,w,ch,tkKey,shortcut):

    trace = True and not g.unitTesting ; verbose = False
    
    if trace and verbose: g.trace('ch: %s, tkKey: %s, shortcut: %s' % (
        repr(ch),repr(tkKey),repr(shortcut)))
        
    # Last-minute adjustments...
    if shortcut == 'Return':
        ch = '\n' # Somehow Qt wants to return '\r'.
    elif shortcut == 'Escape':
        ch = 'Escape'

    # Switch the Shift modifier to handle the cap-lock key.
    if len(ch) == 1 and len(shortcut) == 1 and ch.isalpha() and shortcut.isalpha():
        if ch != shortcut:
            if trace and verbose: g.trace('caps-lock')
            shortcut = ch

    # Patch provided by resi147.
    # See the thread: special characters in MacOSX, like '@'.
    if sys.platform.startswith('darwin'):
        darwinmap = {
            'Alt-Key-5': '[',
            'Alt-Key-6': ']',
            'Alt-Key-7': '|',
            'Alt-slash': '\\',
            'Alt-Key-8': '{',
            'Alt-Key-9': '}',
            'Alt-e': '',
            'Alt-l': '@',
        }
        if tkKey in darwinmap:
            shortcut = darwinmap[tkKey]
            
    char = ch
    # Auxiliary info.
    x      = hasattr(event,'x') and event.x or 0
    y      = hasattr(event,'y') and event.y or 0
    # Support for fastGotoNode plugin
    x_root = hasattr(event,'x_root') and event.x_root or 0
    y_root = hasattr(event,'y_root') and event.y_root or 0
    
    if trace and verbose: g.trace('ch: %s, shortcut: %s printable: %s' % (
        repr(ch),repr(shortcut),ch in string.printable))
                
    return leoGui.leoKeyEvent(c,char,shortcut,w,x,y,x_root,y_root)
.. @+node:ekr.20070228160107: *6* class leoKeyEvent (leoGui.py)
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''
    
    @others

    def __repr__ (self):

        return 'leoKeyEvent: stroke: %s, char: %s, w: %s' % (
            repr(self.stroke),repr(self.char),repr(self.w))
            
    def type(self):
        return 'leoKeyEvent'
.. @+node:ekr.20110605121601.18846: *7* ctor (leoKeyEvent)
def __init__ (self,c,char,shortcut,w,x,y,x_root,y_root):
    
    trace = False and not g.unitTesting
    k = c.k
    
    if g.isStroke(shortcut):
        g.trace('***** (leoKeyEvent) oops: already a stroke',shortcut,g.callers())
        stroke = shortcut
    else:
        stroke = g.KeyStroke(shortcut) if shortcut else None

    assert g.isStrokeOrNone(stroke),'(leoKeyEvent) %s %s' % (
        repr(stroke),g.callers())
        
    if trace: g.trace('(leoKeyEvent) stroke',stroke)
    
    self.c = c
    self.char = char or ''
    self.stroke = stroke
    self.w = self.widget = w
    
    # Optional ivars
    self.x = x
    self.y = y

    # Support for fastGotoNode plugin
    self.x_root = x_root
    self.y_root = y_root
.. @+node:ekr.20110531190516.19365: *4* Maybe
@language rest

.. @+node:ekr.20110611043506.16494: *5*  Ashland sprint items: 3
.. @+node:ekr.20110527084258.18378: *6* New file format
@nocolor-node

** remove window state, expansion status etc.
   stuff from .leo file, and move that over to c.db

- <attr> solves pickle problem.

* Treat gnx's as strings: don't parse them.
  http://mail.google.com/mail/#inbox/12f3d4950fbabeea
  
* Don't save expansion bits in uA if not saving expansion bits. It's illogical
  to save bits in uA's if they aren't save in in the <v> elements.
  
    @bool put_expansion_bits_in_leo_files = False

- Use uuid's?

- Remove spaces from user names.

.. @+node:ekr.20110609042343.16546: *7* Notes
.. @+node:ekr.20110609042343.16548: *8* File format, v3 draft 5
@language rest
@pagewidth 65

http://groups.google.com/group/leo-editor/browse_thread/thread/2ddb57c62e67825c

Leo's file format: version 3, draft 5

This draft is intended to reflect minimal changes from Leo's
present file format, but with improvements mentioned at the
Ashland sprint and developed afterward.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

This draft contains significant invention by EKR. See the next
section. Don't panic: it can be changed :-)

Summary of changes from draft 4
===============================

- Elements will be renamed as follows::

    old         new
    ====        ====
    <vnodes>    <directed-acyclic-graph>
    <tnodes>    <data-list>
    <v>         <node>
    <t>         <data>

- Nesting of <node> elements represents the structure of the DAG,
  just as nesting of <v> elements does at present.
  
- Thus, there will be no <edge> elements.

- Headlines will move from <v> elements to <data> elements.
  This "normalizes" the data: headlines will appear only once.
  
- <attr> elements will represent uA's.  A full discussion below.

  Ideally, I would like to support only string and json formats
  for <attr> elements.  This is open to discussion. 

- Only <node> elements will contain <attr> elements.

- <node> elements for @file nodes will contain
  <at-file-attributes> elements, representing Leo's "hidden
  machinery" attributes.  <at-file-attributes> will contain
  <attr> elements. 

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear within
<node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <directed-acyclic-graph>
        <node id="gnx">
            <!-- contained node elements, if any.
        </node>
        <node id="gnx">
            <!-- contained v elements, if any.
        </node>
        ...
    </directed-acyclic-graph>
    <data-list>
        <data id="gnx">
            <!-- marked attribute appears only if the tnode/vnode is marked -->
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </data>
        ...
    </data-list>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
The value will be a string by default.

If possible, I would like to support only the string and json
formats. This would make the data as transparent as possible.
Please mentally amend the following discussion...

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may optionally be contained in
the <node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
.. @+node:ekr.20110421132230.6107: *8* File format, v3 draft 4
@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in <attr> elements (and "type" in <edge> elements.)

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <at-file-attributes>
                <attr>key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx">value
                </attr>
                ...
            </at-file-attributes>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may be contained in the
<node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20110419083918.6104: *8* File format, v3 graphml
@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in <edge> elements if that
would be preferable.

Recent changes
==============

- Added <graphml> element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed <leo_file> to <leo:outline>
    - Renamed <descendant-attributes> to <leo:at-file-attributes>

- Used <leo:at-file-attributes> for marks, removing the special case.

- Enclosed <leo:descendant-attributes> in a (graphml) <data> element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <data>
                <leo:at-file-attributes>
                    <attr>key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx">value
                    </attr>
                    ...
                </leo:at-file-attributes>
            </data>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </graphml>
    </leo:outline>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <leo:at-file-attributes> element may be contained in the
<node> element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    <data>
        <leo:at-file-attributes>
            <attr>key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx">value
            </attr>
            ...
        </leo:at-file-attributes>
    </data>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20090218115025.3: *8* Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
.. @+node:ekr.20110415173840.6098: *7* Code related to uA's
.. @+node:ekr.20040701065235.2: *8* putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
.. @+node:ekr.20080805071954.2: *8* putDescendentVnodeUas
def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
.. @+node:EKR.20040526202501: *8* putUnknownAttributes
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
.. @+node:ekr.20090130114732.6: *8* v.u Property
def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
.. @+node:ekr.20110528034751.18273: *6* Global search in Nav plugin?
.. @+node:ekr.20110613110911.16421: *6* Read/write files in json format
.. @+node:ekr.20051110155735.1: *5* Improve Spell tab & spell checker
@nocolor

- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.

@color
.. @+node:ekr.20090907080624.6081: *6* Spell checker should check headlines
.. @+node:ekr.20101004092958.5914: *5* Write treepad scanner
@ treepad.py is from the treepad website
.. @+node:ekr.20101004092958.5939: *6* treepad.py
@first #! /usr/local/bin/python

# treepad.py

@language python
@tabwidth -4
@others
if __name__ == '__main__':
    Main().Run()

.. @+node:ekr.20101004092958.5940: *7* treepad declarations
import sys, os, re, string

# constants
VERSION = "<Treepad version 2.7>"

# regexes
END_RE = re.compile(r'^<end node> ([^ ]+)$')
.. @+node:ekr.20101004092958.5941: *7* class Node
class Node:
    @others
.. @+node:ekr.20101004092958.5942: *8* __init__ (Node/treepad)
def __init__(self):
    self.title    = ""
    self.level    = 0
    self.article  = []
    self.children = []
    self.parent   = None
    self.end      = ""
.. @+node:ekr.20101004092958.5943: *8* __str__
def __str__(self):
    return "%s/%d" % (self.title, self.level)
.. @+node:ekr.20101004092958.5944: *8* addchild
def addchild(self, node):
    assert self.level == node.level-1 and node.parent is None
    node.parent = self
    self.children.append( node )
.. @+node:ekr.20101004092958.5945: *8* findparent
def findparent(self, node):
    if self.level == (node.level-1): return self
    return self.parent.findparent(node)
.. @+node:ekr.20101004092958.5946: *8* writenode
def writenode(self, fp):
    fp.write("dt=Text\n")
    fp.write("<node>\n")
    fp.write("%s\n" % self.title)
    fp.write("%s\n" % self.level)
    for line in self.article:
        fp.write("%s\n" % line)
    fp.write("<end node> %s\n" % self.end)
.. @+node:ekr.20101004092958.5947: *8* writetree
def writetree(self, fp):
    self.writenode(fp)
    for node in self.children:
        node.writetree(fp)

.. @+node:ekr.20101004092958.5948: *7* class NodeReader
class NodeReader:
    @others
.. @+node:ekr.20101004092958.5949: *8* __init__ (NodeReader)
def __init__(self, fname, fp):
    self.fname    = fname
    self.fp       = fp
.. @+node:ekr.20101004092958.5950: *8* expect
def expect(self, text, line=None):
    if line is None:
        line = self.fp.readline().strip()
    assert line == text, "expected " + line + " == " + text
.. @+node:ekr.20101004092958.5951: *8* readstart
def readstart(self):
    self.expect(VERSION)
.. @+node:ekr.20101004092958.5952: *8* readnode
def readnode(self):
    line = self.fp.readline()
    if line is None:
        return None
    line = line.strip()
    if len(line) < 1:
        return None
    self.expect("dt=Text", line)
    self.expect("<node>")
    node = Node()
    node.title = self.fp.readline().strip()
    node.level = int(self.fp.readline().strip())
    while 1:
        line = self.fp.readline()
        m = re.match(END_RE, line)
        if m:
            node.end = m.group(1).strip()
            break
        node.article.append( line.strip() )
    return node

.. @+node:ekr.20101004092958.5953: *7* class TreeReader
class TreeReader:
    @others
.. @+node:ekr.20101004092958.5954: *8* __init__(TreeReader)
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'r')
    self.nodereader = NodeReader(fname, fp)
    self.root = None
    self.prev = None
.. @+node:ekr.20101004092958.5955: *8* add
def add(self, node):
    if self.prev is None:
        assert node.level == 0
        self.root = node
    else:
        assert node.level > 0
        parent = self.prev.findparent(node)
        parent.addchild( node )
    self.prev = node
.. @+node:ekr.20101004092958.5956: *8* read
def read(self):
    self.nodereader.readstart()
    prev = None
    while 1:
        node = self.nodereader.readnode()
        if node is None: break
        self.add(node)

.. @+node:ekr.20101004092958.5957: *7* class TreeWriter
class TreeWriter:
    @others
.. @+node:ekr.20101004092958.5958: *8* __init__ (TreeWriter)
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'w')
    self.fname = fname
    self.fp    = fp
.. @+node:ekr.20101004092958.5959: *8* write
def write(self, root):
    self.fp.write("%s\n" % VERSION)
    root.writetree(self.fp)

.. @+node:ekr.20101004092958.5960: *7* class Main
class Main:
    @others
.. @+node:ekr.20101004092958.5961: *8* __init__ (Main)
def __init__(self):
    self.infile  = sys.argv[1]
    self.outfile = sys.argv[2]
    self.reader  = TreeReader(self.infile)
    self.writer  = TreeWriter(self.outfile)
.. @+node:ekr.20101004092958.5962: *8* Run

def Run(self):
    self.reader.read()
    self.writer.write(self.reader.root)

.. @+node:ekr.20110520051220.18203: *5* Cross-tab search
@language rest

This would be a substitute for cross-file clones.
.. @+node:ekr.20071001052501: *5* Versioning for nodes
@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
.. @+node:ekr.20080802070659.11: *5* Make node attributes visible, and supported by Leo's core
.. @+node:ekr.20110614123640.6587: *5* Add headline/color functions to Leo's core
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/7e279fe3dedf42be/f00fde4df5b39ded

What uA should be used to specify node colors?

if the foreground / background color API uses uAs,
would/should the uAs use the reserved "leo_&lt;something&gt;"
namespace?

-------------------

Terry Brown

Sounds like something I may have brought up, long ago.

I was thinking that setting the fore/background color of nodes in the
tree should be a "gui core" function, and that the info should be
stored in uA, and so wanted to know what key should be used in uA for
that.  I think the docs say top level keys starting with "leo_" are
reserved, and probably wanted a ruling on

v.u['leo_fg'] = 'red'

vs

v.u['leo_tree_style']['fg'] = 'red'

etc.

I think the question may be more complicated than just what to call the
key, so you can probably retire the todo item.
.. @+node:ekr.20100112051224.6226: *5* Vim-related: Range prefix to commands/objects (k.getArgs)
The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
.. @+node:ekr.20110601105631.19373: *6* Simple vim bindings
.. @+node:ekr.20110601105631.19374: *7* Cursors
Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
.. @+node:ekr.20110601105631.19375: *7* Enter insert mode after ctrl-h
.. @+node:ekr.20110601105631.19376: *7* Colorize headline text depending on state
.. @+node:ekr.20110601105631.19377: *7* colon destroys alt-x binding
This project reorganizes makeBindingFromCommandsDict
.. @+node:ekr.20110518103946.18179: *5* Add external/leosax.py to leoPyRef.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/93f2cc88ebbf9893

Would be ok with you if I pulled it into leoPy.leo, thereby adding sentinels to it? 
.. @+node:ekr.20090801103907.6018: *5* Add entries to global dicts for more languages (waiting for requests)
http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780

Especially languages in leo/modes.

** Only c.getOpenWithExt uses app.language_extension_dict.

I'll wait until I get requests for particular language.
.. @+node:ekr.20110528103005.18323: *6* Found: extension_dict
.. @+node:ekr.20080819075811.13: *7* adjustTargetLanguage
def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
.. @+node:ekr.20090212054250.9: *7* c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
.. @+node:ekr.20031218072017.2824: *7* c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    if trace: g.trace(ext)
    
    c = self
    
    if ext:
        for ch in ("'",'"'):
            if ext.startswith(ch): ext = ext.strip(ch)

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext
        
    if trace: g.trace(ext)

    return ext
.. @+node:EKR.20040504150046.4: *7* g.comment_delims_from_extension
def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    >>> import leo.core.leoGlobals as g
    >>> g.comment_delims_from_extension(".py")
    ('#', '', '')

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    >>> g.comment_delims_from_extension(".html")
    ('', '<!--', '-->')

    """

    if filename.startswith('.'):
        # Python 2.6 changes how splitext works.
        root,ext = None,filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension: %s, filename: %s, root: %s" % (
            repr(ext),repr(filename),repr(root)))
        return '','',''
.. @+node:ekr.20080811174246.1: *7* languageForExtension
def languageForExtension (self,ext):

    '''Return the language corresponding to the extension ext.'''

    unknown = 'unknown_language'

    if ext.startswith('.'): ext = ext[1:]

    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None,'none','None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None,'none','None'):
            language = unknown
    else:
        language = unknown

    # g.trace(ext,repr(language))

    # Return the language even if there is no colorizer mode for it.
    return language
.. @+node:ekr.20031218072017.368: *6* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "javascript"    : "// /* */", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "<%-- --%>", # EKR: 2011/11/25
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "matlab"        : "%", # EKR: 2011/10/21
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "javascript"    : "js", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "jsp", # EKR: 2011/11/25
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "matlab"        : "m", # EKR: 2011/10/21
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "js"    : "javascript", # EKR: 2011/11/12: For javascript import test.
    "jsp"   : "javaserverpage", # EKR: 2011/11/25: For @shadow.
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "m"     : "matlab", # EKR 2011/10/21
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
.. @+node:ekr.20110528103005.18319: *6* Script to global data structures from in modes/*.py files
import glob
import imp

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
aList = glob.glob(theDir)
theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes')

print('-'*40,len(aList))
known_keys = list(g.app.language_delims_dict.keys())
known_keys.sort()
known = []
computed = {}
for z in aList:
    name = g.os_path_basename(z)
    name2 = name[:-3]
    if name2.startswith('__'): continue
    # if name2 in known_keys:
        # known.append(name)
        # continue
    try:
        theFile, pathname, description = imp.find_module(name2,[theDir])
        m = imp.load_module(name2, theFile, pathname, description)
    except Exception:
        g.es_exception()
        m = None
    if m:
        aList2 = [m.properties.get(z)
            for z in ('lineComment','commentStart','commentEnd')
                if m.properties.get(z)]
        print('%-20s : "%s",' % (
            '"%s"' % (name2),
            ' '.join(aList2)))
        computed[name2] = ' '.join(aList2)
mismatches = 0
for z in known_keys:
    val = g.app.language_delims_dict.get(z)
    val2 = computed.get(z)
    if not val:
        print('oops: no val',z)
    elif not val2:
        print('oops: no val2',z)
    elif val != val2:
        mismatches += 1
        print('mismatch for %s' % z)
        print(repr(val))
        print(repr(val2))
print('%s total languages' % len(aList))
print('%s new languages' % (len(list(computed.keys())) - len(known_keys)))
print('%s mismatches' % mismatches)
print('%s known language: %s' % (len(known_keys),known_keys))
.. @+node:ekr.20111013065147.9424: *5* Code cleanup
.. @+node:ekr.20111012061216.15699: *6* ?use @g.command for all Leo commands?
.. @+node:ekr.20111010093113.15548: *6* Lighten Leo's code base; remove wrapper layers
@nocolor-node

Almost from day one, Leo has defined gui base classes in the core, and
subclasses in gui plugins.

I plan to continue that organization, but I would like to remove some of the
wrapping layers if possible. The present scheme has one or two too many
redirection layers, and they are more of a nuisance than a help.

One idea would be to define **interface classes** that define the desired api's.
Unit tests could test that subclass implements the interface class, without
having to resort to quite as much error-prone machinery as at present.
.. @+node:ekr.20110527225107.18351: *4* Vague
@language rest

**Important**: These items are not scheduled for any release. They will be done
only if there are specific requests for them.

Eventually, all these items will move to the dreaded to-do-later list.
.. @+node:ekr.20110529115328.18238: *5* Emacs related: 5
I'll do these if and and only if somebody asks for them.
.. @+node:ekr.20110529104352.18248: *6* Complete k.universalDispatcher
.. @+node:ekr.20110529104352.18249: *6* Complete number-to-register command
.. @+node:ekr.20031218072017.753: *6* Emacs comint-mode
@nocolor

The improved Execute Script command does most of this

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
.. @+node:ekr.20071004120359.2: *6* expand-region-abbrev
See: regionalExpandAbbrev.

You may wish to expand an abbrev with a prefix attached; for example, if `cnst'
expands into `construction', you might want to use it to enter `reconstruction'.
It does not work to type recnst, because that is not necessarily a defined
abbrev. What you can do is use the command M-' (abbrev-prefix-mark) in between
the prefix `re' and the abbrev `cnst'. First, insert `re'. Then type M-'; this
inserts a hyphen in the buffer to indicate that it has done its work. Then
insert the abbrev `cnst'; the buffer now contains `re-cnst'. Now insert a
non-word character to expand the abbrev `cnst' into `construction'. This
expansion step also deletes the hyphen that indicated M-' had been used. The
result is the desired `reconstruction'.

If you actually want the text of the abbrev in the buffer, rather than its
expansion, you can accomplish this by inserting the following punctuation with
C-q. Thus, foo C-q , leaves `foo,' in the buffer.
.. @+node:ekr.20060628103226.3: *6* Make sure repeat counts work on basic editing commands
.. @+node:ekr.20111027103125.16543: *4* Code related to docs
.. @+node:ekr.20111018104244.15931: *5* Add @command print-cmd-docstrings
Leo must have a check-doc-strings script that will verify that all
commands have non-trivial doc strings.

.. @+node:ekr.20111021105253.9476: *5* Make sure all colorizer languages have entries in leoApp.py
.. @+node:ekr.20111021035504.9469: *6* Script: get all comments from modes
import glob
import imp
@others

keys = ("lineComment","commentStart","commentEnd",)
d = {}
    # Keys are language names.
    # Values are a list of comment delims, in keys order.
paths,modes_path = get_paths()
for path in paths:
    module_name = g.shortFileName(path)[:-3]
    module = import_module(module_name,modes_path)
    aList = []
    for key in keys:
        val = module.properties.get(key)
        if val: aList.append(val)
    d[module_name] = aList

print('-'* 20)
print('language_delims_dict')
for key in sorted(d):
    print('%16s: "%s"' % ('"%s"' % (key),' '.join(d.get(key))))
.. @+node:ekr.20111021035504.9470: *7* get_paths
def get_paths():
    
    modes_path = g.os_path_finalize_join(g.app.loadDir,'..','modes')
    pattern = g.os_path_finalize_join(modes_path,'*.py')
    paths = glob.glob(pattern)
    paths = [z for z in paths if not z.endswith('__init__.py')]
    return paths,modes_path
.. @+node:ekr.20111021035504.9471: *7* import_module
def import_module(module_name,modes_path):
    
    data = imp.find_module(module_name,[modes_path])
        # This can open the file.
    theFile,pathname,description = data
    module = imp.load_module(module_name,theFile,pathname,description)
    return module
.. @+node:ekr.20111019104425.15865: *5* Make sure docstrings include present documentation
.. @+node:ekr.20111018220642.15862: *3* Plugins
.. @+node:ekr.20111017132257.15882: *4* Study import_xml plugin
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/b5c2982778a2df53

Provides commands (Alt-x) for importing and exporting XML from a Leo
outline. These commands are to XML what ``@auto-rst`` is to
reStructuredText.

``xml2leo`` imports an .xml file into the node following the currently
selected node.  ``leo2xml`` exports the current subtree to an .xml file
the user selects.

``xml_validate``, if executed on the top node in the
Leo xml tree, reports any errors in XML generation or DTD validation,
based on the DTD referenced from the XML itself.  If there's no DTD
it reports that as an error.

``leo2xml2leo`` takes the selected Leo subtree representing an XML file,
converts it to XML internally, and then creates a new Leo subtree from
that XML after the original, with 'NEW ' at the start of the top node's
name.  This updates all the headlines, so that the convenience only
previews (see below) are updated.  The original can be deleted if the
new subtree seems correct.

Conventions
===========

This is a valid XML file::

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE dml SYSTEM "dml.dtd">
    <?xml-stylesheet href="common.css"?>
    <dml xmlns='http://example.com/' xmlns:other='http://other.com/'/>
      <block type='example'>Here's <other:b>some</other:b> text</block>
    </dml>
    <!-- This is the last line -->

Note the processing instruction (xml-stylesheet), the DTD (DOCTYPE),
the trailing comment (after the closing tag), and the pernicious
mixed content (three separate pieces of text in the ``<block/>`` element).
These commands attempt to deal with all of this.

 - A top level Leo node is created to hold these top level parts.  Its
   headline is the basename of the file.
 - The xml declaration is placed in the body of
   this top level Leo node
 - Below that, in the same body text, appears a simple namespace map::

     http://example.com/
     other: http://other.com/
     ...

   i.e. the default namespace first, and then any prefixed name spaces.
 - Below that, in the same body text, appears the ``DOCTYPE`` declaration
 - Children are added to this top level Leo node to represent the
   top level elements in the xml file.  Headlines have the following
   meanings:

       - ``? pi-target some="other" __CHK`` - i.e. questionmark,
         space, name of processing instruction target, start of processing
         instruction content.  Only the questionmark, which indicates
         the processing instruction, and the first word, which indicates
         the processing instruction target, matter.  The remainder is just
         a convenience preview of the processing instruction content, which
         is the Leo node's body text.

       - ``# This is *really* imp`` - i.e. hash,
         space, start of comment content.  Only the hash, which indicates
         the comment, matters.  The remainder is just
         a convenience preview of the comment content, which
         is the Leo node's body text.

       - ``tagname name_attribute start of element text`` - i.e. the name
         of an element followed by a convenience preview of the element's
         text content.  If the element has a ``name`` attribute that's
         included at the start of the text preview.  Only the first word
         matters, it's the name of the element.

 - Element's text is placed in the Leo node's body.  If the element has
   tailing text (the ``" text"`` tailing the ``<other:b/>`` element
   in the above example), that occurs in the Leo node's body separated
   by the `tailing text sentinel`::

       @________________________________TAIL_TEXT_______________________________

 - Element's attributes are stored in a dict ``p.v.u['_XML']['_edit']``
   on the Leo node. ``'_XML'`` is the uA prefix for these commands, and
   ``'_edit'`` is used by the ``attrib_edit`` plugin to identify
   attributes it should present to the user for editing. The
   ``attrib_edit`` plugin **should be enabled** and its ``v.u mode``
   activated (through its submenu on the Plugins menu). The attribute
   edit panel initially appears as a tab in the log pane, although it
   can be moved around by right clicking on the pane dividers if the
   ``viewrendered`` and ``free_layout`` plugins are enabled. 
.. @+node:ekr.20111004090723.15495: *4* Finish leoOPML plugin
.. @+node:ekr.20111027143736.16557: *4* Study leo_screen
@nocolor-node

Ville mentioned leoremote for driving Leo from the command line.
There's also leoscreen, for driving the command line from Leo,
providing you use screen, which is probably unix/cygwin only.
.. @+node:ekr.20111019104425.15861: *3* Scripts
.. @+node:ekr.20111018104244.15932: *4* Write create-command-docs script
@language rest

This will create large docs for individual commands from docstrings.

Base this on print-cmd-docstrings.
.. @+node:ekr.20111018104244.15933: *4* Write create-plugins-doc script (Use/adapt plugin_catalog.py)
@language rest

Leo must have a create-plugins-doc script that does the same for
plugins.  A prototype of this script exists somewhere.  Making it an
@command node will make it much more visible. 

Terry wrote plugin_catalog.py.  It is in LeoDocs.leo)
.. @+node:ekr.20110917104720.9418: *4* convert-names-to-pep8
.. @+node:ekr.20110918204546.6809: *4* convert-to-class
.. @+node:ekr.20111109083738.9798: *3* Testing
.. @+node:ekr.20111105222316.9706: *4* Unit test: no unit tests omitted
@nocolor-node

Create a "registry" of unit tests.  Verify that unitTest.leo contains them all.
.. @+node:ekr.20111105222316.9707: *4* Unit test: importing a plugin changes nothing
@nocolor-node

Menu and plugin registry methods can fail if that *particular* unit test is running.
.. @+node:ekr.20111114151846.9856: *4* Create unit test that verifies class relationships
.. @+node:ekr.20111114102224.9936: *5* << define class HighLevelInterface >>
class HighLevelInterface(object):
    
    '''A class to specify Leo's high-level editing interface
    used throughout Leo's core.
    
    The interface has two parts:
        
    1. Standard (immutable) methods that will never be overridden.
    
    2. Other (mutable) methods that subclasses may override.
    '''
    
    @others
.. @+node:ekr.20111114102224.9950: *6* ctor (HighLevelInterface)
def __init__ (self,c):
    
    self.c = c
    
    self.widget = None
    
    self.mutable_methods = (
        'flashCharacter',
        'toPythonIndex',
        'toPythonIndexRowCol',
        # 'toGuiIndex', # A synonym.
    )
.. @+node:ekr.20111114102224.9935: *6* mutable methods (HighLevelInterface)
.. @+node:ekr.20111114102224.9946: *7* flashCharacter
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):
    pass
    
.. @+node:ekr.20111114102224.9943: *7* toPythonIndex (HighLevelInterface)
def toPythonIndex (self,index):
    
    s = self.getAllText()
    return g.toPythonIndex(s,index)

toGuiIndex = toPythonIndex
.. @+node:ekr.20111114102224.9945: *7* toPythonIndexRowCol (BaseTextWidget)
def toPythonIndexRowCol(self,index):
    
    # This works, but is much slower that the leoQTextEditWidget method.
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row,col = g.convertPythonIndexToRowCol(s,i)
    return i,row,col
.. @+node:ekr.20111114102224.9937: *6* immutable redirection methods (HighLevelInterface)
def appendText(self,s):
    if self.widget: self.widget.appendText(s)
def delete(self,i,j=None):
    if self.widget: self.widget.delete(i,j)
def deleteTextSelection (self):
    if self.widget: self.widget.deleteTextSelection()
def get(self,i,j):
    return self.widget and self.widget.get(i,j) or ''
def getAllText(self):
    return self.widget and self.widget.getAllText() or ''
def getInsertPoint(self):
    return self.widget and self.widget.getInsertPoint() or 0
def getSelectedText(self):
    return self.widget and self.widget.getSelectedText() or ''
def getSelectionRange (self):
    return self.widget and self.widget.getSelectionRange() or (0,0)
def getYScrollPosition (self):
    return self.widget and self.widget.getYScrollPosition() or 0
def hasSelection(self):
    # Take special care with this, for the benefit of LeoQuickSearchWidget.
    # This problem only happens with the qttabs gui.
    w = self.widget
    return bool(w and hasattr(w,'hasSelection') and w.hasSelection())
def insert(self,i,s):
    if self.widget: self.widget.insert(i,s)    
def replace (self,i,j,s):
    if self.widget: self.widget.replace(i,j,s)
def see(self,i):
    if self.widget: self.widget.see(i)
def seeInsertPoint (self):
    if self.widget: self.widget.seeInsertPoint()
def selectAllText (self,insert=None):
    if self.widget: self.widget.selectAllText(insert)
def setAllText (self,s):
    if self.widget: self.widget.setAllText(s)
def setBackgroundColor(self,color):
    if self.widget: self.widget.setBackgroundColor(color)
def setFocus(self):
    if self.widget: self.widget.setFocus()
def setForegroundColor(self,color):
    if self.widget: self.widget.setForegroundColor(color)
def setInsertPoint(self,pos):
    if self.widget: self.widget.setInsertPoint(pos)
def setSelectionRange (self,i,j,insert=None):
    if self.widget: self.widget.setSelectionRange(i,j,insert=insert)
def setYScrollPosition (self,i):
    if self.widget: self.widget.setYScrollPosition(i)
def tag_configure (self,colorName,**keys):
    if self.widget: self.widget.tag_configure(colorName,**keys)
.. @+node:ekr.20111114102224.9940: *6* other immutable methods (HighLevelInterface)
# These all use leoGlobals functions or leoGui methods.

def clipboard_append(self,s):
    s1 = g.app.gui.getTextFromClipboard()
    g.app.gui.replaceClipboardWith(s1 + s)
    
def clipboard_clear (self):
    g.app.gui.replaceClipboardWith('')
    
def getFocus(self):
    return g.app.gui.get_focus(self.c)
    
def rowColToGuiIndex (self,s,row,col):
    return g.convertRowColToPythonIndex(s,row,col)   
    
# def rowColToGuiIndex (self,s,row,col):
    # return self.widget and self.widget.rowColToGuiIndex(s,row,col) or 0 

set_focus = setFocus
.. @+node:ekr.20111114102224.9950: *5* ctor (HighLevelInterface)
def __init__ (self,c):
    
    self.c = c
    
    self.widget = None
    
    self.mutable_methods = (
        'flashCharacter',
        'toPythonIndex',
        'toPythonIndexRowCol',
        # 'toGuiIndex', # A synonym.
    )
.. @+node:ekr.20111114151846.9852: *5* mustBeDefined...
.. @+node:ekr.20111114151846.9850: *6* From baseTextWidget
.. @+node:ekr.20081031074455.3: *7* baseTextWidget.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'clipboard_append', # uses g.app.gui method.
    'clipboard_clear', # usesg.app.gui method.
)
.. @+node:ekr.20081031074455.4: *7* baseTextWidget.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    'appendText',
    'delete',
    'deleteTextSelection',
    'get',
    'getAllText',
    'getFocus',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionRange',
    'getYScrollPosition',
    'insert',
    'see',
    'seeInsertPoint',
    'setAllText',
    'setBackgroundColor',
    'setForegroundColor',
    'setFocus',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
)

.. @+node:ekr.20081031074455.5: *7* baseTextWidget.mustBeDefined...
# These can be do-nothings
mustBeDefined = (
    'flashCharacter',
    'hasSelection',
    'replace',
    'rowColToGuiIndex',
    'selectAllText',
    'tag_configure',
    'toGuiIndex',
    'toPythonIndex',
    'toPythonIndexRowCol',
)
.. @+node:ekr.20111114151846.9851: *6* From leoBody
.. @+node:ekr.20081005065934.9: *7* leoBody.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'after_idle',
    'forceFullRecolor', # The base-class method is usually good enough.
    'initAfterLoad',
    'tag_configure', # used in qtGui.py.
)
.. @+node:ekr.20031218072017.3660: *7* leoBody.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Birth, death & config.
    '__init__',
    'createBindings',
    'createControl',
    'setColorFromConfig',
    'setFontFromConfig'
    # Editors
    'createEditorLabel',
    'setEditorColors',
    # Events...
    'scheduleIdleTimeRoutine',
    # Low-level gui...(May be deleted)
    'getBodyPaneHeight',
    'getBodyPaneWidth',
    'hasFocus',
    'setFocus',
)
.. @+node:ekr.20061109102912: *7* define leoBody.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'getAllText',
    'getColorizer',
    'getInsertLines',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionAreas',
    'getSelectionLines',
    'getYScrollPosition',
    'hasSelection',
    'oops',
    'onBodyChanged',
    'recolor',
    'recolor_now',
    'see',
    'seeInsertPoint',
    'selectAllText',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
    'setSelectionAreas',
    'setYScrollPosition',
    'updateSyntaxColorer',
)
.. @+node:ekr.20111114151846.9853: *6* from leoFrame
.. @+node:ekr.20080429051644.1: *7* leoFrame.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (

    # Icon bar convenience methods.    
    'addIconButton',
    'addIconRow',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'getNewIconFrame',
    'hideIconBar',
    'initAfterLoad',
    'initCompleteHint',
    'showIconBar',
)
.. @+node:ekr.20061109120726: *7* leoFrame.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (

    'createFirstTreeNode', # New in Leo 4.6: was defined in tkTree.
    'initialRatios',
    'longFileName',
    'oops',
    'promptForSave',
    'scanForTabWidth',
    'shortFileName',

    # Headline editing.
    'abortEditLabelCommand',
    'endEditLabelCommand',
    'insertHeadlineTime',

    # Cut/Copy/Paste.
    'OnPaste',
    'OnPasteFromMenu',
    'copyText',
    'cutText',
    'pasteText',

    # Status line convenience methods.
    'createStatusLine',
    'clearStatusLine',
    'disableStatusLine',
    'enableStatusLine',
    'getStatusLine',
    'getStatusObject',
    'putStatusLine',
    'setFocusStatusLine',
    'statusLineIsEnabled',
    'updateStatusLine',
)
.. @+node:ekr.20061109120704: *7* leoFrame.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    #Gui-dependent commands.
    'cascade',
    'contractBodyPane',
    'contractLogPane',
    'contractOutlinePane',
    'contractPane',
    'equalSizedPanes',
    'expandLogPane',
    'expandPane',
    'fullyExpandBodyPane',
    'fullyExpandLogPane',
    'fullyExpandOutlinePane',
    'fullyExpandPane',
    'hideBodyPane',
    'hideLogPane',
    'hideLogWindow',
    'hideOutlinePane',
    'hidePane',
    'leoHelp',
    'minimizeAll',
    'resizeToScreen',
    'toggleActivePane',
    'toggleSplitDirection',
    # Windowutilities...
    'bringToFront',
    'deiconify',
    'get_window_info',
    'lift',
    'update',
    # Config...
    'resizePanesToRatio',
    'setInitialWindowGeometry',
    'setTopGeometry',
)
.. @+node:ekr.20111114151846.9854: *6* from leoTree
.. @+node:ekr.20081005065934.7: *7* leoTree.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'initAfterLoad', # New in Leo 4.6.
    'treeSelectHint', # New in Leo 4.6.
)
.. @+node:ekr.20061109164512: *7* leoTree.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    # Getters & setters.
    'editPosition',
    'getEditTextDict',
    'setEditPosition',
    # Others.
    'endEditLabel',
    # 'expandAllAncestors', # Now defined in Commands class.
    'injectCallbacks',
    'OnIconDoubleClick',
    'onHeadChanged',
    'onHeadlineKey',
    'updateHead',
    'oops',
)
.. @+node:ekr.20061109164610: *7* leoTree.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Colors & fonts.
    'getFont',
    'setFont',
    'setFontFromConfig ',
    # Drawing & scrolling.
    'drawIcon',
    'redraw_now',
    'scrollTo',
    # Headlines.
    'editLabel',
    # 'setEditLabelState',
    # Selecting.
    # 'select', # Defined in base class, may be overridden in do-nothing subclasses.
)
.. @+node:ekr.20111114151846.9855: *6* from leoGui
.. @+node:ekr.20061109211054: *7* leoGui.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'guiName',
    'oops',
    'setScript',
    'widget_name',
)
.. @+node:ekr.20061109211022: *7* leoGui.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Startup & shutdown
    'attachLeoIcon',
    'center_dialog',
    'color',
    #'createComparePanel',          # optional
    #'createFindPanel',             # optional
    'createFindTab',
    # 'createKeyHandlerClass',
    'createLeoFrame',
    'createRootWindow',
    'create_labeled_frame',
    'destroySelf',
    #'eventChar',
    #'eventKeysym',
    'eventWidget',
    # 'eventXY',
    # 'finishCreate', # optional.
    # 'getFontFromParams', # optional
    # 'getFullVersion', # optional.
    'getTextFromClipboard',
    'get_focus',
    'get_window_info',
    'isTextWidget',
    # 'keysym',
    'killGui',
    # 'makeScriptButton', # optional
    'recreateRootWindow',
    'replaceClipboardWith',
    'runAboutLeoDialog',
    'runAskLeoIDDialog',
    'runAskOkCancelNumberDialog',
    'runAskOkDialog',
    'runAskYesNoCancelDialog',
    'runAskYesNoDialog',
    'runMainLoop',
    'runOpenFileDialog',
    'runSaveFileDialog',
    'set_focus',
    #'setIdleTimeHook',             # optional       
    #'setIdleTimeHookAfterDelay',   # optional
)
.. @-all
.. @-leo
