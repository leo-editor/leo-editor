.. @+leo-ver=5-thin
.. @+node:ekr.20100119205347.6015: * @file ../doc/leoToDo.txt
.. @@language rest # override the default .txt coloring.
.. @@wrap
.. @+all
.. @+node:ekr.20150227040245.4: ** To do: Leo 5.1 b1
@language rest
@wrap

.. @+node:ekr.20150319055953.12: *3* Should updating an @clean node mark it dirty?
Changed 3.
.. @+node:ekr.20150319055953.11: *3* Improve <?xml-stylesheet>
Set default for @string stylesheet so it generates::

    <?xml-stylesheet type="text/xsl" href="ekr_test"?>
.. @+node:ekr.20150319055953.4: *3* Relocate remove-sentinels
It is an import command, not an export command.
.. @+node:ekr.20150304232409.4: *3* Docs
.. @+node:ekr.20150304232409.5: *4* document --diff
Search for added --diff
.. @+node:ekr.20150307034303.6: *4* Document nodes-dark icons & stylesheet
https://groups.google.com/d/msg/leo-editor/BrruEaWaX4Y/A0g4HQFvNtAJ
By Andrea Nuvola

To set the collapsed/expanded node images, one can add the following sections
to a theme settings tree (in my case, I put them in the body of the 
"Non-color styles (fonts etc.)/tree" node of the "leo_dark_0" theme):

QTreeView::branch:closed:has-children{
   image: url("<home directory>/.leo/icons/nodes-dark/closed.png");
}

QTreeView::branch:open:has-children{
   image: url("<home directory>/.leo/icons/nodes-dark/open.png");
}

I attach the images I use for my solarized dark theme, both small triangles and plus/minus signs, in case they can be useful.
.. @+node:ekr.20150315132217.1621: *4* Search g.command for missing docstrings
.. @+node:ekr.20150315132217.1638: *4* remove open-offline-tutorial
.. @+node:ekr.20150227040245.5: *3* Bugs for b1
.. @+node:ekr.20150211104036.4: *4* Fix bugs 135 & 141: DnD & paste-retaing-clones
https://github.com/leo-editor/leo-editor/issues/135
drag and drop between trees broken

This may also affect paste-retaining-clones.
https://github.com/leo-editor/leo-editor/issues/141

4f848037424544e127166dbb0375f90c6826aa21 is the first bad commit
Author: Me
Date:   Fri Sep 13 16:44:33 2013 -0500
Tag: Bug-135
.. @+node:ekr.20150311051910.4: *4* Improve recovered nodes operation.
@nocolor-node

- Detect changes in root node, if possible.
- Detect changes in headlines, if possible.
.. @+node:ekr.20150311123850.7: *4* Improve --diff
The --diff option is not very useful as a git diff.
.. @+node:ekr.20150312080344.4: *4* Improve speed of spelling
@language rest

Why is spell-checking so slow?

Trick: Spell-check just desired clone (at bottom of file).

Substitute for the lack of an "outline-only" button in the spell tab.
.. @+node:ekr.20150302140653.4: *3* Bugs for b1/b2
.. @+node:ekr.20141223150820.4: *4* Fix bug 122: @auto-rst should add an empty line after a heading
@language rest

https://github.com/leo-editor/leo-editor/issues/122

When one generates a node (call it Placeholder) without
any contents, then the resulting rst file is written like:

Placeholder
***********
Summary
*******

That is, there is no space between the two headings. Then if I do Refresh
from disk, @auto-rst yields an error. This should not happen if @auto-rst
automatically writes an empty line after each heading.
.. @+node:ekr.20130806072439.20650: *4* Fix bug 106: brew install leo
@language rest

https://github.com/leo-editor/leo-editor/issues/106

https://github.com/ska-sa/homebrew-tap/blob/master/leo.rb

http://brew.sh/

https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/Formula-Cookbook.md

Do this after creating official release.

@language ruby
@tabwidth -2
.. @+node:ekr.20141210123805.4: *5* brew install (original)
require 'formula'

class Leo < Formula
  homepage 'http://leoeditor.com/'
  url 'http://sourceforge.net/projects/leo/files/Leo/4.10%20final/Leo-4.10-final.zip'
  sha1 '1988c54d34d2233eda7ba2faa02066ff02575fec'
  head 'https://code.launchpad.net/leo-editor', :using => :bzr
  devel do
    url 'http://sourceforge.net/projects/leo/files/Leo/4.11-a2/Leo-4.11-a2.zip'
    sha1 '435c023df4d7b378ba10594a4b46ca83e82fc6b2'
  end

  depends_on 'pyqt'
  depends_on 'enchant' => :recommended

  def install
    # Obtain information on Python installation
    python_xy = "python" + %x(python -c 'import sys;print(sys.version[:3])').chomp
    python_site_packages = lib + "#{python_xy}/site-packages"
    python_site_packages.install 'leo'
    bin.install ['launchLeo.py', 'profileLeo.py']
    ln_s "#{bin}/launchLeo.py", "#{bin}/leo"
  end

  test do
    if system "python -c 'import leo'" then
      onoe 'Leo FAILED'
    else
      ohai 'Leo OK'
    end
  end
end
.. @+node:ekr.20141210123805.5: *5* brew install (new)
require 'formula'

class Leo < Formula

  homepage 'http://leoeditor.com/'
  url 'http://sourceforge.net/projects/leo/files/Leo/5.0-final/Leo-5.0-final.zip'
  sha1 '9a8ca37688e60851b4faea3adfa30aae2156eb9f'
  
  head https://github.com/leo-editor/leo-editor, :using => :git

  depends_on 'pyqt'
  depends_on 'enchant' => :recommended

  def install
    # Obtain information on Python installation
    python_xy = "python" + %x(python -c 'import sys;print(sys.version[:3])').chomp
    python_site_packages = lib + "#{python_xy}/site-packages"
    python_site_packages.install 'leo'
    bin.install ['launchLeo.py', 'profileLeo.py']
    ln_s "#{bin}/launchLeo.py", "#{bin}/leo"
  end

  test do
    if system "python -c 'import leo'" then
      onoe 'Leo FAILED'
    else
      ohai 'Leo OK'
    end
  end
end
.. @+node:ekr.20150227040245.11: *4* Fix bug 143: dabbrev-expand broken
https://github.com/leo-editor/leo-editor/issues/143

https://groups.google.com/d/msg/leo-editor/5yVJzLzeOtA/atuE-qhJll8J

On Tue, Dec 30, 2014 at 8:33 PM, 翅膀 <wzy3721@gmail.com> wrote:

    *
    editor panel text

    main
    m
     
    *  press  alt + /

    minibuffer show :

    dabbrev-expand: main

    * press enter

            editor panel text
           
            main
            m
.. @+node:ekr.20150211104036.7: *4* Fix bug 127: Bracket matching is buggy
https://github.com/leo-editor/leo-editor/issues/127

Bracket matching should take into account the language in effect.

For example, JavaScript regular expressions are not handled properly.

Furthermore, there should be a command to select the region between
matching brackets.
.. @+node:ekr.20150316141655.14: *4* Better default for open/save file dialogs?
# Maybe the directory of c.fileName.
.. @+node:ekr.20110605121601.18487: *5* LeoQtGui.Dialogs & panels
.. @+node:ekr.20110605121601.18488: *6* LeoQtGui.alert
def alert (self,c,message):

    if g.unitTesting: return

    b = QtWidgets.QMessageBox
    d = b(None)
    d.setWindowTitle('Alert')
    d.setText(message)
    d.setIcon(b.Warning)
    d.addButton('Ok',b.YesRole)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False
.. @+node:ekr.20110605121601.18489: *6* LeoQtGui.makeFilter
def makeFilter (self,filetypes):

    '''Return the Qt-style dialog filter from filetypes list.'''

    filters = ['%s (%s)' % (z) for z in filetypes]

    return ';;'.join(filters)
.. @+node:ekr.20110605121601.18492: *6* LeoQtGui.panels
def createComparePanel(self,c):
    """Create a qt color picker panel."""
    return None # This window is optional.

def createFindTab (self,c,parentFrame):
    """Create a qt find tab in the indicated frame."""
    pass # Now done in dw.createFindTab.

def createLeoFrame(self,c,title):
    """Create a new Leo frame."""
    gui = self
    return qt_frame.LeoQtFrame(c,title,gui)

def createSpellTab(self,c,spellHandler,tabName):
    return qt_frame.LeoQtSpellTab(c,spellHandler,tabName)
.. @+node:ekr.20110605121601.18493: *6* LeoQtGui.runAboutLeoDialog
def runAboutLeoDialog(self,c,version,theCopyright,url,email):

    """Create and run a qt About Leo dialog."""

    if g.unitTesting: return None

    b = QtWidgets.QMessageBox
    d = b(c.frame.top)

    d.setText('%s\n%s\n%s\n%s' % (
        version,theCopyright,url,email))
    d.setIcon(b.Information)
    yes = d.addButton('Ok',b.YesRole)
    d.setDefaultButton(yes)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False
.. @+node:ekr.20110605121601.18496: *6* LeoQtGui.runAskDateTimeDialog
def runAskDateTimeDialog(self, c, title, 
    message='Select Date/Time', init=None, step_min={}):
    """Create and run a qt date/time selection dialog.

    init - a datetime, default now
    step_min - a dict, keys are QtWidgets.QDateTimeEdit Sections, like
      QtWidgets.QDateTimeEdit.MinuteSection, and values are integers,
      the minimum amount that section of the date/time changes
      when you roll the mouse wheel.

    E.g. (5 minute increments in minute field):

        print g.app.gui.runAskDateTimeDialog(c, 'When?',
          message="When is it?",
          step_min={QtWidgets.QDateTimeEdit.MinuteSection: 5})

    """

    class DateTimeEditStepped(QtWidgets.QDateTimeEdit):
        """QDateTimeEdit which allows you to set minimum steps on fields, e.g.
          DateTimeEditStepped(parent, {QtWidgets.QDateTimeEdit.MinuteSection: 5})
        for a minimum 5 minute increment on the minute field.
        """
        def __init__(self, parent=None, init=None, step_min={}):

            self.step_min = step_min
            if init:
                QtWidgets.QDateTimeEdit.__init__(self, init, parent)
            else:
                QtWidgets.QDateTimeEdit.__init__(self, parent)

        def stepBy(self, step):
            cs = self.currentSection()
            if cs in self.step_min and abs(step) < self.step_min[cs]:
                step = self.step_min[cs] if step > 0 else -self.step_min[cs]
            QtWidgets.QDateTimeEdit.stepBy(self, step)

    class Calendar(QtWidgets.QDialog):
        def __init__(self, parent=None, message='Select Date/Time',
            init=None, step_min={}):
            QtWidgets.QDialog.__init__(self, parent)

            layout = QtWidgets.QVBoxLayout()
            self.setLayout(layout)

            layout.addWidget(QtWidgets.QLabel(message))

            self.dt = DateTimeEditStepped(init=init, step_min=step_min)
            self.dt.setCalendarPopup(True)
            layout.addWidget(self.dt)

            buttonBox = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok
                | QtWidgets.QDialogButtonBox.Cancel)
            layout.addWidget(buttonBox)

            buttonBox.accepted.connect(self.accept)
            buttonBox.rejected.connect(self.reject)

    if g.unitTesting: return None

    b = Calendar
    if not init:
        init = datetime.datetime.now()
    d = b(c.frame.top, message=message, init=init, step_min=step_min)

    d.setWindowTitle(title)

    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False

    if val != d.Accepted:
        return None
    else:
        return d.dt.dateTime().toPyDateTime()
.. @+node:ekr.20110605121601.18494: *6* LeoQtGui.runAskLeoIDDialog
def runAskLeoIDDialog(self):

    """Create and run a dialog to get g.app.LeoID."""

    if g.unitTesting: return None

    message = (
        "leoID.txt not found\n\n" +
        "Please enter an id that identifies you uniquely.\n" +
        "Your cvs/bzr login name is a good choice.\n\n" +
        "Leo uses this id to uniquely identify nodes.\n\n" +
        "Your id must contain only letters and numbers\n" +
        "and must be at least 3 characters in length.")
    parent = None
    title = 'Enter Leo id'
    s,ok = QtWidgets.QInputDialog.getText(parent,title,message)
    return g.u(s)
.. @+node:ekr.20110605121601.18491: *6* LeoQtGui.runAskOkCancelNumberDialog
def runAskOkCancelNumberDialog(self,c,title,message,cancelButtonText=None,okButtonText=None):

    """Create and run askOkCancelNumber dialog ."""

    if g.unitTesting: return None

    # n,ok = QtWidgets.QInputDialog.getDouble(None,title,message)
    d = QtWidgets.QInputDialog()
    d.setWindowTitle(title)
    d.setLabelText(message)
    if cancelButtonText:
        d.setCancelButtonText(cancelButtonText)
    if okButtonText:
        d.setOkButtonText(okButtonText)
    self.attachLeoIcon(d)
    ok = d.exec_()
    n = d.textValue()
    try:
        n = float(n)
    except ValueError:
        n = None
    return n if ok else None
.. @+node:ekr.20110605121601.18490: *6* LeoQtGui.runAskOkCancelStringDialog
def runAskOkCancelStringDialog(self,c,title,message,cancelButtonText=None,
                               okButtonText=None,default=""):

    """Create and run askOkCancelString dialog ."""

    if g.unitTesting: return None

    d = QtWidgets.QInputDialog()
    d.setWindowTitle(title)
    d.setLabelText(message)
    d.setTextValue(default)
    if cancelButtonText:
        d.setCancelButtonText(cancelButtonText)
    if okButtonText:
        d.setOkButtonText(okButtonText)
    self.attachLeoIcon(d)
    ok = d.exec_()
    return str(d.textValue()) if ok else None
.. @+node:ekr.20110605121601.18495: *6* LeoQtGui.runAskOkDialog
def runAskOkDialog(self,c,title,message=None,text="Ok"):

    """Create and run a qt askOK dialog ."""

    if g.unitTesting: return None
    b = QtWidgets.QMessageBox
    d = b(c.frame.top)
    d.setWindowTitle(title)
    if message: d.setText(message)
    d.setIcon(b.Information)
    d.addButton(text,b.YesRole)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False
.. @+node:ekr.20110605121601.18497: *6* LeoQtGui.runAskYesNoCancelDialog
def runAskYesNoCancelDialog(self,c,title,
    message=None,
    yesMessage="&Yes",
    noMessage="&No",
    yesToAllMessage=None,
    defaultButton="Yes"
):

    """Create and run an askYesNo dialog."""

    if g.unitTesting:
        return None
    b = QtWidgets.QMessageBox
    d = b(c.frame.top)
    if message: d.setText(message)
    d.setIcon(b.Warning)
    d.setWindowTitle(title)
    yes      = d.addButton(yesMessage,b.YesRole)
    no       = d.addButton(noMessage,b.NoRole)
    yesToAll = d.addButton(yesToAllMessage,b.YesRole) if yesToAllMessage else None
    cancel = d.addButton(b.Cancel)
    if   defaultButton == "Yes": d.setDefaultButton(yes)
    elif defaultButton == "No": d.setDefaultButton(no)
    else: d.setDefaultButton(cancel)
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False
    if   val == 0: val = 'yes'
    elif val == 1: val = 'no'
    elif yesToAll and val == 2: val = 'yes-to-all'
    else: val = 'cancel'
    return val
.. @+node:ekr.20110605121601.18498: *6* LeoQtGui.runAskYesNoDialog
def runAskYesNoDialog(self,c,title,message=None,yes_all=False,no_all=False):
    """
    Create and run an askYesNo dialog.
    Return one of ('yes','yes-all','no','no-all')

    :Parameters:
    - `c`: commander
    - `title`: dialog title
    - `message`: dialog message
    - `yes_all`: bool - show YesToAll button
    - `no_all`: bool - show NoToAll button
    """
    if g.unitTesting: return None
    b = QtWidgets.QMessageBox
    buttons = b.Yes | b.No
    if yes_all:
        buttons |= b.YesToAll
    if no_all:
        buttons |= b.NoToAll
    d = b(c.frame.top)
    d.setStandardButtons(buttons)
    d.setWindowTitle(title)
    if message: d.setText(message)
    d.setIcon(b.Information)
    d.setDefaultButton(b.Yes)
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False
    return {
        b.Yes: 'yes',
        b.No: 'no',
        b.YesToAll: 'yes-all',
        b.NoToAll: 'no-all'
    }.get(val, 'no')
.. @+node:ekr.20110605121601.18499: *6* LeoQtGui.runOpenDirectoryDialog
def runOpenDirectoryDialog(self,title,startdir):

    """Create and run an Qt open directory dialog ."""

    parent = None
    d = QtWidgets.QFileDialog()
    self.attachLeoIcon(d)
    s = d.getExistingDirectory (parent,title,startdir)
    return g.u(s)
.. @+node:ekr.20110605121601.18500: *6* LeoQtGui.runOpenFileDialog
def runOpenFileDialog(self,title,filetypes,defaultextension='',multiple=False,startpath=None):

    """Create and run an Qt open file dialog ."""

    if g.unitTesting:
        return ''
    else:
        if startpath is None:
            startpath = os.curdir

        parent = None
        filter = self.makeFilter(filetypes)
        d = QtWidgets.QFileDialog()
        self.attachLeoIcon(d)
        if multiple:
            lst = d.getOpenFileNames(parent,title,startpath,filter)
            if isQt5:  # this is a *Py*Qt change rather than a Qt change
                lst, selected_filter = lst
            return [g.u(s) for s in lst]
        else:
            s = d.getOpenFileName(parent,title,startpath,filter)
            if isQt5:
                s, selected_filter = s
            return g.u(s)
.. @+node:ekr.20110605121601.18501: *6* LeoQtGui.runPropertiesDialog
def runPropertiesDialog(self,
    title='Properties',data={}, callback=None, buttons=None):

    """Dispay a modal TkPropertiesDialog"""

    # g.trace(data)
    g.warning('Properties menu not supported for Qt gui')
    result = 'Cancel'
    return result,data
.. @+node:ekr.20110605121601.18502: *6* LeoQtGui.runSaveFileDialog
def runSaveFileDialog(self,initialfile='',title='Save',filetypes=[],defaultextension=''):

    """Create and run an Qt save file dialog ."""

    if g.unitTesting:
        return ''
    else:
        parent = None
        filter_ = self.makeFilter(filetypes)
        d = QtWidgets.QFileDialog()
        self.attachLeoIcon(d)
        obj = d.getSaveFileName(parent,title,os.curdir,filter_)
        # Very bizarre: PyQt5 version can return a tuple!
        s = obj[0] if isinstance(obj,(list,tuple)) else obj
        return g.u(s)
.. @+node:ekr.20110605121601.18503: *6* LeoQtGui.runScrolledMessageDialog
def runScrolledMessageDialog (self,
    short_title= '',
    title='Message',
    label= '',
    msg='',
    c=None,**kw
):

    if g.unitTesting: return None

    def send(title=title, label=label, msg=msg, c=c, kw=kw):
        return g.doHook('scrolledMessage',
            short_title=short_title,title=title,
            label=label, msg=msg,c=c, **kw)

    if not c or not c.exists:
        << no c error>>
    else:        
        retval = send()
        if retval: return retval
        << load viewrendered plugin >>
        retval = send()
        if retval: return retval
        << no dialog error >>
    << emergency fallback >>
.. @+node:ekr.20110605121601.18504: *7* << no c error>>
g.es_print_error('%s\n%s\n\t%s' % (
    "The qt plugin requires calls to g.app.gui.scrolledMessageDialog to include 'c'",
    "as a keyword argument",
    g.callers()
))
.. @+node:ekr.20110605121601.18505: *7* << load viewrendered plugin >>
pc = g.app.pluginsController
# 2011/10/20: load viewrendered (and call vr.onCreate)
# *only* if not already loaded.
if not pc.isLoaded('viewrendered.py') and not pc.isLoaded('viewrendered2.py'):
    vr = pc.loadOnePlugin('viewrendered.py')
    if vr:
        g.blue('viewrendered plugin loaded.')
        vr.onCreate('tag',{'c':c})
.. @+node:ekr.20110605121601.18506: *7* << no dialog error >>
g.es_print_error(
    'No handler for the "scrolledMessage" hook.\n\t%s' % (
        g.callers()))
.. @+node:ekr.20110605121601.18507: *7* << emergency fallback >>
b = QtWidgets.QMessageBox
d = b(None) # c.frame.top)
d.setWindowFlags(QtCore.Qt.Dialog)
    # That is, not a fixed size dialog.
d.setWindowTitle(title)
if msg: d.setText(msg)
d.setIcon(b.Information)
d.addButton('Ok',b.YesRole)
c.in_qt_dialog = True
d.exec_()
c.in_qt_dialog = False
.. @+node:ekr.20110605121601.18502: *5* LeoQtGui.runSaveFileDialog
def runSaveFileDialog(self,initialfile='',title='Save',filetypes=[],defaultextension=''):

    """Create and run an Qt save file dialog ."""

    if g.unitTesting:
        return ''
    else:
        parent = None
        filter_ = self.makeFilter(filetypes)
        d = QtWidgets.QFileDialog()
        self.attachLeoIcon(d)
        obj = d.getSaveFileName(parent,title,os.curdir,filter_)
        # Very bizarre: PyQt5 version can return a tuple!
        s = obj[0] if isinstance(obj,(list,tuple)) else obj
        return g.u(s)
.. @+node:ekr.20110605121601.18500: *5* LeoQtGui.runOpenFileDialog
def runOpenFileDialog(self,title,filetypes,defaultextension='',multiple=False,startpath=None):

    """Create and run an Qt open file dialog ."""

    if g.unitTesting:
        return ''
    else:
        if startpath is None:
            startpath = os.curdir

        parent = None
        filter = self.makeFilter(filetypes)
        d = QtWidgets.QFileDialog()
        self.attachLeoIcon(d)
        if multiple:
            lst = d.getOpenFileNames(parent,title,startpath,filter)
            if isQt5:  # this is a *Py*Qt change rather than a Qt change
                lst, selected_filter = lst
            return [g.u(s) for s in lst]
        else:
            s = d.getOpenFileName(parent,title,startpath,filter)
            if isQt5:
                s, selected_filter = s
            return g.u(s)
.. @+node:ekr.20150316141655.12: *5* Found: (flattened) runOpenFileDialog
.. @+node:ekr.20150316141655.13: *6* defs
.. @+node:ekr.20031218072017.3744: *7* dialogs (NullGui)
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message,cancelButtonText=None,okButtonText=None):
    return self.simulateDialog("numberDialog",-1)

def runAskOkCancelStringDialog(self,c,title,message,cancelButtonText=None,
                               okButtonText=None,default=""):
    return self.simulateDialog("stringDialog",'')

def runCompareDialog(self,c):
    return self.simulateDialog("compareDialog",'')

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False,startpath=None):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None,yes_all=False,no_all=False):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",yesToAllMessage=None,defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
.. @+node:ekr.20031218072017.3731: *7* app.gui file dialogs
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False,startpath=None):

    """Create and run an open file dialog ."""

    self.oops()

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run a save file dialog ."""

    self.oops()
.. @+node:ekr.20110605121601.18500: *7* LeoQtGui.runOpenFileDialog
def runOpenFileDialog(self,title,filetypes,defaultextension='',multiple=False,startpath=None):

    """Create and run an Qt open file dialog ."""

    if g.unitTesting:
        return ''
    else:
        if startpath is None:
            startpath = os.curdir

        parent = None
        filter = self.makeFilter(filetypes)
        d = QtWidgets.QFileDialog()
        self.attachLeoIcon(d)
        if multiple:
            lst = d.getOpenFileNames(parent,title,startpath,filter)
            if isQt5:  # this is a *Py*Qt change rather than a Qt change
                lst, selected_filter = lst
            return [g.u(s) for s in lst]
        else:
            s = d.getOpenFileName(parent,title,startpath,filter)
            if isQt5:
                s, selected_filter = s
            return g.u(s)
.. @+node:ekr.20050920084036.166: *6* getReadableTextFile
def getReadableTextFile (self):

    fn = g.app.gui.runOpenFileDialog(
        title = 'Open Text File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    return fn
.. @+node:ekr.20071114081313.1: *6* insertIcon
def insertIcon (self,event=None):

    '''Prompt for an icon, and insert it into the node's icon list.'''

    c = self.c ; p = c.p
    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)
    paths = g.app.gui.runOpenFileDialog(
        title='Get Icons',
        filetypes=[('All files','*'),('Gif','*.gif'), ('Bitmap','*.bmp'),('Icon','*.ico'),],
        defaultextension=None,
        multiple=True)
    if not paths: return
    aList = [] ; xoffset = 2
    for path in paths:
        xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset)
    aList2 = self.getIconList(p)
    aList2.extend(aList)
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw_after_icons_changed()
.. @+node:ekr.20070915134101: *6* c.readFileIntoNode
def readFileIntoNode (self,event=None):

    '''Read a file into a single node.'''

    c = self ; undoType = 'Read File Into Node'
    c.endEditing()

    filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Read File Into Node",filetypes=filetypes,defaultextension=None)
    if not fileName:return
    s,e = g.readFileIntoString(fileName)
    if s is None: return

    g.chdir(fileName)
    s = '@nocolor\n' + s
    w = c.frame.body.wrapper
    p = c.insertHeadline(op_name=undoType)
    p.setHeadString('@read-file-into-node ' + fileName)
    p.setBodyString(s)
    w.setAllText(s)
    c.redraw(p)
.. @+node:ekr.20110530124245.18245: *6* c.importAnyFile & helper
def importAnyFile (self,event=None):

    '''Import one or more files.'''

    c = self ; ic = c.importCommands
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]
    names = g.app.gui.runOpenFileDialog(
        title="Import File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()
    if names:
        g.chdir(names[0])
    else:
        names = []
    if not names:
        if g.unitTesting:
            # a kludge for unit testing.
            c.init_error_dialogs()
            c.raise_error_dialogs(kind='read')
        return
    # New in Leo 4.9: choose the type of import based on the extension.
    c.init_error_dialogs()
    derived = [z for z in names if c.looksLikeDerivedFile(z)]
    others = [ z for z in names if not z in derived]
    if derived:
        ic.importDerivedFiles(parent=c.p,paths=derived)
    for fn in others:
        junk,ext = g.os_path_splitext(fn)
        if ext.startswith('.'): ext = ext[1:]
        if ext in ('cw','cweb'):
            ic.importWebCommand([fn],"cweb")
        elif ext in ('nw','noweb'):
            ic.importWebCommand([fn],"noweb")
        elif ext == 'txt':
            ic.importFlattenedOutline([fn])
        else:
            ic.importFilesCommand([fn],'@clean') # "@nosent",)
        # No longer supported.
        # c.importCommands.importFilesCommand (names,"@root")
    c.raise_error_dialogs(kind='read')

# Compatibility
importAtFile = importAnyFile
importAtRoot = importAnyFile
importCWEBFiles = importAnyFile
importDerivedFile = importAnyFile
importFlattenedOutline = importAnyFile
importNowebFiles = importAnyFile
.. @+node:ekr.20110530124245.18248: *7* c.looksLikeDerivedFile
def looksLikeDerivedFile (self,fn):

    '''Return True if fn names a file that looks like an
    external file written by Leo.'''

    # c = self    
    try:
        f = open(fn,'r')
    except IOError:
        return False

    s = f.read()
    f.close()
    val = s.find('@+leo-ver=') > -1
    return val
.. @+node:ekr.20031218072017.2839: *6* c.readOutlineOnly
def readOutlineOnly (self,event=None):

    '''Open a Leo outline from a .leo file, but do not read any derived files.'''

    c = self
    c.endEditing()

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        g.chdir(fileName)
        c = g.app.newCommander(fileName)
        frame = c.frame
        frame.deiconify()
        frame.lift()
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:",fileName)
.. @+node:ekr.20050920084036.20: *6* readAbbreviations & helper
def readAbbreviations (self,event=None):

    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if fileName:
        self.readAbbreviationsFromFile(fileName)
.. @+node:ekr.20100901080826.6156: *7* readAbbreviationsFromFile
def readAbbreviationsFromFile(self,fileName):

    k = self.c.k

    try:
        f = open(fileName)
        for s in f:
            self.addAbbrevHelper(s,'file')
        f.close()
        k.abbrevOn = True
        g.es("Abbreviations on")
        # self.listAbbrevs()
    except IOError:
        g.es('can not open',fileName)
.. @+node:ekr.20031218072017.2859: *6* c.removeSentinels
def removeSentinels (self,event=None):

    '''Import one or more files, removing any sentinels.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.removeSentinelsCommand (names)
.. @+node:ekr.20070920104110: *6* compareAnyTwoFiles & helpers
def compareAnyTwoFiles (self,event):
    '''Compare two files.'''
    trace = False and not g.unitTesting
    c = c1 = self.c
    w = c.frame.body.wrapper
    commanders = g.app.commanders()
    if g.app.diff:
        if len(commanders) == 2:
            c1,c2 = commanders
            fn1 = g.shortFileName(c1.wrappedFileName) or c1.shortFileName()
            fn2 = g.shortFileName(c2.wrappedFileName) or c2.shortFileName()
            g.es('--diff auto compare',color='red')
            g.es(fn1)
            g.es(fn2)
        else:
            g.es('expecting two .leo files')
            return
    else:
        # Prompt for the file to be compared with the present outline.
        filetypes = [("Leo files", "*.leo"),("All files", "*"),]
        fileName = g.app.gui.runOpenFileDialog(
            title="Compare .leo Files",filetypes=filetypes,defaultextension='.leo')
        if not fileName: return
        # Read the file into the hidden commander.
        c2 = self.createHiddenCommander(fileName)
        if not c2: return
    # Compute the inserted, deleted and changed dicts.
    d1 = self.createFileDict(c1)
    d2 = self.createFileDict(c2)  
    inserted, deleted, changed = self.computeChangeDicts(d1,d2)
    if trace: self.dumpCompareNodes(fileName,c1.mFileName,inserted,deleted,changed)
    # Create clones of all inserted, deleted and changed dicts.
    self.createAllCompareClones(c1,c2,inserted,deleted,changed)
    # Fix bug 1231656: File-Compare-Leo-Files leaves other file open-count incremented.
    if not g.app.diff:
        g.app.forgetOpenFile(fn=c2.fileName(),force=True)
        c2.frame.destroySelf()
        g.app.gui.set_focus(c,w)
.. @+node:ekr.20070921072608: *7* computeChangeDicts
def computeChangeDicts (self,d1,d2):

    '''Compute inserted, deleted, changed dictionaries.
    
    New in Leo 4.11: show the nodes in the *invisible* file, d2, if possible.'''

    inserted = {}
    for key in d2:
        if not d1.get(key):
            inserted[key] = d2.get(key)
    deleted = {}
    for key in d1:
        if not d2.get(key):
            deleted[key] = d1.get(key)
    changed = {}
    for key in d1:
        if d2.get(key):
            p1 = d1.get(key)
            p2 = d2.get(key)
            if p1.h != p2.h or p1.b != p2.b:
                changed[key] = p2 # Show the node in the *other* file.
    return inserted, deleted, changed
.. @+node:ekr.20070921072910: *7* createAllCompareClones & helper
def createAllCompareClones(self,c1,c2,inserted,deleted,changed):
    '''Create the comparison trees.'''
    c = self.c # Always use the visible commander
    assert c == c1
    # Create parent node at the start of the outline.
    u,undoType = c.undoer,'Compare Two Files'
    u.beforeChangeGroup(c.p,undoType)
    undoData = u.beforeInsertNode(c.p)
    parent = c.p.insertAfter()
    parent.setHeadString(undoType)
    u.afterInsertNode(parent,undoType,undoData,dirtyVnodeList=[])
    # Use the wrapped file name if possible.
    fn1 = g.shortFileName(c1.wrappedFileName) or c1.shortFileName()
    fn2 = g.shortFileName(c2.wrappedFileName) or c2.shortFileName()
    for d,kind in (
        (deleted,'not in %s' % fn2),
        (inserted,'not in %s' % fn1),
        (changed,'changed: as in %s' % fn2),
    ):
        self.createCompareClones(d,kind,parent)
    c.selectPosition(parent)
    u.afterChangeGroup(parent,undoType,reportFlag=True) 
    c.redraw()
.. @+node:ekr.20070921074410: *8* createCompareClones
def createCompareClones (self,d,kind,parent):

    if d:
        c = self.c # Use the visible commander.
        parent = parent.insertAsLastChild()
        parent.setHeadString(kind)
        for key in d:
            p = d.get(key)
            if not kind.endswith('.leo') and p.isAnyAtFileNode():
                # Don't make clones of @<file> nodes for wrapped files.
                pass
            elif p.v.context == c:
                clone = p.clone()
                clone.moveToLastChildOf(parent)
            else:
                # Fix bug 1160660: File-Compare-Leo-Files creates "other file" clones.
                copy = p.copyTreeAfter()
                copy.moveToLastChildOf(parent)
                for p2 in copy.self_and_subtree():
                    p2.v.context = c
.. @+node:ekr.20070921070101: *7* createHiddenCommander (EditFileCommandsClass)
def createHiddenCommander(self,fn):
    '''Read the file into a hidden commander (Similar to g.openWithFileName).'''
    import leo.core.leoCommands as leoCommands
    lm = g.app.loadManager
    c2 = leoCommands.Commands(fn,gui=g.app.nullGui)
    theFile = lm.openLeoOrZipFile(fn)
    if theFile:
        c2.fileCommands.openLeoFile(theFile,fn,
            readAtFileNodesFlag=True,silent=True)
        return c2
    else:
        return None
.. @+node:ekr.20070921070101.1: *7* createFileDict
def createFileDict (self,c):
    '''Create a dictionary of all relevant positions in commander c.'''
    d = {}
    for p in c.all_positions():
        d[p.v.fileIndex] = p.copy()
    return d
.. @+node:ekr.20070921072608.1: *7* dumpCompareNodes
def dumpCompareNodes (self,fileName1,fileName2,inserted,deleted,changed):

    for d,kind in (
        (inserted,'inserted (only in %s)' % (fileName1)),
        (deleted, 'deleted  (only in %s)' % (fileName2)),
        (changed, 'changed'),
    ):
        g.pr('\n',kind)
        for key in d:
            p = d.get(key)
            if g.isPython3:
                g.pr('%-32s %s' % (key,p.h))
            else:
                g.pr('%-32s %s' % (key,g.toEncodedString(p.h,'ascii')))
.. @+node:ekr.20031218072017.2821: *6* c.open & helper
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>
    table = [
        # 2010/10/09: Fix an interface blunder. Show all files by default.
        ("All files","*"),
        ("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()

    c.init_error_dialogs()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            c2 = g.openWithFileName(fileName,old_c=c)
            if c2:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if c2 and closeFlag:
                g.app.destroyWindow(c.frame)
        elif c.looksLikeDerivedFile(fileName):
            # 2011/10/09: A smart open makes Leo lighter:
            # Create an @file node for files containing Leo sentinels.
            ok = c.importCommands.importDerivedFiles(parent=c.p,
                paths=[fileName],command='Open')
        else:
            # otherwise, create an @edit node.
            ok = c.createNodeFromExternalFile(fileName)

    c.raise_error_dialogs(kind='write')

    # openWithFileName sets focus if ok.
    if not ok:
        c.initialFocusHelper()
.. @+node:ekr.20031218072017.2822: *7* << Set closeFlag if the only open window is empty >>
@
If this is the only open window was opened when the app started, and
the window has never been written to or saved, then we will
automatically close that window if this open command completes
successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfUntitledWindows == 1) # Only one untitled window has ever been opened
.. @+node:ekr.20090212054250.9: *7* c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.wrapper
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
.. @+node:ekr.20150305084546.4: *3* Can't/won't fix
.. @+node:ekr.20150306075700.4: *4* Fix bug 89: Spontaneous clones when using sections
https://github.com/leo-editor/leo-editor/issues/89
.. @+node:ekr.20150305053156.5: *4* Fix bug 147: Python 3 clipboard encoding
@language rest
@wrap
https://github.com/leo-editor/leo-editor/issues/147

Text: ÷ Σ

In body text copy / paste (Ctrl-C, Ctrl-V) works as expected in py2, but there is a Σ -> £ translation on paste in py3. The ÷ is ok.

This appears to be a serious bug in older version of pyqt...

@language python
.. @+node:ekr.20110605121601.18485: *5* LeoQtGui.Clipboard
def replaceClipboardWith (self,s):

    '''Replace the clipboard with the string s.'''

    trace = False and not g.unitTesting
    cb = self.qtApp.clipboard()
    if cb:
        # cb.clear()  # unnecessary, breaks on some Qt versions
        s = g.toUnicode(s)
        QtWidgets.QApplication.processEvents()
        cb.setText(s)
        QtWidgets.QApplication.processEvents()
        if trace: g.trace(len(s),type(s),s[:25])
    else:
        g.trace('no clipboard!')

def getTextFromClipboard (self):

    '''Get a unicode string from the clipboard.'''

    trace = False and not g.unitTesting
    cb = self.qtApp.clipboard()
    if cb:
        QtWidgets.QApplication.processEvents()
        s = cb.text()
        if trace: g.trace (len(s),type(s),s[:25])
        # Fix bug 147: Python 3 clipboard encoding
        s = g.u(s)
            # Don't call g.toUnicode here!
            # s is a QString, which isn't exactly a unicode string!
        return s
    else:
        g.trace('no clipboard!')
        return ''
.. @+node:ekr.20091206161352.6232: *5* g.u & g.ue
if isPython3: # g.not defined yet.
    def u(s):
        return s
    def ue(s,encoding):
        return s if g.isUnicode(s) else str(s,encoding)
else:
    def u(s):
        return unicode(s)
    def ue(s,encoding):
        return unicode(s,encoding)
.. @+node:ekr.20110605121601.18081: *5* qtew.getAllText
def getAllText(self):
    '''QTextEditWrapper.'''
    w = self.widget
    s = g.u(w.toPlainText())
    return s
.. @+node:ekr.20070130115927.4: *5* Cut/Copy/Paste (LeoFrame)
.. @+node:ekr.20070130115927.5: *6* copyText (LeoFrame)
def copyText (self,event=None):
    '''Copy the selected text from the widget to the clipboard.'''
    trace = False and not g.unitTesting
    f = self ; c = f.c
    w = event and event.widget
    wname = (w and c.widget_name(w)) or '<no widget>'
    if trace: g.trace(g.isTextWrapper(w),wname,w)
    if not w or not g.isTextWrapper(w):
        return
    # Set the clipboard text.
    i,j = w.getSelectionRange()
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)

OnCopyFromMenu = copyText
.. @+node:ekr.20070130115927.6: *6* LeoFrame.cutText
def cutText (self,event=None):

    '''Invoked from the mini-buffer and from shortcuts.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.isTextWrapper(w): return

    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i,j = w.getSelectionRange()

    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        # 2011/11/14: Not used at present.
        # width = f.tree.headWidth(p=None,s=s)
        # w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
.. @+node:ekr.20070130115927.7: *6* LeoFrame.pasteText
def pasteText (self,event=None,middleButton=False):
    '''
    Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.
    '''
    trace = False and not g.unitTesting
    f = self ; c = f.c
    w = event and event.widget
    wname = (w and c.widget_name(w)) or '<no widget>'
    # if trace: g.trace(g.isTextWrapper(w),w)
    if not w or not g.isTextWrapper(w):
        if trace: g.trace('not a text widget',w)
        return
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()
    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = g.app.gui.getTextFromClipboard()
    s = g.toUnicode(s)
    # g.trace('pasteText','wname',wname,'s',s,g.callers())
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    # Save the horizontal scroll position.
    if hasattr(w,'getXScrollPosition'):
        x_pos = w.getXScrollPosition()
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)
    w.see(i+len(s) + 2)
    if wname.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif singleLine:
        s = w.getAllText()
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # 2011/11/14: headline width methods do nothing at present.
        # if wname.startswith('head'):
            # The headline is not officially changed yet.
            # p.initHeadString(s)
            # width = f.tree.headWidth(p=None,s=s)
            # w.setWidth(width)
    else:
        pass
    # Never scroll horizontally.
    if hasattr(w,'getXScrollPosition'):
        w.setXScrollPosition(x_pos)

OnPasteFromMenu = pasteText
.. @+node:ekr.20061016071937: *6* OnPaste (To support middle-button paste)
def OnPaste (self,event=None):

    return self.pasteText(event=event,middleButton=True)
.. @+node:ekr.20110605121601.18092: *5* qtew.setAllText
def setAllText(self,s):
    '''Set the text of body pane.'''
    trace = False and not g.unitTesting
    traceTime = False and not g.unitTesting
    c,w = self.c,self.widget
    if trace: g.trace(len(s),c.p and c.p.h)
    colorizer = c.frame.body.colorizer
    highlighter = colorizer.highlighter
    # Be careful: Scintilla doesn't have a colorer.
    colorer = highlighter and highlighter.colorer
    if colorer: colorer.initFlag = True
    try:
        if traceTime:
            t1 = time.time()
        self.changingText = True # Disable onTextChanged.
        colorizer.changingText = True # Disable colorizer.
        # g.trace('read/write text')
        w.setReadOnly(False)
        w.setPlainText(s)
        # w.update()
            # 2014/08/30: w.update does not ensure that all text is loaded
            # before the user starts editing it!
        if traceTime:
            delta_t = time.time()-t1
            if False or delta_t > 0.1:
                g.trace('w.setPlainText: %2.3f sec.' % (delta_t))
    finally:
        self.changingText = False
        colorizer.changingText = False
.. @+node:ekr.20150211104036.474: ** First improvements
.. @+node:ekr.20150227040245.10: *3* Jump to [node of selected text]
https://groups.google.com/d/msg/leo-editor/p3MR1es0Ez0/U4ME-UAuf0AJ

Terry: Seems like the codewise ctags thing Ville worked on does most of that, may need refreshing though. 

Matt: Wanted Leo function or plugin: Ctrl-X click or R-click {selected text} or ... that jumps to the associated node or function.

Consider the following code:

    print "Downloading", ', '.join(packages)
    for p in packages:
        do_download(p)
        ball(p)
        md5(p)

Wouldn't be nice to ctrl-click `do_download` and have Leo navigate to whatever node contains def do_download(): ?
.. @+node:ekr.20150211104036.477: *3* Smart paste
@language rest
.. @+node:ekr.20150211104036.478: *4* Terry's post
https://groups.google.com/d/msg/leo-editor/TZGd_gAmQwk/SqXLGyj4V7kJ

I don't think you need to view source or copy text that looks like HTML.

For me, the most effective way to reproduce a web page from a browser
in a Leo richtext node is to select-all (ctrl-a) copy (ctrl-c) on the
*rendered* browser content, i.e. the web page as you usually look at it.

That gave better results, fidelity of reproduction wise, than viewing
the source and copying that.  Partly because the source includes the
outer elements that the richtext editor probably doesn't want to see,
remember the richtext editor is itself a complete HTML page with its
own HTML and HEAD elements.

> There is no way that Leo, or any other program, can magically recover
> the missing data.

Actually I think modern clipboard operations are based on magic ;-)
When you copy the rendered HTML in the browser and paste into Leo you
get WYSIWYG reproduction pasting into a richtext node and just plain
text posting into a regular node - somewhere in the pipeline the
content actually delivered is selected based on the capabilities of the
receiving end of the pipeline - not sure of the details, but remember
clipboards can paste images and other things that aren't plain text.

Cheers -Terry 
.. @+node:ekr.20150211104036.479: *4* Matt's links
https://groups.google.com/d/msg/leo-editor/TZGd_gAmQwk/LEC1ezHsOG4J

> Is it possible to have Leo analyse what type of text is being pasted and thus
define automatically the type of node (rich/plain)?

It looks possible, `win32clipboard.EnumClipboardFormat`, "enumerate the
data formats that are currently available on the clipboard. " --
http://docs.activestate.com/activepython/2.4/pywin32/win32clipboard.html.
.. @+node:ekr.20150211131925.4: *3* Feature: auto-close quotes
https://groups.google.com/d/msg/leo-editor/yJLz-p3I4mY/Pqa1phYN_10J
.. @+node:ekr.20150120155724.4: *3* improve python importer
@language rest

- Handle properties.
- Show base classes in headlines.
- Put @language and @tabwidth directives at end of body.
- Translate:
    #-----------------------------------------------------------------------------
    # Imports
    #-----------------------------------------------------------------------------
to organizer node whose headline is Imports.
.. @+node:ekr.20141210123805.9: *3* Support rope
.. @+node:ekr.20130806211959.17377: *3* Add coffeescript importer
.. @+node:ekr.20120226183512.10195: ** Other bugs
@language rest
.. @+node:ekr.20141017150357.18271: *3* 3 Launchpad bugs assigned to Terry
https://bugs.launchpad.net/leo-editor/+bug/1245111
Can't get the viewrendered pane back next to the editor

https://github.com/leo-editor/leo-editor/issues/57
Leo sets focus to body when main window gets focus

https://bugs.launchpad.net/leo-editor/+bug/1235619 BUG: Deleting multiple
selection in pyqt if a children of a to-delete node is also to be deleted
.. @+node:ekr.20130926053913.11562: *3* Bug-tracker: Hard
.. @+node:ekr.20140824163757.20587: *4* Bug 1022140: scroll problem in the body pane (Hard)
@language rest

https://bugs.launchpad.net/leo-editor/+bug/1022140
.. @+node:ekr.20130806072439.20497: *5* ** Leo does not display all content of a node ...
@language rest

From: Viktor Ransmayr <viktor.ransmayr@gmail.com>

even at the latest revision (rev. 5500) Leo does not display all content of 
larger nodes
- Larger nodes approximately defined as >= 150 lines ...

That is searching for example for a 'TO-DO' item just return this 
particular line w/o the
context  around. - Going up - or - down does not refresh the screen & 
content ...

I thought I could provide you with an outline, where this problem 
consistently shows up.
- However, whenever I trim the personal outline I'm using the problem 
disappears.

This problem is really annoying - and - I would gladly provide more input, 
but so far I
fail. - Any suggestion?

With kind regards,

Viktor

PS: For completeness here's the log from Leo's startup:

<log>

Leo Log Window
Leo 4.11 devel, build 5500, 2012-10-19 18:35:23
Python 3.2.2, qt version 4.8.0
Windows 6, 1, 7601, 2, Service Pack 1
leoID=VR20100603 (in D:\\Users\\Viktor Ransmayr\\.leo)
load dir: D:\\Branches\\leo-editor\\leo\\core
global config dir: D:\\Branches\\leo-editor\\leo\\config
home dir: D:\\Users\\Viktor Ransmayr
reading settings in D:\\Branches\\leo-editor\\leo\\config\\leoSettings.leo
reading settings in D:\\Users\\Viktor Ransmayr\\.leo\\myLeoSettings.leo
reading settings in D:\\Users\\Viktor Ransmayr\\Documents\\Leo-BR-r5500.leo
reading: D:\\Users\\Viktor Ransmayr\\Documents\\Leo-BR-r5500.leo

</log>
.. @+node:ekr.20130806072439.20498: *6* Re: Leo does not display all content of a node ...
From: Terry Brown <terry_n_brown@yahoo.com>

I can confirm that this type of bug is still present in 5500 also.

Yesterday I was noticing this:

 - editing a node (A)
 - create new node by accidentally hitting insert
 - delete new node immediately while still in headline edit mode using
   cut-node 
 - node A is displayed incorrectly, a line is missing, selecting the
   body restores the missing line

vs. the above but selecting the body of the inserted node, then
deleting it, in which case A is displayed correctly without selecting
its body.

Today (the outline's changed) it's not doing that, but I still
notice the difference between inserting and immediately deleting a node
(scroll position in A restored incorrectly), vs. inserting a node,
selecting its body, and then deleting it (scroll position in A restored
correctly).

So, there's some execution path difference between A being selected
after an inserted node is deleted immediately (still in headline edit
mode) vs. after selection of its body.

Not a very helpful report, but maybe the difference between deletion of
the node immediately and after selecting its body guides you to a
particular piece of code.
.. @+node:ekr.20130806072439.20499: *6* Re: Leo does not display all content of a node ...
From: resi147 <scalet@yebu.de>

I also have the same problem, using the official 4.10 final.
I.e. a couple of lines are missing in the node (the linecounter
increments and decrements but the cursor does not move).

Not sure what report could be useful.
I also feel like it occurs on larger body nodes.
.. @+node:ekr.20130806072439.20501: *6* Re: Leo does not display all content of a node ...
From: lewis <lewisneal@operamail.com>

Same issue for me has been occurring on a large node. Interestingly, I can
only reproduce the display error when 'Leo Log Window' is at bottom left
position which is my ''initial_split_orientation' setting (horizontal: body
pane to the right). I can use Window>Toggle Split Direction to correct the
initial display error.

For me, the display error always becomes evident at line 95. My line
numbers 95,96 are visible then skips to 118. Lines 97 thru 117 are not
displayed. It appears to be graphics performance time lag; if I return to
the file after having switched to another leo tab the previously invisible
lines are visible.

Leo Log Window
Leo 4.11 devel, build 5647, 2013-04-02 08:03:37
Python 3.3.1, qt version 4.8.4
Windows 6, 1, 7601, 2, Service Pack 1
.. @+node:ekr.20130806072439.20531: *6* Response to Leo does not display... Styling in Leo
From: Terry Brown <terry_n_brown@yahoo.com>

(This is a response to the invisible line glitch, but not directly
related, so a new thread)

Remember this:

http://groups.google.com/group/leo-editor/browse_thread/thread/ee869a0a70f2d765

Some time ago I was working on styling Leo from a single top level
stylesheet using a mechanism similar to CSS classes, so instead of:
    
    # widget is active
    w.setStyle("QTextEdit { color: red; font-weight: bold; }")
    
    ...
    
    # widget is inactive
    w.setStyle("QTextEdit { color: black; font-weight: normal; }")
    
you'd have

    # widget is active
    w.setAttribute('active', True)
    
    ...
    
    # widget is inactive
    w.setAttribute('active', False)

and in the single global style sheet

    QTextEdit[active="true"] { color: red; font-weight: bold; }
    QTextEdit[active="false"] { color: red; font-weight: bold; }

This isn't a perfect example because if active == focused then you
could probably just use the pseudo-state :focus and let Qt do all the
work, and also Leo would .setStyle() a string defined in @settings, not
something hard coded.

Qt styles are different from CSS in that CSS has a single attribute,
`class`, which can contain a space separated list of tags, whereas Qt
has arbitrary attributes like the `active` I just made up above.
.. @+node:ekr.20130805080841.21380: *4* Bug 1222947: javascript import bug (Hard)
@language javascript

https://groups.google.com/forum/#!topic/leo-editor/dmC8iIKlF7g

Bug 
https://bugs.launchpad.net/leo-editor/+bug/1222947

Here is the test file::

    var express = require('express');
     
    var app = express.createServer(express.logger());
     
    app.get('/', function(request, response) {
    response.send('Hello World!');
    });
     
    var port = process.env.PORT || 5000;
    app.listen(port, function() {
    console.log("Listening on " + port);
    });
.. @+node:ekr.20130916105324.19894: *4* Bug 1226353: @shadow does not retain outline structure properly (Hard)
@language rest

https://bugs.launchpad.net/leo-editor/+bug/1226353

===== EKR

The most important problem is compatibility.  As I have just verified,
@shadow will work even if the private file does not exist,
but all outline structure will be lost.  Therefore, it may be best
not to try to read old (ver-4thin) files at all.

@shadow does not reload the following simple file correctly!

+ @shadow
   @others
  + child 1
    child 1.1

shadow files (the private files containing the sentinels) use the *old*
(#@+leo-ver=4-thin) sentinels, rather than the new (#@+leo-ver=5-thin)
sentinels.

The old sentinels don't have an explicit notion of nesting level; the new
sentinels do, so it would seem that the way to fix this problem is to use
new sentinels. However, this would be a major change to the inner workings
of the @shadow logic.
.. @+node:ekr.20130908104426.11242: *4* Bug 914221: bound method ViewRenderedController.updated (Hard)
https://bugs.launchpad.net/leo-editor/+bug/914221

Summary of a *long* discussion: this may be a docutils issue, and does not
seem easy to fix.
.. @+node:ekr.20130908104426.11269: *3* Bug-tracker: Wish-list
There are 42 wishlist items.  Some appear to be duplicates, or closely related.
.. @+node:ekr.20130806072439.20369: *4* @paragraph(s)
From: <offray@riseup.net>

I have been using txt2tags + Nested Editor to produce structured docs in 
a light markup and exporting them to HTML and LaTeX > pdf. The fine 
tunning on the pdf output is done by editing the LaTeX source in Leo. I 
like the aesthetic of the source code and the outputs and I have 
contacted the Nested author in order to get some cross-pollination 
between it and Leo [1].

[1] 
https://groups.google.com/group/nestededitor/browse_thread/thread/7068e3cd229d4614 

Now I think that is time to start hacking Leo for a better support of my 
work flow and the first thing I would like to have is a "@paragraph" 
directive that works the same as @rst-no-head but can be used in any 
part of a (sub)tree, even if is not @rst (sub)tree. This would come 
handy in chunking and reassembling LaTeX docs without marking up the 
parts with "<<chunk>>" tags.

===== EKR

Interesting idea. Please file a wishlist bug at https://bugs.launchpad.net/leo-editor.

===== offray As I have say repeatedly I'm an "end user" 
of Leo and I have browse the doc about developing in Leo in [2] and I 
plan to follow it as a tutorial, but any pointer to a more detailed 
section to pay attention or to the Leo trees to start hacking is welcomed

[2] http://webpages.charter.net/edreamleo/scripting.html

.. @+node:ekr.20130806072439.20374: *4* aha moment when using leo script with @url, and feature request ;-)
From: HaveF <iamaplayer@gmail.com>

1. Aha Sometimes, I just wonder, I write a script (say, @button button-1)
in leo-file-A.leo, and reuse it by copy(ctrl+shift+c) the button to
leo-file-B.leo.

When I'm working on leo-file-B.leo, I may have ideas to improve the
@button button-1, but at that time(working on leo-file-B.leo), I may
forget where the original place of @button button-1 is. Even I store
the original scripts in the default workbook.leo is a tedious work to
deal with(open it, locate where the original script is, update it...)

But! After I add the @url at the first line of @button button-1, I can
decide if the improvements what I made on leo-file-B.leo's @button button-1
should or shouldn't be merged to the original and upstream @button
button-1(in leo-file-A.leo) easily by just a click.

And if I work on leo-file-C.leo, I want to use the same script, but I just
only remember I use the script in the leo-file-B.leo instead of original
place. With @url I can easily jump to original place, and copy it to
leo-file-C.leo.

Using @url in the leo script, I can make the scripts consistency and
diversity at same time.

Great! But, Wait, wait!

2. Feature request.  At this time, you can use this idea by comment the @url
line after jump. If @url isn't comment, the leo-editor will say...
SyntaxError: invalid syntax at the @url line.

Maybe it is a good idea to omit the @url line in the script when executing
script?

===== EKR

Yes.  I think this is a good idea.  A similar idea occurred to me when
looking at @rclick nodes.  At present, the context_menu plugin contains an
ugly hack:  it allows an @rclick node to *follow* an @button node.  This is
needed at present when the @button node contains @others: the @rclick node
can't be part of the script "pulled in" by @others.

It would be much more elegant to ignore @rclick nodes when computing the
script.  This would require a change to the @others logic, but I think it
is worthwhile.

===== Terry Brown <terry_n_brown@yahoo.com>

I do this kind of thing by keeping buttons in @files...

@file ~/.leo/gen  # general utility buttons
@file ~/.leo/dml  # tools for editing an XML dialect I use
@file ~/.leo/sql  # tools for editing SQL / interacting with server

so changes made in one outline are automatically propagated to other
outlines next time they're reloaded.  You just reference the files
in each outline where you want those buttons.

> 2. Feature request
> At this time, you can use this idea by comment the @url line
> after jump. If @url isn't comment, the leo-editor will say...
> SyntaxError: invalid syntax
> at the @url line.
> 
> Maybe it is a good idea to omit the @url line in the script when executing
> script?

This probably would make sense, already the scripting machinery is
ignoring things like @nocolor or @language cobol or @nowrap etc.

Maybe you could file a wish-list bug item for tracking.
.. @+node:ekr.20130806072439.20377: *4* An unexpected phenomenon(Using @url node) in @shadow
From: HaveF <iamaplayer@gmail.com>

When I use @url node in @shadow file, the node
should not be in public file, right?
.. @+node:ekr.20130806072439.20523: *4* RST3 Tables with Nodes as Rows
From: Craig Johnson <craig@hivemind.net>

I'm trying to use rst tables by using the table markup in the body text, 
with one node per table row.  However it seems that the nodes are being 
preceded with a line-feed even-though @rst-no-head is in effect.
 
Can anybody help with preventing that line-feed, it breaks the rst table 
formatting.

===== EKR

Hmm.  My guess is that a new @rst directive would be needed.  The
workaround would seem to be to put the entire table in a single node, but
presumably you have your reasons for not wanting to do that.

Feel free to file a wish-list bug.

===== Craig Johnson <craig@hivemind.net>
 
I've been creating rst tables using rst markup directly in the body text.  
For field lists.  As the same field apears in multiple programs, I would 
like to use Leo's cloning to reproduce a table row in several locations in 
the tree.  The issue that prevents me from doing this, is that an 
@rst-no-head headline seems to generate a line-feed preceeding the body 
text in the derived file which breaks the table parse.
 
Maybe a example:
The Leo tree:
 
+Program1
  +Parameters
       =================== ========
       Field Name          Format
       =================== ========
    +@rst-no-head Field1
        prmField1          Integer
 
Results in the following markup
Program1
^^^^^^^^^
Parameters
~~~~~~~~~
=================== ========
Field Name          Format
=================== ========

prmField1           Integer
That blank line in the markup before the node body text breaks the table.
 
===== wgw <wgwinder@gmail.com>


No fix (sorry), but can confirm the problem -- it should go in the bug
list. (I looked at the rst code, and fainted)

I note that your format wouldn't work without closing the table off:


Field Name                       Format
 add                                    add

But you are right: @rst-no-head doesn't work properly.

Looks like you can only post process the rst intermediate file and=20
eliminate that extra line.
.. @+node:ekr.20141115150149.5: *4* Wishlist bug 62: Syntax @color settings don't dereference
@language rest

https://github.com/leo-editor/leo-editor/issues/62

Unlike the stylesheet @colors, the syntax @color settings don't
dereference. For example::

    @color mycomment = #586E76
    @color comment1_color = @mycomment
    @color comment2_color = @mycomment
    @color comment3_color = @mycomment
    @color comment4_color = @mycomment

Result:
Errors in the console (see below) and uncolored comments in code (same as normal fg color).

Console output:
** isPython3: False
Leo 4.11 final, build 20140922060345, Mon Sep 22 06:03:44 CDT 2014
Git repo info: branch = master, commit = c93bd17
Python 2.7.6, PyQt version 4.8.5
Windows 7 x86 (build 6.1.7601) SP1
leoID=peckj (in C:\Users\PeckJ.leo)
reading settings in C:\cygwin\home\PeckJ\repos\leo\leo-editor\leo\config\leoSettings.leo
reading settings in C:\Users\PeckJ.leo\myLeoSettings.leo
reading settings in C:\Users\PeckJ.leo\workbook.leo
setTag unknown color name @mycomment mainLoop,python_rule0,match_eol_span,colorRangeWithTag
setTag unknown color name @mycomment mainLoop,python_rule0,match_eol_span,colorRangeWithTag
.. @+node:ekr.20111125072438.10204: *4* Wishlist bug 882243: Clones sometimes not saved: change how @others works
See https://bugs.launchpad.net/leo-editor/+bug/882243

In Leo, I made this file:

@file test.txt
@others
.....test1
     test: these are clones
.....test2
     @others

      what is going on...?
..........test1 <--- this is cloned
          test: these are clones

The output file does not have the cloned node:

#@+leo-ver=5-thin
#@+node:bill.20111025150533.3528: * @thin test.txt
#@+others
#@+node:bill.20111025150533.3527: ** test1
test: these are clones
#@+node:bill.20111025150533.3529: ** test2
#@+others
#@-others

what is going on...?
#@-others
#@-leo

I don't think it is a conflict with @others; it is just that some files do not retain the clones that are displayed.

Here is the copied node:

<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2"/>
<vnodes>
<v t="bill.20111025150533.3528" a="E"><vh>@thin test.txt</vh>
<v t="bill.20111025150533.3527"><vh>test1</vh></v>
<v t="bill.20111025150533.3529" a="E"><vh>test2</vh>
<v t="bill.20111025150533.3527"></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="bill.20111025150533.3527">test: these are clones
</t>
<t tx="bill.20111025150533.3528">@others
</t>
<t tx="bill.20111025150533.3529">@others

what is going on...?</t>
</tnodes>
</leo_file>

Here is the copied leo file:

<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
 <global_window_position top="50" left="50" height="500" width="700"/>
 <global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="bill.20111025150533.3528" a="E"
expanded="bill.20111025150533.3529,"><vh>@thin test.txt</vh></v>
</vnodes>
<tnodes>
</tnodes>
</leo_file>
.. @+node:ekr.20111216105907.10218: *5* My response: this is a wishlist item
Reposted from http://groups.google.com/group/leo-editor/browse_thread/thread/67a28984616d09c9
About bug 882243: clones sometimes not saved

I'd like to discuss this bug here, because I would like us all to be aware of the situation, and possible changes.

The surprise
=========

To paraphrase the original bug report, suppose we have the following @file tree:

+ @file test.txt
@others
  + node 1 (cloned)
    node 1 text.
  + node 2
     @others
    + node 1 (cloned)
       node 1 text.

As usual, lines preceded by "+" denote headlines: all other lines are body text.

The surprise is that the cloned node1 node is written to the external file only once (as a child of the root node) and hence does not appear as a (cloned) child of the node2 node when Leo next loads the @file tree.

History
=====

I would like to call this a wishlist item because the
present code quite intentionally writes *any* node
(including cloned nodes) only once. That is, the write code
sets a bit when writing a node, and @others ignores any
nodes with that bit set.

You could call this a bug in the @others write logic, but at
one time it was done explicitly and on purpose.

I don't remember why this was so, but I do remember it *was*
so. It may have been an artifact of Leo's old representation
of clones that used both vnodes and tnodes. tnodes no longer
exist in the one-node world that we have been living in for
several years, and it may well be time to revisit the
original design, but I would rather not do that just now
because there are several "real" bugs that need attention
asap.

Workaround
=========

Because this is an issue involving @others, you might assume
that a workaround involving sections would be possible. You
would be correct. The following file works as expected::

+ @file test.txt
<< node 1 >>
<< node 2 >>
  + << node 1>> (cloned)
     node 1 text.
  + << node 2 >>
     << node 1 >>
    + << node 1 >>(cloned)
       node 1 text.
.. @+node:ekr.20141030042423.13: *4* Wishlist bug 93: Leo should keep the external editor's temp file up to date
https://github.com/leo-editor/leo-editor/issues/93
Index of top Launchpad wishlist items

https://bugs.launchpad.net/leo-editor/+bug/1259755
Leo should keep the external editor's temp file up to date
.. @+node:ekr.20130806072439.20387: *4* wishlist: Autosaving when external file saved
From: "Ville M. Vainio" <vivainio@gmail.com>

Just an idea:

After discovering sublime edit, I have started using external editor mode
more (rclick -> Edit in...). Annoyance there is that once you save in
external editor, you still have to go to leo and save there, or your
changes will be lost if you close leo without saving.

This can lead to loss of data if you don't routinely agree to save changes
when closing Leo. I often don't do this, as I save all the time when I
type, and don't want to save accidental changes I might have done to the
leo document; I don't usually have time to review changes when closing a
document.

Maybe .leo could automatically save the tree if and only if the externally
edited node is the only dirty one.

===== EKR

I agree there is a problem, but I don't believe hacking Leo's save logic is
a good idea, for several reasons:

1. There might be several dirty nodes, and you could still lose data
(strictly following your suggestion) in that case.

2. The write logic for external files is complex, mainly due to file
caching.  I tolerate that complexity because caching is such a big win.
But it would not be easy to do @file AI to discover the special case you
mention.

3. Imo, the proper place to handle this problem is in the vim and xemacs
plugins.  These plugins are responsible for the interaction with Leo.

Would it work for you if the xemacs and vim plugins automatically saved an
external file whenever the plugin caused a node in that file to become
dirty?  This would likely solve the problem you mention, although I
wouldn't be my life on it.

Your comments, please.

===== Matt Wilkie <maphew@gmail.com>

I've been bit by this several times too.

It's lead to me relying on pyscripter (my usual external editor these days,
has more useful to me command completion than leo) more and more, when I
otherwise might just nip out, do a few things and come back.

===== EKR

One thing that must be done in any case is to provide alt-x commands for
all context-menu entries.  There is something wrong with having to use the
mouse at all...

===== Terry Brown <terry_n_brown@yahoo.com>

Coincidentally I added the alt-X command 'context-menu-open' a week or
so ago, letting you open the context menu with a keyboard binding so
you can then navigate the menu with the cursor keys.

This is because not all menu entries can have alt-X commands,
specifically the quickMove plugins commands for moving nodes to
pre-defined destinations in other outlines, this is basically a list
selection operation, but being on a sub-sub-menu it's a pain with the
mouse, and easier with the cursor keys.

This is part of my method for handling todo items for different
projects, they are imported from email to one outline, and then I file
them to the relevant project outline's todo node.  Which creates a
management problem I just found a surprisingly viable solution for I'll
mention in another post.

===== From: "Ville M. Vainio" <vivainio@gmail.com>

I wouldn't change the save logic, I'd just execute "save" for the full .leo
document when

- Node has changed in external editor.
- The node that changed is the only dirty node in the whole leo document.

I don't use xemacs/vim plugin, but rather "edit in" in right click menu
(contextmenu.py plugin IIRC).

I agree that this is not an elegant proposal, in that it involves a
potentially surprising (if useful) special case.

I have to think this a bit more. Perhaps some kind of extra warning in the
UI for this scenario would do the trick as well.

.. @+node:ekr.20130806072439.20394: *5* Re: Autosaving when external file saved
From: "Edward K. Ream" <edreamleo@gmail.com>

On Thu, Nov 29, 2012 at 6:30 AM, Ville M. Vainio wrote:

> I wouldn't change the save logic, I'd just execute "save" for the full 
>> .leo document when 
>>
>> - Node has changed in external editor.
>> - The node that changed is the only dirty node in the whole leo document.
>>
>> I don't use xemacs/vim plugin, but rather "edit in" in right click menu 
>> (contextmenu.py plugin IIRC).
>>
>
> Ok.  In that case the contextmenu plugin should handle this. 
>

I believe that c.openWith should be able to deal with this problem.  
c.openWith creates a temporary external file and updates a node when the 
user changes that file.  This logic is independent of the editor being 
used; it works, for example, with Scite, my default external editor.

Clearly, c.openWith (or rather, one of its helpers) is able to update the 
node and to mark it dirty.  So at the time the node is marked dirty 
c.openWith has an opportunity to automatically save the file containing the 
vnode.  c.openWith can issue a colored message to the log pane, but that 
should be the only "warning" necessary.

My present plan is to write a helper, say c.write_vnode, that will discover 
the external file (if any) containing the vnode, and immediately write that 
external file *without* a prompt.  If there is no external file, 
c.write_vnode could just do an ordinary save of the .leo file and all dirty 
external files.  Alternatively, c.write_vnode could write only the .leo 
file (the write-outline-only command) *without* clearing the c.changed bit.

I believe c.write_vnode will solve this problem fairly completely.  What do 
you think, Amigos?

Edward
.. @+node:ekr.20130806072439.20395: *5* Re: Autosaving when external file saved
From: "Edward K. Ream" <edreamleo@gmail.com>

On Thu, Nov 29, 2012 at 9:17 AM, Edward K. Ream <edreamleo@gmail.com> wrote:

>
> Clearly, c.openWith (or rather, one of its helpers) is able to update the
> node and to mark it dirty.
>

The "helper" is the idle-time hook,  editnode_on_idle, in contextmenu.py.
You could call this good news, because our experiments with auto-saving can
be confined to the contextmenu plugin.  If our experiments end happily we
can use the same techniques in the vim and xemacs plugins.

I'll wait awhile for your comments before going ahead with the proposed
changes.
.. @+node:ekr.20130806072439.20396: *5* Re: Autosaving when external file saved
From: "Edward K. Ream" <edreamleo@gmail.com>

On Tue, Dec 11, 2012 at 5:55 AM, Ville M. Vainio <vivainio@gmail.com> wrote:

> """
> My present plan is to write a helper, say c.write_vnode, that will
> discover the external file (if any) containing the vnode, and immediately
> write that external file *without* a prompt.  If there is no external file,
> c.write_vnode could just do an ordinary save of the .leo file and all dirty
> external files.
> """
>
> Maybe a relatively safe solution is to do this:
>
> 1) My present plan is to write a helper, say c.write_vnode, that will
> discover the external file (if any) containing the vnode, and immediately
> write that external file *without* a prompt.
>
> But not do this:
>
> 2) If there is no external file, c.write_vnode could just do an ordinary
> save of the .leo file and all dirty external files.
>
> This way, if you "want to be safe", you will create an external @file for
> the content.
>
> For situation 2), some kind of loud warning is in order, not sure of what
> kind though. Red g.es?
>

Thanks for this suggestion.  I have a great distrust of all operations
containing "if" statements in their explanation.  Somehow, we need a
simpler approach, but I don't know what it is.

.. @+node:ekr.20130806072439.20397: *5* Re: Autosaving when external file saved
From: "Edward K. Ream" <edreamleo@gmail.com>

On Thu, Nov 29, 2012 at 6:30 AM, Ville M. Vainio <vivainio@gmail.com> wrote:

> I wouldn't change the save logic, I'd just execute "save" for the full
> .leo document when
>
> - Node has changed in external editor.
> - The node that changed is the only dirty node in the whole leo document.
>
> I don't use xemacs/vim plugin, but rather "edit in" in right click menu
> (contextmenu.py plugin IIRC).
>

Ok.  In that case the contextmenu plugin should handle this.

>
> I agree that this is not an elegant proposal, in that it involves a
> potentially surprising (if useful) special case.
>
> I have to think this a bit more. Perhaps some kind of extra warning in the
> UI for this scenario would do the trick as well.
>

I agree that if the code is going to do something like this it should issue
a clear warning that something has happened.  Otoh, such "clear warnings"
tend to get ignored :-)  Indeed, the problem is that you are *already*
ignoring such a clear warning!  Adding another warning is not likely to be
a big help...

Edward
.. @+node:ekr.20130806211959.17373: *4* wishlist: meld integration
From: Haroldo Stenger <haroldo.stenger@gmail.com>

I'm slowly trying to grok leo. I love meld, it's simply the best text
comparison I've ever seen. I wonder if a greater bit of integration between
meld and leo is possible, and in which ways. Undoubtedly calling it as an
external process is better than anything.
.. @+node:ekr.20141026191037.6: *3* Can't fix bug 83: Bracket completion doesn't work
@language rest

https://github.com/leo-editor/leo-editor/issues/83

This appears to be a Windows 8 issue.
.. @+node:ekr.20140824043305.18303: *3* Not in any bug tracker
.. @+node:ekr.20141017110114.18267: *4* @data qt-scintilla-styles only works in leoSetting.leo
- @data qt-scintilla-styles *only* works in leoSetting.leo, not myLeoSettings.leo.
.. @+node:ekr.20130806072439.20371: *4* @wrap now suppresses horizontal scrolling
From: "Edward K. Ream" <edreamleo@gmail.com>

The title pretty much says it all.  This is a significant improvement, and 
makes Leo suitable for authoring text.  It should have been done ages ago. 
Please let me know immediately if this new behavior causes problems for you.

There is one glitch.  If you add @wrap, the directive won't be in effect 
until you leave the node and revisit it.

===== redla <radim.halir@gmail.com>

There is one problem which is (IMHO) caused by this change: I have @wrap 
active and see my "plain" text wrapped properly. But if there is any "long 
enough" URL on the page (i.e. longer than the screen width), this is not 
wrapped (as there is no space in the string) nor I can see the end of it 
(as there is no horizontal scrollbar either) ;-(

===== EKR

The workaround is to disable @wrap in order to see the url, but this is
clumsy.
.. @+node:ekr.20130806072439.20380: *4* auto-rst error? need more robust?
From: HaveF <iamaplayer@gmail.com>

When I use auto-rst import rst file, sometimes, the author write extra
characters which aren't harm, but the leo says it is a error...like this
one:

reading: @auto-rst README

Error: @auto did not import @auto-rst README perfectly
The clean-all-lines command may help fix whitespace problems
first mismatched line: 20 (original) = 20 (imported)

Original file...

  18 u'how the learning experiment went.\\n'
  19 u'Step 1: Create the dataset\\n'
  20 u'----------------------------\\n'
  21 u'From this directory, run\\n'
  22 u'python make_dataset.py\\n'

Imported file...

  18 u'how the learning experiment went.\\n'
  19 u'Step 1: Create the dataset\\n'
  20 u'--------------------------\\n'
  21 u'From this directory, run\\n'
  22 u'python make_dataset.py\\n'

inserting @ignore

errors inhibited read @auto
D:\\OpenCourses\\ufldl\\ref\\pylearn2\\pylearn2\\scripts\\tutorials\\grbm_smd\\README

reading entire file into @auto node.

reading: @edit README

finished

The problem is the line 20 has two extra '-', when I remove it manually,
the import works.

Do you have a better idea to do this than do it manually?

===== From: Terry Brown <terry_n_brown@yahoo.com>

On Sat, 18 May 2013 16:50:12 +0800
HaveF <iamaplayer@gmail.com> wrote:

> Original file...
> 
>   18 u'how the learning experiment went.\\n'
>   19 u'Step 1: Create the dataset\\n'
>   20 u'----------------------------\\n'
>   21 u'From this directory, run\\n'
>   22 u'python make_dataset.py\\n'

At first I thought that the rst was invalid, but the docs. say
  The underline/overline must be at 
  least as long as the title text. 
http://docutils.sourceforge.net/docs/user/rst/quickref.html#section-structure
so I guess it's not.  But leo has nowhere to store the length of the
underlining.  Also, this is related to the issue where Leo changes the
underline characters used, e.g. = -> - and * -> # etc.

I think the easiest solution is going to be to do the import and just
remove the @ignore afterwards, checking that there are no changes that
matter.  Perhaps the wording of the @ignore message could make it
clearer that the import may not have failed, but just needs checking.

===== HaveF <iamaplayer@gmail.com>


But in fact, the @auto-rst load this rst file like @auto, no @ignore node 
at all.

My import procedure is like this:
1. make a node name:
@auto-rst models.txt
2. right click it, and select "refresh from disk"


And I just find another problem...
If the rst file like this:

MLP
===

It also occurs error:

reading: @auto-rst models.txt

Error: @auto did not import @auto-rst models.txt perfectly
The clean-all-lines command may help fix whitespace problems
first mismatched line: 10 (original) = 10 (imported)

Original file...

   8 u'    :members:\\n'
   9 u'MLP\\n'
  10 u'===\\n'
  11 u'.. automodule:: pylearn2.models.mlp\\n'
  12 u'    :members:\\n'

Imported file...

   8 u'    :members:\\n'
   9 u'MLP\\n'
  10 u'====\\n'
  11 u'.. automodule:: pylearn2.models.mlp\\n'
  12 u'    :members:\\n'

inserting @ignore

errors inhibited read @auto D:\\OpenCourses\\ufldl\\ref\\pylearn2\\doc\\library\\models.txt

reading entire file into @auto node.

reading: @edit models.txt

finished

It says I need a extra "="...

I have attached this file, for someone has interest to reproduce the error.

.. @+node:ekr.20111125072438.10214: *4* Fix bug: Another @shadow bug (test4.leo) (maybe)
email:
http://mail.google.com/mail/#label/Leo%2FBugs/133ac31add8b2c6c

see attachment, shadow file won't get written correctly, and it won't reread
correctly too. Using leo-editor-snapshot- 201111090253.

Hopefully I will be able to look on some bugs myself, but don't know when. Needs
a bit of time, I am not very familiar with python.

===== EKR

Leo doesn't understand .jsp.  @shadow should refuse to work for unknown languages.
.. @+node:ekr.20111010162047.15678: *4* Fix bug: Imports to @file should put @first/@last directives in root node
Especially:
    - Shebang line.
    - Python encoding line.
    
- @auto correctly works for all Python files.
.. @+node:ekr.20111221102703.10289: *5* @@@nosent ../test/at-auto-at-first-test.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

def spam():
    pass
    
# This is the last line.
.. @+node:ekr.20120219152142.34262: *4* Fix bug: Revert moves the reverted tab to the right
.. @+node:ekr.20111125072438.10217: *4* Fix bug: shell interprets characters in at-mime headings
http://groups.google.com/group/leo-editor/browse_thread/thread/07efd66847ac4a64

on linux, parenthesis or angled brackets in @mime headings prevent the file from
being opened, probably because they are interpreted specially by the shell, e.g.
they need to be escaped. Such characters should be escaped before passing the
filename to the shell.

.. @+node:ekr.20120327163022.9744: *4* Fix bug: The @auto script *must* put @first nodes in root node
Also the import commands.

Especially:
    - Shebang line.
    - Python encoding line.
.. @+node:ekr.20111018104244.15920: *4* Fix bug: Use QLocalSocket in LProtoClient.connect
http://groups.google.com/group/leo-editor/browse_thread/thread/fe9cddc0e7ac8199
.. @+node:ekr.20141024211256.7: *4* Improve help-for command
Fix focus problem with F11 & help-for-command

Add modules/plugins to help-for-command.
.. @+node:ekr.20130807203905.16596: *4* PortableFileAssociator
From the thread: Cannot open Leo files by double-click in Windows Explorer?
https://groups.google.com/d/msg/leo-editor/KwrqYGMH20Q/z1uc-99vsnsJ

From: HansBKK <hansbkk@gmail.com>

For those like me who work in "portable" mode, there's a very cool tool
called "PortableFileAssociator" that allows you to create a set of windows
file associations, icons etc and enable/disable the whole profile at one
time, without messing with the local system's registry.

Also handy for those not in portable mode, but working on different windows
boxes and bored with having to tweak each one separately.
.. @+node:ekr.20130806072439.20732: *4* Runnable Leo in one .zip file w/ virtual machine
From: Terry Brown <terry_n_brown@yahoo.com>

Summary - it's easy to make a .zip file containing Leo and all it's
dependencies.

Inspired by Matt's recipe, using VirtualBox throw away 1GB Windows XP
32 bit machines, I tried the following.

Install Python (installer from python.org) 2.7.2 to 

  C:\Docouments and Settings\someuser\Desktop\leo\python27

Install PyQt (installer from Riverbank) 4.9 into the same folder (it
goes there by default)

Unzip http://www.greygreen.org/leo/leo-editor-latest.zip into

  C:\Docouments and Settings\someuser\Desktop\leo\leo-editor-latest

Make leo.zip from C:\Docouments and Settings\someuser\Desktop\leo

Delete the virtual machine, purging any registry entries etc. created
by the two installers.

On a fresh machine, searched the registry for 'python' just to be sure,
found nothing.

Unzip the .zip file, then

  cd C:\Docouments and Settings\someuser\Desktop\leo
  python27\python.exe leo-editor-latest\launchLeo.py

And Leo opens a blank outline, after asking for an ID, as it's supposed
to.  Didn't test it beyond that.

So, the .zip file contains all Leo needs to run, and obviously
runLeo.bat could be added in the top level to actually launch it.

Of course this is for Windows, so I think it's an improvement over
asking people to install Python and PyQt first, but neither of those
steps was that hard in Windows anyway.

===== EKR

Is this a technique that we could use for official Windows releases?
If so, what exactly would we do?

===== Terry

I guess, perhaps as an all-in-one option with a system integrated
option for those who want to use system python/qt.  Don't know if it
violates and licensing on Python / Qt, everything's being distributed
unaltered, so I wouldn't think so.

So basically you'd give people a large .zip file and tell them to
extract it to a folder and run the batchfile at the top level.  If they
can't do that, they might not be ready for Leo :-)  I guess you could
make it a self-extracting .zip, for that matter.

Also, the daily snapshot could be made this way, seeing once Python and
Qt are installed in the folder the Leo version can just be copied in.

It's not uncommon for FLOSS to be distributed this way, both Blender
and Inkscape use this approach, particularly for recent builds.

===== From: HansBKK <hansbkk@gmail.com>

If something like this **is** done, it should IMO be packaged as an
alternative to the normal installation procedure.

You would definitely get marketing exposure by getting the specs from
PortableApps.com and let them host it there as  "Portable Leo", tracking
the "official" Portable Python (currently 2.7.2) as a dependency, obviously
including QT etc as well. But it would need to be kept up to date. . .

Most Windows users would be better served by following the normal
installation procedure and ending up with a
registry-and-environment-variables-complete install of Python et al which
they can use for other things beyond Leo. Ending up with multiple instances
of Python to maintain is likely to cause more problems.

And the normal Windows install just isn't that hard, really! Improving the
current instructions, by providing a step-by-step "cookbook" with direct
links to the download packages etc might make it a **little** easier (IMO
only for the clueless), but then of course that would be a doc that would
need pretty frequent updates, which if I may be so bold doesn't seem to
happen too quickly on the doc side.
.. @+node:ekr.20130806072439.20736: *5* Re: Runnable Leo in one .zip file.
From: Matt Wilkie <maphew@gmail.com>

Since this topical today, almost a year later, I thought I'd take a run at 
repeating this using Portable Python (http://www.portablepython.com) as a 
base. It didn't work, but I think it should. Maybe someone else knows why. 

I ran the installer for 2.7.3 since 3.2 doesn't include PyQt4. At install 
time I selected only the Python and PyQt4 packages. Then from a fresh 
command shell:

{{{
path=c:\windows;c:\windows\system32
pushd x:\portapy27\App
path=%cd%;%cd%\Scripts;%cd%\Lib\site-packages\PyQt4;%path%
set pythonhome=%cd%
set pythonpath=%cd%\Lib

popd

python --version
Python 2.7.3

python -c "import PyQt4"
:: no error returned, we're good.

python c:\apps\leo-editor-latest\launchLeo.py
Leo requires Qt to be installed.
}}}

oh well.
.. @+node:ekr.20130806072439.20744: *5* Re: Runnable Leo in one .zip file.
From: HansBKK <hansbkk@gmail.com>

> PortableApps version would be FANTASTIC!!

A couple of versions have been posted here already, including Terry's very
simple sequence in the first message of this thread. Of course, we're only
talking about Windows, but note that it works equally well either syncing
with whatever tool (I favor Unison over SSH) or carrying around on an
arbitrary-path'd external device, including flash drives (but they can be
slow).

Here's my more robust (hence more complex) version, xx indicating your 
python version (mine is 27):

Use the normal .MSI, setup.exe etc processes to Install a clean "canonical" 
version of your "python dev stack" to say C:\PythonXX, reboot if needed, 
test thoroughly. Note any new environment variables pointing to your new 
binary locations.

Now create a corresponding PythonXX folder in your "PortableApps" location 
(I put it under "CommonFiles" along with GTK and Java) and copy everything 
from your installed location to the portable one.

You can then use the project-provided tools on the "master" computer to 
keep your binaries updated, and they will see any local Registry entries 
and the environment variables they created and operate normally wrt your 
installed location (e.g. C:\PythonXX).

If you have a local folder sync tool (I use Unison and WinMerge) you can 
add to/remove from/configure your Python environment from either location, 
otherwise just keep your installed location as the "master" and just copy 
the whole stack over each time you do so.

The whole PortableApps tree can then be sync'd/copied to any other 
desktop(s) you like, either over the wire or via an external device, and 
the latter can be carried for use in say an Internet cafe or client-site 
situation.

====================

For use on those other computers, for running in portable mode, I use a
"portable start menu" (PStart) which allows for its own "autolaunch" batch
files, where I set some global environment variables to be used by
app-specific launch batch files, including :

%Path% (I add my batch folder and a general utility/tools folder)
%HOME% (usually "E:\aasync\Data\H_HOME"
and a custom one called %h_pa%, which points to the root of my PortableApps 
parent (usually "D:\aasync\PortableApps")

Then for each environment that requires its own custom settings, I create a 
launch batch file that builds on that base. In the case of Python apps, 
here's an example that opens a CMD console window:

@ECHO OFF
set 
PATH=%PATH%;%h_pa%\CommonFiles\Python27;%h_pa%\CommonFiles\Python27\Lib\site-packages\PyQt4;%h_pa%\CommonFiles\Python27\Lib\idlelib;%h_pa%\CommonFiles\Python27\Scripts;
set PROMPT=$p_python$g
E:
cd \aasync
CMD.exe

I'm not sure which if any of the environment stuff Leo requires, but I 
figure it might as well have the same environment as my Python CLI, since 
I'll be testing shell integration, including iPython. In my leo-win.bat, 
the last three lines above are replaced with:

D:
cd \aasync\PortableApps\leo-editor
start "" "..\CommonFiles\Python27\pythonw.exe" 
"..\CommonFiles\Python27\Lib\site-packages\leo-editor4\launchLeo.py" %*

====================

Note this is more than the minimum you need to just run Leo - you could of 
course simplify it; for example, only set the environment variables Leo 
requires, or you could just set the master computer' installation routines 
to use a single location under PortableApps, but I prefer to keep them 
separate for testing purposes.

I hope you (and others googling this later) find this useful.
.. @+node:ekr.20130806072439.20485: *4* Whitespace when importing java file using @auto
Importing java file using @auto. How do I adjust Leo to ignore whitespace and indentation irregularities?
From: Eoin <eoinmccarthy@fastmail.fm>

I'm using @auto to import java files into my Leo project. I'm then cloning 
various methods as sub-nodes of new feature nodes. 
It's helping keep my development focussed - and is useful to look back and 
see what parts of the codebase I've worked on for each feature. 

However, the whitespace in the Java files isn't completely regular. In 
particular, debug logging is always placed in column 1 - regardless of the 
surrounding indentation. 
Other people are also working on these files, so I'd rather not mess with 
the established convention. 

As things stand, when Leo imports a file its outputting a bunch of error 
messages:
* error: underindented line. Extra leading whitespace will be added
* warning: intermixed blanks and tabs

The creation of the auto node goes fine - though the final result has an 
@ignore directive in its root node. 
When working, I just take the @ignore away and clone the methods I want to 
work on. 
The problem is when I close the Leo file and re-open it later on, the same 
errors occur during the building of the auto node and the previous cloned 
information is lost. 
To restart work on a feature, I need to reclone the appropriate nodes. Not 
a showstopper, but not ideal. 

I tried adjusting the info in the JavaScanner class in the core 
leoImport.py file as follows:

        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = None
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.classTags = ['class','interface']
        self.functionTags = []
        self.sigFailTokens = [';','='] # Just like c.
        self.strict=False

I deleted the pyc file and restarted Leo. A new pyc file appears, so the 
compiled to bytecode seems to be ok.

I was hoping the the setting of self.strict = False would allow the parsing 
to ignore the whitespace and indentation issues. 
I'm still getting the same errors though. 

Any help appreciated. I'm using Leo 4.10-final. 

===== EKR

There is no easy way to do this at present, but it's probably reasonable to
disable errors (and not add @ignore) for underindented comments for
non-strict languages.

Please file a wishlist bug for this.  Thanks.
.. @+node:ekr.20111114085925.9932: *4* Why does the unittest/output folder contain empty files?
Related nodes:
ic.exportHeadlines
TM.makeImportExportSuite
class ImportExportTestCase
c.exportHeadlines
.. @+node:ekr.20130807203905.16594: *4* Wishlist for newbies (Fidel)
@language rest

From the thread: "Associate .Leo files to open with Leo when double click"
https://groups.google.com/d/msg/leo-editor/KOXSm8crU1I/qCLYzZCJuc4J

From: <fidelperez@gmail.com>

1. Include a small file within the Quickstart guide which would associate
   files automatically. (Or maybe asking for imput, which can be done
   through a Leo node and this way the user learns about its
   functionality).

2. More buttons or scripts in quick start guide, preferably before the
   "programming" section, so when a new user opens it, he has had the
   opportunity to do Ctrl+B on several scripts (for instance, showing in
   the log the name of all the nodes within the selected one, having some
   subnodes with numbers and doing math on them and showing the result on
   the log pane, and as much "silly" but visual functions as possible so
   the user, by going pressing ctrl+b on each, gets a bigger chance to
   understand what is Leo. In my oppinion some users will just stop in the
   quickguide if they are not presented with such a thing before going to
   docs.leo etc.

3. The description of the plugins is not as accessible as it should be. A
   script for activating them easier, been a week using Leo and still cant
   quite activate, find the descriptions or use them freely... And if each
   plugin or script had an example of use that would be priceless, for
   instance, including them all in quickstart (both scripts, plugins
   branchs) and then the new user could just go through all clicking on the
   examples and just seeing Leo work and show its potential. I know some of
   those are done but as I said, after a week or so I still am very
   confused...

4. Quickstart should be open by default (instead of current Leo workbook)
   at least until the user changes some config and prevents that from
   happening. Is there any "load previous tabs" functionality? (IE open the
   Leo files which where open when it was closed the last time)
.. @+node:ekr.20120516140545.9987: ** Wishlist
The big picture:

- The dog that isn't barking: newbies seem to be having an easier time learning Leo.
- A gallery showing what rST & css can do in Leo.
- Leo as a web app.
.. @+node:ekr.20140521095206.16728: *3* * Important
.. @+node:ekr.20141108064630.19: *4* Resolve clone wars based on modification dates
From: Joon Ro <joonpyro@gmail.com>

I think it would make more sense if leo checks the file modification time
when it makes decision which node is new, instead of just depending on the
order of files in the outline.
.. @+node:ekr.20130508084413.10631: *4* add g.etrace
How easy is this to do?
.. @+node:ekr.20120520055508.11873: *4* Add split-window commands
These would be an alternative to the Easter Egg interface.
.. @+node:ekr.20140115052524.16699: *4* Allow clones *anywhere* in @file nodes
​https://groups.google.com/d/msg/leo-editor/YjJdWjNSM9o/SDL7Nb__OUcJ

There is a way to allow clones *anywhere* in @file nodes and simplify Leo's
read code in the process!

The idea is for the read code to treat *all* nodes exactly the same
initially, regardless of whether they should actually be clones of each
other. A post-pass would then "unify" all vnodes having the same gnx.

Why, oh, why, did I never think of doing this? It will be *so* much simpler
than the present code!​ And it will be just as fast, maybe even faster.
Another example of generality arising from simplicity...

I can tell you why I *did* think of doing this now: the new @auto read
logic uses a new p._relinkAsCloneOf method, exactly what the @file read
post pass will use!
.. @+node:ekr.20130807203905.16679: *4* Centralizing focus handling (to make debugging easier)
From: "Ville M. Vainio" <vivainio@gmail.com>

I am having some problems wrapping my head around how focus behaves
throughout leo.

IMO it would be a good idea to have only one place in Leo where focus is
explicitly set. E.g. g.setFocus(widget). This implementetation would
suffice:

def setFocus(widget):
  widget.setFocus()

Reasoning: it would be handy to add debugging stuff here, to see why my
focus stuff is failing in alt-x go-anywhere handling.

(My guess is treeFocusHelper only understanding focus being either in tree
or body, but no time to explore further now)

===== EKR

In fact, there is only one such place: c.outerUpdate.  The various
xWantsFocus methods simply set ivars, which c.outerUpdate uses to set the
focus when a command completes.

The various xWantsFocusNow methods call c.outerUpdate immediately.  Usually
we don't want to do this, because it could cause screen flash, but
sometimes the immediate update is essential.

I've marked this thread as a topic for implementers.  Such things will form
the basis for documentation for my successors.
.. @+node:ekr.20130806072439.21204: *4* Comparison leo outline type with other outliner's types?
From: Todd Mars <tamnt54@gmail.com>

I remember reading -somewhere- about comparing various multi-parent or
multi-copy of node outline types (clones vs. backlinks or whatever) but I
can't find where I read that. Where is it? Desire to read analysis, isn't
that in the leo docs somewhere?

Terry

Personally I think Leo could navigate cyclic graphs, see
http://leo.zwiki.org/GraphsInTrees particularly the 'Older notes' section
towards the end. But it's a major issue with regard to all the algorithms
which don't expect to run in to loops. And the extra layer of connections
from the backlinks plugin allows the same functionality, so it may be that
it's more an interface issue than a data model issue.

I'd like Leo to be able to behave like CmapTools, http://cmap.ihmc.us/ but
maybe it can, essentially, and it's really a matter of defining some new
interface bells and whistle's.
.. @+node:ekr.20120527053550.10117: *4* Create find-def command
@nocolor-node

The find-def command (with ctrl-click support) would do
the hyperlinking.

It shouldn't be too hard: create an auto-completion-like popup if there are
multiple possibilities.  Use leoInspect.
.. @+node:ekr.20140704052551.17955: *4* Create myLeoSettings and workbook automatically
Create myLeoSettings and workbook automatically if they do not exist.
.. @+node:ekr.20130806072439.21225: *4* Distributed collaboration tool
From: Miles Fidelman <mfidelman@meetinghouse.net>

A big Leo fan pointed me at Leo, and this group - indicated that sharing 
Leo documents has been talked about over the years, but not really 
implemented, and suggested that I post some details about a project that 
I've been working on.  So....

Basic model is synchronized copies of documents, linked by an asynchronous 
pub-sub channel.  Think of a personal Wiki (like TiddlyWiki) - linked to 
copies of itself, that's the general idea.  Compose a document, email 
copies to collaborators, everyone saves a local copy - those copies link to 
each other via a pub-sub protocol to distribute updates.  All in 
JavaScript, embedded in the "smart documents" - nothing special to install.

If you're interested, details are at:
http://www.kickstarter.com/projects/1947703258/smart-notebooks-keeping-on-the-same-page-across-th
and Andy Oram wrote a background piece for O'Reilly Radar, at:
http://radar.oreilly.com/2012/08/smart-notebooks-for-linking-virtual-teams-across-the-net.html

I'd welcome comments, support, likes, tweets, blogs, ...

Thank you very much,

Miles Fidelman

EKR

My apologies for not responding sooner.  That was really unfortunate.  In
my experience, the best way to ruin good ideas is to ignore them :-(

As you may have gathered, I've been overwhelmed with good ideas, bugs that
should have been fixed years ago, sometimes pathetic or non-existent
documentation.  I'm getting less overwhelmed, but I won't be able to follow
up on this idea for now.

I encourage some of Leo's more web-aware users to take a look at this. For
now, I just have to file this under Leo/Ideas :-)
.. @+node:ekr.20130807203905.16681: *4* Free "continuous integration" for Leo
From: "Ville M. Vainio" <vivainio@gmail.com>

Someone may be interested in investigating a free CI system for Leo:

https://travis-ci.org/

This could e.g. create debian packages for daily builds, run unit tests,
check stuff with lint, try compiling with python3 so we (*cough*) wouldn't
have accidental print statements in the source...
.. @+node:ekr.20130806072439.21241: *4* Free range body editors
From: Terry Brown <terry_n_brown@yahoo.com>

I suspect that if body editors could be made just slightly more
flexible it would open up whole new ways of using Leo.  It seems they
just need two or three things to make them really flexible.

- a flag to indicate whether the tree pane should select the body
    editor's node when the body editor is focused.  To see an
    example of editing bodies without the tree selecting the node you're
    editing, see the stickynotes plugin

 - a flag to indicate whether the body editor should track the node
   currently selected in the tree

 - it needs to not care about what it's contained in, GUI wise.  I
   don't know how much work's involved in this.

I'll try and contribute to things moving in this direction when I have
time, just throwing it out there for others to think on.

If you could have a body editor edit the node indicated by an UNL, it
would basically be a clone...

.. @+node:ekr.20140306114536.16869: *4* Handle multiple (headline?) selections
@language rest

How to select multiple nodes?  Did I disable multiple selections??

They work from the rclick menu, but not from the minibuffer.
- Should handle clone and delete and move, at least.
.. @+node:ekr.20130806072439.21248: *4* Idea/needed: system command queue (g.execute_shell_commands?)
From: "Ville M. Vainio" <vivainio@gmail.com>

Often, I find myself wanting to execute system commands in serial fashion
(first in, first out), capture their output, and allow browsing it, BUT not
blocking Leo or ipython terminal.

I'd like to show stderr and stdout in g.es, or separate log page, and
provide callback after task has been completed.

Unless anyone has something like this already, I plan to create it "later"
with QProcess.

===== Ville

Now I have basic functionality pushed to trunk.

If you want to "spawn" (posibbly several) system commands to background,
use g.procs.add(), like this ctrl+b script:

def L(*args):
    g.es("callback", args)

g.procs.add(['sleep', '4'], "que1")
g.procs.add(['sleep', '3'], "que1", L)
g.procs.add(['sleep', '2'], "que1")
g.procs.add(['sleep', '2'], "que2")

Note how que2 completes first. Idea is that commands in same queue depend
on each other, and thus need to run in sequential order.

This should make waiting for long lasting operations easier as the whole
Leo won't freeze until they are over (but you can still use the stdout /
stderr output from these calls, thanks to the optional callback)

API may change once I start using it (soon).

===== Terry

There's the leoscreen stuff for integration with the GNU `screen`
terminal switcher / manager.  Push lines from the body to the terminal,
pull lines back the other way.  But more for interactive interaction
with terminal programs than batch oriented work.  Leo doesn't block.

===== Ville

A challenge I can imagine with the "screen" workflow is detecting when a
command has been executed (and capturing stderr/stdout). Do you have a
solution for that in mind?

===== Terry

I tried more direct communication (subprocess.Popen.communicate())
before the screen approach, it's hard and probably app. specific.
leoscreen avoids that by basically being interactive, so it might not
be a fit for your case.  Basically it's leveraging the intelligence of
the user to keep track of execution.
.. @+node:ekr.20130806072439.21254: *4* Idea: easy key bindings
From: "Ville M. Vainio" <vivainio@gmail.com>

Problem: I find myself repeating a bunch of alt-x commands in the same
document. There is more than one, so ctrl-p (repeat last command) is not
useful.

Idea: specify that keys from alt-1 to alt-9 are "easy macro keys". They
would be easy to bind to various alt-x command without editing preferences.

How they can be bound:

Do e.g. alt-x ipython-exec

BUT instead of pressing ENTER in the end, press alt-1. This would bind the
command to alt-1.

Store them it c.db, so they will be remembered for every leo document, but
won't clutter bindings of other people editing the same file.

===== Matt

From: Matt Wilkie <maphew@gmail.com>

I often find myself in the same situation with regards to clipboards. If
alt-# were macros, ctrl-# could be clipboards perhaps?

It could be even more important then to have some sort UI method for
inspecting/previewing the contents of them. Maybe thumbnail preview a la
Sublime's right hand document overview.

===== Fidel

I am still studying (and have much more to study yet) Leo, but I think that 
two things can be archieved by integrating it with libraries like pywinauto 
<https://code.google.com/p/pywinauto/> or
dragonfly<https://code.google.com/p/dragonfly/>


- First of all, it could track all the keystrokes of the user, relate it to
  the window, then offer the user possibility to repeat (even complex
  sequences)

- Second, It would be great to have a Leo tab with buttons showing the
  hotkeys related to the current action (IE when the user has the cursor on
  a node, or the edit pane, etc) (or even the current window in front). So
  when the user uses those hotkeys, Leo will track them, so the next
  scenario could happen:

User copyes a link from Leo
User sets an excel file to front
User pastes it in an excel cell and hits down.

If both the user did those through hotkeys, and they were tracked, Leo 
could automatically offer repeat the same action with the next links held 
in the same category.

This is a pretty raw explanation but I hope it makes the point. 
Nevertheless, I will continue to study, research and try to help with those 
features by myself.
.. @+node:ekr.20131117054619.16683: *4* Improve Find
@language rest

New check boxes:
    - Find-All starts at selected node.
    - Ignore duplicates.

* (Done??) Reset wrap & onlyPosition when the find pattern changes:
    The find command must reset several state variables whenever
    a) The find pattern changes or
    b) a limited (node-only, suboutline-only) search completes or
    c) a wrapped search completes.
    d) Whenever any radio button (find scope) changes.

- Create unit tests.
    - Check all bug reports.
    - Test outline-only, node-only, wrap.
    - Test isearch (forward & backward)
* Revise theory of operation.
- Add @bool find_all_from_present_position = True
* Ctrl-F puts selected text into the search box.
- Make sure to capture search string, even if do ctrl-g, etc.
** Smart search: clear ignore case if the search text has at least one uppercase letter.
- find-all and change-all never wrap.=

Maybe:
- Put "not found" message somewhere else.
- Don't put unknown ctrl keys in minibuffer (suppress ctrl-shift-r)

@language python
.. @+node:ekr.20131118113639.17705: *5* Done
@language rest

Important classes & methods:
- spellTabHandler (in leoEditcommands.py) is no longer a subclass of leoFind class.
- dw.createFindTab & helpers
- class FindTabManager
- class EventWrapper

What I did:
- Added support for Alt-Ctrl keys.
- start-find selects all text in findbox.
- Removed eventFilter ivar
- All defaults work in the Find pane, except the Alt-Ctrl bindings.
  The user can just use the standard Alt-bindings to set checkboxes and radio buttons.
- Add shortcuts to button names.
- Honor Ctrl-G, F2, F3, Ctrl-- & Ctrl-+ from any widget in the find pane.
- Create help button in the Find pane.
- dw code now sets ftm ivars, not dw ivars.
- Added tab easter egg to searchWithPresentOptions.
- Removed all clones and dead code from leoSettings.leo.
  (Improved introductory comments.)
- Createf leo/config/exampleSettings.leo.
- fc.minibuffer_mode replaces fc.expert_mode.
- start-find command
- test set-replace-string.
- Protect self.p everywhere.
- Don't hide find pane during searches.
- Init widgets from c.config.
- Clicking widgets should set leoFind ivars.
- Toggle commands should toggle widgets.
- Move search classes from leoEditCommands.py to leoFind.py

Changed methods:
- c.initObjects now creates leoFind object.
- c.finishCreate does: self.findCommands = leoFind.leoFind(c)
- Added the FindTabManager (ftm)
- dw.createFindTab adds find buttons and calls.
- dw.createFindTab creates the FindTabManager and calls ftm.init_widgets.
* Added find_generation ivar to vnode class.
.. @+node:ekr.20131123071505.16462: *5* Crash in undoer
redoGroup oops: expecting bunch.items.  bunch.kind = typing
redoGroup Bunch...
dirtyVnodeList: [<pos 192439856 childIndex: 9 lvl: 0 key: 65845296:9 find.generalSearchHelper (Must init!!)>]
kind: typing
leading: 10
newMiddleLines: [u'        self.setup_command() ### ']
newNewlines: 1
newSel: (276, 276)
newText: None
oldMiddleLines: [u'        self.setup_command()']
oldNewlines: 1
oldSel: (271, 271)
oldText: None
p: <pos 192438800 childIndex: 9 lvl: 0 key: 65845296:9 find.generalSearchHelper (Must init!!)>
redoHelper: <bound method undoer.redoTyping of <leo.core.leoUndo.undoer instance at 0x03FF4198>>
trailing: 9
undoHelper: <bound method undoer.undoTyping of <leo.core.leoUndo.undoer instance at 0x03FF4198>>
undoType: Typing
yview: 0
.. @+node:ekr.20131207054442.16335: *5* check isearch
* unit tests?
- Create save/restore_isearch_vars methods using isearch_save_d.
.. @+node:ekr.20140704052551.17954: *4* Improve p.isVisible
p.isVisible: its algorithm is poor.

Where is this used?
.. @+node:ekr.20060227131611: *4* Kent: extensible auto-completion-like capabilities
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3593116
By: ktenney

Zope3, with it's component based architecture,
has machinery which hooks components together ..
Interfaces, Adapters and ZCML, the configuration
language.

It sounds like the autocompleter code is able
to build indexes of classes and methods. It would
be cool if that capability could be extensible,
allowing building indexes of the couplings between
components.

I think this might look like some kind of automatic
hyperlinking, providing access to related code,
as defined for that application.

I really don't know if this makes sense, but
I see you moving in the direction of making Leo
capable of doing some _explaining_ of the code 
being written.
.. @+node:ekr.20120520113447.9874: *4* Kent: select node from traceback
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3593116
By: ktenney

When I have a traceback in the log pane, I'd love
to be able to select an item and cause the file
to appear in a node.
It would be cool to have 'Next' and 'Prev' 
capability while in this mode, effortlessly 
traversing views of the source of the stack items.
.. @+node:ekr.20130806211959.17365: *4* Leo as PIM and authoring tool
Josef <joe_da@gmx.net> 7/30/12
		
Recently I evaluated docear - a mind-mapping tool for collecting reference
data (written in Java). It automatically extracts bookmarks and annotations
from PDF files, and more, but it's support for authoring is still not up to
the task. I think it would be great if Leo could do some of the tasks
docear is doing.

Leo is primarily a literate programming editor, but also quite good at
organizing bits of information. Dragging a PDF into Leo currently just
creates an url to the PDF. This could be expanded to also extract data
(bookmarks, notes) from the PDF and to sync this data between Leo and the
PDF. This info could be placed in child nodes: bookmarks and notes could
even jump directly to the page in the PDF (although each PDF viewer seems
to have a different syntax for doing that). This would be a great way to
organize data sheets and specifications stemming from external sources.

Combining the above with an improved LaTeX support, one would get a very
powerful research and authoring tool - in my opinion with a much more
convenient interface than docear.

Perhaps it is too much work to duplicate all the work docear is doing. An
alternative may be to sync data somehow between docear and Leo. Docear
stores the data in a freeplane mind-map. Has anyone else thoughts about
this? Offray Vladimir Luna Cárdenas offray@riseup.net via googlegroups.com
	
7/30/12
		
I have been using Leo to write my thesis. I didn't know about Docear, but
my use was in some sense similar. I have a lot of @url links pointint to
the pdfs files and in a subtree I cut and paste the text of the pdf I want
to comment and made the comments inside the tree. These pdf were part of my
bibliographic entries and I'm now writing a .bib file for these, so I can
have in only one Leo tree all my thesis, with all the references to
external files and the annotations and bibtex entries for them. For me the
key point of Leo in academic writing is the tree view plus the clones and
ignore nodes. My thesis can have several layers, the external ones being
the actual writing and the deeper ones the references, texts, images, tools
that enable me to do that writing. Using clones and @rst-no-head directives
I can have the level of granularity of a paragraph, something that is not
possible on traditional word processor which are the writing tool of tools
like docear. This approach have some glitches:

* I still need to do some fine tunning to the LaTeX export for writing the
pdf as I want. I imagine that putting sphinx in the tool chain could change
that.

* I can not get much people of my companions using this advangages, besides
of myself, because of the difficult installation process of Leo in
Windows/Mac and the not so friendly interface for non-programmers. Other
light markup structured text writing programs like Nested[1] are more
easily used and understood despite of not having all the advantages and
flexibility of Leo.

So, in resume, may be the better approach is connecting Leo to Docear, so
you can have the advantages of both in terms of easy multiplataform
installation and friendly interface of the later and programmability,
flexibility and deeper organic structure of the former.

Offray

Terry Brown <terry_n_brown@yahoo.com>


> Recently I evaluated docear - a mind-mapping tool for collecting reference
> data (written in Java). It automatically extracts bookmarks and annotations
> from PDF files, and more, but it's support for authoring is still not up to
> the task. I think it would be great if Leo could do some of the tasks
> docear is doing.
>
> Leo is primarily a literate programming editor, but also quite good at
> organizing bits of information.

I would describe it as an general purpose outline that's very good at
editing code.

> Dragging a PDF into Leo currently just
> creates an url to the PDF. This could be expanded to also extract data
> (bookmarks, notes) from the PDF and to sync this data between Leo and the
> PDF. This info could be placed in child nodes: bookmarks and notes could
> even jump directly to the page in the PDF (although each PDF viewer seems
> to have a different syntax for doing that). This would be a great way to
> organize data sheets and specifications stemming from external sources.

I'm not really sure how notes get embedded in PDFs.  As an aside, there
is also capability for using Leo to manage bookmarks to web pages, with
notes, tags, and snippets.  Look at the mod_http plugin.  It uses a
javascript bookmark button in your browser to communicate with Leo.

> Combining the above with an improved LaTeX support, one would get a very
> powerful research and authoring tool - in my opinion with a much more
> convenient interface than docear.
>
> Perhaps it is too much work to duplicate all the work docear is doing. An
> alternative may be to sync data somehow between docear and Leo. Docear
> stores the data in a freeplane mind-map. Has anyone else thoughts about
> this?

Syncing between the two sounds a little cumbersome to me.  I wonder if
the PDF stuff could be integrated with some sort of BibTeX .bib file
management?

Do you really need the mindmap UI of docear?  I used to use Freemind
which has a very similar interface, but switched to Leo.  I like what
http://cmap.ihmc.us/ does, but it only does idea organization, no
authoring etc.  To me cmaptools is better at idea organizing than
mindmaps.

There is also the backlinks plugin for Leo, which allows arbitrary
networks of links instead of just the directed tree, and graphcanvas,
which allows graph layout of nodes.  There aren't comparable with the
mindmap layouts, but they head in that direction.  Also note Leo's
hidden UI flexibility in the context menus on the pane dividers, you
can open a new window for the graphcanvas plugin, which gives it much
needed screen real estate.

Cheers -Terry

Josef <joe_da@gmx.net>
7/30/12
		
no, I do not need the mindmap stuff at all. I had a look at short look at
cmaptools, and I agree the generalized graph approach seems better than a
standard mindmap. But I am quite happy with the tree view in Leo and as you
already mentioned, this can be extended with backlinks etc. I have used Leo
already to organize reference documents and write documentation (using
Latex).

What I do want is links to a particular page of a PDF - links to just a
file are not enough when you refer to documents with 100+ pages.
Unfortunately this seems to be difficult to achieve in a cross-platform
way, particular when trying to support different PDF viewers. Docear is
solving this (and other compatibility problems) by developing its own
integrated viewer (I do not suggest to do this for Leo).

On second thought, I don't think that extracting the bookmark and
annotation info is really important to me - I would keep that info in the
PDF, anyhow. I would write inside Leo addional notes, and the output text
(in Latex).

Some integration of Bibtex may be a good thing and needs to be thought out
- perhaps by using JabRef for this, or by recycling some pyBibliographer
code, but this is also low on my priority list.

Offray seems to have a very similar use case as I - although I do not write
a thesis, but specifications for scientific instruments. The point about
cross-platform installation ease is also well taken, so I will look into
some inter-operability here (either with docear or cmaptools). I see Leo
mainly as a personal project / information manager: the leo tree is not
easily shared with others, while the files Leo points to with @url, @auto,
@file etc can be shared quite easily. In this I use Leo as *my personal*
view on the project.

Ville Vainio <vivainio@gmail.com>
7/30/12
		
It seems that e.g. w/ foxit reader, you can open selected page from command
line (-n 123). Abstracting this for other pdf readers that support such a
thing should be no problem.
 
On Monday, July 30, 2012 8:08:23 PM UTC+2, Ville M. Vainio wrote:
     
    It seems that e.g. w/ foxit reader, you can open selected page from
    command line (-n 123). Abstracting this for other pdf readers that
    support such a thing should be no problem.
    
Yes, I suppose one could translate from a canonical representation inside
Leo to whatever the tool needs (using @setting). Ideally, one would even
have a choice between opening the new page in a different or in the same
PDF viewer instance as the last page, but few viewers support that (Okular
does - but I don't know any cross-platform solution).
.. @+node:ekr.20130806072439.21301: *4* Leo doc-generation and Wiki integration - GitIt and Pandocs
From: HansBKK <hansbkk@gmail.com>

This is highly off-topic for most on the list, so feel free to ignore, but 
anyone using Leo for single-source documentation generation/conversion, 
including future googlers, please reply with comments or notes on your 
experiences.

I have been advocating the idea of pushing Leo-derived content to DokuWiki 
as a platform for "wiki-publishing" to enable collaborative/community 
editing of content (1 <../d/msg/leo-editor/fSzVi1Rh5Tg/uu85satgb9YJ>, 2<../d/msg/leo-editor/xf6_HBxlV_c/4RgGYdDh8ywJ>). 
I've also talked about the markup syntax/doc generation tool Txt2tags (1<https://groups.google.com/d/msg/leo-editor/nNEnxoohFBM/XkMPQhqhDRsJ>, 
2 <https://groups.google.com/d/msg/leo-editor/HBhBnAyVG3E/UXHC1jq50iYJ> ).

However, I have recently learned of the wiki platform Gitit<https://github.com/jgm/gitit#readme>, 
which apparently, like DW, also uses plain-text files rather than a 
database back-end, and integrates not only with git but mercurial (and 
darcs).

Gitit also incorporates the Pandoc <http://johnmacfarlane.net/pandoc/>project for its markup syntax, therefore enabling not only markdown but 
reST as a master source input format, while DokuWiki has its own (yet 
another unique) markup syntax 8-( 

With the increasing likelihood that I'll be using Leo as the centerpiece of 
my toolchain, plus the fact that Pandoc is much more actively maintained, 
it's starting to look worth my while to consider switching my "master 
source" content syntax over from Txt2tags to reST. The only downsides are 
that Gitit is a Haskell project rather than Python, and one thing I like 
about Txt2tags is its support for conversion to AsciiDoc, rather than 
Pandoc's direct output to full-blown DocBook XML - but apparently even 
that's in the works in Pandoc's dev version.

Anyone in the Leo community using Gitit, especially for use beyond simple 
code documentation?
.. @+node:ekr.20130806072439.21302: *5* Re: Leo doc-generation and Wiki integration - GitIt and Pandocs
From: "Edward K. Ream" <edreamleo@gmail.com>

On Thu, Jan 19, 2012 at 8:09 PM, HansBKK <hansbkk@gmail.com> wrote:
> This is highly off-topic for most on the list, so feel free to ignore, but
> anyone using Leo for single-source documentation generation/conversion,
> including future googlers, please reply with comments or notes on your
> experiences.

No experience myself, but thanks for these interesting links.

EKR
.. @+node:ekr.20130806072439.21303: *5* Re: Leo doc-generation and Wiki integration - GitIt and Pandocs
From: =?UTF-8?B?T2ZmcmF5IFZsYWRpbWlyIEx1bmEgQ8OhcmRlbmFz?= <offray@riseup.net>

Hi,

I made some errors.

In this part:

El lun 23 ene 2012 07:22:21 COT, Offray Vladimir Luna C=E1rdenas escribi=F3=
:
>
> but at the end we could not intervene MoinMoin as much as we would=20
> like because of the server permissions, that why I started to look=20
> more integrated solutions of the development and deployment=20
> environment as web2py or seaside, but they're not wiki engines=20
> properly but web application frameworks (where you could build a=20
> wiki-engine if needed). But surely
>

"But surely" was not intended.

Cheers,

Offray

.. @+node:ekr.20130806072439.21304: *5* Re: Leo doc-generation and Wiki integration - GitIt and Pandocs
From: <offray@riseup.net>

El jue 19 ene 2012 21:09:26 COT, HansBKK escribi=F3:
> This is highly off-topic for most on the list, so feel free to ignore, bu=
t
> anyone using Leo for single-source documentation generation/conversion,
> including future googlers, please reply with comments or notes on your ex=
periences.

I'm using Leo in that scenario (for writing my Thesis and I hope my=20
students will use it in a similar fashion), so is not off-topic for me=20
and not for people who is using Leo primary for documentation.

> I have been advocating the idea of pushing Leo-derived content to DokuWik=
i as a
> platform for "wiki-publishing" to enable collaborative/community editing =
of
> content (1<../d/msg/leo-editor/fSzVi1Rh5Tg/uu85satgb9YJ>, 2
> <../d/msg/leo-editor/xf6_HBxlV_c/4RgGYdDh8ywJ>). I've also talked about t=
he
> markup syntax/doc generation tool Txt2tags (1
> <https://groups.google.com/d/msg/leo-editor/nNEnxoohFBM/XkMPQhqhDRsJ>, 2
> <https://groups.google.com/d/msg/leo-editor/HBhBnAyVG3E/UXHC1jq50iYJ>  ).


When you suggested DocuWiki I thought of MoinMoin which has also=20
support of plain files as storage mechanism but is also scalable to=20
databases if this is needed and it supports reStructuredText and is=20
made in python, a language that "leonizens" are familiar with.

> However, I have recently learned of the wiki platform Gitit
> <https://github.com/jgm/gitit#readme>, which apparently, like DW, also us=
es
> plain-text files rather than a database back-end, and integrates not only=
 with
> git but mercurial (and darcs).
>
> Gitit also incorporates the Pandoc<http://johnmacfarlane.net/pandoc/>  pr=
oject
> for its markup syntax, therefore enabling not only markdown but reST as a=
 master
> source input format, while DokuWiki has its own (yet another unique) mark=
up
> syntax 8-(
>
> With the increasing likelihood that I'll be using Leo as the centerpiece =
of my
> toolchain, plus the fact that Pandoc is much more actively maintained, it=
's
> starting to look worth my while to consider switching my "master source" =
content
> syntax over from Txt2tags to reST. The only downsides are that Gitit is a
> Haskell project rather than Python, and one thing I like about Txt2tags i=
s its
> support for conversion to AsciiDoc, rather than Pandoc's direct output to
> full-blown DocBook XML - but apparently even that's in the works in Pando=
c's dev
> version.
>
> Anyone in the Leo community using Gitit, especially for use beyond simple=
 code
> documentation?

Now that I'm using Leo + Fossil for my documentation related matters=20
and distributed work I certainly think that a distributed off-line=20
collaboration system for documentation is needed and, if MoinMoin can't=20
support the use of distributed wikis (and seems is not planned or in=20
development [1][2]) Gitit would be a nice place to start with this idea=20
and would offer advantages over the non-distributed and outdated Zope's=20
actual implementation, so, interested ones in the community could offer=20
an implementation of Gitit. On a related matter one of the problems I=20
see with actual server technology is its gigantism which concentrates=20
power in the people who has the resources, knowledge and time to=20
possess, understand and administer/intervene this technology so a=20
Global South Test for me about which server technology to choose is:=20
"it runs from a USB thumb drive?". This, for example, favors=20
Web2py/Smalltalk instead of Zope and Fossil instead of GitHub. May be=20
you should put this in the panorama when you judge GitIt or=20
Haskell/Pandoc. Pandoc, by the way, was for me a compelling reason to=20
learn Haskell[3] (but I thought that I would learn Smalltalk before)=20
because it deals elegantly with a problem in the diversity of markup=20
languages (txt2tags makes something similar but only in one way=20
translation) and for me the point of using Leo is having a tool to deal=20
consistently with diversity in the "sub-optimal distopic world of=20
everything is a file".

[1] http://moinmo.in/PawelPacana/MercurialBackend
[2] http://moinmo.in/MoinMoin2.0
[3] http://learnyouahaskell.com/

We could get philosophical here, and think about different programming=20
paradigms and languages that implement them with elegant syntaxes, like=20
Smalltalk, Haskell and Python versus the non elegant ones of .java, php=20
or ... (put your hated language here) and how this elegant syntaxes,=20
languages and computer using experience could cross-pollinate. If that=20
is the case, may be reading some about Combined Object Lambda=20
Architecture[4] and the comprehensive "Concepts, Techniques, and Models=20
of Computer Programming" by Van Roy and Haridi would be a nice reading.=20
Some times I dream of a world connected diversity where all the=20
problems of computer interaction can be solved by expressing that=20
diversity in fundamental constructs that respect it at the same time=20
that bring consistency and interface solving the apparent chaos and=20
noise.

[4] https://en.wikipedia.org/wiki/COLA_%28software_architecture%29

Cheers,

Offray

.. @+node:ekr.20130806072439.21305: *5* Re: Leo doc-generation and Wiki integration - GitIt and Pandocs
From: Matt Wilkie <maphew@gmail.com>

> Wow I think that this is the first time I have the opportunity to
> write (curiously in English instead of my native tongue) about
> that dystopy, because most of the time I just talk about this
> with my students or friends but not as detailed and contextually,
> so thanks for bring this up Hans, and thanks everyone else
> here who is still reading :-)

I am reading, and enjoying. The clouds you've placed in my mind are
making interesting shapes and I am intrigued. ;-)
.. @+node:ekr.20130806072439.21306: *5* Re: Leo doc-generation and Wiki integration - GitIt and Pandocs
From: =?UTF-8?B?T2ZmcmF5IFZsYWRpbWlyIEx1bmEgQ8OhcmRlbmFz?= <offray@riseup.net>

Hi,

El lun 23 ene 2012 01:18:48 COT, HansBKK escribi=F3:
> Thanks Offray for your detailed and informative response.

Well I'm enjoying also these talks with you. I think that putting=20
documentation also in the center is required if we want to break the=20
Leo's self-fulfilled prophesy about being a "ghetto tool" for=20
programmers only and I want this in the best way.

[..]
>
> I for some reason missed the MoinMoin's "simple page storage" option - th=
anks so
> much for pointing that out. For all the reasons you cite, and most import=
antly
> is much more mainstream, more actively developed and well-supported than =
Gitit,
> I'll definitely give it a higher priority in my testing.
[...]

I enjoyed using MoinMoin for this project:

http://el-directorio.org/

but at the end we could not intervene MoinMoin as much as we would like=20
because of the server permissions, that why I started to look more=20
integrated solutions of the development and deployment environment as=20
web2py or seaside, but they're not wiki engines properly but web=20
application frameworks (where you could build a wiki-engine if needed).=20
But surely

>      the "sub-optimal distopic world of everything is a file".
>
>
> I personally disagree with your dislike for "everything is a file" - I se=
e that
> principle as a fundamental part of the *nix tool philosophy, and IMO this=
 is a
> perfect example:
>
>      I certainly think that a distributed off-line collaboration system f=
or
>      documentation is needed and, if MoinMoin can't
>
>      support the use of distributed wikis (and seems is not planned or in=
 development
>
> To my mind, any wiki platform that can store the page data as plain text =
(as
> opposed to binary/database), in a format suitable for diff tools ("light"=
 markup
> as opposed to html/xml) can make use of whatever VCS for distribution/rep=
lication.

You're right and I like the idea of "everything is a something" when=20
that something is powerful unifying idea. That's the case with Unix's=20
"everything is a file" or Smalltalk's "everything is an object" (in=20
Unix you have also every tool makes one thing and makes it right,=20
combined with pipes). For me these two paradigm's were the ones that,=20
in 70's, were fighting for the mind share  about computer experience of=20
today and both of them won in a dystopic way, but for me "taking genius=20
to understand Unix simplicity"[0], was even more dystopic. When you're=20
trying to empower users the impedance between development and=20
deployment shows the dystopia, at least compared with the original=20
visions, so most of the "end users" cant change the tool that changes=20
them, so, someone else is making decisions about that changes and that=20
users.

[0] https://en.wikipedia.org/wiki/Unix_philosophy#Quotes

I like the simplicity of light markups and I try myself of not using=20
explicitly nothing as xml and I like also the idea of the light markup=20
being used by VCS tools. That's not where dystopia lies. The problem is=20
not about files or structure but about "meta-structure" (structure=20
talking about structure, as in meta-languages), specially=20
self-referential meta-structure, because self-referential=20
meta-structures are the key for self-directed change, as opposed with=20
change directed by others. When you see how the "world of everything is=20
a file" talks about itself, there is a lot of impedance and=20
discontinuity between source code, binary, apps and docs and there is a=20
long path for the user who is confined to using apps to create docs,=20
but never change the apps that could let she/he to change his/her=20
writing and that's why I want to use Leo this semester with=20
non-technical writers to explore the way that writing change the tool=20
that writes and not only the human who does.

For me a unified emergent meta-structure in the world of "everything is=20
a file" is where lies the power of Leo. You can use an outline to=20
change the way that Leo behaves and that's why having the Leo's=20
self-referential meta-structure is more powerful that the "dystopic=20
world of everything is a file" (in that world you don't have=20
meta-structure, only structure, mostly for storage purposes and the=20
intelligence to read/process it is mostly outside the file, in the=20
human reader, the compiler or the binary). What Leo does is to create=20
self-referentiality in the world of everything is a file by introducing=20
outlines that can talk/structure the files and that can talk about=20
outlines, i.e outlines that can talk about files and about themselves=20
and can reprogram the way Leo itself works, and so Leo is bridging the=20
gap between objects and files in a valuable and unique way.  But we=20
need still to improve, specifically we need a more elegant way to talk=20
about that files, specially about their changes in time, because is in=20
that change where talking with the distopic world has more problems and=20
possibilities, and that way I'm making the Fossil/VCS experiment and=20
also.

Wow I think that this is the first time I have the opportunity to write=20
(curiously in English instead of my native tongue) about that dystopy,=20
because most of the time I just talk about this with my students or=20
friends but not as detailed and contextually, so thanks for bring this=20
up Hans, and thanks everyone else here who is still reading :-)

>      On a related matter one of the problems I see with actual server tec=
hnology
>      is its gigantism which concentrates
>      power in the people who has the resources, knowledge and time to pos=
sess,
>      understand and administer/intervene this technology so a Global Sout=
h Test
>      for me about which server technology to choose is: "it runs from a U=
SB thumb
>      drive?".
>
> IMO "server" is a function, not a question of scale or complexity - the b=
etter
> question for my workflow is "does the app run portably?". I personally fi=
nd
> actually running stuff from flash drives too slow and data-dangerous.

I'm agree with you. Server and gigantism have not to be equal, but=20
unfortunately in the "dystopic informatic world" (where the previous=20
dystopia is just a part) they're most of the time. Portability is the=20
key, not flash drives. In my context they're just a medium to ask the=20
same as you, but also a way to let people take the technology with=20
them, no matter if they have access to a "classical" server.

>
> So far I've found that anything that runs under Linux is inherently porta=
ble in
> that sense.

Agreed. Having Leo + Fossil + Laptop ( ;-P ) gives me some kind of=20
portability, but we need more. That's why I think that we need a self=20
contained version of Leo with a default discourse about file flat world=20
change in time (at least for Windows), but ideally would be nice to=20
have something like the self-contained multiplatform Pharo's One Click=20
Experience[1]

[1] http://www.pharo-project.org/pharo-download

>      This, for example, favors Web2py/Smalltalk instead of Zope and Fossi=
l
>      instead of GitHub.
>
> I haven't any experience with these others, but note that Git does not =
=3D GitHub.
> I share your dislike for server/storage platforms out of my direct contro=
l, not
> least for privacy/security issues for many use cases. If I used Git for d=
ata
> distribution I wouldn't use GitHub, and my understanding is that even "Gi=
t for
> Windows" is already fully portable.

Oohh I don't make myself clear, sorry. Fossil compared with GitHub was=20
not because of the equivalence of Git and GitHub, but because of the=20
integration of web characteristics of GitHub in Fossil (wiki, tickets,=20
web interface and so on).

> For myself, I think mercurial would be a good fit, but my main point is t=
hat any
> moves toward a "distributed Leo" should IMO be VCS-agnostic, just as my p=
lans
> for enabling community editing of Leo-managed content will be wiki-platfo=
rm
> agnostic.

I fully share your opinion on that subjects, but in this case I want to=20
start by some specific implementation from which one start to abstract=20
that to think abstractly without any particular implementation in the=20
road, which is not your case, I just point to different implementation=20
strategies based on the same agnosticism/diversity as a valuable thing=20
to preserve.

> To me, the key enabler for that is "everything as a file". . .

For me the enabler is self-referential meta-structure

Thanks,

Offray

.. @+node:ekr.20130806072439.21307: *5* Re: Leo doc-generation and Wiki integration - GitIt and Pandocs
From: HansBKK <hansbkk@gmail.com>



Content-Transfer-Encoding: quoted-printable

On Monday, January 23, 2012 7:22:21 PM UTC+7, Offray Vladimir Luna C=E1rden=
as=20
wrote:
>
>
> documentation also in the center is required if we want to break the Leo'=
s=20
> self-fulfilled prophesy about being a "ghetto tool" for programmers only


Usability for clueless noobs is a lot of work, probably harder than the=20
complex whiz-bang functionality part.

And to take something as powerful and flexible as Leo and make it=20
accessible for noobs would require "lobotomizing" it to some extent, at=20
least hiding those features that weren't relevant to the intended=20
more-mainstream task at hand.

I imagine something like "application mode" flag at launch time=20
  - Leo as a journaling tool (like Rednotebook on steroids)
  - Leo as an Evernote-style note-taking brain extension
    - with user-accessible tagging, perhaps multiple headings per node?
  - Leo as a delicous-replacement (import/export/backup) bookmarks=20
management tool
  - Leo as a single-source multiple-output documentation management=20
meta-organizer and conversion-supporting tool

etc - very different UX - pane layouts, menu structures etc - for each=20
mode, but the same underlying code and data structures

but at the end we could not intervene MoinMoin as much as we would like=20
> because of the server permissions


ACLs is one of DokuWiki's strengths, as they target the corporate world (as=
=20
much as a FOSS tool can 8-)

> So far I've found that anything that runs under Linux is inherently=20
> portable in
>
> > that sense.
>
> Agreed. Having Leo + Fossil + Laptop ( ;-P ) gives me some kind of=20
> portability, but we need more.
>
Pocket-size portable HDD with USB2 / SATA2  (will soon start converting to=
=20
v3 of both, used to use Firewire), booted up using any arbitrary internet=
=20
cafe / friend / customer desktop.

ideally would be nice to have something like the self-contained=20
> multiplatform Pharo's One Click=20
> Experience[1]
>
> [1] http://www.pharo-project.org/pharo-download
>
Most of the mainstream distros now have easy-to-customize=20
create-your-own-distro LiveCD/USB+persistent storage projects. I've got a=
=20
portable drive that launches a GRUB2 boot menu letting me choose between=20
various configs of Fedora, Red Hat, Debian, Ubuntu and Slax, all of which=
=20
access shared /home and server-data partitions (which gets sync'd with my=
=20
central filer). Check out Sardu <http://www.sarducd.it/>, which also=20
handles all the mainstream recovery/rescue/sysadmin tools like grml,=20
pmagic, sysresccd - even BartPE, Win7 repair etc all on the same pocket=20
drive. . .
=20

> integration of web characteristics of GitHub in Fossil (wiki, tickets, we=
b=20
> interface and so on).
>
=20

> agnosticism/diversity as a valuable thing to preserve.

=20
Personally I prefer using CLI batch/scripts and/or TortoiseXX rather than a=
=20
web interface for my VCS usage, and my ticket/project management/GTD system=
=20
of choice is Redmine (likely Chili soon).=20

Both of these integrate well with the important VCSs, so when I finally get=
=20
away from SVN and get familiar with the distributed new kids, I can keep my=
=20
other tools - Redmine/Chili now has such a custom-infrastructure encrusted=
=20
around it sync'ing with gcal, printing pocketmods for my calendar and=20
@context to-do's that have become indispensable to my day-to-day life=20
management.

=20

> "dystopic world of everything is a file" (in that world you don't have=20
> meta-structure, only structure, mostly for storage purposes and the=20
> intelligence to read/process it is mostly outside the file, in the human=
=20
> reader, the compiler or the binary). What Leo does is to create=20
> self-referentiality in the world of everything is a file by introducing=
=20
> outlines that can talk/structure the files and that can talk about=20
> outlines, i.e outlines that can talk about files and about themselves=20
> and can reprogram the way Leo itself works, and so Leo is bridging the ga=
p=20
> between objects and files in a valuable and unique way.  But we need stil=
l=20
> to improve, specifically we need a more elegant way to talk about that=20
> files, specially about their changes in time, because is in that change=
=20
> where talking with the distopic world has more problems and=20
> possibilities, and that way I'm making the Fossil/VCS experiment and also=
.
>

> To me, the key enabler for that is "everything as a file". . .
>
> For me the enabler is self-referential meta-structure
>
=20
I don't see any conflict between the two, IOW no inherent limitations to=20
"everything is a file" other than (to me, at least within the personal-use=
=20
prototyping context) unimportant factors like relative speed/scaleability -=
=20
it's "just" an implementation detail.=20

The various levels of structural overlays as presented within Leo as=20
"uber-manager of the metadata" can be as flexible and complex as can be,=20
and still be stored/distributed as diffed/versionable/convertable files at=
=20
whatever appropriate level of granularity to support integration with=20
outside toolchains. To the extent design choices are made that "lock in" to=
=20
a particular "higher level" technology bet, e.g. a specific database engine=
=20
or DVCS, then much higher-level programming/sysadmin skills are required in=
=20
order to integrate Leo into the thousands of mainstream tools that have=20
evolved over time to support structured-plain-text.

Look at source code - after all these decades, it's still stored as plain=
=20
text in a filesystem. There's a reason for that - any language that=20
required its modules/functions/objects whatever to be stored in a=20
"proprietary" database engine for example would have very limited uptake,=
=20
because coders would have to put so much effort into infrastructure=20
overhead work to be able to keep working with their preferred toolset.=20
Anyway 'nuff said on that.

.. @+node:ekr.20130806072439.21308: *5* Re: Leo doc-generation and Wiki integration - GitIt and Pandocs
From: Largo84 <Largo84@gmail.com>

This topic is of much interest to me as I use Leo primarily for writing 
documentation (mostly LaTex, some html and some rST). I haven't worked w/ 
Pandoc yet but am interested in some of the possibilities. Thanks for the 
links, I'll check them out.
.. @+node:ekr.20130806072439.21309: *5* Re: Leo doc-generation and Wiki integration - GitIt and Pandocs
From: HansBKK <hansbkk@gmail.com>



Content-Transfer-Encoding: quoted-printable

Thanks Offray for your detailed and informative response.

On Friday, January 20, 2012 5:34:21 PM UTC+7, Offray Vladimir Luna C=E1rden=
as=20
wrote:
>
> When you suggested DocuWiki I thought of MoinMoin which has also support=
=20
> of plain files as storage mechanism but is also scalable to databases if=
=20
> this is needed and it supports reStructuredText and is made in python, a=
=20
> language that "leonizens" are familiar with.
>
 I for some reason missed the MoinMoin's "simple page storage" option -=20
thanks so much for pointing that out. For all the reasons you cite, and=20
most importantly is much more mainstream, more actively developed and=20
well-supported than Gitit, I'll definitely give it a higher priority in my=
=20
testing.

=20

> the "sub-optimal distopic world of everything is a file".
>
 =20
I personally disagree with your dislike for "everything is a file" - I see=
=20
that principle as a fundamental part of the *nix tool philosophy, and IMO=
=20
this is a perfect example:

 I certainly think that a distributed off-line collaboration system for=20
> documentation is needed and, if MoinMoin can't=20
>
> support the use of distributed wikis (and seems is not planned or in=20
> development
>
To my mind, any wiki platform that can store the page data as plain text=20
(as opposed to binary/database), in a format suitable for diff tools=20
("light" markup as opposed to html/xml) can make use of whatever VCS for=20
distribution/replication.

=20

> On a related matter one of the problems I see with actual server=20
> technology is its gigantism which concentrates=20
> power in the people who has the resources, knowledge and time to possess,=
=20
> understand and administer/intervene this technology so a Global South Tes=
t=20
> for me about which server technology to choose is: "it runs from a USB=20
> thumb drive?".
>
IMO "server" is a function, not a question of scale or complexity - the=20
better question for my workflow is "does the app run portably?". I=20
personally find actually running stuff from flash drives too slow and=20
data-dangerous.

In my workflow, at the beginning of a session I first sync the relevant=20
data and "portable apps" filesystem branches, then run everything off the=
=20
local HD. At the end of a session I sync it all back - most of the time=20
these days this is to/from a central filer, but I do have portable drives I=
=20
use for this when that's required or more convenient, which then get sync'd=
=20
to the filer next chance I get.

So far I've found that anything that runs under Linux is inherently=20
portable in that sense.
=20

> This, for example, favors Web2py/Smalltalk instead of Zope and Fossil=20
> instead of GitHub.
>
I haven't any experience with these others, but note that Git does not =3D=
=20
GitHub. I share your dislike for server/storage platforms out of my direct=
=20
control, not least for privacy/security issues for many use cases. If I=20
used Git for data distribution I wouldn't use GitHub, and my understanding=
=20
is that even "Git for Windows" is already fully portable.

For myself, I think mercurial would be a good fit, but my main point is=20
that any moves toward a "distributed Leo" should IMO be VCS-agnostic, just=
=20
as my plans for enabling community editing of Leo-managed content will be=
=20
wiki-platform agnostic.

To me, the key enabler for that is "everything as a file". . .
.. @+node:ekr.20130806072439.21323: *4* Leo reader as a web app
From: "Ville M. Vainio" <vivainio@gmail.com>

I want to do some technology evaluation, so I will start doing a Leo
file reader for mobile devices using:

- jQuery mobile
- CoffeeScript

This can be deployed on web or locally. Interesting use cases are
browsing Leo notes you composed elsewhere on your tablet, and
publishing leo docs on the web (e.g. we could host fully browseable
leo source outline on Leo website)

I will notify the mailing list on the progress; it may be slow since I
don't have much contiguous time slots for hobby projects at the
moment. If someone wants to hop along, all the better; I'll probably
start the project at github once I have something that runs on a
desktop browser properly.

===== <offray@riseup.net>

Me and some friends where just thinking (but still I can not express my 
thoughts in code) in having something like and Etherpad[1] + Leo real 
time outliner and document creator. And I thought that would be nice to 
learn web2py in order to create the app and may be have jstree[2] or 
dynatree[3][4] as a way to create the heads of the nodes and put them in 
the web. Every node would be an etherpad-lite document ready for 
collaboration. At this point I have only links and no development now or 
in the coming times, but may be this can be helpful for your project.

[1] http://etherpad.org/
[2] http://dev.s-cubism.com/plugin_jstree
[3] https://code.google.com/p/dynatree/
[4] http://wwwendt.de/tech/dynatree/doc/samples.html

By the way I have been using txt2tags again for writing real-time 
structured docs with my students using etherpads and is really easy. Now 
I have found a txt2tags multiplataform editor at:

http://nestededitor.sourceforge.net/about.html

may that project be of some inspiration,
.. @+node:ekr.20130806072439.21332: *4* Leo tags *
From: Terry Brown <terry_n_brown@yahoo.com>

Does leo need tags for nodes?

===== Kent

Yes. My view of Leo as a data manager means I want tags. I've been thinking
I'd address them in the context of the db of nodes, all the better if they
were native.

===== EKR

A very quick first response.

- Support for tags as uA's would be natural.
- User interface issues more complicated, of course.
- In general, Leo has not paid enough attention to searches/tags as alternatives to clones.
- Finding by tag, cloning by tag, etc. all seem natural.
- Kent's and Terry's suggestions are always worth consideration :-)

===== Jacob Peck <gatesphere@gmail.com>

I sort of implemented tags in my rpg.leo project - basically a series of
buttons that interacted with the nav pane to search for hashtags, which
were simply part of headlines.

It worked, it was simple, and to be honest, I don't think that Leo really
needs them. I'm sure there is some functionality that I'm missing out on,
though. Perhaps for those who don't wish to maintain lists of clones, or
for sorting into groups based on common tags. Perhaps even a view-rendered
extension that would render a clickable tag cloud of an entire outline?

===== Terry

Interface wise I see something similar to the the bookmarks.py
interface, shown in the attached, colored strings indicating the tags a
node has, probably a bit smaller.  Various commands and clicks for
adding or removing tags and navigating through the nodes with a
particular tag, or set of tags.

===== Kent

Display location, maybe a tab in the output pane.
Maybe enter them via minibuffer?
<alt-x> tags= ideas, terry, tagging

Maybe they could display in the minibuffer until <alt-x> was pressed. IE;
tags for current node on display until minibuffer is needed.

===== Terry

This would be useful for all sorts of things, but Leo, being Leo,
already has features that overlap functionality wise.  You could
collect clones of all the nodes you want to identify with a particular
tag, under a single parent node, which becomes the tag proxy thing.

You can do something similar with the backlinks.py plugin which provides
unrestricted node linking, just link all the nodes which need a
particular tag to a particular node.

But I'm guessing only a tag centric UI component will give the quick
and easy use you'd want from a tagging system.  Data wise I guess tags
could be a simple list of string, p.v.u['_tags'], with Leo maintaining
an index of tag to node list mappings.

===== Kent

wish list:
- tab completion / drop-down list to prevent creating similar tags
- import / export of tags, encourage consistent ontologies
- hooks which parse the node content, create tags from them
.. @+node:ekr.20130806072439.20430: *4* minor dabbrev improvements
was: Does dabbrev work?
From: "F.S." <speech.free@gmail.com>

The answer seems to be based on the exchange here:
https://groups.google.com/forum/?fromgroups=#!searchin/leo-editor/dabbrev/leo-editor/3A4JOHqhJSU/W1DjTvooNCkJ

Summary: Alt-/ always shows a completion list. Backspace works as expected:
showing more and more items.  Nothing needs to be done.

**Possible minor improvements**

In Emacs M-/ (dabbrev-expand) just expands to the first choice. You then
cycle through the choices by repeating M-/. If you go too far you can cycle
back with C-/. C-M-/ (dabbrev-completion) expands to the longest common
prefix.

With 5473: I seem to already get the behavior you are talking about: that on
M-/ I get a completion list. I agree that getting a list is nice, esp if
<backspace><tab> show more choices. (It does).


I think there are a few use cases here:
1) I know exactly what I want but I just don't want to type it again (I may 
be lazy or I don't want to create a typo) so give it to me with as few key 
strokes as possible
2) I am not quite sure so let me see the choices
3) None of the choices is what I need so let me go back and show me some 
more choices

Maybe a combination of behavior is the best. With M-/ and C-/ one just 
cycles through the choices (auto inserted), which takes care of 1). 
With C-M-/ (dabbrev-completion) one gets the longest prefix auto inserted 
and a list of choices. Now it would be truly great that if we can easily 
just <backspace><tab> to see potentially more choices. But how do you 
interface with both? For 2) one desires to type just one more letter so as 
to make a choice in the choice list. For 3) we need to go back but may need 
backspace quite a bit to get back to before where we started (the only 
place where we can get new choices) -- can that be achieved with a single 
backspace instead?

For example suppose I have abcdefg and abwxyz. I type abc, C-M-/ and 
abcdefg is the sole completion. I may not want it but it would be nice to 
not have to backspace all the way to b to see the other choice. In other 
word if I backspace at all it is understood that I want to go before where 
I started (before where the auto insertion takes place). That would be neat!


@language python
.. @+node:ekr.20140921072018.17937: *4* New separate-process commands
@language rest

run-script-from-bridge
run-script-externally
    * Specify which version of python to use.
    
*** The at_produce plugin now has technology for reporting progress using
the IdleTime class.

This technology should become part of g.execute_shell_commands. New
settings will control whether, and how often, to report progress.

*** There will soon be two new functions for running both Leo and non-Leo
scripts externally.

- g.run_python_script_externally would simply create an external file
  containing the script and then run python on that file.

- g.run_leo_script_externally would do something similar using the Leo
  bridge.

Both functions would be controlled by new settings, including (Kent will be
glad) what version of Python.

*** Revise http://leoeditor.com/leoBridge.html

There are several ways to run code externally:

- Using leo.core.leoBridgeTest.
- (When ready) using g.run_leo_script_externally.
- Using the full-blown method that Terry discusses in that chapter.
.. @+node:ekr.20140921072018.17938: *5* Settings for at-produce plugin?
* Why not just improve g.execute_shell_commands ?
    - It could report too.
    - And it could use settings too.

- time-between-notifications: 0 means disable notifications.
- Decrease time between calls to idle-time handler.
.. @+node:ekr.20140919052413.17946: *5* Revise leoBridge docs
Do this after the new run-script commands
.. @+node:ekr.20140922043414.17947: *6* Solution 1
# http://leoeditor.com/leoBridge.html#running-leobridge-from-within-leo

import sys
import subprocess
path = r'c:\Users\edreamleo\test\leo_bridge_test.py'
    ### Create file containing script
assert g.os_path_exists(path)
proc = subprocess.Popen([sys.executable,path])
proc.communicate()
.. @+node:ekr.20140921072018.17943: *7* leo_bridge_test.py (defined in ekr.leo)
'''A minimal Leo bridge application'''
# This can not be run locally!
import leo.core.leoBridge as leoBridge
b = leoBridge.controller(
    gui='nullGui',loadPlugins=True,
    silent=False,tracePlugins=True,verbose=False)
g = b.globals()
path = g.os_path_finalize_join(g.app.loadDir,'..','doc','LeoDocs.leo')
assert g.os_path_exists(path)
c = b.openLeoFile(path)
assert c
assert c.rootPosition()
.. @+node:ekr.20140922043414.17948: *6* Solution 2 (test)
# From within the bridge, do:
import leo.core.leoTest as leoTest
helper = leoTest.RunTestExternallyHelperClass(c,all=True,marked=False)
helper.runUnitTestLeoFile(
    path='unitTest.leo',
        # The path, relative to leo/test.  The full path will be:
        # g.os_path_finalize_join(g.app.loadDir,'..','test',relative_path)
    gui=None, # Use a Null gui.
    loadPlugins=True,
    readSettings=True,
    silent=True,
    tracePlugins=True,
    verbose=True,
)
.. @+node:ekr.20140922043414.17949: *6* Solution 0 (already documented)
import leo.core.leoBridgeTest as leoBridgeTest

leoBridgeTest.main()
.. @+node:ekr.20130806072439.21341: *4* Node pipes
From: Kent Tenney <ktenney@gmail.com>

The editor envy resulting from the Light Table demo has me revisiting
a feature that's been percolating.

Sending output to the log pane is very useful, it's how Leo talks back.

Executing from the command line means one space for input and output.

Executing in a Leo node and writing to the log improves on this by providing
different spaces for input and output.

Could Leo generalize this concept such that any node could be designated as
a destination for output?

Given multiple visible nodes, akin to Terry's stickynotes, or Ville's
recent grid
suggestion, Leo could duplicate the power of simultaneous feedback shown
by Light Table.

I guess 'rendering' addresses this to some degree.

Reminds me of the power graph database folks talk about, where you can
define nodes and edges to be whatever you want.

The nodes could be sources or sinks.
Sources: code or commands ...
Sinks: standard out, tail -f logfile, network traffic, introspection ...

The edges would define handlers for the content of the sources, format the
results and send to the sinks.

So, as I write code in one node, I can see a node displaying stdout, another
watching a log file, another showing docstrings, another showing test
results ...

===== Ville

The 'ileo workbook' concept is relevant; it allowed you to easily reference
other nodes in your scripts (wb.foo meant node with headline 'foo').

It's nice in theory, but the rigid ui model where we show only one node at
a time made it hard to visualize. Tabula or grid would make it more
concrete and intuitive - you could show input, output and the manipulator
script at the same time. Or make small nodes with intermedote results etc.

How this would relate to 'pipeline' - you would have explicit way to say
what nodes are input, whan nodes are output and what are the scripts that
transform input to output. Editing inputs or scriyts would ping you somehow
that outputs are out of date, allowing you to easily press button to
recalculate outputs.
.. @+node:ekr.20130806072439.21342: *5* Re: Node pipes
From: "Edward K. Ream" <edreamleo@gmail.com>

On Wed, Apr 18, 2012 at 9:48 AM, Kent Tenney <ktenney@gmail.com> wrote:

> Could...any node...be designated as a destination for output?

Certainly.  Just assign to v.b in the appropriate place.

> could [Leo] duplicate the power of simultaneous feedback shown by Light Table.

Yes, provided somebody understands what the simultaneous feedback is ;-)

Tabula might be natural for that, perhaps enhanced via free_layout.

> I guess 'rendering' addresses this to some degree.

Interesting connection.  We might want to render to tabula nodes.

> Reminds me of the power graph database folks talk about, where you can
> define nodes and edges to be whatever you want.

This is coming.  Redefining edges would be easy provided that they had
different colors from the "main" edges.

> The nodes could be sources or sinks.
> Sources: code or commands ...
> Sinks: standard out, tail -f logfile, network traffic, introspection ...

Yes.  This is a straightforward generalization of your first question.

> The edges would define handlers for the content of the sources, format the
> results and send to the sinks.

A new idea!  This could be revolutionary!

> So, as I write code in one node, I can see a node displaying stdout, another
> watching a log file, another showing docstrings, another showing test
> results ...

To paraphrase: nodes and links are not simply ways to represent
structure.  They may have independent identity and function.  A
brilliant idea.

Edward
.. @+node:ekr.20130806072439.21344: *5* Re: Node pipes
From: "Edward K. Ream" <edreamleo@gmail.com>

On Wed, Apr 18, 2012 at 11:47 AM, Kent Tenney <ktenney@gmail.com> wrote:

>> Certainly. Just assign to v.b in the appropriate place.
>
> Right. Leo can be considered a programming language, it is able
> to do most anything one dreams up. Here we are discussing what
> features are appropriate to add to the 'standard library' IE: put the
> effort into making the capability an API call instead of a bunch of code.

In fact, the inadequacy of my remark that assigning to v.b was all
that was needed lead me to consider the broadcaster/listener
framework.

The idea is that the v.b setter property would broadcast the fact that
v.b has changed to all the listeners connected to v.  Presumably,
those listeners will be UI elements that will update their text from
v.b and recolor as appropriate.

We might generalize this concept to update outline structure in those
UI elements that show outlines.

> My impression of the Light Table demo is that the right side of the scree=
n was reporting interesting information about what was being typed on the l=
eft side. Seems like it could be called "simultaneous feedback"

An excellent generalization.  We can use this without knowing exactly
what the feedback is, or where it comes from.

> I'm unable to keep up, unaware of the capability of free_layout,
> tabula, rendering, but I expect most if not all of the tools are availabl=
e.

Keeping up with ourselves these days seems like a full-time job.

I believe a broadcaster/listener event framework is an essential
ingredient.  It shouldn't be too hard to do, it will simplify existing
code, and it will be an enabling technology that will stimulate
further development.
.. @+node:ekr.20130806072439.21349: *4* OMG: @nosent should put headlines as comments
From: "Edward K. Ream" <edreamleo@gmail.com>

I've been blind all these years!  @nosent should put headlines as nodes a 
comments.  They would be very useful and I can see no reason not to put 
such comments.  If, for some reason, they are not desired, you could use 
@asis.

===== Ville

I use @nosent for non-code text mostly, and it's not clear what "comment"
should mean in that context.

I for sure would like this kind of feature, but sometimes I'd like to have
the headlines written as reST style headlines (underlines), etc.

So this is not a complete no-brainer modification.

===== EKR

I agree.  Some more thought is needed.

===== Ville

Instead of changing how Leo fundamentally behaves (@nosent is part of
that), how about adding a new @directive that allows things like this? E.g.
"@write a.txt" would be nice & "obvious".

===== EKR

In this case, adding support for a new directive might be more complicated
than changing @nosent :-)

.. @+node:ekr.20111125072438.10219: *4* Open file dialogs starting with @path directory
@nocolor-node

File 'Open' or 'Import File' command to follow @path directive
http://groups.google.com/group/leo-editor/browse_thread/thread/7e508921c85d18bc

Suppose my focus node is under a @path directive, say @path E:
\Documents\Some Folder\

Is there a setting that would cause the 'File>Open' or 'File>Import
File' commands to begin the search dialog in the directory, E:
\Documents\Some Folder\ instead of the last directory used?

Would others find this a useful feature?
.. @+node:ekr.20111221114145.10217: *5* Found: runOpenFileDialog
# Important: many plugins use g.app.gui.openFileDialog.
.. @+node:ekr.20141103113220.10: *4* Parameterized template nodes
From: Alexandre_Toledo <jalexandretoledo@gmail.com>

As I use Leo to write PL/SQL code, I need to write similar text several
times, changing only small parts of it. It would be great if I could create
a node with the "template" and then clone it everywhere it should be
written, and then providing the parameters to be used in this writing.

Let me try to clarify it. I'd like to create a tree like this:

    +- @file something.sql
       +- Section 1
          + << Clone >> with Parameters A, B
       +- Section 2
          + << Clone >> with Parameters C, D

In this tree, both "Clone" nodes would be generated from a template
specified somewhere in the tree, and would have parts of its text replaced
with values "A" and "B" in Section 1, and "C" and "D" in Section 2.

I've searched but couldn't find anything like this, then I've thought of
trying to write a hook to intercept the "save" command, but couldn't think
of a way to pass the parameters; I think the obvious way would be to put
the parameters after the "<< >>", but then all cloned nodes are changed, so
it wouldn't work.

Another alternative would be creating some kind of directive @something,
but I have no idea of how to do that.

Any ideas?
.. @+node:ekr.20141103113220.11: *5* OP: Re: Parameterized template nodes
I've tried it and it's great, I think it will be useful, but it's not what
I was thinking of...

Let me try to explain what I had thought about.  What I would like to do is:

 1. create a new .leo file
 2. add a "template" node (eventually with sub nodes) with some ${schema}
    and ${table} macro place holders in its contents
 3. add a @file node to the .leo file
 4. add to this @file node a new one with definitions such as
    schema=3DSCHEMA_NAME and table=3DTABLE_NAME
 5. add as a sub node to this last one a clone from the "template" node;
 6. then, when I save everything, the @file would have "SCHEMA_NAME" and
    "TABLE_NAME" everywhere a "${schema}" or a "${table}" were in the original
    template node.

It would be important that, when I reopen the .leo file later, the macros
in the @file node where shown as ${schema} and ${table}, and not as it's
substituted text.

Now that I've described it, I can't see how it would be done... The
${macro} place holders should be on the contents of the @file node, so
after substitution, how could we recover it?

That's also why the code from Jacob is not what I need (but I'm already
thinking of other uses for it :) ): it will create a text when the button
is pressed, but the generated nodes will be just static text.
.. @+node:ekr.20130806072439.21370: *4* Parameterized template nodes
From: Alexandre_Toledo?= <jalexandretoledo@gmail.com>

As I use Leo to write PL/SQL code, I need to write similar text several
times, changing only small parts of it. It would be great if I could create
a node with the "template" and then clone it everywhere it should be
written, and then providing the parameters to be used in this writing.

Let me try to clarify it. I'd like to create a tree like this:

 +- @file something.sql
           +- Section 1
              + << Clone >> with Parameters A, B
           +- Section 2
              + << Clone >> with Parameters C, D

In this tree, both "Clone" nodes would be generated from a template
specified somewhere in the tree, and would have parts of its text replaced
with values "A" and "B" in Section 1, and "C" and "D" in Section 2.

I've searched but couldn't find anything like this, then I've thought of
trying to write a hook to intercept the "save" command, but couldn't think
of a way to pass the parameters; I think the obvious way would be to put
the parameters after the "<< >>", but then all cloned nodes are changed, so
it wouldn't work.

Another alternative would be creating some kind of directive @something,
but I have no idea of how to do that.

Any ideas?

===== EKR

Variants of this seem to be wanted by many people.  Most recently, there is
the thread, "Templates with macro expansions",
https://groups.google.com/forum/?fromgroups=3D#!topic/leo-editor/nF2lUEUtaUE

Does that do what you want?
.. @+node:ekr.20130806072439.21371: *5* Re: Parameterized template nodes
@nocolor

From: <fidelperez@gmail.com>

I know a programming IDE
<http://sourceforge.net/projects/doublesvsoop/>which bases its existence in
that concept:

You write "code Masks" and whenever you call a piece of code it will ask
only for the parameters, and write the rest of the code. There are already
some languages with most of the masks (all the primary functions and some
complex ones) and its growing.

For instance, if you write:

"window" it will add the window to the code and let you edit the params.

Their functionality would be awesome in Leo and when I know a bit better I
will try to emulate on it. Sticking to Leo tho since it has a much superior
way of managing data.
.. @+node:ekr.20130806072439.21372: *5* Re: Parameterized template nodes
@nocolor

From: Terry Brown <terry_n_brown@yahoo.com>

On Sun, 5 May 2013 16:35:59 -0700 (PDT) <fidelperez@gmail.com> wrote:

> I know a programming IDE <http://sourceforge.net/projects/doublesvsoop/>which bases its existence in that concept:
>
> You write "code Masks" and whenever you call a piece of code it will ask
> only for the parameters, and write the rest of the code. There are already
> some languages with most of the masks (all the primary functions and some
> complex ones) and its growing.

I suspect different people have different things in mind when they talk
about templates.

Leo's abbreviation system is already quite advanced when it comes to
filling in skeletons of common code layouts.  I type

  def;;

and I get

  def foo(this, that=3D3):
      """foo - Return
 
      :Parameters:
      - `this`: <|describe this|>
      - `that`: <|describe that|>
      """
 
      <|code|>

Two "parameters" are interactively requested, the function name, and
the list of arguments.  The node name is presented as the default for
the function name, and 'self' is included in the list of arguments, so,
assuming the node was already called 'foo', all I type is this, that=3D3.
The layout above is the rst form of the epydoc/sphinx docstring with
formally identified parameters.

The cursor is positioned after Return, where the was an empty <||>
placeholder.  Pressing ,, selects the next placeholder so that typing
replaces it.

There's more, see
https://groups.google.com/forum/?fromgroups=3D#!topic/leo-editor/5ni2PwfmBz8
and the screencast linked from there
http://www.greygreen.org/tmp/leoabbrev.ogv

Other people, Jacob etc. I think, have been talking about templates
where the input parameters are stored in the outline, allowing for
some of them to be altered and the template generation step re-run.
More like generating a website from data etc.
.. @+node:ekr.20130806072439.21375: *5* Re: Parameterized template nodes
@nocolor

From: <jalexandretoledo@gmail.com>

I've tried it and it's great, I think it will be useful, but it's not what
I was thinking of...

Let me try to explain what I had tougth about... What I would like to do is:

 1. create a new .leo file
 2. add a "template" node (eventually with sub nodes) with some ${schema}
and ${table} macro place holders in its contents
 3. add a @file node to the .leo file
 4. add to this @file node a new one with definitions such as
schema=3DSCHEMA_NAME and table=3DTABLE_NAME
 5. add as a sub node to this last one a clone from the "template" node;
 6. then, when I save everything, the @file would have "SCHEMA_NAME" and
"TABLE_NAME" everywhere a "${schema}" or a "${table}" were in the original
template node.

It would be important that, when I reopen the .leo file later, the macros
in the @file node where shown as ${schema} and ${table}, and not as it's
substituted text.

Now that I've described it, I can't see how it would be done... The
${macro} place holders should be on the contents of the @file node, so
after substitution, how could we recover it?

That's also why the code from Jacob is not what I need (but I'm already
thinking of other uses for it :) ): it will create a text when the button
is pressed, but the generated nodes will be just static text.
.. @+node:ekr.20130806072439.21380: *4* QML - new window / gui / coding for Leo?
From: Terry Brown <terry_n_brown@yahoo.com>

This thread will need Ville to set it on the right track, I barely know
the names of the technologies, but Qt has been advancing with, quoting
from their site:

Qt Quick

The Qt UI Creation Kit lets you create rich, touch-enabled UIs and
apps...quickly.

  * QML - CSS & JavaScript like language, same code base for UI
    designers & developers

  * Supported by Qt Creator IDE for rapid prototyping and development

  * Qt Quick UI runtime - Direct access to native APIs, performance
    boost with C++

I think the first bullet is most relevant to Leo.  Could we embed this
kind of environment in Leo?  Can it be integrated effectively with the
current GUI?

That route might make adding task specific GUIs in Leo quick and easy.

Not for the touch part (although Leo on a tablet would be fun), but as
a way of quickly creating task specific GUIs, "forms" if you like, for
accessing / interacting with the data in a Leo outline.  I'm assuming
that QML is higher level / less coding the regular PyQt programming,
but I don't know that, not having tried it.

===== Ville

QML is actually lower level than QWidgets / "regular" PyQt
programming. Key selling point of QML is that the UI's are more free
form, "custom" and much faster than QWidget UI's (in Qt5, QML maps
quite naturally to OpenGL, making it fly on mobile phone/tablet
hardware).

QML would be natural for graphcanvas / tabula / other "custom" ui
plugins, but it doesn't yet have text editor as powerful as QTextEdit,
not tree widget as powerful as QTreeWidget / QTreeView.

I expect QML to be first used in mobile version of Leo (I have one
actually, that I will publish "at later date" ;-). For desktop, QML is
not yet as attractive as the "old stuff".


.. @+node:ekr.20100223123910.5930: *4* recentFilesController
@
The present operation of recent files is surprising.

Recent files should be a global list, managed by a single controller.
.. @+node:ekr.20140104063158.16448: *4* reload-abbreviations and reload-key-bindings commands
reload-abbreviations and reload-key-bindings commands.
    Use regex replace to replace settings ivars with @property defs.

@language python
.. @+node:ekr.20140312052111.16811: *5* Notes
@language rest

https://groups.google.com/forum/#!topic/leo-editor/gEktoPf6aVc

    I've put adding new reload-abbreviations and reload-key-bindings
    commands on the list of things to do asap. These are non-trivial
    commands, but they should have been ​done ​ years ago. I'll see what I
    can do in the next day or so.


​Updating the configuration tables in leoConfig.py is straightforward, a​s
it turns out. Naturally, there are complications, all involved cached
settings, in one forma or another.

1. The easy cases: use properties.

There are about 60 or 70 places in the code where config settings are
stored in an ivar. Usually for readability, not for speed.

The solution (tested) is simple: rather than do:

    self.setting_ivar = c.config.getX('a-setting-name')

Leo could define a property:

    @property
    def setting_ivar(self):
        return c.config.getX('a-setting-name')

No other changes required. The existing code will test self.setting_ivar
exactly as before, but now any recent changes to the setting will have
effect.

I'll make these changes using a script.

2. The harder cases: use a reload_setting method in the affected classes.

Several subcommanders create tables on startup using config settings.
c.abbrevCommands is one such subcommander.

These classes should have a reload_settings method, called whenever
settings are dynamically reloaded.

Key bindings are the hardest case: the tables for key bindings are
mind-bogglingly complex. k.reload_settings would be a piece of work, but in
theory it should be possible.
.. @+node:ekr.20140630071432.16748: *5* Related methods
lm.doPrePluginsInit
lm.computeLocalSettings.
g.GeneralSetting
LM.Settings suboutline.
abbrevCommandsClass
    init_abbrev
.. @+node:ekr.20140104063158.17235: *5* Found: \w*\.\w*\s*=\s*c.config.get
# About 65-70 matches.
.. @+node:ekr.20110621085435.6532: *4* Request: have equal-sized-panes resize vr pane
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/583bc0a31a6c7979

I noticed that when the renderpane is active it is not affected by the
Window>Equal Sized Panes command. Only the Outline and Body Panes are affected -
just as described in
http://webpages.charter.net/edreamleo/outlines.html#resizing-panes. However from
the user perspective the current behaviour appears as though the command is only
partially successful. Since there are specific commands to contract/expand the
log pane, shouldn't the log and render panes also be affected by the
Window>Equal Sized Panes command?


I suppose so.  I would prefer to wait for Terry to finish his
pane-generalization code before dealing with this.
.. @+node:ekr.20111018104244.15933: *4* script to create documentation for commands/plugins
@language rest

Command docs
------------

This will create large docs for individual commands from docstrings.

Base this on print-cmd-docstrings.

Plugins docs

Leo must have a create-plugins-doc script that does the same for
plugins.  A prototype of this script exists somewhere.  Making it an
@command node will make it much more visible. 

Terry wrote plugin_catalog.py.  It is in LeoDocs.leo
.. @+node:ekr.20140610063815.17693: *4* Sentinel files
.. @+node:ekr.20140426030229.16869: *5* prototype of sentinel files
.. @+node:ekr.20140611055007.17696: *5* original post
https://groups.google.com/forum/#!topic/leo-editor/1uw1llvuYBQ

@language rest

For the last several days I have been thinking about the new-@auto project
that I worked on in February while in Florida.

As always, the real problems involve sentinels: It's essential that Leo's
sentinels not be visible in projects that do not use Leo.

The fundamental problem is that operating systems do not support additional
(hidden) data in text files. (Old versions of MacOS did support such data
in the so-called "resource fork").

A new set of thoughts has now appeared. These are quite different from the
thoughts I have explored for the past 20 years.

===== The idea

We want a way of Leo users to share outline structure in a way that is
completely invisible to non-Leo users. This is *not* the same thing as
doing without sentinels! It puts the focus on "back-channel" communication
of sentinels between Leo users as follows:

0. Let's use the same terminology as with @shadow: **private** files
   contain sentinels; **public** files do not.

1. Instead of writing sentinels *within* external files, Leo's file-write
   logic could easily create separate **sentinel files**. Sentinel files
   would contain:

- a header with data such as sha1-hash for the corresponding public file,
  and a gnx-like author/timestamp field.

- a list of sentinel lines themselves. Each sentinel line would be preceded
  by a relative offset of the sentinel within the corresponding public
  file. Using relative offsets means that most offsets would not change if
  a line were inserted/deleted from the public file.

2. Leo's file-read logic for public files would "shuffle" the sentinels
   into the public file (using the relative offset of each sentinel). After
   the sentinels have been restored, the read logic would be identical to
   the present @file read logic.

3. We want this scheme to be completely invisible to non-Leonine users, so
   sentinel files must be kept *away* from project files, say in the
   ~/.leo/sentinels directory. Call this the user's **sentinels
   directory**.

The obvious way to associate sentinel files with the corresponding public
file would be with the sha1 hash. The files in the sentinels directory
would have names that are the sha1 hash of the corresponding public file.

4. Leo users can *share outline structure* by sharing sentinels files.

At first, this sharing would have to be done "by hand" each time a public
file is committed. Later, perhaps more automatic ways of sharing sentinels
files could be created. Say by using git hooks, for example.

5. Because sharing sentinels files may not always be automatic (and might
   not ever be automatic), Leonine users will need ways of "recovering"
   when a public file changes without the corresponding sentinel files
   being available. This leads us to...

===== Doing without sentinels files

Suppose Alice has committed the new public file f.py, and suppose Alice has
*not* committed the corresponding sentinel file. Suppose Bob wants to use
the new version of f.py in Leo. Bob has two options:

1. Use @auto to create the outline for f.py.

2. Use the @shadow algorithm as follows. Using git (say) Bob recovers some
   previous version V of f.py (without sentinels) for which Bob *does* have
   a corresponding sentinel file. Bob (using Leo) recreates the *private*
   copy of version V of f.py by shuffling the sentinels into f.py. Bob then
   runs the @shadow algorithm on the old private copy to create the new
   version of f.py *with* sentinels.

**Important**: the choice between @auto and @shadow would be a personal
preference. I've gone into detail here to show how Leo could do the
recovery for Bob automatically using the @shadow idea.

===== Pros and cons

As with all ways of doing without sentinels, this scheme has plusses and
minuses.

On the plus side:

- It is completely invisible and imposes *zero* cost on non-Leonine users
  and projects. Costs accrue only to Leo users.

- When the proper sentinel file is available, Leo uses the simplest
  possible algorithm to reconstruct outlines, namely shuffling sentinels
  into the public file followed by running the @file read code. This
  requires neither parsing (as @auto does) nor any complicated diffing (as
  @shadow does). I think of the @file read code as a simple, deterministic
  finite automaton.

- When the proper sentinel file is available, Leo will provide all the
  advantages of @file nodes, including the conservation of gnx's and all
  that implies, especially rock-solid clone links.

- It will be easy to prototype. A simple script will test the **round trip** criterion.

  The script will create a sentinel file from a *private* file and verify
  that shuffling the sentinels from the sentinels file back into the
  corresponding *public* file results in the original *private* file.

On the minus side:

- Most importantly, no matter how good (or how automatic) the connection
  between public files and the corresponding sentinel files, that
  connection can *never* be as solid as embedding sentinels in external
  files. Thus, the opportunity for problems will always be greater when
  using this scheme compared to using files with embedded sentinels.

- Leo's users will be responsible for sharing sentinels files. This will be
  an extra step, even if it is eventually done automatically.

- When the proper sentinel file does not exist for a public file, Leo users
  will have to live with either @auto-based recovery or @shadow-based
  recovery.

- There is no advantage for a lone Leonine user within a project to use
  this scheme: she may as well use @shadow or @auto. Similarly, if *all*
  the users of the project use Leo, they may as well just use @file. So
  this scheme is only useful if a project contains two or more Leonine
  programmers and one or more non-Leonine programmers.

===== Summary

- This scheme puts more emphasis on sharing data *among Leo users* than on
  "magically" recreating sentinels.

- This scheme's implementation advantages (using the @file read logic) is
  offset (in part) by the inconvenience of having to share and synchronize
  sentinels files.

- This scheme is only useful when multiple Leonine programmers work in a
  non-Leonine project. Solo Leonine programmers in a non-Leonine project
  may as well use @shadow or @auto.
.. @+node:ekr.20130806072439.21428: *4* Set of markup2html converter
From: tfer <tfetherston@aol.com>

Having played with Jacob Peck's markdown fork, I now get what leo is doing 
to provide a preview of text using a markup type. It is converting that 
markup, (rst: built-in, markdown: proposed).  What is being done is to run 
the text through a xxx2html converter and then using a Qt window widget 
that renders the generated html.

There have been requests to extend the built in rst functionality to other 
markup types, (Peck has an experimental one for markdown).  Rather than 
added them piecemeal, I think we could incorporate the code github uses to 
allow people to use their preferred markup language for their projects 
readme file.  Although a number of the converters are written in ruby, some 
are python and one is even pearl.  It is an extensible scheme.  The license 
for the library is basically, "keep the copyright notice and have at it", 
so it shouldn't cause any problem.

The code is here:
  https://github.com/github/markup

The current "see the selected node's body text" in the view-render-pane 
should work, the only thing lacking is a way to preview an entire file. 
 How about adding an option to preview it in the context menu for a right 
click on an @file node?

===== From: Jacob Peck <gatesphere@gmail.com>

That was actually my first thought when approaching the markdown 
implementation.  The major problem here is that the wrapper program, and 
several of the assorted converters are in ruby.  The only python one is 
rest2html, which we already have (via docutils).  I don't think adding 
ruby and perl as dependencies for one small feature of Leo would be 
wise...  that seems to me to be the very definition of bloatware.

That being said, github-markup supports the following formats, which are 
supported by python libs:

markdown (markdown)
rst (docutils)
textile (textile)
org mode (pyorgmode)
creole (python-creole)
mediawiki (mw2html)
asciidoc (asciidoc)

The following do not have a python equivalent (to my knowledge):

rdoc (ruby documentation)
perlpod (perl documentation)

I could certainly keep hacking on viewrendered to support the first 
list, if interest is high.

> The current "see the selected node's body text" in the 
> view-render-pane should work, the only thing lacking is a way to 
> preview an entire file.  How about adding an option to preview it in 
> the context menu for a right click on an @file node?
I could look into this suggestion too, if someone would point me in the 
right direction with respect to 2 things (I'm really new to Leo, so I 
have no idea where these things are in the source):

1. How to add a context menu item for a node
2. How to get a "full file" without saving it, i.e., fill in the << 
references >>, @others, and @all directives.

.. @+node:ekr.20131225061403.16375: *4* Support @bookmark-view
@nocolor-node

- Choosing bookmarks-show with a large tree selected kills performance.
- view-pack will create sorted list of unl's.
- view-unpack will sort list of unl's.
.. @+node:ekr.20131225061403.16377: *5* g.command(view-pack)
@g.command('view-pack')
def viewPack(event):
    c = event.get('c')
    if not c: return
    result = [g.unl(p) for p in c.p.self_and_subtree()]
    # What to do about c.p.b and c.p.h?
.. @+node:ekr.20081119132758.2: *4* Support @ifgui in settings trees
This can be done now that gui's are created on the command line.
.. @+node:ekr.20111026075003.16481: *4* Support ~/.leo_config.py
@language python
@language rest

1. Imo, it is time to consider adding a typical "startup" file to Leo,
~/leo_config.py, similar to ~/.emacs or ipython_config.py.  This will
make Leo "thicker", that is more professional/standard.

IPython adds lots of bells and whistles to configuration.  Leo
emulates most of them, but .leo_config.py would be a good addition.
Think of .leo_config.py as a lightweight plugin.

leo_config.py should execute after settings have been parsed, but
before plugins have been loaded.  If desired, leo_config.py may
register "start2" event handlers, which execute after all plugins have
been loaded, just before starting the main Qt event loop.

2. Leo commands form a good framework for other solutions to Qt
stylesheet issues.  Consider the following commands::

- qt-stylesheet-set-global-stylesheet
- qt-stylesheet-append-to-global-stylesheet
- qt-stylesheet-set-widget-stylesheet
- qt-stylesheet-append-to-widget-stylesheet

.. @+node:ekr.20130806072439.21443: *4* threaded saveAll()
From: Terry Brown <terry_n_brown@yahoo.com>

I guess this is a wishlist item - I suspect it is a result of my
workflow that might be quite different from other peoples, but I often
need to save 4, 6, even more open changed Leo files at once.  Mainly
when I'm filing / adjusting todo items, although at the end of a
session having 4 changed files open can't be that unlikely.

So it would be really nice if c.saveAll() could be threaded.  Even as I
write this, it gets more complicated as I think about it :-}

  - each thread should do no user interface calls, or at least no calls
    that aren't deferred to the main thread

    - that's ok, would take quite a bit of tracing to catch them all,
      but doable - except - plugins called from save hooks might break
      the rule

  - updating recent files list would have to be done properly, not a
    big deal

  - multiple threads saving to the same external files would be a
    problem, that's the complication that only just occurred to me

I don't typically have the same external file referenced from multiple
Leo files, why would you do that... so the last problem, although
potentially major, might be theoretical more than practical.

Hmm, well it's a thought.  First thing to check, is saving IO bound or
CPU bound...
.. @+node:ekr.20130806072439.21444: *5* Re: threaded saveAll()
From: "Ville M. Vainio" <vivainio@gmail.com>

Since the flat document is a sort of "rambling" blue sky topic, I added
some more thought on G+ leo community instead of increasing mailing list
noise:

https://plus.google.com/103097156557482112329/posts/Vp5ansTdLwq
.. @+node:ekr.20130806072439.21445: *5* Re: threaded saveAll()
From: "Ville M. Vainio" <vivainio@gmail.com>

--f46d042fd84e36bae704d78bf5db


I'm pretty sure saving is cpu bound; for "normal" size documents, flushing
that kind of stuff to disk (or memory buffers that are to be written to
disk) shouldn't take significant amount of time.

.. @+node:ekr.20130806072439.21446: *5* Re: threaded saveAll()
From: Terry Brown <terry_n_brown@yahoo.com>

On Sat, 9 Mar 2013 14:46:09 -0600
Terry Brown <terry_n_brown@yahoo.com> wrote:

> I guess this is a wishlist item - I suspect it's a result of my
> workflow that might be quite different from other peoples, but I often
> need to save 4, 6, even more open changed Leo files at once.  Mainly
> when I'm filing / adjusting todo items, although at the end of a
> session having 4 changed files open can't be that unlikely.

I've just found that, because these todo items are always in the
outline itself and not external files, I can just do 
'write outline only' on all the open outlines, and this is much faster
and smooths out the bump in my workflow that got me started thinking
about this.
.. @+node:ekr.20130806072439.21447: *5* Re: threaded saveAll()
From: Terry Brown <terry_n_brown@yahoo.com>

On Sun, 10 Mar 2013 08:13:41 +0200
"Ville M. Vainio" <vivainio@gmail.com> wrote:

> I'm pretty sure saving is cpu bound; for "normal" size documents, flushing
> that kind of stuff to disk (or memory buffers that are to be written to
> disk) shouldn't take significant amount of time.

Probably right, so could you use `multiprocessing` instead of
`threading`?  More challenging implementation wise, but I'm wondering
if it's even possible, in terms of handing over the in-memory data
structure?
.. @+node:ekr.20130806072439.21448: *5* Re: threaded saveAll()
From: "Ville M. Vainio" <vivainio@gmail.com>

--14dae9340445ec94c604d796bde2


Multiprocessing based implementation will likely be quite hard, and once
you walk the trees anyway and copy the data over the process boundary, it
could cause bad pauses in execution.

I have often thought how nice it would be to have "flat" storage for the
leo document, so that you could just copy over a flat chunk of memory and
let other processes traverse that. Doing that is a somewhat nontrivial
undertaking, to say the least :).

I'd just start with threads, despite the GIL problems.
.. @+node:ekr.20130806072439.21298: *4* Treat leo tree as a flat memory structure
Ville
https://plus.google.com/_/notifications/emlink?emr=02870587547267324596&emid=CLiiydTt8rUCFaY6MQodYAsAAA&path=%2F103097156557482112329%2Fposts%2FVp5ansTdLwq&dt=1362942818945&ub=63

How could we  treat leo tree as flat, contiguous memory structure (something that's easy to memcpy, pass as shared memory or flush to disk in one write)?

Some ideas could be: 

- Use Redis to store tree
- Keep the "clean" body texts in contiguous block (most bodies will always be clean), append dirty (modified) body texts after it
- Keeping the outline structure in memory block is quite easy, since there is not a lot of data. You could have just a list of [parent, child] id's or whatever
.. @+node:ekr.20130806072439.21464: *4* UI idea: body editors in a grid
From: "Ville M. Vainio" <vivainio@gmail.com>

Hey,

No time to mock this up right now, just throwing it out there.

"tabula" plugin allowed you to edit many nodes simultaneously in an
MDI canvas - i.e. you could move the body editors around freely.

How about taking this idea further and locking the body editors in a
grid, or column?

One fun idea would by layout like this

            | Child 1
Outline  | Child 2
            | Child3

That is, you would edit and view all the children of the currently
focused node all at once. We can already do two body editors at once,
so this would seem like natural extension.

Of course you could only see a small amount of text per body, but for
a "workbook" / sheet like use cases it would be fine.
.. @+node:ekr.20130806072439.21465: *5* Re: UI idea: body editors in a grid
From: "Edward K. Ream" <edreamleo@gmail.com>

On Apr 18, 10:53=A0am, Terry Brown <terry_n_br...@yahoo.com> wrote:

> When the body editor is a well behaved widget it should be straight
> forward to place them where ever you want in using the free-layout
> mechanism.

Yes.  This might the key.

As I was thinking about doing body editors with free_layout (and by
extension, the tabula editors) I had another new thought: it's time to
replace the present difficult selection code with a broadcaster/
listener framework.

In particular, the multiple body editor code is on the verge of
collapse because it tries to figure out too much in a spaghetti-like
mass of logic.  This doesn't generalize, and Leo is becoming so
"exuberant" in its IDE that a simpler, more general mechanism is
becoming essential.

Edward

.. @+node:ekr.20130806072439.21466: *5* Re: UI idea: body editors in a grid
From: "Edward K. Ream" <edreamleo@gmail.com>

On Wed, Apr 18, 2012 at 4:37 AM, Ville M. Vainio <vivainio@gmail.com> wrote:

> "tabula" plugin allowed you to edit many nodes simultaneously in an
> MDI canvas - i.e. you could move the body editors around freely.

Tabula is part of the stickynotes plugin.  It creates the following commands:

         tabula
         tabula-marked
         tabula-show
         tabula-subtree

The "windowlets" show the node's headline. So this is the "sea of nodes" view!

The tabula nodes are "live": changes made in the tabula window
instantly affect the corresponding nodes in the regular outline.

An easter egg: double-clicking the title of a windowlet fills the
tabula window with the windowlet.  Another double-click undoes the
expansion.

> How about taking this idea further and locking the body editors in a
> grid, or column?

Good idea.  The tabula window is a great playground for invention.

In the "multi-colored link" world (coming soon, I hope), we could
imagine commands that create "tabula-colored" links, so that the
tabula window would work like a chapter.  (And each chapter would have
its own links).

The Light Table video suggested something else that I never considered
before.  Suppose each node "carries" its own mini-context outline,
showing just the parents of the node.  The tabula window might be
natural for that.

The idea is that each windowlet would have two parts:  the top would
show the parents, the bottom would show the body pane.  This allows
context to be visible without actually having to show the outline
pane.

Edward
.. @+node:ekr.20130806072439.21467: *5* Re: UI idea: body editors in a grid
From: "Edward K. Ream" <edreamleo@gmail.com>

On Wed, Apr 18, 2012 at 10:53 AM, Terry Brown <terry_n_brown@yahoo.com> wrote:
> On Wed, 18 Apr 2012 12:37:22 +0300

> When the body editor is a well behaved widget it should be straight
> forward to place them where ever you want in using the free-layout
> mechanism.

Are you suggesting doing free-layout in tabula?

EKR
.. @+node:ekr.20130806072439.21468: *5* Re: UI idea: body editors in a grid
From: "Ville M. Vainio" <vivainio@gmail.com>

--20cf3005df0ef84cc304be0227bb


If you fill the cells with stickynotes (as in tabula), the editors would at
least stick to the nodes.

Otoh, if more felxible body editors are just around the corner, it may not
be worth the hassle.

.. @+node:ekr.20130806072439.21469: *5* Re: UI idea: body editors in a grid
From: Kent Tenney <ktenney@gmail.com>

On Wed, Apr 18, 2012 at 2:57 PM, Edward K. Ream <edreamleo@gmail.com> wrote=
:
> On Apr 18, 10:53=A0am, Terry Brown <terry_n_br...@yahoo.com> wrote:
>
>> When the body editor is a well behaved widget it should be straight
>> forward to place them where ever you want in using the free-layout
>> mechanism.
>
> Yes. =A0This might the key.
>
> As I was thinking about doing body editors with free_layout (and by
> extension, the tabula editors) I had another new thought: it's time to
> replace the present difficult selection code with a broadcaster/
> listener framework.

'publish / subscribe' has buzzword cred these days, there are several
protocols out there, reportedly fairly simple to implement, don't know
if any are a fit here.
.. @+node:ekr.20130806072439.21470: *5* Re: UI idea: body editors in a grid
From: Terry Brown <terry_n_brown@yahoo.com>

--MP_/YLiyZOi3S=ZU5mZC9llHxW5

Content-Disposition: inline

On Wed, 18 Apr 2012 12:48:42 -0700
Ville Vainio <vivainio@gmail.com> wrote:

> > Expanding the scope to a grid, we could have a grid-lock-column that would
> > freeze the current column, allowing you to move the selected position in
> > the tree to another node, and locking the nodes for column 2 etc etc  

Attached screen-shot shows the potential for free-layout with the new
Open Window command to open a separate window as a 'grid' editor.  Here
instead of body editors I just have 5 view-rendered panes open, and
they're all looking at the same node because there's no mechanism for
locking them to separate nodes presently(*).  Free layout could handle
body editors in the same way, if they were more agnostic about their
containers.

Cheers -Terry

(*) I think there's a way to lock/unlock a special case singleton
view-rendered pane, but not a flock of them like this.
.. @+node:ekr.20130806072439.21471: *5* RE: UI idea: body editors in a grid
From: Ville Vainio <vivainio@gmail.com>

You are probably right. We Could also adjust the sizes dynamically
based on the amount of text in the nodes

Sent from my Windows Phone
From: Terry Brown
Sent: 4/18/2012 10:31 PM
To: leo-editor@googlegroups.com
Re: UI idea: body editors in a grid
On Wed, 18 Apr 2012 21:42:21 +0300
"Ville M. Vainio" <vivainio@gmail.com> wrote:

> I am bringing another angle into play here - systematic selection of what
> nodes are shown in the editors, in the proposed scheme we would have a
> single column of editors, each displaying every child of currently selected
> node.
>
> Expanding the scope to a grid, we could have a grid-lock-column that would
> freeze the current column, allowing you to move the selected position in
> the tree to another node, and locking the nodes for column 2 etc etc

Ok, but I still think it makes sense to implement this with the
free-layout system, so that your grid could be a separate window, or
not, as desired.  free-layout is basically nested QSplitters, so it can
represent a grid, but with more flexibility (cell 1,0 doesn't have to
be the same height as cell 0,0, etc.)
.. @+node:ekr.20130806072439.21472: *5* Re: UI idea: body editors in a grid
From: Matt Wilkie <maphew@gmail.com>

> That is, you would edit and view all the children of the currently
> focused node all at once.

I often use "Edit in notepad" (or more likely pyscripter) for this
purpose. It would be nice to stay inside Leo; I sometimes lose data by
forgetting which editor has the most current version.
.. @+node:ekr.20130806072439.21473: *5* Re: UI idea: body editors in a grid
From: Terry Brown <terry_n_brown@yahoo.com>

On Wed, 18 Apr 2012 21:42:21 +0300
"Ville M. Vainio" <vivainio@gmail.com> wrote:

> I am bringing another angle into play here - systematic selection of what
> nodes are shown in the editors, in the proposed scheme we would have a
> single column of editors, each displaying every child of currently selected
> node.
> 
> Expanding the scope to a grid, we could have a grid-lock-column that would
> freeze the current column, allowing you to move the selected position in
> the tree to another node, and locking the nodes for column 2 etc etc

Ok, but I still think it makes sense to implement this with the
free-layout system, so that your grid could be a separate window, or
not, as desired.  free-layout is basically nested QSplitters, so it can
represent a grid, but with more flexibility (cell 1,0 doesn't have to
be the same height as cell 0,0, etc.)
.. @+node:ekr.20130806072439.21474: *5* Re: UI idea: body editors in a grid
From: Kent Tenney <ktenney@gmail.com>

On Wed, Apr 18, 2012 at 10:53 AM, Terry Brown <terry_n_brown@yahoo.com> wro=
te:
> On Wed, 18 Apr 2012 12:37:22 +0300
> "Ville M. Vainio" <vivainio@gmail.com> wrote:
>
>> How about taking this idea further and locking the body editors in a
>> grid, or column?
>
> When the body editor is a well behaved widget it should be straight
> forward to place them where ever you want in using the free-layout
> mechanism.

Plus, free-layout provides persistence: it's worth putting effort into
configuring pane configuration because it will be available next time.

(I guess I'm persistent about wanting persistence)
.. @+node:ekr.20130806072439.21475: *5* Re: UI idea: body editors in a grid
From: Terry Brown <terry_n_brown@yahoo.com>

On Wed, 18 Apr 2012 12:57:03 -0700 (PDT)
"Edward K. Ream" <edreamleo@gmail.com> wrote:

> As I was thinking about doing body editors with free_layout (and by
> extension, the tabula editors) I had another new thought: it's time to
> replace the present difficult selection code with a broadcaster/
> listener framework.

Although such a framework might be quite useful, I can't help thinking
it would insert a big delay between now and getting flexible body
editors implemented.

> In particular, the multiple body editor code is on the verge of
> collapse because it tries to figure out too much in a spaghetti-like
> mass of logic.  This doesn't generalize, and Leo is becoming so
> "exuberant" in its IDE that a simpler, more general mechanism is
> becoming essential.

I think that getting body editors working as described in my recently
bumped "Free range body editors" post would not be that hard, certainly
simpler and faster than a broadcaster / listener framework.  And the
current multiple body editors code could just be dropped completely, so
while I suspect you're right about it being on the edge of implosion, I
don't think that's a problem :-)
.. @+node:ekr.20130806072439.21476: *5* Re: UI idea: body editors in a grid
From: "Ville M. Vainio" <vivainio@gmail.com>

--20cf305b11c06d69c404bdf86a61


I am bringing another angle into play here - systematic selection of what
nodes are shown in the editors, in the proposed scheme we would have a
single column of editors, each displaying every child of currently selected
node.

Expanding the scope to a grid, we could have a grid-lock-column that would
freeze the current column, allowing you to move the selected position in
the tree to another node, and locking the nodes for column 2 etc etc

.. @+node:ekr.20130806072439.21477: *5* Re: UI idea: body editors in a grid
From: "Ville M. Vainio" <vivainio@gmail.com>

Have you tried alt-x stickynote from stickynotes plugin?

.. @+node:ekr.20130806072439.21478: *5* Re: UI idea: body editors in a grid
From: Terry Brown <terry_n_brown@yahoo.com>

On Wed, 18 Apr 2012 11:45:25 -0500
Terry Brown <terry_n_brown@yahoo.com> wrote:

> Another feature I've wanted to add to free_layout is popping out any
> element into its own window (replacing sticky-notes).  You could go one
> better and pop-out free-layout frames which could contain multiple
> widgets, like tabula currently does.
> 
> I'll try and get those features into free-layout.

Woohoo - done and pushed.  Went for the second option, instead of
pop-out windows holding a single widget, they hold a whole new
free-layout hierarchy, which of course can be a single widget, or much
more, if you want.  See the 'Open Window' command on the free-layout
splitter handle context menu.

Even made a screencast to demonstrate, but unfortunately the sound was
useless, despite being ok in trials before hand.  Might try again later.
.. @+node:ekr.20130806072439.21479: *5* Re: UI idea: body editors in a grid
From: Terry Brown <terry_n_brown@yahoo.com>

On Wed, 18 Apr 2012 12:37:22 +0300
"Ville M. Vainio" <vivainio@gmail.com> wrote:

> How about taking this idea further and locking the body editors in a
> grid, or column?

When the body editor is a well behaved widget it should be straight
forward to place them where ever you want in using the free-layout
mechanism.  I think that's a better goal, it allows you more
flexibility in terms of maybe one small (both dimensions) and one large
editor, for example.
.. @+node:ekr.20130806072439.21480: *5* Re: UI idea: body editors in a grid
From: "Edward K. Ream" <edreamleo@gmail.com>

On Apr 18, 1:42=A0pm, "Ville M. Vainio" <vivai...@gmail.com> wrote:
> I am bringing another angle into play here - systematic selection of what
> nodes are shown in the editors, in the proposed scheme we would have a
> single column of editors, each displaying every child of currently select=
ed
> node.

The new broadcaster/listener framework should probably be designed to
handle this.  That is, in the new framework it should explicitly be
possible to select multiple nodes.


> Expanding the scope to a grid, we could have a grid-lock-column that woul=
d
> freeze the current column, allowing you to move the selected position in
> the tree to another node, and locking the nodes for column 2 etc etc
> On Apr 18, 2012 6:53 PM, "Terry Brown" <terry_n_br...@yahoo.com> wrote:

Interesting.  For some purposes the column would be like a "super
node", that is, an explicit collection of nodes.

EKR

.. @+node:ekr.20130806072439.21481: *5* Re: UI idea: body editors in a grid
From: Terry Brown <terry_n_brown@yahoo.com>

On Wed, 18 Apr 2012 11:12:45 -0500
"Edward K. Ream" <edreamleo@gmail.com> wrote:

> > When the body editor is a well behaved widget it should be straight
> > forward to place them where ever you want in using the free-layout
> > mechanism.  
> 
> Are you suggesting doing free-layout in tabula?

No, although that gives me another idea...

Another feature I've wanted to add to free_layout is popping out any
element into its own window (replacing sticky-notes).  You could go one
better and pop-out free-layout frames which could contain multiple
widgets, like tabula currently does.

I'll try and get those features into free-layout.  Note that a couple
of widgets already have their own pop-out capability, the body editor
and view-rendered.

Also some frame manipulation tools in free-layout would be good.  To
maximize / restore one frame, and layout frames in a grid, if there was
an intent to replace tabula.

Not that tabular needs replacing, but I think it's benefits can be
generalized.
.. @+node:ekr.20110528034751.18272: *4* Use free_layout to implement body editors
Collaborate with Terry.

A. Place separate body editors in free_layout areas. This should *easy* to
   do! Almost nothing changes in the code, but the visual effect should be
   much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane) and
   "untabified." There are a few details to be handled, but nothing major.
   
C. Labels for panes.
.. @+node:ekr.20111017132257.15883: *4* Use IPython completion?
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/014fe61ff9480b2b

I don't know if this is relevant or not, but the IPython autocompletion
capability is awesome.

If I'm investigating code I tend to do the following.

list the modules in a package:
In [1]: from fs import <tab>

this lists the modules, in a package so I pick one
In [1]: from fs import osfs
<the osfs entry is tab-completable>

now I can check the usage of fs.osfs
In [2]: osfs? <enter>

or the source:
In [2]: osfs?? <enter>

or the contents of the module
In [2]: osfs. <tab>

I can instantiate a class:
In [3]: myfs = osfs.OSFS('/')

and examine the ivars and methods:
In [4]: myfs. <tab>

It is such an efficient way to learn and remember the details of code.

I know a bunch of work was done on Leo/IPython integration, don't
know the current status, my wish of synchronized IPython and Leo
may well be one of the many granted wishes I have forgotten about.

I certainly think IPython autocompletion is the gold standard. 
.. @+node:ekr.20111019104425.15894: *4* Use templates to create Wizards (Kent)
Leverage the template capability to offer form-based content creation:
- create a plugin
- generate a test node
- generate a wizard :-]
.. @+node:ekr.20130806072439.21337: *4* Wanted: better C importer
From: ne1uno <eltronis@gmail.com>

wouldn't it be great to have a first class c importer?
hiding the complexity of platform & compiler/option #defines.
invisible (TM) nodes would be fruitful here. switched on by @#define.
with an @#define=3D collection node or using a bunch of headlines.
and an rclick flipper for true/false, defined/not defined
declarations.

we know c isn't disappearing. quite a few people still regard
any so called scripting language as a nuisance.
maybe ok for prototyping but not for the final product.
pyqt would be near zilch useful w/o Qt, at least currently.
I guess that's as far as I ever got, wouldn't it be great if...

meanwhile I wait for the inspiration or someone else to nail down
a regular expression c language parser. maybe a tokenizer is enough.
I did run c code through AStyle then through your old c2py via
buttons.
for code that would remain in c,
in SciTE through google CPPlint program to point up flaws,
and to get the context sensitive help from various CHM.
running flawfinder good to do now and then old or new code.
post processing and displaying the report in a browser.
but it doesn't go far enough & too many false positives.

there is splint, maybe the only free lint left. the need to inject
"hints" all over the code make it less than ideal for perusing
unknown source and generally a deal breaker for project code.
sometimes all you need is a function/var list to get by.
deeper static analysis is quite the serious business. so, it's
not a surprise those programs are not easily found, or used.
there are a few code flow programs that could be harnessed
to colorize headlines indicating relations.
taking all this in, marking nodes that need work with a popup
or tooltip action event when you view that node with the
details of one or another parser to annotate what needs work.

we have had a few plugins/buttons/attempts at designing an
interface to get a program node compiled. this is also a decent
way to get info on the quality of code by turning all warnings on.
fails for snippits. never quite simple to hookup or modify painless.
perhaps the biggest problem is knowing what is available and where.
more toolbars, no reason they can't dock. drag & dropping buttons.
one of the huge advantages of Qt over Tk so far barely tapped.
you begin to accept the fact that you need to create a temp file
instead of real process control. managing program quirks
& options becomes more trouble than it's worth just to
protect the purity of the operation sans temp files.
QTprocess has more options than the process in pythons libs.
if it ever works as well as it should. but, a little hard to wrap.
not going to venture a guess if pyqt gets it right or not.
not to mention how bungled up OS process control still is.
process control will be essential to any inter-process operations.
that is, unless you backslide into wanting to build everything "in"
and invent everything new again. re: blender, I haven't looked at
blender code in a while, but I would be shocked if there weren't
some well established way to hook into a script.
sounds like noone has found them yet.

not sure how to grab a window handle on other OS but for windows
it's fairly straight forward. blender or GTK could setup blocks.
another great Qt based project is universal indenter, a front end

for many indenters for many languages. this would be a good place
to look for how to manage inter-process communication in Qt.
a first class editor will have to include first class importer for
javascript at the least and probably lua and one or two others.
one could imagine niceties like clickable links on #include files.
right clickable options on them such as import, simple view, htmlize.

also about styles, astyle has the options on the commandline, the
builtin/compiled in defaults and an ~/.astyle.rc for personal style.
some will find an indenter that has no options useless. I know the
indenter created is purely for internal use, as it were, at this
point.
adding selectable options later will complicate the program and for
most use will have little payback. you may as well expect to have some
want a plugable option for style.
exposing a general use tokenizer could have many callers.
.. @+node:ekr.20130806072439.21482: *4* Wish list: xiki window for leo
@nocolor

From: wgw <wgwinder@gmail.com>

Xiki.org gives a demo of a "wiki" shell for command execution. Leo should 
be able to do the same thing (and more!), in the sense that leoscreen, for 
example, has two way communication with the command line. I suppose a 
"Lxiki" is really just a question of setting up the right shortcuts (like a 
shift-ctrl-b that would run highlighted python code from the command 
line... with a tmp file?).

Just an idea for the Leo melting pot. 

.. @+node:ekr.20130806072439.21483: *5* Re: Wish list: xiki window for leo
@nocolor

From: wgw <wgwinder@gmail.com>

Thanks for the tip -- it will take me a while to get my head around vspace
(will keep an eye on Ville's blog post).

I'm just beginning to appreciate (or imagine) what Ipython, sublime text
editor, leo, xiki, etc could mean for some kind of intelligent document
workbench. Of course the big hurdle is not so much the string processing
(sublime is a good example of how that can be done), but rather the syntax
processing -- i.e. the docbench  (to coin a phrase) should understand the
syntax of whatever is being input and then offer syntax-aware functions....
Sorry, getting a little obscure: all I mean by syntax-aware is the ability
to propose text completions (Leo's autocompletion is a good example --
everything should work like autocomplete!) and allow for intelligent text
changes depending on a database of information (for example, a search and
replace that would  know how to search on "caterpillar" and turn it into
"butterfly" but would not touch "caterpillar truck").

Seems like Leo is not far from doing that synthesis, but it would require
more database integration. So for example, even the python help system does
not have autocomplete. (No criticism there! The great thing about Leo is
that if you want something, you just have to dive in and build it. My day
job might just let me do that!)
.. @+node:ekr.20130806072439.21484: *5* Re: Wish list: xiki window for leo
@nocolor

From: Terry Brown <terry_n_brown@yahoo.com>

> Thanks for the tip -- it will take me a while to get my head around vspace
> (will keep an eye on Ville's blog post).

Just to clarify, vs-eval, vs-last, vs-last-pretty are quite straight
forward, as I described them below, and do not require comprehension of
the esoterica of value-space :-) I just put them in that plugin (a) to
avoid creating yet another plugin, and (b) because it seemed sensible
to have them use the value-space namespace c.vs, but all that means for
vs-eval, vs-last, vs-last-pretty is that

  a =3D 7

executed by vs-eval assigns a value to a which can be used by
subsequent vs-eval calls (persistent for the lifetime of the session).

For example, make a body with this text

a =3D 7
b =3D 3
a + b

and place the cursor in front of the first 'a'

execute (Alt-x or key binding) vs-eval 4 times

 - first time executes the empty selection and selects the next line
 - second time assigns 7 to a and report 7 in the log
 - third time assigns 3 to b and report 3 in the log
 - forth time calculates a + b and report 10 in the log

executing vs-last(-pretty) would insert the last result (None, 7, 3,
10) in the body.
.. @+node:ekr.20130806072439.21485: *5* Re: Wish list: xiki window for leo
@nocolor

From: wgw <wgwinder@gmail.com>

Got it! The value of valuespace (!) is that that you can make a pythonesque
session persist. I did not realize that there was no direct two-way bridge
to the python window that leo launches. Even if there were, we would want
to make the session persist by logging it into the outline, as
valuespace (vs-create-tree) does.
.. @+node:ekr.20130806072439.21487: *5* Re: Wish list: xiki window for leo
@nocolor

From: Terry Brown <terry_n_brown@yahoo.com>

In addition to the outline as a active data document functions of
Ville's value-space plugin, I recently added some simple ;-) commands:

Alt+A vs-eval
Alt+S vs-last
Alt+D vs-last-pretty
(my key bindings)

vs-eval evaluates the selected python in the c.vs namespace.  It makes
an effort to workout what the output should be, and puts it in the
log.  It captures print output to the log too.  It selects the next
line, ready for execution.

vs-last inserts the last result into the body, and vs-last-pretty
does the same, but using pprint formatting.

Ctrl-B also runs the script in the body, but not in a persistent
namespace, running only the selected text doesn't seem to be working,
and it doesn't work so hard to work out the output.

I guess leoscreen would do the same things as the vs-* commands if you
used it against a python shell.  The inspiration for the vs-* commands
was wanting Leo to tell you what 3.57 * 365 / 12 was without a lot of
effort, but of course you can define functions etc. etc.
.. @+node:ekr.20140704052551.17951: *3* Code
All are minor.
.. @+node:ekr.20120208062900.10146: *4* Complete new_modes
@nocolor-node

This will eliminate the hacks for *entry-commands* and *command-prompt keys.

ModeController: a wrapper for g.app.config.modeCommandsDict

Clean up #### in leoKeys
.. @+node:ekr.20080628095358.1: *4* Make each Leo command a class
http://groups.google.com/group/leo-editor/browse_thread/thread/5688ed9aaa39be2e#

@nocolor

The main difficulty I see in the migration is creating the tables in the getPublicCommands methods in the various classes in leoEditCommands.py.  At present, these tables associate command names (strings) with corresponding methods.  The form of getPublicCommands is always:

def getPublicCommands (self):
  return {
    'command-name1': self.methodName1,
    'command-name2': self.methodName2,
    ...
  }

Thinking out loud, let's see whether the migration can be done easily.  We would change the entry:

    'command-name1': self.methodNameN,

to:

    'command-name1': self.classNameN(self),

That is, the table creates an instance of the class by calling the class's ctor, with self (the container object) as the ctor's only argument.  To make this work, all we need to do is give the class a __call__ method whose signature matches the signature of methodNameN, that is, the signature used to call methods previously.

Well, isn't this nice.  We can transition gradually, as needed.  No need *ever* to do a mass migration.  It should be easy to verify this scheme with one or two examples.  Please report your experiences if you decide to play around with this.

Edward

P.S.  I think it would be good style to append "Class" to the name of each command class. This makes it clear that self.myCommandClass(self) is a ctor.
.. @+node:ekr.20100219083854.5615: *4* Improve caching
.. @+node:ekr.20100209160132.5770: *5* cache notes
Top-level folder are direct subfolders of .leo/db.
Top-level folders represent file *locations* not file contents.
Exception: the top-level "globals" folder represents minor data.

Only two files are ever needed in a top-level folder:

contents_<key>: the contents of the file.
data_<key>: a dict representing the "minor data" of the file:
    <globals> element stuff, expansion bits, etc.

We write contents_<key> only once.
By definition, its contents never changes, since the contents generates the key.
We can write data_<key> as many times as we like.

To do:
- Simplify or even eliminate the path-manipulation code in PickleShareDB.
- Use g.makeAllNonExistentDirectories to make top-level directories.
- Clear cache should clear all top-level directories.
.. @+node:ekr.20100209114432.5751: *6* Cache expansion bits
# Simplify the structure of the cache: put more into the "minor" files.
.. @+node:ekr.20100211095442.6201: *5* cache notes 2
1. Memory does leak, and that's not ok with me.  And I want just two
files per top-level directory.

2. Strange things can happen with caching, as just happened to me when
I restored qtui_generate.py mistakenly deleted from leo/test.  There
is an @auto node for this file in qtGui.py, and I got improper 'can
not open' messages for this file.

3. It is troubling that the present caching scheme does not use the
full path to a file, only the basename.  This means that two identical
files in two different places will use the same cache entries.  I've
been wondering for the last several days about whether this could
cause problems.  I don't know for sure, but I am uncomfortable.

4. I want the clear-cache and clear-all-caches commands to do what
they say: get rid of everything.  Among other things, this is good for
debugging and recovering from cache problems.

.. @+node:ekr.20100223075705.5635: *5* Don't write expansion bits
.. @+node:ekr.20100210163813.5748: *5* Caching buglets?
This is a recent bug, but imo it has uncovered some other caching buglets. These
buglets are not big enough to delay Leo 4.7, but the new caching scheme would
ensure they never bite.

1. The code that computes what I have been calling the top-level directory is dubious::

    dbdirname = join(g.app.homeLeoDir,'db',
            '%s_%s' % (bname,hashlib.md5(fn).hexdigest()))

The problem is that bname is only the base name of the cached file, not a name
(or key) that depends on the full path. Thus, two copies of the same file in the
same place will be cached in the same directory. Is this ominous?

2. It's not clear what caching to do with the save-to command.
.. @+node:ekr.20100225102636.5627: *5* Use the string returned by cacher
# It should be possible to avoid duplicate reads.
.. @+node:ekr.20111101050427.16716: *4* Make g.openWithFileName "reentrant"
@nocolor-node

That is, make sure it works when called from within itself.
.. @+node:ekr.20111125072438.10216: *4* Regularize slashes and back-slashes
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/0d48b507bc8ffc05

v4.9.1 build 4669
WinXP

If I 'Open' a file, I get the following node header:

@edit E:/Documents/index.html

If I 'Import' the same file, I get the following:

@file E:\Documents\index.html

Just wondering why the difference between

E:/ and E:\

This is probably trivial and of no consequence, but I thought it
curious.

Create unit tests illustrating path ops
.. @+node:ekr.20130503061707.10515: *5* @@test path computations
fj = g.os_path_finalize_join
f  = g.os_path_finalize
eu = g.os_path_expanduser

if g.app.isExternalUnitTest:
    loadDir = fj(g.app.loadDir,'..','test')
else:
    loadDir = g.app.loadDir

table = (
    (fj,'@@file fj-test-1',fj(loadDir,'rel-path')),
)

for func,h,expected in table:
    p = g.findNodeAnywhere(c,h)
    assert p,'not found: "%s"' % (h)
    assert p.h.startswith('@@')
    p.h = p.h[1:] # Remove the first @ sign.
    
    try:
        d = c.scanAllDirectives(p)
        result = d.get('path')
        assert result == expected,'expected "%s", got "%s"' % (
            expected,result)
    finally:
        p.h = '@' + p.h
        c.redraw()
.. @+node:ekr.20130503061707.10516: *6* @path rel-path
.. @+node:ekr.20130503061707.10517: *7* @@file fj-test-1
.. @+node:ekr.20111003232155.6988: *4* Use c.db for marks & expansion bits
This would allow us to eliminate @bool put_expansion_bits_in_leo_files.
.. @+node:ekr.20120516140545.9993: *4* zz Unlikely
.. @+node:ekr.20111010093113.15548: *5* Lighten Leo's code base; remove wrapper layers
@nocolor-node

Almost from day one, Leo has defined gui base classes in the core, and
subclasses in gui plugins.

I plan to continue that organization, but I would like to remove some of the
wrapping layers if possible. The present scheme has one or two too many
redirection layers, and they are more of a nuisance than a help.

One idea would be to define **interface classes** that define the desired api's.
Unit tests could test that subclass implements the interface class, without
having to resort to quite as much error-prone machinery as at present.
.. @+node:ekr.20111021035504.9467: *5* Play with PyQt Qtest framework
http://groups.google.com/group/leo-editor/browse_thread/thread/b851e7d9855a57c2

http://www.voom.net/pyqt-qtest-example
.. @+node:ekr.20120205022040.15412: *5* Refactor the key code
@nocolor-node
    
* Define k factory methods:
    
    k.makeKeyStroke(user_setting_string)
    k.makeKeyStrokeFromData(data)
    k.makeShortcutInfo(...)

* Refactor the Qt input code so it calls k.makeKeyStrokeFromData(data).
  This will require untangling the input code from event handling code.
.. @+node:ekr.20120226183512.10202: *5* Use QSignalSpy?
QSignalSpy: doesn't exist on PyQt?
.. @+node:ekr.20110605121601.18838: *5* Remove or complete x.createBindings
.. @+node:ekr.20110605121601.18840: *5* Support cascade menu
leoQtFrame.cascade.
.. @+node:ekr.20110605121601.18841: *6* cascade
def cascade (self,event=None):

    '''Cascade all Leo windows.'''

    x,y,delta = 50,50,50
    for frame in g.app.windowList:

        w = frame and frame.top
        if w:
            r = w.geometry() # a Qt.Rect
            w.setGeometry(x,y,r.width(),r.height())

            # Compute the new offsets.
            x += 30 ; y += 30
            if x > 200:
                x = 10 + delta ; y = 40 + delta
                delta += 10
.. @+node:ekr.20110605121601.18842: *5* Should leoQtMenu.index do something?
.. @+node:ekr.20140704052551.17957: *3* Coloring
.. @+node:ekr.20060824110846: *4* * Add colorizing for cweb, rapidq
.. @+node:ekr.20110605121601.18839: *4* * Create color picker
createColorPicker
.. @+node:ekr.20130803073926.12442: *4* * Waiting
- Waiting for answer to solarized question:
    http://qt-project.org/forums/viewthread/30838/
    https://groups.google.com/forum/#!topic/leo-editor/W1_LVrQxdwQ
.. @+node:ekr.20110614123640.6587: *4* Add headline/color functions to Leo's core
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/7e279fe3dedf42be/f00fde4df5b39ded

What uA should be used to specify node colors?

if the foreground / background color API uses uAs,
would/should the uAs use the reserved "leo_&lt;something&gt;"
namespace?

-------------------

Terry Brown

Sounds like something I may have brought up, long ago.

I was thinking that setting the fore/background color of nodes in the
tree should be a "gui core" function, and that the info should be
stored in uA, and so wanted to know what key should be used in uA for
that.  I think the docs say top level keys starting with "leo_" are
reserved, and probably wanted a ruling on

v.u['leo_fg'] = 'red'

vs

v.u['leo_tree_style']['fg'] = 'red'

etc.

I think the question may be more complicated than just what to call the
key, so you can probably retire the todo item.
.. @+node:ekr.20111028195854.16607: *4* Allow ruleset-specific colors
@nocolor-node

Like @color html::tags_markup_color = blue
.. @+node:ekr.20120229094652.15178: *3* Commands
.. @+node:ekr.20141105050314.23: *4* Problems with @g.command decorator
@language rest

This post discusses discusses problems with the @g.command decorator. Later
sections discuss solutions. These later sections are ENB (Engineering Note
Book) discussions, which can safely be ignored by all except the usual
suspects...

Promises to do something "today" don't always get kept because a seemingly
simple task like adding an insert-file-name command becomes unbearable.
Creating a better way to define commands has become urgent.

===== Background

@g.command has its uses, especially in plugins. It allows any code to
 define a new Leo command without having any access to Leo's core code. For
 this reason alone, the @g.command decorator is here to stay.

However, using @g.command to add Leo commands is often *way* too clumsy.
There are several problems using @g.command. To see these problems clearly,
let's look at a typical example, from leoVim.py::

@language python


    @g.command(':gt')
    def vim_gt(event):
        '''cycle-focus'''
        c = event.get('c')
        if c and c.vimCommands:
            c.vimCommands.cycle_focus()
            
@language rest

This code sucks, for at least the following reasons:

1. It requires an outer-level function-name (vim_gt) that has no value
   except to the @g.command decorator itself. This is useless verbiage and
   just clutters the namespace. Worse, although the decorator doesn't
   require distinct names, disabling a pylint check for duplicate names
   would be way too dangerous.

2. It repeats the template code for each different command. This is pure
   cruft. Worse, the tests for c and c.vimCommands would not be necessary
   in a subcommander.

3. It is usually bad design to define the command at the top level.
   Commands should be defined in the classes that contain their code!

For all these reasons, vim-mode commands clearly should *not* be defined
using the @g.command decorator. The question is, how to define them
cleanly?

Everything from here on is an ENB entry. Feel free to ignore, unless you
are Terry ;-)

===== Motivation

It would be possible to define vc commands in vc.finishCreate as is done by
sub-commanders in leoEditCommands.py, but as I was thinking about this
problem I discovered how to simplify the definition of almost *all* of
Leo's commands. This is too good to ignore, for the following reasons:

1. The simplifications to be described reduce order constraints during
   startup. Any such reduction is, all by itself, extremely valuable,
   because such order constraints are the main complicating factor in the
   startup code.

2. As always, simplifications to complex code (and Leo's startup code is
   complex in hard-to-see ways) promise further simplifications. No further
   simplifications are apparent *now*, but it would be bad practice not to
   simplify the code when I can.

===== Details

At present, there are several ways (not sure how to count them ;-) to
define large numbers of commands. By defining a command I mean associating
a string (the command's name) with a method of some class.

Although details vary, the basic idea in each case is to define a
**commands dict**, a Python dict whose keys are command names (Python
strings) and whose values are methods.

In particular, each subcommander in leoEditCommands.py defines a
getPublicCommands method that returns a commands dict.

ECM.finishCreateEditCommanders then merges all the commands dicts, like
this::

@language python

    def finishCreateEditCommanders (self):
        '''Finish creating edit classes in the commander.
        Return the commands dictionary for all the classes.'''
        c,d = self.c,{}
        for name, theClass in self.classesList:
            theInstance = getattr(c,name)
            theInstance.finishCreate()
            theInstance.init()
            d2 = theInstance.getPublicCommands()
            if d2:
                d.update(d2)
        return d
        
@language rest


But none of this should be necessary. Or rather, it should happen in a
different place, and at no *particular* time.

===== A much better way to define commands.

The basic problem with the code above is that it must happen at the exact
instant that various finishCreate methods get called. Yes, the present code
works, but it depends *far* too much on code order during startup.

We can remove *all* these unnecessary ordering constraints as follows:

1.  Define init phase 0: create ivars.

This phase is trivial, for our present purposes. Commands.__init__ will
just define c.commandsDict and its inverse, as *empty* Python dictionaries.

At present, the inverse of c.commandsDict is c.k.inverseCommandsDict. How
stupid is that? It must be a c (Commands) ivar, not a c.k (KeyHandlerClass)
ivar! Doh. Using a c.k ivar means that c.k must be inited *before*
c.k.inverseCommandsDict is ever used. This is a completely unnecessary
constraint.

In short, the inverseCommandsDict must be a Commands ivar, not a
KeyHandlerClass ivar. This will ensure that c.inverseCommandsDict will
exist before any subcommander's *ctor* gets called.

2. Define c.registerCommands (plural). This will call a new method,
   c.registerCommand, for each item in a commands dict.

Important: c.k.registerCommand must remain for compatibility, but it will
probably just call c.registerCommand.

With just these simple changes, *any* class can call c.registerCommands at
*any* time. In particular, any class can call c.registerCommands in its
ctor, or its ctor's helpers. There is no need to wait until finishCreate
gets called!

Defining command names in the ctor logic may leave some finishCreate
methods empty. If so, we can rejoice--another ordering constraint has
disappeared forever!

===== Testing

I expect the changeover to the new scheme to be straightforward. It may
happen "today" (TM).

This new scheme should be safe, but just to make sure, I'll probably enable
the new code with g.NEW_COMMANDS.

It's not clear how well the present unit tests actually tests the
association between commands and their names. A separate unit test may be
advisable.
.. @+node:ekr.20141105050314.24: *5* What I did
In the end, I have opted for the bare minimum of changes. Given the
complexity of key handling, I think this is the only sane way. Here is a
slightly revised checkin log for rev 09ab839...:

QQQ

Cleaned up how command names get put into c.commandsDict and
c.inverseCommandsDict, but only a little bit ;-)

All tests pass, but use a bit more caution.

- Removed @g.command nodes from leoVim.py.
  vc.defineCommandNames now creates command names.
 - Called vc.defineCommandNames from the new c.createCommandNames, called from c.finishCreate.
- Changed k.inverseCommandsDict to c.inverseCommandsDict.
- Renamed ecm.finishCreateEditCommanders to ecm.defineCommandNames.
QQQ

All this adds up to *slightly* better code.

In particular, the various o.defineCommandNames methods can be called any
time after o has been created. These methods depend on nothing else, so
they can be called "early" in c.finishCreate, by c.createCommandNames. This
is a real plus: there are now a few less order dependencies in the startup
code. Replacing rst.finishCreate with rst.createCommandNames is gratifying.

This is important! The various finishCreate methods must be called in
*exactly* the right order so that various widgets are created in one
finishCreate method before they are needed in another finishCreate method.
So anything that either eliminates finishCreate methods entirely or reduces
their complexity is a real improvement in Leo's startup code.

Otoh, I left the code that creates c.commandsDict and c.inverseCommandsDict
*strictly* alone, except that:

1. inverseCommandsDict is now a c ivar instead of a k ivar.

2. The new c.createCommandNames method encapsulates all aspects of the
   making of the command name dicts. This should make this difficult code
   slightly easier to understand.

On balance, this was a long day of coding for minor improvements to Leo's
startup logic. But these are steps in the right direction.

In any case, the VimCommands class now defines command names in
vc.defineCommandNames. There no need for vc.finishCreate and no need for
all those redundant @g.command code hunks.

Unless there are bugs reported, this ends this project for the foreseeable
future.
.. @+node:ekr.20111010122531.15569: *4* print-bindings/commands/settings create nodes??
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/d302b2715b3ace96

A reminder, the opposite of "light" is "heavy", not "dark" :-)

Leo's print-settings, print-commands and print-bindings commands
create too much text.

Suppose they created outline nodes instead, replacing existing nodes
if they exist.  Something like this:

- Reference (Anywhere you like)
 - @print-settings
    etc.
 - @print-bindings
   etc
 - @print commands
   etc

Doh!  This uses Leo's power.  The subnodes can be as voluminous as
desired, and there can be organizer nodes in each case.  The actual
tree could be specified as in @menus.

Etc., etc.  This could moot the need for separate apropos commands.
Conversely, apropos commands could create their own trees, or
subtrees.

This could be the tip of an iceberg.

The more I think about the light/heavy distinction, the more I think
it is getting close to what makes Leo special.  For example, clones
(and nodes, for that matter) drastically lighten the apparent
complexity of programs or data.
.. @+node:ekr.20130508084413.10634: *4* quickmove-jump-to adds button
.. @+node:ekr.20111019104425.15868: *4* Render to tex, pdf, rst, etc.
.. @+node:ekr.20120515193246.10083: *4* Find & spell
.. @+node:ekr.20111018104244.15928: *5* Improve Find panel
@nocolor-node

- All open files.
- Show all results as in quicksearch.
.. @+node:ekr.20111014134653.15672: *5* Search across multiple Leo files
http://groups.google.com/group/leo-editor/browse_thread/thread/cf5ab54f29a6c128
.. @+node:ekr.20051110155735.1: *5* Improve spell checking
- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.
_ Spell checker should check headlines.
.. @+node:ekr.20110520051220.18203: *5* Cross-tab search
@language rest

This would be a substitute for cross-file clones.
.. @+node:ekr.20111027143736.16558: *5* Work-flow improvements
@nocolor-node

Considering leo.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/e3ddbe650fc9525b/290e97c593ee950a

> > I think there's a way to search across Leo files: quicksearch multiple
> > files ... ?

> http://groups.google.com/group/leo-editor/browse_thread/thread/cf5ab5...

Leo has to have this :-)  It's on my list.  It would be a great way to
find @button nodes.

Furthermore, global searches for attributes in docstrings have
immediate uses.

On the urgent to-do list: drive all aspects of the Nav pane using
keystrokes.

I just reviewed @bookmarks--it's perfect for leo.leo.  The following
would replace all.bat:

- @bookmarks
  - leoPy.leo (url in body)
  - leoPlugins.leo
  - leoSettings.leo
  - myLeoSettings.leo
  - leoDocs.leo
  - leoDist.leo
  - scripts.leo

This way could be said to be much better than all.bat: nothing gets
loaded until needed.  Therefore, even more files could be added.

Imo, URL's in bookmark trees should support {{expression}} notations.

For example, I want the following to work in the body text of a node
in an @bookmarks tree::

file://{{g.os_path_finalize_join(g.app.loadDir,'..','doc','LeoDocs.leo').replace('\\','/')}}

Not bad, eh?  Or maybe the URL logic should do the replace('\\','/')
automatically...

Got to go.  We are nearing a tipping point in Leo's workflow... 
.. @+node:ekr.20041022083005.2: *5* add a Stop button for find/change
.. @+node:ekr.20041219162724: *5* Add dialog to insert recent directories
http://sourceforge.net/forum/message.php?msg_id=2903742
By: nobody

In the multifile plugin there is an option to insert a directory string.  I
use it alot for the @path directive.  What happens is that when executed a FileDialog
opens up and the user selects the directory he wants to use as a directory string.
When chosen the directory string is inserted into the text editor.

The good of this:
1. It makes using path simpler, you dont have to type out the directory path
yourself, just use the tkFileDialog to select it and have Leo insert the string.
For long directories this saves a lot of typing.

simple, short and quite helpful.  Thoughts? :)

-----------

Time to create a directory class??

.. @+node:ekr.20120515193246.10084: *4* Import/export
.. @+node:ekr.20101004092958.5914: *5* Write treepad scanner
@ treepad.py is from the treepad website
.. @+node:ekr.20101004092958.5939: *6* treepad.py
@first #! /usr/local/bin/python

# treepad.py

@language python
@tabwidth -4
@others
if __name__ == '__main__':
    Main().Run()

.. @+node:ekr.20101004092958.5940: *7* treepad declarations
import sys, os, re, string

# constants
VERSION = "<Treepad version 2.7>"

# regexes
END_RE = re.compile(r'^<end node> ([^ ]+)$')
.. @+node:ekr.20101004092958.5941: *7* class Node
class Node:
    @others
.. @+node:ekr.20101004092958.5942: *8* __init__ (Node/treepad)
def __init__(self):
    self.title    = ""
    self.level    = 0
    self.article  = []
    self.children = []
    self.parent   = None
    self.end      = ""
.. @+node:ekr.20101004092958.5943: *8* __str__
def __str__(self):
    return "%s/%d" % (self.title, self.level)
.. @+node:ekr.20101004092958.5944: *8* addchild
def addchild(self, node):
    assert self.level == node.level-1 and node.parent is None
    node.parent = self
    self.children.append( node )
.. @+node:ekr.20101004092958.5945: *8* findparent
def findparent(self, node):
    if self.level == (node.level-1): return self
    return self.parent.findparent(node)
.. @+node:ekr.20101004092958.5946: *8* writenode
def writenode(self, fp):
    fp.write("dt=Text\n")
    fp.write("<node>\n")
    fp.write("%s\n" % self.title)
    fp.write("%s\n" % self.level)
    for line in self.article:
        fp.write("%s\n" % line)
    fp.write("<end node> %s\n" % self.end)
.. @+node:ekr.20101004092958.5947: *8* writetree
def writetree(self, fp):
    self.writenode(fp)
    for node in self.children:
        node.writetree(fp)

.. @+node:ekr.20101004092958.5948: *7* class NodeReader
class NodeReader:
    @others
.. @+node:ekr.20101004092958.5949: *8* __init__ (NodeReader)
def __init__(self, fname, fp):
    self.fname    = fname
    self.fp       = fp
.. @+node:ekr.20101004092958.5950: *8* expect
def expect(self, text, line=None):
    if line is None:
        line = self.fp.readline().strip()
    assert line == text, "expected " + line + " == " + text
.. @+node:ekr.20101004092958.5951: *8* readstart
def readstart(self):
    self.expect(VERSION)
.. @+node:ekr.20101004092958.5952: *8* readnode
def readnode(self):
    line = self.fp.readline()
    if line is None:
        return None
    line = line.strip()
    if len(line) < 1:
        return None
    self.expect("dt=Text", line)
    self.expect("<node>")
    node = Node()
    node.title = self.fp.readline().strip()
    node.level = int(self.fp.readline().strip())
    while 1:
        line = self.fp.readline()
        m = re.match(END_RE, line)
        if m:
            node.end = m.group(1).strip()
            break
        node.article.append( line.strip() )
    return node

.. @+node:ekr.20101004092958.5953: *7* class TreeReader
class TreeReader:
    @others
.. @+node:ekr.20101004092958.5954: *8* __init__(TreeReader)
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'r')
    self.nodereader = NodeReader(fname, fp)
    self.root = None
    self.prev = None
.. @+node:ekr.20101004092958.5955: *8* add
def add(self, node):
    if self.prev is None:
        assert node.level == 0
        self.root = node
    else:
        assert node.level > 0
        parent = self.prev.findparent(node)
        parent.addchild( node )
    self.prev = node
.. @+node:ekr.20101004092958.5956: *8* read
def read(self):
    self.nodereader.readstart()
    prev = None
    while 1:
        node = self.nodereader.readnode()
        if node is None: break
        self.add(node)

.. @+node:ekr.20101004092958.5957: *7* class TreeWriter
class TreeWriter:
    @others
.. @+node:ekr.20101004092958.5958: *8* __init__ (TreeWriter)
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'w')
    self.fname = fname
    self.fp    = fp
.. @+node:ekr.20101004092958.5959: *8* write
def write(self, root):
    self.fp.write("%s\n" % VERSION)
    root.writetree(self.fp)

.. @+node:ekr.20101004092958.5960: *7* class Main
class Main:
    @others
.. @+node:ekr.20101004092958.5961: *8* __init__ (Main)
def __init__(self):
    self.infile  = sys.argv[1]
    self.outfile = sys.argv[2]
    self.reader  = TreeReader(self.infile)
    self.writer  = TreeWriter(self.outfile)
.. @+node:ekr.20101004092958.5962: *8* Run

def Run(self):
    self.reader.read()
    self.writer.write(self.reader.root)

.. @+node:ekr.20031218072017.790: *5* Import dialog improvements
@nocolor

Other options I though would be really handy:

1. Use an existing node as a source also

2. Use an node from another Leo file.. I am not sure what the syntax for that
would be exactly

3. From a URL.. this would be really cool. People could post outlines not only
as existing Leo xml files, but as text files or even dynamic scripts. The code
to handle these would presumably need to deal with http:// intelligently. But
that's easy in Python. Rebol is great at that too.

4. Other XML file with valid filepaths in them.
That's probably a much bigger project like Leo 3.10  

Jason
.. @+node:ekr.20060227124411: *5* Import/export from wiki's
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3583737
By: Offray

I was previously thinking in the relation between Leo and Wikis, and I think
that may be a thing that would help to make Leo more visible in Wiki space could
be if Leo can export/import to/from a Wiki (something limilar to th @file or
@url directives). Let me explain a little better the scenary where this idea
come.

We have a local wiki for colombian Free Software Community related issues, and
I have used Leo for writing the migration scripts from Mediawiki to MoinMoin
(wich I think is more flexible and extensible that the popular wiki behind
wikipedia). I was probing also the idea of a Wiki like environment for solving
colaborative problems, so I was posting the scripts I made on Leo in a Wiki
page, and republishing them in the moment they changed. This keeps me pasting
all the time the script and in some moments I was thinking what about if someone
make a change in the Wiki page. Would be nice then to have the same capability
to detect and sincronize that change as Leo make with the hard disk files.

But this doesnt end here. Another Wiki-Leo interaction is to use outlines as
a way to organice Wiki content. For example "= Title =" in a Wiki would be a
Outline Node in Leo and "== Subtitle ==" Would become a outline subnode all
arranged in the proper hierarchy.

Somekind of Wisiwyg display would be nice, but this must be a plugin or something
like that, so Leo could become a "Layered" front end to some kind of data.

About and article on Wikipedia. That would be nice, but I'm a little tired of
fighting with some wikipedians ignorance on certain matters combined with power
(a pretty bad combination). I think that a Wiki page is nice because its live
comes from the community knowledge, but I'm not interested in that fighting,
so I have made a Leo wiki page in our local Wiki:

http://www.el-directorio.org:8080/Leo

and when I have enough knowledge about Leo (and time) I hope to start making
contribs in the spanish documentation (for the moment I'm only workind in the
evangelism here).
.. @+node:ekr.20031218072017.748: *5* Import/Export to yaml
Need a good yaml parser first: I don't want to write another parser by hand.
.. @+node:ekr.20041130123243: *4* Clear Undo command
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2859273
e

theres a config option to clear undo on save.
can that be a menu choice as well? 
clear undo now.
enable clear undo on save.
moot as it will be with the new config options
and any undo changes on the table.
maybe there is a single point to involke clear 
undo that could be run from a button?

with py2.3 after allot of small edits on an open leo after a few hours gc can
hit unexpectedly and last several minutes
and return at any time lasting several more minutes.
I think its gc related because the memory use and disk grinding demanding I
free up memory or kill python.

I have no idea if undo is the cause,
 just guessing.
using cvs of last week. I just updated, 
will let you know if it happens again.
(new error reporting jump to error is great)

usually I don't edit in the same process that long.
I have run scripts from leo that run 6, 12 
or 24 hours no problem. 
maybe I can turn on some internals reporting and
get some feedback on whats going on from python if it happens again. 
or run the gc script before and after.

 win98 128meg w/maxmem memory defrager that works well.
but I go from 50% free to 10% when this starts happening.
I haven't noticed this problem yet in py2.4, and it is peppier,
but don't use py2.4 enough. it doesn't happen every day.
I reboot at least once a day for various reasons.
so it isn't that either. 
you do need to reboot and or exit python once it starts.
this was never an issue with py2.2 and Leo 4.1 or less with only 64 megs.
I don't really have any other long running python processes to compare to Leo. 
can't say what it is.
Aha, progress. 
this started sometime early in 4.2 or late 4.1
but I can still be persuaded something in my 
local system is to blame, some install or dll update. or script, psyco or plugin
related.

nonwithstanding, I should be taking better advantage Moore's law in my CPU and
memory.
I only notice this when I'm running the same leo over a few hours of constant
editing and running scrips.
and when I exit python and restart leo everything returns to normal.
more a supporting anomaly report 
than a bug report or feature request.
.. @+node:ekr.20050127110221: *4* Printing & flash
@killcolor
https://sourceforge.net/forum/message.php?msg_id=2962825
By: jasonic

-- pdf -- 
yes I know what you mean, PDF has it uses.  If nicely embedded into Leo via
'reportwriter'  and some export scripts {and clear useinterfance} would stillbe
a good thing.


As I start to think about how to print Leo, I become more aware of the differneces
between Leo structures and linear [print] layouts.

Different kinds of outlines obviously will need different kinds of printing.
I don't yet have enough experience or overview.

--xslt--
Seems a natural way to go for printing Leo, but yet another langauge and syntax
to wrassle with. Last time I looked I went from being horrified to very impressed
to be being exhausted.

--htmlize--
thanks I'll check into that

"print to web"  should definitely be on Leo's missing PRINT MENU.

--swf [flash]--
This printing topic pushes me harder to get FLC  [my FlashLeoClient project]
into the Leosphere.

Flash has*limited*  CSS handling, but enough to do some nice and useful typographic
formatting in a pretty clean object-oriented manner.

FLC parses .leo files into a Flash object. Flash Textformat instances are created
using CSS and can be applied then to rendering any parts of  the deserialized
Leo object.. The beauty is it can be very fast and ynamic so I can imagine a
real-time WYSIWYG laytou tool for printing Leo to web and at the same making
it suitable at the same time for print-to-paper.

Since FLC is in the very first instance a READ-ONLY client tool for Leo, it
makes it a natural Leo printing service.

To complete full service, it woudl be good if Leo could create SWF files directly
itself, just like using PDF reportwriter.
There are a couple of libraries to help this 
- Ming [with PHP, Perl, Python and Ruby wrappers]
http://ming.sourceforge.net/

- makeswf.r [interesting REBOL/Flash dialect by David Oldes]
http://sweb.cz/oliva.david/swf/

These could also be both configured as web-services.
So Leo print-to-web would include by default rendering a flash swf file versoin
of itself either using locally installed libraries or by passing a view of itself
to a chosen client or server-based tool.

But even without those extra 'services' and libraries a single flash file in
the form of FLC could become an effective Leo printing kit. Using a standalone
desktop  version [not embedded in the browser, out of the sandbox] much more
is possible - remote control, peer-peer editing, file writing etc.

-- flashpaper2--
btw, Lately I've been using Flashpaper2 a lot to print all kinds of stuff, Often
from web pages to my local adhoc home filebase. It's a very fast lighweight
alternative to PDF, saves paper, has excellent zooming and nice search features
built-in.
Flashpaper renders a very litteral snapshot, but as I am discovering that turns
out to be extremely useful.
For example you visit a page and click on some links. Flashpaper saves teh pages
exactly as it looks, viisted links disntinguished.  In the era of info-overload,
even that crude mnemonic is valuable.

Alas, Flashpaper2 is not free nor open in the way Leo is. But worth to play
with it if only for for the experience.
30 day trial downlaod from
http://www.macromedia.com/software/flashpaper/

And of course the flash _players_ is free, so can send people flashpaper documents
just like PDF.
Brilliant when you have a big Excel spreadsheet or CAD document which would
normally get all messy printing across pages, confusing people.
Instead adjust and print to a generous 'piece' of flashpaper - letting your
coleagues pan and zoom to their comfort.

I've not quite figured out the place where  Leo meets Flashpaper, because Leo
needs to preserve its full pane contents. Flashpaper works fine with long web
pages, automatically reading the full window contents and cutting into a paginated
sequence, ready for paper printing.
Leo's does not have aprint menu, so it's off the sytem's print-devices map,
which Flash paper appearing just  like any phtycial printer.

I imagine is possible to fix that in Leo, but I do not where to begin and woudl
not be surprised to learn its a major heachche to write adn debug for multiple
operating systems.

An immediate alternative are screencapture tools like vnc2swf or MDM Capture.

[vnc2swf uses Ming-0.2a]
http://www.unixuser.org/~euske/vnc2swf/

http://www.multidmedia.com/software/capture/index.php

But much is hidden or lost from view. 
Still very vauable for creating dynamic narrative tutorials [aka screencasting]

AS you know I am very excited about what flash can do for Leo, and vice versa.
But I am concerned that there is not yet a 100% Leo means which supports people's
standard print needs and habits.

-- PRINT MENU-- 
Leo deserves good friendly printing features which anyone can use. At the moment
we have a confusing patchwork of choices. Printing Leo seems to be both harder
and easier than  first meets the eye.

Having a little library of export scripts - well named, documented and intended
to aid printing woudl go a long way. Thesse scripts anyone coiuld be called
by onayone given a Leo Outline, accessing a navabr button. PRINT MENU or list.
Or they can just insert the appropriate script  into an outline giving finer
grained print control on the fly.
.. @+node:ekr.20031218072017.807: *4* Put up file dialog on empty @url, etc.
@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2003457
By: dsalomoni

Proposal: modify the code for @url so that if you type for example just "@url"
(no file specified) in a headline, a window pops up allowing you to browse the
local file system and select the file (similar to what browsers do when you
want to open a file).

This would be more convenient than manually writing @url
file://a/long/path/to/the/file. @read-only nodes already allow this, it would
perhaps be nice if all these types of plugins (@folder might be another one
for example) and directives (@file etc) had the same behavior (and this should
probably be specified in some guidelines for writing new plugins -see e.g. the
jedit plugin guidelines).

Davide
.. @+node:ekr.20140824043305.18297: *4* Unlikely...
.. @+node:ekr.20041016134312.2: *5* Standard Weave command
Use noweb and TeX, or maybe Pyx.
.. @+node:ekr.20110529115328.18238: *5* Emacs related
I'll do these if and and only if somebody asks for them.
.. @+node:ekr.20110529104352.18248: *6* Complete k.universalDispatcher
.. @+node:ekr.20110529104352.18249: *6* Complete number-to-register command
.. @+node:ekr.20031218072017.753: *6* Emacs comint-mode
@nocolor

The improved Execute Script command does most of this

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
.. @+node:ekr.20060116090428: *6* Expand 'point' so it indicates node as well as text location
.. @+node:ekr.20071004120359.2: *6* expand-region-abbrev
See: regionalExpandAbbrev.

You may wish to expand an abbrev with a prefix attached; for example, if `cnst'
expands into `construction', you might want to use it to enter `reconstruction'.
It does not work to type recnst, because that is not necessarily a defined
abbrev. What you can do is use the command M-' (abbrev-prefix-mark) in between
the prefix `re' and the abbrev `cnst'. First, insert `re'. Then type M-'; this
inserts a hyphen in the buffer to indicate that it has done its work. Then
insert the abbrev `cnst'; the buffer now contains `re-cnst'. Now insert a
non-word character to expand the abbrev `cnst' into `construction'. This
expansion step also deletes the hyphen that indicated M-' had been used. The
result is the desired `reconstruction'.

If you actually want the text of the abbrev in the buffer, rather than its
expansion, you can accomplish this by inserting the following punctuation with
C-q. Thus, foo C-q , leaves `foo,' in the buffer.
.. @+node:ekr.20060123091352: *6* Incremental search in switch-to-buffer
.. @+node:ekr.20060628103226.3: *6* Make sure repeat counts work on basic editing commands
.. @+node:ekr.20051021074728: *6* Space completion
.. @+node:ekr.20041022083226: *3* Directives
.. @+node:ekr.20031218072017.805: *4* Allow other section delims besides << and >>
Maybe the section operator could be customizable, 
I personally prefer the wiki way [[name of section]]. 

@setlink-tag [[ ]] 
.. @+node:ekr.20031218072017.745: *4* @@first <n>
@nocolor

Hate to break into the grand design discussions, but here's a hopefully small thing. If you need to place a good sized copyright statement at the top of your files, LEO doesn't handle this case very cleanly. As I'm sure you're aware, you wind up with a matching number of @@first lines for each leading line in your source. 

As an example: 
# 1 
# 2 
# 3 
# 4 
# 5 
@verbatim
@verbatim
@verbatim
#@+leo 
@verbatim
@verbatim
@verbatim
#@+node:0::@file /tmp/firstcheck.py 
@verbatim
@verbatim
@verbatim
#@+body 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@+doc 
# 
# How many firsts do I get? 

@verbatim
@verbatim
@verbatim
#@-doc 
@verbatim
@verbatim
@verbatim
#@@c 
Start code. 
@verbatim
@verbatim
@verbatim
#@-body 
@verbatim
@verbatim
@verbatim
#@-node:0::@file /tmp/firstcheck.py 
@verbatim
@verbatim
@verbatim
#@-leo 

My fellow co-workers who don't use LEO, aren't exactly loving me here. 

Might we introduce an: 

@@first <num> 

Type tag instead? So one '@@first 5' could represent all 5 of the above @@first lines? It makes for a smaller, cleaner LEO footprint and will tick off non-LEO users much less. 

Thanks. 

- ordinarius 
.. @+node:ekr.20031218072017.795: *4* Metatags
@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 3.11 todo list & schedule   
2003-02-11 03:25  

Here are some features I'd like to see: 

3. Metatags. @sectionname or @savedate are expanded to the appropriate text when saved.

-marshall-  

There are quite a few of these now.  It would be good to generalize:
- Register @node type.
.. @+node:ekr.20041130104552: *4* (Support bird-track programs/comments?)
@killcolor

By: Guenther Enthaler - genthaler
RE: Haskell support  
2004-11-18 22:55

There's a literate programming mode in Haskell (and in a number of other
functional programming languages such as Clean & Curry), where the program is in
a comment, usually where the line starts with ">" (bird track style, I think
it's called), and the comments/documentation are freeform. It would be difficult
but cool if Leo could support it, if only because the sentinels in the derived
files wouldn't make whole file look so busy.

Günther 
.. @+node:ekr.20111010122531.15568: *4* @render-rest, @render-html trees
@language rest

The free_layout and viewrendered plugins are a huge step forward.  But
the lighter/heavier distinction suggests a new way to use them.

Suppose Leo supports @render-rest or @render-html.

This means that all nodes in the tree will have the body pane become a
rendering pane for rST or html.

Imagine LeoDocs completely rendered at all times.

Of course, for specific purposes, say in Leo's scripting chapter, we
might want to override these rendering directives (which should be
allowed in headlines too) with @no-render.

The point is that having *both* the original text *and* the rendered
text be visible is often too heavy: the user usually does not want to
know about the sources: the rendering is good enough.

I suppose for sophisticated users, something like show/hide-body pane
would be good commands to have, but that doesn't matter: those
commands to not increase the burden on the user while she is reading
the (rendered) docs.
.. @+node:ekr.20031218072017.797: *4* Allow @file http & @file ftp
@nocolor

I'd like to see leo's @file can be extended to cover more protocols, like REBOL's "read" does. 

in short, it would be very sweet if the following work: 

@file http://www.somedomain.org/python/foo.py 

@file pass@ftp.sd.org/python/foo.py" target="_blank" target="_new">ftp://user:pass@ftp.sd.org/python/foo.py> 

while we are at it, what about xmlrpc/soap? 

should there be new directive, like @source ?

@color
.. @+node:ekr.20031218072017.810: *5* Remote access Scott Powell
I will wait. Here's clarification, when you're ready for it:

All of my projects are stored on remote computers, and accessed via FTP. 
What I want is basically the ability to open up these projects directly 
through leo, instead of transferring the files manually between my computer 
and the computers that hold my projects, preferably through FTP.

My solution: A new menu item called 'FTP' or 'Remote'. Click on this, and an 
FTP dialog opens up, with an empty list of FTP sites, and the ability to add 
more. You select a site, and it brings up a list of files. You select a 
file, and it is added to your project. When you hit 'save', it automatically 
does an FTP send.

Python makes this a lot easier with the builtin module 'ftplib'. I'm sure 
there are similar things for C++. I hope you take this idea into 
consideration.

Scott Powell
CEO, Dev Designs
.. @+node:ekr.20140824043305.18292: *3* Docs
.. @+node:ekr.20131029095615.17089: *4* A cool tricks section
.. @+node:ekr.20130807203905.16650: *4* Leo in a nutshell (statistics)
https://groups.google.com/forum/#!topic/leo-editor/lgHE4OJSLzw

In a Nutshell, The Leo Editor...

- has had 15,508 commits made by 47 contributors
  representing 1,064,650 lines of code
- is mostly written in Python
  with an average number of source code comments
- has a well established, mature codebase
  maintained by a large development team
  with decreasing Y-O-Y commits
- took an estimated 292 years of effort (COCOMO model)
  starting with its first commit in February, 2002
  ending with its most recent commit 2 days ago 
.. @+node:ekr.20060227123536: *4* Tiddlywiki and related comments about rendering body text (Mulder)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3578252
By: bwmulder

I have been thinking for a while that it ought to be possible to somehow  to
unite Leo with wiki features (my thinking is still vague at this point).

If you look at systems like Tiddlywiki (http://www.tiddlywiki.com/) you will
find that they already pretty much provide all the formatting features mentioned
in the article.

MoinMoin, another wiki (http://moinmoin.wikiwikiweb.de), has started to use
a graphical interface for editing in the latest version.

Maybe Leo can be split up into three components:

1. A storage component is responsible for storing nodes. Currently, this is
just memory, but databases like shelve, Zope or sqllite should also be possible.

2. The control component is responsible for converting from the internal format
to external files which can be processed by existing compilers, searching within
a document, and the like.

3. A display component is responsible for interfacing with the user. If can
be TK, but it can also be something like the Tiddlywiki interface, which immediately
shows the formatting applied to text.

I don't know much about javascript, so I would have to learn more about this
language before doing anything in this direction.

As an intermediate step, maybe we could allow mixing RST processing with regular
program text.  Leo would produce two documents out of a source file: a version
for the compiler in plain ascii, and an HTML file for reading the source.
.. @+node:ekr.20111018104244.15924: *4* Revise Leo's wiki
.. @+node:ekr.20120515193246.10087: *3* DOM
.. @+node:ekr.20071001052501: *4* Versioning for nodes
@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
.. @+node:ekr.20080802070659.11: *4* Make node attributes visible, and supported by Leo's core
.. @+node:ekr.20111019104425.15896: *4* Enhansed node attributes: ctime, atime, mtime (Kent)
.. @+node:ekr.20111027103125.16546: *4* Fossil
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/19bfe6daf2b324/c50a750606d64f77

Fossil (SCCS) and Leo.

> I think that the interaction of Fossil + Leo could
> solve the idea of having external files in a single "Leo document" that
> would be really a fossil sqlite repository with all the external files in
> it, but syncronizable with the outside world. This kind of instantiated
> image of files in a moment of time in Fossil + Leo, would be like the
> instantiated image of objects in a moment of time of Smalltalk.
.. @+node:ekr.20090131200406.15: *3* File & file format
.. @+node:ekr.20141017110114.18265: *4* Use uuid's in gnx's
https://groups.google.com/d/msg/leo-editor/p_b2LLBAqps/aTQoyGBec68J

This post discusses a new command line argument for Leo: --uuid

I have no plans to implement --uuid now, but it may have to be done in future.

===== Rationale

Terry has convinced me that collisions between both user ids and timestamps
will become more frequent as Leo becomes more popular. Such collisions are
not a serious problem at present: the odds of two different people with the
same user id sharing .leo files is small.

Nevertheless, a serious problem lurks, one that can not, even in principle,
be solved with Leo's present gnx's.

Suppose two people have the same id. Then Leo *must* assume that those
people are actually the same person! As I have explained in other post,
this can lead to data loss if the two people create two *distinct* nodes
with the same gnx, and then try to merge those nodes into the same .leo
file. The odds of this happening are small, but increasing.

A good way to solve this problem is to use uuids,
http://en.wikipedia.org/wiki/Universally_unique_identifier
and python's uuid module: https://docs.python.org/2/library/uuid.html

===== Operation

The --uuid should cause Leo to use uuid's for all *new* gnx's. The uuid
option should not convert *existing* gnx's to uuid-based gnx's.

A new Leo command would convert all existing gnx's to uuid-based gnxs. Such
mass conversions should *never* be done automatically.

===== Format of uuid-based gnxs

I would like the uuid-based gnx's to use uuid's in *addition* to the id and
timestamp fields. Something like::

    id.timestamp..uuid

Alas, that does not seem possible, unless this kind of gnx is written to
external files (in node sentinels). But many users would complain that such
very-long gnx's clutters external files too much.

So it seems that new-style gnxs would have something like this form::

    ..uuid

The leading dots allow Leo to distinguish this kind of gnx from the old
forms::

    id.timestamp.n
    id.timestamp

provided that dots are not allowed in ids.

===== Summary

Leo's uuid-based gnxs can contain neither user ids nor timestamps.

We must ensure we stick with whatever new-style gnx format we choose
initially: we don't want to burden Leo with distinguishing between several
different forms of uuid-based gnxs.
.. @+node:ekr.20061002093442: *4* Add opml support to new,open, save commands
.. @+node:ekr.20080311135649.2: *4* Allow different .leo formats
@nocolor

On Tue, Mar 11, 2008 at 7:03 AM, Kent Tenney <kten...@gmail.com> wrote:

> On 3/11/08, derwisch <johannes.hues...@med.uni-heidelberg.de> wrote:

> >  On 11 Mrz., 08:03, "Ville M. Vainio" <vivai...@gmail.com> wrote:
> >  > It could also be argued that

> >  > - Referring to previous cloned vnodes explicitly in XML does not
> >  > necessarily obscure DAG - it follows the "do not repeat yourself"
> rule
> >  > - It will speed up reading
> >  > - Wouldn't it be better for preserving the integrity of the XML file?

> > I would lean towards this line of argumentation. A couple of days I
> >  had my Leo extension destroy the Leo ODM file (which was still valid
> >  according to Leo, but unreadable wrt the extension and broken uAs). I
> >  resorted to editing the Leo file with Emacs, and was quite surprised
> >  to see that the headStrings were attributes of vnodes.

> I'll chime in with my pet peeve re: .leo file structure::

> I think that putting the headstrings on vnodes and body strings on tnodes
> obscures the informational content of the .leo file, and makes the .leo
> file
> format less attractive as a generalized solution to the problem of how to
> manage head/body pairs which live in a hierarchal structure.

> Thanks,
> Kent

> >  I think that
> >  editing the file might have been a bit easier if there had been no
> >  such redundancy. But this is more a feeling rather than a qualified
> >  opinion.

Thanks for all these comments.  I'll respond to them all here.

Clearly, we should be using a standard xml parser to read .leo files.

My present thoughts:

- I personally like human-readable headlines in <v> elements.

- I am open to putting headlines in <t> elements, as an indication that
tnodes do indeed contain headlines and body text.

- I am willing to consider only writing shared subtrees once.

Oh! (An Aha)  All these are preferences.  We can allow any combination of
these provided that headlines appear somewhere.

So that's clean.  This will happen in Leo 4.5. 
.. @+node:ekr.20080626081829.2: *4* Allow headline comments for @nosent files
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/eb718b4c6d478ac0

I'm just getting started learning how to use Leo. Now, I'd like to use
it for some of my projects, but there's no chance that I can convert
everyone at work to using it, so putting sentinel-filled files in our
repository is out of the question. At the same time, my code looks
awfully bare without sentinels because the documentation ends up in
the section names, not the comments!

So, I was wondering if there's a convenient way to pull the section
names into a comment at the start of each section?

===============

Interesting question.  Am I correct in assuming you are using @nosent trees
to generate your files?  If so, it would be easy to add support for the
following options:

@bool write_section_comments_in_at_nosent_trees
@bool write_node_name_comments_in_at_nosent_trees

The first would write a sentinel consisting of only the section name;
the second would write a sentinel consisting only of the node's headline
(for nodes whose headline is not a section name).

These seem like they would be useful additions.  One can even imagine
corresponding Leo directives so that the comments could be turned on or off
within an @nosent tree.

What do you think?

=====================

> Interesting question.  Am I correct in assuming you are using @nosent trees
> to generate your files?  If so, it would be easy to add support for the
> following options:

> @bool write_section_comments_in_at_nosent_trees
> @bool write_node_name_comments_in_at_nosent_trees

> The first would write a sentinel consisting of only the section name;
> the second would write a sentinel consisting only of the node's headline
> (for nodes whose headline is not a section name).

> These seem like they would be useful additions.  One can even imagine
> corresponding Leo directives so that the comments could be turned on or off
> within an @nosent tree.

That sounds like an excellent solution. Particularly the last bit --
if you could turn section-comments on and off as required, it would
become very convenient to use Leo to produce source that is intended
to also be read by non Leo users. 
.. @+node:ekr.20080922115725.1: *4* Finish @shadow
# Allow block comments in private shadow files.
# Compute delims using the private shadow file, not the file extension!
# Can @shadow mark externally changed nodes?
.. @+node:ekr.20081004102201.2: *5* Log file for @shadow
http://groups.google.com/group/leo-editor/browse_thread/thread/5e7bd3af2d1fbf51

How about a shadow.log file which Leo told what it thought of the relationship
between the node, file and shadow? It might provide useful clues.
.. @+node:ekr.20081001062423.1: *5* Can @shadow mark externally changed nodes?
http://groups.google.com/group/leo-editor/browse_thread/thread/c46eabe8a9fe6e8
.. @+node:ekr.20090402072059.13: *5* Create a general mechanism for aux (shadow, _db) files
http://groups.google.com/group/leo-editor/browse_thread/thread/4ec30df3f1db8db3

On Sat, Mar 28, 2009 at 3:24 AM, VR <viktor.ransmayr@gmail.com> wrote:


    When I tried to de-install Leo-4.6b1 I succeeded, but the program
    reported that 5 directories
    were not removed.

    Three of the directories where

    1) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\config
    2) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\doc
    3) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\plugins

    [containing]


    a) .leoSettings.leo_db
    b) .leoDocs.leo_db
    c) .leo_shadow
    d) .leoPluginsRef.leo_db


Thanks for this report. I think it is important, and needs a good solution.

I dislike all these files being sprayed around the file system. I'd like to see
these files placed somewhere the ~/.leo directory. Is there a reason why this
would be a bad idea?

Similarly, we might also prefer to have shadow files place in, say,
~/.leo/shadow_files.

In both cases, I think we want to create files that indicate their location.
Either that, or mirror their location in (subdirectories) ~/.leo. In other
words, this is a general problem, and it would be good to have a robust, general
solution.
.. @+node:ekr.20100826110728.5839: *5* Relocating .leo_shadow directories
2008

http://groups.google.com/group/leo-editor/browse_thread/thread/b738e3f8d164f9fc

May 10, 2010

Kent

I think there could be quite a bit of interest in moving
the shadow files to their own tree, avoiding what might
be considered 'pollution' of a tree of files in @shadow nodes.

Edward has said that this would add a lot of complexity to Leo.

It seems that a VCS back end for Leo might simplify the
task of arbitrary shadow file location, as well as adding
versioning capability.


Those of us old enough to remember the Groucho Marx show will know what I am ...

bogomil
 to me

In order to relocate .leo_shadow directories in home dir, I have made
the following changes leoShadow.py:
1. Introduce new setting 'shadow_in_home_dir':
   x.ctor:
     ...
     self.shadow_prefix = c.config.getString('shadow_prefix') or ''

=>  self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir')
or False
    ...

2. Make the following line:
   x.shadowDirName and shadowPathName:
      ...
      fileDir = g.os_path_dirname(filename)

=>   if self.shadow_in_home_dir:
        fileDir = "//".join([baseDir, fileDir.replace(':','%')])

In this way I keep .leo_shadow dirs in a tree and it is ok if the user
reorgs the original tree.

=====================
Edward K. Ream
 to bogomil

Thanks for these suggestions.  I'll try them soon.

A few minor comments about the code.

>  self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir') or False

This works (because c.config.getBool returns None if the setting does
not exist). Thus, the "or False" part merely replaces None by False.
I prefer the following:

self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir',default=False)

>   if self.shadow_in_home_dir:
>         fileDir = "//".join([baseDir, fileDir.replace(':','%')])

This looks like a Windows-only solution because of ':'.  It might fail
in strange ways on other platforms.
.. @+node:ekr.20111019104425.15895: *4* LeoFS (Kent)
- create a Leo implementation of pyfilesystem
http://packages.python.org/fs/implementersguide.html

.. @+node:ekr.20110613110911.16421: *4* Read/write files in json format
.. @+node:ekr.20111009230326.7037: *5* Leo-to-json script for IPython?
.. @+node:ekr.20110527084258.18378: *6* New file format
@nocolor-node

** remove window state, expansion status etc.
   stuff from .leo file, and move that over to c.db

- <attr> solves pickle problem.

* Treat gnx's as strings: don't parse them.
  http://mail.google.com/mail/#inbox/12f3d4950fbabeea
  
* Don't save expansion bits in uA if not saving expansion bits. It's illogical
  to save bits in uA's if they aren't save in in the <v> elements.
  
    @bool put_expansion_bits_in_leo_files = False

- Use uuid's?

- Remove spaces from user names.

.. @+node:ekr.20110609042343.16546: *7* Notes
.. @+node:ekr.20110609042343.16548: *8* File format, v3 draft 5
@language rest
@pagewidth 65

http://groups.google.com/group/leo-editor/browse_thread/thread/2ddb57c62e67825c

Leo's file format: version 3, draft 5

This draft is intended to reflect minimal changes from Leo's
present file format, but with improvements mentioned at the
Ashland sprint and developed afterward.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

This draft contains significant invention by EKR. See the next
section. Don't panic: it can be changed :-)

Summary of changes from draft 4
===============================

- Elements will be renamed as follows::

    old         new
    ====        ====
    <vnodes>    <directed-acyclic-graph>
    <tnodes>    <data-list>
    <v>         <node>
    <t>         <data>

- Nesting of <node> elements represents the structure of the DAG,
  just as nesting of <v> elements does at present.
  
- Thus, there will be no <edge> elements.

- Headlines will move from <v> elements to <data> elements.
  This "normalizes" the data: headlines will appear only once.
  
- <attr> elements will represent uA's.  A full discussion below.

  Ideally, I would like to support only string and json formats
  for <attr> elements.  This is open to discussion. 

- Only <node> elements will contain <attr> elements.

- <node> elements for @file nodes will contain
  <at-file-attributes> elements, representing Leo's "hidden
  machinery" attributes.  <at-file-attributes> will contain
  <attr> elements. 

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear within
<node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <directed-acyclic-graph>
        <node id="gnx">
            <!-- contained node elements, if any.
        </node>
        <node id="gnx">
            <!-- contained v elements, if any.
        </node>
        ...
    </directed-acyclic-graph>
    <data-list>
        <data id="gnx">
            <!-- marked attribute appears only if the tnode/vnode is marked -->
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </data>
        ...
    </data-list>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
The value will be a string by default.

If possible, I would like to support only the string and json
formats. This would make the data as transparent as possible.
Please mentally amend the following discussion...

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may optionally be contained in
the <node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
.. @+node:ekr.20110421132230.6107: *8* File format, v3 draft 4
@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in <attr> elements (and "type" in <edge> elements.)

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <at-file-attributes>
                <attr>key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx">value
                </attr>
                ...
            </at-file-attributes>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may be contained in the
<node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20110419083918.6104: *8* File format, v3 graphml
@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in <edge> elements if that
would be preferable.

Recent changes
==============

- Added <graphml> element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed <leo_file> to <leo:outline>
    - Renamed <descendant-attributes> to <leo:at-file-attributes>

- Used <leo:at-file-attributes> for marks, removing the special case.

- Enclosed <leo:descendant-attributes> in a (graphml) <data> element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <data>
                <leo:at-file-attributes>
                    <attr>key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx">value
                    </attr>
                    ...
                </leo:at-file-attributes>
            </data>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </graphml>
    </leo:outline>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <leo:at-file-attributes> element may be contained in the
<node> element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    <data>
        <leo:at-file-attributes>
            <attr>key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx">value
            </attr>
            ...
        </leo:at-file-attributes>
    </data>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20090218115025.3: *8* Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
.. @+node:ekr.20080919085541.3: *4* Use sqlite data base as an alternative representation for .leo files
http://groups.google.com/group/leo-editor/browse_thread/thread/dff0c165e2211691
.. @+node:ekr.20120515193246.10085: *3* Gui
.. @+node:ekr.20110929074744.15449: *4* generalize show/hide/select gui elements commands
@nocolor-node

tab-cycle-next makes the following not so important

There is a relationship here with mouseless
programming.  It would seem that all visual elements, especially those
that may exist in multiple versions, must have a name or other
description suitable for generalized commands.

The user might want multiple rendering panes, especially if
one or more are locked.  Without a description, there is no way to
specify exactly what show/hide-rendering pane does.

I haven't forgotten the autocompleter docs.  I'll get to them next.
It looks like autocompletion would be the way to generalize the not-
very-effect commands that switch focus from one ui element to
another.  A related benefit is one generalized command might be more
convenient to use than the present flavors of (buggy) cycle-focus
commands.

In short, contemplating generalized windows leads us to generalized
select/delete/show/hide commands, based on autocompletion, that work
on various ui elements.  This looks like the next project. 
.. @+node:ekr.20110929074744.15499: *4* Allow more panes to be part of the free_layout "action" buttons
.. @+node:ekr.20131121090013.17108: *4* Import pane, similar to the Find pane
Very important.

ActivePath is an alternative.  Has rclick interface.
.. @+node:ekr.20101104191857.5820: *4* QWebView makes Leo a presentation tool
http://groups.google.com/group/leo-editor/browse_thread/thread/4ea2d3f7d2c68106#

Ville:

Create one QWebView window, zoom it in to have large fonts.

Create @button that converts current node containing restructuredtext to html,
and pushes that html to QWebView.

Voila', instant presentation tool. The webview window would be on projector, and
leo would be in your private computer. You can easily edit the text, or find new
interesting slides to present in privacy of your own screen.

.. @+node:ekr.20111019104425.15888: *4* Support an openGL window in Leo
.. @+node:ekr.20111019104425.15892: *4* Buttons (Kent)
Enhance the button machinery to allow mixed case, spaces, colors.
Provide cascading rclick capability: rclick on an rclick list ...
.. @+node:ekr.20120604071051.10187: *4* Add multiple body editors to session machinery
# Terry will do this, or help with it.
.. @+node:ekr.20140824043305.18299: *4* zz Unlikely
.. @+node:ekr.20110620083705.14901: *5* Fix or disable curses gui
leoBridge.py requires the nullGui.
.. @+node:ekr.20111019104425.15887: *5* Host the PyQt demo inside Leo
.. @+node:ekr.20050509085713: *3* Installer (wishlist)
.. @+node:ekr.20070929125944: *4* Emulate Orange's download philosophy
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4543089
By: billp9619

from the download page:

If it's the first time you hear about Python, this is the installation for you.
The packages includes complete Orange, Python, Windows Extensions for Python
(PythonWin), Numeric Python, Qt 2.2 non-commercial, PyQt, PyQwt and GraphViz.

Leo should copy this download philosophy.



.. @+node:ekr.20130807203905.16773: *4* Leo for portableapps?
.. @+node:ekr.20140704052551.17950: *3* IPython
.. @+node:ekr.20121005105428.12866: *4* Ipython notebook stuff
.. @+node:ekr.20121005105428.10112: *5* ipynb example
{
  "metadata": {
    "name": "Part 2: Dataset Basics and Concepts"
  }, 
  "nbformat": 3, 
  "nbformat_minor": 0, 
  "worksheets": [
    {
      "cells": [
        {
          "cell_type": "heading", 
          "level": 1, 
          "metadata": {}, 
          "source": [
            "Part 2: Dataset Basics and Concepts"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Note*", 
            "\n\n", 
            "This tutorial part is also available for download as an ", 
            "[IPython notebook][IPython notebook]:\n[", 
            "[ipynb][ipynb]]", 
            "- - -\n"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "A ", 
            "[Dataset](http://pymvpa.org/generated/mvpa2.datasets.base.Dataset.html#mvpa2-datasets-base-dataset) is the basic data container in PyMVPA. It\nserves as the primary form of input data storage, but also as container for\nmore complex results returned by some algorithm. In this tutorial part we will\ntake a look at what a dataset consists of, and how it works.\n\n", 
            "In the simplest case, a dataset only contains ", 
            "*data* that is a matrix of\nnumerical values."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "from mvpa2.tutorial_suite import *\n", 
            "data = [[  1,  1, -1],\n        [  2,  0,  0],\n        [  3,  1,  1],\n        [  4,  0, -1]]\n", 
            "ds = Dataset(data)\n", 
            "ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In the above example, every row vector in the `data` matrix becomes an\nobservation or a ", 
            "[sample](http://pymvpa.org/glossary.html#term-sample) in the dataset, and every column vector\nrepresents an individual variable or a ", 
            "[feature](http://pymvpa.org/glossary.html#term-feature). The concepts of samples\nand features are essential for a dataset, hence we take a further, closer look.\n\n", 
            "The dataset assumes the first axis of the data to be the samples separating\ndimension. If the dataset is created using a one-dimensional vector it will\ntherefore have as many samples as elements in the vector, and only one feature."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "one_d = [ 0, 1, 2, 3 ]\n", 
            "one_ds = Dataset(one_d)\n", 
            "one_ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "On the other hand, if a dataset is created from multi-dimensional data, only its\nsecond axis represents the features"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "import numpy as np\n", 
            "m_ds = Dataset(np.random.random((3, 4, 2, 3)))\n", 
            "m_ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "m_ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In this case we have a dataset with three samples and four features, where each\nfeature is a 2x3 matrix. In case somebody is wondering now, why not simply each\nvalue in the data array is considered as its own feature (yielding 24 features)\n-- stay tuned, as this is going to be of importance later on."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Attributes"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "What we have seen so far does not really warrant the use of a dataset over a\nplain array or a matrix with samples. However, in the MVPA context we often need\nto know more about each samples than just the value of its features.  In the\nprevious tutorial part we have already seen that per-sample ", 
            "[target](http://pymvpa.org/glossary.html#term-target)\nvalues are required for supervised-learning algorithms, and that a dataset\noften has to be split based on the origin of specific groups of samples.  For\nthis type of auxiliary information a dataset can also contain collections of\nthree types of ", 
            "[attribute](http://pymvpa.org/glossary.html#term-attribute)s: ", 
            "[sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute), ", 
            "[feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute), and\n", 
            "[dataset attribute](http://pymvpa.org/glossary.html#term-dataset-attribute)."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For Samples"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In a dataset each ", 
            "[sample](http://pymvpa.org/glossary.html#term-sample) can have an arbitrary number of additional\nattributes. They are stored as vectors of the same length as the number of samples\nin a collection, and are accessible via the `sa` attribute. A collection is\nderived from a standard Python ", 
            "`dict`, and hence adding sample attributes\nworks identical to adding elements to a dictionary:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'] = [ 0., 1, 1, 3 ]\n", 
            "ds.sa.keys()"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "However, sample attributes are not directly stored as plain data, but for\nvarious reasons as a so-called ", 
            "[Collectable](http://pymvpa.org/generated/mvpa2.base.collections.Collectable.html#mvpa2-base-collections-collectable) that in\nturn embeds a NumPy array with the actual attribute:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "type(ds.sa['some_attr'])"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'].value"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "This \"complication\" is done to be able to extend attributes with additional\nfunctionality that is often needed and can offer significant speed-up of\nprocessing. For example, sample attributes carry a list of their unique values.\nThis list is only computed once (upon first request) and can subsequently be\naccessed directly without repeated and expensive searches:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'].unique"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "However, for most interactive uses of PyMVPA this type of access to attributes'\n`.value` is relatively cumbersome (too much typing), therefore collections offer direct\nattribute access by name:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Another purpose of the sample attribute collection is to preserve data\nintegrity, by disallowing improper attributes:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['invalid'] = 4"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['invalid'] = [ 1, 2, 3, 4, 5, 6 ]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "But other than basic plausibility checks no further constraints on values of\nsamples attributes exist. As long as the length of the attribute vector matches\nthe number of samples in the dataset, and the attributes values can be stored\nin a NumPy array, any value is allowed. For example, it is perfectly possible\nand supported to store literal attributes. It should also be noted that each\nattribute may have its own individual data type, hence it is possible to have\nliteral and numeric attributes in the same dataset."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['literal'] = ['one', 'two', 'three', 'four']\n", 
            "sorted(ds.sa.keys())"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "for attr in ds.sa:\n   print \"%s: %s\" % (attr, ds.sa[attr].value.dtype.name)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For Features"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "[Feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute)s are almost identical to ", 
            "[sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute)s the ", 
            "*only* difference is that instead of having one attribute value per\nsample, feature attributes have one value per (guess what? ...) ", 
            "*feature*.\nMoreover, they are stored in a separate collection in the datasets that is\ncalled `fa`:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.fa['my_fav'] = [0, 1, 0]\n", 
            "ds.fa['responsible'] = ['me', 'you', 'nobody']\n", 
            "sorted(ds.fa.keys())"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For The Dataset"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Finally, there can be also attributes, not per each sample, or each\nfeature, but for the dataset as a whole: so called ", 
            "[dataset](http://pymvpa.org/glossary.html#term-dataset)s. Assigning such attributes and accessing them later on work in\nexactly the same way as for the other two types of attributes, except that dataset\nattributes are stored in their own collection which is accessible via the\n`a` property of the dataset.  However, in contrast to sample and feature\nattribute no constraints on the type or size are imposed -- anything can be\nstored. Let's store a list with all files in the current directory, just\nbecause we can:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "from glob import glob\n", 
            "ds.a['pointless'] = glob(\"*\")\n", 
            "'setup.py' in ds.a.pointless"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Slicing, resampling, feature selection"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "At this point we can already construct a dataset from simple arrays and\nenrich it with an arbitrary number of additional attributes. But just\nhaving a dataset isn't enough. From part one of this tutorial we already\nknow that we need to be able to select subsets of a dataset for further\nprocessing, and we also know that this is possible with PyMVPA's datasets.\nNow it is time to have a closer look into how it works.\n\n", 
            "Slicing a dataset (i.e. selecting specific subsets) is very similar to\nslicing a NumPy array. It actually works ", 
            "*almost* identical. A dataset\nsupports Python's ", 
            "`slice` syntax, but also selection by boolean masks, and\nindices. The following three slicing operations\nresult in equivalent output datasets, by always selecting every other samples\nin the dataset:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[::2].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "mask = np.array([True, False, True, False])\n", 
            "ds[mask].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[[0, 2]].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Exercise*", 
            "\n\n", 
            "Search the `NumPy documentation`_ for the difference between \"basic slicing\"\nand \"advanced indexing\". Especially the aspect of memory consumption\napplies to dataset slicing as well, and being aware of this fact might\nhelp to write more efficient analysis scripts. Which of the three slicing\napproaches above is the most memory-efficient?  Which of the three slicing\napproaches above might lead to unexpected side-effects if output dataset\ngets modified?"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "# you can use this cell to for this exercise"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n", 
            "\n\n", 
            "All three slicing-styles are equally applicable to the selection of feature\nsubsets within a dataset. Remember, features are represented on the second axis\nof a dataset."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[:, [1,2]].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "By applying a selection by indices to the second axis, we can easily get\nthe last two features of our example dataset. Please note the ", 
            "`:` is supplied\nas first axis slicing. This is the Python way to indicate ", 
            "*take everything\nalong this axis*, hence including all samples.\n\n", 
            "As you can guess, it is also possible to select subsets of samples and\nfeatures at the same time."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "subds = ds[[0,1], [0,2]]\n", 
            "subds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "If you have prior experience with NumPy you might be confused now. What you\nmight have expected is this:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples[[0,1], [0,2]]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "The above code applies the same slicing directly to the NumPy array with\nthe samples, and the result is fundamentally different. For NumPy arrays\nthis style of slicing allows to select specific elements by their indices on\neach axis of an array. For PyMVPA's datasets this mode is not very useful,\ninstead we typically want to select rows and columns, i.e. samples and\nfeatures given by their indices."
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Exercise*", 
            "\n\n", 
            "Try to select samples [0,1] and features [0,2,3] simultaneously using\ndataset slicing.  Now apply the same slicing to the samples array itself\n(`ds.samples`) -- make sure that the result doesn't surprise you and find\na pure NumPy way to achieve similar selection."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "# you can use this cell to for this exercise"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n", 
            "\n\n", 
            "One last interesting thing to look at, in the context of dataset slicing\nare the attributes. What happens to them when a subset of samples and/or\nfeatures is chosen? Our original dataset had both samples and feature attributes:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.fa.responsible"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Now let's look at what they became in the subset-dataset we previously\ncreated:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print subds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print subds.fa.responsible"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We see that both attributes are still there and, moreover, also the\nappropriate subsets have been selected."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Loading fMRI data"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Enough of theoretical foreplay -- let's look at a concrete example of an\nfMRI dataset. PyMVPA has several helper functions to load data from\nspecialized formats, and the one for fMRI data is\n", 
            "[fmri_dataset()](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset). The example dataset we are going to\nlook at is a single subject from Haxby et al. (2001) that we already\nloaded in part one of this tutorial. For more convenience, and less typing\nwe first specify the path of the directory with the fMRI data."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "path=os.path.join(tutorial_data_path, 'data')"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In the simplest case, we now let ", 
            "[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) do its job, by just\npointing it to the fMRI data file. The data is stored as a NIfTI file that has\nall runs of the experiment concatenated into a single file."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'))\n", 
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We can notice two things. First, it worked! Second, we get a\ntwo-dimensional dataset with 1452 samples (these are volumes in the NIfTI\nfile), and over 160k features (these are voxels in the volume). The voxels\nare represented as a one-dimensional vector, and it seems that they have\nlost their association with the 3D-voxel-space. However, this is not the\ncase, as we will see in the next chapter.  PyMVPA represents\ndata in this simple format to make it compatible with a vast range of generic\nalgorithms that expect data to be a simple matrix.\n\n", 
            "We just loaded all data from that NIfTI file, but usually we would be\ninterested in a subset only, i.e. \"brain voxels\".\n", 
            "[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) is capable of performing data masking. We just need to\nspecify a mask image. Such mask image is generated in pretty much any fMRI\nanalysis pipeline -- may it be a full-brain mask computed during\nskull-stripping, or an activation map from a functional localizer. We are going\nto use the original GLM-based localizer mask of ventral temporal cortex\nfrom Haxby et al. (2001). We already know that it comprises 577 voxels.\nLet's reload the dataset:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'),\n                  mask=os.path.join(path, 'mask_vt.nii.gz'))\n", 
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "As expected, we get the same number of samples and also only 577 features\n-- voxels corresponding to non-zero elements in the mask image. Now, let's\nexplore this dataset a little further.\n\n", 
            "Besides samples the dataset offers number of attributes that enhance the\ndata with information that is present in the NIfTI image header in the file. Each sample has\ninformation about its volume ID in the time series and the actual acquisition\ntime (relative to the beginning of the file). Moreover, the original voxel\nindex (sometimes referred to as `ijk`) for each feature is available too.\nFinally, the dataset also contains information about the dimensionality\nof the input volumes, voxel size, and any other NIfTI-specific information\nsince it also includes a dump of the full NIfTI image header."
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Note*", 
            "\n\n", 
            "Previously (0.4.x versions and 0.5 development prior March 03, 2010),\nPyMVPA exposed 4D (and 3D with degenerate 1st dimension) data in `tkji`\n(corresponds to `tzyx` if volumes were axial slices in\nneurologic convention) order of dimensions.  Now it uses more convenient\norder `tijk` (corresponding to `txyz`), which will match the order exposed\nby NiBabel (PyNIfTI and NiftiImage still expose them as `tkji`).", 
            "- - -\n"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.time_indices[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.time_coords[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.fa.voxel_indices[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.a.voxel_eldim"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.a.voxel_dim"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "'imghdr' in ds.a"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In addition to all this information, the dataset also carries a key\nattribute: the ", 
            "*mapper*. A mapper is an important concept in PyMVPA, and\nhence worth devoting the whole ", 
            "*next tutorial chapter* to it."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.a.mapper"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Having all these attributes being part of a dataset is often a useful thing\nto have, but in some cases (e.g. when it comes to efficiency, and/or very\nlarge datasets) one might want to have a leaner dataset with just the\ninformation that is really necessary. One way to achieve this, is to strip\nall unwanted attributes. The Dataset class'\n", 
            "[AttrDataset.copy()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.copy) method can help with that."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "stripped = ds.copy(deep=False, sa=['time_coords'], fa=[], a=[])\n", 
            "print stripped"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We can see that all attributes besides `time_coords` have been filtered out.\nSetting the `deep` arguments to `False` causes the copy function to reuse the\ndata from the source dataset to generate the new stripped one, without\nduplicating all data in memory -- meaning both datasets now share the sample\ndata and any change done to `ds` will also affect `stripped`."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Storage"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Some data preprocessing can take a long time.  One would rather prevent\ndoing it over and over again, and instead just store the preprocessed data\ninto a file for subsequent analyses. PyMVPA offers functionality to store a\nlarge variety of objects, including datasets, into ", 
            "[HDF5][HDF5] files. A variant\nof this format is also used by recent versions of Matlab to store data.\n\n", 
            "For HDF5 support PyMVPA depends on the ", 
            "[h5py][h5py] package. If it is available,\nany dataset can be saved to a file by simply calling\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) with the desired filename."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "import tempfile, shutil\n", 
            "tempdir = tempfile.mkdtemp()\n", 
            "ds.save(os.path.join(tempdir, 'mydataset.hdf5'))"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "HDF5 is a flexible format that also supports, for example, data\ncompression. To enable it, you can pass additional arguments to\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) that are supported by\n", 
            "`Group.create_dataset()`. Instead of using\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) one can also use the ", 
            "[h5save()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5save.html#mvpa2-base-hdf5-h5save)\nfunction in a similar way. Saving the same dataset with maximum\ngzip-compression looks like this:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), compression=9)\n", 
            "h5save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), ds, compression=9)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Loading datasets from a file is easy too. ", 
            "[h5load()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5load.html#mvpa2-base-hdf5-h5load) takes a filename as\nan argument and returns the stored dataset. Compressed data will be handled\ntransparently."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "loaded = h5load(os.path.join(tempdir, 'mydataset.hdf5'))\n", 
            "np.all(ds.samples == loaded.samples)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "shutil.rmtree(tempdir, ignore_errors=True)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }
      ], 
      "metadata": {}
    }
  ]
}
.. @+node:ekr.20121005105428.10095: *5* << ipynb example >>
# s = '["foo", {"bar":["baz", null, 1.0, 2]}]'

s = '''
{
  "metadata": {
    "name": "Part 2: Dataset Basics and Concepts"
  }, 
  "nbformat": 3, 
  "nbformat_minor": 0, 
  "worksheets": [
    {
      "cells": [
        {
          "cell_type": "heading", 
          "level": 1, 
          "metadata": {}, 
          "source": [
            "Part 2: Dataset Basics and Concepts"
          ]
        }
      ]
    }
  ]
}
'''

s2 = '''
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Note*", 
            "\n\n", 
            "This tutorial part is also available for download as an ", 
            "[IPython notebook][IPython notebook]:\n[", 
            "[ipynb][ipynb]]", 
            "- - -\n"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "A ", 
            "[Dataset](http://pymvpa.org/generated/mvpa2.datasets.base.Dataset.html#mvpa2-datasets-base-dataset) is the basic data container in PyMVPA. It\nserves as the primary form of input data storage, but also as container for\nmore complex results returned by some algorithm. In this tutorial part we will\ntake a look at what a dataset consists of, and how it works.\n\n", 
            "In the simplest case, a dataset only contains ", 
            "*data* that is a matrix of\nnumerical values."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "from mvpa2.tutorial_suite import *\n", 
            "data = [[  1,  1, -1],\n        [  2,  0,  0],\n        [  3,  1,  1],\n        [  4,  0, -1]]\n", 
            "ds = Dataset(data)\n", 
            "ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In the above example, every row vector in the `data` matrix becomes an\nobservation or a ", 
            "[sample](http://pymvpa.org/glossary.html#term-sample) in the dataset, and every column vector\nrepresents an individual variable or a ", 
            "[feature](http://pymvpa.org/glossary.html#term-feature). The concepts of samples\nand features are essential for a dataset, hence we take a further, closer look.\n\n", 
            "The dataset assumes the first axis of the data to be the samples separating\ndimension. If the dataset is created using a one-dimensional vector it will\ntherefore have as many samples as elements in the vector, and only one feature."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "one_d = [ 0, 1, 2, 3 ]\n", 
            "one_ds = Dataset(one_d)\n", 
            "one_ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "On the other hand, if a dataset is created from multi-dimensional data, only its\nsecond axis represents the features"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "import numpy as np\n", 
            "m_ds = Dataset(np.random.random((3, 4, 2, 3)))\n", 
            "m_ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "m_ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In this case we have a dataset with three samples and four features, where each\nfeature is a 2x3 matrix. In case somebody is wondering now, why not simply each\nvalue in the data array is considered as its own feature (yielding 24 features)\n-- stay tuned, as this is going to be of importance later on."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Attributes"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "What we have seen so far does not really warrant the use of a dataset over a\nplain array or a matrix with samples. However, in the MVPA context we often need\nto know more about each samples than just the value of its features.  In the\nprevious tutorial part we have already seen that per-sample ", 
            "[target](http://pymvpa.org/glossary.html#term-target)\nvalues are required for supervised-learning algorithms, and that a dataset\noften has to be split based on the origin of specific groups of samples.  For\nthis type of auxiliary information a dataset can also contain collections of\nthree types of ", 
            "[attribute](http://pymvpa.org/glossary.html#term-attribute)s: ", 
            "[sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute), ", 
            "[feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute), and\n", 
            "[dataset attribute](http://pymvpa.org/glossary.html#term-dataset-attribute)."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For Samples"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In a dataset each ", 
            "[sample](http://pymvpa.org/glossary.html#term-sample) can have an arbitrary number of additional\nattributes. They are stored as vectors of the same length as the number of samples\nin a collection, and are accessible via the `sa` attribute. A collection is\nderived from a standard Python ", 
            "`dict`, and hence adding sample attributes\nworks identical to adding elements to a dictionary:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'] = [ 0., 1, 1, 3 ]\n", 
            "ds.sa.keys()"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "However, sample attributes are not directly stored as plain data, but for\nvarious reasons as a so-called ", 
            "[Collectable](http://pymvpa.org/generated/mvpa2.base.collections.Collectable.html#mvpa2-base-collections-collectable) that in\nturn embeds a NumPy array with the actual attribute:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "type(ds.sa['some_attr'])"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'].value"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "This \"complication\" is done to be able to extend attributes with additional\nfunctionality that is often needed and can offer significant speed-up of\nprocessing. For example, sample attributes carry a list of their unique values.\nThis list is only computed once (upon first request) and can subsequently be\naccessed directly without repeated and expensive searches:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'].unique"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "However, for most interactive uses of PyMVPA this type of access to attributes'\n`.value` is relatively cumbersome (too much typing), therefore collections offer direct\nattribute access by name:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Another purpose of the sample attribute collection is to preserve data\nintegrity, by disallowing improper attributes:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['invalid'] = 4"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['invalid'] = [ 1, 2, 3, 4, 5, 6 ]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "But other than basic plausibility checks no further constraints on values of\nsamples attributes exist. As long as the length of the attribute vector matches\nthe number of samples in the dataset, and the attributes values can be stored\nin a NumPy array, any value is allowed. For example, it is perfectly possible\nand supported to store literal attributes. It should also be noted that each\nattribute may have its own individual data type, hence it is possible to have\nliteral and numeric attributes in the same dataset."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['literal'] = ['one', 'two', 'three', 'four']\n", 
            "sorted(ds.sa.keys())"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "for attr in ds.sa:\n   print \"%s: %s\" % (attr, ds.sa[attr].value.dtype.name)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For Features"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "[Feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute)s are almost identical to ", 
            "[sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute)s the ", 
            "*only* difference is that instead of having one attribute value per\nsample, feature attributes have one value per (guess what? ...) ", 
            "*feature*.\nMoreover, they are stored in a separate collection in the datasets that is\ncalled `fa`:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.fa['my_fav'] = [0, 1, 0]\n", 
            "ds.fa['responsible'] = ['me', 'you', 'nobody']\n", 
            "sorted(ds.fa.keys())"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For The Dataset"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Finally, there can be also attributes, not per each sample, or each\nfeature, but for the dataset as a whole: so called ", 
            "[dataset](http://pymvpa.org/glossary.html#term-dataset)s. Assigning such attributes and accessing them later on work in\nexactly the same way as for the other two types of attributes, except that dataset\nattributes are stored in their own collection which is accessible via the\n`a` property of the dataset.  However, in contrast to sample and feature\nattribute no constraints on the type or size are imposed -- anything can be\nstored. Let's store a list with all files in the current directory, just\nbecause we can:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "from glob import glob\n", 
            "ds.a['pointless'] = glob(\"*\")\n", 
            "'setup.py' in ds.a.pointless"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Slicing, resampling, feature selection"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "At this point we can already construct a dataset from simple arrays and\nenrich it with an arbitrary number of additional attributes. But just\nhaving a dataset isn't enough. From part one of this tutorial we already\nknow that we need to be able to select subsets of a dataset for further\nprocessing, and we also know that this is possible with PyMVPA's datasets.\nNow it is time to have a closer look into how it works.\n\n", 
            "Slicing a dataset (i.e. selecting specific subsets) is very similar to\nslicing a NumPy array. It actually works ", 
            "*almost* identical. A dataset\nsupports Python's ", 
            "`slice` syntax, but also selection by boolean masks, and\nindices. The following three slicing operations\nresult in equivalent output datasets, by always selecting every other samples\nin the dataset:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[::2].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "mask = np.array([True, False, True, False])\n", 
            "ds[mask].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[[0, 2]].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Exercise*", 
            "\n\n", 
            "Search the `NumPy documentation`_ for the difference between \"basic slicing\"\nand \"advanced indexing\". Especially the aspect of memory consumption\napplies to dataset slicing as well, and being aware of this fact might\nhelp to write more efficient analysis scripts. Which of the three slicing\napproaches above is the most memory-efficient?  Which of the three slicing\napproaches above might lead to unexpected side-effects if output dataset\ngets modified?"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "# you can use this cell to for this exercise"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n", 
            "\n\n", 
            "All three slicing-styles are equally applicable to the selection of feature\nsubsets within a dataset. Remember, features are represented on the second axis\nof a dataset."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[:, [1,2]].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "By applying a selection by indices to the second axis, we can easily get\nthe last two features of our example dataset. Please note the ", 
            "`:` is supplied\nas first axis slicing. This is the Python way to indicate ", 
            "*take everything\nalong this axis*, hence including all samples.\n\n", 
            "As you can guess, it is also possible to select subsets of samples and\nfeatures at the same time."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "subds = ds[[0,1], [0,2]]\n", 
            "subds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "If you have prior experience with NumPy you might be confused now. What you\nmight have expected is this:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples[[0,1], [0,2]]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "The above code applies the same slicing directly to the NumPy array with\nthe samples, and the result is fundamentally different. For NumPy arrays\nthis style of slicing allows to select specific elements by their indices on\neach axis of an array. For PyMVPA's datasets this mode is not very useful,\ninstead we typically want to select rows and columns, i.e. samples and\nfeatures given by their indices."
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Exercise*", 
            "\n\n", 
            "Try to select samples [0,1] and features [0,2,3] simultaneously using\ndataset slicing.  Now apply the same slicing to the samples array itself\n(`ds.samples`) -- make sure that the result doesn't surprise you and find\na pure NumPy way to achieve similar selection."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "# you can use this cell to for this exercise"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n", 
            "\n\n", 
            "One last interesting thing to look at, in the context of dataset slicing\nare the attributes. What happens to them when a subset of samples and/or\nfeatures is chosen? Our original dataset had both samples and feature attributes:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.fa.responsible"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Now let's look at what they became in the subset-dataset we previously\ncreated:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print subds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print subds.fa.responsible"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We see that both attributes are still there and, moreover, also the\nappropriate subsets have been selected."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Loading fMRI data"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Enough of theoretical foreplay -- let's look at a concrete example of an\nfMRI dataset. PyMVPA has several helper functions to load data from\nspecialized formats, and the one for fMRI data is\n", 
            "[fmri_dataset()](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset). The example dataset we are going to\nlook at is a single subject from Haxby et al. (2001) that we already\nloaded in part one of this tutorial. For more convenience, and less typing\nwe first specify the path of the directory with the fMRI data."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "path=os.path.join(tutorial_data_path, 'data')"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In the simplest case, we now let ", 
            "[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) do its job, by just\npointing it to the fMRI data file. The data is stored as a NIfTI file that has\nall runs of the experiment concatenated into a single file."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'))\n", 
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We can notice two things. First, it worked! Second, we get a\ntwo-dimensional dataset with 1452 samples (these are volumes in the NIfTI\nfile), and over 160k features (these are voxels in the volume). The voxels\nare represented as a one-dimensional vector, and it seems that they have\nlost their association with the 3D-voxel-space. However, this is not the\ncase, as we will see in the next chapter.  PyMVPA represents\ndata in this simple format to make it compatible with a vast range of generic\nalgorithms that expect data to be a simple matrix.\n\n", 
            "We just loaded all data from that NIfTI file, but usually we would be\ninterested in a subset only, i.e. \"brain voxels\".\n", 
            "[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) is capable of performing data masking. We just need to\nspecify a mask image. Such mask image is generated in pretty much any fMRI\nanalysis pipeline -- may it be a full-brain mask computed during\nskull-stripping, or an activation map from a functional localizer. We are going\nto use the original GLM-based localizer mask of ventral temporal cortex\nfrom Haxby et al. (2001). We already know that it comprises 577 voxels.\nLet's reload the dataset:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'),\n                  mask=os.path.join(path, 'mask_vt.nii.gz'))\n", 
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "As expected, we get the same number of samples and also only 577 features\n-- voxels corresponding to non-zero elements in the mask image. Now, let's\nexplore this dataset a little further.\n\n", 
            "Besides samples the dataset offers number of attributes that enhance the\ndata with information that is present in the NIfTI image header in the file. Each sample has\ninformation about its volume ID in the time series and the actual acquisition\ntime (relative to the beginning of the file). Moreover, the original voxel\nindex (sometimes referred to as `ijk`) for each feature is available too.\nFinally, the dataset also contains information about the dimensionality\nof the input volumes, voxel size, and any other NIfTI-specific information\nsince it also includes a dump of the full NIfTI image header."
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Note*", 
            "\n\n", 
            "Previously (0.4.x versions and 0.5 development prior March 03, 2010),\nPyMVPA exposed 4D (and 3D with degenerate 1st dimension) data in `tkji`\n(corresponds to `tzyx` if volumes were axial slices in\nneurologic convention) order of dimensions.  Now it uses more convenient\norder `tijk` (corresponding to `txyz`), which will match the order exposed\nby NiBabel (PyNIfTI and NiftiImage still expose them as `tkji`).", 
            "- - -\n"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.time_indices[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.time_coords[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.fa.voxel_indices[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.a.voxel_eldim"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.a.voxel_dim"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "'imghdr' in ds.a"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In addition to all this information, the dataset also carries a key\nattribute: the ", 
            "*mapper*. A mapper is an important concept in PyMVPA, and\nhence worth devoting the whole ", 
            "*next tutorial chapter* to it."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.a.mapper"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Having all these attributes being part of a dataset is often a useful thing\nto have, but in some cases (e.g. when it comes to efficiency, and/or very\nlarge datasets) one might want to have a leaner dataset with just the\ninformation that is really necessary. One way to achieve this, is to strip\nall unwanted attributes. The Dataset class'\n", 
            "[AttrDataset.copy()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.copy) method can help with that."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "stripped = ds.copy(deep=False, sa=['time_coords'], fa=[], a=[])\n", 
            "print stripped"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We can see that all attributes besides `time_coords` have been filtered out.\nSetting the `deep` arguments to `False` causes the copy function to reuse the\ndata from the source dataset to generate the new stripped one, without\nduplicating all data in memory -- meaning both datasets now share the sample\ndata and any change done to `ds` will also affect `stripped`."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Storage"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Some data preprocessing can take a long time.  One would rather prevent\ndoing it over and over again, and instead just store the preprocessed data\ninto a file for subsequent analyses. PyMVPA offers functionality to store a\nlarge variety of objects, including datasets, into ", 
            "[HDF5][HDF5] files. A variant\nof this format is also used by recent versions of Matlab to store data.\n\n", 
            "For HDF5 support PyMVPA depends on the ", 
            "[h5py][h5py] package. If it is available,\nany dataset can be saved to a file by simply calling\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) with the desired filename."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "import tempfile, shutil\n", 
            "tempdir = tempfile.mkdtemp()\n", 
            "ds.save(os.path.join(tempdir, 'mydataset.hdf5'))"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "HDF5 is a flexible format that also supports, for example, data\ncompression. To enable it, you can pass additional arguments to\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) that are supported by\n", 
            "`Group.create_dataset()`. Instead of using\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) one can also use the ", 
            "[h5save()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5save.html#mvpa2-base-hdf5-h5save)\nfunction in a similar way. Saving the same dataset with maximum\ngzip-compression looks like this:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), compression=9)\n", 
            "h5save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), ds, compression=9)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Loading datasets from a file is easy too. ", 
            "[h5load()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5load.html#mvpa2-base-hdf5-h5load) takes a filename as\nan argument and returns the stored dataset. Compressed data will be handled\ntransparently."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "loaded = h5load(os.path.join(tempdir, 'mydataset.hdf5'))\n", 
            "np.all(ds.samples == loaded.samples)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "shutil.rmtree(tempdir, ignore_errors=True)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }
      ], 
      "metadata": {}
    }
  ]
}
'''
.. @+node:ekr.20121005105428.10109: *5* JSON Reference
if 0:
    @others
.. @+node:ekr.20121005105428.10102: *6* class NoteBookReader
class NotebookReader(object): # From rwbase.py
    """A class for reading notebooks."""

    def reads(self, s, **kwargs):
        """Read a notebook from a string."""
        raise NotImplementedError("loads must be implemented in a subclass")

    def read(self, fp, **kwargs):
        """Read a notebook from a file like object"""
        nbs = fp.read()
        if not py3compat.PY3 and not isinstance(nbs, unicode):
            nbs = py3compat.str_to_unicode(nbs)
        return self.reads(nbs, **kwargs)
.. @+node:ekr.20121005105428.10108: *6* JSONReader(NotebookReader)
class JSONReader(NotebookReader):

    def reads(self, s, **kwargs):
        nb = json.loads(s, **kwargs)
        nb = self.to_notebook(nb, **kwargs)
        return nb

    def to_notebook(self, d, **kwargs):
        return restore_bytes(
            rejoin_lines(from_dict(d))) # from_dict and rejoin_lines are in nbbase.
.. @+node:ekr.20121005105428.10107: *6* class BytesEncoder
class BytesEncoder(json.JSONEncoder):
    """A JSON encoder that accepts b64 (and other *ascii*) bytestrings."""
    def default(self, obj):
        if isinstance(obj, bytes):
            return obj.decode('ascii')
        return json.JSONEncoder.default(self, obj)

.. @+node:ekr.20121005105428.10097: *6* From v3/nbjson.py
_reader = JSONReader()
reads = _reader.reads
read =  _reader.read
to_notebook = _reader.to_notebook
.. @+node:ekr.20121005105428.10098: *6* From v3/rwbase.py
.. @+node:ekr.20121005105428.10103: *7* fromDict
def from_dict(d):
    if isinstance(d, dict):
        newd = NotebookNode()
        for k,v in d.items():
            newd[k] = from_dict(v)
        return newd
    elif isinstance(d, (tuple, list)):
        return [from_dict(i) for i in d]
    else:
        return d
.. @+node:ekr.20121005105428.10104: *7* restore_bytes
def restore_bytes(nb):
    """Restore bytes of image data from unicode-only formats.
    
    Base64 encoding is handled elsewhere.  Bytes objects in the notebook are
    always b64-encoded. We DO NOT encode/decode around file formats.
    """
    for ws in nb.worksheets:
        for cell in ws.cells:
            if cell.cell_type == 'code':
                for output in cell.outputs:
                    if 'png' in output:
                        output.png = str_to_bytes(output.png, 'ascii')
                    if 'jpeg' in output:
                        output.jpeg = str_to_bytes(output.jpeg, 'ascii')
    return nb
.. @+node:ekr.20121005105428.10105: *7* _join_lines
def _join_lines(lines):
    """join lines that have been written by splitlines()
    
    Has logic to protect against `splitlines()`, which
    should have been `splitlines(True)`
    """
    if lines and lines[0].endswith(('\n', '\r')):
        # created by splitlines(True)
        return u''.join(lines)
    else:
        # created by splitlines()
        return u'\n'.join(lines)
.. @+node:ekr.20121005105428.10106: *7* rejoin_lines
def rejoin_lines(nb):
    """rejoin multiline text into strings
    
    For reversing effects of ``split_lines(nb)``.
    
    This only rejoins lines that have been split, so if text objects were not split
    they will pass through unchanged.
    
    Used when reading JSON files that may have been passed through split_lines.
    """
    for ws in nb.worksheets:
        for cell in ws.cells:
            if cell.cell_type == 'code':
                if 'input' in cell and isinstance(cell.input, list):
                    cell.input = _join_lines(cell.input)
                for output in cell.outputs:
                    for key in _multiline_outputs:
                        item = output.get(key, None)
                        if isinstance(item, list):
                            output[key] = _join_lines(item)
            else: # text, heading cell
                for key in ['source', 'rendered']:
                    item = cell.get(key, None)
                    if isinstance(item, list):
                        cell[key] = _join_lines(item)
    return nb
.. @+node:ekr.20121008100945.10295: *5* Installation notes for ipython 0.13
@nocolor-node

- Downloaded and ran ipython-0.13.py2-win32.exe
- Uninstalled several older IPython's using the Windows Control Panel

Linux
=====

- Installed pip: sudo apt-get install python-pip
- distribute was already installed in python2.7
- Installed curl: sudo apt-get install curl.
- Upgraded ipython: easy_install ipython[zmq,qtconsole,notebook,test] ipython==0.13
- Tested Ipython: iptest  Works!!!  not available:  oct2py rpy2
- removed home/.ipython/ipythonrc this removed the warnings on startup.

Windows:
========

- Download c:\apps\distribute_setup.py.
- python26 distribute_setup.py
- Removed all former versions of Enthought and ActiveState Python and IPython.
.. @+node:ekr.20130806072439.21299: *4* Leo and IPython
From: Kent Tenney <ktenney@gmail.com>

The ipython integration is great, any chance of connecting the the web notebook?

# ipython notebook

then, from the ipython dashboard in browser, click to open a notebook

the console reports:
[IPKernelApp] To connect another client to this kernel, use:
[IPKernelApp] --existing kernel-a25b19a2-55d6-43a2-aa05-dfeffb55136b.json

could <ctl-x> push-to-ipython send the contents of current Leo node
to the current cell in the ipython notebook?

It would be great to be able to jump between Leo's nodes and IPython's
cells, each offering a different set of cool functionality.

===== From: Alia K <alia_khouri@yahoo.com>

Incidentally look at this recent IPEP (Ipython Enhancement Proposal)
which allows for leo like cell-level directives (which in Ipython are
called magic commands): https://github.com/ipython/ipython/issues/1611

Leo + Ipython notebook integration is a killer app indeed.
.. @+node:ekr.20130803125244.17100: *3* Marketing
.. @+node:ekr.20131121211048.16378: *4* * More screenshots!
Different font sizes, coloring schemes, plugins, etc.
.. @+node:ekr.20131101080215.16488: *4* * Outreach to magazine editors
===== Steve Litt

I think the first step in getting this kind of review is to get more
fans who can write and who are listened to. To do that, you'd need to
give them enough of a burning desire to spend a few days learning the
ins and outs of Leo. I'll give you an idea how to do this later in this
email.

But first, I think Leo has an image problem. Mention Leo, and most
people say "it's an outliner." If that's all Leo was, VimOutliner would
have eaten Leo's lunch years ago --- VimOutliner's faster and has the
90% of outlining features that people use 90% of the time. Not only
that, face the facts, 95% of the population will never believe they
need an outliner or that an outliner would do them any good, or that
outlining is a skill they need to bother to acquire.

My understanding, and please correct me if I'm wrong, is that Leo is a
mechanism by which you can specify a computer program as an outline
like thing in an outliner like setting, flip a switch, and bang, there's
your program. THAT'S what's going to hook people.

So here's what to do. Make a 3 minute video showing how to compose an
application outline and turn it into a program. The program can be
trivially simple, but make the program as 2014 relevant as possible: A
web app would be nice. At the end of the video explain that although
this video's program was simple, Leo can be used to make arbitrarily
complex apps, and make them well.

Maybe have a second video showing how to make a GUI app. Maybe a 3rd
showing how to write a book in Leo, flip a switch, and have it be a
book, flip it back, and see your book as an outline again, ready for
changes, either minor, or structurally major.

Publicize these videos, and you're going to get some journalists
excited, and those are your reviews.

One more thing: Start publicizing different ways people use Leo.
Encourage them to write in with their unique uses, and publicize them.
I bet people are doing things with Leo you never dreamed of, and some
of those things might be the itch some journalist wants to scratch.
.. @+node:ekr.20130909111702.13058: *4* Allow paypal donations to Leo
.. @+node:ekr.20130503155210.24814: *4* Tutorials/Screencasts (revise)
@nocolor-node

Rewrite in screencast-script style:
- Docstrings for the most important plugins.
- All help-for-<topic> text.
- Leo's tutorials.

** Screencast style for plugins docstrings.
* Screencast style for help messages.
* Screencast style for tutorials.
* Create YouTube channel for Leo screencasts.

Topics:
- Minibuffer: alt-x, tab-completion.
- @button.
- @rclick
- Find/Change (done)
- execute-script.
- bookmarks.py.

.. @+node:ekr.20131213072223.16397: *4* Video tutorials (revise)
@language rest

Are any more needed?

When ready to release:

- Note to Dave Winer.
- Announce to comp.lang.python & SourceForge.
.. @+node:ekr.20131221065129.16519: *5* - Basic: Basic operations
@language rest
.. @+node:ekr.20131221065129.16522: *6* Basic focus operations
The presently selected pane has a blue border.
We say that the selected pane **has focus**.

Regardless of what pane has focus:

- Alt-T puts selects the outline pane.
- Alt-D puts selects the body pane.
- Alt-Arrow key select another outline node
  and put focus in the outline pane.

A handy shortcut:

- When the outline pane has focus,
  the Return puts focus in the body pane.
.. @+node:ekr.20131221065129.16524: *6* Basic outline operations
Ctrl-N creates a new file.
Ctrl-S saves the file.

When focus is in the outline pane:

- The Insert key inserts a new node.
  Type the headline text followed by Return.
- The Delete key or the BackSpace key deletes a node.
- Plain Arrow keys select nodes.
- Shift-Arrow keys move nodes.

The following commands work regardless of focus.


- Ctrl-I inserts a new node.
- Ctrl-H edits the headline of the selected node.
- Ctrl-Shift-X deletes (cuts) the node.
  (Ctrl-Shift-C copies the selected node)
- Ctrl-Shift-V copies a previously copied or cut node.
- Alt-Arrow keys select nodes, as in Windows explorer.
- Alt-Shift-Arrow keys move nodes.
- Ctrl-U, Ctrl-D, Ctrl-L and Ctrl-R move nodes up, down, left and right.
- Ctrl-Z undoes the last operation. 
  Ctrl-Shift-Z redoes the last operation.
.. @+node:ekr.20131221065129.16520: *6* Basic text operations
- Return inserts a newline.
- Arrow keys move the cursor by characters.
- Ctrl-Arrow keys move the cursor by words.
- Home and End move the cursor to the start/end of a line.
- PageUp and Page-Down move the cursor by pages.
- Ctrl-Home and Ctrl-End move the cursor to the start/end of the body text.

- Adding the Shift modifier to any of these keys extends the selection:

- Shift Arrow keys.
- Shift-Ctrl-Arrow keys.
- Shift-PageUp and Shift-PageDown.
- Shift-Home and Shift-End.
- Shift-Ctrl-Home and Shift-Ctrl-End.
.. @+node:ekr.20131208103040.16342: *5* - Basic: Settings
- focus on visual settings.
@menu
leo-x-pt.leo files.
- Small test .leo files: useful for settings.
.. @+node:ekr.20131121050226.16328: *6* settings vid
open leoSettings.leo.
open myLeoSettings.leo.

Concentrate on:
    - visual settings.
    - keyboard shortcuts.

print-settings, print-bindings, print-commands.

Trick: use small, easily/quickly started, file to test settings.
    Demo: put console *behind* window.
.. @+node:ekr.20131211054925.16380: *5* - Basic: Creating external files
Using Leo *is* easy.

The rule (of thumb) that helper methods should be children of the method
that calls them instantly reveals that programs are outlines in disguise.
Once you have a way of seeing that fact *at all times*, one can never go
back to the flat, myopic way of seeing. It's really that simple.

And finally, there is @others. I created it within the first hour of
prototyping Leo in the MORE outliner. It has remained unchanged all these
years because it is, fundamentally, a very simple idea.

.. @+node:ekr.20131208103040.16343: *5* - Basic: Getting help
.. @+node:ekr.20131208103040.16349: *5* - Intermediate: Importing files
recursive import.  Where is it?
active-path plugin, 
.. @+node:ekr.20131116212505.16666: *5* - Intermediate: More about scripting
@language rest

c, g, p: commanders, generators, p.b, p.h etc.

@button (already covered)
@test (already covered)
    
@language python
.. @+node:ekr.20131116212505.16668: *6* Ctrl-B (execute-script)
# Ctrl-B executes the Python code in the presently-selected body pane.
g.es('hello world')

.. @+node:ekr.20131116212505.16669: *6* Ctrl-B on selected text
print('hi')
print('there')
.. @+node:ekr.20131116212505.16667: *6* g
# g is a Python module containing global utility functions and classes.
# g.es prints its arguments to Leo's log pane.
g.es(g.es)
# g is a large module:
g.es(len(list(dir(g))))
.. @+node:ekr.20131208103040.16344: *5* - Intermediate: Auto-completion
.. @+node:ekr.20131208103040.16350: *5* - Find command (needed?)
- Ctrl-G hides the Find pane.

- Show how to use the minibuffer to discover the toggle commands:
    <Alt-X>tog<tab>f<tab>   or
    <Alt-X>set<tab>f<tab>
.. @+node:ekr.20131116123026.16661: *6* Example
# For the Find screencast.  It could be improved so the differences between nodes is more apparent.
.. @+node:ekr.20131116123026.16662: *7* spam
DEF spam():
    pass
.. @+node:ekr.20131116123026.16663: *7* eggs
def eggs():
    pass
.. @+node:ekr.20111018220642.15862: *3* Plugins
.. @+node:ekr.20111017132257.15882: *4* Study import_xml plugin
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/b5c2982778a2df53

Provides commands (Alt-x) for importing and exporting XML from a Leo
outline. These commands are to XML what ``@auto-rst`` is to
reStructuredText.

``xml2leo`` imports an .xml file into the node following the currently
selected node.  ``leo2xml`` exports the current subtree to an .xml file
the user selects.

``xml_validate``, if executed on the top node in the
Leo xml tree, reports any errors in XML generation or DTD validation,
based on the DTD referenced from the XML itself.  If there's no DTD
it reports that as an error.

``leo2xml2leo`` takes the selected Leo subtree representing an XML file,
converts it to XML internally, and then creates a new Leo subtree from
that XML after the original, with 'NEW ' at the start of the top node's
name.  This updates all the headlines, so that the convenience only
previews (see below) are updated.  The original can be deleted if the
new subtree seems correct.

Conventions
===========

This is a valid XML file::

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE dml SYSTEM "dml.dtd">
    <?xml-stylesheet href="common.css"?>
    <dml xmlns='http://example.com/' xmlns:other='http://other.com/'/>
      <block type='example'>Here's <other:b>some</other:b> text</block>
    </dml>
    <!-- This is the last line -->

Note the processing instruction (xml-stylesheet), the DTD (DOCTYPE),
the trailing comment (after the closing tag), and the pernicious
mixed content (three separate pieces of text in the ``<block/>`` element).
These commands attempt to deal with all of this.

 - A top level Leo node is created to hold these top level parts.  Its
   headline is the basename of the file.
 - The xml declaration is placed in the body of
   this top level Leo node
 - Below that, in the same body text, appears a simple namespace map::

     http://example.com/
     other: http://other.com/
     ...

   i.e. the default namespace first, and then any prefixed name spaces.
 - Below that, in the same body text, appears the ``DOCTYPE`` declaration
 - Children are added to this top level Leo node to represent the
   top level elements in the xml file.  Headlines have the following
   meanings:

       - ``? pi-target some="other" __CHK`` - i.e. questionmark,
         space, name of processing instruction target, start of processing
         instruction content.  Only the questionmark, which indicates
         the processing instruction, and the first word, which indicates
         the processing instruction target, matter.  The remainder is just
         a convenience preview of the processing instruction content, which
         is the Leo node's body text.

       - ``# This is *really* imp`` - i.e. hash,
         space, start of comment content.  Only the hash, which indicates
         the comment, matters.  The remainder is just
         a convenience preview of the comment content, which
         is the Leo node's body text.

       - ``tagname name_attribute start of element text`` - i.e. the name
         of an element followed by a convenience preview of the element's
         text content.  If the element has a ``name`` attribute that's
         included at the start of the text preview.  Only the first word
         matters, it's the name of the element.

 - Element's text is placed in the Leo node's body.  If the element has
   tailing text (the ``" text"`` tailing the ``<other:b/>`` element
   in the above example), that occurs in the Leo node's body separated
   by the `tailing text sentinel`::

       @________________________________TAIL_TEXT_______________________________

 - Element's attributes are stored in a dict ``p.v.u['_XML']['_edit']``
   on the Leo node. ``'_XML'`` is the uA prefix for these commands, and
   ``'_edit'`` is used by the ``attrib_edit`` plugin to identify
   attributes it should present to the user for editing. The
   ``attrib_edit`` plugin **should be enabled** and its ``v.u mode``
   activated (through its submenu on the Plugins menu). The attribute
   edit panel initially appears as a tab in the log pane, although it
   can be moved around by right clicking on the pane dividers if the
   ``viewrendered`` and ``free_layout`` plugins are enabled. 
.. @+node:ekr.20111004090723.15495: *4* Finish leoOPML plugin
.. @+node:ekr.20111027143736.16557: *4* Study leo_screen
@nocolor-node

Ville mentioned leoremote for driving Leo from the command line.
There's also leoscreen, for driving the command line from Leo,
providing you use screen, which is probably unix/cygwin only.
.. @+node:ekr.20110930075237.15474: *3* Settings
.. @+node:ekr.20120516140545.9992: *4* Matt Wilkie
As for user interface, I'd love to see myLeoSettings with a checkbox
interface and filter bar at the top, and a feature to "merge or reset
from LeoSettings".

Or maybe something like Firefox's "about:config" would be better
suited (and probably faster to build).
.. @+node:ekr.20061011111007: *4* @bool autoload_most_recent_leo_file
http://sourceforge.net/forum/message.php?msg_id=3957908

Is there a setting for autmoatically loading most recent file or files.
.. @+node:ekr.20111109083738.9798: *3* Testing
.. @+node:ekr.20111105222316.9706: *4* Unit test: no unit tests omitted
@nocolor-node

Create a "registry" of unit tests.  Verify that unitTest.leo contains them all.
.. @+node:ekr.20111105222316.9707: *4* Unit test: importing a plugin changes nothing
@nocolor-node

Menu and plugin registry methods can fail if that *particular* unit test is running.
.. @+node:ekr.20111114151846.9856: *4* Unit test: verifies class relationships
.. @+node:ekr.20111114151846.9852: *5* mustBeDefined...
.. @+node:ekr.20111114151846.9850: *6* From baseTextWidget
.. @+node:ekr.20081031074455.3: *7* baseTextWidget.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'clipboard_append', # uses g.app.gui method.
    'clipboard_clear', # usesg.app.gui method.
)
.. @+node:ekr.20081031074455.4: *7* baseTextWidget.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    'appendText',
    'delete',
    'deleteTextSelection',
    'get',
    'getAllText',
    'getFocus',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionRange',
    'getYScrollPosition',
    'insert',
    'see',
    'seeInsertPoint',
    'setAllText',
    'setBackgroundColor',
    'setForegroundColor',
    'setFocus',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
)

.. @+node:ekr.20081031074455.5: *7* baseTextWidget.mustBeDefined...
# These can be do-nothings
mustBeDefined = (
    'flashCharacter',
    'hasSelection',
    'replace',
    'rowColToGuiIndex',
    'selectAllText',
    'tag_configure',
    'toGuiIndex',
    'toPythonIndex',
    'toPythonIndexRowCol',
)
.. @+node:ekr.20111114151846.9851: *6* From leoBody
.. @+node:ekr.20081005065934.9: *7* leoBody.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'after_idle',
    'forceFullRecolor', # The base-class method is usually good enough.
    'initAfterLoad',
    'tag_configure', # used in qtGui.py.
)
.. @+node:ekr.20031218072017.3660: *7* leoBody.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Birth, death & config.
    '__init__',
    'createBindings',
    'createControl',
    'setColorFromConfig',
    'setFontFromConfig'
    # Editors
    'createEditorLabel',
    'setEditorColors',
    # Events...
    'scheduleIdleTimeRoutine',
    # Low-level gui...(May be deleted)
    'getBodyPaneHeight',
    'getBodyPaneWidth',
    'hasFocus',
    'setFocus',
)
.. @+node:ekr.20061109102912: *7* define leoBody.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'getAllText',
    'getColorizer',
    'getInsertLines',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionAreas',
    'getSelectionLines',
    'getYScrollPosition',
    'hasSelection',
    'oops',
    'onBodyChanged',
    'recolor',
    'recolor_now',
    'see',
    'seeInsertPoint',
    'selectAllText',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
    'setSelectionAreas',
    'setYScrollPosition',
    'updateSyntaxColorer',
)
.. @+node:ekr.20111114151846.9853: *6* from leoFrame
.. @+node:ekr.20080429051644.1: *7* leoFrame.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (

    # Icon bar convenience methods.    
    'addIconButton',
    'addIconRow',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'getNewIconFrame',
    'hideIconBar',
    'initAfterLoad',
    'initCompleteHint',
    'showIconBar',
)
.. @+node:ekr.20061109120726: *7* leoFrame.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (

    'createFirstTreeNode', # New in Leo 4.6: was defined in tkTree.
    'initialRatios',
    'longFileName',
    'oops',
    'promptForSave',
    'scanForTabWidth',
    'shortFileName',

    # Headline editing.
    'abortEditLabelCommand',
    'endEditLabelCommand',
    'insertHeadlineTime',

    # Cut/Copy/Paste.
    'OnPaste',
    'OnPasteFromMenu',
    'copyText',
    'cutText',
    'pasteText',

    # Status line convenience methods.
    'createStatusLine',
    'clearStatusLine',
    'disableStatusLine',
    'enableStatusLine',
    'getStatusLine',
    'getStatusObject',
    'putStatusLine',
    'setFocusStatusLine',
    'statusLineIsEnabled',
    'updateStatusLine',
)
.. @+node:ekr.20061109120704: *7* leoFrame.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    #Gui-dependent commands.
    'cascade',
    'contractBodyPane',
    'contractLogPane',
    'contractOutlinePane',
    'contractPane',
    'equalSizedPanes',
    'expandLogPane',
    'expandPane',
    'fullyExpandBodyPane',
    'fullyExpandLogPane',
    'fullyExpandOutlinePane',
    'fullyExpandPane',
    'hideBodyPane',
    'hideLogPane',
    'hideLogWindow',
    'hideOutlinePane',
    'hidePane',
    'leoHelp',
    'minimizeAll',
    'resizeToScreen',
    'toggleActivePane',
    'toggleSplitDirection',
    # Windowutilities...
    'bringToFront',
    'deiconify',
    'get_window_info',
    'lift',
    'update',
    # Config...
    'resizePanesToRatio',
    'setInitialWindowGeometry',
    'setTopGeometry',
)
.. @+node:ekr.20111114151846.9854: *6* from leoTree
.. @+node:ekr.20081005065934.7: *7* leoTree.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'initAfterLoad', # New in Leo 4.6.
    'treeSelectHint', # New in Leo 4.6.
)
.. @+node:ekr.20061109164512: *7* leoTree.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    # Getters & setters.
    'editPosition',
    'getEditTextDict',
    'setEditPosition',
    # Others.
    'endEditLabel',
    # 'expandAllAncestors', # Now defined in Commands class.
    'injectCallbacks',
    'OnIconDoubleClick',
    'onHeadChanged',
    'onHeadlineKey',
    'updateHead',
    'oops',
)
.. @+node:ekr.20061109164610: *7* leoTree.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Colors & fonts.
    'getFont',
    'setFont',
    'setFontFromConfig ',
    # Drawing & scrolling.
    'drawIcon',
    'redraw_now',
    'scrollTo',
    # Headlines.
    'editLabel',
    # 'setEditLabelState',
    # Selecting.
    # 'select', # Defined in base class, may be overridden in do-nothing subclasses.
)
.. @+node:ekr.20111114151846.9855: *6* from leoGui
.. @+node:ekr.20061109211054: *7* leoGui.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'guiName',
    'oops',
    'setScript',
    'widget_name',
)
.. @+node:ekr.20061109211022: *7* leoGui.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Startup & shutdown
    'attachLeoIcon',
    'center_dialog',
    'color',
    #'createComparePanel',          # optional
    'createFindTab',
    # 'createKeyHandlerClass',
    'createLeoFrame',
    'createRootWindow',
    'create_labeled_frame',
    'destroySelf',
    #'eventChar',
    #'eventKeysym',
    'eventWidget',
    # 'eventXY',
    # 'finishCreate', # optional.
    # 'getFontFromParams', # optional
    # 'getFullVersion', # optional.
    'getTextFromClipboard',
    'get_focus',
    'get_window_info',
    'isTextWidget',
    # 'keysym',
    'killGui',
    # 'makeScriptButton', # optional
    'recreateRootWindow',
    'replaceClipboardWith',
    'runAboutLeoDialog',
    'runAskLeoIDDialog',
    'runAskOkCancelNumberDialog',
    'runAskOkDialog',
    'runAskYesNoCancelDialog',
    'runAskYesNoDialog',
    'runMainLoop',
    'runOpenFileDialog',
    'runSaveFileDialog',
    'set_focus',
    #'setIdleTimeHook',             # optional       
    #'setIdleTimeHookAfterDelay',   # optional
)
.. @+node:ekr.20100131161507.6303: *4* Unit test: all commands have docstrings
# Just make the test.  It doesn't have to pass.
.. @+node:ekr.20140322090829.16832: *4* Improve Sherlock
@language rest

* Improve traces for __init__:

* Optionally print g.callers.

* Distinguish between calls & returns.
    ? Just print return trace if it immediate follows the call trace.
    - Have a return-only trace list.

? Allow stops at each trace: drop into pdb??
.. @+node:ekr.20120226180525.10191: *4* Run unit tests interactively?
@nocolor-node

Getting value from Bret Victor's video

http://groups.google.com/group/leo-editor/browse_thread/thread/9e1785ba4f57faf8

Thus, to associate code with unit tests, we need only create a
convention for associating source code with nodes.  But clones make
this trivial to do!

- @interactive-unit-tests
 - @itest
   - @test spam
   - (clone of) spam

This is all we would need to "declare" that @test spam should be run
whenever the spam node changes!

These are just first thoughts, made up as I am writing this post.  But
clearly, Leo can do more in this area.
.. @+node:ekr.20140730175636.17982: *3* Vim emulation
@language rest

- N ; repeat the last t,T,f,F command.
  N , repeat the last t,T,f,F command in opposite direction.

- Support z commands:
    z-          or zb   redraw, current line at bottom of window
    z.          or zz   redraw, current line at center of window
    z<Return>   or zt   redraw, current line at top of window

- Finish g command
    ge should go to end of n'th word: at present it goes to end of line.
    gv start visual mode at previous visual area
    gV start visual-line mode at previous visual area.
    
- Possible extensions:
    gft  focus-to-tree
    gfb  focus-to-body
    gfl  focus-to-log
    gfs  focus-to-spell-tab
.. @+node:ekr.20140808182202.18183: *4* Maybe
http://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/

- ctrl-v : visual select column

- Write extend_vim_mode plugin

- Extend Leo's undo to show the vim characters for the commands.

- tab & shift-tab in normal mode might indent text.
  They do nothing in the real vim.  Sheesh.

- Ctrl-C works like escape (Conflicts with copy-text)

:1,$ s/^/  /g

    From line 1 to EOF ($), replace the beginning of the line (^) with two
    spaces ( ), globally (keep applying as many times as possible)
    
    A quick vim-like way to do indents on a range of characters. I also use
    this one frequently...

EKR: Can't Leo's find command do this?
.. @+node:ekr.20140822072856.18255: *4* Substitution notes
@language rest

The :substitute command searches for a text pattern, and replaces it with a text string. There are many options, but these are what you probably want:

:%s/foo/bar
:%s/foo/bar/
    Replace first occurrence of 'foo' with 'bar' in all lines.

:%s/foo/bar/g
     Replace all occurrences of 'foo' with 'bar' in all lines.
   
:s/foo/bar/
    Replace first occurrence of 'foo' (on the current line) with 'bar'

:s/foo/bar/g
    Replace all occurrence of 'foo' (on the current line ), with 'bar'.
    
Flags:
/gi case insensitive
/gI case sensitive
/gw word insensitive
/gW word sensitive
    
===== It's pointless to ask for confirmation: in that case, use Leo's search commands.

:%s/foo/bar/gc
    Change each 'foo' to 'bar', but ask for confirmation first. 

:%s/\<foo\>/bar/gc
    Change only whole words exactly matching 'foo' to 'bar'; ask for confirmation. 

:%s/foo/bar/gci
    Change each 'foo' (case insensitive) to 'bar'; ask for confirmation. 
    This may be wanted after using :set noignorecase to make searches case sensitive (the default). 

:%s/foo/bar/gcI
    Change each 'foo' (case sensitive) to 'bar'; ask for confirmation. 
    This may be wanted after using :set ignorecase to make searches case insensitive. 
.. @+node:ekr.20140822160427.19046: *4* Unfinished operations
N   CTRL-R          redo last N undone changes
    Ctrl-Shift-Z    redo last change
    
N   +               (motion) down N lines, on the first non-blank character (also: CTRL-M and <CR>)
N   -               (motion) up N lines, on the first non-blank character
N   (               (motion) N sentences backward
N   )               (motion) N sentences forward
N   {               (motion) N paragraphs backward
N   }               (motion) N paragraphs forward
N   |               (motion) to column N (default: 1)
    `<              (motion) go to the start of the (previous) Visual area
    `>              (motion) go to the end of the (previous) Visual area
    
N   [(              (motion) N times back to unclosed '('
N   [*              (motion) N times back to start of comment "/*"
N   [{              (motion) N times back to unclosed '{'
N   ])              (motion) N times forward to unclosed ')'
N   ]*              (motion) N times forward to end of comment "*/"
N   ]}              (motion) N times forward to unclosed '}'

N   C               change to end-of-line (and N-1 more lines)
N   D               delete to end-of-line (and N-1 more lines)
N   G               (motion) goto line N (default: last line), on the first non-blank character
N   I               insert text before the first non-blank in the line (N times)
N   J               (motion?) join N-1 lines (delete newlines)
VIS J               (motion?) join the highlighted lines
N   N               (motion) repeat last search, in opposite direction
N   R               enter Replace mode (repeat the entered text N times)
N   S               change N lines
N   X               delete N characters before the cursor
N   Y               yank N lines
    ZQ              Same as ":q!".
    ZZ              Same as ":x".
    
N   cc              change N lines
N   c{motion}       change the text that is moved over with {motion}
VIS c               change the highlighted text
    m<a-zA-Z>       mark current position with mark <a-zA-Z>
N   p               put a register after the cursor position (N times)
    q               stop recording
    q<A-Z>          record typed characters, appended to register <a-z>
    q<a-z>          record typed characters into register <a-z>
N   r<char>         replace N characters with <char>
N   s               change N characters

Searches:

N   /<CR>                       (motion) repeat last search, in the forward direction
N   /{pattern}[/[offset]]<CR>   (motion) search forward for the Nth occurrence of {pattern}
N   ?<CR>                       (motion) repeat last search, in the backward direction
N   ?{pattern}[?[offset]]<CR>   (motion) search backward for the Nth occurrence of {pattern}
.. @+node:ekr.20100113075303.6270: *4* vim problems (from Tom L)
None of these is easily solvable in Leo's present environment.
.. @+node:ekr.20140822160427.19049: *5* Can not be solved using @mode
Most, if not all of these things *can* be solved in Leo's new vim mode.
.. @+node:ekr.20100112051224.6239: *6* Displaying mode help
The "--> mode-help" command has the following issues related to the
display of the "Help" tab:

1. Key label always capitalized.

Vim commands are mapped to both lower-case and upper-case keys but always appear
mapped to upper-case keys within the "Help" tab.

2. Layout of tab's contents.

To improve readability and better support narrow tab cards, display the mode's
label without the "enter-" and "-mode" text and place the key label before the
mode label.

For example, the following entries would change from::
    enter-vi-delete-line-mode d
    enter-vi-delete-to-begin-of-word-mode b
to::
    d : vi-delete-line
    b : vi-delete-to-begin-of-word
.. @+node:ekr.20100113075303.6271: *6* Need mode-oriented bindings
Mapping a number to a command or an @mode node works but can not be used as it
prevents the number from being entered as text while in Vi's insert state.

Binding 'bksp' key to back-char to move back a character in command mode
prevents 'bksp' from deleting characters in text edit mode.
.. @+node:ekr.20100112051224.6238: *6* Some commands do not work in headline
Leo functions exist which unconditionally set focus to the body pane
regardless of the active pane.

For example, bracket matching commands ("%" key) do not work within
a node's headline text.  Instead, the command is performed on the
node's body text.

Using the "undo" command (key 'u') to undo a change to a node's headline text
only works correctly after another node has been selected. It appears that
changes made to a node's headline text are not recorded in Leo's change history
until the edited node has lost focus.
.. @+node:ekr.20100112051224.6222: *6* Commands requesting user input
Commands requesting user input must be the last command executed within an @mode
node. This prevents the implementation of commands such as "yank to <character>"
that requires a "copy to clipboard" operation after the "find-character"
command.

======

Maybe we just need more commands...
.. @+node:ekr.20100112051224.6223: *6* Editing node headlines using @mode nodes
Commands modifying or selecting headline text do not work correctly within a
@mode node.

This eliminates accurate implementation of vi's delete/change/substitute/yank
object commands. As a workaround, the commands are currently written to only
select the text. The user must perform the subsequent delete, change,
substitute, and yank.
.. @+node:ekr.20110529115328.18247: *6* Block cursor
Having worked with Tk text canvases more that Qt, there still seem to
be things that it had that have to be worked around as the Qt people
just haven't seen the need for.

One is the block cursor, I giving Leo Vim like functionality, it would
be nice if one where supported, theses new kids just don't understand
something so primitive I guess.
.. @+node:ekr.20090629183608.8446: *6* Copy/paste/yank/delete
Yank vs. Yank:
Vi's "yank" commands copy the selected text TO the clipboard.
Leo's "yank" commands insert text FROM the clipboard.

copy-text in modes:
Leo's copy-text command does not work within a mode.  As a result,
all "copy to clipboard" capability is being implemented using the
kill-<object> command followed by Leo's "yank" command to put the
text back.

paste-text in modes:
The paste-text command does not work within an @mode node.  Leo's
"yank" command is used instead.

delete-node does not copy node to clipboard:
A copy-node command is issued to copy the node to the clipboard
followed by the delete-node command.
.. @+node:ekr.20100112051224.6226: *6* Range prefix to commands/objects (k.getArgs)
The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
.. @+node:ekr.20140822160427.19047: *5* To be solved in new vim mode
Support the ';' key: repeat the last "To character" or "Find character" command.
.. @+node:ekr.20080616110054.2: *6* Support vim dot command
The ability to repeat the last editing related command by pressing the period
key is not supported and there is no workaround in place.

Binding keys within nodes:

Some commands can be "easily" repeated by having the command's mode
bind itself to the period key.  This is not currently working.  

Support commands requesting input:

Add companion commands that reuse input.  For example, a zap-to-
character-again command could exist which will reuse the key entered
in the last zap-to-character command.  With this support, the mode
that performs the initial command would assign the period key to a
companion mode that is identical to the initial mode but with the zap-
to-character command replaced by the zap-to-character-again command.

Commands requiring companion commands are:
  zap-to-character
  find-character
  backward-find-character
  (Any others?)

Notes:

- The copy of the character should be saved somewhere that does NOT affect the
  contents of the clipboard.

- The same or a separate storage location can be used for all commands to retain
  a copy of the character entered by the user. It doesn't matter since only the
  last command is assigned to the period key to be re-executed.
.. @+node:ekr.20100112051224.6234: *6* Move current line (to screen position)
Vi has a collection of "z<movement>" commands that will move the
current line to the top, middle, and bottom of the screen.  They are
not supported in Leo.
.. @+node:ekr.20100112051224.6235: *6* Move body text up/down
Vi maps keys to scroll the text up/down one line and by half the
number of visible lines.  Leo does not support this.

.. @+node:ekr.20110202094848.12568: *6* Named marks
Another is named marks, in Vim you can store a number of cursor
locations, and recall them to jump around in your code.  This was also
useful in filling out templates as each stop could be given a name
mark.  This helped make filling out a template easier as you weren't
stuck in a linear filling in the blanks in a set order, template stops
where linked in rings, you could jump from the last stop back to the
first and make and changes you wanted on a second go round.  Gravity
of marks made things easier to inspect to determine what stops where
used and which ones were being bypassed.

As these things had an actual presence in the text buffer, it going to
be a little harder to come up with a reasonable work around.
.. @+node:ekr.20100112051224.6236: *6* Two kinds of words
Vi supports two types of words in its commands:

1. Words that consist of only a subset of the character set and
2. words that consist of all characters except the space and tab characters.

Leo's always considers a word to consist of a subset of characters
although some word related commands include different characters
than others.
.. @+node:ekr.20100521090440.5887: *5* Generalize minibuffer code
From Tom L

This is hardwired for the first parameter.  Things I need to expand
this:

1. put in a variable that cycles through the tabStops

2. In this mock up, you are entering the parameters in the minibuffer,
a more advanced version would collect each keypress and put it in the
body at the current tabStop, a tab would finalize the entry and
advance to the next stop, no text other than the 'help', ends up in
the minibuffer.

Sinc I'm only modifying existing code without real understanding of
what Leo is doing, any guidance would be appreciated.

===== EKR: I think this has been solved.
.. @+node:ekr.20131105122124.16479: *4* vim reference card (do not delete)
@killcolor

https://groups.google.com/forum/#!topic/leo-editor/OSe0_D5tmJQ

http://stackoverflow.com/questions/7325052/can-someone-explain-to-me-why-the-dot-command-is-so-useful-in-vim
.. @+node:ekr.20131105122124.16482: *5*  keys (do not sort!!)
N   <Del>       delete N characters under and after the cursor
    <Del>       delete the character under the cursor
    <Del>       while entering a count: delete last character
    
    <Left>      (motion) cursor left
    <Right>     (motion) cursor right
    <C-Left>    (motion) cursor one word left
    <C-Right>   (motion) cursor one word right
    
    <Down>      recall newer command-line that starts with current command
    <S-Down>    recall newer command-line from history
    <S-Up>      recall older command-line from history
    <Up>        recall older command-line that starts with current command
    <Esc>       abandon command-line (if 'wildchar' is <Esc>, type it twice)

N   CTRL-^                  Edit alternate file N (equivalent to ":e #N").
N   CTRL-A                  add N to the number at or after the cursor
N   CTRL-B                  window N pages Backwards (upwards)
    CTRL-B                  (motion?) cursor to beginning of command-line
    CTRL-BREAK              MS-DOS: during searches: interrupt the search
    CTRL-C                  during searches: interrupt the search
N   CTRL-D                  window N lines Downwards (default: 1/2 window)
N   CTRL-E                  window N lines downwards (default: 1)
    CTRL-E                  (motion?) cursor to end of command-line
N   CTRL-F                  (motion) window N pages Forwards (downwards)
    CTRL-G                  show current file name (with path) and cursor position
N   CTRL-I                  (motion) go to Nth newer position in jump list
    CTRL-K {char1} {char2}  enter digraph
    CTRL-L                  Clear and redraw the screen.
N   CTRL-O                  (motion) go to Nth older position in jump list
N   CTRL-R                  redo last N undone changes
    CTRL-R <0-9a-z"%:->     insert contents of register <0-9a-z"%:->
N   CTRL-T                  (motion) Jump back from Nth older tag in tag list
N   CTRL-U                  window N lines Upwards (default: 1/2 window)
    CTRL-U                  remove all characters
    CTRL-V                  highlight blockwise or stop highlighting
    CTRL-V                  start highlighting blockwise   }  highlighted text
    CTRL-V {char}           insert {char} literally
    CTRL-V {number}         enter decimal value of character (up to three digits)
    CTRL-W                  delete the word in front of the cursor
    CTRL-W +                Increase current window height
    CTRL-W -                Decrease current window height
    CTRL-W =                Make all windows equal height
    CTRL-W CTRL-W           Move cursor to window below (wrap)
    CTRL-W CTRL-^           Split window and edit alternate file
    CTRL-W R                Rotate windows upwards
    CTRL-W W                Move cursor to window above (wrap)
    CTRL-W ]                Split window and jump to tag under cursor
    CTRL-W _                Set current window height (default: very high)
    CTRL-W b                Move cursor to bottom window
    CTRL-W c  or :cl[ose]   Make buffer hidden and close window
    CTRL-W f                Split window and edit file name under the cursor
    CTRL-W j                Move cursor to window below
    CTRL-W k                Move cursor to window above
    CTRL-W n  or :new       Create new empty window
    CTRL-W o  or :on[ly]    Make current window only one on the screen
    CTRL-W p                Move cursor to previous active window
    CTRL-W q  or :q[uit]    Quit editing and close window
    CTRL-W r                Rotate windows downwards
    CTRL-W s                Split window into two parts
    CTRL-W t                Move cursor to top window
    CTRL-W x                Exchange current window with next one
N   CTRL-X                  subtract N from the number at or after the cursor
N   CTRL-Y                  window N lines upwards (default: 1)
    CTRL-Z                  Same as ":stop!"
    CTRL-]                  Jump to the tag under cursor, unless changes have been made
    
    0               (motion) to first character in the line (also: <Home> key)
VIS ~               switch case for highlighted text
N   ~               switch case for N characters and advance cursor
N   +               (motion) down N lines, on the first non-blank character (also: CTRL-M and <CR>)
N   _               (motion) down N-1 lines, on the first non-blank character
N   -               (motion) up N lines, on the first non-blank character
N   ,               (motion) repeat the last "f", "F", "t", or "T" N times in opposite direction
N   .               (motion?) repeat last change (with count replaced with N)
N   ;               (motion) repeat the last "f", "F", "t", or "T" N times
N   (               (motion) N sentences backward
N   )               (motion) N sentences forward
N   {               (motion) N paragraphs backward
N   }               (motion) N paragraphs forward
N   |               (motion) to column N (default: 1)
    `"              (motion) go to the position when last editing this file
    '<a-zA-Z0-9[]'"<>>  (motion) same as `, but on the first non-blank in the line
    `<              (motion) go to the start of the (previous) Visual area
    `<0-9>          (motion) go to the position where Vim was last exited
    `<A-Z>          (motion) go to mark <A-Z> in any file
    `<a-z>          (motion) go to mark <a-z> within current file
    `>              (motion) go to the end of the (previous) Visual area
    `[              (motion) go to the start of the previously operated or put text
    `]              (motion) go to the end of the previously operated or put text
    ``              (motion) go to the position before the last jump
N   $               (motion) go to the last character in the line (N-1 lines lower) (also: <End> key)
    ^               (motion) go to first non-blank character in the line
N   %               (motion) goto line N percentage down in the file.  N must be given, otherwise it is the % command.
    %               (motion) find the next brace, bracket, comment, or "#if"/ "#else"/"#endif" in this line and go to its match
    
N   <{motion}       move the lines that are moved over with {motion} one shiftwidth left
N   >{motion}       move the lines that are moved over with {motion} one shiftwidth right
N   <<              move N lines one shiftwidth left
N   >>              move N lines one shiftwidth right

N   #                           (motion) search backward for the identifier under the cursor
N   *                           (motion) search forward for the identifier under the cursor
N   /<CR>                       (motion) repeat last search, in the forward direction
N   /{pattern}[/[offset]]<CR>   (motion) search forward for the Nth occurrence of {pattern}
N   ?<CR>                       (motion) repeat last search, in the backward direction
N   ?{pattern}[?[offset]]<CR>   (motion) search backward for the Nth occurrence of {pattern}

N   @<a-z>          execute the contents of register <a-z> (N times)
N   @@              (motion?) repeat previous @<a-z> (N times)

    "<char>         use register <char> for the next delete, yank, or put

N   [#              (motion) N times back to unclosed "#if" or "#else"
N   [(              (motion) N times back to unclosed '('
N   [*              (motion) N times back to start of comment "/*"
N   [[              (motion) N sections backward, at start of section
N   []              (motion) N sections backward, at end of section
N   [p              (motion?) like P, but adjust indent to current line
N   [{              (motion) N times back to unclosed '{'
N   ]#              (motion) N times forward to unclosed "#else" or "#endif"
N   ])              (motion) N times forward to unclosed ')'
N   ]*              (motion) N times forward to end of comment "*/"
N   ][              (motion) N sections forward, at end of section
N   ]]              (motion) N sections forward, at start of section
N   ]p              (motion?) like p, but adjust indent to current line
N   ]}              (motion) N times forward to unclosed '}'

N   A               append text at the end of the line (N times)
N   B               (motion) N blank-separated WORDS backward
N   C               change to end-of-line (and N-1 more lines)
N   D               delete to end-of-line (and N-1 more lines)
N   E               (motion) forward to the end of the Nth blank-separated WORD
N   F<char>         (motion) to the Nth occurrence of <char> to the left
N   G               (motion) goto line N (default: last line), on the first non-blank character
N   H               (motion?) go to the Nth line in the window, on the first non-blank
N   I               insert text before the first non-blank in the line (N times)
N   J               (motion?) join N-1 lines (delete newlines)
VIS J               (motion?) join the highlighted lines
    K               lookup keyword under the cursor with 'keywordprg' program (default: "man")
    M               (motion?) go to the middle line in the window, on the first non-blank
N   L               (motion?) go to the Nth line from the bottom, on the first non-blank
N   N               (motion) repeat last search, in opposite direction
N   O               open a new line above the current line, append text (N times)
N   P               put a register before the cursor position (N times)
N   R               enter Replace mode (repeat the entered text N times)
N   S               change N lines
N   T<char>         (motion) till before the Nth occurrence of <char> to the left
    U               restore last changed line
VIS U               make highlighted text uppercase
    V               highlight linewise or stop highlighting
    V               start highlighting linewise    }  operator to affect
N   W               (motion) N blank-separated WORDS forward
N   X               delete N characters before the cursor
N   Y               yank N lines
    ZQ              Same as ":q!".
    ZZ              Same as ":x".
N   a               append text after the cursor (N times)
N   b               (motion) N words backward
N   cc              change N lines
N   c{motion}       change the text that is moved over with {motion}
VIS c               change the highlighted text
VIS d               delete the highlighted text
N   dd              delete N lines
N   d{motion}       delete the text that is moved over with {motion}
N   e               (motion) forward to the end of the Nth word
N   f<char>         (motion) to the Nth occurrence of <char> to the right
    g CTRL-G        show cursor column, line, and character position
N   g^              (motion) to first non-blank character in screen line (differs from "^" when lines wrap)
    g~{motion}      switch case for the text that is moved over with {motion}
N   g#              (motion) like "#", but also find partial matches
N   g$              (motion) to last character in screen line (differs from "$" when lines wrap)
N   g*              (motion) like "*", but also find partial matches
N   g0              (motion) to first character in screen line (differs from "0" when lines wrap)
    gD              (motion) goto global declaration of identifier under the cursor
N   gE              (motion) backward to the end of the Nth blank-separated WORD
N   gI              insert text in column 1 (N times)
    gU{motion}      make the text that is moved over with {motion} uppercase
    ga              show ascii value of character under cursor in decimal, hex, and octal
    gd              (motion) goto local declaration of identifier under the cursor
    gf  or ]f       Edit the file whose name is under the cursor
N   ge              (motion) backward to the end of the Nth word
N   gg              (motion) goto line N (default: first line), on the first non-blank character
N   gj              (motion) down N screen lines (differs from "j" when line wraps)
N   gk              (motion) up N screen lines (differs from "k" when line wraps)
N   gq{motion}      format the lines that are moved over with {motion} to 'textwidth' length
N   gs              Goto Sleep for N seconds
    gu{motion}      make the text that is moved over with {motion} lowercase
    gv              start highlighting on previous visual area
N   h               (motion) left (also: CTRL-H, <BS>, or <Left> key)
N   i               insert text before the cursor (N times) (also: <Insert>)
N   j               (motion) down N lines (also: CTRL-J, CTRL-N, <NL>, and <Down>)
N   k               (motion) up N lines (also: CTRL-P and <Up>)
N   l               (motion) right (also: <Space> or <Right> key)
N   n               (motion?) repeat last search
    m<a-zA-Z>       mark current position with mark <a-zA-Z>
N   o               open a new line below the current line, append text (N times)
    o               (motion?) exchange cursor position with start of highlighting
N   p               put a register after the cursor position (N times)
    q               stop recording
    q<A-Z>          record typed characters, appended to register <a-z>
    q<a-z>          record typed characters into register <a-z>
N   r<char>         replace N characters with <char>
N   s               change N characters
N   t<char>         (motion) till before the Nth occurrence of <char> to the right
N   u               undo last N changes
VIS u               make highlighted text lowercase
    v               highlight characters or stop highlighting
    v               start highlighting characters  }  move cursor and use
N   w               (motion) N words forward
N   x               delete N characters under and after the cursor
N   yy              yank N lines 
N   y{motion}       yank the text moved over with {motion} 
VIS y               yank the highlighted text 
    z- or zb        redraw, current line at bottom of window
    z. or zz        redraw, current line at center of window
    z<CR> or zt     redraw, current line at top of window
N   zh              scroll screen N characters to the right
N   zl              scroll screen N characters to the left
.. @+node:ekr.20131108082341.18235: *5* motion keys
    CTRL-B  (motion?) cursor to beginning of command-line
    CTRL-E  (motion?) cursor to end of command-line
    N   .   (motion?) repeat last change (with count replaced with N)
N   [p      (motion?) like P, but adjust indent to current line
N   ]p      (motion?) like p, but adjust indent to current line
    
    <Left>  (motion) cursor left
    <Right> (motion) cursor right
    <S-Left>/<S-Right>  (motion) cursor one word left/right
    
N   CTRL-F  (motion) window N pages Forwards (downwards)
N   CTRL-I  (motion) go to Nth newer position in jump list
N   CTRL-O  (motion) go to Nth older position in jump list
N   CTRL-T  (motion) Jump back from Nth older tag in tag list
    0       (motion) to first character in the line (also: <Home> key)
N   +       (motion) down N lines, on the first non-blank character (also: CTRL-M and <CR>)
N   _       (motion) down N-1 lines, on the first non-blank character
N   -       (motion) up N lines, on the first non-blank character
N   ,       (motion) repeat the last "f", "F", "t", or "T" N times in opposite direction
N   ;       (motion) repeat the last "f", "F", "t", or "T" N times
N   (       (motion) N sentences backward
N   )       (motion) N sentences forward
N   {       (motion) N paragraphs backward
N   }       (motion) N paragraphs forward
N   |       (motion) to column N (default: 1)

    `"                  (motion) go to the position when last editing this file
    '<a-zA-Z0-9[]'"<>>  (motion) same as `, but on the first non-blank in the line
    `<                  (motion?) go to the start of the (previous) Visual area
    `<0-9>              (motion) go to the position where Vim was last exited
    `<A-Z>              (motion) go to mark <A-Z> in any file
    `<a-z>              (motion) go to mark <a-z> within current file
    `>                  (motion) go to the end of the (previous) Visual area
    `[                  (motion) go to the start of the previously operated or put text
    `]                  (motion) go to the end of the previously operated or put text
    ``                  (motion) go to the position before the last jump

N   $       (motion) go to the last character in the line (N-1 lines lower) (also: <End> key)
    ^       (motion) go to first non-blank character in the line
N   %       (motion) goto line N percentage down in the file.  N must be given, otherwise it is the % command.
    %       (motion) find the next brace, bracket, comment, or "#if"/ "#else"/"#endif" in this line and go to its match
    
N   #       (motion) search backward for the identifier under the cursor
N   *       (motion) search forward for the identifier under the cursor
N   /<CR>   (motion) repeat last search, in the forward direction

N   /{pattern}[/[offset]]<CR>   (motion) search forward for the Nth occurrence of {pattern}
N   ?<CR>                       (motion) repeat last search, in the backward direction
N   ?{pattern}[?[offset]]<CR>   (motion) search backward for the Nth occurrence of {pattern}

N   [#      (motion) N times back to unclosed "#if" or "#else"
N   [(      (motion) N times back to unclosed '('
N   [*      (motion) N times back to start of comment "/*"
N   [[      (motion) N sections backward, at start of section
N   []      (motion) N sections backward, at end of section
N   [{      (motion) N times back to unclosed '{'

N   ]#      (motion) N times forward to unclosed "#else" or "#endif"
N   ])      (motion) N times forward to unclosed ')'
N   ]*      (motion) N times forward to end of comment "*/"
N   ][      (motion) N sections forward, at end of section
N   ]]      (motion) N sections forward, at start of section
N   ]}      (motion) N times forward to unclosed '}'

N   B       (motion) N blank-separated WORDS backward
N   E       (motion) forward to the end of the Nth blank-separated WORD
N   F<char> (motion) to the Nth occurrence of <char> to the left
N   G       (motion) goto line N (default: last line), on the first non-blank character
N   H       (motion?) go to the Nth line in the window, on the first non-blank
N   J       (motion?) join N-1 lines (delete newlines)
VIS J       (motion?) join the highlighted lines
    M       (motion?) go to the middle line in the window, on the first non-blank
N   L       (motion?) go to the Nth line from the bottom, on the first non-blank
N   N       (motion) repeat last search, in opposite direction
N   T<char> (motion) till before the Nth occurrence of <char> to the left
N   W       (motion) N blank-separated WORDS forward

N   b       (motion) N words backward
N   e       (motion) forward to the end of the Nth word
N   f<char> (motion) to the Nth occurrence of <char> to the right
N   g^      (motion) to first non-blank character in screen line (differs from "^" when lines wrap)
N   g#      (motion) like "#", but also find partial matches
N   g$      (motion) to last character in screen line (differs from "$" when lines wrap)
N   g*      (motion) like "*", but also find partial matches
N   g0      (motion) to first character in screen line (differs from "0" when lines wrap)
    gD      (motion) goto global declaration of identifier under the cursor
N   gE      (motion) backward to the end of the Nth blank-separated WORD
    gd      (motion) goto local declaration of identifier under the cursor
N   ge      (motion) backward to the end of the Nth word
N   gg      (motion) goto line N (default: first line), on the first non-blank character
N   gj      (motion) down N screen lines (differs from "j" when line wraps)
N   gk      (motion) up N screen lines (differs from "k" when line wraps)
N   h       (motion) left (also: CTRL-H, <BS>, or <Left> key)
N   j       (motion) down N lines (also: CTRL-J, CTRL-N, <NL>, and <Down>)
N   k       (motion) up N lines (also: CTRL-P and <Up>)
N   l       (motion) right (also: <Space> or <Right> key)
N   n       (motion?) repeat last search
    o       (motion?) exchange cursor position with start of highlighting
N   t<char> (motion) till before the Nth occurrence of <char> to the right
N   w       (motion) N words forward
.. @+node:ekr.20131108082341.18226: *5* motions
@color

w   to start of next word, excluding it's first character.
e   to end of next word, including it's last character.
$   to end of line, including the last character.
0   to start of line

Motions may include repeat count:

d2w
2dd
d2d

From: http://bullium.com/support/vim.html#motion

Basic motion commands:

N h
N j or Ctrl-N
N k or Ctrl-P
0 or <Home>
^ 
$ or <End>
g0 or
g<Home> 	
g^
g$ or g<End>
f{char}
F{char}
t{char}
T{char}
; 	Repeat latest f, t, F or T [count] times.
, 	Repeat latest f, t, F or T in opposite direction [count] times.
-
N + or CTRL-M or <CR>
N _
<C-End> or G
N <C-Home> or gg
N <S-Right> or w
N <C-Right> or W
N e 	Forward to the end of word [count]
E 	Forward to the end of WORD [count]
<S-Left> or
b 	[count] words backward
<C-Left> or
B 	[count] WORDS backward
ge 	Backward to the end of word [count]
gE 	Backward to the end of WORD [count]

These commands move over words or WORDS.

A word consists of a sequence of letters, digits and underscores, or a
sequence of other non-blank characters, separated with white space (spaces,
tabs, ). This can be changed with the 'iskeyword' option.

A WORD consists of a sequence of non-blank characters, separated with white
space. An empty line is also considered to be a word and a WORD.

N ( 	    
N ) 	    
N { 	    
N } 	
N ]] 	    
N ][ 	    
N [[ 	    
N [] 	
.. @+node:ekr.20131105122124.16483: *5* vim regex
                                           Value of magic option
                                           ---------------------
                        meaning            magic       nomagic

           matches any single character      .            \.
                  matches start of line      ^            ^
                    matches end of line      $            $
                  matches start of word      \<           \<
                    matches end of word      \>           \>
   matches a single char from the range      [a-z]        \[a-z]
 matches a single char not in the range      [^a-z]       \[^a-z]
             matches an identifier char      \i           \i
              idem but excluding digits      \I           \I
            matches a keyword character      \k           \k
              idem but excluding digits      \K           \K
           matches a filename character      \f           \f
              idem but excluding digits      \F           \F
          matches a printable character      \p           \p
              idem but excluding digits      \P           \P

                          matches <Esc>      \e           \e
                          matches <Tab>      \t           \t
                           matches <CR>      \r           \r
                           matches <BS>      \b           \b

matches 0 or more of the preceding atom      *            \*
matches 1 or more of the preceding atom      \+           \+
   matches 0 or 1 of the preceding atom      \=           \=
                 separates two branches      \|           \|
           group a pattern into an atom      \(\)         \(\)
.. @+node:ekr.20131105122124.16484: *5* keys in insert mode
    char                action in Insert mode
    ----                --------------------- 
 
    <Esc>               end Insert mode, back to Normal mode
    <BS> or CTRL-H      delete the character before the cursor
    {char1} <BS> {char2}    enter digraph if 'digraph' option set
    <Del>               delete the character under the cursor
    <End>               cursor after last character in the line
    <Home>              cursor to first character in the line
    <NL> or <CR>        begin new line
    
    cursor keys         move cursor left/right/up/down
    shift-left/right    one word left/right
    shift-up/down       one screenful backward/forward

    CTRL-@              insert previously inserted text and stop insert
    CTRL-A              insert previously inserted text
    CTRL-B              toggle 'revins' (reverse insert) option
    CTRL-C              like <Esc>, but do not do an abbreviation
    CTRL-D              delete one shiftwidth of indent in front of the current line
0   CTRL-D              delete all indent in the current line
^   CTRL-D              delete all indent in the current line, restore indent in next line
    CTRL-E              insert the character from below the cursor
    CTRL-K {char1} {char2}  enter digraph
    CTRL-M or CTRL-J    begin new line
    CTRL-N              insert next match of identifier before the cursor
    CTRL-O {command}    execute {command}
    CTRL-P              insert previous match of identifier before the cursor
    CTRL-R <0-9a-z%:.-"> insert contents of register <0-9a-z%:.-">
    CTRL-T              insert one shiftwidth of indent in front of the current line
    CTRL-U              delete all entered characters in the current line
    CTRL-V <char>..     insert character literally, or enter decimal byte value
    CTRL-W              delete word before the cursor
    CTRL-X ...          complete the word before the cursor in various ways
    CTRL-Y              insert the character from above the cursor
.. @+node:ekr.20131105122124.16485: *5* complex
N  !{motion}{command}<CR>  filter the lines that are moved over through {command}
N  !!{command}<CR>         filter N lines through {command}
   {visual}!{command}<CR>  filter the highlighted lines through {command}
   :[range]! {command}<CR> filter [range] lines through {command}
N  ={motion}               filter the lines that are moved over through "indent"
N  ==                      filter N lines through "indent"
   {visual}=               filter the highlighted lines through "indent"
   
:[range]s[ubstitute]/{pattern}/{string}/[g][c]
:[range]s[ubstitute] [g][c]
   &         Repeat previous ":s" on current line without options
:[range]ret[ab][!] [tabstop]
.. @+node:ekr.20131105122124.16486: *5* text object
Used only in Visual mode or after an operator

a   Select current word
A   Select current WORD
s   Select current sentence
p   Select current paragraph
S   Select current block (from "[(" to "])")
P   Select current block (from "[{" to "]}")
.. @+node:ekr.20131105122124.16487: *5* offsets after search command
[num]       [num] lines downwards, in column 1
+[num]      [num] lines downwards, in column 1
-[num]      [num] lines upwards, in column 1
e[+num]     [num] characters to the right of the end of the match
e[-num]     [num] characters to the left of the end of the match
s[+num]     [num] characters to the right of the start of the match
s[-num]     [num] characters to the left of the start of the match
b[+num]     [num] characters to the right of the start (begin) of the match
b[-num]     [num] characters to the left of the start (begin) of the match
;{search command}   execute {search command} next

Examples

/test/+1		one line below "test", in column 1
/test/e		on the last t of "test"
/test/s+2		on the 's' of "test"
/test/b-3		three characters before "test"
.. @+node:ekr.20131105122124.16488: *5* Examples
:%g/^a/-1join     join lines starting with character 'a' to previous line
:%g/^ *$/d        delete empty lines
:%v/vim/m 1       move lines not matching the word 'vim' to line 1
:%g/^a/+1d        delete lines after the ones starting with character 'a'

:so[urce] {file}    Read Ex commands from {file}.
:so[urce]! {file}   Read Vim commands from {file}.
:sl[eep] [N]        don't do anything for N seconds
.. @+node:ekr.20131105122124.16489: *5* Options overview
name       short name   explanation
----       ----------   -----------
aleph          al       ASCII code of the letter Aleph (RIGHTLEFT)
autoindent     ai       take indent for new line from previous line
autowrite      aw       automatically write file if changed
backspace      bs       how backspace works at start of line
backup         bk       keep backup file after overwriting a file
backupdir      bdir     list of directories for the backup file
backupext      bex      extension used for the backup file
binary         bin      edit binary file mode
bioskey        biosk    MS-DOS: use bios calls for input characters
breakat        brk      characters that may cause a line break
cindent        cin      do C program indenting
cinkeys        cink     keys that trigger indent when 'cindent' is set
cinoptions     cino     how to do indenting when 'cindent' is set
cinwords       cinw     words where 'si' and 'cin' add an indent
cmdheight      ch       number of lines to use for the command-line
columns        co       number of columns in the display
comments       com      patterns that can start a comment line
compatible     cp       behave Vi-compatibly as much as possible
cpoptions      cpo      flags for Vi-compatible behaviour
define         def      pattern to be used to find a macro definition
dictionary     dict     list of filenames used for keyword completion
digraph        dg       enable the entering of digraphs in Insert mode
directory      dir      list of directory names for the swapfile
edcompatible   ed       toggle flags of ":substitute" command
endofline      eol      write end-of-line for last line in file
equalalways    ea       windows are automatically made the same size
equalprg       ep       external program to use for "=" command
errorbells     eb       ring the bell for error messages
errorfile      ef       name of the error file for the QuickFix mode
errorformat    efm      description of the lines in the error file
esckeys        ek       recognize function keys in Insert mode
expandtab      et       use spaces when <Tab> is inserted
exrc                    read .vimrc and .exrc in the current directory
formatoptions  fo       how automatic formatting is to be done
formatprg      fp       name of external program used with "gq" command
gdefault       gd       the ":substitute" flag 'g' is default on
guifont        gfn      GUI: Name(s) of font(s) to be used
guioptions     go       GUI: Which components and options are used
guipty                  GUI: try to use a pseudo-tty for ":!" commands
helpfile       hf       name of this help file
helpheight     hh       minimum height of a new help window
hidden         hid      don't unload buffer when it is abandoned
highlight      hl       sets highlighting mode for various occasions
history        hi       number of command-lines that are remembered
hkmap          hk       Hebrew keyboard mapping (RIGHTLEFT)
icon                    set icon of the window to the name of the file
ignorecase     ic       ignore case in search patterns
include        inc      pattern to be used to find an include file
incsearch      is       highlight match while typing search pattern
infercase      inf      adjust case of match for keyword completion
insertmode     im       start the edit of a file in Insert mode
isfname        isf      characters included in filenames and pathnames
isident        isi      characters included in identifiers
isprint        isp      printable characters
iskeyword      isk      characters included in keywords
joinspaces     js       two spaces after a period with a join command
keywordprg     kp       program to use for the "K" command
langmap        lmap     alphabetic characters for other language mode
laststatus     ls       tells when last window has status lines
linebreak      lbr      wrap long lines at a blank
lines                   number of lines in the display
lisp                    automatic indenting for Lisp
list                    show <Tab> and end-of-line
magic                   changes special characters in search patterns
makeprg        mp       program to use for the ":make" command
maxmapdepth    mmd      maximum recursive depth for mapping
maxmem         mm       maximum memory (in Kbyte) used for one buffer
maxmemtot      mmt      maximum memory (in Kbyte) used for all buffers
modeline       ml       recognize modelines at start or end of file
modelines      mls      number of lines checked for modelines
modified       mod      buffer has been modified
more                    pause listings when the whole screen is filled
mouse                   enable the use of mouse clicks
mousetime      mouset   max time between mouse double-click
number         nu       print the line number in front of each line
paragraphs     para     nroff macros that separate paragraphs
paste                   allow pasting text
patchmode      pm       keep the oldest version of a file
path           pa       list of directories searched with "gf" et.al.
readonly       ro       disallow writing the buffer
remap                   allow mappings to work recursively
report                  threshold for reporting nr. of lines changed
restorescreen  rs       Win32: restore screen when exiting
revins         ri       inserting characters will work backwards
rightleft      rl       window is right-to-left oriented (RIGHTLEFT)
ruler          ru       show cursor line and column in the status line
scroll         scr      lines to scroll with CTRL-U and CTRL-D
scrolljump     sj       minimum number of lines to scroll
scrolloff      so       minimum nr. of lines above and below cursor
sections       sect     nroff macros that separate sections
secure                  secure mode for reading .vimrc in current dir
shell          sh       name of shell to use for external commands
shellcmdflag   shcf     flag to shell to execute one command
shellpipe      sp       string to put output of ":make" in error file
shellquote     shq      quote character(s) for around shell command
shellredir     srr      string to put output of filter in a temp file
shelltype      st       Amiga: influences how to use a shell
shiftround     sr       round indent to multiple of shiftwidth
shiftwidth     sw       number of spaces to use for (auto)indent step
shortmess      shm      list of flags, reduce length of messages
shortname      sn       non-MS-DOS: File names assumed to be 8.3 chars
showbreak      sbr      string to use at the start of wrapped lines
showcmd        sc       show (partial) command in status line
showmatch      sm       briefly jump to matching bracket if insert one
showmode       smd      message on status line to show current mode
sidescroll     ss       minimum number of columns to scroll horizontal
smartcase      scs      no ignore case when pattern has uppercase
smartindent    si       smart autoindenting for C programs. For perl
                        script editing set this option and the following
                        key mapping: inoremap # x<BS># 
smarttab       sta      use 'shiftwidth' when inserting <Tab>
splitbelow     sb       new window from split is below the current one
startofline    sol      commands move cursor to first blank in line
suffixes       su       suffixes that are ignored with multiple match
swapsync       sws      how to sync swapfile
tabstop        ts       number of spaces that <Tab> in file uses
taglength      tl       number of significant characters for a tag
tagrelative    tr       filenames in tag file are relative
tags           tag      list of filenames used by the tag command
term                    name of the terminal
terse                   shorten some messages
textauto       ta       set 'textmode' automatically when reading file
textmode       tx       lines are separated by <CR><NL>
textwidth      tw       maximum width of text that is being inserted
tildeop        top      tilde command "~" behaves like an operator
timeout        to       time out on mappings and key codes
ttimeout                time out on mappings
timeoutlen     tm       time out time in milliseconds
ttimeoutlen    ttm      time out time for key codes in milliseconds
title                   set title of window to the name of the file
ttybuiltin     tbi      use built-in termcap before external termcap
ttyfast        tf       indicates a fast terminal connection
ttyscroll      tsl      maximum number of lines for a scroll
ttytype        tty      alias for 'term'
undolevels     ul       maximum number of changes that can be undone
updatecount    uc       after this many characters flush swapfile
updatetime     ut       after this many milliseconds flush swapfile
viminfo        vi       use .viminfo file upon startup and exiting
visualbell     vb       use visual bell instead of beeping
warn                    warn for shell command when buffer was changed
weirdinvert    wi       for terminals that have weird inversion method
whichwrap      ww       allow specified keys to cross line boundaries
wildchar       wc       command-line character for wildcard expansion
winheight      wh       minimum number of lines for the current window
wrap                    long lines wrap and continue on the next line
wrapmargin     wm       chars from the right where wrapping starts
wrapscan       ws       searches wrap around the end of the file
writeany       wa       write to file with no need for "!" override
writebackup    wb       make a backup before overwriting a file
writedelay     wd       delay this many msec for each char (for debug)
.. @+node:ekr.20131105122124.16490: *5* Command-line completion
'wildchar' (default: <Tab>)
    do completion on the pattern in front of the cursor. If there are
    multiple matches, beep and show the first one; further 'wildchar' will
    show the next ones.
                   
CTRL-A  insert all names that match pattern in front of cursor
CTRL-D  list   all names that match the pattern in front of the cursor
CTRL-L  insert longest common part of names that match pattern
CTRL-N  after 'wildchar' with multiple matches: go to next match
CTRL-P  after 'wildchar' with multiple matches: go to previous match
.. @+node:ekr.20131105122124.16491: *5* Special Ex characters
|           separates two commands (not for ":global" and ":!")
"           begins comment

%           current filename (only where filename is expected)
#[number]   alternate filename [number] (only where filename is expected)

Note: The next four are typed literally; these are not special keys!

<cword>     word under the cursor (only where filename is expected)
<cWORD>     WORD under the cursor (only where filename is expected)
<cfile>     file name under the cursor (only where filename is expected)
<afile>     file name for autocommand (only where filename is expected)

After "%", "#", "<cfile>", or "<afile>"
:p          full path
:h          head
:t          tail
:r          root
:e          extension
.. @+node:ekr.20131105122124.16492: *5* Ex ranges
,               separates two line numbers
;               idem, set cursor to the first line number
                before interpreting the second one
{number}        an absolute line number
.               the current line
$               the last line in the file
%               equal to 1,$ (the entire file)
*               equal to '<,'> (visual area)
't              position of mark t
/{pattern}[/]   the next line where {pattern} matches
?{pattern}[?]   the previous line where {pattern} matches
+[num]          add [num] to the preceding line number (default: 1)
-[num]          subtract [num] from the preceding line number (default: 1)
.. @+node:ekr.20131105122124.16493: *5* Starting vim
38 -- Starting VIM


vim [options]                start editing with an empty buffer
vim [options] {file ..}      start editing one or more files
vim [options] -t {tag}       edit the file associated with {tag}
vim [options] -e [fname]     start editing in QuickFix mode, display the first error


39 -- Vim Command Line Arguments


-g                  start GUI (also allows other options)

+[num]              put the cursor at line [num] (default: last line)
+{command}          execute {command} after loading the file
+/{pat} {file ..}   put the cursor at the first occurrence of {pat}
-v                  read-only mode (View), implies -n
-R                  read-only mode, same as -v
-b                  binary mode
-l                  lisp mode
-H                  Hebrew mode ('hkmap' and 'rightleft' are set)
-r                  give list of swap files
-r {file ..}        recover aborted edit session
-n                  do not create swapfile
-o [N]              open N windows (default: one for each file)
-x                  Amiga: do not restart VIM to open a window (for
                        e.g., mail)
-s {scriptin}       first read commands from the file {scriptin}
-w {scriptout}      write typed chars to file {scriptout} (append)
-W {scriptout}      write typed chars to file {scriptout} (overwrite)
-T {terminal}       set terminal name
-d {device}         Amiga: open {device} to be used as a console
-u {vimrc}          read inits from {vimrc} instead of other inits
-i {viminfo}        read info from {viminfo} instead of other files
--                  end of options, other arguments are file names

Automatic option setting when editing a file

vim:{set-arg}: ..       In the first and last lines of the
                        file (see 'ml' option), {set-arg} is
                        given as an argument to ":set"
                        
Automatic execution of commands on certain events.

:au                     List all autocommands
:au {event}             List all autocommands for {event}
:au {event} {pat}       List all autocommands for {event} with {pat}
:au {event} {pat} {cmd} Enter new autocommands for {event} with {pat}
:au!                    Remove all autocommands
:au! {event}            Remove all autocommands for {event}
:au! * {pat}            Remove all autocommands for {pat}
:au! {event} {pat}      Remove all autocommands for {event} with {pat}
:au! {event} {pat} {cmd}  Remove all autocommands for {event} with {pat} and enter new one
.. @+node:ekr.20131105122124.16494: *5* : commands unsorted
:marks                  print the active marks
:ju[mps]                print the jump list
:ta[g][!] {tag}         Jump to tag {tag}
:[count]ta[g][!]        Jump to [count]'th newer tag in tag list
:[count]po[p][!]        Jump back from [count]'th older tag in tag list
:tags                   Print tag list
:dig[raphs]                                 show current list of digraphs
:dig[raphs] {char1}{char2} {number} ...     add digraph(s) to the list
:r [file]               insert the contents of [file] below the cursor
:r! {command}           insert the standard output of {command} below the cursor
:[range]d [x]           delete [range] lines [into register x]
:reg                    show the contents of all registers
:reg {arg}              show the contents of registers mentioned in {arg}
:[range]ce[nter] [width] center the lines in [range]
:[range]le[ft] [indent]  left-align the lines in [range] [with indent]
:[range]ri[ght] [width]  right-align the lines in [range]
:@<a-z>                 execute the contents of register <a-z> as an Ex command
:@@                     repeat previous :@<a-z>
:[range]g[lobal]/{pattern}/[cmd] 
:[range]g[lobal]!/{pattern}/[cmd]     or    :[range]v/{pattern}/[cmd]
:ma[p] {lhs} {rhs}          Map {lhs} to {rhs} in Normal and Visual mode.
:ma[p]! {lhs} {rhs}         Map {lhs} to {rhs} in Insert and Command-line mode.
:no[remap][!] {lhs} {rhs}   Same as ":map", no remapping for this {rhs}
:unm[ap] {lhs}              Remove the mapping of {lhs} for Normal and Visual mode.
:unm[ap]! {lhs}             Remove the mapping of {lhs} for Insert and Command-line mode.
:ma[p] [lhs]         List mappings (starting with [lhs]) for Normal and Visual mode.
:ma[p]! [lhs]        List mappings (starting with [lhs]) for Insert and Command-line mode.
:cmap/:cunmap/:cnoremap 
:imap/:iunmap/:inoremap
:nmap/:nunmap/:nnoremap
:vmap/:vunmap/:vnoremap
:mk[exrc][!] [file]  write current mappings, abbreviations, and settings to [file] (default: ".exrc"; use ! to overwrite)
:mkv[imrc][!] [file] same as ":mkexrc", but with default ".vimrc"
:mapc[lear]          remove mappings for Normal and Visual mode
:mapc[lear]!         remove mappings for Insert and Cmdline mode
:imapc[lear]         remove mappings for Insert mode
:vmapc[lear]         remove mappings for Visual mode
:nmapc[lear]         remove mappings for Normal mode
:cmapc[lear]         remove mappings for Cmdline mode

:ab[breviate] {lhs} {rhs}  add abbreviation for {lhs} to {rhs}
:ab[breviate] {lhs}        show abbr's that start with {lhs}
:ab[breviate]              show all abbreviations
:una[bbreviate] {lhs}      remove abbreviation for {lhs}
:norea[bbrev] [lhs] [rhs]  like ":ab", but don't remap [rhs]
:iab/:iunab/:inoreab       like ":ab", but only for Insert mode
:cab/:cunab/:cnoreab       like ":ab", but only for Command-line mode
:abc[lear]                 remove all abbreviations
:cabc[lear]                remove all abbr's for Cmdline mode
:iabc[lear]                remove all abbr's for Insert mode
:se[t]                  Show all modified options.
:se[t] all              Show all options.
:se[t] {option}         Set toggle option on, show string or number option.
:se[t] no{option}       Set toggle option off.
:se[t] inv{option}      invert toggle option.
:se[t] {option}={value} Set string or number option to {value}.
:se[t] {option}?        Show value of {option}.
:se[t] {option}&        Reset {option} to its default value.
:fix[del]               Set value of 't_kD' according to value of 't_kb'.
:sh[ell]        start a shell
:!{command}     execute {command} with a shell
:cc [nr]        display error [nr] (default is the same again)
:cn             display the next error
:cp             display the previous error
:cl             list all errors
:cf             read errors from the file 'errorfile'
:cq             quit without writing and return error code (to the compiler)
:make [args]    start make, read errors, and jump to first error
:ve[rsion]      show exact version number of this Vim
:mode N         MS-DOS: set screen mode to N (number, C80, C4350, etc.)
:norm[al][!] {commands} Execute Normal mode commands.
:e[dit]              Edit the current file, unless changes have been made.
:e[dit]!             Edit the current file always.  Discard any changes.
:e[dit] {file}       Edit {file}, unless changes have been made.
:e[dit]! {file}      Edit {file} always.  Discard any changes.
:pwd                 Print the current directory name.
:cd [path]           Change the current directory to [path].
:f[ile]              Print the current filename and the cursor position.
:f[ile] {name}       Set the current filename to {name}.
:files               Show alternate filenames.

:argu[ment] N       edit file N
:n[ext]             edit next file
:n[ext] {arglist}   define new arg list and edit first file
:N[ext]             edit previous file
:rew[ind][!]        edit first file
:last               edit last file
:sar[gument] N      edit file N (new window)
:sn[ext]            edit next file (new window)
:sn[ext] {arglist}  define new arg list and edit first file (new window)
:sN[ext]            Edit previous file (new window)
:srew[ind]          Edit first file (new window)
:slast              Edit last file (new window)


:ar[gs]              Print the argument list, with the current file in "[]".
:all  or :sall       Open a window for every file in the arg list.
:wn[ext][!]          Write file and edit next file.
:wn[ext][!] {file}   Write to {file} and edit next file, unless {file} exists.  With !, overwrite existing file.
:wN[ext][!] [file]   Write file and edit previous file.
:[range]w[rite][!]            Write to the current file.
:[range]w[rite] {file}        Write to {file}, unless it already exists.
:[range]w[rite]! {file}       Write to {file}.  Overwrite an existing file.
:[range]w[rite][!] >>         Append to the current file.
:[range]w[rite][!] >> {file}  Append to {file}.
:[range]w[rite] !{cmd}        Execute {cmd} with [range] lines as standard input.
:wall[!]                      write all changed buffers

:q[uit]               Quit current buffer.
:q[uit]!              Quit current buffer always.
:qall                 Exit Vim, unless changes have been made.
:qall!                Exit Vim always, discard any changes.
:cq                   Quit without writing and return error code.

:wq[!]                Write the current file and exit.
:wq[!] {file}         Write to {file} and exit.
:x[it][!] [file]      Like ":wq" but write only when changes have been made
:xall[!]  or :wqall[!]  Write all changed buffers and exit
:st[op][!]              Suspend VIM or start new shell. If 'aw' option is set and [!] not given write the buffer.

:rv[iminfo] [file]      Read info from viminfo file [file]
:rv[iminfo]! [file]     idem, overwrite exisiting info
:wv[iminfo] [file]      Add info to viminfo file [file]
:wv[iminfo]! [file]     Write info to viminfo file [file]

:split                  Split window into two parts
:split {file}           Split window and edit {file} in one of them

:buffers  or  :files    list all known buffer and file names
:ball     or  :sball    edit all args/buffers
:unhide   or  :sunhide  edit all loaded buffers

:bunload[!] [N]         unload buffer [N] from memory
:bdelete[!] [N]         unload buffer [N] and delete it from the buffer list

:[N]buffer [N]      to arg/buf N
:[N]bnext [N]       to Nth next arg/buf
:[N]bNext [N]       to Nth previous arg/buf
:[N]bprevious [N]   to Nth previous arg/buf
:brewind            to first arg/buf
:blast              to last arg/buf
:[N]bmod [N]        to Nth modified buf

:[N]sbuffer [N]     to arg/buf N (in new window)
:[N]sbnext [N]      to Nth next arg/buf (in new window)
:[N]sbNext [N]      to Nth previous arg/buf (in new window)
:[N]sbprevious [N]  to Nth previous arg/buf (in new window)
:sbrewind           to first arg/buf (in new window)
:sblast             to last arg/buf (in new window)
:[N]sbmod [N]       to Nth modified buf (in new window)
.. @+node:ekr.20131105122124.16495: *5* : commands merged (do not sort!)
:!{command}                     execute {command} with a shell
:@<a-z>                         execute the contents of register <a-z> as an Ex command
:@@                             repeat previous :@<a-z>
:N[ext]                         edit previous file
:ab[breviate]                   show all abbreviations
:ab[breviate] {lhs}             show abbr's that start with {lhs}
:ab[breviate] {lhs} {rhs}       add abbreviation for {lhs} to {rhs}
:abc[lear]                      remove all abbreviations
:all  or :sall                  open a window for every file in the arg list.
:ar[gs]                         print the argument list, with the current file in "[]".
:argu[ment] N                   edit file N
:[N]bNext [N]                   to Nth previous arg/buf
:ball     or  :sball            edit all args/buffers
:bdelete[!] [N]                 unload buffer [N] and delete it from the buffer list
:blast                          to last arg/buf
:[N]bmod [N]                    to Nth modified buf
:[N]bnext [N]                   to Nth next arg/buf
:[N]bprevious [N]               to Nth previous arg/buf
:[N]buffer [N]                  to arg/buf N
:brewind                        to first arg/buf
:buffers  or  :files            list all known buffer and file names
:bunload[!] [N]                 unload buffer [N] from memory
:cab/:cunab/:cnoreab            like ":ab", but only for Command-line mode
:cabc[lear]                     remove all abbr's for Cmdline mode
:cc [nr]                        display error [nr] (default is the same again)
:cd [path]                      change the current directory to [path].
:[range]ce[nter] [width]        center the lines in [range]
:cf                             read errors from the file 'errorfile'
:cl                             list all errors
:cmap/:cunmap/:cnoremap 
:cmapc[lear]                    remove mappings for Cmdline mode
:cn                             display the next error
:cp                             display the previous error
:cq                             quit without writing and return error code.
:cq                             quit without writing and return error code (to the compiler)
:[range]d [x]                   delete [range] lines [into register x]
:dig[raphs]                     show current list of digraphs
:dig[raphs] {char1}{char2} {number} ...     add digraph(s) to the list
:e[dit]                         edit the current file, unless changes have been made.
:e[dit] {file}                  edit {file}, unless changes have been made.
:e[dit]!                        edit the current file always.  Discard any changes.
:e[dit]! {file}                 edit {file} always.  Discard any changes.
:f[ile]                         print the current filename and the cursor position.
:f[ile] {name}                  set the current filename to {name}.
:files                          show alternate filenames.
:fix[del]                       set value of 't_kD' according to value of 't_kb'.
:[range]g[lobal]!/{pattern}/[cmd]
:[range]g[lobal]/{pattern}/[cmd] 
:iab/:iunab/:inoreab            like ":ab", but only for Insert mode
:iabc[lear]                     remove all abbr's for Insert mode
:imap/:iunmap/:inoremap
:imapc[lear]                    remove mappings for Insert mode
:ju[mps]                        print the jump list
:last                           edit last file
:[range]le[ft] [indent]         left-align the lines in [range] [with indent]
:ma[p] [lhs]                    list mappings (starting with [lhs]) for Normal and Visual mode.
:ma[p] {lhs} {rhs}              map {lhs} to {rhs} in Normal and Visual mode.
:ma[p]! [lhs]                   list mappings (starting with [lhs]) for Insert and Command-line mode.
:ma[p]! {lhs} {rhs}             map {lhs} to {rhs} in Insert and Command-line mode.
:make [args]                    start make, read errors, and jump to first error
:mapc[lear]                     remove mappings for Normal and Visual mode
:mapc[lear]!                    remove mappings for Insert and Cmdline mode
:marks                          print the active marks
:mk[exrc][!] [file]             write current mappings, abbreviations, and settings to [file] (default: ".exrc"; use ! to overwrite)
:mkv[imrc][!] [file]            same as ":mkexrc", but with default ".vimrc"
:mode N                         MS-DOS: set screen mode to N (number, C80, C4350, etc.)
:n[ext]                         edit next file
:n[ext] {arglist}               define new arg list and edit first file
:nmap/:nunmap/:nnoremap
:nmapc[lear]                    remove mappings for Normal mode
:no[remap][!] {lhs} {rhs}       same as ":map", no remapping for this {rhs}
:norea[bbrev] [lhs] [rhs]       like ":ab", but don't remap [rhs]
:norm[al][!] {commands}         execute Normal mode commands.
:[count]po[p][!]                jump back from [count]'th older tag in tag list
:pwd                            print the current directory name.
:q[uit]                         quit current buffer.
:q[uit]!                        quit current buffer always.
:qall                           exit Vim, unless changes have been made.
:qall!                          exit Vim always, discard any changes.
:r [file]                       insert the contents of [file] below the cursor
:r! {command}                   insert the standard output of {command} below the cursor
:reg                            show the contents of all registers
:reg {arg}                      show the contents of registers mentioned in {arg}
:rew[ind][!]                    edit first file
:[range]ri[ght] [width]         right-align the lines in [range]
:rv[iminfo] [file]              read info from viminfo file [file]
:rv[iminfo]! [file]             idem, overwrite exisiting info
:sN[ext]                        edit previous file (new window)
:sar[gument] N                  edit file N (new window)
:sblast                         to last arg/buf (in new window)
:[N]sbNext [N]                  to Nth previous arg/buf (in new window)
:[N]sbmod [N]                   to Nth modified buf (in new window)
:[N]sbnext [N]                  to Nth next arg/buf (in new window)
:[N]sbprevious [N]              to Nth previous arg/buf (in new window)
:[N]sbuffer [N]                 to arg/buf N (in new window)
:sbrewind                       to first arg/buf (in new window)
:se[t]                          show all modified options.
:se[t] all                      show all options.
:se[t] inv{option}              invert toggle option.
:se[t] no{option}               set toggle option off.
:se[t] {option}                 set toggle option on, show string or number option.
:se[t] {option}&                reset {option} to its default value.
:se[t] {option}={value}         set string or number option to {value}.
:se[t] {option}?                show value of {option}.
:sh[ell]                        start a shell
:slast                          edit last file (new window)
:sn[ext]                        edit next file (new window)
:sn[ext] {arglist}              define new arg list and edit first file (new window)
:split                          Split window into two parts
:split {file}                   Split window and edit {file} in one of them
:srew[ind]                      Edit first file (new window)
:st[op][!]                      Suspend VIM or start new shell. If 'aw' option is set and [!] not given write the buffer.
:[count]ta[g][!]                jump to [count]'th newer tag in tag list
:ta[g][!] {tag}                 jump to tag {tag}
:tags                           print tag list
:una[bbreviate] {lhs}           remove abbreviation for {lhs}
:unhide   or  :sunhide          edit all loaded buffers
:unm[ap] {lhs}                  remove the mapping of {lhs} for Normal and Visual mode.
:unm[ap]! {lhs}                 remove the mapping of {lhs} for Insert and Command-line mode.
:[range]v/{pattern}/[cmd]
:ve[rsion]                      show exact version number of this Vim
:vmap/:vunmap/:vnoremap
:vmapc[lear]                    remove mappings for Visual mode
:[range]w[rite] !{cmd}          execute {cmd} with [range] lines as standard input.
:[range]w[rite] {file}          write to {file}, unless it already exists.
:[range]w[rite]! {file}         write to {file}.  Overwrite an existing file.
:[range]w[rite][!]              write to the current file.
:[range]w[rite][!] >>           append to the current file.
:[range]w[rite][!] >> {file}    append to {file}.
:wN[ext][!] [file]              write file and edit previous file.
:wall[!]                        write all changed buffers
:wn[ext][!]                     write file and edit next file.
:wn[ext][!] {file}              write to {file} and edit next file, unless {file} exists.  With !, overwrite existing file.
:wq[!]                          write the current file and exit.
:wq[!] {file}                   write to {file} and exit.
:wv[iminfo] [file]              add info to viminfo file [file]
:wv[iminfo]! [file]             write info to viminfo file [file]
:x[it][!] [file]                like ":wq" but write only when changes have been made
:xall[!]  or :wqall[!]          Write all changed buffers and exit
.. @+node:ekr.20040123102724: *3* zz Can't or won't do
@language rest
.. @+node:ekr.20140824043305.18296: *4* Can't do
These are known bugs that probably can't be fixed.
.. @+node:ekr.20111011062533.15693: *5* Make headline widgets scrollable
# It doesn't seem easy.

Related nodes:
editLabelHelper (leoQtTree)
.. @+node:ekr.20031218072017.670: *5* Possible webbrowser bug
(In Linux) The home page and online tutorial options in the menu only work
properly if Mozilla window is already open. If not, a Mozilla window opens, but
with empty page and url field.
.. @+node:ekr.20050202073944: *5* Mac bugs
.. @+node:ekr.20050201175325.2: *6* Can't delete script buttons
.. @+node:ekr.20050201175325.1: *6* Icon buttons are not colored, nor do they have square borders, etc.
.. @+node:ekr.20110111100539.12257: *6* Fix end-of-line problem (MacOS)
Apparently, ctrl-e is not passed to Leo at all.

This probably can't be fixed.
.. @+node:ekr.20110111100539.12258: *7* Report
http://mail.google.com/mail/#inbox/12c5646c646a90d2

I expect C-e to go to end-of-line, but C-e works as the next line.
Alt-x and check end-of-line and I get the following result.

I use Mac OS X 10.6.5, newest Leo, and Python/Qt.

Leo 4.8 rc1, build 3715, November 15, 2010
Python 2.6.1, qt version 4.7.0
darwin

I remember I could use C-e, but it doesn't work anymore even after I
reinstall the Leo.

As I explained in this post - http://groups.google.com/group/leo-editor/browse_thread/thread/1ee0b35b4f76c999
After having @bool swap_mac_keys = True, I can use C-e.

C-a move the cursor to the start of line, but C-e seems to move the
cursor the first of the next line, which is the end of last line + 1.
If the line is the final one, C-e moves the cursor to the end of line
as there's no next line.

.. @+node:ekr.20031218072017.673: *5* Tk bugs
The following bugs can not be fixed because they are Tk bugs.

These bugs are becoming moot: Tk will soon be deprecated.
.. @+node:ekr.20081208102356.1: *6* Threading colorizer doesn't handle multiple body editors
http://groups.google.com/group/leo-editor/browse_thread/thread/5be7a099b299327e

> Tk only colorizes one body editor, and if you delete that editor it
> colorizes no editor.

Thanks for this report.  This is a problem, never noticed until now,
with the threading colorizer.  A workaround is to disable the
threading colorizer plugin. 
.. @+node:ekr.20041201071145: *6* Tk Freezes on debean when libtk is compiled with thread support
http://sourceforge.net/forum/message.php?msg_id=2876797
By: skal

By: Grossé Pascal - skal
RE: Leo freezing up  
2004-12-01 06:15

The freezing problem on debian sid (which is also my current OS) is caused by a bug in Tkinter: Tkinter does not work when libtk is compiled with thread support, which is the case on debian sid for tk8.4 
I compiled my own non-threaded libtk with the corresponding python/tkinter, and the freeze magically vanished.  

This is a known bug in debian bugtrack: 

http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=171353 

Skal
.. @+node:EKR.20040523192553: *6* (Crash when pasting large text into headlines)
.. @+node:EKR.20040606104355: *7* Report
@nocolor

From: <eltronic@juno.com>
To: <edreamleo@charter.net>
Sent: Sunday, May 23, 2004 9:36 AM
Subject: fatal bug in Leo headline handling


> found a fatal bug in Leo headline handling.
> not sure if anyone reported before,
> an oversize string can crash python 2.3.3
> 
> 
> the text was about 4500 bytes. nothing but text.
> opened the  leo again, copy a large page of text,
> insert headline, paste, fatal error in python.
> 
> I have by mistake pasted whatever node xml was in 
> the copy buffer into a headline w/o problem.
> but that was just dumb luck. just verified,
> had the node been large enough it crashes.
> 
> Leo 4.1 final, py2.3.3 win98
> PYTHON caused an invalid page fault in
> module TK84.DLL at 0167:1022b74f.
> 
> Leo 4.1 final, py2.2 win98
> paste a 15k node copy into headline. no problem.
> 
> this is the first repeatable hard crash I've stumbled on
> and thought it best to report it privately.
> I can think of no advantage to allowing a headline 
> of this size anyway. think of the tooltip that would create!
> 
> there are latent bugs in the selectall and delete from 
> the edit menu related to headline as well on the todo list.
> reported many times. 
> covert destruction of the selected body text.
> use of virtual events, with out proper focus to headline.
> 
> without myself being able to supply a patch, I'll guess,
> the virtual event paste called can as well point 
> to a function that checks the size before pasting.
> or simply sets the headline directly with 
> g.app.gui.getTextFromClipboard()[:1024]
> 
> 
> e
.. @+node:ekr.20031218072017.674: *6* Caps lock affects keyboard shortcuts on Windows
Using leo under Windows, the keyboard shortcuts seem to use the "Caps Lock" state in determining the shift state when executing a shortcut.   For example, if the caps-lock key is on, then Ctrl-X is interpreted as Shift-Ctrl-X and cuts a node rather than selected text, and Shift-Ctrl-X is interpreted as Ctrl-X and cuts text.
.. @+node:ekr.20031218072017.675: *6* Tree problems
1. The border of the tree control is gray, and it is overwritten with large headlines.  This may be a Tk or Tkinter bug.

2. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this glitch because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.
.. @+node:ekr.20031218072017.676: *6* Control-T can't be overridden in canvas text.
.. @+node:ekr.20031218072017.677: *6* (Alt-ctrl = Alt)
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1765069
By: dalcolmo

I use the bindings that come with Leo:

[keyboard shortcuts]
pastenode = Shift+Ctrl+V
gonextvisible = Alt+DnArrow
importtofile = Shift+Ctrl+F
writefilenodes = Shift+Ctrl+W
editheadline = Ctrl+H
markchangeditems = Alt+C
replace = Ctrl+=
goprevvisible = Alt+UpArrow
gotonextmarked = Alt+M
readoutlineonly = Shift+Ctrl+R
extractnames = Shift+Ctrl+N
gonext = Alt+Shift+DnArrow
findpanel = Ctrl+F
close = Ctrl+W
demote = Ctrl+}
tangle = Shift+Ctrl+T
extract = Shift+Ctrl+D
openpythonwindow = Alt+P
marksubheads = Alt+S
saveas = Shift+Ctrl+S
cut = Ctrl+X
preferences = Ctrl+Y
equalsizedpanes = Ctrl+E
cantundo = Ctrl+Z
open = Ctrl+O
promote = Ctrl+{
sortsiblings = Alt-A
unmarkall = Alt+U
mark = Ctrl+M
showinvisibles = Alt+V
exit = Ctrl-Q
insertnode = Ctrl+I
findprevious = F4
converttabs = Shift+Ctrl+J
save = Ctrl+S
tanglemarked = Shift+Ctrl+M
moveup = Ctrl+U
copynode = Shift+Ctrl+C
contractparent = Alt+0
selectall = Ctrl+A
setfont = Alt+Shift+T
aborteditheadline = Shift+Esc
goback = Alt+Shift+UpArrow
toggleactivepane = Ctrl+T
findnext = F3
tangleall = Shift+Ctrl+A
endeditheadline = Esc
deletenode = Shift+Ctrl+BkSp
cantredo = Shift+Ctrl+Z
new = Ctrl+N
contractall = Alt+1
moveleft = Ctrl+L
copy = Ctrl+C
paste = Ctrl+V
convertblanks = Shift+Ctrl+B
expandall = Alt+9
markchangedroots = Alt+R
cutnode = Shift+Ctrl+X
indent = Ctrl+]
gotonextchanged = Alt+D
expandnextlevel = Alt+=
setcolors = Alt+Shift+S
matchbrackets = Ctrl+K
movedown = Ctrl+D
clonenode = Ctrl+`
untangle = Shift+Ctrl+U
expandtolevel7 = Alt+7
expandtolevel6 = Alt+6
expandtolevel5 = Alt+5
expandtolevel4 = Alt+4
expandtolevel3 = Alt+3
expandtolevel2 = Alt+2
moveright = Ctrl+R
unindent = Ctrl+[
replacethenfind = Ctrl+-
extractsection = Shift+Ctrl+E
expandtolevel8 = Alt+8


However, I use a utility called AllChars (Free as in beer :-(  ) to be able
to type all kinds of chars on my US keyboard, and "Handything" to place the
windows on the screen (Win2000). Perhaps this makes a difference, although disabling
them did not seem to make it go away. Still, on pressing alt+ctrl+uparrow I
end up at the next upper node etc...

- Josef

.. @+node:ekr.20031218072017.718: *6* (tab bug)
.. @+node:ekr.20040117092727: *7* This is definitely a Tk bug
By: dthein ( Dave Hein ) 
 RE: BUG: Non-leading tabs not working properl   
2004-01-17 14:40  

 This seems to be a TK bug. I've reproduced the problem directly in Tk.

It's been around for a long time :-(

More details on this page, along with a patch for an earlier version.

http://www.qs.co.nz/Tcl/TkTabs.html

The Tk folks fixed a bug I reported with Ctrl-V behavior, but it took about a year for them to get to it. I don't have high expectations with this problem either, but I'll probably put together a patch for some of the recent version of Tk and submit the patches and bug report.  
.. @+node:ekr.20040118090055: *7* Patch and bug report
https://sourceforge.net/forum/message.php?msg_id=2380238
By: dthein

I've submitted a patch and bug report to the Tk project.

The patch, #879073, for those that want to fix this problem on their systems,
is at:

http://sourceforge.net/tracker/?func=detail&aid=879073&group_id=12997&atid=31299
7

And the bug report, #879077, is at:

http://sourceforge.net/tracker/?func=detail&aid=879077&group_id=12997&atid=11299
7

The patch is for 8.4.2.  If you have a different version, you can probably figure
out the changes needed by looking at the patch file.  If not, let me know your
version and I may be able to produce a patch for it.

Note: If you use tabs for anything other than leading whitespace, you will find
this patch really helpful.  I make lots of little tables when I'm documenting
or note-taking ... this fix really helped my sanity when making those tables
inside Leo.

Dave Hein
.. @+node:ekr.20031218072017.719: *7* Report
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1906790
By: dspeed
Open Discussion

-- Tabs are not expanded correctly in .c files, when language in preferences is set to c, and when the tabs occur in the middle of a line. The tabs are expanded as spaces until the next tab location is reached, then the tabs are expanded correctly. 
.. @+node:ekr.20040105070023.5: *7* Report 2
Leo 4.1 rc3, build 1.62 , December 19, 2003
Python 2.3.0, Tk 8.4.2
Linux 2.4.22-21mdkenterprise

1. Any tab typed before the first tab stop behaves correctly (the cursor is moved to the tab stop). Good.

2. Any tab typed after a non-tab character (even a space) _and_ after the first tab stop position doesn't behave like a tab and doesn't move the cursor to the next tab stop. Bad.

3. Any tab typed after a tab character will behave properly no matter what position on the line. Okay.

To reproduce this, set your global tab prefernence to 4. Show invisibles. And then create a node containing:

[BEGIN BODY TEXT]
@language plain
@tabwidth 8
[END BODY TEXT]

Create a child node to that one, containing:

[BEGIN BODY TEXT]
@root-code somefilename
\t\tThis works
bbb\tAnd This works
So\tdoes this

But, this \tdoes not.
Here is the two-tab \t\t behavior.
[END BODY TEXT]

I hope this is a Leo bug and not a Tk bug. 

Dave Hein 
.. @+node:ekr.20031218072017.720: *7* Minimal test
This is a test line.
.. @+node:ekr.20031218072017.721: *7* Test File for Non Expanding Tabs
This is a test line.
put the text insertion point in the space between 'a' and 'test' above. Enter 3 tabs in a row and watch it not work.

If your expansion works correctly, then maybe something with leoconfig?  But wait, Im using the leoconfig from the beta download.

The contents of my Log Windows when opening this file:

Leo Log Window...
Pyton 2.2.2, Tk 8.3.2
reading d:\test.leo


.. @+node:ekr.20031218072017.672: *6* Control-V doesn't work on Linux
This has been and continues to be a known issue with Tk. Has been logged as a
bug; no response from the Tk folks.

Here is a link to the Tk bug report: 

http://sourceforge.net/tracker/?func=detail&aid=605277&group_id=12997&atid=112997 

Note the work-around/patch in the followup post at the bottom of that page. Commenting out some statements in text.tcl removes the problem. 
.. @+node:ekr.20040220110030: *6* Change cursor when caps lock is down
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2431552
By: nobody

From: Rich

 I just got nipped twice by the following effect: the Caps-Lock key is ON, but
because the LED is on the Caps-Lock key, it is hidden behind my hand. I hit
Ctrl-x, expecting to cut my selection, but the entire node is cut.

   I know there's a problem with tk and the shift key status, so I'm wondering
if it would be possible to change the shape of the cursor when the Caps-Lock
is ON (preferrably a big red flashing blot 8-), or otherwise show that Caps-Lock
is active ( "CAPS" on a status line, for instance).

  Another way: I don't know if this goes against an "anti-modalism rule," but
only allowing Ctrl-Shift-x|c|v in the outline pane would also be acceptable
to me.
.. @+node:ekr.20040115165036: *5* bug in xml doc parts (hard to fix?)
@language html
@ignore
@color
.. @+node:ekr.20040115165036.1: *6* Demo XML comment bug
@ 
This document demonstrates what appears to be a bug in Leo 4.1 rc3, build 1.62 of December 19, 2003.

It has manifested when Leo is executed under Python 2.3.3, Tk 8.4.3 under Windows 2000.

In brief, derived XML files are not well-formed with respect to comments under some conditions.  Comments can wind up nested, which looks okay to humans but not to XML parsers.
@c
.. @+node:ekr.20040115165036.3: *6* @file xmlcommentbug.xml
@first
@language HTML
<HiMom>
@
This will produce, in the derived file, an XML comment with another XML comment
embedded. Or, if you prefer, it will produce an unclosed XML comment followed by
a well-formed one, followed by a string of text containing a comment-close
marker.

This text is sitting in the inner comment, according to the first view.
@c


@
This comment is well-formed, seemingly because its content does not begin on the
same line as the at-sign.
@c
</HiMom>
.. @+node:ekr.20040115165036.4: *6* xmlcommentbug.xml
<?xml version='1.0'?>
<!--@+leo-ver=4-->
<!--@+node:@file xmlcommentbug.xml-->
<!--@@first-->
<!--@@language HTML-->
<HiMom>
<!--@+at -->
<!--
<!--@nonl-->
This will produce, in the derived file, an XML comment with another XML 
comment embedded.  Or, if you prefer, it will produce an unclosed XML comment 
followed by a well-formed one, followed by a string of text containing a 
comment-close marker.

This text is sitting in the inner comment, according to the first view.
-->
<!--@-at-->
<!--@@c-->


<!--@+at-->
<!--
This comment is well-formed, seemingly because its content does not begin on 
the same line as the at-sign.
-->
<!--@-at-->
<!--@@c-->
</HiMom>
<!--@nonl-->
<!--@-node:@file xmlcommentbug.xml-->
<!--@-leo-->
.. @+node:ekr.20110619173515.14896: *5* Wrong modality level on autocompleter
Just noticed the autocompleter pop-up is modal globally, not just for
the Leo windows.  Probably should only block the Leo windows.
.. @+node:ekr.20140824043305.18295: *4* Won't do
These items will not be done.  Most are bad ideas, imo.
.. @+node:ekr.20130919120947.12506: *5* * Why Leo won't be a web app
here are two reasons why Leo is unlikely ever to be a web app.

1. There are somewhere around a million lines of Python code in Leo's core
   and plugins. Thus, a *solid* python in javascript system is required.
   This isn't likely to happen.

2. Creating a Leo outline widget is extremely complex. Even starting with a
   working javascript outliner, one has to deal with events (commands)
   coming from Leo scripts rather than from the user.

These seem like the most important obstacles. There may be others, but these
suffice
.. @+node:ekr.20040216054459: *5* @h @f @endh and @endf directives
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2424151
By: ksejlod ( Peter Barrel ) 
 I Have a (maybe) great idea!   
2004-02-15 04:29

I've been using LEO for a while and finding surprinsingly powerfull new uses now
and then, (hey, not a week passes that i dont think to myself : "why did'nt
anyone thought of that kind of tool that is LEO. It's so stupid to program such
a tool, yet no one thought of doing such a thing ! ")

I was wondering if there was a leo keyword (beginning with "@") that would do a
feature I thought would be great: something such as :
@h
@endh
and of course, similarily...
@f
@endf

Standing for "Header", "End Header", "Footer" and "End Footer". Let me please explain ...

When creating files with @file (or nosentinels) I use the keyword "@others" in
the starting node body of the file and place in the file, as it's decendants
(children, grand-children & so on) some clones of other stuff somewhere else
outside of this file (usualy, clones of parts of program regrouped as children
of a "components" node up in the leo outline. Typical Example:

-Introduction
-+components
-a
-b
-c
-+@file program.BAS
-b
-c
-a

a, b, and c are clones and the @file node contains @others.

As you see, I proceed that way because in older programming languages or in
lower level languages, the order of components such as procs, declarations, etc
as an importance. It also has the implication that << and >> brackets are
irrelevant in my way of using leo.

Now, my feature that I looked for in the doc but could not find (so i suggest it
here in case no one had any need of this before) is that when used in the BODY
of a node part of an "@file" the @h and @endh would define a chunk of text in
the body, you've guessed it, to be added before _each_ children node and ONLY
children no grandchildren or any deeper. But It could also be used INSIDE the
body of a children to define headers or footers for IT'S OWN direct children.

so, eehh, do you see the relevance of such a feature? Have i explained it
clearly? maybe this would help:'

CONST baba=2 AS INTEGER
CONST bebe=7 AS INTEGER
CONST zaza=5 AS INTEGER
CONST bobo=1 AS INTEGER
... the beginning and end of each of those "parts-of-a-program" is the same for a potential lot of lines... 

To Be Precise : It's just really for adding something at end or beginning of a
direct children of a node part of an @file in the tangling process.

Is this feature already implemented but i have not found it? I'm pretty sure it easy to implement... what do you people think of this?
Thanks 
--
k

p.s. I'm the guy who proposed that in the untangling process, a clone would not
be updated by it's _Last-Instance-Found_ in the @file beeing untangled, but
instead updated by the _Last-Modified-One-Found_ in the @file... :)

(ooouuuuhh that would be slick...)  

By: ksejlod ( Peter Barrel ) 
 RE: I Have a (maybe) great idea!   
2004-02-15 04:35  

 The tree i tried to draw in ascii did not came out the way i did it,
sourceforge "eated" leading spaces sorry a, b and c are children of their "+"
node just above them . -- k
.. @+node:ekr.20101119030344.5838: *5* Bad idea: script to turn all commands into @g.command nodes
@language python
@color

'''Add @g.command(command_name) before all commands.'''

@others

import os ; os.system('cls')

d = c.commandsDict
f_dict = find_all_defs(c)

result1, result2 = [],[]
for f_name in sorted(f_dict): # These are function names, not command name.
    c_name = c.k.inverseCommandsDict.get(f_name) # Get the emacs command name.
    if c_name:
        f = d.get(c_name) # f is the function name that defines a command.
        if f:
            d_name = f.__name__
            s = repr(f)
            tag = '<bound method '
            if s.startswith(tag): s = s[len(tag):]
            i = s.find(' of ')
            if i > -1: s = s[:i]
            aList = [p.h for i,p in f_dict.get(d_name,[])]
            if len(aList) == 1:
                result1.append((d_name,s,aList),)
            else:
                result2.append((d_name,s,aList),)

print('----- duplicate commands -----\n')
for d_name,s,aList in result2:
    print('%s: %s\n%s %s\n' % (d_name,s,len(aList),aList))

print('----- unambiguous commands -----\n')
for d_name,s,aList in result1:
    print('%40s %s' % (d_name,aList[0]))

if 0:
    for name in sorted(d):
        f = d.get(name)
        f_name = f.__name__
        # name is the minibuffer command name, f_name is the function name.
        i,p = find(c,command,f_name)
        adjust(c,f_name,i,p)
.. @+node:ekr.20101119030344.5841: *6* find_all_defs
def find_all_defs (c):

    '''Return a dict containing all function defs.

    Keys are function names, values are lists of (i,p) pairs.'''

    # To do: consider only files that actually generate commands?
    d = {}
    suppress = ('__init__',)
    for p in c.all_unique_positions():
        done,i,s = False,0,p.b
        while not done and i < len(s):
            progress = i
            i = i1 = s.find('def',i)
            if i == -1:
                done = True ; break
            i += 3 # Assures progress.
            if not g.match_word(s,i-3,'def'): continue
            j = g.skip_ws(s,i)
            if j == i: continue
            i = j
            j = g.skip_id(s,i,chars='_')
            if j == i: continue
            name = s[i:j]
            if name not in suppress:
                aList = d.get(name,[])
                aList.append((i1,p.copy()),)
                d[name] = aList
            # g.trace('%30s %s' % (name,p.h))
            i = j
            assert progress < i
    return d
.. @+node:ekr.20101119030344.5839: *6* find
def find (c,command,f_name):

    g.trace('%30s %s' % (command,f_name))

    for p in c.all_unique_nodes():
        s = p.b
        i = s.find('def %s' % f_name)
.. @+node:ekr.20101119030344.5840: *6* adjust
def adjust(f,i,p):
    pass
.. @+node:ekr.20130803125244.17077: *5* bug: web site for Leo google group is out of date
@nocolor

From: ne1uno <eltronis@gmail.com>

http://groups.google.com/group/leo-editor/about

still has the old home page webpages.charter.net
though it also has leoeditor.com/ for discussions.

The google docs state that it is not possible to change the web site for a google group.
.. @+node:ekr.20080815174457.5: *5* Consider deleting private shadow files
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/e86796831635311b

I was wondering whether it would be a good idea to have leo
automatically delete the corresponding shadow file when a @shadow node
is deleted? Ditto for deleting the .leo_shadow dir when it is empty.

Answer:

My second thought is that this is too dangerous--shadow files might
turn out to be useful emergency backups.  I would prefer to have Leo
mess with the file system as little as possible.
.. @+node:ekr.20131019061259.16697: *5* Fix broken links on Leo's web site
found 27 broken links.

http://leoeditor.com/images/edit_note.html
http://leoeditor.com/images/toolbar.html
http://leoeditor.com/images/delete.html
http://leoeditor.com/images/editcopy.html
http://leoeditor.com/images/duedate.html
http://leoeditor.com/slides/external-files/index.html
http://leoeditor.com/slides/leo-basics-step-by-step/_sources/slide-010.html
http://leoeditor.com/images/newlist.html
http://leoeditor.com/images/new_item.html
http://leoeditor.com/images/owners.html
http://leoeditor.com/images/complete.html
http://leoeditor.com/images/openlist.html
http://leoeditor.com/images/editcut.html
http://leoeditor.com/images/print.html
http://leoeditor.com/slides/installation/index.html
http://leoeditor.com/images/refresh.html
http://leoeditor.com/slides/using-leos-minibuffer/index.html
http://leoeditor.com/images/editpaste.html
http://leoeditor.com/slides/installation/_static/underscore.html
http://leoeditor.com/images/find.html
http://leoeditor.com/front.html
http://leoeditor.com/slides/scripting-leo/index.html
http://leoeditor.com/images/printprev.html
http://leoeditor.com/slides/leo-basics-step-by-step/index.html
http://leoeditor.com/slides/clones-and-views/index.html
http://leoeditor.com/images/mail_item.html
http://leoeditor.com/images/page_setup.html
.. @+node:ekr.20100830120622.5829: *5* Fix python import problems
> > Hmm, I guess that would be more clear, although I think I'd like an option
to include it in the following def to avoid

> > Decoration
> > index
> > Decoration
> > add_user
>
> Sure.  Decorations must always be part of a definition.

Well, personally I'd like to have them included in the definition, but I think
Kent's preference for a separate node is reasonable to. If your function and
hence definition node is called "pluralize", and it's decorated with something
like "@authenticate_user", you may never check the innocent looking pluralize
definition to find out what on earth's triggering the mysterious network
database call. And this isn't a completely specious example, authentication may
have been added to stop pluralize being used in a user existence detection
exploit or something. OTOH in well behaved code like CherryPy apps you don't
want a separate node for every @cherrypy.expose.

Bottom line is I think we're asking for a set of @settings to fine tune python
import behavior:

@python_import_interdef = previous | next | own_node | ai
@python_import_decoration = next | own_node

I'm not sure I believe the AI option is possible / practical, and am not asking
for it, just listing it :-)

I'd also like

@python_import_init_in_class_node = true | false

as often there's more docs on a class in the __init__ than the class docstring.

I think that's really all we're talking about, some @settings to test during import.
.. @+node:ekr.20131121050226.16327: *5* Reload command
- Don't reload any files!
- Only reprocess leoSettings.leo or myLeoSettings.leo if they are actually open.
- Change LoadManager to handle a reload flag.
.. @+node:ekr.20111019104425.15863: *5* Use pygments for syntax coloring
This has essentially no chance of improving Leo
.. @+node:ekr.20150215102218.4: *5* Create @ns-rst/vo/otl commands
@language rest

===== @ns-* write logic

In his initial post, Rob said, "when I change my @auto-rst files to @nosent
files, the resulting files do not contain the RST section headers that were
automatically added by @auto-rst."

This proves that @ns-rst must have special logic that writes the proper
section headers. Happily, this can be done easily with special cases in
at.putOpenNodeSentinel. Ditto for @ns-md, @ns-vimoutline and @ns-otl.

From https://groups.google.com/d/msg/leo-editor/QxK2V62ESLw/vCSolavmw4YJ

===== @ns-* read logic

No change is actually *required* for @ns-rst and @ns-md. When reading an
@ns-rst or @ns-md file, added sections could be slurped into the outline as
under/overlining text. The user could leave the changed node as it is. Or
the user could create a new node with the indicated headline. Either way,
the @ns-rst write logic would recreate the changed file.

However, a simple, fast post-pass in the @ns-rst/md read logic could create
the new nodes automagically. The post-pass would traverse the tree created
by the @nosent logic looking for under/overlined lines (or # lines for md),
creating new nodes as needed. The actual code would be similar to the
@auto-rst logic,but it exists in a far simpler context than @auto-rst.

Post passes are probably *required* for @ns-vimoutline and @ns-otl. Indeed,
vimoutline or otl sentinels should *never* be left as plain text in an
existing node. The "raw" sentinels would corrupt the vim or Emacs outline
if the node were later moved. An unpleasant time bomb.
.. @-all
.. @-leo
