#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20090831095817.6067:Leo 4.6.3
- Put caching bug fixes into 46-maint branch
- Fixed bug in g.adjustTripleString.
- Created .nsi script.
#@nonl
#@-node:ekr.20090831095817.6067:Leo 4.6.3
#@+node:ekr.20090907080624.6082:Leo 4.6.4
#@+node:ekr.20090907080624.6083:Added new plugins
@nocolor-node

New command-line option
    --gui=qttabs

new plugins:
    spydershell,
    qtframecommands
    mod_framesize.

Improved plugin:  "show folder" in rclick menu.

Improved plugin: contextmenu.py

    If you rclick on @thin / whatever item, you should see "open
    /home/ville/foo" (or equivalent) menu entry. It open up the file manager on
    that folder (using xdg-open on linux, os.startfile on windows). I have no
    idea what to do with mac, now it runs xdg-open and probably fails.
#@nonl
#@-node:ekr.20090907080624.6083:Added new plugins
#@-node:ekr.20090907080624.6082:Leo 4.6.4
#@+node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:bwmulder.20050101094804:openForWrite (atFile)
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
#@-node:bwmulder.20050101094804:openForWrite (atFile)
#@+node:ekr.20090103070824.11:c.checkFileTimeStamp
def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    trace = False and not g.unitTesting
    c = self

    # Don't assume the file still exists.
    if not g.os_path_exists(fn):
        if trace: g.trace('file no longer exists',fn)
        return True

    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        if trace: g.trace('no time stamp',fn)
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        if trace: g.trace('time stamps match',fn,timeStamp)
        return True

    if g.app.unitTesting:
        return False

    if trace:
        g.trace('mismatch',timeStamp,timeStamp2)

    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090103070824.11:c.checkFileTimeStamp
#@-node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:ekr.20090812165611.5973:Fixed registerHandler bug
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/8616f4e171e1a24b

On Aug 10, 12:25 pm, tfer <tfethers...@aol.com> wrote:
> Well from vim.py:
> When properly installed, this plugin does the following:
>
> 1. - Double clicking on a node's icon opens that node in VIM. You can
> open nodes in VIM with
>         a single-click if you set useDoubleClick = False.

I tried setting "useDoubleClick = False" under the vim plugin node in
leoPluginsRef.leo work. It doesn't seem to work. I get the message:

exception loading plugin
Traceback (most recent call last):

 File "C:\Program Files\Leo-4-6-2-final\leo\core\leoPlugins.py", line
437, in loadOnePlugin
   init_result = result.init()

 File "C:\Program Files\Leo-4-6-2-final\leo\plugins\vim.py", line
232, in init
   leoPlugins.registerHandler(event,open_in_vim,val=True)

TypeError: registerHandler() got an unexpected keyword argument 'val'

The variable val doesn't get modified in the "open_in_vim
(tag,keywords,val=None)" function.
- Show quoted text -
#@nonl
#@-node:ekr.20090812165611.5973:Fixed registerHandler bug
#@+node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
# at_read attribute in the tnode, not the vnode.
#@nonl
#@+node:ekr.20090712050729.6017:promptForDangerousWrite
def promptForDangerousWrite (self,fileName,kind):

    c = self.c

    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForDangerousWrite')
        return val in (None,True)

    # g.trace(timeStamp, timeStamp2)
    message = '%s %s\n%s\n%s' % (
        kind, fileName,
        g.tr('already exists.'),
        g.tr('Overwrite this file?'))

    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite existing file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090712050729.6017:promptForDangerousWrite
#@-node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
#@+node:ekr.20090804091109.5985:Fixed double prompt in c.close()
#@+node:ekr.20091109103928.6372:Notes
@nocolor

This bug happens only on Linux.
#@nonl
#@-node:ekr.20091109103928.6372:Notes
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    # g.trace('frame',frame,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c) # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocus()
        frame.c.outerUpdate()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@-node:ekr.20090804091109.5985:Fixed double prompt in c.close()
#@+node:ekr.20090817080059.5995:Select main chapter initially
It can be alarming to select a small chapter in a large outline.
#@nonl
#@-node:ekr.20090817080059.5995:Select main chapter initially
#@+node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/33e87adbff5d69d9

Latest trunk.  qt gui

I used multiple body editors (2) for the first time in a long time and the
scroll position was moving at times that it shouldn't.

For example if I scrolled partially down the page and copied some text and then
pasted the text somewhere else that was visible without scrolling, the scroll
position would change significantly although the new text would remain visible.

It may not sound particularly serious but I found it very difficult to use.

The fix was to leoQtGui.updateEditors.
#@nonl
#@-node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
#@+node:ekr.20090822060128.6035:Improved the install docs
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/add6242d6f4fc476

From Matt Wilkie

I've installed Leo several times on windows, yet this morning still
took me a few minutes to find the section you reference above because
there are at least two other document sections with phrases similar to
"installing leo". Anyway, this is my simplified recipe for a virgin
install:

-------------------------
Installing Leo On Windows
-------------------------
//skip any step not needed//

1. Install Python - There are many sources, but from
http://www.python.org/download/releases/ is good

2. Install PyQt - acquire and run Binary Package from
http://www.riverbankcomputing.co.uk/software/pyqt/download which
matches installed Python version (so for python 2.5 scan for the
"Py2.5" in filename)

3. Install Leo
   - Head to http://sourceforge.net/projects/leo/ and slap [Download Now]
   - Unpack python *site-packages* folder, e.g.
C:\Python25\Lib\site-packages\leo-4-6-2-final

   - [optional] Generate/update a junction link from unpacked
leo-4-6-2-final to ...\site-packages\leo

      cd C:\Python25\Lib\site-packages\
      junction leo leo-4-6-2-final

   - Create windows shortcut (edit paths as necessary):

      Target   =  C:\Python25\pythonw.exe
"C:\Python25\Lib\site-packages\leo\launchLeo.py" --gui=qt
      Start in =  D:\code

   - Associate .leo filetype batch file:

      ftype LeoFile=C:\Python25\pythonw.exe
"C:\Python25\Lib\site-packages\leo\launchLeo.py" "--gui=qt" "%1"
      assoc .leo=LeoFile

   - [optional] Put this leo.bat in %PATH%:

      @C:\Python25\python.exe -i
"C:\Python25\Lib\site-packages\leo\launchLeo.py" --gui=qt %*

-------------------------

Further reading / Sources used:

   Junction links -
http://technet.microsoft.com/en-gb/sysinternals/bb896768.aspx,
http://groups.google.com/group/leo-editor/msg/30116f9193241dc4
   FTYPE - http://ss64.com/nt/ftype.html
   ASSOC - http://ss64.com/nt/assoc.html


=====================
Ville's comments

On Thu, Aug 20, 2009 at 10:49 PM, Matt Wilkie<map...@gmail.com> wrote:
> 3. Install Leo
>   - Head to http://sourceforge.net/projects/leo/ and slap [Download Now]
>   - Unpack python *site-packages* folder, e.g.
> C:\Python25\Lib\site-packages\leo-4-6-2-final

I don't think you need to use site-packages. Just extract it anywhere
you want (e.g. c:/opt/leo). But I could be wrong.

>   - Associate .leo filetype batch file:
>n
>      ftype LeoFile=C:\Python25\pythonw.exe
> "C:\Python25\Lib\site-packages\leo\launchLeo.py" "--gui=qt" "%1"
>      assoc .leo=LeoFile

--gui=qt us not needed anymore. 
#@nonl
#@-node:ekr.20090822060128.6035:Improved the install docs
#@+node:ekr.20090829175108.6133:Marked @<file> nodes dirty if nodes change during read.
#@+node:ekr.20041005105605.21:read (atFile) & helper
def read(self,root,
    importFileName=None,thinFile=False,
    fromString=None,atShadow=False,
    force=False
):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName and isAtFile >>
    if isAtFile:
        # The @file node has file-like sentinels iff a tnodeList exists.
        thinFile = not (hasattr(root.v,'tnodeList') and root.v.tnodeList)
    doCache = g.enableDB and (thinFile or atShadow) and not force
    at.initReadIvars(root,fileName,
        importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fileName,fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root, fileContent)

    # Remember that we have read this file.
    root.v.at_read = True # Create the attribute for all clones.

    if doCache and cachefile in c.db:
        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        aList = c.db[cachefile]
        root.v.createOutlineFromCacheList(c,aList)
        at.inputFile.close()
        root.clearDirty()
        return

    # Delete all children, but **not** for @file and @nosent nodes!
    # (We do delete all children for @file nodes with thin-like sentinels.)
    if thinFile or atShadow:
        root.v.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if not g.unitTesting:
        g.es("reading:",root.h)

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName and isAtFile >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False

isAtFile = (
    not thinFile and
    not importFileName and
    not atShadow and
    not fromString and
    root.h.startswith('@file'))
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName and isAtFile >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
resurrected = 0
for p in root.self_and_subtree():
    if p.v.isVisited():
        pass
        # g.trace('visited',p.v,p.h)
    else:
        g.trace('**** not visited',p.v,p.h)
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for v in c.all_unique_nodes():

    if hasattr(v,"tempBodyString"):
        delattr(v,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile) & helper
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    try:
        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(p, fileContent)
    except IOError:
        cachefile = None

    # Remember that we have read this file.
    p.v.at_auto_read = True # Create the attribute

    if cachefile is not None and cachefile in c.db:        
        # g.es('uncache:',p.h)
        aList = c.db[cachefile]
        p.v.createOutlineFromCacheList(c,aList)
        return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        # c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        self.writeCachedTree(p, cachefile)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20040311113514:p.clearDirty
def clearDirty (self):

    p = self
    p.v.clearDirty()
#@-node:ekr.20040311113514:p.clearDirty
#@+node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):

    p = self
    return p.v.findAllPotentiallyDirtyNodes()
#@-node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
#@+node:ekr.20040702104823:p.inAtIgnoreRange
def inAtIgnoreRange (self):

    """Returns True if position p or one of p's parents is an @ignore node."""

    p = self

    for p in p.self_and_parents():
        if p.isAtIgnoreNode():
            return True

    return False
#@-node:ekr.20040702104823:p.inAtIgnoreRange
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    trace = False and not g.unitTesting
    verbose = False
    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()

    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.setDirty()

    if trace: g.trace("position",dirtyVnodeList,g.callers(5))

    return dirtyVnodeList
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):

    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []

    # g.trace(p.h,g.callers(4))

    if not p.v.isDirty():
        p.v.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)

    return dirtyVnodeList
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20090830051712.6151: v.Dirty bits
#@+node:ekr.20031218072017.3390:v.clearDirty
def clearDirty (self):
    v = self
    v.statusBits &= ~ v.dirtyBit

#@-node:ekr.20031218072017.3390:v.clearDirty
#@+node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):

    trace = False and not g.unitTesting
    v = self ; c = v.context

    # Set the starting nodes.
    nodes = []
    newNodes = [v]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]

    # Remove the hidden vnode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root',c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)

    if trace: g.trace(nodes)
    return nodes
#@nonl
#@-node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes
#@+node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty
# Unlike p.setAllAncestorAtFileNodesDirty,
# there is no setDescendentsDirty arg.

def setAllAncestorAtFileNodesDirty (self):

    trace = False and not g.unitTesting
    verbose = False
    v = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = v.findAllPotentiallyDirtyNodes()

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]

    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.setDirty() # Do not call v.setDirty here!

    if trace: g.trace("vnode",dirtyVnodeList)

    return dirtyVnodeList
#@-node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty
#@+node:ekr.20080429053831.12:v.setDirty
def setDirty (self):

    self.statusBits |= self.dirtyBit
#@-node:ekr.20080429053831.12:v.setDirty
#@-node:ekr.20090830051712.6151: v.Dirty bits
#@+node:ekr.20090829064400.6040:v.createOutlineFromCacheList & helpers
def createOutlineFromCacheList(self,c,aList):
    """ Create outline structure from recursive aList
    built by p.makeCacheList.

    Clones will be automatically created by gnx,
    but *not* for the top-level node.
    """

    parent_v = self

    #import pprint ; pprint.pprint(tree)
    parent_v = self
    h,b,gnx,children = aList
    if h is not None:
        v = parent_v
        v._headString = h    
        v._bodyString = b

    for z in children:
        h,b,gnx,grandChildren = z
        isClone,child_v = parent_v.fastAddLastChild(c,gnx)
        if isClone:
            if child_v.b != b: # or child_v.h
                # Bug fix: the last seen clone rules.
                child_v.h = h
                child_v.b = b
                # Bug fix: mark @<file> nodes dirty.
                child_v.setAllAncestorAtFileNodesDirty()
                child_v.setMarked()
                g.es("changed:",child_v.h,color="blue")
        else:
            child_v.createOutlineFromCacheList(c,z)
#@+node:ekr.20090829064400.6042:v.fastAddLastChild
# Similar to createThinChild4
def fastAddLastChild(self,c,gnxString):
    '''Create new vnode as last child of the receiver.

    If the gnx exists already, create a clone instead of new vnode.
    '''

    trace = False and not g.unitTesting
    parent_v = self
    indices = g.app.nodeIndices
    gnxDict = c.fileCommands.gnxDict

    if gnxString is None: v = None
    else:                 v = gnxDict.get(gnxString)
    is_clone = v is not None

    if trace: g.trace(
        'clone','%-5s' % (is_clone),
        'parent_v',parent_v,'gnx',gnxString,'v',repr(v))

    if not is_clone:
        v = vnode(context=c)
        if gnxString:
            gnx = indices.scanGnx(gnxString,0)
            v.fileIndex = gnx
        gnxDict[gnxString] = v

    child_v = v
    child_v._linkAsNthChild(parent_v,parent_v.numberOfChildren())
    child_v.setVisited() # Supress warning/deletion of unvisited nodes.

    return is_clone,child_v
#@-node:ekr.20090829064400.6042:v.fastAddLastChild
#@-node:ekr.20090829064400.6040:v.createOutlineFromCacheList & helpers
#@-node:ekr.20090829175108.6133:Marked @<file> nodes dirty if nodes change during read.
#@+node:ekr.20090901175503.6096:Fixed bug in g.adjustTripleString
#@+node:ekr.20050211120242.2:g.removeExtraLws & test
def removeExtraLws (s,tab_width):

    '''Remove extra indentation from one or more lines.

    Warning: used by getScript.  This is *not* the same as g.adjustTripleString.'''

    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w = g.computeWidth(lws,tab_width)
            break
    else: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            g.pr(repr(line))

    return result
#@+node:ekr.20090517020744.5881:@test g.removeExtraLws
if g.unitTesting:

    c,p = g.getTestVars()

    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@-node:ekr.20090517020744.5881:@test g.removeExtraLws
#@-node:ekr.20050211120242.2:g.removeExtraLws & test
#@+node:ekr.20051014175117:g.adjustTripleString
def adjustTripleString (s,tab_width):

    '''Remove leading indentation from a triple-quoted string.

    This works around the fact that Leo nodes can't represent underindented strings.
    '''

    # Compute the minimum leading whitespace of all non-blank lines.
    trace = True and not g.unitTesting
    lines = g.splitLines(s)
    w = 0 ; val = -1
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w2 = g.computeWidth(lws,tab_width)
            # The sign of w does not matter.
            if w == 0 or abs(w2) < w:
                w = abs(w2)

    if w == 0: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    return result
#@+node:ekr.20090901175503.6098:@test g.adjustTripleString
if g.unitTesting:

    c,p = g.getTestVars()

    s = '''\
    a
      b

c
    d'''

    s2 = 'a\n  b\n\nc\nd'

    result = g.adjustTripleString(s,c.tab_width)
    assert result == s2,repr(result)


#@-node:ekr.20090901175503.6098:@test g.adjustTripleString
#@-node:ekr.20051014175117:g.adjustTripleString
#@+node:ekr.20031218072017.3202:removeLeadingWhitespace
# Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0 ; first_ws = abs(first_ws)
    for ch in s:
        if ws >= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j > 0:
        s = s[j:]
    return s
#@-node:ekr.20031218072017.3202:removeLeadingWhitespace
#@-node:ekr.20090901175503.6096:Fixed bug in g.adjustTripleString
#@+node:ekr.20090907140408.6123:Fixed startup reversion when .leoID.txt does not exist
#@+node:ekr.20041113113140:loadOnePlugin & test
def loadOnePlugin (moduleOrFileName,tag='open0',verbose=False):

    trace = False # and not g.unitTesting

    global loadedModules,loadingModuleNameStack

    # Prevent Leo from crashing if .leoID.txt does not exist.
    if g.app.config is None:
        print ('No g.app.config, making stub...')
        class StubConfig(g.nullObject):
            pass
        g.app.config = StubConfig()

    # Fixed reversion: do this after possibly creating stub config class.
    verbose = False or verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if trace or verbose:
            g.trace('plugin',moduleName,'already loaded',color="blue")
        return module

    assert g.app.loadDir

    plugins_path = g.os_path_finalize_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path,pluginName=moduleName,verbose=True)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)

        if tag == 'unit-test-load':
            pass # Keep the result, but do no more.
        elif hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                # g.trace('result',result,'init_result',init_result)
                if init_result:
                    loadedModules[moduleName] = result
                    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es_print('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.

            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                g.trace('no init()',moduleName)
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.app.batchMode or g.app.inBridge: # or g.unitTesting
        pass
    elif result:
        if trace or verbose:
            g.trace('loaded plugin:',moduleName,color="blue")
    else:
        if trace or warn_on_failure or (verbose and not g.app.initing):
            if trace or tag == 'open0':
                g.trace('can not load enabled plugin:',moduleName,color="red")

    return result
#@+node:ekr.20090522161156.5886:@test class StubConfig
if g.unitTesting:

    c,p = g.getTestVars()

    class StubConfig(g.nullObject):
        pass

    x = StubConfig()
    assert not x.getBool(c,'mySetting')
    assert not x.enabledPluginsFileName
#@-node:ekr.20090522161156.5886:@test class StubConfig
#@-node:ekr.20041113113140:loadOnePlugin & test
#@-node:ekr.20090907140408.6123:Fixed startup reversion when .leoID.txt does not exist
#@+node:ekr.20090930103947.6085:Fixed elisp bug
> Here is the fix:
> 'startsFunction' in 'elispScanner' should use
>    j = self.skipId(s,i)
> instead of
>    j = g.skip_id(s,i)
> skip_id doesn't take extraIdChars ('-' in elisp case) into
> consideration. 
#@nonl
#@+node:ekr.20070711060113:class elispScanner
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,unused_s,unused_i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.startSigIndent = self.getLeadingIndent(s,i)
    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False

    end = self.skipBlock(s,i)
    # g.trace('%3s %15s block: %s' % (i,repr(s[i:i+10]),repr(s[i:end])))
    if not g.match(s,end-1,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len('defun')
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = self.skipId(s,i) # Bug fix: 2009/09/30
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner
#@-node:ekr.20090930103947.6085:Fixed elisp bug
#@+node:ekr.20090930151626.6086:Made add-comments and delete-comments commands work with shortcuts
@language python

ab
#@nonl
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self,event=None):

    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('no text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',d3+' '

    # Comment out non-blank lines.
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            result.append(line[0:i]+openDelim+line[i:]+closeDelim)
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self,event=None):

    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('no text selected',color='blue')
        return

    if d1:
        # Remove the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in range(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es('',"'%s'" % (d2),"not found",color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es('',"'%s'" % (d3),"not found",color='blue')
                    return

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',
            repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        << handle special cases for plain keys >>

    << handle per-pane bindings >>

    if traceGC: g.printNewObjects('masterKey 5')

    return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.

if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function',k.state.kind) # k.state.handler)
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20080510153327.4:<< handle special cases for plain keys >>
#g.trace('plain key','state',k.unboundKeyAction,'stroke',stroke)

# Important: only keys bound somewhere have a stroke.
# All unbound plain keys will be handled by handleUnboundKeys.

if k.unboundKeyAction in ('insert','overwrite'):

    for key in (k.unboundKeyAction,'body','log','text','all'):
        # Ignore bindings for all plain keys in insert/overwrite mode *except* auto-complete.
        d = k.masterBindingsDict.get(key,{})
        if d:
            b = d.get(stroke)
            if b and b.commandName == 'auto-complete':
                if trace: g.trace('%s: auto-complete key in %s mode' % (stroke,k.unboundKeyAction))
                k.masterCommand(event,b.func,b.stroke,b.commandName)
                return 'break'

    if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
    k.masterCommand(event,func=None,stroke=stroke,commandName=None)
    return 'break'

# Bound   plain keys in command mode are by the per-pane logic.
# Unbound plain keys in command mode are ignored by handleUnboundKeys.

# This code ignores all command-state keys if we are not in a text widget.
elif k.unboundKeyAction == 'command':
    if not g.app.gui.isTextWidget(w):
        c.onCanvasKey(event)
        return 'break'
#@nonl
#@-node:ekr.20080510153327.4:<< handle special cases for plain keys >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
keyStatesTuple = ('command','insert','overwrite')

if True and trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
    'isTextWidget(w)',g.app.gui.isTextWidget(w))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None),
    ('all',None),
):
    if (
        # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        if trace:
            g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
            # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif keysym.find('Escape') != -1:
        # Never insert escape characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20061031131434.102:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c ; d = c.commandsDict

    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'keyboard-quit': g.trace(key,bunchList)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@-node:ekr.20061031131434.102:makeBindingsFromCommandsDict
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: g.trace(pane,shortcut,commandName)
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print ('redefining shortcut %30s from %s to %s in %s' % (
            shortcut,
            g.choose(pane=='button',z,commandName),
            g.choose(pane=='button',commandName,z),
            pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return

    trace = False
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        # Bug fix: 2009/09/30: use canonical stroke.
        accelerator = k.shortcutFromSetting(accel,addKey=False) or ''
        stroke = k.shortcutFromSetting(accel,addKey=True) or ''
        if accelerator:
            accelerator = g.stripBrackets(k.prettyPrintKey(accelerator))
        if trace: # and commandName == 'add-comments':
            g.trace(bunch.val,repr(stroke),repr(accelerator),commandName)
        def masterMenuCallback (c=c,k=k,stroke=stroke,command=command,commandName=commandName,event=None):
            # if trace: g.trace('stroke',stroke)
            return k.masterMenuHandler(stroke,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>

        # c.add_command ensures that c.outerUpdate is called.
        if menu:
            c.add_command(menu,label=realLabel,
                accelerator=accelerator,
                command=masterMenuCallback,
                underline=amp_index)
#@+node:ekr.20051021091958:<< get label & command or continue >>
if g.isString(data):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            if trace: g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            if trace: g.trace('2','%20s' % (bunch.val),commandName)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val
                    if trace: g.trace('3','%20s' % (bunch.val),commandName)
                    break
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
def shortcutFromSetting (self,setting,addKey=True):

    k = self

    trace = False and not g.unitTesting
    if not setting:return None

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    if trace: g.trace('%20s %s' % (setting,shortcut))
    return shortcut

canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting = shortcutFromSetting
#@+node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
meta  = s2.find("meta") >= 0
#@-node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
#@+node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
#@-node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
#@+node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@-node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
#@+node:ekr.20061031131434.188:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", s)
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
#@-node:ekr.20061031131434.188:<< compute the last field >>
#@+node:ekr.20061031131434.189:<< compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
#@-node:ekr.20061031131434.189:<< compute shortcut >>
#@-node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
#@-node:ekr.20090930151626.6086:Made add-comments and delete-comments commands work with shortcuts
#@+node:ekr.20091003171114.6465:Fixed contractOrGoRight
@nocolor-node

The culprit was the sparse_goto_parent option.
It never worked properly, and it caused the expansion
state of nodes as seen by Leo to get out-of-synch
with the expansion state as seen by the qt tree code.

To exercise the bug, do the following in test.leo:

- Expand the "prototypes" node.
- Expand any child node.
- Move beyond the now-expanded child node.
- Hit Alt-Left.  This will select the prototype node.
  The expanded child node will be marked by Leo as being contracted,
  but it *wont* be contracted actually, which confuses moveToVisNext.
#@nonl
#@+node:ekr.20031218072017.2996:selectVisNext
def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisNext(): return

    p.moveToVisNext(c)
    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2996:selectVisNext
#@+node:ekr.20031218072017.2995:selectVisBack
# This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisBack(): return

    p.moveToVisBack(c)

    # g.trace(p.h)
    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2995:selectVisBack
#@+node:ekr.20031218072017.2920:goToParent
def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.p

    # g.trace(p.parent())

    c.treeSelectHelper(p and p.parent())
#@-node:ekr.20031218072017.2920:goToParent
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    trace = False and not g.unitTesting
    c = self ; p = c.p
    redraw = False ; fullRedraw = False
    if p.hasChildren() and p.isExpanded():
        if trace: g.trace('contract',p.h)
        c.contractNode()
        redraw = True # New in one-node world.
    elif p.hasParent() and p.parent().isVisible(c):
        redraw = False
        p.contract() # Make sure we know this node is contracted.
        # This "feature" is dubious.
        # To work properly, it requires a full redraw.
        if False: # self.sparse_goto_parent:
            for child in p.self_and_siblings():
                if child != p and child.isExpanded():
                    child.contract()
                    redraw = True ; fullRedraw = True
        if trace: g.trace('goto parent',p.h)
        c.goToParent()

    if redraw:
        if fullRedraw or p.isCloned():
            if trace: g.trace('full redraw',p.h)
            c.redraw()
        else:
            c.redraw_after_contract(p=p,setFocus=True)
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    trace = False and not g.unitTesting
    c = self ; p = c.p

    # New code.
    if p.hasChildren():
        if p.isExpanded():
            p.moveToFirstChild()
            if trace: g.trace('select',p.h)
            c.selectPosition(p)
        else:
            if trace: g.trace('expand',p.h)
            c.expandNode() # Calls redraw_after_expand.
    elif p.hasNext():
        c.goToNextSibling()
    else:
        while p.hasParent():
            p.moveToParent()
            if p.hasNext():
                p.moveToNext()
                break
        c.selectPosition(p)
    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode() # Calls redraw_after_expand.
        else:
            c.redraw_after_expand(p.firstChild(),setFocus=True)
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20031218072017.2901:contractNode
def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.p

    p.contract()

    if p.isCloned():
        c.redraw() # A full redraw is necessary to handle clones.
    else:
        c.redraw_after_contract(p=p,setFocus=True)
#@-node:ekr.20031218072017.2901:contractNode
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    trace = False and not g.unitTesting
    c = self ; p = c.p

    p.expand()

    if p.isCloned():
        if trace: g.trace('***redraw')
        c.redraw() # Bug fix: 2009/10/03.
    else:
        c.redraw_after_expand(p,setFocus=True)

#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20070226113916: treeSelectHelper
def treeSelectHelper (self,p):

    c = self

    if not p: p = c.p

    if p:
        # Do not call expandAllAncestors here.
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeFocusHelper()
#@-node:ekr.20070226113916: treeSelectHelper
#@+node:ekr.20080416161551.210:p.moveToVisBack
def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    trace = False and not g.unitTesting
    verbose = True
    p = self ; limit,limitIsVisible = c.visLimit()
    if trace and verbose:
        g.trace(p,'limit',limit,'limitIsVisible',limitIsVisible)
    if trace: g.trace('***entry','parent',p.parent(),'p',p,g.callers(5))
    while p:
        # Short-circuit if possible.
        back = p.back()
        if trace: g.trace(
            'back',back,'hasChildren',bool(back and back.hasChildren()),
            'isExpanded',bool(back and back.isExpanded()))

        if back and back.hasChildren() and back.isExpanded():
            p.moveToThreadBack()
        elif back:
            p.moveToBack()
        else:
            p.moveToParent() # Same as p.moveToThreadBack()
        # if back and (not back.hasChildren() or not back.isExpanded()):
            # p.moveToBack()
        # else:
            # p.moveToThreadBack()
        if trace: g.trace(p.parent(),p)
        if p:
            if trace and verbose: g.trace('**p',p)
            done,val = self.checkVisBackLimit(limit,limitIsVisible,p)
            if done:
                if trace and verbose: g.trace('done',p)
                return val
            if p.isVisible(c):
                if trace and verbose: g.trace('isVisible',p)
                return p
    else:
        # assert not p.
        return p
#@+node:ekr.20090715145956.6166:checkVisBackLimit
def checkVisBackLimit (self,limit,limitIsVisible,p):

    '''Return done, return-val'''

    trace = True and not g.unitTesting
    c = p.v.context

    if limit:
        if limit == p:
            if trace: g.trace('at limit',p)
            if limitIsVisible and p.isVisible(c):
                return True,p
            else:
                return True,None
            #return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
        elif limit.isAncestorOf(p):
            return False,None
        else:
            if trace: g.trace('outside limit tree',limit,p)
            return True,None
    else:
        return False,None
#@-node:ekr.20090715145956.6166:checkVisBackLimit
#@-node:ekr.20080416161551.210:p.moveToVisBack
#@+node:ekr.20080416161551.211:p.moveToVisNext
def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    trace = False and not g.unitTesting
    verbose = False
    p = self ; limit,limitIsVisible = c.visLimit()
    while p:
        if trace: g.trace('1',p.h)
        # if trace: g.trace('hasChildren %s, isExpanded %s %s' % (
            # p.hasChildren(),p.isExpanded(),p.h))
        # Short-circuit if possible.
        if p.hasNext() and p.hasChildren() and p.isExpanded():
            p.moveToFirstChild()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if trace: g.trace('2',p.h)
        if p:
            done,val = self.checkVisNextLimit(limit,p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        return p
#@+node:ekr.20090715145956.6167:checkVisNextLimit
def checkVisNextLimit (self,limit,p):

    '''Return done, return-val'''

    trace = False and not g.unitTesting

    if limit:
        # Unlike moveToVisBack, being at the limit does not terminate.
        if limit == p:
            return False, None
        elif limit.isAncestorOf(p):
            return False,None
        else:
            if trace: g.trace('outside limit tree')
            return True,None
    else:
        return False,None
#@-node:ekr.20090715145956.6167:checkVisNextLimit
#@-node:ekr.20080416161551.211:p.moveToVisNext
#@-node:ekr.20091003171114.6465:Fixed contractOrGoRight
#@+node:ekr.20091007105735.6462:Fixed bug: @nosent should warn about orphan nodes
#@+node:ekr.20041005105605.154:asisWrite
def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        # Note: @asis always writes all nodes,
        # so there can be no orphan or ignored nodes.
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            # openFileForWriting calls root.setDirty() if there are errors.
            return
        for p in root.self_and_subtree():
            << Write p's headline if it starts with @@ >>
            << Write p's body >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
    except Exception:
        at.writeException(root) # Sets dirty and orphan bits.

silentWrite = asisWrite # Compatibility with old scripts.
#@+node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
s = p.h

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) > 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)
#@-node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
#@+node:ekr.20041005105605.156:<< Write p's body >>
s = p.b

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
#@-node:ekr.20041005105605.156:<< Write p's body >>
#@-node:ekr.20041005105605.154:asisWrite
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,
    nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v._bodyString)

    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
    if not toString:
        at.warnAboutOrphandAndIgnoredNodes()
#@-node:ekr.20041005105605.157:writeOpenFile
#@-node:ekr.20091007105735.6462:Fixed bug: @nosent should warn about orphan nodes
#@+node:ekr.20091016055503.6059:Color sections references in @root trees
#@+node:ekr.20090214075058.9:g.get_directives_dict (must be fast)
# The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

g_noweb_root = re.compile('<'+'<'+'*'+'>'+'>'+'=',re.MULTILINE)

def get_directives_dict(p,root=None):

    """Scan p for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    trace = False and not g.unitTesting

    if root: root_node = root[0]
    d = {}

    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat,re.MULTILINE)

    # The headline has higher precedence because it is more visible.
    for kind,s in (('body',p.h),('head',p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(0)[1:] # Omit the @
            i = m.start(0)
            if word.strip() not in d:
                j = i + 1 + len(word)
                k = g.skip_line(s,j)
                val = s[j:k].strip()
                if trace: g.trace(word,repr(val))
                d[word.strip()] = val

    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"]=0 # value not immportant
            else:
                g.es('%s= requires @root in the headline' % (
                    g.angleBrackets('*')))
            break

    if trace: g.trace('%4d' % (len(p.h) + len(p.b)),g.callers(5))
    return d
#@+node:ekr.20090214075058.10:compute_directives_re
def compute_directives_re ():

    '''Return an re pattern which will match all Leo directives.'''

    global globalDirectiveList

    aList = ['^@%s' % z for z in globalDirectiveList
                if z != 'others']

    # @others can have leading whitespace.
    aList.append(r'^\s@others')

    return '|'.join(aList)
#@-node:ekr.20090214075058.10:compute_directives_re
#@-node:ekr.20090214075058.9:g.get_directives_dict (must be fast)
#@+node:ekr.20031218072017.1385:g.findReference
# Called from the syntax coloring method that colorizes section references.

def findReference(c,name,root):

    '''Find the section definition for name.

    If a search of the descendants fails,
    and an ancestor is an @root node,
    search all the descendants of the @root node.
    '''

    for p in root.subtree():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # New in Leo 4.7: expand the search for @root trees.
    for p in root.self_and_parents():
        d = g.get_directives_dict(p)
        if 'root' in d:
            for p2 in p.subtree():
                if p2.matchHeadline(name) and not p2.isAtIgnoreNode():
                    return p2

    # g.trace("not found:",name,root)
    return c.nullPosition()
#@-node:ekr.20031218072017.1385:g.findReference
#@-node:ekr.20091016055503.6059:Color sections references in @root trees
#@+node:ekr.20091103082258.6084:Fixed bug: Sometimes 'redefining shortcut' message is backwards
#@+node:ekr.20061031131434.131:k.registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)

    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('redefining',commandName, color='red')

    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    if trace: g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName,g.callers(4))
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@-node:ekr.20061031131434.131:k.registerCommand
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: g.trace(pane,shortcut,commandName)
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print ('redefining shortcut %30s from %s to %s in %s' % (
            shortcut,
            g.choose(pane=='button',z,commandName),
            g.choose(pane=='button',commandName,z),
            pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@-node:ekr.20091103082258.6084:Fixed bug: Sometimes 'redefining shortcut' message is backwards
#@+node:ekr.20091201125021.6067:Fixed publish-argv-for-missing-stylesheets
# The parsing in writeToDocutils had to be rewritten.
#@nonl
#@+node:ekr.20090502071837.65:writeToDocutils (sets argv) & helper
def writeToDocutils (self,s):

    '''Send s to docutils using the writer implied by self.ext and return the result.'''

    trace = True and not g.unitTesting
    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }

    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()

    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.es_print('unknown docutils extension: %s' % (self.ext),color='red')
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if self.getOption('stylesheet_embed') == False:
        rel_path = g.os_path_join(
            rel_stylesheet_path,self.getOption('stylesheet_name'))
        overrides['stylesheet'] = rel_path
        overrides['stylesheet_path'] = None
        overrides['embed_stylesheet'] = None
    elif g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.es_print('stylesheet not found: %s' % (path),color='red')
    else:
        g.es_print('stylesheet not found\n',path,color='red')
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        if trace: g.trace('overrides',overrides)
        result = None # Ensure that result is defined.
        result = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError as error:
        # g.es_print('Docutils error (%s):' % (
            # error.__class__.__name__),color='red')
        g.es_print('Docutils error:',color='red')
        g.es_print(error,color='blue')
    except Exception:
        g.es_print('Unexpected docutils exception')
        g.es_exception()
    return result
#@+node:ekr.20090502071837.66:handleMissingStyleSheetArgs
def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    force = False
    if force:
        # See http://docutils.sourceforge.net/docs/user/config.html#documentclass
        return {'documentclass':'report', 'documentoptions':'english,12pt,lettersize'}

    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return {}

    # Handle argument lists such as this:
    # --language=en,--documentclass=report,--documentoptions=[english,12pt,lettersize]
    d = {}
    while s:
        s = s.strip()
        if not s.startswith('--'): break
        s = s[2:].strip()
        eq = s.find('=')
        cm = s.find(',')
        if eq == -1 or (-1 < cm < eq): # key[nl] or key,
            val = ''
            cm = s.find(',')
            if cm == -1:
                key = s.strip()
                s = ''
            else:
                key = s[:cm].strip()
                s = s[cm+1:].strip()
        else: # key = val
            key = s[:eq].strip()
            s = s[eq+1:].strip()
            if s.startswith('['): # [...]
                rb = s.find(']')
                if rb == -1: break # Bad argument.
                val = s[:rb+1]
                s = s[rb+1:].strip()
                if s.startswith(','):
                    s = s[1:].strip()
            else: # val[nl] or val,
                cm = s.find(',')
                if cm == -1:
                    val = s
                    s = ''
                else:
                    val = s[:cm].strip()
                    s = s[cm+1:].strip()

        # g.trace('key',repr(key),'val',repr(val),'s',repr(s))
        if not key: break
        if not val.strip(): val = '1'
        d[str(key)] = str(val)

    return d
#@nonl
#@-node:ekr.20090502071837.66:handleMissingStyleSheetArgs
#@-node:ekr.20090502071837.65:writeToDocutils (sets argv) & helper
#@-node:ekr.20091201125021.6067:Fixed publish-argv-for-missing-stylesheets
#@+node:ekr.20091217190731.6075:Recover from bad chars in .leo files
#@+node:ekr.20090525144314.6526:cleanSaxInputString & test
def cleanSaxInputString(self,s):

    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
#@+node:ekr.20090525144314.6527:@test cleanSaxInputString
if g.unitTesting:

    c,p = g.getTestVars()

    s = 'test%cthis' % 27

    assert c.fileCommands.cleanSaxInputString(s) == 'test this'
#@-node:ekr.20090525144314.6527:@test cleanSaxInputString
#@-node:ekr.20090525144314.6526:cleanSaxInputString & test
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                pass
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20091217190731.6075:Recover from bad chars in .leo files
#@-node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090817080059.5996:Features
#@+node:ekr.20090815073537.5991:Added options to vim plugin
@nocolor-node

The setting::

    @string vim_trigger_event = icondclick2

is the default.  It opens vim when the user double-clicks the icon box.

Alternatives are::

    @string vim_trigger_event = iconclick2
    @string vim_trigger_event = select2

The former opens vim on single clicks in the icon bar.
The latter opens vim whenever a new node is selected in Leo.
#@nonl
#@-node:ekr.20090815073537.5991:Added options to vim plugin
#@+node:ekr.20090822054806.6002:Merged clean-sys-path branch
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b868abd65fb57759

I noted that leo adds all of its directories to sys.path. This is
considered "bad form" and can cause nasty surprises. I believe this is
an artifact of the old "leo-as-package" work; now that leo-as-package
stuff works well, I don't think this is needed anymore.

It's not a lot of work to fix either - it's just a matter of removing
the call to adjustSysPath in runLeo.py, and fixing some plugins. (yes,
I tried it). e.g. quicksearch.py needed this trivial change:

+++ leo/plugins/quicksearch.py  2009-08-15 20:22:20 +0000

-import qt_quicksearch
+from leo.plugins import qt_quicksearch 

What I did:

- disabled adjustSysPath.
- g.importModule now imports from 'extensions' and 'external' directories as needed.
- Modified two plugins to import from leo.plugins.
- Added __init__.py to 'extensions' folder.
#@nonl
#@-node:ekr.20090822054806.6002:Merged clean-sys-path branch
#@+node:ekr.20091007104807.6469:Added support for --version and --help
Actually, --help was supported already.
#@nonl
#@-node:ekr.20091007104807.6469:Added support for --version and --help
#@+node:ekr.20091005145253.6057:Convert @file nodes so they use file-like sentinels
@nocolor-node

Leo will now automatically write @file nodes as if they were @thin nodes
(thin-like sentinels). Leo will read @file correctly regardless of whether the
corresponding external file has file-like (legacy) or thin-like (recommended)
sentinels. Once thin-like sentinels are written, Leo deletes the problematic
tnodeList attribute in the .leo file.

**Important**: The conversion to thin-like sentinels happens *only* if Leo
actually writes the @file node, and that happens only if the @file node or one
of its descendants changes. As usual with @file nodes, writing any @file node
forces Leo to write the .leo file. This is necessary so that the tnodeList
attribute in the .leo file remains up- to-date. Thus, the conversion process
should be as safe as using @file nodes ever was, which is to say, *usually* safe
but subject to problems in a cooperative environment.

In short, I recommend that you use Shift-Ctrl-W (write-at-files-nodes)
to force the conversion of all your legacy @file nodes.  Please back
up your .leo file and all your external files first.
#@nonl
#@-node:ekr.20091005145253.6057:Convert @file nodes so they use file-like sentinels
#@+node:ekr.20091007105735.6463:Made show-fonts work with qt gui
#@-node:ekr.20091007105735.6463:Made show-fonts work with qt gui
#@+node:ekr.20091103082258.6085:Removed 'end of script' message
#@+node:ekr.20031218072017.2140:c.executeScript & helpers
def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # g.pr('*** script',script)
            try:
                p = c.p
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if args:
                    # g.trace('setting sys.argv',args)
                    sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                exec(script,d)
                if 0: # This message switches panes, and can be disruptive.
                    if not script1 and not silent:
                        # Careful: the script may have changed the log tab.
                        tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                        g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143:redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@-node:ekr.20031218072017.2143:redirectScriptOutput
#@+node:EKR.20040627100424:unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@-node:EKR.20040627100424:unredirectScriptOutput
#@+node:ekr.20070115135502:writeScriptFile
def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.homeLeoDir,'scriptFile.py')                    

    # Write the file.
    try:
        f = open(path,'w')
        f.write(script)
        f.close()
    except Exception:
        g.es("Failed to write script to %s" % path)
        g.es("Check your configuration of script_file_path, currently %s" % c.config.getString('script_file_path'))
        path = None

    return path
#@nonl
#@-node:ekr.20070115135502:writeScriptFile
#@-node:ekr.20031218072017.2140:c.executeScript & helpers
#@-node:ekr.20091103082258.6085:Removed 'end of script' message
#@-node:ekr.20090817080059.5996:Features
#@+node:ekr.20091007104807.6470:Code
#@+node:ekr.20091001141621.6042:iters -> generators & code cleanup
@nocolor-node
@

What I did:

- Removed t from leoGui.leo.
- Removed t from scripts.leo.
- Renamed xTnodeY to xVnodeY in a few places.
- Removed putDescendantTnodeUas: it was redundant.
- Revised scripting chapter.

Will not do:

- Remove t from leoPlugins.leo.
  This could cause problems that I am not willing to solve.
- v.tnodeList will not change in this branch.
  This must be done in a separate branch as part of the deprecation of @file.



#@+node:ekr.20091003023754.6105:Not used
#@+node:ekr.20091001141621.6067:c.Old iterators
if not g.new_generators:

    @others
#@nonl
#@+node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
def allNodes_iter (self,copy=False):

    r = self.rootPosition()
    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p
    return r.iter_class(r, cp)

all_positions_iter = allNodes_iter
#@nonl
#@-node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
#@+node:EKR.20040529091232.1:c.all_tnodes_iter
def all_tnodes_iter (self):

    return self.rootPosition().tnodes_iter()
#@-node:EKR.20040529091232.1:c.all_tnodes_iter
#@+node:EKR.20040529091232.2:c.all_unique_tnodes_iter
def all_unique_tnodes_iter (self):

    return self.rootPosition().unique_tnodes_iter()
#@-node:EKR.20040529091232.2:c.all_unique_tnodes_iter
#@+node:EKR.20040529091232.3:c.all_vnodes_iter
def all_vnodes_iter (self):
    return self.rootPosition().vnodes_iter()
#@-node:EKR.20040529091232.3:c.all_vnodes_iter
#@+node:EKR.20040529091232.4:c.all_unique_vnodes_iter
def all_unique_vnodes_iter (self):

    return self.rootPosition().unique_vnodes_iter()
#@-node:EKR.20040529091232.4:c.all_unique_vnodes_iter
#@+node:sps.20080317144948.3:c.all_positions_with_unique_tnodes_iter
def all_positions_with_unique_tnodes_iter (self):

    r = self.rootPosition()
    return r.unique_iter_class(r, lambda p: p)
#@-node:sps.20080317144948.3:c.all_positions_with_unique_tnodes_iter
#@+node:sps.20080327174748.4:c.all_positions_with_unique_vnodes_iter
def all_positions_with_unique_vnodes_iter (self):

    r = self.rootPosition()
    return r.unique_iter_class(r, lambda p: p, lambda u: u.v)
#@-node:sps.20080327174748.4:c.all_positions_with_unique_vnodes_iter
#@-node:ekr.20091001141621.6067:c.Old iterators
#@+node:ekr.20091002072933.6096:p.Old iterators
if not g.new_generators:

    @others
#@+node:ekr.20040305172211.1:p.children_iter
class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):

    return self.children_iter_class(self,copy)
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:p.children_iter
#@+node:sps.20080331123552.3:p.iter
class iter_class:

    """Returns a list of mappings of positions in a subtree,
    possibly including the root of the subtree."""

    @others

def tnodes_iter (self):

    return self.iter_class(self, lambda p: p.v.t)

def vnodes_iter (self):

    return self.iter_class(self, lambda p: p.v)
#@+node:sps.20080331123552.1:__init__ & __iter__ (p.iter)
def __init__(self,p,mapping):

    # g.trace('p.tnodes_iter.__init','p',p)

    self.first = p.copy()
    self.p = None
    self.mapping = mapping

def __iter__(self):

    return self
#@-node:sps.20080331123552.1:__init__ & __iter__ (p.iter)
#@+node:sps.20080331123552.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None
    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.mapping(self.p)

    raise StopIteration

__next__ = next
#@nonl
#@-node:sps.20080331123552.2:next
#@-node:sps.20080331123552.3:p.iter
#@+node:ekr.20040305172855:p.parents_iter
class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)

def self_and_parents_iter(self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:p.parents_iter
#@+node:ekr.20040305173343:p.siblings_iter
class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):

    return self.siblings_iter_class(self,copy,following)

self_and_siblings_iter = siblings_iter

def following_siblings_iter (self,copy=False):

    return self.siblings_iter_class(self,copy,following=True)
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):

    # We always include p, even if following is True.

    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:p.siblings_iter
#@+node:ekr.20040305173559:p.subtree_iter
class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=False)

def self_and_subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:p.subtree_iter
#@+node:sps.20080331123552.12:p.subtree_unique_iter
class subtree_unique_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_with_unique_tnodes_iter (self,copy=False):

    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p

    return self.subtree_unique_iter_class(self,
        cp,
        lambda p: p.v.t,
        includeSelf=False)

def subtree_with_unique_vnodes_iter (self,copy=False):

    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p

    return self.subtree_unique_iter_class(self,
        cp,
        lambda p: p.v,
        includeSelf=False)
#@+node:sps.20080331123552.9:__init__ & __iter__
def __init__(self,p,mapping,unique,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.mapping = mapping
    self.unique = unique
    self.d = {}

def __iter__(self):

    return self
#@-node:sps.20080331123552.9:__init__ & __iter__
#@+node:sps.20080331123552.10:next
# moveToThreadNextUnique raises StopIteration
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.moveToThreadNextUnique()

    return self.mapping(self.p)

__next__ = next
#@nonl
#@-node:sps.20080331123552.10:next
#@+node:sps.20080331123552.11:moveToThreadNextUnique
def moveToThreadNextUnique (self):

    """Move a position to threadNext position."""

    p = self.p
    u = self.unique

    if p:
        # We've been visited
        self.d[u(p)]=True

        # First, try to find an unmarked child
        if p.v.t.children:
            p.moveToFirstChild()
            if p == self.after:
                raise StopIteration
            while p and self.d.get(u(p)):
                if p.hasNext():
                    p.moveToNext()
                else:
                    p.moveToParent()
                if p == self.after:
                    raise StopIteration

        # If we didn't find an unmarked child,
        # try to find an unmarked sibling
        if p and self.d.get(u(p)):
            while p.hasNext():
                p.moveToNext()
                if p == self.after:
                    raise StopIteration
                if not self.d.get(u(p)):
                    break

        # If we didn't find an unmarked sibling,
        # find a parent with an unmarked sibling
        if p and self.d.get(u(p)):
            p.moveToParent()
            # if p.equal(self.after):
            if p == self.after:
                raise StopIteration
            while p:
                while p.hasNext():
                    p.moveToNext()
                    if p == self.after:
                        raise StopIteration
                    if not self.d.get(u(p)):
                        break
                # if we run out of siblings, go to parent
                if self.d.get(u(p)):
                    p.moveToParent()
                    if p == self.after:
                        raise StopIteration
                else:
                    break # found
            # At this point, either (not p.d[p.v.t]) and found
            # or (not p) and we're finished

    return p 
#@-node:sps.20080331123552.11:moveToThreadNextUnique
#@-node:sps.20080331123552.12:p.subtree_unique_iter
#@+node:sps.20080331123552.8:p.unique_iter
class unique_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def unique_tnodes_iter (self):

    return self.unique_iter_class(self, lambda p: p.v.t)

def unique_vnodes_iter (self):

    return self.unique_iter_class(self, lambda p: p.v)
#@+node:sps.20080331123552.4:__init__ & __iter__ (p.unique_tnodes_iter)
def __init__(self,p,mapping,unique=lambda p: p.v.t):

    # g.trace('p.unique_tnodes_iter.__init','p',p,)

    self.d = {}
    self.first = p.copy()
    self.p = None
    self.mapping = mapping
    self.unique=unique

def __iter__(self):

    return self
#@-node:sps.20080331123552.4:__init__ & __iter__ (p.unique_tnodes_iter)
#@+node:sps.20080331123552.5:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.moveToThreadNextUnique()

    if self.p:
        return self.mapping(self.p)

    raise StopIteration

__next__ = next
#@-node:sps.20080331123552.5:next
#@+node:sps.20080331123552.7:moveToThreadNextUnique
def moveToThreadNextUnique (self):

    """Move a position to threadNext position."""

    p = self.p
    u = self.unique

    self_d_get = self.d.get
    if p:
        # We've been visited
        self.d[u(p)]=True

        # First, try to find an unmarked child
        if p.v.t.children:
            p.moveToFirstChild()
            while p and self_d_get(u(p)):
                if p.hasNext():
                    p.moveToNext()
                else:
                    p.moveToParent()

        # If we didn't find an unmarked child,
        # try to find an unmarked sibling
        if p and self_d_get(u(p)):
            while p.hasNext():
                p.moveToNext()
                if not self_d_get(u(p)):
                    break

        # If we didn't find an unmarked sibling,
        # find a parent with an unmarked sibling
        if p and self_d_get(u(p)):
            p.moveToParent()
            while p:
                while p.hasNext():
                    p.moveToNext()
                    if not self_d_get(u(p)):
                        break
                # if we run out of siblings, go to parent
                if self_d_get(u(p)):
                    p.moveToParent()
                else:
                    break # found
            # At this point, either (not p.d[p.v.t]) and found
            # or (not p) and we're finished

    return p 
#@-node:sps.20080331123552.7:moveToThreadNextUnique
#@-node:sps.20080331123552.8:p.unique_iter
#@-node:ekr.20091002072933.6096:p.Old iterators
#@+node:ekr.20031218072017.2009:newVnode (fileCommands) (not used)
def newVnode(self,index):

    c = self.c

    v = leoNodes.vnode(context=c)

    if index in self.tnodesDict:
        g.es("bad tnode index:",str(index),"using empty text.")
        return v
    else:
        # Create the tnode.
        # Use the _original_ index as the key in tnodesDict.
        self.tnodesDict[index] = v

        if not g.isString(index):
            g.es("newVnode: unexpected index type:",type(index),index,color="red")

        # Convert any pre-4.1 index to a gnx.
        junk,theTime,junk = gnx = g.app.nodeIndices.scanGnx(index,0)
        if theTime != None:
            v.fileIndex = gnx

        return v
#@-node:ekr.20031218072017.2009:newVnode (fileCommands) (not used)
#@-node:ekr.20091003023754.6105:Not used
#@+node:ekr.20091001141621.6061:c.generators
#@+node:ekr.20091001141621.6043:c.all_nodes & all_unique_nodes
def all_nodes(self):
    c = self
    for p in c.all_positions():
        yield p.v
    raise StopIteration

def all_unique_nodes(self):
    c = self
    for p in c.all_unique_positions():
        yield p.v
    raise StopIteration

# Compatibility with old code.
all_tnodes_iter = all_nodes
all_vnodes_iter = all_nodes
all_unique_tnodes_iter = all_unique_nodes
all_unique_vnodes_iter = all_unique_nodes
#@-node:ekr.20091001141621.6043:c.all_nodes & all_unique_nodes
#@+node:ekr.20091001141621.6062:c.all_unique_positions
def all_unique_positions(self):
    c = self
    p = c.rootPosition() # Make one copy.
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p
            p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
all_positions_with_unique_tnodes_iter = all_unique_positions
all_positions_with_unique_vnodes_iter = all_unique_positions
#@nonl
#@-node:ekr.20091001141621.6062:c.all_unique_positions
#@+node:ekr.20091001141621.6044:c.all_positions
def all_positions (self):
    c = self
    p = c.rootPosition() # Make one copy.
    while p:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
all_positions_iter = all_positions
allNodes_iter = all_positions
#@-node:ekr.20091001141621.6044:c.all_positions
#@-node:ekr.20091001141621.6061:c.generators
#@+node:ekr.20091001141621.6060:p.generators
#@+node:ekr.20091001141621.6055:p.children
def children(self):

    '''Return all children of p.'''

    p = self
    p = p.firstChild()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
children_iter = children
#@-node:ekr.20091001141621.6055:p.children
#@+node:ekr.20091002083910.6102:p.following_siblings
def following_siblings(self):
    '''
    Return all siblings that follow p, not including p.
    '''

    p = self
    p = p.copy() # Always include the original node.
    p = p.next()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
following_siblings_iter = following_siblings
#@-node:ekr.20091002083910.6102:p.following_siblings
#@+node:ekr.20091002083910.6104:p.nodes
def nodes (self):

    p = self
    p = p.copy()
    while p:
        yield p.v
        p.moveToThreadNext()

# Compatibility with old code.
tnodes_iter = nodes
vnodes_iter = nodes
#@-node:ekr.20091002083910.6104:p.nodes
#@+node:ekr.20091001141621.6058:p.parents
def parents(self):

    '''Return all parents of p.'''

    p = self
    p = p.parent()
    while p:
        yield p
        p.moveToParent()
    raise StopIteration

# Compatibility with old code.
parents_iter = parents
#@-node:ekr.20091001141621.6058:p.parents
#@+node:ekr.20091002083910.6099:p.self_and_parents
def self_and_parents(self):

    '''Return p and all parents of p.'''

    p = self
    p = p.copy()
    while p:
        yield p
        p.moveToParent()
    raise StopIteration

# Compatibility with old code.
self_and_parents_iter = self_and_parents
#@-node:ekr.20091002083910.6099:p.self_and_parents
#@+node:ekr.20091001141621.6057:p.self_and_siblings
def self_and_siblings(self):
    '''Return all siblings of p including p.
    '''

    p = self
    p = p.copy()
    while p.hasBack():
        p.moveToBack()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
self_and_siblings_iter = self_and_siblings
#@nonl
#@-node:ekr.20091001141621.6057:p.self_and_siblings
#@+node:ekr.20091001141621.6066:p.self_and_subtree
def self_and_subtree(self):

    '''Return p's entire subtree, including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
self_and_subtree_iter = self_and_subtree
#@-node:ekr.20091001141621.6066:p.self_and_subtree
#@+node:ekr.20091001141621.6056:p.subtree
def subtree(self):

    '''Return all descendants of p, not including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
subtree_iter = subtree
#@-node:ekr.20091001141621.6056:p.subtree
#@+node:ekr.20091002083910.6105:p.unique_nodes
def unique_nodes (self):

    p = self
    p = p.copy()
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p.v
            p.moveToThreadNext()

# Compatibility with old code.
unique_tnodes_iter = unique_nodes
unique_vnodes_iter = unique_nodes
#@-node:ekr.20091002083910.6105:p.unique_nodes
#@+node:ekr.20091002083910.6103:p.unique_subtree
def unique_subtree (self):
    '''Return unique positions in p's entire subtree, including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    seen = set()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p
            p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
subtree_with_unique_tnodes_iter = unique_subtree
subtree_with_unique_vnodes_iter = unique_subtree
#@-node:ekr.20091002083910.6103:p.unique_subtree
#@-node:ekr.20091001141621.6060:p.generators
#@+node:tbrown.20080119085249.1:setIconList & helpers
def setIconList(self, p, l):
    """Set list of icons for position p to l"""

    trace = False and not g.unitTesting

    current = self.getIconList(p)
    if not l and not current: return  # nothing to do
    lHash = ''.join([self.dHash(i) for i in l])
    cHash = ''.join([self.dHash(i) for i in current])
    # if trace: g.trace('lHash:',lHash)
    # if trace: g.trace('cHash:',cHash)
    if lHash == cHash:
        # no difference between original and current list of dictionaries
        return

    if trace: g.trace(l)

    self._setIconListHelper(p, l, p.v)

#@+node:ekr.20090701125429.6012:_setIconListHelper
def _setIconListHelper(self, p, subl, uaLoc):
    """icon setting code common between v and t nodes

    p - postion
    subl - list of icons for the v or t node
    uaLoc - the v or t node"""

    trace = False and not g.unitTesting

    if subl: # Update the uA.
        if not hasattr(uaLoc,'unknownAttributes'):
            uaLoc.unknownAttributes = {}
        uaLoc.unknownAttributes['icons'] = list(subl)
        # g.es((p.h,uaLoc.unknownAttributes['icons']))
        uaLoc.unknownAttributes["lineYOffset"] = 3
        uaLoc._p_changed = 1
        p.setDirty()
        if trace: g.trace('uA',uaLoc.u,uaLoc)
    else: # delete the uA.
        if hasattr(uaLoc,'unknownAttributes'):
            if 'icons' in uaLoc.unknownAttributes:
                del uaLoc.unknownAttributes['icons']
                uaLoc.unknownAttributes["lineYOffset"] = 0
                uaLoc._p_changed = 1
                p.setDirty()
        if trace: g.trace('del uA[icons]',uaLoc)
#@-node:ekr.20090701125429.6012:_setIconListHelper
#@-node:tbrown.20080119085249.1:setIconList & helpers
#@+node:ekr.20080805071954.1:putDescendentTnodeUas
def putDescendentTnodeUas (self,p):

    ### In the one-node world, there are no such things as independent tnodes.
    g.trace('*** ERROR: should not be called')
    return

    trace = False
    if trace: g.trace(p.h)

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = [] ; aList = []
    for p2 in p.self_and_subtree():
        v = p2.v
        if hasattr(v,"unknownAttributes"):
            if v not in tnodes :
                # g.trace(p2.h,v)
                tnodes.append(v)
                aList.append((p2.copy(),v),)

    # Create a list of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create s, an enclosing dict to hold all the inner dicts.
    d = {}
    nodeIndices = g.app.nodeIndices
    for v,d2 in aList:
        # Could be eliminated.
        # New in Leo 4.4.8.  Assign v.fileIndex here as needed.
        if not v.fileIndex:
            v.fileIndex = g.app.nodeIndices.getNewIndex()
        gnx = nodeIndices.toString(v.fileIndex)
        d[gnx]=d2

    if trace: g.trace(g.dictToString(d))

    # Pickle and hexlify d.
    return d and self.pickle(
        torv=p.v,val=d,tag="descendentTnodeUnknownAttributes") or ''
#@-node:ekr.20080805071954.1:putDescendentTnodeUas
#@-node:ekr.20091001141621.6042:iters -> generators & code cleanup
#@+node:ekr.20091219151045.6361:Simplified g.create_temp_file
# We can do this now that we require Python 2.5+
#@nonl
#@+node:ekr.20031218072017.3117:g.create_temp_file & test
def create_temp_file (textMode=False):
    '''Return a tuple (theFile,theFileName)

    theFile: a file object open for writing.
    theFileName: the name of the temporary file.'''

    try:
        # fd is an handle to an open file as would be returned by os.open()
        fd,theFileName = tempfile.mkstemp(text=textMode)
        mode = g.choose(textMode,'w','wb')
        theFile = os.fdopen(fd,mode)
    except Exception:
        g.es('unexpected exception in g.create_temp_file',color='red')
        g.es_exception()
        theFile,theFileName = None,''

    return theFile,theFileName
#@+node:ekr.20090517020744.5873:@test g.create_temp_file
if g.unitTesting:

    c,p = g.getTestVars()

    theFile,fn = g.create_temp_file()
    assert theFile
    assert g.isString(fn)
#@-node:ekr.20090517020744.5873:@test g.create_temp_file
#@-node:ekr.20031218072017.3117:g.create_temp_file & test
#@-node:ekr.20091219151045.6361:Simplified g.create_temp_file
#@-node:ekr.20091007104807.6470:Code
#@-node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20091203060018.6100:leo-3k
@nocolor-node

To do:

- Run all tests in this file (Alt-6).

- Fix plugins that fail with Python3k.

#@+node:ekr.20091203060018.6067:2to3 output
#@+node:ekr.20091203165343.6144:2to3 args
Available transformations for the -f/--fix option:
apply
basestring
buffer
callable
dict
except
exec
execfile
filter
funcattrs
future
getcwdu
has_key
idioms
import
imports
imports2
input
intern
isinstance
itertools
itertools_imports
long
map
metaclass
methodattrs
ne
next
nonzero
numliterals
paren
### print
raise
raw_input
reduce
renames
repr
set_literal
standarderror
sys_exc
throw
tuple_params
types
unicode
urllib
ws_comma
xrange
xreadlines
zip
#@-node:ekr.20091203165343.6144:2to3 args
#@-node:ekr.20091203060018.6067:2to3 output
#@+node:ekr.20091206084842.6197:Details, surprises
@nocolor-node

- add list for .keys(), .values(), .items()
- changes to library & exceptions.

*** Happy surprises ***

Python 3k does significantly better in catching type errors involving arithmetic types.
#@nonl
#@-node:ekr.20091206084842.6197:Details, surprises
#@+node:ekr.20091206161352.6230:Fixed unit tests
#@+node:ekr.20091206150342.6202:print statement in unit tests
ERROR: @test unindent in triple string does not end function

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 32
    print 'h',h
            ^
SyntaxError: invalid syntax
#@-node:ekr.20091206150342.6202:print statement in unit tests
#@+node:ekr.20091206150342.6193:u' in unit tests
======================================================================
ERROR: @test selfInsertCommand-1

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 12
    u = u'(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aBcz):\n'
                                          ^
SyntaxError: invalid syntax

ERROR: @test open non-existent non-ascii directory
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 6
    file = u''

ERROR: @test atFile.printError
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 9
    s = u'La Pe\xf1a'
                    ^
SyntaxError: invalid syntax

ERROR: @test failure to convert unicode characters to ascii
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 13
    s = u''
           ^
SyntaxError: invalid syntax

ERROR: @test g.reportBadChars
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 8
    (u'ab', 'ascii'),
             ^
SyntaxError: invalid syntax
#@-node:ekr.20091206150342.6193:u' in unit tests
#@+node:ekr.20091206150342.6207:string.strip does not exist
#@-node:ekr.20091206150342.6207:string.strip does not exist
#@+node:ekr.20091206150342.6192:sortLines: string.lower does not exist
======================================================================
ERROR: @test reverse-sort-lines-ignoring-case

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4650, in reverseSortLinesIgnoringCase
    return self.sortLines(event,ignoreCase=True,reverse=True)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4676, in sortLines
    if ignoreCase:  aList.sort(key=string.lower)
AttributeError: 'module' object has no attribute 'lower'
#@-node:ekr.20091206150342.6192:sortLines: string.lower does not exist
#@+node:ekr.20091206150342.6191:centerRegion
ERROR: @test center-region

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 2125, in centerRegion
    w.insert(i,' '*n)
TypeError: can't multiply sequence by non-int of type 'float'
#@+node:ekr.20050920084036.69:centerRegion
def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)

    self.beginCommand(undoType='center-region')

    inserted = 0
    while ind < end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) >= self.fillColumn:
            ind = j
        else:
            n = int((self.fillColumn-len(line))/2)
            inserted += n
            k = g.skip_ws(s,i)
            if k > i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    w.setSelectionRange(sel_1,sel_2+inserted)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.69:centerRegion
#@-node:ekr.20091206150342.6191:centerRegion
#@+node:ekr.20091206150342.6195:setInsertPoint
ERROR: @test moveUpOrDownHelper

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 7, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 1105, in setInsertPoint
    i = max(0,min(i,len(s)))
TypeError: unorderable types: int() < str()
#@nonl
#@-node:ekr.20091206150342.6195:setInsertPoint
#@+node:ekr.20091206150342.6201:skipBlock (elisp)
ERROR: @test elisp functions

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 23, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1506, in elispUnitTest
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.el')
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1557, in scannerUnitTest
    self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 862, in createOutline
    func(s,p,atAuto=atAuto)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1610, in scanElispText
    scanner.run(s,parent)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 3096, in run
    self.scan(s,parent)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2554, in scan
    i = self.skipDecls(s,0,len(s),inClass=False)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2786, in skipDecls
    elif self.startsFunction(s,i):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 3254, in startsFunction
    end = self.skipBlock(s,i)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2654, in skipBlock
    if indent < startIndent and line.strip():
TypeError: unorderable types: int() < NoneType()
#@+node:ekr.20070711060113:class elispScanner
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,unused_s,unused_i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.startSigIndent = self.getLeadingIndent(s,i)
    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False

    end = self.skipBlock(s,i)
    # g.trace('%3s %15s block: %s' % (i,repr(s[i:i+10]),repr(s[i:end])))
    if not g.match(s,end-1,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len('defun')
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = self.skipId(s,i) # Bug fix: 2009/09/30
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level <= 0:
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    self.error('no block')
    if 1:
        g.pr('** no block **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@-node:ekr.20091206150342.6201:skipBlock (elisp)
#@+node:ekr.20091206150342.6194:sortColumns
ERROR: @test sort-columns

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4709, in sortColumns
    zlist.sort()
AttributeError: 'zip' object has no attribute 'sort'

#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):

    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not self._chckSel(event): return
    self.beginCommand(undoType='sort-columns')
    try:
        s = w.getAllText()
        ins = w.getInsertPoint()
        sel_1,sel_2 = w.getSelectionRange()
        sint1,sint2 = g.convertPythonIndexToRowCol(s,sel_1)
        sint3,sint4 = g.convertPythonIndexToRowCol(s,sel_2)
        sint1 += 1 ; sint3 += 1
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        txt = s[i:j]
        columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
            for z in range(sint1,sint3+1)]
        aList = g.splitLines(txt)
        zlist = list(zip(columns,aList))
        zlist.sort()
        s = g.joinLines([z[1] for z in zlist])
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_1+len(s),insert=sel_1+len(s))
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.119:sortColumns
#@-node:ekr.20091206150342.6194:sortColumns
#@+node:ekr.20091206150342.6196:setSelectionRangeHelper
ERROR: @test paste from menu into headline sticks

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 10, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 382, in setSelectionRange
    return self.setSelectionRangeHelper(i,j,insert)
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 1594, in setSelectionRangeHelper
    insert = max(0,min(insert,n))
TypeError: unorderable types: int() < str()
#@-node:ekr.20091206150342.6196:setSelectionRangeHelper
#@+node:ekr.20091206150342.6199:flattenHeadline
ERROR: ImportExportTestCase: flattenOutline /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/output/flattenOutline.txt
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1545, in flattenOutline
    c.importCommands.flattenOutline(fileName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 409, in flattenOutline
    theFile.write(head + nl)
TypeError: can't concat bytes to str
#@+node:ekr.20031218072017.1147:flattenOutline
def flattenOutline (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.currentVnode()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    # 10/14/02: support for output_newline setting.
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return

    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel)
        s = g.toEncodedString(head + nl,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
        body = p.moreBody() # Inserts escapes.
        if len(body) > 0:
            s = g.toEncodedString(body + nl,self.encoding,reportErrors=True)
            theFile.write(s)
    theFile.close()
#@-node:ekr.20031218072017.1147:flattenOutline
#@-node:ekr.20091206150342.6199:flattenHeadline
#@+node:ekr.20091206150342.6198:exportHeadlines
ERROR: ImportExportTestCase: exportHeadlines /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/output/exportHeadlines.txt
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1523, in exportHeadlines
    c.importCommands.exportHeadlines(fileName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 384, in exportHeadlines
    theFile.write(head + nl)
TypeError: can't concat bytes to str

#@+node:ekr.20031218072017.1462:exportHeadlines
def exportHeadlines (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.p
    if not p: return
    self.setEncoding()
    firstLevel = p.level()
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return
    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel,useVerticalBar=True)
        s = g.toEncodedString(head + nl,self.encoding,reportErrors=True)
        theFile.write(s)
    theFile.close()
#@-node:ekr.20031218072017.1462:exportHeadlines
#@-node:ekr.20091206150342.6198:exportHeadlines
#@+node:ekr.20091206150342.6200:scanWebFile
ERROR: ImportExportTestCase: importCWEBFiles /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/input/cweave.w
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1626, in importCWEBFiles
    c.importCommands.importWebCommand(names,"cweb")
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1212, in importWebCommand
    p = self.createOutlineFromWeb(fileName,current)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1195, in createOutlineFromWeb
    self.scanWebFile(path,p)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1332, in scanWebFile
    if k > -1: self.cstEnter(s[j:k])
TypeError: unorderable types: NoneType() > int()
#@nonl
#@+node:ekr.20031218072017.3176:find_on_line
def find_on_line(s,i,pattern):

    j = s.find('\n',i)
    if j == -1: j = len(s)
    k = s.find(pattern,i,j)
    return k
#@-node:ekr.20031218072017.3176:find_on_line
#@+node:ekr.20031218072017.3231:scanWebFile (handles limbo)
def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@<","<<")
    rb = g.choose(theType=="cweb","@>",">>")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except Exception:
        g.es("can not import",fileName, color="blue")
        return

    << Create a symbol table of all section names >>
    << Create nodes for limbo text and the root section >>
    while i < len(s):
        outer_progress = i
        << Create a node for the next module >>
        assert(i > outer_progress)
#@nonl
#@+node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
i = 0 ; self.web_st = []

while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k > -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i > progress)

# g.trace(self.cstDump())
#@-node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
#@+node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
i = 0
while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i > progress)

j = g.skip_ws(s,0)
if j < i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i > progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

# g.trace(g.get_line(s,i))
#@-node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
#@+node:ekr.20031218072017.3234:<< Create a node for the next module >>
if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i < len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i > progress)
    << Handle cweb @d, @f, @c and @p directives >>
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i > progress)

body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
#@+node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i > progress)
    i = g.skip_ws_and_nl(s,i)

while i < len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i > progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i < len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i > progress)
#@-node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
#@-node:ekr.20031218072017.3234:<< Create a node for the next module >>
#@-node:ekr.20031218072017.3231:scanWebFile (handles limbo)
#@-node:ekr.20091206150342.6200:scanWebFile
#@+node:ekr.20091206150342.6189:outputStringWithLineEndings
Traceback (most recent call last):

  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoAtFile.py", line 3175, in asisWrite
    at.outputStringWithLineEndings(s)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoAtFile.py", line 4324, in outputStringWithLineEndings
    self.os(s.replace('\n',self.output_newline))
TypeError: expected an object with the buffer interface
#@nonl
#@+node:ekr.20041005105605.205:outputStringWithLineEndings
# Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):

    # Calling self.onl() runs afoul of queued newlines.
    s = g.u(s).replace(g.u('\n'),g.u(self.output_newline))
    self.os(s)
#@-node:ekr.20041005105605.205:outputStringWithLineEndings
#@-node:ekr.20091206150342.6189:outputStringWithLineEndings
#@+node:ekr.20091206150342.6190:parse_leo_file
 File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoFileCommands.py", line 1445, in parse_leo_file
    theFile = StringIO(s)

TypeError: initial_value must be str or None, not bytes
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                pass
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20091206150342.6190:parse_leo_file
#@+node:ekr.20091206224118.6260:unicode failures
FAIL: @test failure to convert unicode characters to ascii
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 11, in <module>
AssertionError: toUnicodeWithErrorCode returns True for  with ascii encoding

======================================================================
FAIL: @test of round-tripping toUnicode & toEncodedString
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 19, in <module>
AssertionError: Round-trip one fails for a

======================================================================
FAIL: @test failure with ascii encodings
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 10, in <module>
AssertionError: toUnicodeWithErrorCode returns True for  with ascii encoding

======================================================================
FAIL: @test round trip toUnicode toEncodedString
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 27, in <module>
AssertionError: Round-trip one failed for a
#@+node:ekr.20080816125725.2:g.isBytes, isChar, isString & isUnicode
# The syntax of these functions must be valid on Python2K and Python3K.

def isBytes(s):
    '''Return True if s is Python3k bytes type.'''
    if g.isPython3:
        # Generates a pylint warning, but that can't be helped.
        return type(s) == type(bytes('a','utf-8'))
    else:
        return False

def isChar(s):
    '''Return True if s is a Python2K character type.'''
    if g.isPython3:
        return False
    else:
        return type(s) == types.StringType

def isString(s):
    '''Return True if s is any string, but not bytes.'''
    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) in types.StringTypes

def isUnicode(s):
    '''Return True if s is a unicode string.'''
    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) == types.UnicodeType
#@-node:ekr.20080816125725.2:g.isBytes, isChar, isString & isUnicode
#@+node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20050208093800:g.toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if g.isUnicode(s):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors: g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@-node:ekr.20050208093800:g.toEncodedString
#@+node:ekr.20080919065433.2:toEncodedStringWithErrorCode (for unit testing)
def toEncodedStringWithErrorCode (s,encoding,reportErrors=False):

    ok = True

    if g.isUnicode(s):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors: g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
            ok = False
    return s, ok
#@-node:ekr.20080919065433.2:toEncodedStringWithErrorCode (for unit testing)
#@+node:ekr.20050208093800.1:g.toUnicode
def toUnicode (s,encoding,reportErrors=False):

    if isPython3:
        convert,mustConvert,nullVal = str,g.isBytes,''
    else:
        convert,nullVal = unicode,unicode('')
        def mustConvert (s):
            return type(s) != types.UnicodeType

    if not s:
        s = nullVal
    elif mustConvert(s):
        try:
            s = convert(s,encoding,'strict')
        except UnicodeError:
            s = convert(s,encoding,'replace')
            if reportErrors: g.reportBadChars(s,encoding)
    else:
        pass

    return s
#@nonl
#@-node:ekr.20050208093800.1:g.toUnicode
#@+node:ekr.20091206161352.6232:g.u
if False:
    def u(s):
        '''Convert the string s to unicode if necessary.'''
        if g.isUnicode(s):
            return s
        elif g.isPython3:
           return str(s)
        else:
            return unicode(s)
else:
    def u(s,encoding='utf-8'):
        '''Convert the string s to unicode if necessary.'''
        if g.isUnicode(s):
            return s
        elif g.isPython3:
           return str(s,encoding)
        else:
            return unicode(s,encoding)

#@-node:ekr.20091206161352.6232:g.u
#@+node:ekr.20080919065433.1:toUnicodeWithErrorCode (for unit testing)
def toUnicodeWithErrorCode (s,encoding,reportErrors=False):

    ok = True
    if g.isPython3: f = str
    else: f = unicode
    if s is None:
        s = g.u('')
    if not g.isUnicode(s):
        try:
            s = f(s,encoding,'strict')
        except (UnicodeError,ValueError):
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = f(s,encoding,'replace')
            ok = False
    return s,ok
#@-node:ekr.20080919065433.1:toUnicodeWithErrorCode (for unit testing)
#@-node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@-node:ekr.20091206224118.6260:unicode failures
#@+node:ekr.20091207194815.6264:t1.next
ERROR: @test find_h / find_b / select_h / select_b

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 23, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoNodes.py", line 2842, in select_b
    first = t1.next()
AttributeError: 'itertools.tee' object has no attribute 'next'
#@+node:ville.20090311195550.1:select_b
def select_b(self, regex, flags = re.IGNORECASE ):
    """ Find all the nodes in poslist where body matches regex

    You can chain find_h / find_b with select_h / select_b like this
    to refine an outline search::

        pl = c.find_h('@thin.*py').select_h('class.*').select_b('import (.*)')
    """
    pat = re.compile(regex, flags)
    res = poslist()
    for p in self:
        m = re.finditer(pat, p.b)
        t1,t2 = itertools.tee(m,2)
        try:
            if g.isPython3:
                first = t1.__next__()
            else:
                first = t1.next()
            # if does not raise StopIteration...
            pc = p.copy()
            pc.matchiter = t2
            res.append(pc)

        except StopIteration:
            pass

    return res
#@-node:ville.20090311195550.1:select_b
#@+node:ville.20090311200059.1:c.find_b
def find_b(self, regex, flags = re.IGNORECASE | re.MULTILINE):
    """ Return list (a poslist) of all nodes whose body matches the regex

    You can chain find_h / find_b with select_h / select_b like this
    to refine an outline search::

    pl = c.find_h('@thin.*py').select_h('class.*').select_b('import (.*)')    
    """

    c = self
    pat = re.compile(regex, flags)
    res = leoNodes.poslist()
    for p in c.all_positions():
        m = re.finditer(pat, p.b)
        t1,t2 = itertools.tee(m,2)
        try:
            if g.isPython3:
                first = t1.__next__()
            else:
                first = t1.next()
        except StopIteration:
            continue
        pc = p.copy()
        pc.matchiter = t2
        res.append(pc)
    return res
#@-node:ville.20090311200059.1:c.find_b
#@-node:ekr.20091207194815.6264:t1.next
#@+node:ekr.20091207194815.6265:putDescendentVnodeUas
FAIL: @test putDescendentVnodeUas

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 19, in <module>
AssertionError: expected: ' descendentVnodeUnknownAttributes="7d7100285503302e3071017d7102550f756e69745f746573745f6368696c6471035504616263647104735505302e302e3071057d71065514756e69745f746573745f6772616e646368696c64710755047778797a710873752e"', got: ' descendentVnodeUnknownAttributes="b\'7d7100285803000000302e3071017d7102580f000000756e69745f746573745f6368696c6471035804000000616263647104735805000000302e302e3071057d71065814000000756e69745f746573745f6772616e646368696c64710758040000007778797a710873752e\'"'
#@-node:ekr.20091207194815.6265:putDescendentVnodeUas
#@+node:ekr.20041001161108:doPlugins
ignoringMessageGiven = False

def doPlugins(tag,keywords):

    global ignoringMessageGiven

    if g.app.killed:
        return

    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
#@-node:ekr.20041001161108:doPlugins
#@-node:ekr.20091206161352.6230:Fixed unit tests
#@+node:ekr.20091209095640.6218:Output tnodes in proper order
#@+node:ekr.20031218072017.1997:scanGnx
def scanGnx (self,s,i):

    """Create a gnx from its string representation"""

    if not g.isString(s):
        g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
        return None,None,None

    s = s.strip()

    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if theId == None or len(theId) == 0:
        theId = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except Exception: pass

    return theId,t,n
#@-node:ekr.20031218072017.1997:scanGnx
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):

    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("<tnodes>\n")
    << write only those tnodes that were referenced >>
    self.put("</tnodes>\n")
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
if self.usingClipboard: # write the current tree.
    theIter = c.p.self_and_subtree()
else: # write everything
    theIter = c.all_unique_positions()

# Populate tnodes
tnodes = {}
nodeIndices = g.app.nodeIndices
for p in theIter:
    # Make *sure* the file index has the proper form.
    # g.trace(p.v.fileIndex)
    try:
        theId,t,n = p.v.fileIndex
    except ValueError:
        try:
            theId,t,n = p.v.fileIndex,''
        except Exception:
            raise BadLeoFile('bad p.v.fileIndex' % repr(index))

    if n is None:
        n = g.u('0')
    elif g.isPython3:
        n = str(n)
    else:
        n = unicode(n)
    index = theId,t,n
    tnodes[index] = p.v

# Put all tnodes in index order.
for index in sorted(tnodes):
    # g.trace(index)
    v = tnodes.get(index)
    if v:
        # Write only those tnodes whose vnodes were written.
        if v.isWriteBit():
            self.putTnode(v)
    else:
        g.trace('can not happen: no vnode for',repr(index))
        # This prevents the file from being written.
        raise BadLeoFile('no vnode for %s' % repr(index))
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@-node:ekr.20091209095640.6218:Output tnodes in proper order
#@+node:ekr.20091217191310.6304:Remove bad chars from .leo files
#@+node:ekr.20090525144314.6526:cleanSaxInputString & test
def cleanSaxInputString(self,s):

    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
#@+node:ekr.20090525144314.6527:@test cleanSaxInputString
if g.unitTesting:

    c,p = g.getTestVars()

    s = 'test%cthis' % 27

    assert c.fileCommands.cleanSaxInputString(s) == 'test this'
#@-node:ekr.20090525144314.6527:@test cleanSaxInputString
#@-node:ekr.20090525144314.6526:cleanSaxInputString & test
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                pass
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20091217191310.6304:Remove bad chars from .leo files
#@+node:ekr.20091209114435.6223:Fixed caching
#@+node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.doubleClickFlag = False
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui
self.ipythonController = None # Set only by the ipython plugin.

# Interlock to prevent setting c.changed when switching chapters.
c.suppressHeadChanged = False

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None
self.timeStampDict = {} # New in Leo 4.6.

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False

# Default Tangle options
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = g.u('') # Must always be a string.
self.navTime = None

pth, bname = os.path.split(self.mFileName)
if pth and bname and g.enableDB:
    fn = self.mFileName.lower()
    fn = g.toEncodedString(fn,'utf-8') # Required for Python 3.x.
    dbdirname = '%s/db/%s_%s' % (
        g.app.homeLeoDir,bname,hashlib.md5(fn).hexdigest())
    # Use compressed pickles (handy for @thin caches)
    self.db = leo.external.pickleshare.PickleShareDB(dbdirname,protocol='picklez')
else:
    self.db = {}
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
#@+node:ekr.20091204132346.6078:<< imports >> (pickleshare.py)
import leo.core.leoGlobals as g
from leo.external.path import path as Path
import glob
import os
import stat
import sys
import time
import warnings

isPython3 = sys.version_info >= (3,0,0)

try:
    import marshal
except ImportError:
    marshal = None

if isPython3:
    import pickle
else:
    import cPickle as pickle

try:
    import simplejson
except ImportError:
    simplejson = None

try:
    import zlib
except ImportError:
    zlib = None
#@-node:ekr.20091204132346.6078:<< imports >> (pickleshare.py)
#@+node:ekr.20041005105605.21:read (atFile) & helper
def read(self,root,
    importFileName=None,thinFile=False,
    fromString=None,atShadow=False,
    force=False
):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName and isAtFile >>
    if isAtFile:
        # The @file node has file-like sentinels iff a tnodeList exists.
        thinFile = not (hasattr(root.v,'tnodeList') and root.v.tnodeList)
    doCache = g.enableDB and (thinFile or atShadow) and not force
    at.initReadIvars(root,fileName,
        importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fileName,fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root, fileContent)

    # Remember that we have read this file.
    root.v.at_read = True # Create the attribute for all clones.

    if doCache and cachefile in c.db:
        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        aList = c.db[cachefile]
        root.v.createOutlineFromCacheList(c,aList)
        at.inputFile.close()
        root.clearDirty()
        return

    # Delete all children, but **not** for @file and @nosent nodes!
    # (We do delete all children for @file nodes with thin-like sentinels.)
    if thinFile or atShadow:
        root.v.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if not g.unitTesting:
        g.es("reading:",root.h)

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName and isAtFile >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False

isAtFile = (
    not thinFile and
    not importFileName and
    not atShadow and
    not fromString and
    root.h.startswith('@file'))
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName and isAtFile >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
resurrected = 0
for p in root.self_and_subtree():
    if p.v.isVisited():
        pass
        # g.trace('visited',p.v,p.h)
    else:
        g.trace('**** not visited',p.v,p.h)
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for v in c.all_unique_nodes():

    if hasattr(v,"tempBodyString"):
        delattr(v,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile) & helper
#@+node:ekr.20091204132346.6080:class PickleShareDB
_sentinel = object()

class PickleShareDB:
    """ The main 'connection' object for PickleShare database """
    @others
#@+node:ekr.20091204132346.6081: __init__
def __init__(self,root, protocol = 'pickle'):
    """ Initialize a PickleShare object that will manage the specied directory

    root: The directory that contains the data. Created if it doesn't exist.

    protocol: one of 

        * 'pickle' (universal, default) 
        * 'picklez' (compressed pickle)         
        * 'marshal' (fast, limited type support)
        * 'json' : brief, human-readable, very limited type support

    Protol 'json' requires installation of simplejson module
    """
    self.root = Path(root).expanduser().abspath()
    if not self.root.isdir():
        self.root.makedirs()
    # cache has { 'key' : (obj, orig_mod_time) }
    self.cache = {}

    if protocol == 'pickle':
        self.loader = pickle.load
        self.dumper = pickle.dump
    elif protocol == 'marshal':
        if marshal:
            self.loader = marshal.load
            self.dumper = marshal.dump
    elif protocol == 'json':
        if simplejson:
            self.loader = simplejson.load
            self.dumper = simplejson.dump
    elif protocol == 'picklez':
        if zlib:
            def loadz(fileobj):
                val = pickle.loads(zlib.decompress(fileobj.read()))
                return val

            def dumpz(val, fileobj):
                compressed = zlib.compress(pickle.dumps(val, pickle.HIGHEST_PROTOCOL))
                fileobj.write(compressed)

            self.loader = loadz
            self.dumper = dumpz
#@-node:ekr.20091204132346.6081: __init__
#@+node:ekr.20091216103214.6305:__contains__
def __contains__(self, key):

    return self.has_key(key)
#@-node:ekr.20091216103214.6305:__contains__
#@+node:ekr.20091204132346.6088:__delitem__
def __delitem__(self,key):

    """ del db["key"] """

    fil = self.root / key
    # g.trace('(PickleShareDB)',key) # ,g.shortFileName(fil))
    self.cache.pop(fil,None)
    try:
        fil.remove()
    except OSError:
        # notfound and permission denied are ok - we
        # lost, the other process wins the conflict
        pass
#@-node:ekr.20091204132346.6088:__delitem__
#@+node:ekr.20091204132346.6082:__getitem__
def __getitem__(self,key):

    """ db['key'] reading """

    fil = self.root / key
    # g.trace('(PickleShareDB)',key) #,g.shortFileName(fil))
    try:
        mtime = (fil.stat()[stat.ST_MTIME])
    except OSError:
        raise KeyError(key)

    if fil in self.cache and mtime == self.cache[fil][1]:
        return self.cache[fil][0]
    try:
        # The cached item has expired, need to read
        obj = self.loader(fil.open("rb"))
    except:
        raise KeyError(key)

    self.cache[fil] = (obj,mtime)
    return obj
#@-node:ekr.20091204132346.6082:__getitem__
#@+node:ekr.20091216103214.6303:__iter__
def __iter__(self):

    for k in list(self.keys()):
        yield k
#@-node:ekr.20091216103214.6303:__iter__
#@+node:ekr.20091204132346.6094:__repr__
def __repr__(self):

    return "PickleShareDB('%s')" % self.root



#@-node:ekr.20091204132346.6094:__repr__
#@+node:ekr.20091204132346.6083:__setitem__
def __setitem__(self,key,value):

    """ db['key'] = 5 """

    fil = self.root / key
    parent = fil.parent
    if parent and not parent.isdir():
        parent.makedirs()
    pickled = self.dumper(value,fil.open('wb'))
    # g.trace('(PickleShareDB)',key) # ,g.shortFileName(fil))
    try:
        self.cache[fil] = (value,fil.mtime)
    except OSError as e:
        if e.errno != 2:
            raise

#@-node:ekr.20091204132346.6083:__setitem__
#@+node:ekr.20091204132346.6089:_normalized
def _normalized(self, p):
    """ Make a key suitable for user's eyes """
    return str(self.root.relpathto(p)).replace('\\','/')

#@-node:ekr.20091204132346.6089:_normalized
#@+node:ekr.20091204132346.6093:getlink
def getlink(self,folder):
    """ Get a convenient link for accessing items  """
    return PickleShareLink(self, folder)

#@-node:ekr.20091204132346.6093:getlink
#@+node:ekr.20091216103214.6304:has_key
def has_key(self, key):

    try:
        value = self[key]
    except KeyError:
        return False

    return True
#@-node:ekr.20091216103214.6304:has_key
#@+node:ekr.20091204132346.6087:hcompress
def hcompress(self, hashroot):
    """ Compress category 'hashroot', so hset is fast again

    hget will fail if fast_only is True for compressed items (that were
    hset before hcompress).

    """
    hfiles = self.keys(hashroot + "/*")
    all = {}
    for f in hfiles:
        # print("using",f)
        all.update(self[f])
        self.uncache(f)

    self[hashroot + '/xx'] = all
    for f in hfiles:
        p = self.root / f
        if p.basename() == 'xx':
            continue
        p.remove()



#@-node:ekr.20091204132346.6087:hcompress
#@+node:ekr.20091204132346.6086:hdict
def hdict(self, hashroot):
    """ Get all data contained in hashed category 'hashroot' as dict """
    hfiles = self.keys(hashroot + "/*")
    hfiles.sort()
    last = len(hfiles) and hfiles[-1] or ''
    if last.endswith('xx'):
        # print("using xx")
        hfiles = [last] + hfiles[:-1]

    all = {}

    for f in hfiles:
        # print("using",f)
        try:
            all.update(self[f])
        except KeyError:
            print("Corrupt",f,"deleted - hset is not threadsafe!")
            del self[f]

        self.uncache(f)

    return all
#@-node:ekr.20091204132346.6086:hdict
#@+node:ekr.20091204132346.6085:hget
def hget(self, hashroot, key, default = _sentinel, fast_only = True):
    """ hashed get """
    hroot = self.root / hashroot
    hfile = hroot / gethashfile(key)
    d = self.get(hfile, _sentinel )
    g.trace("got dict",d,"from",g.shortFileName(hfile))
    if d is _sentinel:
        if fast_only:
            if default is _sentinel:
                raise KeyError(key)
            return default
        # slow mode ok, works even after hcompress()
        d = self.hdict(hashroot)

    return d.get(key, default)
#@nonl
#@-node:ekr.20091204132346.6085:hget
#@+node:ekr.20091204132346.6084:hset
def hset(self, hashroot, key, value):
    """ hashed set """
    hroot = self.root / hashroot
    if not hroot.isdir():
        hroot.makedirs()
    hfile = hroot / gethashfile(key)
    d = self.get(hfile, {})
    d.update( {key : value})
    self[hfile] = d                



#@-node:ekr.20091204132346.6084:hset
#@+node:ekr.20091216103214.6306:iteritems & iterkeys
def iteritems(self):
    for k in self:
        yield (k, self[k])

def iterkeys(self):
    return self.__iter__()
#@-node:ekr.20091216103214.6306:iteritems & iterkeys
#@+node:ekr.20091204132346.6090:keys
def keys(self, globpat = None):
    """ All keys in DB, or all keys matching a glob"""

    if globpat is None:
        files = self.root.walkfiles()
    else:
        files = [Path(p) for p in glob.glob(self.root/globpat)]

    return [self._normalized(p) for p in files if p.isfile()]

#@-node:ekr.20091204132346.6090:keys
#@+node:ekr.20091204132346.6091:uncache
def uncache(self,*items):
    """ Removes all, or specified items from cache

    Use this after reading a large amount of large objects
    to free up memory, when you won't be needing the objects
    for a while.

    """
    if not items:
        self.cache = {}
    for it in items:
        self.cache.pop(it,None)

#@-node:ekr.20091204132346.6091:uncache
#@+node:ekr.20091204132346.6092:waitget
def waitget(self,key, maxwaittime = 60 ):
    """ Wait (poll) for a key to get a value

    Will wait for `maxwaittime` seconds before raising a KeyError.
    The call exits normally if the `key` field in db gets a value
    within the timeout period.

    Use this for synchronizing different processes or for ensuring
    that an unfortunately timed "db['key'] = newvalue" operation 
    in another process (which causes all 'get' operation to cause a 
    KeyError for the duration of pickling) won't screw up your program 
    logic. 
    """

    wtimes = [0.2] * 3 + [0.5] * 2 + [1]
    tries = 0
    waited = 0
    while 1:
        try:
            val = self[key]
            return val
        except KeyError:
            pass

        if waited > maxwaittime:
            raise KeyError(key)

        time.sleep(wtimes[tries])
        waited+=wtimes[tries]
        if tries < len(wtimes) -1:
            tries+=1
#@-node:ekr.20091204132346.6092:waitget
#@-node:ekr.20091204132346.6080:class PickleShareDB
#@-node:ekr.20091209114435.6223:Fixed caching
#@+node:ekr.20091218143600.6302:Fixed doctest problems on Linux
#@+node:ekr.20051104075904.99:createUnitTestsFromDoctests
def createUnitTestsFromDoctests (modules,verbose=True):

    created = False # True if suite is non-empty.

    suite = unittest.makeSuite(unittest.TestCase)

    for module in list(modules):
        # New in Python 4.2: n may be zero.
        try:
            test = doctest.DocTestSuite(module)
            n = test.countTestCases()
            if n > 0:
                suite.addTest(test)
                created = True
                if verbose:
                    g.pr("found %2d doctests for %s" % (n,module.__name__))
        except ValueError:
            g.pr('no doctests in %s' % module.__name__)
            pass # No tests found.

    return g.choose(created,suite,None)
#@-node:ekr.20051104075904.99:createUnitTestsFromDoctests
#@+node:ekr.20051104075904.102:importAllModulesInPath
def importAllModulesInPath (path,exclude=[]):

    path = g.os_path_finalize(path)

    if not g.os_path_exists(path):
        g.es("path does not exist:",path)
        return []

    path2 = g.os_path_join(path,"leo*.py")
    files = glob.glob(path2)
    files2 = []
    for theFile in files:
        for z in exclude:
            if theFile.endswith(z):
                break
        else:
            files2.append(theFile)
    modules = []

    for theFile in files2:
        module = safeImportModule(theFile)
        if module:
            modules.append(module)

    # g.trace(modules)
    return modules
#@nonl
#@-node:ekr.20051104075904.102:importAllModulesInPath
#@+node:ekr.20051104075904.103:safeImportModule & test
@ Warning: do NOT use g.importFromPath here!

g.importFromPath uses imp.load_module, and that is equivalent to reload!
reloading Leo files while running will crash Leo.
@c

def safeImportModule (fileName):

    fileName = g.os_path_finalize(fileName)
    head,tail = g.os_path_split(fileName)
    moduleName,ext = g.os_path_splitext(tail)
    oldUnitTesting = g.unitTesting

    if ext == ".py":
        try:
            # g.trace(moduleName)
            g.unitTesting = False # Disable @test nodes!
            g.app.unitTesting = False
            try:
                # for base in ('leo.core','leo.plugins','leo.external',):
                    # fullName = '%s.%s' % (base,moduleName)
                    # m = __import__(fullName) # 'leo.core.%s' % moduleName)
                    # if m is not None:
                        # return sys.modules.get(fullName)
                fullName = 'leo.core.%s' % (moduleName)
                __import__(fullName)
                return sys.modules.get(fullName)
            finally:
                g.unitTesting = oldUnitTesting
                g.app.unitTesting = oldUnitTesting
        except Exception:
            # g.trace('can not import',moduleName,fileName)
            # leoScriptModule.py, for example, can throw other exceptions.
            return None
    else:
        g.pr("Not a .py file:",fileName)
        return None
#@+node:ekr.20090703155133.6418:@test safeImportModule
if g.unitTesting:

    d = g.app.unitTestDict
    c,p = g.getTestVars()
    assert d.get('getTestVars') is True
    d['getTestVars'] = False

    # Do lots of imports.
    import leo.core.leoTest as leoTest
    path = g.os_path_join(g.app.loadDir,"..","core")
    modules = leoTest.importAllModulesInPath(path)

    # Assert that g.getTestVars has not been called.
    val = d.get('getTestVars')
    assert val is False, val

#@-node:ekr.20090703155133.6418:@test safeImportModule
#@-node:ekr.20051104075904.103:safeImportModule & test
#@-node:ekr.20091218143600.6302:Fixed doctest problems on Linux
#@+node:ekr.20091218173731.6717:Fixed completer crash
#@+node:ekr.20060221083356:g.prettyPrintType
def prettyPrintType (obj):

    if g.isPython3:
        if type(obj) in (types.MethodType,types.BuiltinMethodType):
            return 'method'
        elif type(obj) in (types.BuiltinFunctionType,types.FunctionType):
            return 'function'
        elif type(obj) == types.ModuleType:
            return 'module'
        elif g.isString(obj):
            return 'string'
        else:
            theType = str(type(obj))
            if theType.startswith("<type '"): theType = theType[7:]
            if theType.endswith("'>"): theType = theType[:-2]
            return theType
    else:
        if type(obj) in (
            types.MethodType,types.UnboundMethodType,types.BuiltinMethodType):
            return 'method'
        elif type(obj) in (types.BuiltinFunctionType,types.FunctionType):
            return 'function'
        elif type(obj) == types.ModuleType:
            return 'module'
        elif type(obj) == types.InstanceType:
            return 'object'
        elif type(obj) in (types.UnicodeType,types.StringType):
            return 'string'
        else:
            theType = str(type(obj))
            if theType.startswith("<type '"): theType = theType[7:]
            if theType.endswith("'>"): theType = theType[:-2]
            return theType
#@-node:ekr.20060221083356:g.prettyPrintType
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    if g.isPython3:
        for z in gc.get_objects():
            name = z.__class__.__name__
            self.allClassesDict [name] = z
    else:
        for z in gc.get_objects():
            t = type(z)
            if t == types.ClassType:
                name = z.__name__
            elif t == types.InstanceType:
                name = z.__class__.__name__
            elif repr(t).startswith('<class'): # A wretched kludge.
                name = z.__class__.__name__
            elif t == types.TypeType:
                name = z.__name__
            else:
                name = None
            if name:
                # if name == 'position': g.trace(t,z)
                self.allClassesDict [name] = z

    # g.printList(list(self.allClassesDict.keys()),tag='Classes',sort=True)
    # g.trace(len(list(self.allClassesDict.keys())))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@-node:ekr.20091218173731.6717:Fixed completer crash
#@+node:ekr.20091218182246.6722:Added entries for haxe language
#@+node:ekr.20031218072017.368:<< define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lua"           : "--",  # ddm 13/02/06
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--', # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    "rst"           : "rst",
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
#@-node:ekr.20031218072017.368:<< define global data structures >> (leoApp.py)
#@-node:ekr.20091218182246.6722:Added entries for haxe language
#@-node:ekr.20091203060018.6100:leo-3k
#@+node:ekr.20091211111443.6264:Batch operations on nodes
#@+node:ekr.20091211111443.6265:c.doBatchOperations & helpers
def doBatchOperations (self,aList):
    # Validate aList and create the parents dict
    ok, d = self.checkBatchOperationsList()
    if not ok:
        return g.es('do-batch-operations: invalid list argument',
            color='red')

    for v in list(d.keys()):
        aList2 = d.get(v,[])
        if aList2:
            aList.sort()
            for n,op in aList2:
                if op == 'insert':
                    g.trace('insert:',v.h,n)
                else:
                    g.trace('delete:',v.h,n)
#@+node:ekr.20091211111443.6266:checkBatchOperationsList
def checkBatchOperationsList(self,aList):
    ok = True ; d = {}
    for z in aList:
        try:
            op,p,n = z
            ok= (op in ('insert','delete') and
                isinstance(p,leoNodes.position) and
                type(n) == type(9))
            if ok:
                aList2 = d.get(p.v,[])
                data = n,op
                aList2.append(data)
                d[p.v] = aList2
        except ValueError:
            ok = False
        if not ok: break
    return ok,d
#@nonl
#@-node:ekr.20091211111443.6266:checkBatchOperationsList
#@-node:ekr.20091211111443.6265:c.doBatchOperations & helpers
#@+node:ekr.20091210082012.6231:Comparing positions
#@+node:ekr.20080416161551.190: p.__init__
def __init__ (self,v,childIndex=0,stack=None,trace=False):

    '''Create a new position with the given childIndex and parent stack.'''

    # To support ZODB the code must set v._p_changed = 1
    # whenever any mutable vnode object changes.

    self._childIndex = childIndex
    self.v = v

    # New in Leo 4.5: stack entries are tuples (v,childIndex).
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())

    self.txtOffset = None # see self.textOffset()
#@-node:ekr.20080416161551.190: p.__init__
#@+node:ekr.20080920052058.3:p.__eq__ & __ne__
def __eq__(self,p2):

    """Return True if two postions are equivalent."""

    p1 = self

    # Don't use g.trace: it might call p.__eq__ or p.__ne__.
    # print ('p.__eq__: %s %s' % (
        # p1 and p1.v and p1.h,p2 and p2.v and p2.h))

    if p2 is None or p2.v is None:
        return p1.v is None
    else:
        return ( p1.v == p2.v and
            p1._childIndex == p2._childIndex and
            p1.stack == p2.stack )

def __ne__(self,p2):

    """Return True if two postions are not equivalent."""

    return not self.__eq__(p2) # For possible use in Python 2.x.
#@-node:ekr.20080920052058.3:p.__eq__ & __ne__
#@+node:ekr.20091210082012.6230:p.__ge__ & __le__& __lt__
def __ge__ (self,other):

    return self.__eq__(other) or self.__gt__(other)

def __le__ (self,other):

    return self.__eq__(other) or self.__lt__(other)

def __lt__ (self,other):

    return not self.__eq__(other) and not self.__gt__(other)
#@-node:ekr.20091210082012.6230:p.__ge__ & __le__& __lt__
#@+node:ekr.20091210082012.6233:p.__gt__
def __gt__ (self,other):

    '''Return True if self appears after other in outline order.'''

    stack1,stack2 = self.stack,other.stack
    n1,n2 = len(stack1),len(stack2) ; n = min(n1,n2)
    # Compare the common part of the stacks.
    for item1,item2 in zip(stack1,stack2):
        v1,x1 = item1 ; v2,x2 = item2
        if x1 > x2: return True
        elif x1 < x2: return False
    # Finish the comparison.
    if n1 == n2:
        x1,x2 = self._childIndex,other._childIndex
        return x1 > x2
    elif n1 < n2:
        x1 = self._childIndex; v2,x2 = other.stack[n]
        return x1 > x2
    else:
        return True
#@nonl
#@-node:ekr.20091210082012.6233:p.__gt__
#@+node:ekr.20091210082012.6232:@test p rich comparison methods
if g.unitTesting:

    c,p = g.getTestVars()

    last = None

    for p in c.all_positions():
        if last:
            assert p > last,'%s <= %s' % (p.h,last.h)
        last = p.copy()
#@nonl
#@-node:ekr.20091210082012.6232:@test p rich comparison methods
#@+node:ekr.20080427062528.4:p._adjustPositionBeforeUnlink
def _adjustPositionBeforeUnlink (self,p2):

    '''Adjust position p before unlinking p2.'''

    # p will change if p2 is a previous sibling of p or
    # p2 is a previous sibling of any ancestor of p.

    trace = False and not g.unitTesting
    p = self ; sib = p.copy()

    if trace: g.trace('entry',p.stack)

    # A special case for previous siblings.
    # Adjust p._childIndex, not the stack's childIndex.
    while sib.hasBack():
        sib.moveToBack()
        if sib == p2:
            p._childIndex -= 1
            if trace: g.trace('***new index: %s\n%s' % (
                p.h,p.stack))
            return

    # Adjust p's stack.
    stack = [] ; changed = False ; i = 0
    while i < len(p.stack):
        v,childIndex = p.stack[i]
        p3 = position(v=v,childIndex=childIndex,stack=stack[:i])
        while p3:
            if p2.v == p3.v: # A match with the to-be-moved node?
                stack.append((v,childIndex-1),)
                changed = True
                break # terminate only the inner loop.
            p3.moveToBack()
        else:
            stack.append((v,childIndex),)
        i += 1

    if changed:
        if trace: g.trace('***new stack: %s\n%s' % (
            p.h,stack))
        p.stack = stack
#@nonl
#@+node:ekr.20090713125326.6116:@test p.adjustPositionBeforeUnlink
if g.unitTesting:

    c,p = g.getTestVars()

    table = (
        '1',
        '1-1','1-1-1','1-1-2',
        '1-2','1-2-1','1-2-2',
        '2',
        '2-1','2-1-1','2-1-2',
        '2-2','2-2-1','2-2-2',
        '3',
        '3-1','3-1-1','3-1-2',
        '3-2','3-2-1','3-2-2',
    )

    for suffix in table:
        h = 'node %s' % suffix
        p2 = g.findNodeInTree(c,p,h)
        assert p2,h

    table2 = (
        ('2-1-2','2-1-1','2-1-1'),
        ('3','2','2'),
    )  

    for h1,h2,h3 in table2:
        p1 = g.findNodeInTree(c,p,'node %s' % h1)
        p2 = g.findNodeInTree(c,p,'node %s' % h2)
        p3 = g.findNodeInTree(c,p,'node %s' % h3)
        p1._adjustPositionBeforeUnlink(p2)
        result = p1
        assert result.stack == p3.stack,'expected %s got %s' % (
            p3.h,result and result.h or '<none>')

    # Data.
    @others
#@+node:ekr.20090713125326.6117:node 1
# Node 1
#@nonl
#@+node:ekr.20090713125326.6118:node 1-1
# node 1-1
#@nonl
#@+node:ekr.20090713125326.6119:node 1-1-1
# node 1-1-1
#@nonl
#@-node:ekr.20090713125326.6119:node 1-1-1
#@+node:ekr.20090713125326.6135:node 1-1-2
# node 1-1-2
#@nonl
#@-node:ekr.20090713125326.6135:node 1-1-2
#@-node:ekr.20090713125326.6118:node 1-1
#@+node:ekr.20090713125326.6133:node 1-2
# node 1-2
#@nonl
#@+node:ekr.20090713125326.6134:node 1-2-1
# node 1-2-1
#@nonl
#@-node:ekr.20090713125326.6134:node 1-2-1
#@+node:ekr.20090713125326.6136:node 1-2-2
# node 1-2-2
#@nonl
#@-node:ekr.20090713125326.6136:node 1-2-2
#@-node:ekr.20090713125326.6133:node 1-2
#@-node:ekr.20090713125326.6117:node 1
#@+node:ekr.20090713125326.6124:node 2
# node 2
#@nonl
#@+node:ekr.20090713125326.6125:node 2-1
# node 2-1
#@nonl
#@+node:ekr.20090713125326.6126:node 2-1-1
# node 2-1-1
#@nonl
#@-node:ekr.20090713125326.6126:node 2-1-1
#@+node:ekr.20090713125326.6137:node 2-1-2
# node 2-1-2
#@-node:ekr.20090713125326.6137:node 2-1-2
#@-node:ekr.20090713125326.6125:node 2-1
#@+node:ekr.20090713125326.6142:node 2-2
# node 2-2
#@nonl
#@+node:ekr.20090713125326.6143:node 2-2-1
# node 2-2-1
#@nonl
#@-node:ekr.20090713125326.6143:node 2-2-1
#@+node:ekr.20090713125326.6144:node 2-2-2
# node 2-2-2
#@-node:ekr.20090713125326.6144:node 2-2-2
#@-node:ekr.20090713125326.6142:node 2-2
#@-node:ekr.20090713125326.6124:node 2
#@+node:ekr.20090713125326.6130:node 3
# node 3
#@nonl
#@+node:ekr.20090713125326.6131:node 3-1
# node 3-1
#@+node:ekr.20090713125326.6132:node 3-1-1
# node 3-1-1
#@nonl
#@-node:ekr.20090713125326.6132:node 3-1-1
#@+node:ekr.20090713125326.6138:node 3-1-2
# node 3-1-2
#@-node:ekr.20090713125326.6138:node 3-1-2
#@-node:ekr.20090713125326.6131:node 3-1
#@+node:ekr.20090713125326.6148:node 3-2
# node 3-2
#@+node:ekr.20090713125326.6149:node 3-2-1
# node 3-2-1
#@nonl
#@-node:ekr.20090713125326.6149:node 3-2-1
#@+node:ekr.20090713125326.6150:node 3-2-2
# node 3-2-2
#@-node:ekr.20090713125326.6150:node 3-2-2
#@-node:ekr.20090713125326.6148:node 3-2
#@-node:ekr.20090713125326.6130:node 3
#@-node:ekr.20090713125326.6116:@test p.adjustPositionBeforeUnlink
#@-node:ekr.20080427062528.4:p._adjustPositionBeforeUnlink
#@-node:ekr.20091210082012.6231:Comparing positions
#@-node:ekr.20091211111443.6264:Batch operations on nodes
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
