#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file leoProjects.txt
#@+all
#@+node:ekr.20101127152442.5916: ** Testing
#@+node:ekr.20101115092550.5825: *3* Pylint reports
@killcolor

Wrong:
************* Module leo.core.leoFileCommands
E1120:833:baseFileCommands.getDiff: No value passed for parameter 'b' in function call
E1101:1048:baseFileCommands.cleanSaxInputString: Class 'str' has no 'maketrans' member
#@+node:ekr.20101115092550.5826: *4* Minor plugins
************* Module leo.plugins.groupOperations
W0601:190:initImages: Global variable 'groupOpPI' undefined at the module level
W0601:191:initImages: Global variable 'bullseyePI' undefined at the module level
W0601:192:initImages: Global variable 'copyPI' undefined at the module level
W0601:193:initImages: Global variable 'clonePI' undefined at the module level
W0601:194:initImages: Global variable 'movePI' undefined at the module level
W0601:195:initImages: Global variable 'move_arrowPI' undefined at the module level
W0601:196:initImages: Global variable 'copy_arrowPI' undefined at the module level
W0601:197:initImages: Global variable 'clone_arrowPI' undefined at the module level
W0601:198:initImages: Global variable 'markSpotPI' undefined at the module level
W0601:199:initImages: Global variable 'markForPI' undefined at the module level
W0601:200:initImages: Global variable 'operateOnMarkedPI' undefined at the module level
W0601:201:initImages: Global variable 'clearMarksPI' undefined at the module level
W0601:202:initImages: Global variable 'transferFromPI' undefined at the module level
W0611: 33: Unused import copy
W0611: 34: Unused import base64

************* Module leo.plugins.leoupdate
W0105: 59: String statement has no effect
W0601: 85:onCreate: Global variable 'thePluginController' undefined at the module level
W0601: 92:topLevelMenu: Global variable 'thePluginController' undefined at the module level
E1101:132:LeoUpdater.showManagerDialog.HandlerDialog.initLocalCollection: Instance of 'HandlerDialog' has no 'c' member
E1101:150:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'remote_plugin_list' member
E1101:151:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
E1101:155:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
E1101:159:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'plugin_list' member
E1101:160:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'plugin_list' member
E1101:162:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'remote_plugin_list' member
E1101:163:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
W0611: 28: Unused import glob
W0611: 27: Unused import sys
W0611: 26: Unused import re

************* Module leo.plugins.mod_labels
W0311:113: Bad indentation. Found 3 spaces, expected 4
W0311:114: Bad indentation. Found 6 spaces, expected 8
W0311:121: Bad indentation. Found 6 spaces, expected 8
W0311:123: Bad indentation. Found 3 spaces, expected 4
W0311:124: Bad indentation. Found 6 spaces, expected 8
W0311:128: Bad indentation. Found 3 spaces, expected 4
W0311:129: Bad indentation. Found 6 spaces, expected 8
W0311:130: Bad indentation. Found 6 spaces, expected 8
W0311:135: Bad indentation. Found 6 spaces, expected 8
W0311:137: Bad indentation. Found 3 spaces, expected 4
W0311:138: Bad indentation. Found 6 spaces, expected 8
W0311:201: Bad indentation. Found 20 spaces, expected 16
W0311:202: Bad indentation. Found 20 spaces, expected 16
W0311:203: Bad indentation. Found 20 spaces, expected 16
W0311:204: Bad indentation. Found 28 spaces, expected 20
W0311:205: Bad indentation. Found 20 spaces, expected 16
W0311:207: Bad indentation. Found 20 spaces, expected 16
W0311:221: Bad indentation. Found 20 spaces, expected 16
W0311:223: Bad indentation. Found 20 spaces, expected 16
W0311:231: Bad indentation. Found 20 spaces, expected 16
E1123:537:labelsController.label_to_subnode: Passing unexpected keyword argument 'p' in function call
E1120:537:labelsController.label_to_subnode: No value passed for parameter 'v' in function call
E1101:566:labelsController.subnode_to_label: Instance of 'labelsController' has no 'get_labellist_for_node' member
E0602:574:labelsController.subnode_to_label: Undefined variable 'v'
E0602:600:labelsController.subnode_to_label: Undefined variable 'labels'
E0602:601:labelsController.subnode_to_label: Undefined variable 'v'
E0602:601:labelsController.subnode_to_label: Undefined variable 'labels'
E0602:606:labelsController.subnode_to_label: Undefined variable 'v'
E1120:618:labelsController.subnodes_to_label: No value passed for parameter 'title' in function call
E0602:668:labelsController.subnodes_to_labels: Undefined variable 'v'
W0611: 37: Unused import leoAtFile
W0611: 38: Unused import leoCommands
W0611: 48: Unused import os
('EKR: exit status', 6)
('*****', 'c:\\leo.repo\\trunk\\leo\\plugins\\mod_read_dir_outline.py', '')
************* Module leo.plugins.mod_read_dir_outline
E1103:105:controller.readDir: Instance of 'unitTestGui' has no 'runOpenDirectoryDialog' member (but some types could notbe inferred)
E1103:105:controller.readDir: Instance of 'nullGui' has no 'runOpenDirectoryDialog' member (but some types could not beinferred)

************* Module leo.plugins.multifile
E1103:131:insertDirectoryString: Instance of 'unitTestGui' has no 'runOpenDirectoryDialog' member (but some types could not be inferred)
E1103:131:insertDirectoryString: Instance of 'nullGui' has no 'runOpenDirectoryDialog' member (but some types could not be inferred)

************* Module leo.plugins.newButtons
E1101:246:UIHelperClass.addWidgets: Instance of 'FlatOptionMenu' has no 'pack' member
E1111:359:HelperForm.formCommit: Assigning to function call which doesn't return

************* Module leo.plugins.nodeActions
W0312:252: Found indentation with tabs instead of spaces
W0312:253: Found indentation with tabs instead of spaces
W0312:254: Found indentation with tabs instead of spaces
W0312:255: Found indentation with tabs instead of spaces
W0312:256: Found indentation with tabs instead of spaces
W0312:257: Found indentation with tabs instead of spaces
W0311:261: Bad indentation. Found 3 spaces, expected 4
W0311:270: Bad indentation. Found 3 spaces, expected 4
W0311:272: Bad indentation. Found 3 spaces, expected 4
W0311:273: Bad indentation. Found 6 spaces, expected 8
W0311:276: Bad indentation. Found 3 spaces, expected 4
W0311:277: Bad indentation. Found 3 spaces, expected 4
W0311:278: Bad indentation. Found 6 spaces, expected 8
W0311:281: Bad indentation. Found 3 spaces, expected 4
W0311:282: Bad indentation. Found 3 spaces, expected 4
W0311:283: Bad indentation. Found 6 spaces, expected 8
W0311:285: Bad indentation. Found 3 spaces, expected 4
W0311:287: Bad indentation. Found 6 spaces, expected 8
W0311:288: Bad indentation. Found 6 spaces, expected 8
W0311:290: Bad indentation. Found 6 spaces, expected 8
W0311:293: Bad indentation. Found 9 spaces, expected 12
W0311:294: Bad indentation. Found 12 spaces, expected 16
W0311:297: Bad indentation. Found 9 spaces, expected 12
W0311:298: Bad indentation. Found 12 spaces, expected 16
W0311:300: Bad indentation. Found 9 spaces, expected 12
W0311:301: Bad indentation. Found 9 spaces, expected 12
W0311:302: Bad indentation. Found 12 spaces, expected 16
W0311:305: Bad indentation. Found 9 spaces, expected 12
W0311:306: Bad indentation. Found 9 spaces, expected 12
W0311:307: Bad indentation. Found 12 spaces, expected 16
W0311:308: Bad indentation. Found 9 spaces, expected 12
W0311:309: Bad indentation. Found 12 spaces, expected 16
W0311:311: Bad indentation. Found 9 spaces, expected 12
W0311:312: Bad indentation. Found 9 spaces, expected 12
W0311:313: Bad indentation. Found 9 spaces, expected 12
W0311:314: Bad indentation. Found 12 spaces, expected 16
W0311:316: Bad indentation. Found 9 spaces, expected 12
W0311:317: Bad indentation. Found 9 spaces, expected 12
W0311:318: Bad indentation. Found 12 spaces, expected 16
W0311:322: Bad indentation. Found 9 spaces, expected 12
W0311:326: Bad indentation. Found 9 spaces, expected 12
W0311:327: Bad indentation. Found 9 spaces, expected 12
W0311:328: Bad indentation. Found 9 spaces, expected 12
W0311:330: Bad indentation. Found 12 spaces, expected 16
W0311:331: Bad indentation. Found 12 spaces, expected 16
W0311:332: Bad indentation. Found 15 spaces, expected 20
W0311:334: Bad indentation. Found 15 spaces, expected 20
W0311:335: Bad indentation. Found 15 spaces, expected 20
W0311:336: Bad indentation. Found 18 spaces, expected 24
W0311:340: Bad indentation. Found 9 spaces, expected 12
W0311:341: Bad indentation. Found 12 spaces, expected 16
W0311:342: Bad indentation. Found 9 spaces, expected 12
W0311:343: Bad indentation. Found 12 spaces, expected 16
W0311:344: Bad indentation. Found 9 spaces, expected 12
W0311:345: Bad indentation. Found 12 spaces, expected 16
W0311:346: Bad indentation. Found 15 spaces, expected 20
W0311:347: Bad indentation. Found 12 spaces, expected 16
W0311:348: Bad indentation. Found 15 spaces, expected 20
W0311:351: Bad indentation. Found 12 spaces, expected 16
W0311:352: Bad indentation. Found 15 spaces, expected 20
W0311:354: Bad indentation. Found 18 spaces, expected 24
W0311:355: Bad indentation. Found 18 spaces, expected 24
W0311:356: Bad indentation. Found 18 spaces, expected 24
W0311:357: Bad indentation. Found 18 spaces, expected 24
W0311:358: Bad indentation. Found 21 spaces, expected 28
W0311:360: Bad indentation. Found 12 spaces, expected 16
W0311:362: Bad indentation. Found 12 spaces, expected 16
W0311:364: Bad indentation. Found 12 spaces, expected 16
W0311:365: Bad indentation. Found 15 spaces, expected 20
W0311:366: Bad indentation. Found 9 spaces, expected 12
W0311:367: Bad indentation. Found 12 spaces, expected 16
W0311:368: Bad indentation. Found 15 spaces, expected 20
W0311:371: Bad indentation. Found 6 spaces, expected 8
W0311:373: Bad indentation. Found 9 spaces, expected 12
W0311:374: Bad indentation. Found 12 spaces, expected 16
W0311:375: Bad indentation. Found 9 spaces, expected 12
W0311:376: Bad indentation. Found 6 spaces, expected 8
W0311:378: Bad indentation. Found 9 spaces, expected 12
W0311:379: Bad indentation. Found 12 spaces, expected 16
W0311:380: Bad indentation. Found 9 spaces, expected 12
W0311:381: Bad indentation. Found 6 spaces, expected 8
W0311:383: Bad indentation. Found 9 spaces, expected 12
W0311:384: Bad indentation. Found 12 spaces, expected 16
W0311:385: Bad indentation. Found 9 spaces, expected 12
W0311:386: Bad indentation. Found 3 spaces, expected 4
W0311:388: Bad indentation. Found 6 spaces, expected 8
W0311:389: Bad indentation. Found 9 spaces, expected 12
W0311:390: Bad indentation. Found 6 spaces, expected 8
W0311:394: Bad indentation. Found 3 spaces, expected 4
W0311:395: Bad indentation. Found 3 spaces, expected 4
W0311:396: Bad indentation. Found 7 spaces, expected 8
W0311:397: Bad indentation. Found 7 spaces, expected 8
W0311:398: Bad indentation. Found 7 spaces, expected 8
W0311:399: Bad indentation. Found 7 spaces, expected 8
W0311:401: Bad indentation. Found 7 spaces, expected 8
W0311:402: Bad indentation. Found 11 spaces, expected 12
W0311:403: Bad indentation. Found 11 spaces, expected 12
W0311:404: Bad indentation. Found 7 spaces, expected 8
W0311:405: Bad indentation. Found 11 spaces, expected 12
W0311:411: Bad indentation. Found 11 spaces, expected 12
W0311:413: Bad indentation. Found 11 spaces, expected 12
W0311:414: Bad indentation. Found 15 spaces, expected 16
W0311:415: Bad indentation. Found 15 spaces, expected 16
W0311:416: Bad indentation. Found 7 spaces, expected 8
W0311:418: Bad indentation. Found 11 spaces, expected 12
W0311:419: Bad indentation. Found 15 spaces, expected 16
W0311:420: Bad indentation. Found 15 spaces, expected 16
W0311:421: Bad indentation. Found 11 spaces, expected 12
W0311:422: Bad indentation. Found 11 spaces, expected 12
W0311:424: Bad indentation. Found 7 spaces, expected 8

************* Module leo.plugins.pie_menus
E1101:104:PieMenu.drawString: Instance of 'PieMenu' has no 'l4' member
E1101:104:PieMenu.drawString: Instance of 'PieMenu' has no 'l4' member
E0602:134:PieMenu.construct: Undefined variable 'l1'
E0602:138:PieMenu.construct: Undefined variable 'l1'
E0602:142:PieMenu.construct: Undefined variable 'l1'
E0602:147:PieMenu.construct: Undefined variable 'l1'
E0602:151:PieMenu.construct: Undefined variable 'l1'
E0602:166:PieMenu.construct: Undefined variable 'l1'
E0602:179:PieMenu.construct: Undefined variable 'l3'
E0602:185:PieMenu.construct: Undefined variable 'l3'
E0602:192:PieMenu.construct: Undefined variable 'l3'
E0602:200:PieMenu.construct: Undefined variable 'l2'
E0602:206:PieMenu.construct: Undefined variable 'l2'
E0602:212:PieMenu.construct: Undefined variable 'l2'
E0602:219:PieMenu.construct: Undefined variable 'l2'
E0602:225:PieMenu.construct: Undefined variable 'l2'
E0602:233:PieMenu.construct: Undefined variable 'l4'
E0602:239:PieMenu.construct: Undefined variable 'l4'
E0602:246:PieMenu.construct: Undefined variable 'l4'
E0602:254:PieMenu.construct: Undefined variable 'l5'
E0602:262:PieMenu.construct: Undefined variable 'l6'
E0602:270:PieMenu.construct: Undefined variable 'l7'
E0602:276:PieMenu.construct: Undefined variable 'l7'
E0602:282:PieMenu.construct: Undefined variable 'l7'
E1101:381:PieMenu.clean: Instance of 'PieMenu' has no 'l1' member
E1101:382:PieMenu.clean: Instance of 'PieMenu' has no 'l2' member
E1101:383:PieMenu.clean: Instance of 'PieMenu' has no 'l3' member
E1101:384:PieMenu.clean: Instance of 'PieMenu' has no 'l4' member
E1101:385:PieMenu.clean: Instance of 'PieMenu' has no 'l5' member
E1101:386:PieMenu.clean: Instance of 'PieMenu' has no 'l6' member
E1101:387:PieMenu.clean: Instance of 'PieMenu' has no 'l7' member
E1101:433:PieMenu.draw: Instance of 'PieMenu' has no 'l1' member
E1101:434:PieMenu.draw: Instance of 'PieMenu' has no 'l3' member
E1101:435:PieMenu.draw: Instance of 'PieMenu' has no 'l2' member
E1101:436:PieMenu.draw: Instance of 'PieMenu' has no 'l4' member
E1101:437:PieMenu.draw: Instance of 'PieMenu' has no 'l5' member
E1101:438:PieMenu.draw: Instance of 'PieMenu' has no 'l6' member
E1101:439:PieMenu.draw: Instance of 'PieMenu' has no 'l7' member
E1101:440:PieMenu.draw: Instance of 'PieMenu' has no 'l1' member
E1101:441:PieMenu.draw: Instance of 'PieMenu' has no 'l3' member
E1101:442:PieMenu.draw: Instance of 'PieMenu' has no 'l2' member
E1101:443:PieMenu.draw: Instance of 'PieMenu' has no 'l4' member
E1101:444:PieMenu.draw: Instance of 'PieMenu' has no 'l5' member
E1101:445:PieMenu.draw: Instance of 'PieMenu' has no 'l6' member
E1101:446:PieMenu.draw: Instance of 'PieMenu' has no 'l7' member

************* Module leo.plugins.read_only_nodes
E0611: 73: No name 'parse' in module 'urllib'
E0602:188:FTPurl.read: Undefined variable 'sys'
E0602:222:FTPurl.write: Undefined variable 'sys'
E0213:226:FTPurl.seek: Method should have "self" as first argument
E0602:227:FTPurl.seek: Undefined variable 'self'
E0211:229:FTPurl.flush: Method has no argument
E0602:243:FTPurl.dir: Undefined variable 'sys'
W0601:277:enable_body: Global variable 'insertOnTime' undefined at the module level
W0601:277:enable_body: Global variable 'insertOffTime' undefined at the module level
W0601:287:disable_body: Global variable 'insertOnTime' undefined at the module level
W0601:287:disable_body: Global variable 'insertOffTime' undefined at the module level

************* Module leo.plugins.rClick
W0511:611: TODO:
E1101:938:pluginController.getButtonHandlers: Instance of 'pluginController' has no 'button_handlers' member
E1101:1567:pluginController.findButtonCommandClass.doCommand: Instance of 'findButtonCommandClass' has no 'data' member
W0611:640: Unused import ImageTk
W0611:639: Unused import Image

************* Module leo.plugins.searchbar
W0107: 89:onPreCreate: Unnecessary pass statement
E1101:162:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'bg' member
E1101:168:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'labelText' member
E1101:170:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'command' member
E1101:225:SearchbarEntryWidget.detachWidget: Instance of 'SearchbarEntryWidget' has no 'leoIconBar' member
E1101:230:SearchbarEntryWidget.detachWidget: Instance of 'SearchbarEntryWidget' has no 'leoIconBar' member
E1101:252:SearchbarEntryWidget.onTextChanged: Instance of 'SearchbarEntryWidget' has no 'slave' member
E1101:261:SearchbarEntryWidget.onRightClick: Instance of 'SearchbarEntryWidget' has no 'entry_menu' member
E1101:267:SearchbarEntryWidget.onReturn: Instance of 'SearchbarEntryWidget' has no 'command' member
W0107:403:pluginController.toggleSearchbarCommandClass.doCommand: Unnecessary pass statement
W0611: 27: Unused import leoPlugins
W0611: 30: Unused import sys
W0611: 38: Unused import ImageTk
W0611: 37: Unused import Image
W0611: 29: Unused import re
W0611: 31: Unused import os

************* Module leo.plugins.searchbox
E1101:241:QuickFind.__init__: Class 'leoTkinterFrame' has no 'leoTkTextWidget' member
E1103:276:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'mark_set' member (but some types could not be inferred)
E1103:278:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'toGuiIndex' member (but some types could not be inferred)
E1103:279:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'mark_set' member (but some types could not be inferred)

************* Module leo.plugins.templates
W0601: 95:initImages: Global variable 'templatePI' undefined at the module level
W0601: 96:initImages: Global variable 'tempwizPI' undefined at the module level
E0602:205:getTemplateDialog: Undefined variable 'bs'
E0602:206:getTemplateDialog: Undefined variable 'hs'

************* Module leo.plugins.toolbar
W0511:725: FIXME:
W0511:805: TODO: not ready yet
E1103:463:ToolbarTkinterFrame.getIconButton: Instance of 'tkIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:463:ToolbarTkinterFrame.getIconButton: Instance of 'nullIconBarClass' has no 'getButton' member (but some types could not be inferred)
W0221:467:ToolbarTkinterFrame.addIconWidget: Arguments number differs from overridden method
W0221:475:ToolbarTkinterFrame.clearIconBar: Arguments number differs from overridden method
E1101:479:ToolbarTkinterFrame.clearIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
W0221:481:ToolbarTkinterFrame.createIconBar: Arguments number differs from overridden method
E1101:495:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1101:501:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1101:504:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
W0221:516:ToolbarTkinterFrame.hideIconBar: Arguments number differs from overridden method
E1101:520:ToolbarTkinterFrame.hideIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1103:538:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'tkIconBarClass' has no 'getWidgetFrame' member (but some
types could not be inferred)
E1103:538:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'nullIconBarClass' has no 'getWidgetFrame' member (but som
e types could not be inferred)
E1101:556:ToolbarTkinterFrame.getToolbarFrame: Instance of 'ToolbarTkinterFrame' has no 'toolBar' member
E1101:619:ToolbarIconWidgetFrame.detachWidget: Instance of 'ToolbarIconWidgetFrame' has no 'leoIconBar' member
E1101:624:ToolbarIconWidgetFrame.detachWidget: Instance of 'ToolbarIconWidgetFrame' has no 'leoIconBar' member
E1101:834:ToolbarIconButton.detachWidget: Instance of 'ToolbarIconButton' has no 'leoIconBar' member
E1101:839:ToolbarIconButton.detachWidget: Instance of 'ToolbarIconButton' has no 'leoIconBar' member
E1101:971:ToolbarIconButton.setCommand: Instance of 'ToolbarIconButton' has no 'config' member
E1101:1007:ToolbarScriptButton.__init__.<lambda>: Instance of 'ToolbarScriptButton' has no 'invoke' member
W0221:1229:ToolbarScriptingController.executeScriptFromButton: Arguments number differs from overridden method
W0221:1314:ToolbarScriptingController.createScriptButtonIconButton: Arguments number differs from overridden method
E1103:1336:ToolbarScriptingController.createScriptButtonIconButton: Instance of 'ToolbarScriptButton' has no 'configure'
 member (but some types could not be inferred)
W0221:1338:ToolbarScriptingController.addScriptButtonCommand: Arguments number differs from overridden method
W0221:1816:ToolbarTkIconBarClass.addWidget: Arguments number differs from overridden method
W0221:1992:ToolbarTkIconBarClass.pack: Arguments number differs from overridden method

************* Module leo.plugins.xcc_nodes
W0312:233: Found indentation with tabs instead of spaces
W0312:403: Found indentation with tabs instead of spaces
W0312:405: Found indentation with tabs instead of spaces
W0312:406: Found indentation with tabs instead of spaces
W0312:407: Found indentation with tabs instead of spaces
W0312:409: Found indentation with tabs instead of spaces
W0312:410: Found indentation with tabs instead of spaces
W0312:414: Found indentation with tabs instead of spaces
W0312:415: Found indentation with tabs instead of spaces
W0312:420: Found indentation with tabs instead of spaces
W0312:421: Found indentation with tabs instead of spaces
W0312:422: Found indentation with tabs instead of spaces
W0312:466: Found indentation with tabs instead of spaces
W0312:468: Found indentation with tabs instead of spaces
W0312:470: Found indentation with tabs instead of spaces
W0312:471: Found indentation with tabs instead of spaces
W0312:472: Found indentation with tabs instead of spaces
W0312:475: Found indentation with tabs instead of spaces
W0312:476: Found indentation with tabs instead of spaces
W0312:491: Found indentation with tabs instead of spaces
W0312:492: Found indentation with tabs instead of spaces
W0312:493: Found indentation with tabs instead of spaces
W0312:495: Found indentation with tabs instead of spaces
W0312:496: Found indentation with tabs instead of spaces
W0312:500: Found indentation with tabs instead of spaces
W0312:501: Found indentation with tabs instead of spaces
W0312:502: Found indentation with tabs instead of spaces
W0312:503: Found indentation with tabs instead of spaces
W0312:504: Found indentation with tabs instead of spaces
W0312:505: Found indentation with tabs instead of spaces
W0312:509: Found indentation with tabs instead of spaces
W0312:510: Found indentation with tabs instead of spaces
W0312:511: Found indentation with tabs instead of spaces
W0312:512: Found indentation with tabs instead of spaces
W0312:514: Found indentation with tabs instead of spaces
W0312:518: Found indentation with tabs instead of spaces
W0312:522: Found indentation with tabs instead of spaces
W0312:523: Found indentation with tabs instead of spaces
W0312:524: Found indentation with tabs instead of spaces
W0312:525: Found indentation with tabs instead of spaces
W0312:529: Found indentation with tabs instead of spaces
W0312:530: Found indentation with tabs instead of spaces
W0312:533: Found indentation with tabs instead of spaces
W0312:534: Found indentation with tabs instead of spaces
W0312:535: Found indentation with tabs instead of spaces
W0312:536: Found indentation with tabs instead of spaces
W0312:537: Found indentation with tabs instead of spaces
W0312:539: Found indentation with tabs instead of spaces
W0312:553: Found indentation with tabs instead of spaces
W0312:554: Found indentation with tabs instead of spaces
W0511:169: XXX to XxxClass.
W0511:518: TODO: ","Add import code in ImportFiles function!")
W0511:3339: TODO: Support precompiled header auto creation/inclusion."""
W0511:3660: TODO: send a WATCHTASK if breaked
E0602:336:OnStart2: Undefined variable 'XCC_INITED'
E0602:338:OnStart2: Undefined variable 'InitXcc'
E1101:415:linPause: Module 'os' has no 'kill' member
E0601:420:AddText: Using variable 'c' before assignment
E0602:421:AddText: Undefined variable 'LeoBody'
E0602:422:AddText: Undefined variable 'LeoBody'
E0602:471:DecompressIcon: Undefined variable 'Excetion'
E0602:472:DecompressIcon: Undefined variable 'Traceback'
E0602:533:ReplaceVars: Undefined variable 'NAME'
E0602:534:ReplaceVars: Undefined variable 'EXT'
E0602:535:ReplaceVars: Undefined variable 'ABS_PATH'
E0602:536:ReplaceVars: Undefined variable 'REL_PATH'
E0602:537:ReplaceVars: Undefined variable 'SRC_EXT'
E1121:674:controllerClass.onIdle: Too many positional arguments for function call
E1121:727:controllerClass.onQuit: Too many positional arguments for function call
E0211:813:controllerClass.UpdateProcess: Method has no argument
E0601:815:controllerClass.UpdateProcess: Using variable 'cc' before assignment
E0602:817:controllerClass.UpdateProcess: Undefined variable 'self'
E0211:992:controllerClass.sGetExecInfo: Method has no argument
E0602:994:controllerClass.sGetExecInfo: Undefined variable 'self'
E0602:1020:controllerClass.sGoToError: Undefined variable 'CPL'
E1101:1178:controllerClass.sSetText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1178:controllerClass.sSetText: Undefined variable 'SELECTED_NODE'
E1101:1184:controllerClass.sAddText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1184:controllerClass.sAddText: Undefined variable 'SELECTED_NODE'
E1120:1249:controllerClass.aStop: No value passed for parameter 'pid' in function call
E0602:1265:controllerClass.aStepIn: Undefined variable 'DBG'
E0602:1280:controllerClass.aStepOver: Undefined variable 'DBG'
E0602:1295:controllerClass.aStepOut: Undefined variable 'DBG'
E1120:1308:controllerClass.aPause: No value passed for parameter 'pid' in function call
E1101:1342:controllerClass.aSetText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1342:controllerClass.aSetText: Undefined variable 'ACTIVE_NODE'
E1101:1348:controllerClass.aAddText: Instance of 'controllerClass' has no 'ACTIVE_NOD' member
E1101:1349:controllerClass.aAddText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1352:controllerClass.aAddText: Undefined variable 'LeoBodyText'
E1101:1379:controllerClass.Compile: Instance of 'controllerClass' has no 'ProcessClass' member
E1101:1386:controllerClass.Compile: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1401:controllerClass.CplCmd: Instance of 'controllerClass' has no 'ReplaceVars' member
E0602:1440:controllerClass.CplCmd: Undefined variable 'CPL'
E1101:1457:controllerClass.Debug: Instance of 'controllerClass' has no 'GetDebugInfo' member
E1101:1466:controllerClass.Debug: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1473:controllerClass.DbgCmd: Instance of 'controllerClass' has no 'ReplaceVars' member
E1121:1483:controllerClass.Execute: Too many positional arguments for function call
E1101:1495:controllerClass.Execute: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1507:controllerClass.CplStart: Instance of 'controllerClass' has no 'VProcessList' member
E1101:1587:controllerClass.DbgStart: Instance of 'controllerClass' has no 'ProcessList' member
E0602:1607:controllerClass.DbgStart: Undefined variable 'DBG'
E0602:1614:controllerClass.DbgStart: Undefined variable 'DBG'
E0213:1616:controllerClass.DbgOut: Method should have "self" as first argument
E0602:1620:controllerClass.DbgOut: Undefined variable 'self'
E0602:1625:controllerClass.DbgOut: Undefined variable 'OutBuff'
E1101:1704:controllerClass.ProgStart: Instance of 'controllerClass' has no 'ProcessList' member
E0602:1719:controllerClass.ProgOut: Undefined variable 'ExtractLines'
E0602:1719:controllerClass.ProgOut: Undefined variable 'OutBuff'
E0602:1736:controllerClass.ProgErr: Undefined variable 'ExtractLines'
E0602:1736:controllerClass.ProgErr: Undefined variable 'ErrBuff'
E0602:1772:DBGTASK.__init__: Undefined variable 'DBG_SD'
E0602:1774:DBGTASK.__init__: Undefined variable 'DBG_SD'
E1101:1780:DBGTASK.Send: Instance of 'DBGTASK' has no 'Command' member
E1101:1781:DBGTASK.Send: Instance of 'DBGTASK' has no 'aWrite' member
E1101:1781:DBGTASK.Send: Instance of 'DBGTASK' has no 'Command' member
E1101:1782:DBGTASK.Send: Instance of 'DBGTASK' has no 'DBG_SD' member
E0602:1858:BREAKTASK.__init__: Undefined variable 'aGet'
E0602:1860:BREAKTASK.__init__: Undefined variable 'DBG'
E0602:1862:BREAKTASK.__init__: Undefined variable 'Waning'
E0602:1867:BREAKTASK.__init__: Undefined variable 'DBG'
E0602:1881:BREAKTASK.Send: Undefined variable 'NAME'
E0602:1882:BREAKTASK.Send: Undefined variable 'aWrite'
E0602:1884:BREAKTASK.Send: Undefined variable 'DBG_SD'
E0602:1885:BREAKTASK.Send: Undefined variable 'DBG_RD'
E0602:1897:BREAKTASK.Receive: Undefined variable 'aAddText'
E0602:1949:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1951:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1955:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1956:WATCHTASK.__init__: Undefined variable 'ccWatcher'
E0602:1959:WATCHTASK.__init__: Undefined variable 'DBG_SD'
W0601:1969:WATCHTASK.Cancel: Global variable 'WATCH_TASK' undefined at the module level
E0602:1970:WATCHTASK.Cancel: Undefined variable 'DBG_SD'
E0602:1971:WATCHTASK.Cancel: Undefined variable 'DBG_SD'
E0602:1972:WATCHTASK.Cancel: Undefined variable 'DBG_RD'
E0602:1973:WATCHTASK.Cancel: Undefined variable 'DBG_RD'
E0602:1974:WATCHTASK.Cancel: Undefined variable 'PROMPT_RD'
E0602:1975:WATCHTASK.Cancel: Undefined variable 'PROMPT_RD'
E0602:1977:WATCHTASK.Cancel: Undefined variable 'Watcher'
E0602:1983:WATCHTASK.Send: Undefined variable 'Watcher'
E0602:1985:WATCHTASK.Send: Undefined variable 'aWrite'
E0602:1985:WATCHTASK.Send: Undefined variable 'DBG'
E0602:1986:WATCHTASK.Send: Undefined variable 'DBG_SD'
E0602:1987:WATCHTASK.Send: Undefined variable 'DBG_RD'
E0602:1988:WATCHTASK.Send: Undefined variable 'PROMPT_RD'
E0602:1993:WATCHTASK.Receive: Undefined variable 'DBG_PROMPT'
W0601:1997:WATCHTASK.OnPrompt: Global variable 'WATCH_TASK' undefined at the module level
E0602:1999:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2005:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2010:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2011:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2014:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2015:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2017:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2020:WATCHTASK.OnPrompt: Undefined variable 'DBG_SD'
E0602:2022:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2025:WATCHTASK.OnPrompt: Undefined variable 'PROMPT_RD'
E0602:2026:WATCHTASK.OnPrompt: Undefined variable 'DBG_RD'
E0602:2101:BREAKIDTASK.Send: Undefined variable 'aWrite'
E0602:2102:BREAKIDTASK.Send: Undefined variable 'DBG_SD'
E0602:2103:BREAKIDTASK.Send: Undefined variable 'DBG_RD'
E0602:2554:ConfigClass.CplPageClass.Browse: Undefined variable 'e'
E0602:2694:ConfigClass.DbgPageClass.Browse: Undefined variable 'e'
E0602:3535:ToolbarClass.SyncDisplayToError: Undefined variable 'BreakBar'
E0602:3536:ToolbarClass.SyncDisplayToError: Undefined variable 'BreakBar'
E0602:3541:ToolbarClass.SyncDisplayToError: Undefined variable 'INSERT'
E0602:3554:ToolbarClass.SyncDisplayToError: Undefined variable 'c'
W0601:3558:ToolbarClass.SetError: Global variable 'PARSE_ERROR' undefined at the module level
W0601:3558:ToolbarClass.SetError: Global variable 'PARSE_ERROR_NODE' undefined at the module level
E0602:3590:ToolbarClass.Refresh: Undefined variable 'ACTIVE_NODE'
E0602:3610:WatcherClass.__init__: Undefined variable 'c'
E0602:3631:WatcherClass.__init__: Undefined variable 'c'
E0602:3632:WatcherClass.__init__: Undefined variable 'c'
E0602:3633:WatcherClass.__init__: Undefined variable 'c'
E0602:3634:WatcherClass.__init__: Undefined variable 'c'
E0602:3684:WatcherClass.OnDelete: Undefined variable 'sGet'
W0221:3796:BreakbarClass.yview: Arguments number differs from overridden method
E0602:3846:BreakbarClass.OnCut: Undefined variable 'LeoFrame'
E0602:3850:BreakbarClass.OnPaste: Undefined variable 'LeoFrame'
E1101:3855:BreakbarClass.OnRightClick: Instance of 'BreakbarClass' has no 'c' member
E0602:3856:BreakbarClass.OnRightClick: Undefined variable 'Menu'
E0602:3873:BreakbarClass.OnLeftClick: Undefined variable 'cGet'
E0602:3875:BreakbarClass.OnLeftClick: Undefined variable 'CHILD_NODE'
E0602:3888:BreakbarClass.OnLeftClick: Undefined variable 'SEL'
E0602:3892:BreakbarClass.AddNodeBreak: Undefined variable 'cGet'
E0602:3895:BreakbarClass.DeleteNodeBreak: Undefined variable 'cGet'
E0602:3900:BreakbarClass.ClearNodeBreaks: Undefined variable 'cSet'
E0602:4010:BreakbarClass.BreaksFromTags: Undefined variable 'CHILD_EXT'
E0602:4010:BreakbarClass.BreaksFromTags: Undefined variable 'CHILD_LINE'
E0602:4016:BreakbarClass.AddBreak: Undefined variable 'sGet'
E0602:4057:BreakbarClass.DeleteNodeBreaks: Undefined variable 'cGet'
E0602:4061:BreakbarClass.DeleteNodeBreaks: Undefined variable 'CHILD_EXT'
E0602:4061:BreakbarClass.DeleteNodeBreaks: Undefined variable 'CHILD_LINE'
E1101:4063:BreakbarClass.DeleteNodeBreaks: Instance of 'BreakbarClass' has no 'DeleteDbgBreaks' member
E0602:4065:BreakbarClass.DeleteNodeBreaks: Undefined variable 'cSelect'
E0602:4357:CppParserClass.FUNCRULE.DeclareFunc: Undefined variable 'ToolBar'
E0602:4375:CppParserClass.FUNCRULE.DefineFunc: Undefined variable 'ToolBar'
E0602:4513:CppParserClass.CLASSRULE.OnMatch: Undefined variable 'ToolBar'
E1101:4703:CppParserClass.Docum: Instance of 'CppParserClass' has no 'CURRENT_DOC_LINE' member
E0602:4727:CppParserClass.SetRealBodyDestination: Undefined variable 'EXT'
E1101:4796:CppParserClass.CppParse: Instance of 'CppParserClass' has no 'cc' member
E1102:4823:CppParserClass.CppParse: self.OnStart is not callable
E0602:4830:CppParserClass.CppParse: Undefined variable 'NAME'
E1102:4836:CppParserClass.CppParse: self.OnEnd is not callable
E1101:4849:CppParserClass.ParseNode: Instance of 'CppParserClass' has no 'cc' member
E0602:4939:WriterClass.OnWriteStart: Undefined variable 'REL_PATH'
E0602:4940:WriterClass.OnWriteStart: Undefined variable 'REL_PATH'
E0602:4940:WriterClass.OnWriteStart: Undefined variable 'NAME'
E0602:4942:WriterClass.OnWriteStart: Undefined variable 'NAME'
E0602:4945:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4946:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4950:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4951:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4956:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4956:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4957:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4957:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4958:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4961:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4962:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:5008:BreakFinderClass.__init__: Undefined variable 'controllerSELECTED_NODE'
E0602:5008:BreakFinderClass.__init__: Undefined variable 'controllerEXT'
E0602:5024:BreakFinderClass.OnFindStart: Undefined variable 'sSet'
E0602:5025:BreakFinderClass.OnFindStart: Undefined variable 'sGet'
E0602:5031:BreakFinderClass.OnFindEnd: Undefined variable 'sSet'
E0602:5050:BreakFinderClass.BreakDef: Undefined variable 'SRC_EXT'
W0611:206: Unused import tkSimpleDialog
W0611:207: Unused import base64
W0611:203: Unused import beep

************* Module leo.plugins.active_path
W0108:124:attachToCommander.<lambda>: Lambda may not be necessary
E1101:399:openDir: Generator 'walk' has no 'next' member

************* Module leo.plugins.attrib_edit
W0311:816: Bad indentation. Found 3 spaces, expected 4
W0311:819: Bad indentation. Found 3 spaces, expected 4
W0311:822: Bad indentation. Found 3 spaces, expected 4
W0311:825: Bad indentation. Found 3 spaces, expected 4
W0311:828: Bad indentation. Found 3 spaces, expected 4
W0511:289: FIXME type_ = {True: '_view', False: '_edit'}[readonly]
W0511:304: FIXME self.attrPaths.add(tuple(ns))
E1101:665:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'recSearch' member
E1101:669:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'typeMap' member
E1101:671:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'typeMap' member
W0611:118: Unused import os
W0611:114: Unused import re

************* Module leo.plugins.backlink
W0511: 23: TODO
E1101:145:backlinkTkUI.updateTkTab: Instance of 'backlinkTkUI' has no 'c' member
E1101:150:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'c' member
E1123:161:backlinkTkUI.updateTkTabInt: Passing unexpected keyword argument 'optional' in function call
E1101:169:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'vnode' member
E1101:170:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'vnodePosition' member
E1101:171:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'c' member
E1123:179:backlinkTkUI.updateTkTabInt: Passing unexpected keyword argument 'optional' in function call
E1101:186:backlinkTkUI.updateTkTabInt.delLink: Instance of 'backlinkTkUI' has no 'deleteLink' member
W0101:787:backlinkController.vnodePosition: Unreachable code
E1101:790:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member
E1101:791:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member
E1101:805:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member

************* Module leo.plugins.codewisecompleter
E1111:244:codewise_lookup: Assigning to function call which doesn't return
E0602:283:codewise_suggest: Undefined variable 'txt'
W0611: 34: Unused import os

************* Module leo.plugins.cursesGui
W0311: 84: Bad indentation. Found 2 spaces, expected 4
W0311: 85: Bad indentation. Found 4 spaces, expected 8
W0311: 87: Bad indentation. Found 2 spaces, expected 4
W0311: 92: Bad indentation. Found 2 spaces, expected 4
W0311: 93: Bad indentation. Found 4 spaces, expected 8
W0311: 95: Bad indentation. Found 4 spaces, expected 8
W0311: 96: Bad indentation. Found 4 spaces, expected 8
W0311: 99: Bad indentation. Found 2 spaces, expected 4
W0311:103: Bad indentation. Found 6 spaces, expected 8
W0311:105: Bad indentation. Found 2 spaces, expected 4
W0311:106: Bad indentation. Found 4 spaces, expected 8
W0311:107: Bad indentation. Found 4 spaces, expected 8
W0311:108: Bad indentation. Found 4 spaces, expected 8
W0311:110: Bad indentation. Found 2 spaces, expected 4
W0311:111: Bad indentation. Found 4 spaces, expected 8
W0311:114: Bad indentation. Found 2 spaces, expected 4
W0311:115: Bad indentation. Found 4 spaces, expected 8
W0311:117: Bad indentation. Found 2 spaces, expected 4
W0311:118: Bad indentation. Found 4 spaces, expected 8
W0311:120: Bad indentation. Found 2 spaces, expected 4
W0311:122: Bad indentation. Found 6 spaces, expected 8
W0311:124: Bad indentation. Found 6 spaces, expected 8
W0311:126: Bad indentation. Found 2 spaces, expected 4
W0311:127: Bad indentation. Found 4 spaces, expected 8
W0311:129: Bad indentation. Found 2 spaces, expected 4
W0311:130: Bad indentation. Found 4 spaces, expected 8
W0311:132: Bad indentation. Found 2 spaces, expected 4
W0311:133: Bad indentation. Found 4 spaces, expected 8
W0311:135: Bad indentation. Found 4 spaces, expected 8
W0311:137: Bad indentation. Found 4 spaces, expected 8
W0311:138: Bad indentation. Found 4 spaces, expected 8
W0311:140: Bad indentation. Found 4 spaces, expected 8
W0311:142: Bad indentation. Found 4 spaces, expected 8
W0311:143: Bad indentation. Found 6 spaces, expected 12
W0311:144: Bad indentation. Found 4 spaces, expected 8
W0311:146: Bad indentation. Found 2 spaces, expected 4
W0311:147: Bad indentation. Found 4 spaces, expected 8
W0311:149: Bad indentation. Found 2 spaces, expected 4
W0311:150: Bad indentation. Found 4 spaces, expected 8
W0311:152: Bad indentation. Found 2 spaces, expected 4
W0311:153: Bad indentation. Found 4 spaces, expected 8
W0311:155: Bad indentation. Found 4 spaces, expected 8
W0311:156: Bad indentation. Found 4 spaces, expected 8
W0311:158: Bad indentation. Found 4 spaces, expected 8
W0311:161: Bad indentation. Found 6 spaces, expected 12
W0311:162: Bad indentation. Found 8 spaces, expected 16
W0311:163: Bad indentation. Found 6 spaces, expected 12
W0311:164: Bad indentation. Found 6 spaces, expected 12
W0311:167: Bad indentation. Found 6 spaces, expected 12
W0311:169: Bad indentation. Found 6 spaces, expected 12
W0311:170: Bad indentation. Found 8 spaces, expected 16
W0311:171: Bad indentation. Found 6 spaces, expected 12
W0311:172: Bad indentation. Found 10 spaces, expected 16
W0311:174: Bad indentation. Found 2 spaces, expected 4
W0311:176: Bad indentation. Found 4 spaces, expected 8
W0311:177: Bad indentation. Found 6 spaces, expected 12
W0311:178: Bad indentation. Found 4 spaces, expected 8
W0311:179: Bad indentation. Found 6 spaces, expected 12
W0311:180: Bad indentation. Found 4 spaces, expected 8
W0311:181: Bad indentation. Found 6 spaces, expected 12
W0311:182: Bad indentation. Found 4 spaces, expected 8
W0311:183: Bad indentation. Found 6 spaces, expected 12
W0311:184: Bad indentation. Found 8 spaces, expected 16
W0311:185: Bad indentation. Found 6 spaces, expected 12
W0311:186: Bad indentation. Found 6 spaces, expected 12
W0311:187: Bad indentation. Found 8 spaces, expected 16
W0311:188: Bad indentation. Found 6 spaces, expected 12
W0311:189: Bad indentation. Found 8 spaces, expected 16
W0311:190: Bad indentation. Found 6 spaces, expected 12
W0311:191: Bad indentation. Found 8 spaces, expected 16
W0311:192: Bad indentation. Found 4 spaces, expected 8
W0311:193: Bad indentation. Found 6 spaces, expected 12
W0311:194: Bad indentation. Found 4 spaces, expected 8
W0311:195: Bad indentation. Found 6 spaces, expected 12
W0311:197: Bad indentation. Found 2 spaces, expected 4
W0311:198: Bad indentation. Found 4 spaces, expected 8
W0311:199: Bad indentation. Found 6 spaces, expected 12
W0311:200: Bad indentation. Found 4 spaces, expected 8
W0311:206: Bad indentation. Found 2 spaces, expected 4
W0311:208: Bad indentation. Found 4 spaces, expected 8
W0311:210: Bad indentation. Found 4 spaces, expected 8
W0311:213: Bad indentation. Found 2 spaces, expected 4
W0311:215: Bad indentation. Found 4 spaces, expected 8
W0311:217: Bad indentation. Found 4 spaces, expected 8
W0311:218: Bad indentation. Found 4 spaces, expected 8
W0311:219: Bad indentation. Found 4 spaces, expected 8
W0311:221: Bad indentation. Found 4 spaces, expected 8
W0311:222: Bad indentation. Found 4 spaces, expected 8
W0311:223: Bad indentation. Found 4 spaces, expected 8
W0311:236: Bad indentation. Found 2 spaces, expected 4
W0311:237: Bad indentation. Found 2 spaces, expected 4
W0311:239: Bad indentation. Found 2 spaces, expected 4
W0311:240: Bad indentation. Found 6 spaces, expected 8
W0311:242: Bad indentation. Found 2 spaces, expected 4
W0311:243: Bad indentation. Found 4 spaces, expected 8
W0311:245: Bad indentation. Found 4 spaces, expected 8
W0311:246: Bad indentation. Found 4 spaces, expected 8
W0311:247: Bad indentation. Found 4 spaces, expected 8
W0311:248: Bad indentation. Found 4 spaces, expected 8
W0311:250: Bad indentation. Found 4 spaces, expected 8
W0311:251: Bad indentation. Found 6 spaces, expected 12
W0311:253: Bad indentation. Found 4 spaces, expected 8
W0311:254: Bad indentation. Found 4 spaces, expected 8
W0311:257: Bad indentation. Found 4 spaces, expected 8
W0311:260: Bad indentation. Found 4 spaces, expected 8
W0311:262: Bad indentation. Found 2 spaces, expected 4
W0311:264: Bad indentation. Found 2 spaces, expected 4
W0311:265: Bad indentation. Found 4 spaces, expected 8
W0311:267: Bad indentation. Found 2 spaces, expected 4
W0311:268: Bad indentation. Found 4 spaces, expected 8
W0311:270: Bad indentation. Found 2 spaces, expected 4
W0311:271: Bad indentation. Found 4 spaces, expected 8
W0311:273: Bad indentation. Found 4 spaces, expected 8
W0311:274: Bad indentation. Found 4 spaces, expected 8
W0311:276: Bad indentation. Found 4 spaces, expected 8
W0311:277: Bad indentation. Found 4 spaces, expected 8
W0311:279: Bad indentation. Found 4 spaces, expected 8
W0311:280: Bad indentation. Found 8 spaces, expected 12
W0311:281: Bad indentation. Found 12 spaces, expected 16
W0311:282: Bad indentation. Found 12 spaces, expected 16
W0311:283: Bad indentation. Found 12 spaces, expected 16
W0311:284: Bad indentation. Found 12 spaces, expected 16
W0311:285: Bad indentation. Found 12 spaces, expected 16
W0311:291: Bad indentation. Found 4 spaces, expected 8
W0311:292: Bad indentation. Found 4 spaces, expected 8
W0311:293: Bad indentation. Found 4 spaces, expected 8
W0311:295: Bad indentation. Found 4 spaces, expected 8
W0311:296: Bad indentation. Found 4 spaces, expected 8
W0311:298: Bad indentation. Found 2 spaces, expected 4
W0311:299: Bad indentation. Found 2 spaces, expected 4
W0311:305: Bad indentation. Found 2 spaces, expected 4
W0311:306: Bad indentation. Found 4 spaces, expected 8
W0311:308: Bad indentation. Found 4 spaces, expected 8
W0311:310: Bad indentation. Found 4 spaces, expected 8
W0311:311: Bad indentation. Found 4 spaces, expected 8
W0311:314: Bad indentation. Found 2 spaces, expected 4
W0311:317: Bad indentation. Found 4 spaces, expected 8
W0311:321: Bad indentation. Found 2 spaces, expected 4
W0311:322: Bad indentation. Found 2 spaces, expected 4
W0311:324: Bad indentation. Found 2 spaces, expected 4
W0311:326: Bad indentation. Found 4 spaces, expected 8
W0311:327: Bad indentation. Found 4 spaces, expected 8
W0311:328: Bad indentation. Found 4 spaces, expected 8
W0311:329: Bad indentation. Found 4 spaces, expected 8
W0311:333: Bad indentation. Found 2 spaces, expected 4
W0311:338: Bad indentation. Found 2 spaces, expected 4
W0311:339: Bad indentation. Found 4 spaces, expected 8
W0311:340: Bad indentation. Found 4 spaces, expected 8
W0311:341: Bad indentation. Found 4 spaces, expected 8
W0311:343: Bad indentation. Found 2 spaces, expected 4
W0311:344: Bad indentation. Found 4 spaces, expected 8
W0311:345: Bad indentation. Found 4 spaces, expected 8
W0311:346: Bad indentation. Found 6 spaces, expected 12
W0311:347: Bad indentation. Found 4 spaces, expected 8
W0311:353: Bad indentation. Found 2 spaces, expected 4
W0311:354: Bad indentation. Found 4 spaces, expected 8
W0311:355: Bad indentation. Found 4 spaces, expected 8
W0311:356: Bad indentation. Found 4 spaces, expected 8
W0311:357: Bad indentation. Found 4 spaces, expected 8
W0311:359: Bad indentation. Found 2 spaces, expected 4
W0311:360: Bad indentation. Found 4 spaces, expected 8
W0311:366: Bad indentation. Found 2 spaces, expected 4
W0311:367: Bad indentation. Found 4 spaces, expected 8
W0311:374: Bad indentation. Found 2 spaces, expected 4
W0311:377: Bad indentation. Found 6 spaces, expected 8
W0311:378: Bad indentation. Found 6 spaces, expected 8
W0311:381: Bad indentation. Found 6 spaces, expected 8
W0311:383: Bad indentation. Found 2 spaces, expected 4
W0311:385: Bad indentation. Found 4 spaces, expected 8
W0311:387: Bad indentation. Found 4 spaces, expected 8
W0311:389: Bad indentation. Found 4 spaces, expected 8
W0311:391: Bad indentation. Found 2 spaces, expected 4
W0311:393: Bad indentation. Found 4 spaces, expected 8
W0311:398: Bad indentation. Found 4 spaces, expected 8
W0311:399: Bad indentation. Found 4 spaces, expected 8
W0311:400: Bad indentation. Found 4 spaces, expected 8
W0311:402: Bad indentation. Found 2 spaces, expected 4
W0311:406: Bad indentation. Found 4 spaces, expected 8
W0311:407: Bad indentation. Found 8 spaces, expected 12
W0311:408: Bad indentation. Found 4 spaces, expected 8
W0311:412: Bad indentation. Found 2 spaces, expected 4
W0311:417: Bad indentation. Found 4 spaces, expected 8
W0311:421: Bad indentation. Found 4 spaces, expected 8
W0311:422: Bad indentation. Found 6 spaces, expected 12
W0311:424: Bad indentation. Found 4 spaces, expected 8
W0311:425: Bad indentation. Found 4 spaces, expected 8
W0311:426: Bad indentation. Found 4 spaces, expected 8
W0311:427: Bad indentation. Found 4 spaces, expected 8
W0311:430: Bad indentation. Found 4 spaces, expected 8
W0311:431: Bad indentation. Found 4 spaces, expected 8
W0311:433: Bad indentation. Found 2 spaces, expected 4
W0311:434: Bad indentation. Found 4 spaces, expected 8
W0311:436: Bad indentation. Found 2 spaces, expected 4
W0311:438: Bad indentation. Found 4 spaces, expected 8
W0311:440: Bad indentation. Found 2 spaces, expected 4
W0311:441: Bad indentation. Found 4 spaces, expected 8
W0311:443: Bad indentation. Found 4 spaces, expected 8
W0311:444: Bad indentation. Found 6 spaces, expected 12
W0311:446: Bad indentation. Found 6 spaces, expected 12
W0311:447: Bad indentation. Found 8 spaces, expected 16
W0311:448: Bad indentation. Found 6 spaces, expected 12
W0311:450: Bad indentation. Found 6 spaces, expected 12
W0311:451: Bad indentation. Found 6 spaces, expected 12
W0311:452: Bad indentation. Found 6 spaces, expected 12
W0311:454: Bad indentation. Found 6 spaces, expected 12
W0311:455: Bad indentation. Found 8 spaces, expected 16
W0311:456: Bad indentation. Found 6 spaces, expected 12
W0311:458: Bad indentation. Found 8 spaces, expected 16
W0311:459: Bad indentation. Found 8 spaces, expected 16
W0311:460: Bad indentation. Found 10 spaces, expected 20
W0311:461: Bad indentation. Found 14 spaces, expected 24
W0311:462: Bad indentation. Found 8 spaces, expected 16
W0311:464: Bad indentation. Found 6 spaces, expected 12
W0311:465: Bad indentation. Found 8 spaces, expected 16
W0311:466: Bad indentation. Found 6 spaces, expected 12
W0311:467: Bad indentation. Found 8 spaces, expected 16
W0311:469: Bad indentation. Found 6 spaces, expected 12
W0311:470: Bad indentation. Found 6 spaces, expected 12
W0311:471: Bad indentation. Found 8 spaces, expected 16
W0311:472: Bad indentation. Found 8 spaces, expected 16
W0311:473: Bad indentation. Found 6 spaces, expected 12
W0311:474: Bad indentation. Found 8 spaces, expected 16
W0311:475: Bad indentation. Found 6 spaces, expected 12
W0311:476: Bad indentation. Found 8 spaces, expected 16
W0311:483: Bad indentation. Found 2 spaces, expected 4
W0311:484: Bad indentation. Found 4 spaces, expected 8
W0311:486: Bad indentation. Found 2 spaces, expected 4
W0311:487: Bad indentation. Found 4 spaces, expected 8
W0311:489: Bad indentation. Found 2 spaces, expected 4
W0311:490: Bad indentation. Found 4 spaces, expected 8
W0311:493: Bad indentation. Found 2 spaces, expected 4
W0311:494: Bad indentation. Found 2 spaces, expected 4
W0311:496: Bad indentation. Found 2 spaces, expected 4
W0311:504: Bad indentation. Found 2 spaces, expected 4
W0311:505: Bad indentation. Found 4 spaces, expected 8
W0311:507: Bad indentation. Found 2 spaces, expected 4
W0311:508: Bad indentation. Found 4 spaces, expected 8
W0311:510: Bad indentation. Found 2 spaces, expected 4
W0311:511: Bad indentation. Found 4 spaces, expected 8
W0311:512: Bad indentation. Found 6 spaces, expected 12
W0311:514: Bad indentation. Found 2 spaces, expected 4
W0311:515: Bad indentation. Found 4 spaces, expected 8
W0311:517: Bad indentation. Found 2 spaces, expected 4
W0311:518: Bad indentation. Found 4 spaces, expected 8
W0311:519: Bad indentation. Found 6 spaces, expected 12
W0311:522: Bad indentation. Found 2 spaces, expected 4
W0311:524: Bad indentation. Found 4 spaces, expected 8
W0311:526: Bad indentation. Found 4 spaces, expected 8
W0311:528: Bad indentation. Found 2 spaces, expected 4
W0311:531: Bad indentation. Found 4 spaces, expected 8
W0311:532: Bad indentation. Found 4 spaces, expected 8
W0311:534: Bad indentation. Found 4 spaces, expected 8
W0311:538: Bad indentation. Found 4 spaces, expected 8
W0311:541: Bad indentation. Found 2 spaces, expected 4
W0311:542: Bad indentation. Found 4 spaces, expected 8
W0311:544: Bad indentation. Found 2 spaces, expected 4
W0311:545: Bad indentation. Found 4 spaces, expected 8
W0311:547: Bad indentation. Found 2 spaces, expected 4
W0311:550: Bad indentation. Found 4 spaces, expected 8
W0311:551: Bad indentation. Found 4 spaces, expected 8
W0311:553: Bad indentation. Found 2 spaces, expected 4
W0311:555: Bad indentation. Found 4 spaces, expected 8
W0311:557: Bad indentation. Found 6 spaces, expected 12
W0311:558: Bad indentation. Found 8 spaces, expected 16
W0311:559: Bad indentation. Found 6 spaces, expected 12
W0311:560: Bad indentation. Found 8 spaces, expected 16
W0311:562: Bad indentation. Found 6 spaces, expected 12
W0311:568: Bad indentation. Found 6 spaces, expected 12
W0311:570: Bad indentation. Found 6 spaces, expected 12
W0311:571: Bad indentation. Found 8 spaces, expected 16
W0511: 21: TODO >>
W0511: 22: TODO >>
W0511: 43: TODO >>
W0511: 97: TODO leoTkinterFrame finishCreate g.app.windowList.append(f) - use that?
W0511:319: TODO Tkinter onBodyChanged undo call and many others. =(
W0511:529: TODO Much more here: there's four hooks and all sorts of other things called in the TK version.
W0221:267:textFrame.setTopGeometry: Arguments number differs from overridden method
W0221:391:textLeoMenu.new_menu: Arguments number differs from overridden method
W0221:412:textLeoMenu.add_command: Arguments number differs from overridden method
W0221:436:textLeoMenu.delete_range: Arguments number differs from overridden method
W0221:514:textTree.redraw: Arguments number differs from overridden method
W0221:517:textTree.redraw_now: Arguments number differs from overridden method
W0221:541:textTree.editLabel: Arguments number differs from overridden method

************* Module leo.plugins.dtest
W0611: 32: Unused import leoPlugins

************* Module leo.plugins.leo_interface
W0311: 42: Bad indentation. Found 3 spaces, expected 4
W0311: 43: Bad indentation. Found 6 spaces, expected 8
W0311: 45: Bad indentation. Found 3 spaces, expected 4
W0311: 46: Bad indentation. Found 6 spaces, expected 8
W0311: 52: Bad indentation. Found 3 spaces, expected 4
W0311: 59: Bad indentation. Found 3 spaces, expected 4
W0311: 60: Bad indentation. Found 7 spaces, expected 8
W0311: 62: Bad indentation. Found 3 spaces, expected 4
W0311: 63: Bad indentation. Found 7 spaces, expected 8
W0311: 64: Bad indentation. Found 7 spaces, expected 8
W0311: 66: Bad indentation. Found 3 spaces, expected 4
W0311: 67: Bad indentation. Found 7 spaces, expected 8
W0311: 69: Bad indentation. Found 3 spaces, expected 4
W0311: 70: Bad indentation. Found 7 spaces, expected 8
W0311: 71: Bad indentation. Found 11 spaces, expected 12
W0311: 73: Bad indentation. Found 3 spaces, expected 4
W0311: 74: Bad indentation. Found 7 spaces, expected 8
W0311: 75: Bad indentation. Found 7 spaces, expected 8
W0311: 76: Bad indentation. Found 11 spaces, expected 12
W0311: 77: Bad indentation. Found 7 spaces, expected 8
W0311: 78: Bad indentation. Found 7 spaces, expected 8
W0311: 80: Bad indentation. Found 3 spaces, expected 4
W0311: 81: Bad indentation. Found 7 spaces, expected 8
W0311: 82: Bad indentation. Found 7 spaces, expected 8
W0311: 83: Bad indentation. Found 7 spaces, expected 8
W0311: 84: Bad indentation. Found 7 spaces, expected 8
W0311: 85: Bad indentation. Found 7 spaces, expected 8
W0311: 86: Bad indentation. Found 11 spaces, expected 12
W0311: 87: Bad indentation. Found 7 spaces, expected 8
W0311: 88: Bad indentation. Found 7 spaces, expected 8
W0311: 89: Bad indentation. Found 11 spaces, expected 12
W0311: 90: Bad indentation. Found 7 spaces, expected 8
W0311: 91: Bad indentation. Found 7 spaces, expected 8
W0311: 92: Bad indentation. Found 7 spaces, expected 8
W0311: 93: Bad indentation. Found 11 spaces, expected 12
W0311: 95: Bad indentation. Found 3 spaces, expected 4
W0311: 96: Bad indentation. Found 7 spaces, expected 8
W0311: 97: Bad indentation. Found 7 spaces, expected 8
W0311: 98: Bad indentation. Found 7 spaces, expected 8
W0311: 99: Bad indentation. Found 7 spaces, expected 8
W0311:100: Bad indentation. Found 7 spaces, expected 8
W0311:101: Bad indentation. Found 11 spaces, expected 12
W0311:102: Bad indentation. Found 7 spaces, expected 8
W0311:104: Bad indentation. Found 3 spaces, expected 4
W0311:105: Bad indentation. Found 5 spaces, expected 8
W0311:109: Bad indentation. Found 3 spaces, expected 4
W0311:115: Bad indentation. Found 3 spaces, expected 4
W0311:116: Bad indentation. Found 6 spaces, expected 8
W0311:118: Bad indentation. Found 3 spaces, expected 4
W0311:119: Bad indentation. Found 6 spaces, expected 8
W0311:121: Bad indentation. Found 3 spaces, expected 4
W0311:122: Bad indentation. Found 7 spaces, expected 8
W0311:124: Bad indentation. Found 3 spaces, expected 4
W0311:125: Bad indentation. Found 7 spaces, expected 8
W0311:126: Bad indentation. Found 7 spaces, expected 8
W0311:128: Bad indentation. Found 3 spaces, expected 4
W0311:129: Bad indentation. Found 7 spaces, expected 8
W0311:130: Bad indentation. Found 7 spaces, expected 8
W0311:131: Bad indentation. Found 7 spaces, expected 8
W0311:132: Bad indentation. Found 7 spaces, expected 8
W0311:134: Bad indentation. Found 3 spaces, expected 4
W0311:135: Bad indentation. Found 7 spaces, expected 8
W0311:138: Bad indentation. Found 7 spaces, expected 8
W0311:143: Bad indentation. Found 7 spaces, expected 8
W0311:144: Bad indentation. Found 7 spaces, expected 8
W0311:145: Bad indentation. Found 7 spaces, expected 8
W0311:146: Bad indentation. Found 10 spaces, expected 12
W0311:147: Bad indentation. Found 10 spaces, expected 12
W0311:148: Bad indentation. Found 7 spaces, expected 8
W0311:149: Bad indentation. Found 7 spaces, expected 8
W0311:151: Bad indentation. Found 3 spaces, expected 4
W0311:152: Bad indentation. Found 7 spaces, expected 8
W0311:153: Bad indentation. Found 11 spaces, expected 12
W0311:155: Bad indentation. Found 3 spaces, expected 4
W0311:156: Bad indentation. Found 6 spaces, expected 8
W0311:157: Bad indentation. Found 9 spaces, expected 12
W0311:158: Bad indentation. Found 9 spaces, expected 12
W0311:159: Bad indentation. Found 9 spaces, expected 12
W0311:160: Bad indentation. Found 6 spaces, expected 8
W0311:161: Bad indentation. Found 9 spaces, expected 12
W0311:163: Bad indentation. Found 3 spaces, expected 4
W0311:164: Bad indentation. Found 7 spaces, expected 8
W0311:170: Bad indentation. Found 3 spaces, expected 4
W0311:171: Bad indentation. Found 7 spaces, expected 8
W0311:173: Bad indentation. Found 3 spaces, expected 4
W0311:174: Bad indentation. Found 7 spaces, expected 8
W0311:176: Bad indentation. Found 3 spaces, expected 4
W0311:177: Bad indentation. Found 7 spaces, expected 8
W0311:179: Bad indentation. Found 3 spaces, expected 4
W0311:180: Bad indentation. Found 7 spaces, expected 8
W0311:184: Bad indentation. Found 3 spaces, expected 4
W0311:194: Bad indentation. Found 3 spaces, expected 4
W0311:195: Bad indentation. Found 3 spaces, expected 4
W0311:199: Bad indentation. Found 3 spaces, expected 4
W0311:200: Bad indentation. Found 7 spaces, expected 8
W0311:201: Bad indentation. Found 7 spaces, expected 8
W0311:202: Bad indentation. Found 7 spaces, expected 8
W0311:203: Bad indentation. Found 7 spaces, expected 8
W0311:204: Bad indentation. Found 7 spaces, expected 8
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:209: Bad indentation. Found 3 spaces, expected 4
W0311:210: Bad indentation. Found 7 spaces, expected 8
W0311:213: Bad indentation. Found 7 spaces, expected 8
W0311:214: Bad indentation. Found 11 spaces, expected 12
W0311:216: Bad indentation. Found 3 spaces, expected 4
W0311:217: Bad indentation. Found 7 spaces, expected 8
W0311:219: Bad indentation. Found 3 spaces, expected 4
W0311:220: Bad indentation. Found 6 spaces, expected 8
W0311:221: Bad indentation. Found 6 spaces, expected 8
W0311:222: Bad indentation. Found 9 spaces, expected 12
W0311:227: Bad indentation. Found 9 spaces, expected 12
W0311:228: Bad indentation. Found 9 spaces, expected 12
W0311:229: Bad indentation. Found 12 spaces, expected 16
W0311:230: Bad indentation. Found 12 spaces, expected 16
W0311:231: Bad indentation. Found 12 spaces, expected 16
W0311:232: Bad indentation. Found 12 spaces, expected 16
W0311:233: Bad indentation. Found 15 spaces, expected 20
W0311:234: Bad indentation. Found 12 spaces, expected 16
W0311:235: Bad indentation. Found 12 spaces, expected 16
W0311:236: Bad indentation. Found 9 spaces, expected 12
W0311:237: Bad indentation. Found 9 spaces, expected 12
W0311:238: Bad indentation. Found 9 spaces, expected 12
W0311:239: Bad indentation. Found 9 spaces, expected 12
W0311:240: Bad indentation. Found 6 spaces, expected 8
W0311:241: Bad indentation. Found 6 spaces, expected 8
W0311:242: Bad indentation. Found 9 spaces, expected 12
W0311:243: Bad indentation. Found 9 spaces, expected 12
W0311:245: Bad indentation. Found 3 spaces, expected 4
W0311:246: Bad indentation. Found 6 spaces, expected 8
W0311:247: Bad indentation. Found 6 spaces, expected 8
W0311:248: Bad indentation. Found 9 spaces, expected 12
W0311:250: Bad indentation. Found 3 spaces, expected 4
W0311:251: Bad indentation. Found 7 spaces, expected 8
W0311:253: Bad indentation. Found 3 spaces, expected 4
W0311:254: Bad indentation. Found 7 spaces, expected 8
W0311:256: Bad indentation. Found 3 spaces, expected 4
W0311:257: Bad indentation. Found 7 spaces, expected 8
W0311:259: Bad indentation. Found 3 spaces, expected 4
W0311:260: Bad indentation. Found 7 spaces, expected 8
W0311:263: Bad indentation. Found 3 spaces, expected 4
W0311:264: Bad indentation. Found 7 spaces, expected 8
W0311:266: Bad indentation. Found 3 spaces, expected 4
W0311:267: Bad indentation. Found 6 spaces, expected 8
W0311:271: Bad indentation. Found 3 spaces, expected 4
W0311:286: Bad indentation. Found 3 spaces, expected 4
W0311:287: Bad indentation. Found 6 spaces, expected 8
W0311:288: Bad indentation. Found 6 spaces, expected 8
W0311:290: Bad indentation. Found 3 spaces, expected 4
W0311:291: Bad indentation. Found 6 spaces, expected 8
W0311:296: Bad indentation. Found 3 spaces, expected 4
W0311:297: Bad indentation. Found 6 spaces, expected 8
W0601:146:leo_file.gen1: Global variable 'vnode_count' undefined at the module level
W0601:157:leo_file.gen_vnodes: Global variable 'allvnodes' undefined at the module level
W0601:157:leo_file.gen_vnodes: Global variable 'vnode_stack' undefined at the module level
W0105:226:leo_node.gen_vnodes: String statement has no effect
W0601:236:leo_node.gen_vnodes: Global variable 'vnode_count' undefined at the module level

************* Module leo.plugins.leo_pdf
E0602:322:Bunch.__setitem__: Undefined variable 'operator'
E0602:326:Bunch.__getitem__: Undefined variable 'operator'
W0105:344:Writer: String statement has no effect
W0105:372:Writer: String statement has no effect

************* Module leo.plugins.leoOPML
E1101:211:opmlFileCommandsClass.putOPMLHeader: Instance of 'opmlFileCommandsClass' has no 'opml_write_leo_globals_attributes' member
E1101:245:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_write_leo_details' member
E1101:261:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_write_body_text' member
E1101:262:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_use_outline_elements' member
E1101:334:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_write_ua_attributes' member
E1101:336:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_expand_ua_dictionary' member
E1101:338:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_skip_ua_dictionary_blanks' member
E1101:430:opmlController.createVnode: Module 'leo.core.leoNodes' has no 'tnode' member
E1101:434:opmlController.createVnode: Instance of 'vnode' has no 't' member
W0221:778:contentHandler.ignorableWhitespace: Arguments number differs from overridden method

************* Module leo.plugins.leoremote
W0611: 41: Unused import sys

************* Module leo.plugins.lineNumbers
E1121: 51:init.putLineNumberDirective: Too many positional arguments for function call

************* Module leo.plugins.macros
E1103:135:paramClass.parameterize: Instance of 'unitTestGui' has no 'getInsertPoint' member (but some types could not be inferred)
E1103:135:paramClass.parameterize: Instance of 'nullGui' has no 'getInsertPoint' member (but some types could not be inferred)

************* Module leo.plugins.mod_autosave
W0311: 86: Bad indentation. Found 9 spaces, expected 8
W0611: 25: Unused import os

************* Module leo.plugins.mod_leo2ascd
E1120:143:GetAscFilename: No value passed for parameter 'vnode' in function call
E1120:358:WriteTreeOfCurrentNode: No value passed for parameter 'vnode' in function call
E1120:373:WriteAll: No value passed for parameter 'vnode' in function call
E1120:433: No value passed for parameter 'c' in function call

************* Module leo.plugins.mod_speedups
W0611: 27: Unused import leoPlugins
W0611: 46: Unused import leo

************* Module leo.plugins.nav_buttons
W0311:319: Bad indentation. Found 11 spaces, expected 12

************* Module leo.plugins.nodeActions
W0312:252: Found indentation with tabs instead of spaces
W0312:253: Found indentation with tabs instead of spaces
W0312:254: Found indentation with tabs instead of spaces
W0312:255: Found indentation with tabs instead of spaces
W0312:256: Found indentation with tabs instead of spaces
W0312:257: Found indentation with tabs instead of spaces
W0311:261: Bad indentation. Found 3 spaces, expected 4
W0311:270: Bad indentation. Found 3 spaces, expected 4
W0311:272: Bad indentation. Found 3 spaces, expected 4
W0311:273: Bad indentation. Found 6 spaces, expected 8
W0311:276: Bad indentation. Found 3 spaces, expected 4
W0311:277: Bad indentation. Found 3 spaces, expected 4
W0311:278: Bad indentation. Found 6 spaces, expected 8
W0311:281: Bad indentation. Found 3 spaces, expected 4
W0311:282: Bad indentation. Found 3 spaces, expected 4
W0311:283: Bad indentation. Found 6 spaces, expected 8
W0311:285: Bad indentation. Found 3 spaces, expected 4
W0311:287: Bad indentation. Found 6 spaces, expected 8
W0311:288: Bad indentation. Found 6 spaces, expected 8
W0311:290: Bad indentation. Found 6 spaces, expected 8
W0311:293: Bad indentation. Found 9 spaces, expected 12
W0311:294: Bad indentation. Found 12 spaces, expected 16
W0311:297: Bad indentation. Found 9 spaces, expected 12
W0311:298: Bad indentation. Found 12 spaces, expected 16
W0311:300: Bad indentation. Found 9 spaces, expected 12
W0311:301: Bad indentation. Found 9 spaces, expected 12
W0311:302: Bad indentation. Found 12 spaces, expected 16
W0311:305: Bad indentation. Found 9 spaces, expected 12
W0311:306: Bad indentation. Found 9 spaces, expected 12
W0311:307: Bad indentation. Found 12 spaces, expected 16
W0311:308: Bad indentation. Found 9 spaces, expected 12
W0311:309: Bad indentation. Found 12 spaces, expected 16
W0311:311: Bad indentation. Found 9 spaces, expected 12
W0311:312: Bad indentation. Found 9 spaces, expected 12
W0311:313: Bad indentation. Found 9 spaces, expected 12
W0311:314: Bad indentation. Found 12 spaces, expected 16
W0311:316: Bad indentation. Found 9 spaces, expected 12
W0311:317: Bad indentation. Found 9 spaces, expected 12
W0311:318: Bad indentation. Found 12 spaces, expected 16
W0311:322: Bad indentation. Found 9 spaces, expected 12
W0311:326: Bad indentation. Found 9 spaces, expected 12
W0311:327: Bad indentation. Found 9 spaces, expected 12
W0311:328: Bad indentation. Found 9 spaces, expected 12
W0311:330: Bad indentation. Found 12 spaces, expected 16
W0311:331: Bad indentation. Found 12 spaces, expected 16
W0311:332: Bad indentation. Found 15 spaces, expected 20
W0311:334: Bad indentation. Found 15 spaces, expected 20
W0311:335: Bad indentation. Found 15 spaces, expected 20
W0311:336: Bad indentation. Found 18 spaces, expected 24
W0311:340: Bad indentation. Found 9 spaces, expected 12
W0311:341: Bad indentation. Found 12 spaces, expected 16
W0311:342: Bad indentation. Found 9 spaces, expected 12
W0311:343: Bad indentation. Found 12 spaces, expected 16
W0311:344: Bad indentation. Found 9 spaces, expected 12
W0311:345: Bad indentation. Found 12 spaces, expected 16
W0311:346: Bad indentation. Found 15 spaces, expected 20
W0311:347: Bad indentation. Found 12 spaces, expected 16
W0311:348: Bad indentation. Found 15 spaces, expected 20
W0311:351: Bad indentation. Found 12 spaces, expected 16
W0311:352: Bad indentation. Found 15 spaces, expected 20
W0311:354: Bad indentation. Found 18 spaces, expected 24
W0311:355: Bad indentation. Found 18 spaces, expected 24
W0311:356: Bad indentation. Found 18 spaces, expected 24
W0311:357: Bad indentation. Found 18 spaces, expected 24
W0311:358: Bad indentation. Found 21 spaces, expected 28
W0311:360: Bad indentation. Found 12 spaces, expected 16
W0311:362: Bad indentation. Found 12 spaces, expected 16
W0311:364: Bad indentation. Found 12 spaces, expected 16
W0311:365: Bad indentation. Found 15 spaces, expected 20
W0311:366: Bad indentation. Found 9 spaces, expected 12
W0311:367: Bad indentation. Found 12 spaces, expected 16
W0311:368: Bad indentation. Found 15 spaces, expected 20
W0311:371: Bad indentation. Found 6 spaces, expected 8
W0311:373: Bad indentation. Found 9 spaces, expected 12
W0311:374: Bad indentation. Found 12 spaces, expected 16
W0311:375: Bad indentation. Found 9 spaces, expected 12
W0311:376: Bad indentation. Found 6 spaces, expected 8
W0311:378: Bad indentation. Found 9 spaces, expected 12
W0311:379: Bad indentation. Found 12 spaces, expected 16
W0311:380: Bad indentation. Found 9 spaces, expected 12
W0311:381: Bad indentation. Found 6 spaces, expected 8
W0311:383: Bad indentation. Found 9 spaces, expected 12
W0311:384: Bad indentation. Found 12 spaces, expected 16
W0311:385: Bad indentation. Found 9 spaces, expected 12
W0311:386: Bad indentation. Found 3 spaces, expected 4
W0311:388: Bad indentation. Found 6 spaces, expected 8
W0311:389: Bad indentation. Found 9 spaces, expected 12
W0311:390: Bad indentation. Found 6 spaces, expected 8
W0311:394: Bad indentation. Found 3 spaces, expected 4
W0311:395: Bad indentation. Found 3 spaces, expected 4
W0311:396: Bad indentation. Found 7 spaces, expected 8
W0311:397: Bad indentation. Found 7 spaces, expected 8
W0311:398: Bad indentation. Found 7 spaces, expected 8
W0311:399: Bad indentation. Found 7 spaces, expected 8
W0311:401: Bad indentation. Found 7 spaces, expected 8
W0311:402: Bad indentation. Found 11 spaces, expected 12
W0311:403: Bad indentation. Found 11 spaces, expected 12
W0311:404: Bad indentation. Found 7 spaces, expected 8
W0311:405: Bad indentation. Found 11 spaces, expected 12
W0311:411: Bad indentation. Found 11 spaces, expected 12
W0311:413: Bad indentation. Found 11 spaces, expected 12
W0311:414: Bad indentation. Found 15 spaces, expected 16
W0311:415: Bad indentation. Found 15 spaces, expected 16
W0311:416: Bad indentation. Found 7 spaces, expected 8
W0311:418: Bad indentation. Found 11 spaces, expected 12
W0311:419: Bad indentation. Found 15 spaces, expected 16
W0311:420: Bad indentation. Found 15 spaces, expected 16
W0311:421: Bad indentation. Found 11 spaces, expected 12
W0311:422: Bad indentation. Found 11 spaces, expected 12
W0311:424: Bad indentation. Found 7 spaces, expected 8

************* Module leo.plugins.nodebar
W0601:179:initImages: Global variable 'clonePI' undefined at the module level
W0601:180:initImages: Global variable 'copyPI' undefined at the module level
W0601:181:initImages: Global variable 'cutPI' undefined at the module level
W0601:182:initImages: Global variable 'dehoistPI' undefined at the module level
W0601:183:initImages: Global variable 'deletePI' undefined at the module level
W0601:184:initImages: Global variable 'demotePI' undefined at the module level
W0601:185:initImages: Global variable 'hoistPI' undefined at the module level
W0601:186:initImages: Global variable 'insertPI' undefined at the module level
W0601:187:initImages: Global variable 'movedownPI' undefined at the module level
W0601:188:initImages: Global variable 'moveleftPI' undefined at the module level
W0601:189:initImages: Global variable 'moverightPI' undefined at the module level
W0601:190:initImages: Global variable 'moveupPI' undefined at the module level
W0601:191:initImages: Global variable 'nodedownPI' undefined at the module level
W0601:192:initImages: Global variable 'nodeleftPI' undefined at the module level
W0601:193:initImages: Global variable 'noderightPI' undefined at the module level
W0601:194:initImages: Global variable 'nodeupPI' undefined at the module level
W0601:195:initImages: Global variable 'pastePI' undefined at the module level
W0601:196:initImages: Global variable 'pasteclonePI' undefined at the module level
W0601:197:initImages: Global variable 'promotePI' undefined at the module level
W0601:198:initImages: Global variable 'questionPI' undefined at the module level
W0601:199:initImages: Global variable 'sortchildrenPI' undefined at the module level
W0601:200:initImages: Global variable 'sortsiblingsPI' undefined at the module level
W0611: 26: Unused import weakref

************* Module leo.plugins.pretty_print
W0233: 54:myPrettyPrinter.__init__: __init__ method from a non direct base class 'myPrettyPrinter' is called
E0602: 64:myPrettyPrinter.putNormalToken: Undefined variable 'token'
E0602:190:myPrettyPrinter.doOp: Undefined variable 'keyword'
E0602:225:myPrettyPrinter.doOp: Undefined variable 'string'
E0602:225:myPrettyPrinter.doOp: Undefined variable 'string'

************* Module leo.plugins.quickMove
W0311:219: Bad indentation. Found 16 spaces, expected 12
W0311:224: Bad indentation. Found 16 spaces, expected 12
W0611:105: Unused import types

************* Module leo.plugins.quicksearch
W0301:222: Unnecessary semicolon
W0301:240: Unnecessary semicolon
W0604: 73: Using the global statement at the module level
W0611: 42: Unused import QListWidget

************* Module leo.plugins.rClickBasePluginClasses
E1101:134:pluginCommandClass.preDoCommand: Instance of 'pluginCommandClass' has no 'doCommand' member
E1101:260:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandList' member
E1101:267:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandPrefix' member
E1101:272:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandPrefix' member
E1101:310:basePluginController.getCommandList: Instance of 'basePluginController' has no 'commandList' member
E1101:318:basePluginController.setDefaultContextMenus: Instance of 'basePluginController' has no 'defaultContextMenus' member

************* Module leo.plugins.run_nodes
E1120:211:OnQuit: No value passed for parameter 'c' in function call

************* Module leo.plugins.rst3
E1120:264:runUnitTests: No value passed for parameter 'headline' in function call
E1120:1018:rstClass.initOptionsFromSettings: No value passed for parameter 'tag' in function call

************* Module leo.plugins.scrolledmessage
W0311:402: Bad indentation. Found 12 spaces, expected 8
W0311:403: Bad indentation. Found 12 spaces, expected 8
E1101:284:ScrolledMessageDialog.doActionOutlineShow: Instance of 'ScrolledMessageDialog' has no 'name' member
W0107:309:ScrolledMessageDialog.doActionAbout: Unnecessary pass statement
E1101:526:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'label' member
E1101:527:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'label' member
E1101:533:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'title' member
E0211:537:ScrolledMessageDialog.afterDrawHandler: Method has no argument
E0602:607:ScrolledMessageController.afterRedrawHandler: Undefined variable 'dialogs'
E1120:608:ScrolledMessageController.afterRedrawHandler: No value passed for parameter 'tag' in function call
E1120:608:ScrolledMessageController.afterRedrawHandler: No value passed for parameter 'keywords' in function call
W0611: 86: Unused import inspect

************* Module leo.plugins.todo
E0102:258:todoController.addPopupMenu.func: function already defined line 249
E0213:305:todoController.redrawer: Method should have "self" as first argument
E1102:310:todoController.redrawer.new: fn is not callable
E0213:320:todoController.projectChanger: Method should have "self" as first argument
E1102:323:todoController.projectChanger.new: fn is not callable

************* Module leo.external.ipy_leo
W0601: 30:init_ipython: Global variable 'ip' undefined at the module level
W0107: 90:es: Unnecessary pass statement
W0108:231:LeoNode.<lambda>: Lambda may not be necessary
W1001:398:LeoWorkbook: Use of "property" on an old style class
E1101:438:workbook_complete: Function 'dispatch' has no 'when_type' member
E1101:438:workbook_complete: Function 'complete_object' has no 'when_type' member
E1101:589:edit_macro: Function 'edit_object_in_leo' has no 'when_type' member
W0601:749:lleo_f: Global variable '_request_immediate_connect' undefined at the module level

************* Module leo.external.lproto
E1101:137:LProtoClient.__init__: Module 'socket' has no 'AF_UNIX' member

************* Module leo.plugins.toolbar
E1103:463:ToolbarTkinterFrame.getIconButton: Instance of 'tkIconBarClass' has no 'getButton' member (but some types coul
d not be inferred)
E1103:463:ToolbarTkinterFrame.getIconButton: Instance of 'nullIconBarClass' has no 'getButton' member (but some types co
uld not be inferred)
E1103:538:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'tkIconBarClass' has no 'getWidgetFrame' member (but some
types could not be inferred)
E1103:538:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'nullIconBarClass' has no 'getWidgetFrame' member (but som
e types could not be inferred)
E1103:1336:ToolbarScriptingController.createScriptButtonIconButton: Instance of 'ToolbarScriptButton' has no 'configure'
 member (but some types could not be inferred)
#@+node:ekr.20101028131948.5858: *3* Pylint errors for minor plugins
@killcolor

************* Module leo.plugins.geotag
E1101: 64:geotag_Controller.__del__: Instance of 'geotag_Controller' has no 'handlers' member


************* Module leo.plugins.graphed
W0511:366: FIXME
W0511:377: FIXME no handlers?


************* Module leo.plugins.groupOperations
E0602: 77:init: Undefined variable 'sets'
W0601:192:initImages: Global variable 'groupOpPI' undefined at the module level
W0601:193:initImages: Global variable 'bullseyePI' undefined at the module level
W0601:194:initImages: Global variable 'copyPI' undefined at the module level
W0601:195:initImages: Global variable 'clonePI' undefined at the module level
W0601:196:initImages: Global variable 'movePI' undefined at the module level
W0601:197:initImages: Global variable 'move_arrowPI' undefined at the module level
W0601:198:initImages: Global variable 'copy_arrowPI' undefined at the module level
W0601:199:initImages: Global variable 'clone_arrowPI' undefined at the module level
W0601:200:initImages: Global variable 'markSpotPI' undefined at the module level
W0601:201:initImages: Global variable 'markForPI' undefined at the module level
W0601:202:initImages: Global variable 'operateOnMarkedPI' undefined at the module level
W0601:203:initImages: Global variable 'clearMarksPI' undefined at the module level
W0601:204:initImages: Global variable 'transferFromPI' undefined at the module level
W0611: 31: Unused import copy
W0611: 32: Unused import base64


************* Module leo.plugins.leoupdate
W0105: 61: String statement has no effect
E0602: 72:init: Undefined variable 'sets'
W0601: 96:onCreate: Global variable 'thePluginController' undefined at the module level
W0601:103:topLevelMenu: Global variable 'thePluginController' undefined at the module level
E1101:143:LeoUpdater.showManagerDialog.HandlerDialog.initLocalCollection: Instance of 'HandlerDialog' has no 'c' member
E1101:161:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'remote_plugin_list' member
E1101:162:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
E1101:166:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
E1101:170:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'plugin_list' member
E1101:171:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'plugin_list' member
E1101:173:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'remote_plugin_list' member
E1101:174:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
W0611: 30: Unused import glob
W0611: 29: Unused import sys
W0611: 28: Unused import re


************* Module leo.plugins.mod_labels
W0311:118: Bad indentation. Found 3 spaces, expected 4
W0311:119: Bad indentation. Found 6 spaces, expected 8
W0311:126: Bad indentation. Found 6 spaces, expected 8
W0311:128: Bad indentation. Found 3 spaces, expected 4
W0311:129: Bad indentation. Found 6 spaces, expected 8
W0311:133: Bad indentation. Found 3 spaces, expected 4
W0311:134: Bad indentation. Found 6 spaces, expected 8
W0311:135: Bad indentation. Found 6 spaces, expected 8
W0311:140: Bad indentation. Found 6 spaces, expected 8
W0311:142: Bad indentation. Found 3 spaces, expected 4
W0311:143: Bad indentation. Found 6 spaces, expected 8
W0311:206: Bad indentation. Found 20 spaces, expected 16
W0311:207: Bad indentation. Found 20 spaces, expected 16
W0311:208: Bad indentation. Found 20 spaces, expected 16
W0311:209: Bad indentation. Found 28 spaces, expected 20
W0311:210: Bad indentation. Found 20 spaces, expected 16
W0311:212: Bad indentation. Found 20 spaces, expected 16
W0311:226: Bad indentation. Found 20 spaces, expected 16
W0311:228: Bad indentation. Found 20 spaces, expected 16
W0311:236: Bad indentation. Found 20 spaces, expected 16
E1123:542:labelsController.label_to_subnode: Passing unexpected keyword argument 'p' in function call
E1120:542:labelsController.label_to_subnode: No value passed for parameter 'v' in function call
E1101:571:labelsController.subnode_to_label: Instance of 'labelsController' has no 'get_labellist_for_node' member
E0602:579:labelsController.subnode_to_label: Undefined variable 'v'
E0602:605:labelsController.subnode_to_label: Undefined variable 'labels'
E0602:606:labelsController.subnode_to_label: Undefined variable 'v'
E0602:606:labelsController.subnode_to_label: Undefined variable 'labels'
E0602:611:labelsController.subnode_to_label: Undefined variable 'v'
E1120:623:labelsController.subnodes_to_label: No value passed for parameter 'title' in function call
E0602:673:labelsController.subnodes_to_labels: Undefined variable 'v'
W0611: 39: Unused import leoAtFile
W0611: 40: Unused import leoCommands
W0611: 53: Unused import os


************* Module leo.plugins.newButtons
E1101:249:UIHelperClass.addWidgets: Instance of 'FlatOptionMenu' has no 'pack' member
E1111:362:HelperForm.formCommit: Assigning to function call which doesn't return


************* Module leo.plugins.nodeActions
W0312: 63: Found indentation with tabs instead of spaces
W0312: 64: Found indentation with tabs instead of spaces
W0312: 65: Found indentation with tabs instead of spaces
W0312: 66: Found indentation with tabs instead of spaces
W0312: 67: Found indentation with tabs instead of spaces
W0312: 68: Found indentation with tabs instead of spaces
W0311: 72: Bad indentation. Found 3 spaces, expected 4
W0311: 81: Bad indentation. Found 3 spaces, expected 4
W0311: 83: Bad indentation. Found 3 spaces, expected 4
W0311: 84: Bad indentation. Found 6 spaces, expected 8
W0311: 87: Bad indentation. Found 3 spaces, expected 4
W0311: 88: Bad indentation. Found 3 spaces, expected 4
W0311: 89: Bad indentation. Found 6 spaces, expected 8
W0311: 92: Bad indentation. Found 3 spaces, expected 4
W0311: 93: Bad indentation. Found 3 spaces, expected 4
W0311: 94: Bad indentation. Found 6 spaces, expected 8
W0311: 96: Bad indentation. Found 3 spaces, expected 4
W0311: 98: Bad indentation. Found 6 spaces, expected 8
W0311: 99: Bad indentation. Found 6 spaces, expected 8
W0311:101: Bad indentation. Found 6 spaces, expected 8
W0311:104: Bad indentation. Found 9 spaces, expected 12
W0311:105: Bad indentation. Found 12 spaces, expected 16
W0311:108: Bad indentation. Found 9 spaces, expected 12
W0311:109: Bad indentation. Found 12 spaces, expected 16
W0311:111: Bad indentation. Found 9 spaces, expected 12
W0311:112: Bad indentation. Found 9 spaces, expected 12
W0311:113: Bad indentation. Found 12 spaces, expected 16
W0311:116: Bad indentation. Found 9 spaces, expected 12
W0311:117: Bad indentation. Found 9 spaces, expected 12
W0311:118: Bad indentation. Found 12 spaces, expected 16
W0311:119: Bad indentation. Found 9 spaces, expected 12
W0311:120: Bad indentation. Found 12 spaces, expected 16
W0311:122: Bad indentation. Found 9 spaces, expected 12
W0311:123: Bad indentation. Found 9 spaces, expected 12
W0311:124: Bad indentation. Found 9 spaces, expected 12
W0311:125: Bad indentation. Found 12 spaces, expected 16
W0311:127: Bad indentation. Found 9 spaces, expected 12
W0311:128: Bad indentation. Found 9 spaces, expected 12
W0311:129: Bad indentation. Found 12 spaces, expected 16
W0311:133: Bad indentation. Found 9 spaces, expected 12
W0311:137: Bad indentation. Found 9 spaces, expected 12
W0311:138: Bad indentation. Found 9 spaces, expected 12
W0311:139: Bad indentation. Found 9 spaces, expected 12
W0311:141: Bad indentation. Found 12 spaces, expected 16
W0311:142: Bad indentation. Found 12 spaces, expected 16
W0311:143: Bad indentation. Found 15 spaces, expected 20
W0311:145: Bad indentation. Found 15 spaces, expected 20
W0311:146: Bad indentation. Found 15 spaces, expected 20
W0311:147: Bad indentation. Found 18 spaces, expected 24
W0311:151: Bad indentation. Found 9 spaces, expected 12
W0311:152: Bad indentation. Found 12 spaces, expected 16
W0311:153: Bad indentation. Found 9 spaces, expected 12
W0311:154: Bad indentation. Found 12 spaces, expected 16
W0311:155: Bad indentation. Found 9 spaces, expected 12
W0311:156: Bad indentation. Found 12 spaces, expected 16
W0311:157: Bad indentation. Found 15 spaces, expected 20
W0311:158: Bad indentation. Found 12 spaces, expected 16
W0311:159: Bad indentation. Found 15 spaces, expected 20
W0311:162: Bad indentation. Found 12 spaces, expected 16
W0311:163: Bad indentation. Found 15 spaces, expected 20
W0311:165: Bad indentation. Found 18 spaces, expected 24
W0311:166: Bad indentation. Found 18 spaces, expected 24
W0311:167: Bad indentation. Found 18 spaces, expected 24
W0311:168: Bad indentation. Found 18 spaces, expected 24
W0311:169: Bad indentation. Found 21 spaces, expected 28
W0311:171: Bad indentation. Found 12 spaces, expected 16
W0311:173: Bad indentation. Found 12 spaces, expected 16
W0311:175: Bad indentation. Found 12 spaces, expected 16
W0311:176: Bad indentation. Found 15 spaces, expected 20
W0311:177: Bad indentation. Found 9 spaces, expected 12
W0311:178: Bad indentation. Found 12 spaces, expected 16
W0311:179: Bad indentation. Found 15 spaces, expected 20
W0311:182: Bad indentation. Found 6 spaces, expected 8
W0311:184: Bad indentation. Found 9 spaces, expected 12
W0311:185: Bad indentation. Found 12 spaces, expected 16
W0311:186: Bad indentation. Found 9 spaces, expected 12
W0311:187: Bad indentation. Found 6 spaces, expected 8
W0311:189: Bad indentation. Found 9 spaces, expected 12
W0311:190: Bad indentation. Found 12 spaces, expected 16
W0311:191: Bad indentation. Found 9 spaces, expected 12
W0311:192: Bad indentation. Found 6 spaces, expected 8
W0311:194: Bad indentation. Found 9 spaces, expected 12
W0311:195: Bad indentation. Found 12 spaces, expected 16
W0311:196: Bad indentation. Found 9 spaces, expected 12
W0311:197: Bad indentation. Found 3 spaces, expected 4
W0311:199: Bad indentation. Found 6 spaces, expected 8
W0311:200: Bad indentation. Found 9 spaces, expected 12
W0311:201: Bad indentation. Found 6 spaces, expected 8
W0311:205: Bad indentation. Found 3 spaces, expected 4
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:208: Bad indentation. Found 7 spaces, expected 8
W0311:209: Bad indentation. Found 7 spaces, expected 8
W0311:210: Bad indentation. Found 7 spaces, expected 8
W0311:212: Bad indentation. Found 7 spaces, expected 8
W0311:213: Bad indentation. Found 11 spaces, expected 12
W0311:214: Bad indentation. Found 11 spaces, expected 12
W0311:215: Bad indentation. Found 7 spaces, expected 8
W0311:216: Bad indentation. Found 11 spaces, expected 12
W0311:222: Bad indentation. Found 11 spaces, expected 12
W0311:224: Bad indentation. Found 11 spaces, expected 12
W0311:225: Bad indentation. Found 15 spaces, expected 16
W0311:226: Bad indentation. Found 15 spaces, expected 16
W0311:227: Bad indentation. Found 7 spaces, expected 8
W0311:229: Bad indentation. Found 11 spaces, expected 12
W0311:230: Bad indentation. Found 15 spaces, expected 16
W0311:231: Bad indentation. Found 15 spaces, expected 16
W0311:232: Bad indentation. Found 11 spaces, expected 12
W0311:233: Bad indentation. Found 11 spaces, expected 12
W0311:235: Bad indentation. Found 7 spaces, expected 8


************* Module leo.plugins.pie_menus
E1101:104:PieMenu.drawString: Instance of 'PieMenu' has no 'l4' member
E1101:104:PieMenu.drawString: Instance of 'PieMenu' has no 'l4' member
E0602:134:PieMenu.construct: Undefined variable 'l1'
E0602:138:PieMenu.construct: Undefined variable 'l1'
E0602:142:PieMenu.construct: Undefined variable 'l1'
E0602:147:PieMenu.construct: Undefined variable 'l1'
E0602:151:PieMenu.construct: Undefined variable 'l1'
E0602:166:PieMenu.construct: Undefined variable 'l1'
E0602:179:PieMenu.construct: Undefined variable 'l3'
E0602:185:PieMenu.construct: Undefined variable 'l3'
E0602:192:PieMenu.construct: Undefined variable 'l3'
E0602:200:PieMenu.construct: Undefined variable 'l2'
E0602:206:PieMenu.construct: Undefined variable 'l2'
E0602:212:PieMenu.construct: Undefined variable 'l2'
E0602:219:PieMenu.construct: Undefined variable 'l2'
E0602:225:PieMenu.construct: Undefined variable 'l2'
E0602:233:PieMenu.construct: Undefined variable 'l4'
E0602:239:PieMenu.construct: Undefined variable 'l4'
E0602:246:PieMenu.construct: Undefined variable 'l4'
E0602:254:PieMenu.construct: Undefined variable 'l5'
E0602:262:PieMenu.construct: Undefined variable 'l6'
E0602:270:PieMenu.construct: Undefined variable 'l7'
E0602:276:PieMenu.construct: Undefined variable 'l7'
E0602:282:PieMenu.construct: Undefined variable 'l7'
E1101:381:PieMenu.clean: Instance of 'PieMenu' has no 'l1' member
E1101:382:PieMenu.clean: Instance of 'PieMenu' has no 'l2' member
E1101:383:PieMenu.clean: Instance of 'PieMenu' has no 'l3' member
E1101:384:PieMenu.clean: Instance of 'PieMenu' has no 'l4' member
E1101:385:PieMenu.clean: Instance of 'PieMenu' has no 'l5' member
E1101:386:PieMenu.clean: Instance of 'PieMenu' has no 'l6' member
E1101:387:PieMenu.clean: Instance of 'PieMenu' has no 'l7' member
E1101:433:PieMenu.draw: Instance of 'PieMenu' has no 'l1' member
E1101:434:PieMenu.draw: Instance of 'PieMenu' has no 'l3' member
E1101:435:PieMenu.draw: Instance of 'PieMenu' has no 'l2' member
E1101:436:PieMenu.draw: Instance of 'PieMenu' has no 'l4' member
E1101:437:PieMenu.draw: Instance of 'PieMenu' has no 'l5' member
E1101:438:PieMenu.draw: Instance of 'PieMenu' has no 'l6' member
E1101:439:PieMenu.draw: Instance of 'PieMenu' has no 'l7' member
E1101:440:PieMenu.draw: Instance of 'PieMenu' has no 'l1' member
E1101:441:PieMenu.draw: Instance of 'PieMenu' has no 'l3' member
E1101:442:PieMenu.draw: Instance of 'PieMenu' has no 'l2' member
E1101:443:PieMenu.draw: Instance of 'PieMenu' has no 'l4' member
E1101:444:PieMenu.draw: Instance of 'PieMenu' has no 'l5' member
E1101:445:PieMenu.draw: Instance of 'PieMenu' has no 'l6' member
E1101:446:PieMenu.draw: Instance of 'PieMenu' has no 'l7' member


************* Module leo.plugins.read_only_nodes
E0611: 73: No name 'parse' in module 'urllib'
E0602:201:FTPurl.read: Undefined variable 'sys'
E0602:235:FTPurl.write: Undefined variable 'sys'
E0213:239:FTPurl.seek: Method should have "self" as first argument
E0602:240:FTPurl.seek: Undefined variable 'self'
E0211:242:FTPurl.flush: Method has no argument
E0602:256:FTPurl.dir: Undefined variable 'sys'
W0601:290:enable_body: Global variable 'insertOnTime' undefined at the module level
W0601:290:enable_body: Global variable 'insertOffTime' undefined at the module level
W0601:300:disable_body: Global variable 'insertOnTime' undefined at the module level
W0601:300:disable_body: Global variable 'insertOffTime' undefined at the module level


************* Module leo.plugins.rClick
W0511:633: TODO:
E1101:958:pluginController.getButtonHandlers: Instance of 'pluginController' has no 'button_handlers' member
E1101:1587:pluginController.findButtonCommandClass.doCommand: Instance of 'findButtonCommandClass' has no 'data' member
W0611:662: Unused import ImageTk
W0611:661: Unused import Image


************* Module leo.plugins.searchbar
W0311:100: Bad indentation. Found 9 spaces, expected 8
W0107:125:onPreCreate: Unnecessary pass statement
E1101:205:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'bg' member
E1101:211:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'labelText' member
E1101:213:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'command' member
E1103:216:SearchbarEntryWidget.__init__: Instance of 'stringTextWidget' has no 'pack' member (but some types could not be inferred)
E1101:270:SearchbarEntryWidget.detachWidget: Instance of 'SearchbarEntryWidget' has no 'leoIconBar' member
E1101:275:SearchbarEntryWidget.detachWidget: Instance of 'SearchbarEntryWidget' has no 'leoIconBar' member
E1101:299:SearchbarEntryWidget.onTextChanged: Instance of 'SearchbarEntryWidget' has no 'slave' member
E1101:309:SearchbarEntryWidget.onRightClick: Instance of 'SearchbarEntryWidget' has no 'entry_menu' member
E1101:316:SearchbarEntryWidget.onReturn: Instance of 'SearchbarEntryWidget' has no 'command' member
W0107:460:pluginController.toggleSearchbarCommandClass.doCommand: Unnecessary pass statement
W0611: 48: Unused import sys
W0611: 56: Unused import ImageTk
W0611: 55: Unused import Image
W0611: 47: Unused import re
W0611: 49: Unused import os


************* Module leo.plugins.searchbox
E1101:245:QuickFind.__init__: Class 'leoTkinterFrame' has no 'leoTkTextWidget' member
E1103:280:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'mark_set' member (but some types could not be inferred)
E1103:282:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'toGuiIndex' member (but some types could not be inferred)
E1103:283:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'mark_set' member (but some types could not be inferred)


************* Module leo.plugins.templates
W0601:100:initImages: Global variable 'templatePI' undefined at the module level
W0601:101:initImages: Global variable 'tempwizPI' undefined at the module level
E0602:210:getTemplateDialog: Undefined variable 'bs'
E0602:211:getTemplateDialog: Undefined variable 'hs'


************* Module leo.plugins.toolbar
W0511:749: FIXME:
W0511:829: TODO: not ready yet
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'tkIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'nullIconBarClass' has no 'getButton' member (but some types could not be inferred)
W0221:491:ToolbarTkinterFrame.addIconWidget: Arguments number differs from overridden method
W0221:499:ToolbarTkinterFrame.clearIconBar: Arguments number differs from overridden method
E1101:503:ToolbarTkinterFrame.clearIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
W0221:505:ToolbarTkinterFrame.createIconBar: Arguments number differs from overridden method
E1101:519:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1101:525:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1101:528:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
W0221:540:ToolbarTkinterFrame.hideIconBar: Arguments number differs from overridden method
E1101:544:ToolbarTkinterFrame.hideIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'tkIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'nullIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1101:580:ToolbarTkinterFrame.getToolbarFrame: Instance of 'ToolbarTkinterFrame' has no 'toolBar' member
E1101:643:ToolbarIconWidgetFrame.detachWidget: Instance of 'ToolbarIconWidgetFrame' has no 'leoIconBar' member
E1101:648:ToolbarIconWidgetFrame.detachWidget: Instance of 'ToolbarIconWidgetFrame' has no 'leoIconBar' member
E1101:858:ToolbarIconButton.detachWidget: Instance of 'ToolbarIconButton' has no 'leoIconBar' member
E1101:863:ToolbarIconButton.detachWidget: Instance of 'ToolbarIconButton' has no 'leoIconBar' member
E1101:995:ToolbarIconButton.setCommand: Instance of 'ToolbarIconButton' has no 'config' member
E1101:1031:ToolbarScriptButton.__init__.<lambda>: Instance of 'ToolbarScriptButton' has no 'invoke' member
W0221:1253:ToolbarScriptingController.executeScriptFromButton: Arguments number differs from overridden method
W0221:1338:ToolbarScriptingController.createScriptButtonIconButton: Arguments number differs from overridden method
E1103:1360:ToolbarScriptingController.createScriptButtonIconButton: Instance of 'ToolbarScriptButton' has no 'configure' member (but some types could not be inferred)
W0221:1362:ToolbarScriptingController.addScriptButtonCommand: Arguments number differs from overridden method
W0221:1840:ToolbarTkIconBarClass.addWidget: Arguments number differs from overridden method
W0221:2016:ToolbarTkIconBarClass.pack: Arguments number differs from overridden method


============ xcc
W0312:233: Found indentation with tabs instead of spaces
W0312:406: Found indentation with tabs instead of spaces
W0312:408: Found indentation with tabs instead of spaces
W0312:409: Found indentation with tabs instead of spaces
W0312:410: Found indentation with tabs instead of spaces
W0312:412: Found indentation with tabs instead of spaces
W0312:413: Found indentation with tabs instead of spaces
W0312:417: Found indentation with tabs instead of spaces
W0312:418: Found indentation with tabs instead of spaces
W0312:423: Found indentation with tabs instead of spaces
W0312:424: Found indentation with tabs instead of spaces
W0312:425: Found indentation with tabs instead of spaces
W0312:469: Found indentation with tabs instead of spaces
W0312:471: Found indentation with tabs instead of spaces
W0312:473: Found indentation with tabs instead of spaces
W0312:474: Found indentation with tabs instead of spaces
W0312:475: Found indentation with tabs instead of spaces
W0312:478: Found indentation with tabs instead of spaces
W0312:479: Found indentation with tabs instead of spaces
W0312:494: Found indentation with tabs instead of spaces
W0312:495: Found indentation with tabs instead of spaces
W0312:496: Found indentation with tabs instead of spaces
W0312:498: Found indentation with tabs instead of spaces
W0312:499: Found indentation with tabs instead of spaces
W0312:503: Found indentation with tabs instead of spaces
W0312:504: Found indentation with tabs instead of spaces
W0312:505: Found indentation with tabs instead of spaces
W0312:506: Found indentation with tabs instead of spaces
W0312:507: Found indentation with tabs instead of spaces
W0312:508: Found indentation with tabs instead of spaces
W0312:512: Found indentation with tabs instead of spaces
W0312:513: Found indentation with tabs instead of spaces
W0312:514: Found indentation with tabs instead of spaces
W0312:515: Found indentation with tabs instead of spaces
W0312:517: Found indentation with tabs instead of spaces
W0312:521: Found indentation with tabs instead of spaces
W0312:525: Found indentation with tabs instead of spaces
W0312:526: Found indentation with tabs instead of spaces
W0312:527: Found indentation with tabs instead of spaces
W0312:528: Found indentation with tabs instead of spaces
W0312:532: Found indentation with tabs instead of spaces
W0312:533: Found indentation with tabs instead of spaces
W0312:536: Found indentation with tabs instead of spaces
W0312:537: Found indentation with tabs instead of spaces
W0312:538: Found indentation with tabs instead of spaces
W0312:539: Found indentation with tabs instead of spaces
W0312:540: Found indentation with tabs instead of spaces
W0312:542: Found indentation with tabs instead of spaces
W0312:556: Found indentation with tabs instead of spaces
W0312:557: Found indentation with tabs instead of spaces
W0511:169: XXX to XxxClass.
W0511:521: TODO: ","Add import code in ImportFiles function!")
W0511:3342: TODO: Support precompiled header auto creation/inclusion."""
W0511:3663: TODO: send a WATCHTASK if breaked
E0602:339:OnStart2: Undefined variable 'XCC_INITED'
E0602:341:OnStart2: Undefined variable 'InitXcc'
E1101:418:linPause: Module 'os' has no 'kill' member
E0601:423:AddText: Using variable 'c' before assignment
E0602:424:AddText: Undefined variable 'LeoBody'
E0602:425:AddText: Undefined variable 'LeoBody'
E0602:474:DecompressIcon: Undefined variable 'Excetion'
E0602:475:DecompressIcon: Undefined variable 'Traceback'
E0602:536:ReplaceVars: Undefined variable 'NAME'
E0602:537:ReplaceVars: Undefined variable 'EXT'
E0602:538:ReplaceVars: Undefined variable 'ABS_PATH'
E0602:539:ReplaceVars: Undefined variable 'REL_PATH'
E0602:540:ReplaceVars: Undefined variable 'SRC_EXT'
E1121:677:controllerClass.onIdle: Too many positional arguments for function call
E1121:730:controllerClass.onQuit: Too many positional arguments for function call
E0211:816:controllerClass.UpdateProcess: Method has no argument
E0601:818:controllerClass.UpdateProcess: Using variable 'cc' before assignment
E0602:820:controllerClass.UpdateProcess: Undefined variable 'self'
E0211:995:controllerClass.sGetExecInfo: Method has no argument
E0602:997:controllerClass.sGetExecInfo: Undefined variable 'self'
E0602:1023:controllerClass.sGoToError: Undefined variable 'CPL'
E1101:1181:controllerClass.sSetText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1181:controllerClass.sSetText: Undefined variable 'SELECTED_NODE'
E1101:1187:controllerClass.sAddText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1187:controllerClass.sAddText: Undefined variable 'SELECTED_NODE'
E1120:1252:controllerClass.aStop: No value passed for parameter 'pid' in function call
E0602:1268:controllerClass.aStepIn: Undefined variable 'DBG'
E0602:1283:controllerClass.aStepOver: Undefined variable 'DBG'
E0602:1298:controllerClass.aStepOut: Undefined variable 'DBG'
E1120:1311:controllerClass.aPause: No value passed for parameter 'pid' in function call
E1101:1345:controllerClass.aSetText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1345:controllerClass.aSetText: Undefined variable 'ACTIVE_NODE'
E1101:1351:controllerClass.aAddText: Instance of 'controllerClass' has no 'ACTIVE_NOD' member
E1101:1352:controllerClass.aAddText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1355:controllerClass.aAddText: Undefined variable 'LeoBodyText'
E1101:1382:controllerClass.Compile: Instance of 'controllerClass' has no 'ProcessClass' member
E1101:1389:controllerClass.Compile: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1404:controllerClass.CplCmd: Instance of 'controllerClass' has no 'ReplaceVars' member
E0602:1443:controllerClass.CplCmd: Undefined variable 'CPL'
E1101:1460:controllerClass.Debug: Instance of 'controllerClass' has no 'GetDebugInfo' member
E1101:1469:controllerClass.Debug: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1476:controllerClass.DbgCmd: Instance of 'controllerClass' has no 'ReplaceVars' member
E1121:1486:controllerClass.Execute: Too many positional arguments for function call
E1101:1498:controllerClass.Execute: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1510:controllerClass.CplStart: Instance of 'controllerClass' has no 'VProcessList' member
E1101:1590:controllerClass.DbgStart: Instance of 'controllerClass' has no 'ProcessList' member
E0602:1610:controllerClass.DbgStart: Undefined variable 'DBG'
E0602:1617:controllerClass.DbgStart: Undefined variable 'DBG'
E0213:1619:controllerClass.DbgOut: Method should have "self" as first argument
E0602:1623:controllerClass.DbgOut: Undefined variable 'self'
E0602:1628:controllerClass.DbgOut: Undefined variable 'OutBuff'
E1101:1707:controllerClass.ProgStart: Instance of 'controllerClass' has no 'ProcessList' member
E0602:1722:controllerClass.ProgOut: Undefined variable 'ExtractLines'
E0602:1722:controllerClass.ProgOut: Undefined variable 'OutBuff'
E0602:1739:controllerClass.ProgErr: Undefined variable 'ExtractLines'
E0602:1739:controllerClass.ProgErr: Undefined variable 'ErrBuff'
E0602:1775:DBGTASK.__init__: Undefined variable 'DBG_SD'
E0602:1777:DBGTASK.__init__: Undefined variable 'DBG_SD'
E1101:1783:DBGTASK.Send: Instance of 'DBGTASK' has no 'Command' member
E1101:1784:DBGTASK.Send: Instance of 'DBGTASK' has no 'aWrite' member
E1101:1784:DBGTASK.Send: Instance of 'DBGTASK' has no 'Command' member
E1101:1785:DBGTASK.Send: Instance of 'DBGTASK' has no 'DBG_SD' member
E0602:1861:BREAKTASK.__init__: Undefined variable 'aGet'
E0602:1863:BREAKTASK.__init__: Undefined variable 'DBG'
E0602:1865:BREAKTASK.__init__: Undefined variable 'Waning'
E0602:1870:BREAKTASK.__init__: Undefined variable 'DBG'
E0602:1884:BREAKTASK.Send: Undefined variable 'NAME'
E0602:1885:BREAKTASK.Send: Undefined variable 'aWrite'
E0602:1887:BREAKTASK.Send: Undefined variable 'DBG_SD'
E0602:1888:BREAKTASK.Send: Undefined variable 'DBG_RD'
E0602:1900:BREAKTASK.Receive: Undefined variable 'aAddText'
E0602:1952:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1954:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1958:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1959:WATCHTASK.__init__: Undefined variable 'ccWatcher'
E0602:1962:WATCHTASK.__init__: Undefined variable 'DBG_SD'
W0601:1972:WATCHTASK.Cancel: Global variable 'WATCH_TASK' undefined at the module level
E0602:1973:WATCHTASK.Cancel: Undefined variable 'DBG_SD'
E0602:1974:WATCHTASK.Cancel: Undefined variable 'DBG_SD'
E0602:1975:WATCHTASK.Cancel: Undefined variable 'DBG_RD'
E0602:1976:WATCHTASK.Cancel: Undefined variable 'DBG_RD'
E0602:1977:WATCHTASK.Cancel: Undefined variable 'PROMPT_RD'
E0602:1978:WATCHTASK.Cancel: Undefined variable 'PROMPT_RD'
E0602:1980:WATCHTASK.Cancel: Undefined variable 'Watcher'
E0602:1986:WATCHTASK.Send: Undefined variable 'Watcher'
E0602:1988:WATCHTASK.Send: Undefined variable 'aWrite'
E0602:1988:WATCHTASK.Send: Undefined variable 'DBG'
E0602:1989:WATCHTASK.Send: Undefined variable 'DBG_SD'
E0602:1990:WATCHTASK.Send: Undefined variable 'DBG_RD'
E0602:1991:WATCHTASK.Send: Undefined variable 'PROMPT_RD'
E0602:1996:WATCHTASK.Receive: Undefined variable 'DBG_PROMPT'
W0601:2000:WATCHTASK.OnPrompt: Global variable 'WATCH_TASK' undefined at the module level
E0602:2002:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2008:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2013:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2014:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2017:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2018:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2020:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2023:WATCHTASK.OnPrompt: Undefined variable 'DBG_SD'
E0602:2025:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2028:WATCHTASK.OnPrompt: Undefined variable 'PROMPT_RD'
E0602:2029:WATCHTASK.OnPrompt: Undefined variable 'DBG_RD'
E0602:2104:BREAKIDTASK.Send: Undefined variable 'aWrite'
E0602:2105:BREAKIDTASK.Send: Undefined variable 'DBG_SD'
E0602:2106:BREAKIDTASK.Send: Undefined variable 'DBG_RD'
E0602:2557:ConfigClass.CplPageClass.Browse: Undefined variable 'e'
E0602:2697:ConfigClass.DbgPageClass.Browse: Undefined variable 'e'
E0602:3538:ToolbarClass.SyncDisplayToError: Undefined variable 'BreakBar'
E0602:3539:ToolbarClass.SyncDisplayToError: Undefined variable 'BreakBar'
E0602:3544:ToolbarClass.SyncDisplayToError: Undefined variable 'INSERT'
E0602:3557:ToolbarClass.SyncDisplayToError: Undefined variable 'c'
W0601:3561:ToolbarClass.SetError: Global variable 'PARSE_ERROR' undefined at the module level
W0601:3561:ToolbarClass.SetError: Global variable 'PARSE_ERROR_NODE' undefined at the module level
E0602:3593:ToolbarClass.Refresh: Undefined variable 'ACTIVE_NODE'
E0602:3613:WatcherClass.__init__: Undefined variable 'c'
E0602:3634:WatcherClass.__init__: Undefined variable 'c'
E0602:3635:WatcherClass.__init__: Undefined variable 'c'
E0602:3636:WatcherClass.__init__: Undefined variable 'c'
E0602:3637:WatcherClass.__init__: Undefined variable 'c'
E0602:3687:WatcherClass.OnDelete: Undefined variable 'sGet'
W0221:3799:BreakbarClass.yview: Arguments number differs from overridden method
E0602:3849:BreakbarClass.OnCut: Undefined variable 'LeoFrame'
E0602:3853:BreakbarClass.OnPaste: Undefined variable 'LeoFrame'
E1101:3858:BreakbarClass.OnRightClick: Instance of 'BreakbarClass' has no 'c' member
E0602:3859:BreakbarClass.OnRightClick: Undefined variable 'Menu'
E0602:3876:BreakbarClass.OnLeftClick: Undefined variable 'cGet'
E0602:3878:BreakbarClass.OnLeftClick: Undefined variable 'CHILD_NODE'
E0602:3891:BreakbarClass.OnLeftClick: Undefined variable 'SEL'
E0602:3895:BreakbarClass.AddNodeBreak: Undefined variable 'cGet'
E0602:3898:BreakbarClass.DeleteNodeBreak: Undefined variable 'cGet'
E0602:3903:BreakbarClass.ClearNodeBreaks: Undefined variable 'cSet'
E0602:4013:BreakbarClass.BreaksFromTags: Undefined variable 'CHILD_EXT'
E0602:4013:BreakbarClass.BreaksFromTags: Undefined variable 'CHILD_LINE'
E0602:4019:BreakbarClass.AddBreak: Undefined variable 'sGet'
E0602:4060:BreakbarClass.DeleteNodeBreaks: Undefined variable 'cGet'
E0602:4064:BreakbarClass.DeleteNodeBreaks: Undefined variable 'CHILD_EXT'
E0602:4064:BreakbarClass.DeleteNodeBreaks: Undefined variable 'CHILD_LINE'
E1101:4066:BreakbarClass.DeleteNodeBreaks: Instance of 'BreakbarClass' has no 'DeleteDbgBreaks' member
E0602:4068:BreakbarClass.DeleteNodeBreaks: Undefined variable 'cSelect'
E0602:4360:CppParserClass.FUNCRULE.DeclareFunc: Undefined variable 'ToolBar'
E0602:4378:CppParserClass.FUNCRULE.DefineFunc: Undefined variable 'ToolBar'
E0602:4516:CppParserClass.CLASSRULE.OnMatch: Undefined variable 'ToolBar'
E1101:4706:CppParserClass.Docum: Instance of 'CppParserClass' has no 'CURRENT_DOC_LINE' member
E0602:4730:CppParserClass.SetRealBodyDestination: Undefined variable 'EXT'
E1101:4799:CppParserClass.CppParse: Instance of 'CppParserClass' has no 'cc' member
E1102:4826:CppParserClass.CppParse: self.OnStart is not callable
E0602:4833:CppParserClass.CppParse: Undefined variable 'NAME'
E1102:4839:CppParserClass.CppParse: self.OnEnd is not callable
E1101:4852:CppParserClass.ParseNode: Instance of 'CppParserClass' has no 'cc' member
E0602:4942:WriterClass.OnWriteStart: Undefined variable 'REL_PATH'
E0602:4943:WriterClass.OnWriteStart: Undefined variable 'REL_PATH'
E0602:4943:WriterClass.OnWriteStart: Undefined variable 'NAME'
E0602:4945:WriterClass.OnWriteStart: Undefined variable 'NAME'
E0602:4948:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4949:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4953:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4954:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4959:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4959:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4960:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4960:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4961:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4964:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4965:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:5011:BreakFinderClass.__init__: Undefined variable 'controllerSELECTED_NODE'
E0602:5011:BreakFinderClass.__init__: Undefined variable 'controllerEXT'
E0602:5027:BreakFinderClass.OnFindStart: Undefined variable 'sSet'
E0602:5028:BreakFinderClass.OnFindStart: Undefined variable 'sGet'
E0602:5034:BreakFinderClass.OnFindEnd: Undefined variable 'sSet'
E0602:5053:BreakFinderClass.BreakDef: Undefined variable 'SRC_EXT'
W0611:206: Unused import tkSimpleDialog
W0611:207: Unused import base64
W0611:203: Unused import beep


************* Module leo.plugins.active_path
W0108:122:attachToCommander.<lambda>: Lambda may not be necessary
E1101:397:openDir: Generator 'walk' has no 'next' member


************* Module leo.plugins.attrib_edit
W0311:817: Bad indentation. Found 3 spaces, expected 4
W0311:820: Bad indentation. Found 3 spaces, expected 4
W0311:823: Bad indentation. Found 3 spaces, expected 4
W0311:826: Bad indentation. Found 3 spaces, expected 4
W0311:829: Bad indentation. Found 3 spaces, expected 4
W0511:290: FIXME type_ = {True: '_view', False: '_edit'}[readonly]
W0511:305: FIXME self.attrPaths.add(tuple(ns))
E1101:666:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'recSearch' member
E1101:670:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'typeMap' member
E1101:672:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'typeMap' member
W0611:119: Unused import os
W0611:116: Unused import re


************* Module leo.plugins.backlink
W0511: 21: TODO
E1101:143:backlinkTkUI.updateTkTab: Instance of 'backlinkTkUI' has no 'c' member
E1101:148:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'c' member
E1123:159:backlinkTkUI.updateTkTabInt: Passing unexpected keyword argument 'optional' in function call
E1101:167:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'vnode' member
E1101:168:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'vnodePosition' member
E1101:169:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'c' member
E1123:177:backlinkTkUI.updateTkTabInt: Passing unexpected keyword argument 'optional' in function call
E1101:184:backlinkTkUI.updateTkTabInt.delLink: Instance of 'backlinkTkUI' has no 'deleteLink' member
E1103:647:backlinkController.showMenu: Instance of 'unitTestGui' has no 'killPopupMenu' member (but some types could not be inferred)
E1103:647:backlinkController.showMenu: Instance of 'nullGui' has no 'killPopupMenu' member (but some types could not be inferred)
E1103:709:backlinkController.showMenu: Instance of 'unitTestGui' has no 'postPopupMenu' member (but some types could not be inferred)
E1103:709:backlinkController.showMenu: Instance of 'nullGui' has no 'postPopupMenu' member (but some types could not be inferred)
W0101:785:backlinkController.vnodePosition: Unreachable code
E1101:788:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member
E1101:789:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member
E1101:803:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member


************* Module leo.plugins.cursesGui
W0311: 84: Bad indentation. Found 2 spaces, expected 4
W0311: 85: Bad indentation. Found 4 spaces, expected 8
W0311: 87: Bad indentation. Found 2 spaces, expected 4
W0311: 92: Bad indentation. Found 2 spaces, expected 4
W0311: 93: Bad indentation. Found 4 spaces, expected 8
W0311: 95: Bad indentation. Found 4 spaces, expected 8
W0311: 96: Bad indentation. Found 4 spaces, expected 8
W0311: 99: Bad indentation. Found 2 spaces, expected 4
W0311:103: Bad indentation. Found 6 spaces, expected 8
W0311:105: Bad indentation. Found 2 spaces, expected 4
W0311:106: Bad indentation. Found 4 spaces, expected 8
W0311:107: Bad indentation. Found 4 spaces, expected 8
W0311:108: Bad indentation. Found 4 spaces, expected 8
W0311:110: Bad indentation. Found 2 spaces, expected 4
W0311:111: Bad indentation. Found 4 spaces, expected 8
W0311:114: Bad indentation. Found 2 spaces, expected 4
W0311:115: Bad indentation. Found 4 spaces, expected 8
W0311:117: Bad indentation. Found 2 spaces, expected 4
W0311:118: Bad indentation. Found 4 spaces, expected 8
W0311:120: Bad indentation. Found 2 spaces, expected 4
W0311:122: Bad indentation. Found 6 spaces, expected 8
W0311:124: Bad indentation. Found 6 spaces, expected 8
W0311:126: Bad indentation. Found 2 spaces, expected 4
W0311:127: Bad indentation. Found 4 spaces, expected 8
W0311:129: Bad indentation. Found 2 spaces, expected 4
W0311:130: Bad indentation. Found 4 spaces, expected 8
W0311:132: Bad indentation. Found 2 spaces, expected 4
W0311:133: Bad indentation. Found 4 spaces, expected 8
W0311:135: Bad indentation. Found 4 spaces, expected 8
W0311:137: Bad indentation. Found 4 spaces, expected 8
W0311:138: Bad indentation. Found 4 spaces, expected 8
W0311:140: Bad indentation. Found 4 spaces, expected 8
W0311:142: Bad indentation. Found 4 spaces, expected 8
W0311:143: Bad indentation. Found 6 spaces, expected 12
W0311:144: Bad indentation. Found 4 spaces, expected 8
W0311:146: Bad indentation. Found 2 spaces, expected 4
W0311:147: Bad indentation. Found 4 spaces, expected 8
W0311:149: Bad indentation. Found 2 spaces, expected 4
W0311:150: Bad indentation. Found 4 spaces, expected 8
W0311:152: Bad indentation. Found 2 spaces, expected 4
W0311:153: Bad indentation. Found 4 spaces, expected 8
W0311:155: Bad indentation. Found 4 spaces, expected 8
W0311:156: Bad indentation. Found 4 spaces, expected 8
W0311:158: Bad indentation. Found 4 spaces, expected 8
W0311:161: Bad indentation. Found 6 spaces, expected 12
W0311:162: Bad indentation. Found 8 spaces, expected 16
W0311:163: Bad indentation. Found 6 spaces, expected 12
W0311:164: Bad indentation. Found 6 spaces, expected 12
W0311:167: Bad indentation. Found 6 spaces, expected 12
W0311:169: Bad indentation. Found 6 spaces, expected 12
W0311:170: Bad indentation. Found 8 spaces, expected 16
W0311:171: Bad indentation. Found 6 spaces, expected 12
W0311:172: Bad indentation. Found 10 spaces, expected 16
W0311:174: Bad indentation. Found 2 spaces, expected 4
W0311:176: Bad indentation. Found 4 spaces, expected 8
W0311:177: Bad indentation. Found 6 spaces, expected 12
W0311:178: Bad indentation. Found 4 spaces, expected 8
W0311:179: Bad indentation. Found 6 spaces, expected 12
W0311:180: Bad indentation. Found 4 spaces, expected 8
W0311:181: Bad indentation. Found 6 spaces, expected 12
W0311:182: Bad indentation. Found 4 spaces, expected 8
W0311:183: Bad indentation. Found 6 spaces, expected 12
W0311:184: Bad indentation. Found 8 spaces, expected 16
W0311:185: Bad indentation. Found 6 spaces, expected 12
W0311:186: Bad indentation. Found 6 spaces, expected 12
W0311:187: Bad indentation. Found 8 spaces, expected 16
W0311:188: Bad indentation. Found 6 spaces, expected 12
W0311:189: Bad indentation. Found 8 spaces, expected 16
W0311:190: Bad indentation. Found 6 spaces, expected 12
W0311:191: Bad indentation. Found 8 spaces, expected 16
W0311:192: Bad indentation. Found 4 spaces, expected 8
W0311:193: Bad indentation. Found 6 spaces, expected 12
W0311:194: Bad indentation. Found 4 spaces, expected 8
W0311:195: Bad indentation. Found 6 spaces, expected 12
W0311:197: Bad indentation. Found 2 spaces, expected 4
W0311:198: Bad indentation. Found 4 spaces, expected 8
W0311:199: Bad indentation. Found 6 spaces, expected 12
W0311:200: Bad indentation. Found 4 spaces, expected 8
W0311:206: Bad indentation. Found 2 spaces, expected 4
W0311:208: Bad indentation. Found 4 spaces, expected 8
W0311:210: Bad indentation. Found 4 spaces, expected 8
W0311:213: Bad indentation. Found 2 spaces, expected 4
W0311:215: Bad indentation. Found 4 spaces, expected 8
W0311:217: Bad indentation. Found 4 spaces, expected 8
W0311:218: Bad indentation. Found 4 spaces, expected 8
W0311:219: Bad indentation. Found 4 spaces, expected 8
W0311:221: Bad indentation. Found 4 spaces, expected 8
W0311:222: Bad indentation. Found 4 spaces, expected 8
W0311:223: Bad indentation. Found 4 spaces, expected 8
W0311:236: Bad indentation. Found 2 spaces, expected 4
W0311:237: Bad indentation. Found 2 spaces, expected 4
W0311:239: Bad indentation. Found 2 spaces, expected 4
W0311:240: Bad indentation. Found 6 spaces, expected 8
W0311:242: Bad indentation. Found 2 spaces, expected 4
W0311:243: Bad indentation. Found 4 spaces, expected 8
W0311:245: Bad indentation. Found 4 spaces, expected 8
W0311:246: Bad indentation. Found 4 spaces, expected 8
W0311:247: Bad indentation. Found 4 spaces, expected 8
W0311:248: Bad indentation. Found 4 spaces, expected 8
W0311:250: Bad indentation. Found 4 spaces, expected 8
W0311:251: Bad indentation. Found 6 spaces, expected 12
W0311:253: Bad indentation. Found 4 spaces, expected 8
W0311:254: Bad indentation. Found 4 spaces, expected 8
W0311:257: Bad indentation. Found 4 spaces, expected 8
W0311:260: Bad indentation. Found 4 spaces, expected 8
W0311:262: Bad indentation. Found 2 spaces, expected 4
W0311:264: Bad indentation. Found 2 spaces, expected 4
W0311:265: Bad indentation. Found 4 spaces, expected 8
W0311:267: Bad indentation. Found 2 spaces, expected 4
W0311:268: Bad indentation. Found 4 spaces, expected 8
W0311:270: Bad indentation. Found 2 spaces, expected 4
W0311:271: Bad indentation. Found 4 spaces, expected 8
W0311:273: Bad indentation. Found 4 spaces, expected 8
W0311:274: Bad indentation. Found 4 spaces, expected 8
W0311:276: Bad indentation. Found 4 spaces, expected 8
W0311:277: Bad indentation. Found 4 spaces, expected 8
W0311:279: Bad indentation. Found 4 spaces, expected 8
W0311:280: Bad indentation. Found 8 spaces, expected 12
W0311:281: Bad indentation. Found 12 spaces, expected 16
W0311:282: Bad indentation. Found 12 spaces, expected 16
W0311:283: Bad indentation. Found 12 spaces, expected 16
W0311:284: Bad indentation. Found 12 spaces, expected 16
W0311:285: Bad indentation. Found 12 spaces, expected 16
W0311:291: Bad indentation. Found 4 spaces, expected 8
W0311:292: Bad indentation. Found 4 spaces, expected 8
W0311:293: Bad indentation. Found 4 spaces, expected 8
W0311:295: Bad indentation. Found 4 spaces, expected 8
W0311:296: Bad indentation. Found 4 spaces, expected 8
W0311:298: Bad indentation. Found 2 spaces, expected 4
W0311:299: Bad indentation. Found 2 spaces, expected 4
W0311:305: Bad indentation. Found 2 spaces, expected 4
W0311:306: Bad indentation. Found 4 spaces, expected 8
W0311:308: Bad indentation. Found 4 spaces, expected 8
W0311:310: Bad indentation. Found 4 spaces, expected 8
W0311:311: Bad indentation. Found 4 spaces, expected 8
W0311:314: Bad indentation. Found 2 spaces, expected 4
W0311:317: Bad indentation. Found 4 spaces, expected 8
W0311:321: Bad indentation. Found 2 spaces, expected 4
W0311:322: Bad indentation. Found 2 spaces, expected 4
W0311:324: Bad indentation. Found 2 spaces, expected 4
W0311:326: Bad indentation. Found 4 spaces, expected 8
W0311:327: Bad indentation. Found 4 spaces, expected 8
W0311:328: Bad indentation. Found 4 spaces, expected 8
W0311:329: Bad indentation. Found 4 spaces, expected 8
W0311:333: Bad indentation. Found 2 spaces, expected 4
W0311:338: Bad indentation. Found 2 spaces, expected 4
W0311:339: Bad indentation. Found 4 spaces, expected 8
W0311:340: Bad indentation. Found 4 spaces, expected 8
W0311:341: Bad indentation. Found 4 spaces, expected 8
W0311:343: Bad indentation. Found 2 spaces, expected 4
W0311:344: Bad indentation. Found 4 spaces, expected 8
W0311:345: Bad indentation. Found 4 spaces, expected 8
W0311:346: Bad indentation. Found 6 spaces, expected 12
W0311:347: Bad indentation. Found 4 spaces, expected 8
W0311:353: Bad indentation. Found 2 spaces, expected 4
W0311:354: Bad indentation. Found 4 spaces, expected 8
W0311:355: Bad indentation. Found 4 spaces, expected 8
W0311:356: Bad indentation. Found 4 spaces, expected 8
W0311:357: Bad indentation. Found 4 spaces, expected 8
W0311:359: Bad indentation. Found 2 spaces, expected 4
W0311:360: Bad indentation. Found 4 spaces, expected 8
W0311:366: Bad indentation. Found 2 spaces, expected 4
W0311:367: Bad indentation. Found 4 spaces, expected 8
W0311:374: Bad indentation. Found 2 spaces, expected 4
W0311:377: Bad indentation. Found 6 spaces, expected 8
W0311:378: Bad indentation. Found 6 spaces, expected 8
W0311:381: Bad indentation. Found 6 spaces, expected 8
W0311:383: Bad indentation. Found 2 spaces, expected 4
W0311:385: Bad indentation. Found 4 spaces, expected 8
W0311:387: Bad indentation. Found 4 spaces, expected 8
W0311:389: Bad indentation. Found 4 spaces, expected 8
W0311:391: Bad indentation. Found 2 spaces, expected 4
W0311:393: Bad indentation. Found 4 spaces, expected 8
W0311:398: Bad indentation. Found 4 spaces, expected 8
W0311:399: Bad indentation. Found 4 spaces, expected 8
W0311:400: Bad indentation. Found 4 spaces, expected 8
W0311:402: Bad indentation. Found 2 spaces, expected 4
W0311:406: Bad indentation. Found 4 spaces, expected 8
W0311:407: Bad indentation. Found 8 spaces, expected 12
W0311:408: Bad indentation. Found 4 spaces, expected 8
W0311:412: Bad indentation. Found 2 spaces, expected 4
W0311:417: Bad indentation. Found 4 spaces, expected 8
W0311:421: Bad indentation. Found 4 spaces, expected 8
W0311:422: Bad indentation. Found 6 spaces, expected 12
W0311:424: Bad indentation. Found 4 spaces, expected 8
W0311:425: Bad indentation. Found 4 spaces, expected 8
W0311:426: Bad indentation. Found 4 spaces, expected 8
W0311:427: Bad indentation. Found 4 spaces, expected 8
W0311:430: Bad indentation. Found 4 spaces, expected 8
W0311:431: Bad indentation. Found 4 spaces, expected 8
W0311:433: Bad indentation. Found 2 spaces, expected 4
W0311:434: Bad indentation. Found 4 spaces, expected 8
W0311:436: Bad indentation. Found 2 spaces, expected 4
W0311:438: Bad indentation. Found 4 spaces, expected 8
W0311:440: Bad indentation. Found 2 spaces, expected 4
W0311:441: Bad indentation. Found 4 spaces, expected 8
W0311:443: Bad indentation. Found 4 spaces, expected 8
W0311:444: Bad indentation. Found 6 spaces, expected 12
W0311:446: Bad indentation. Found 6 spaces, expected 12
W0311:447: Bad indentation. Found 8 spaces, expected 16
W0311:448: Bad indentation. Found 6 spaces, expected 12
W0311:450: Bad indentation. Found 6 spaces, expected 12
W0311:451: Bad indentation. Found 6 spaces, expected 12
W0311:452: Bad indentation. Found 6 spaces, expected 12
W0311:454: Bad indentation. Found 6 spaces, expected 12
W0311:455: Bad indentation. Found 8 spaces, expected 16
W0311:456: Bad indentation. Found 6 spaces, expected 12
W0311:458: Bad indentation. Found 8 spaces, expected 16
W0311:459: Bad indentation. Found 8 spaces, expected 16
W0311:460: Bad indentation. Found 10 spaces, expected 20
W0311:461: Bad indentation. Found 14 spaces, expected 24
W0311:462: Bad indentation. Found 8 spaces, expected 16
W0311:464: Bad indentation. Found 6 spaces, expected 12
W0311:465: Bad indentation. Found 8 spaces, expected 16
W0311:466: Bad indentation. Found 6 spaces, expected 12
W0311:467: Bad indentation. Found 8 spaces, expected 16
W0311:469: Bad indentation. Found 6 spaces, expected 12
W0311:470: Bad indentation. Found 6 spaces, expected 12
W0311:471: Bad indentation. Found 8 spaces, expected 16
W0311:472: Bad indentation. Found 8 spaces, expected 16
W0311:473: Bad indentation. Found 6 spaces, expected 12
W0311:474: Bad indentation. Found 8 spaces, expected 16
W0311:475: Bad indentation. Found 6 spaces, expected 12
W0311:476: Bad indentation. Found 8 spaces, expected 16
W0311:483: Bad indentation. Found 2 spaces, expected 4
W0311:484: Bad indentation. Found 4 spaces, expected 8
W0311:486: Bad indentation. Found 2 spaces, expected 4
W0311:487: Bad indentation. Found 4 spaces, expected 8
W0311:489: Bad indentation. Found 2 spaces, expected 4
W0311:490: Bad indentation. Found 4 spaces, expected 8
W0311:493: Bad indentation. Found 2 spaces, expected 4
W0311:494: Bad indentation. Found 2 spaces, expected 4
W0311:496: Bad indentation. Found 2 spaces, expected 4
W0311:504: Bad indentation. Found 2 spaces, expected 4
W0311:505: Bad indentation. Found 4 spaces, expected 8
W0311:507: Bad indentation. Found 2 spaces, expected 4
W0311:508: Bad indentation. Found 4 spaces, expected 8
W0311:510: Bad indentation. Found 2 spaces, expected 4
W0311:511: Bad indentation. Found 4 spaces, expected 8
W0311:512: Bad indentation. Found 6 spaces, expected 12
W0311:514: Bad indentation. Found 2 spaces, expected 4
W0311:515: Bad indentation. Found 4 spaces, expected 8
W0311:517: Bad indentation. Found 2 spaces, expected 4
W0311:518: Bad indentation. Found 4 spaces, expected 8
W0311:519: Bad indentation. Found 6 spaces, expected 12
W0311:522: Bad indentation. Found 2 spaces, expected 4
W0311:524: Bad indentation. Found 4 spaces, expected 8
W0311:526: Bad indentation. Found 4 spaces, expected 8
W0311:528: Bad indentation. Found 2 spaces, expected 4
W0311:531: Bad indentation. Found 4 spaces, expected 8
W0311:532: Bad indentation. Found 4 spaces, expected 8
W0311:534: Bad indentation. Found 4 spaces, expected 8
W0311:538: Bad indentation. Found 4 spaces, expected 8
W0311:541: Bad indentation. Found 2 spaces, expected 4
W0311:542: Bad indentation. Found 4 spaces, expected 8
W0311:544: Bad indentation. Found 2 spaces, expected 4
W0311:545: Bad indentation. Found 4 spaces, expected 8
W0311:547: Bad indentation. Found 2 spaces, expected 4
W0311:550: Bad indentation. Found 4 spaces, expected 8
W0311:551: Bad indentation. Found 4 spaces, expected 8
W0311:553: Bad indentation. Found 2 spaces, expected 4
W0311:555: Bad indentation. Found 4 spaces, expected 8
W0311:557: Bad indentation. Found 6 spaces, expected 12
W0311:558: Bad indentation. Found 8 spaces, expected 16
W0311:559: Bad indentation. Found 6 spaces, expected 12
W0311:560: Bad indentation. Found 8 spaces, expected 16
W0311:562: Bad indentation. Found 6 spaces, expected 12
W0311:568: Bad indentation. Found 6 spaces, expected 12
W0311:570: Bad indentation. Found 6 spaces, expected 12
W0311:571: Bad indentation. Found 8 spaces, expected 16
W0511: 21: TODO >>
W0511: 22: TODO >>
W0511: 43: TODO >>
W0511: 97: TODO leoTkinterFrame finishCreate g.app.windowList.append(f) - use that?
W0511:319: TODO Tkinter onBodyChanged undo call and many others. =(
W0511:529: TODO Much more here: there's four hooks and all sorts of other things called in the TK version. 
W0221:267:textFrame.setTopGeometry: Arguments number differs from overridden method
W0221:391:textLeoMenu.new_menu: Arguments number differs from overridden method
W0221:412:textLeoMenu.add_command: Arguments number differs from overridden method
W0221:436:textLeoMenu.delete_range: Arguments number differs from overridden method
W0221:514:textTree.redraw: Arguments number differs from overridden method
W0221:517:textTree.redraw_now: Arguments number differs from overridden method
W0221:541:textTree.editLabel: Arguments number differs from overridden method


************* Module leo.plugins.dtest
W0611: 30: Unused import leoPlugins


************* Module leo.plugins.leo_interface
W0311: 42: Bad indentation. Found 3 spaces, expected 4
W0311: 43: Bad indentation. Found 6 spaces, expected 8
W0311: 47: Bad indentation. Found 3 spaces, expected 4
W0311: 48: Bad indentation. Found 6 spaces, expected 8
W0311: 59: Bad indentation. Found 3 spaces, expected 4
W0311: 66: Bad indentation. Found 3 spaces, expected 4
W0311: 67: Bad indentation. Found 7 spaces, expected 8
W0311: 70: Bad indentation. Found 3 spaces, expected 4
W0311: 71: Bad indentation. Found 7 spaces, expected 8
W0311: 72: Bad indentation. Found 7 spaces, expected 8
W0311: 75: Bad indentation. Found 3 spaces, expected 4
W0311: 76: Bad indentation. Found 7 spaces, expected 8
W0311: 79: Bad indentation. Found 3 spaces, expected 4
W0311: 80: Bad indentation. Found 7 spaces, expected 8
W0311: 81: Bad indentation. Found 11 spaces, expected 12
W0311: 84: Bad indentation. Found 3 spaces, expected 4
W0311: 85: Bad indentation. Found 7 spaces, expected 8
W0311: 86: Bad indentation. Found 7 spaces, expected 8
W0311: 87: Bad indentation. Found 11 spaces, expected 12
W0311: 88: Bad indentation. Found 7 spaces, expected 8
W0311: 89: Bad indentation. Found 7 spaces, expected 8
W0311: 92: Bad indentation. Found 3 spaces, expected 4
W0311: 93: Bad indentation. Found 7 spaces, expected 8
W0311: 94: Bad indentation. Found 7 spaces, expected 8
W0311: 95: Bad indentation. Found 7 spaces, expected 8
W0311: 96: Bad indentation. Found 7 spaces, expected 8
W0311: 97: Bad indentation. Found 7 spaces, expected 8
W0311: 98: Bad indentation. Found 11 spaces, expected 12
W0311: 99: Bad indentation. Found 7 spaces, expected 8
W0311:100: Bad indentation. Found 7 spaces, expected 8
W0311:101: Bad indentation. Found 11 spaces, expected 12
W0311:102: Bad indentation. Found 7 spaces, expected 8
W0311:103: Bad indentation. Found 7 spaces, expected 8
W0311:104: Bad indentation. Found 7 spaces, expected 8
W0311:105: Bad indentation. Found 11 spaces, expected 12
W0311:108: Bad indentation. Found 3 spaces, expected 4
W0311:109: Bad indentation. Found 7 spaces, expected 8
W0311:110: Bad indentation. Found 7 spaces, expected 8
W0311:111: Bad indentation. Found 7 spaces, expected 8
W0311:112: Bad indentation. Found 7 spaces, expected 8
W0311:113: Bad indentation. Found 7 spaces, expected 8
W0311:114: Bad indentation. Found 11 spaces, expected 12
W0311:115: Bad indentation. Found 7 spaces, expected 8
W0311:120: Bad indentation. Found 3 spaces, expected 4
W0311:121: Bad indentation. Found 5 spaces, expected 8
W0311:130: Bad indentation. Found 3 spaces, expected 4
W0311:135: Bad indentation. Found 3 spaces, expected 4
W0311:136: Bad indentation. Found 6 spaces, expected 8
W0311:140: Bad indentation. Found 3 spaces, expected 4
W0311:141: Bad indentation. Found 6 spaces, expected 8
W0311:145: Bad indentation. Found 3 spaces, expected 4
W0311:146: Bad indentation. Found 7 spaces, expected 8
W0311:149: Bad indentation. Found 3 spaces, expected 4
W0311:150: Bad indentation. Found 7 spaces, expected 8
W0311:151: Bad indentation. Found 7 spaces, expected 8
W0311:154: Bad indentation. Found 3 spaces, expected 4
W0311:155: Bad indentation. Found 7 spaces, expected 8
W0311:156: Bad indentation. Found 7 spaces, expected 8
W0311:157: Bad indentation. Found 7 spaces, expected 8
W0311:158: Bad indentation. Found 7 spaces, expected 8
W0311:161: Bad indentation. Found 3 spaces, expected 4
W0311:162: Bad indentation. Found 7 spaces, expected 8
W0311:165: Bad indentation. Found 7 spaces, expected 8
W0311:170: Bad indentation. Found 7 spaces, expected 8
W0311:171: Bad indentation. Found 7 spaces, expected 8
W0311:172: Bad indentation. Found 7 spaces, expected 8
W0311:173: Bad indentation. Found 10 spaces, expected 12
W0311:174: Bad indentation. Found 10 spaces, expected 12
W0311:175: Bad indentation. Found 7 spaces, expected 8
W0311:176: Bad indentation. Found 7 spaces, expected 8
W0311:179: Bad indentation. Found 3 spaces, expected 4
W0311:180: Bad indentation. Found 7 spaces, expected 8
W0311:181: Bad indentation. Found 11 spaces, expected 12
W0311:184: Bad indentation. Found 3 spaces, expected 4
W0311:185: Bad indentation. Found 6 spaces, expected 8
W0311:186: Bad indentation. Found 9 spaces, expected 12
W0311:187: Bad indentation. Found 9 spaces, expected 12
W0311:188: Bad indentation. Found 9 spaces, expected 12
W0311:189: Bad indentation. Found 6 spaces, expected 8
W0311:190: Bad indentation. Found 9 spaces, expected 12
W0311:194: Bad indentation. Found 3 spaces, expected 4
W0311:195: Bad indentation. Found 7 spaces, expected 8
W0311:202: Bad indentation. Found 3 spaces, expected 4
W0311:203: Bad indentation. Found 7 spaces, expected 8
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:210: Bad indentation. Found 3 spaces, expected 4
W0311:211: Bad indentation. Found 7 spaces, expected 8
W0311:214: Bad indentation. Found 3 spaces, expected 4
W0311:215: Bad indentation. Found 7 spaces, expected 8
W0311:224: Bad indentation. Found 3 spaces, expected 4
W0311:233: Bad indentation. Found 3 spaces, expected 4
W0311:234: Bad indentation. Found 3 spaces, expected 4
W0311:237: Bad indentation. Found 3 spaces, expected 4
W0311:238: Bad indentation. Found 7 spaces, expected 8
W0311:239: Bad indentation. Found 7 spaces, expected 8
W0311:240: Bad indentation. Found 7 spaces, expected 8
W0311:241: Bad indentation. Found 7 spaces, expected 8
W0311:242: Bad indentation. Found 7 spaces, expected 8
W0311:245: Bad indentation. Found 3 spaces, expected 4
W0311:246: Bad indentation. Found 7 spaces, expected 8
W0311:249: Bad indentation. Found 3 spaces, expected 4
W0311:250: Bad indentation. Found 7 spaces, expected 8
W0311:253: Bad indentation. Found 7 spaces, expected 8
W0311:254: Bad indentation. Found 11 spaces, expected 12
W0311:257: Bad indentation. Found 3 spaces, expected 4
W0311:258: Bad indentation. Found 7 spaces, expected 8
W0311:261: Bad indentation. Found 3 spaces, expected 4
W0311:262: Bad indentation. Found 6 spaces, expected 8
W0311:263: Bad indentation. Found 6 spaces, expected 8
W0311:264: Bad indentation. Found 9 spaces, expected 12
W0311:269: Bad indentation. Found 9 spaces, expected 12
W0311:270: Bad indentation. Found 9 spaces, expected 12
W0311:271: Bad indentation. Found 12 spaces, expected 16
W0311:272: Bad indentation. Found 12 spaces, expected 16
W0311:273: Bad indentation. Found 12 spaces, expected 16
W0311:274: Bad indentation. Found 12 spaces, expected 16
W0311:275: Bad indentation. Found 15 spaces, expected 20
W0311:276: Bad indentation. Found 12 spaces, expected 16
W0311:277: Bad indentation. Found 12 spaces, expected 16
W0311:278: Bad indentation. Found 9 spaces, expected 12
W0311:279: Bad indentation. Found 9 spaces, expected 12
W0311:280: Bad indentation. Found 9 spaces, expected 12
W0311:281: Bad indentation. Found 9 spaces, expected 12
W0311:282: Bad indentation. Found 6 spaces, expected 8
W0311:283: Bad indentation. Found 6 spaces, expected 8
W0311:284: Bad indentation. Found 9 spaces, expected 12
W0311:285: Bad indentation. Found 9 spaces, expected 12
W0311:288: Bad indentation. Found 3 spaces, expected 4
W0311:289: Bad indentation. Found 6 spaces, expected 8
W0311:290: Bad indentation. Found 6 spaces, expected 8
W0311:291: Bad indentation. Found 9 spaces, expected 12
W0311:294: Bad indentation. Found 3 spaces, expected 4
W0311:295: Bad indentation. Found 7 spaces, expected 8
W0311:298: Bad indentation. Found 3 spaces, expected 4
W0311:299: Bad indentation. Found 7 spaces, expected 8
W0311:302: Bad indentation. Found 3 spaces, expected 4
W0311:303: Bad indentation. Found 7 spaces, expected 8
W0311:306: Bad indentation. Found 3 spaces, expected 4
W0311:307: Bad indentation. Found 7 spaces, expected 8
W0311:311: Bad indentation. Found 3 spaces, expected 4
W0311:312: Bad indentation. Found 7 spaces, expected 8
W0311:315: Bad indentation. Found 3 spaces, expected 4
W0311:316: Bad indentation. Found 6 spaces, expected 8
W0311:322: Bad indentation. Found 3 spaces, expected 4
W0311:336: Bad indentation. Found 3 spaces, expected 4
W0311:337: Bad indentation. Found 6 spaces, expected 8
W0311:338: Bad indentation. Found 6 spaces, expected 8
W0311:342: Bad indentation. Found 3 spaces, expected 4
W0311:343: Bad indentation. Found 6 spaces, expected 8
W0311:350: Bad indentation. Found 3 spaces, expected 4
W0311:351: Bad indentation. Found 6 spaces, expected 8
W0601:173:leo_file.gen1: Global variable 'vnode_count' undefined at the module level
W0601:186:leo_file.gen_vnodes: Global variable 'allvnodes' undefined at the module level
W0601:186:leo_file.gen_vnodes: Global variable 'vnode_stack' undefined at the module level
W0105:268:leo_node.gen_vnodes: String statement has no effect
W0601:278:leo_node.gen_vnodes: Global variable 'vnode_count' undefined at the module level


************* Module leo.plugins.leo_pdf
E0602:322:Bunch.__setitem__: Undefined variable 'operator'
E0602:326:Bunch.__getitem__: Undefined variable 'operator'
W0105:344:Writer: String statement has no effect
W0105:372:Writer: String statement has no effect


************* Module leo.plugins.leoOPML
E1101:241:opmlFileCommandsClass.putOPMLHeader: Instance of 'opmlFileCommandsClass' has no 'opml_write_leo_globals_attributes' member
E1101:278:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_write_leo_details' member
E1101:294:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_write_body_text' member
E1101:295:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_use_outline_elements' member
E1101:373:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_write_ua_attributes' member
E1101:375:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_expand_ua_dictionary' member
E1101:377:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_skip_ua_dictionary_blanks' member
E1101:485:opmlController.createVnode: Module 'leo.core.leoNodes' has no 'tnode' member
E1101:489:opmlController.createVnode: Instance of 'vnode' has no 't' member
W0221:887:contentHandler.ignorableWhitespace: Arguments number differs from overridden method


************* Module leo.plugins.leoremote
W0611: 45: Unused import sys


************* Module leo.plugins.lineNumbers
E1121: 48:init.putLineNumberDirective: Too many positional arguments for function call


************* Module leo.plugins.macros
This is a real error.
E1103:130:paramClass.parameterize: Instance of 'unitTestGui' has no 'getInsertPoint' member (but some types could not be inferred)
E1103:130:paramClass.parameterize: Instance of 'nullGui' has no 'getInsertPoint' member (but some types could not be inferred)


************* Module leo.plugins.mod_autosave
W0311: 85: Bad indentation. Found 9 spaces, expected 8
W0611: 24: Unused import os


************* Module leo.plugins.mod_leo2ascd
E1120:133:GetAscFilename: No value passed for parameter 'vnode' in function call
E1120:353:WriteTreeOfCurrentNode: No value passed for parameter 'vnode' in function call
E1120:368:WriteAll: No value passed for parameter 'vnode' in function call
E1120:427: No value passed for parameter 'c' in function call


************* Module leo.plugins.mod_speedups
W0611: 30: Unused import leoPlugins
W0611: 52: Unused import leo


************* Module leo.plugins.nav_buttons
W0311:347: Bad indentation. Found 11 spaces, expected 12


************* Module leo.plugins.nodeActions
W0312: 63: Found indentation with tabs instead of spaces
W0312: 64: Found indentation with tabs instead of spaces
W0312: 65: Found indentation with tabs instead of spaces
W0312: 66: Found indentation with tabs instead of spaces
W0312: 67: Found indentation with tabs instead of spaces
W0312: 68: Found indentation with tabs instead of spaces
W0311: 72: Bad indentation. Found 3 spaces, expected 4
W0311: 81: Bad indentation. Found 3 spaces, expected 4
W0311: 83: Bad indentation. Found 3 spaces, expected 4
W0311: 84: Bad indentation. Found 6 spaces, expected 8
W0311: 87: Bad indentation. Found 3 spaces, expected 4
W0311: 88: Bad indentation. Found 3 spaces, expected 4
W0311: 89: Bad indentation. Found 6 spaces, expected 8
W0311: 92: Bad indentation. Found 3 spaces, expected 4
W0311: 93: Bad indentation. Found 3 spaces, expected 4
W0311: 94: Bad indentation. Found 6 spaces, expected 8
W0311: 96: Bad indentation. Found 3 spaces, expected 4
W0311: 98: Bad indentation. Found 6 spaces, expected 8
W0311: 99: Bad indentation. Found 6 spaces, expected 8
W0311:101: Bad indentation. Found 6 spaces, expected 8
W0311:104: Bad indentation. Found 9 spaces, expected 12
W0311:105: Bad indentation. Found 12 spaces, expected 16
W0311:108: Bad indentation. Found 9 spaces, expected 12
W0311:109: Bad indentation. Found 12 spaces, expected 16
W0311:111: Bad indentation. Found 9 spaces, expected 12
W0311:112: Bad indentation. Found 9 spaces, expected 12
W0311:113: Bad indentation. Found 12 spaces, expected 16
W0311:116: Bad indentation. Found 9 spaces, expected 12
W0311:117: Bad indentation. Found 9 spaces, expected 12
W0311:118: Bad indentation. Found 12 spaces, expected 16
W0311:119: Bad indentation. Found 9 spaces, expected 12
W0311:120: Bad indentation. Found 12 spaces, expected 16
W0311:122: Bad indentation. Found 9 spaces, expected 12
W0311:123: Bad indentation. Found 9 spaces, expected 12
W0311:124: Bad indentation. Found 9 spaces, expected 12
W0311:125: Bad indentation. Found 12 spaces, expected 16
W0311:127: Bad indentation. Found 9 spaces, expected 12
W0311:128: Bad indentation. Found 9 spaces, expected 12
W0311:129: Bad indentation. Found 12 spaces, expected 16
W0311:133: Bad indentation. Found 9 spaces, expected 12
W0311:137: Bad indentation. Found 9 spaces, expected 12
W0311:138: Bad indentation. Found 9 spaces, expected 12
W0311:139: Bad indentation. Found 9 spaces, expected 12
W0311:141: Bad indentation. Found 12 spaces, expected 16
W0311:142: Bad indentation. Found 12 spaces, expected 16
W0311:143: Bad indentation. Found 15 spaces, expected 20
W0311:145: Bad indentation. Found 15 spaces, expected 20
W0311:146: Bad indentation. Found 15 spaces, expected 20
W0311:147: Bad indentation. Found 18 spaces, expected 24
W0311:151: Bad indentation. Found 9 spaces, expected 12
W0311:152: Bad indentation. Found 12 spaces, expected 16
W0311:153: Bad indentation. Found 9 spaces, expected 12
W0311:154: Bad indentation. Found 12 spaces, expected 16
W0311:155: Bad indentation. Found 9 spaces, expected 12
W0311:156: Bad indentation. Found 12 spaces, expected 16
W0311:157: Bad indentation. Found 15 spaces, expected 20
W0311:158: Bad indentation. Found 12 spaces, expected 16
W0311:159: Bad indentation. Found 15 spaces, expected 20
W0311:162: Bad indentation. Found 12 spaces, expected 16
W0311:163: Bad indentation. Found 15 spaces, expected 20
W0311:165: Bad indentation. Found 18 spaces, expected 24
W0311:166: Bad indentation. Found 18 spaces, expected 24
W0311:167: Bad indentation. Found 18 spaces, expected 24
W0311:168: Bad indentation. Found 18 spaces, expected 24
W0311:169: Bad indentation. Found 21 spaces, expected 28
W0311:171: Bad indentation. Found 12 spaces, expected 16
W0311:173: Bad indentation. Found 12 spaces, expected 16
W0311:175: Bad indentation. Found 12 spaces, expected 16
W0311:176: Bad indentation. Found 15 spaces, expected 20
W0311:177: Bad indentation. Found 9 spaces, expected 12
W0311:178: Bad indentation. Found 12 spaces, expected 16
W0311:179: Bad indentation. Found 15 spaces, expected 20
W0311:182: Bad indentation. Found 6 spaces, expected 8
W0311:184: Bad indentation. Found 9 spaces, expected 12
W0311:185: Bad indentation. Found 12 spaces, expected 16
W0311:186: Bad indentation. Found 9 spaces, expected 12
W0311:187: Bad indentation. Found 6 spaces, expected 8
W0311:189: Bad indentation. Found 9 spaces, expected 12
W0311:190: Bad indentation. Found 12 spaces, expected 16
W0311:191: Bad indentation. Found 9 spaces, expected 12
W0311:192: Bad indentation. Found 6 spaces, expected 8
W0311:194: Bad indentation. Found 9 spaces, expected 12
W0311:195: Bad indentation. Found 12 spaces, expected 16
W0311:196: Bad indentation. Found 9 spaces, expected 12
W0311:197: Bad indentation. Found 3 spaces, expected 4
W0311:199: Bad indentation. Found 6 spaces, expected 8
W0311:200: Bad indentation. Found 9 spaces, expected 12
W0311:201: Bad indentation. Found 6 spaces, expected 8
W0311:205: Bad indentation. Found 3 spaces, expected 4
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:208: Bad indentation. Found 7 spaces, expected 8
W0311:209: Bad indentation. Found 7 spaces, expected 8
W0311:210: Bad indentation. Found 7 spaces, expected 8
W0311:212: Bad indentation. Found 7 spaces, expected 8
W0311:213: Bad indentation. Found 11 spaces, expected 12
W0311:214: Bad indentation. Found 11 spaces, expected 12
W0311:215: Bad indentation. Found 7 spaces, expected 8
W0311:216: Bad indentation. Found 11 spaces, expected 12
W0311:222: Bad indentation. Found 11 spaces, expected 12
W0311:224: Bad indentation. Found 11 spaces, expected 12
W0311:225: Bad indentation. Found 15 spaces, expected 16
W0311:226: Bad indentation. Found 15 spaces, expected 16
W0311:227: Bad indentation. Found 7 spaces, expected 8
W0311:229: Bad indentation. Found 11 spaces, expected 12
W0311:230: Bad indentation. Found 15 spaces, expected 16
W0311:231: Bad indentation. Found 15 spaces, expected 16
W0311:232: Bad indentation. Found 11 spaces, expected 12
W0311:233: Bad indentation. Found 11 spaces, expected 12
W0311:235: Bad indentation. Found 7 spaces, expected 8


************* Module leo.plugins.nodebar
W0601:183:initImages: Global variable 'clonePI' undefined at the module level
W0601:184:initImages: Global variable 'copyPI' undefined at the module level
W0601:185:initImages: Global variable 'cutPI' undefined at the module level
W0601:186:initImages: Global variable 'dehoistPI' undefined at the module level
W0601:187:initImages: Global variable 'deletePI' undefined at the module level
W0601:188:initImages: Global variable 'demotePI' undefined at the module level
W0601:189:initImages: Global variable 'hoistPI' undefined at the module level
W0601:190:initImages: Global variable 'insertPI' undefined at the module level
W0601:191:initImages: Global variable 'movedownPI' undefined at the module level
W0601:192:initImages: Global variable 'moveleftPI' undefined at the module level
W0601:193:initImages: Global variable 'moverightPI' undefined at the module level
W0601:194:initImages: Global variable 'moveupPI' undefined at the module level
W0601:195:initImages: Global variable 'nodedownPI' undefined at the module level
W0601:196:initImages: Global variable 'nodeleftPI' undefined at the module level
W0601:197:initImages: Global variable 'noderightPI' undefined at the module level
W0601:198:initImages: Global variable 'nodeupPI' undefined at the module level
W0601:199:initImages: Global variable 'pastePI' undefined at the module level
W0601:200:initImages: Global variable 'pasteclonePI' undefined at the module level
W0601:201:initImages: Global variable 'promotePI' undefined at the module level
W0601:202:initImages: Global variable 'questionPI' undefined at the module level
W0601:203:initImages: Global variable 'sortchildrenPI' undefined at the module level
W0601:204:initImages: Global variable 'sortsiblingsPI' undefined at the module level
W0611: 21: Unused import weakref


************* Module leo.plugins.pretty_print
W0233: 52:myPrettyPrinter.__init__: __init__ method from a non direct base class 'myPrettyPrinter' is called
E0602: 62:myPrettyPrinter.putNormalToken: Undefined variable 'token'
E0602:188:myPrettyPrinter.doOp: Undefined variable 'keyword'
E0602:223:myPrettyPrinter.doOp: Undefined variable 'string'
E0602:223:myPrettyPrinter.doOp: Undefined variable 'string'


************* Module leo.plugins.quickMove
W0311:220: Bad indentation. Found 16 spaces, expected 12
W0311:225: Bad indentation. Found 16 spaces, expected 12
E1101:220:quickMove.__init__: Module 'leo.core.leoGlobals' has no 'tree_popup_handlers' member
E1101:225:quickMove.__del__: Module 'leo.core.leoGlobals' has no 'tree_popup_handlers' member
W0611:106: Unused import types


************* Module leo.plugins.quicksearch
W0301:222: Unnecessary semicolon
W0301:240: Unnecessary semicolon
W0604: 73: Using the global statement at the module level
W0611: 42: Unused import QListWidget


************* Module leo.plugins.rClickBasePluginClasses
E1101:134:pluginCommandClass.preDoCommand: Instance of 'pluginCommandClass' has no 'doCommand' member
E1101:260:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandList' member
E1101:267:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandPrefix' member
E1101:272:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandPrefix' member
E1101:310:basePluginController.getCommandList: Instance of 'basePluginController' has no 'commandList' member
E1101:318:basePluginController.setDefaultContextMenus: Instance of 'basePluginController' has no 'defaultContextMenus' member


************* Module leo.plugins.run_nodes
E1120:210:OnQuit: No value passed for parameter 'c' in function call


************* Module leo.plugins.rst3
E1120:263:runUnitTests: No value passed for parameter 'headline' in function call
E1120:1017:rstClass.initOptionsFromSettings: No value passed for parameter 'tag' in function call


************* Module leo.plugins.scrolledmessage
W0311:407: Bad indentation. Found 12 spaces, expected 8
W0311:408: Bad indentation. Found 12 spaces, expected 8
W0311:410: Bad indentation. Found 12 spaces, expected 8
W0311:411: Bad indentation. Found 12 spaces, expected 8
E1101:289:ScrolledMessageDialog.doActionOutlineShow: Instance of 'ScrolledMessageDialog' has no 'name' member
W0107:314:ScrolledMessageDialog.doActionAbout: Unnecessary pass statement
E1101:318:ScrolledMessageDialog.doActionRST3: Instance of 'LeoApp' has no 'pluginsController' member
E1101:532:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'label' member
E1101:533:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'label' member
E1101:539:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'title' member
E0211:543:ScrolledMessageDialog.afterDrawHandler: Method has no argument
E0602:613:ScrolledMessageController.afterRedrawHandler: Undefined variable 'dialogs'
E1120:614:ScrolledMessageController.afterRedrawHandler: No value passed for parameter 'tag' in function call
E1120:614:ScrolledMessageController.afterRedrawHandler: No value passed for parameter 'keywords' in function call
W0611: 91: Unused import inspect


************* Module leo.plugins.todo
E1101: 58:init: Module 'leo.core.leoGlobals' has no 'tree_popup_handlers' member
E0102:260:todoController.addPopupMenu.func: function already defined line 251
E0213:307:todoController.redrawer: Method should have "self" as first argument
E1102:312:todoController.redrawer.new: fn is not callable
E0213:322:todoController.projectChanger: Method should have "self" as first argument
E1102:325:todoController.projectChanger.new: fn is not callable

************* Module leo.plugins.toolbar
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'tkIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'nullIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'tkIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'nullIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1103:1360:ToolbarScriptingController.createScriptButtonIconButton: Instance of 'ToolbarScriptButton' has no 'configure' member (but some types could not be inferred)


************* Module leo.external.ipy_leo
W0601: 30:init_ipython: Global variable 'ip' undefined at the module level
W0107: 90:es: Unnecessary pass statement
W0108:231:LeoNode.<lambda>: Lambda may not be necessary
W1001:398:LeoWorkbook: Use of "property" on an old style class
E1101:438:workbook_complete: Function 'dispatch' has no 'when_type' member
E1101:438:workbook_complete: Function 'complete_object' has no 'when_type' member
E1101:589:edit_macro: Function 'edit_object_in_leo' has no 'when_type' member
W0601:749:lleo_f: Global variable '_request_immediate_connect' undefined at the module level


************* Module leo.external.lproto
E1101:137:LProtoClient.__init__: Module 'socket' has no 'AF_UNIX' member
#@+node:ekr.20100907092144.5901: *3* Unit tests
# These are intended to be temporary tests,
# to be copied eventually to unitTest.leo
#@+node:ekr.20100907115157.5905: *4* @ignore
#@+node:ekr.20100208095423.5940: *5* @test leoCache
import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()
#@+node:ekr.20100906165118.5915: *5* @test leoInkCommands
ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
#@+node:ekr.20101127152442.5917: ** 4.9 b1
#@+node:ekr.20101218101041.8570: *3* Bugs
#@+node:ekr.20101218101041.5922: *4* Fixed bug 682561: pyenchant install problem
#@+node:ekr.20101218101041.5923: *5* Report
@nocolor-node

Traceback (most recent call last):
File "/usr/lib/pymodules/python2.6/leo/core/leoEditCommands.py", line 8574, in __init__
self.d = enchant.DictWithPWL(language,fn)
File "/usr/lib/pymodules/python2.6/enchant/__init__.py", line 708, in __init__
self.pwl = self._broker.request_pwl_dict(pwl)
File "/usr/lib/pymodules/python2.6/enchant/__init__.py", line 276, in request_pwl_dict
self._raise_error(eStr % (pwl,))
File "/usr/lib/pymodules/python2.6/enchant/__init__.py", line 216, in _raise_error
raise eclass(err)
Error: Couldn't open personal wordlist '/usr/share/pyshared/leo/plugins/spellpyx.txt'
not a valid dictionary file /usr/share/pyshared/leo/plugins/spellpyx.txt
#@+node:ekr.20100904095239.5916: *5*  __init__ (EnchantClass)
def __init__ (self,c):

    """Ctor for the EnchantClass class."""

    self.c = c
    language = g.toUnicode(c.config.getString('enchant_language'))

    # Set the base language
    if language and not enchant.dict_exists(language):
        g.es_print('Invalid language code for Enchant',
            repr(language),color='blue')
        g.es('Using "en_US" instead')
        language = 'en_US'

    # Compute fn, the full path to the local dictionary.
    fn = g.os_path_finalize(
        c.config.getString('enchant_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))

    if fn and g.os_path_exists(fn):
        # Merge the local and global dictionaries.
        try:
            self.d = enchant.DictWithPWL(language,fn)
        except Exception:
            g.es_exception()
            g.es_print('not a valid dictionary file',fn,color='red')
            self.d = enchant.Dict(language) 
    else:
        self.d = enchant.Dict(language) 
#@+node:ekr.20101218103123.5936: *4* Investigated bug 689314: @path does not create folder
@nocolor-node

This appears to be invalid.
#@+node:ekr.20101218103123.5937: *5* Report
@nocolor-node

Steps to reproduce it:

0) Make sure that there is no directory named 'test' in your home directory.
1) Create new .leo file with File>New and save it as test.leo
2) Create '@path test' headline.
3) Create '@thin file.txt' headline as a child of the @path headline
4) Save
Log window content for step 4:

created: /home/username/file.txt
saved: test.leo

suppose that file.txt should be found in ~/test/ but it is really in ~.

5) Quit leo and open test.leo again
Log window content:

reading: /home/username/test.leo
can not open: '@file /home/username/test/file.txt'

6) Create directory test/ in your home directory (in file manager)
7) Edit '@thin file.txt' content and save all.
Log window content:

created: /home/ss/test/file.txt
saved: test.leo

I think that in the case of directory absence the @path directive should either
create it or raise an error message but should not create the file silently. I
would prefer the first way.
#@+node:ekr.20080827175609.39: *5* c.scanAllDirectives
def scanAllDirectives(self,p=None):

    '''Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.'''

    trace = False and not g.unitTesting
    c = self ; p = p or c.p

    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body_pane_wraps")

    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')

    d = {
        "delims"        : lang_dict.get('delims'),
        "encoding"      : d.get('encoding'),
        "language"      : lang_dict.get('language'),
        "lineending"    : d.get('lineending'),
        "pagewidth"     : d.get('pagewidth'),
        "path"          : d.get('path'), # Redundant: or g.getBaseDirectory(c),
        "tabwidth"      : d.get('tabwidth'),
        "pluginsList"   : [], # No longer used.
        "wrap"          : d.get('wrap'),
    }

    if trace: g.trace(lang_dict.get('language'),g.callers())

    return d
#@+node:ekr.20080828103146.15: *5* c.scanAtPathDirectives
def scanAtPathDirectives(self,aList):

    '''Scan aList for @path directives.
    Return a reasonable default if no @path directive is found.'''

    trace = False and not g.unitTesting
    verbose = True

    c = self
    c.scanAtPathDirectivesCount += 1 # An important statistic.
    if trace and verbose: g.trace('**entry',g.callers(4))

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose:
        g.trace('base   ',base)
        g.trace('loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        warning = d.get('@path_in_body')
        if trace and path:
            g.trace('**** d',d)
            g.trace('**** @path path',path)
        if path is not None: # retain empty paths for warnings.
            # Convert "path" or <path> to path.
            path = g.stripPathCruft(path)
            if path and not warning:
                paths.append(path)
            # We will silently ignore empty @path directives.

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose:
        g.printList(paths,tag='c.scanAtPathDirectives: raw paths')

    path = c.os_path_finalize_join(*paths)

    if trace and verbose: g.trace('joined path:',path)
    if trace: g.trace('returns',path)

    return path or g.getBaseDirectory(c)
        # 2010/10/22: A useful default.
#@+node:ekr.20080923070954.4: *5* at.scanAllDirectives
def scanAllDirectives(self,p,
    scripting=False,importing=False,
    reading=False,forcePythonSentinels=False,
    createPath=True,
    issuePathWarning=False,
):

    '''Scan p and p's ancestors looking for directives,
    setting corresponding atFile ivars.'''

    trace = False and not g.unitTesting
    at = self ; c = self.c
    g.app.atPathInBodyWarning = None
    << set ivars >>
    lang_dict = {'language':at.language,'delims':delims,}
    table = (
        ('encoding',    at.encoding,    g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    if issuePathWarning and g.app.atPathInBodyWarning:
        g.es('warning: ignoring @path directive in',
            g.app.atPathInBodyWarning,color='red')

    # Post process.
    lang_dict   = d.get('lang-dict')
    delims      = lang_dict.get('delims')
    lineending  = d.get('lineending')

    at.encoding             = d.get('encoding')
    at.explicitLineEnding   = bool(lineending)
    at.language             = lang_dict.get('language')
    at.output_newline       = lineending or g.getOutputNewline(c=c)
    at.page_width           = d.get('pagewidth')
    at.default_directory    = d.get('path')
    at.tab_width            = d.get('tabwidth')

    if not importing and not reading:
        # Don't override comment delims when reading!
        << set comment strings from delims >>

    # For unit testing.
    d = {
        "all"       : all,
        "encoding"  : at.encoding,
        "language"  : at.language,
        "lineending": at.output_newline,
        "pagewidth" : at.page_width,
        "path"      : at.default_directory,
        "tabwidth"  : at.tab_width,
    }
    if trace: g.trace(d)
    return d
#@+node:ekr.20080923070954.14: *6* << Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

# g.trace(c.target_language)

if c.target_language:
    c.target_language = c.target_language.lower()

delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language

at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@+node:ekr.20080923070954.13: *6* << Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1,delim2,delim3 = delims

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    if not g.app.unitTesting:
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:",c.target_language)
        g.es_print('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
    at.startSentinelComment = "#" # This should never happen!
    at.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@+node:ekr.20041005105605.144: *5* at.write & helper
def write (self,root,
    kind = '@unknown', # Should not happen.
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
):
    """Write a 4.x derived file.
    root is the position of an @<file> node"""

    trace = False and not g.unitTesting
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString)

    # "look ahead" computation of eventual fileName.
    eventualFileName = c.os_path_finalize_join(
        at.default_directory,at.targetFileName)
    exists = g.os_path_exists(eventualFileName)

    if trace:
        g.trace('default_dir',
            g.os_path_exists(at.default_directory),
            at.default_directory)
        g.trace('eventual_fn',exists,eventualFileName)

    if not scriptWrite and not toString:
        # 2010/7/28: The read logic now sets the at_read bit for @nosent nodes,
        # so we can just use promptForDangerousWrite.
        if not hasattr(root.v,'at_read') and exists:
            # Prompt if writing a new @file or @thin node would
            # overwrite an existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind)
            if ok:
                root.v.at_read = True # Create the attribute for all clones.
            else:
                g.es("not written:",eventualFileName)
                << set dirty and orphan bits >> # 2010/10/21.
                return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        assert root==at.root,'write'
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            if hasattr(self.root.v,'tnodeList'):
                delattr(self.root.v,'tnodeList')
            root.v._p_changed = True
        else:
            at.closeWriteFile()
            if at.errors > 0 or root.isOrphan():
                << set dirty and orphan bits >>
                g.es("not written:",at.outputFileName)
            else:
                root.v.at_read = True # 2011/05/24.
                at.replaceTargetFileIfDifferent(root)
                    # Sets/clears dirty and orphan bits.

    except Exception:
        if hasattr(self.root.v,'tnodeList'):
            delattr(self.root.v,'tnodeList')
        if toString:
            at.exception("exception preprocessing script")
            root.v._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145: *6* << set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
    if not at.targetFileName:
        # We have an @file node.
        at.targetFileName = root.atFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@+node:ekr.20041005105605.146: *6* << set dirty and orphan bits >>
# Setting the orphan and dirty flags tells Leo to write the tree..
root.setOrphan()
root.setDirty()
# Delete the temp file.
self.remove(at.outputFileName) 

#@+node:ekr.20041005105605.15: *5* at.initWriteIvars
def initWriteIvars(self,root,targetFileName,
    atAuto=False,atEdit=False,atShadow=False,
    nosentinels=False,thinFile=False,
    scriptWrite=False,toString=False,
    forcePythonSentinels=None,
):
    at = self ; c = at.c

    assert root
    self.initCommonIvars()

    at.atAuto = atAuto
    at.atEdit = atEdit
    at.atShadow = atShadow
    # at.default_directory: set by scanAllDirectives()
    at.docKind = None
    if forcePythonSentinels:
        at.endSentinelComment = None
    # else: at.endSentinelComment set by initCommonIvars.
    # at.encoding: set by scanAllDirectives() below.
    # at.explicitLineEnding # True: an @lineending directive specifies the ending.
        # Set by scanAllDirectives() below.
    at.fileChangedFlag = False # True: the file has actually been updated.
    at.force_newlines_in_at_nosent_bodies = c.config.getBool(
        'force_newlines_in_at_nosent_bodies')
    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite
    # at.language:      set by scanAllDirectives() below.
    # at.outputFile:    set below.
    # at.outputNewline: set below.
    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        at.startSentinelComment = "#"
    # else:                 set by initCommonIvars.
    # at.stringOutput:      set below.
    # at.outputFileName:    set below.
    # at.output_newline:    set by scanAllDirectives() below.
    # at.page_width:        set by scanAllDirectives() below.
    at.sentinels = not nosentinels
    at.shortFileName = ""   # For messages.
    at.root = root
    # at.tab_width:         set by scanAllDirectives() below.
    at.targetFileName = targetFileName
        # Must be None for @shadow.
    at.thinFile = thinFile
    at.toString = toString
    at.writeVersion5 = at.new_write and not atShadow

    at.scanAllDirectives(root,
        scripting=scriptWrite,
        forcePythonSentinels=forcePythonSentinels,
        issuePathWarning=True)
    # Sets the following ivars:
        # at.default_directory
        # at.encoding
        # at.explicitLineEnding
        # at.language
        # at.output_newline
        # at.page_width
        # at.tab_width

    if toString:
        at.outputFile = g.fileLikeObject()
        if g.app.unitTesting:
            at.output_newline = '\n'
        # else: at.output_newline set in initCommonIvars.
        at.stringOutput = ""
        at.outputFileName = "<string-file>"
    else:
        at.outputFile = None # The temporary output file.
        # at.outputNewline set in initCommonIvars.
        at.stringOutput = None
        at.outputFileName = g.u('')

    # Init all other ivars even if there is an error.
    if not at.errors and at.root:
        if hasattr(at.root.v,'tnodeList'):
            delattr(at.root.v,'tnodeList')
        at.root.v._p_changed = True
#@+node:ekr.20110117113521.6105: *4* Fixed unit tests
@nocolor-node

Support @nonl in headlines in compareOutlines. This is another test of reformat
paragraph. And this is some.
#@+node:ekr.20110117145531.6151: *4* Don't change user's lines!
#@+node:ekr.20041005105605.161: *5* at.putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    trace = False and not g.unitTesting
    at = self
    at_comment_seen,at_delims_seen,at_warning_given=False,False,False
        # 2011/05/25: warn if a node contains both @comment and @delims.

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.b)

    p.v.setVisited()
    if trace: g.trace('visit',p.h)
        # Make sure v is never expanded again.
        # Suppress orphans check.
    if not at.thinFile:
        p.v.setWriteBit() # Mark the vnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    at.raw = False # 2007/07/04: Bug fix exposed by new sentinels.
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert next_i > i,'putBody'
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()

    if not trailingNewlineFlag:
        if at.writeVersion5:
            if at.sentinels:
                pass # Never write @nonl
            elif at.atAuto and not at.atEdit:
                at.onl() # 2010/08/01: bug fix: ensure newline here.
        else:
            if at.sentinels:
                at.putSentinel("@nonl")
            elif at.atAuto and not at.atEdit:
                # Ensure all @auto nodes end in a newline!
                at.onl()
#@+node:ekr.20041005105605.162: *6* << Make sure all lines end in a newline >>
@ If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if not trailingNewlineFlag:
        if (at.sentinels or 
            (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
        ):
            # g.trace('Added newline',repr(s))
            s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@+node:ekr.20041005105605.163: *6* << handle line at s[i] >> (putBody)
if trace: g.trace(kind,repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif at.raw:
    if kind == at.endRawDirective:
        at.raw = False
        at.putSentinel("@@end_raw")
        i = g.skip_line(s,i)
    else:
        # Fix bug 784920: @raw mode does not ignore directives 
        at.putCodeLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert not at.pending,'putBody at.pending'
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    # Fix bug 784920: @raw mode does not ignore directives 
    at.error('unmatched @end_raw directive: %s' % p.h)
    # at.raw = False
    # at.putSentinel("@@end_raw")
    # i = g.skip_line(s,i)
elif kind == at.startVerbatim:
    # Fix bug 778204: @verbatim not a valid Leo directive.
    if g.unitTesting:
        # A hack: unit tests for @shadow use @verbatim as a kind of directive.
        pass
    else:
        g.trace(at.atShadow)
        at.error('@verbatim is not a Leo directive: %s' % p.h)
    if 0: # Old code.  This is wrong: @verbatim is not a directive!
        at.putSentinel("@verbatim")
        at.putIndent(at.indent)
        i = next_i
        next_i = g.skip_line(s,i)
        at.os(s[i:next_i])
elif kind == at.miscDirective:
    # Fix bug 583878: Leo should warn about @comment/@delims clashes.
    if g.match_word(s,i,'@comment'):
        at_comment_seen = True
    elif g.match_word(s,i,'@delims'):
        at_delims_seen = True
    if at_comment_seen and at_delims_seen and not at_warning_given:
        at_warning_given = True
        at.error('@comment and @delims in node %s' % p.h)
    at.putDirective(s,i)
else:
    at.error('putBody: can not happen: unknown directive kind: %s' % kind)
#@+node:ekr.20041005105605.174: *5* putCodeLine (leoAtFile)
def putCodeLine (self,s,i):

    '''Put a normal code line.'''

    trace = False and not g.unitTesting
    at = self

    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')

    j = g.skip_line(s,i)
    line = s[i:j]

    if trace: g.trace(self.atShadow,repr(line))

    # Don't put any whitespace in otherwise blank lines.
    if len(line) > 1: # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent,line)

        if line[-1:]=='\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    else:
        g.trace('Can not happen: completely empty line')

#@+node:ekr.20101218103123.5938: *4* Fix bug 690260: g.es sends to wrong tabbed pane
#@+node:ekr.20101218103123.5939: *5* Report
@nocolor-node

I start Leo with 3 filenames, they open in tabs.
I execute a g.es() in the leftmost file tab, it writes to the
log pane for the file with it's tab on the right.

update:

Doesn't happen via ctl-b, does happen if the g.es() is in a @button.
Kent Tenney wrote on 2010-12-14: 	#2

upupdate:

doing a ctl-b in the left pane corrects it, after that the @button g.es()
targets the correct pane.
#@+node:ekr.20110120193351.5982: *4* Fixed goto-global-line problems
# The key was not to keep track of skipped lines.
# That is, we use a simpler invariant.
#@+node:ekr.20100216141722.5620: *5* class gotoLineNumber and helpers (commands)
class goToLineNumber:

    '''A class implementing goto-global-line.'''

    @others
#@+node:ekr.20100216141722.5621: *6*  __init__ (gotoLineNumber)
def __init__ (self,c):

    # g.trace('(c.gotoLineNumber)')
    self.c = c
    self.p = c.p.copy()
    self.isAtAuto = False
#@+node:ekr.20100216141722.5622: *6* go
def go (self,n,p=None,scriptData=None):

    '''Place the cursor on the n'th line of a derived file or script.
    When present scriptData is a dict with 'root' and 'lines' keys.'''

    c = self.c
    if n < 0: return

    if scriptData:
        fileName,lines,p,root = self.setup_script(scriptData)
    else:
        if not p: p = c.p
        fileName,lines,n,root = self.setup_file(n,p)

    self.isAtAuto = root and root.isAtAutoNode()
    isRaw = not root or (
        root.isAtEditNode() or root.isAtAsisFileNode() or
        root.isAtAutoNode() or root.isAtNoSentFileNode())
    ignoreSentinels = root and root.isAtNoSentFileNode()
    if not root:
        if scriptData:  root = p.copy()
        else:           root = c.p

    if isRaw:
        p,n2,found = self.countLines(root,n)
        n2 += 1 # Convert to one-based.
    else:
        vnodeName,gnx,n2,delim = self.findVnode(root,lines,n,ignoreSentinels)
        p,found = self.findGnx(delim,root,gnx,vnodeName)

    self.showResults(found,p or root,n,n2,lines)
    return found
#@+node:ekr.20100216141722.5623: *6* countLines & helpers
def countLines (self,root,n):

    '''Scan through root's outline, looking for line n (one based).
    Return (p,i,found)
    p is the found node.
    i is the offset of the line within the node.
    found is True if the line was found.'''

    trace = False and not g.unitTesting
    c = self.c
    
    # if trace and not g.unitTesting and sys.platform.startswith('win'): os.system('cls')

    # Start the recursion.
    n = max(0,n-1)# Convert to zero based internally.
    if trace: g.trace('%s %s (zero-based) %s' % ('*' * 20,n,root.h))
    p,i,junk,found = self.countLinesHelper(root,n,trace)
    return p,i,found # The index is zero-based.
#@+node:ekr.20100216141722.5624: *7* countLinesHelper
def countLinesHelper (self,p,n,trace):

    '''Scan p's body text, looking for line n (zero-based).
    ao is the index of the line containing @others or None.

    Return (p,i,n,effective_lines,found)
    found: True if the line was found.
    if found:
        p:              The found node.
        i:              The offset of the line within the node.
        effective_lines:-1 (not used)
    if not found:
        p:              The original node.
        i:              -1 (not used)
        effective_lines:The number of lines in this node and
                        all descendant nodes.
    '''
    if trace: g.trace('='*10,n,p.h)
    c = self.c ; ao = None
    lines = g.splitLines(p.b)
    i = 0
        # The index of the line being scanning in this node.
    effective_lines = 0
        # The number of "counted" lines including the present line i.
    # Invariant 1: n never changes in this method(!)
    # Invariant 2: n is alway the target line.
    while i < len(lines):
        progress = i
        line = lines[i]
        if trace: g.trace('i %3s effective %3s %s' % (
            i,effective_lines,line.rstrip()))
        if line.strip().startswith('@'):
            if line.strip().startswith('@others'):
                if ao is None and p.hasChildren():
                    ao = i
                    # Count lines in inner nodes.
                    # Pass n-effective_lines as the targe line number.
                    new_n = n-effective_lines
                    p2,i2,effective_lines2,found = \
                        self.countLinesInChildren(new_n,p,trace)
                    if found:
                        return p2,i2,-1,True # effective_lines doesn't matter.
                    else:
                        # Assert that the line has not been found.
                        if effective_lines2 > new_n:
                            if trace: g.trace(
                                '***oops! effective_lines2: %s, new_n: %s' % (
                                effective_lines2,new_n))
                            if g.unitTesting: assert False
                        effective_lines += effective_lines2
                        # Do *not* change i: it will be bumped below.
                        # Invariant: n never changes!
                else:
                    pass # silently ignore erroneous @others.
            else:
                pass # A regular directive: don't change n or i here.
        else:
            # Bug fix 2011/01/21: use effective_lines, not i, in this comparison.
            # The line is now known to be effective.
            if effective_lines == n:
                if trace: g.trace('Found! n: %s i: %s %s' % (n,i,lines[i]))
                return p,i,-1,True # effective_lines doesn't matter.
            else:
                effective_lines += 1
        # This is the one and only place we update i in this loop.
        i += 1
        assert i > progress

    if trace:
        g.trace('Not found. n: %s effective_lines: %s %s' % (
            n,effective_lines,p.h))
    return p,-1,effective_lines,False # i doesn't matter.
#@+node:ekr.20100216141722.5625: *7* countLinesInChildren
def countLinesInChildren(self,n,p,trace):

    if trace: g.trace('-'*10,n,p.h)
    effective_lines = 0
    for child in p.children():
        if trace:g.trace('child %s' % child.h)
        # Recursively scan the children.
        # Pass n-effective_lines as the targe line number for each child.
        new_n = n-effective_lines
        p2,i2,effective_lines2,found = \
            self.countLinesHelper(child,new_n,trace)
        if found:
            if trace: g.trace('Found! i2: %s %s' % (i2,child.h))
            return p2,i2,-1,True # effective_lines doesn't matter.
        else:
            # Assert that the line has not been found.
            if effective_lines2 > new_n:
                if trace: g.trace(
                    '*** oops! effective_lines2: %s, new_n: %s n: %s %s' % (
                        effective_lines2,new_n,n,p.h))
                if g.unitTesting: assert False
            # i2 is not used
            effective_lines += effective_lines2
    
    if trace: g.trace('Not found. effective_lines: %s %s' % (
        effective_lines,p.h))
    return p,-1,effective_lines,False # i does not matter.
#@+node:ekr.20100216141722.5626: *6* findGnx
def findGnx (self,delim,root,gnx,vnodeName):

    '''Scan root's tree for a node with the given gnx and vnodeName.

    return (p,found)'''

    trace = False and not g.unitTesting

    if delim and gnx:
        gnx = g.app.nodeIndices.scanGnx(gnx,0)
        for p in root.self_and_subtree():
            if p.matchHeadline(vnodeName):
                if p.v.fileIndex == gnx:
                    return p.copy(),True

        if trace: g.trace('not found! %s, %s' % (gnx,repr(vnodeName)))
        return None,False
    else:
        return root,False
#@+node:ekr.20100216141722.5627: *6* findRoot
def findRoot (self,p):

    '''Find the closest ancestor @<file> node, except @all nodes.

    return root, fileName.'''

    c = self.c ; p1 = p.copy()

    # First look for ancestor @file node.
    for p in p.self_and_parents():
        fileName = not p.isAtAllNode() and p.anyAtFileNodeName()
        if fileName:
            return p.copy(),fileName

    # Search the entire tree for joined nodes.
    # Bug fix: Leo 4.5.1: *must* search *all* positions.
    for p in c.all_positions():
        if p.v == p1.v and p != p1:
            # Found a joined position.
            for p2 in p.self_and_parents():
                fileName = not p2.isAtAllNode() and p2.anyAtFileNodeName()
                if fileName:
                    return p2.copy(),fileName

    return None,None
#@+node:ekr.20100216141722.5628: *6* findVnode & helpers
def findVnode (self,root,lines,n,ignoreSentinels):

    '''Search the lines of a derived file containing sentinels for a vnode.
    return (vnodeName,gnx,offset,delim):

    vnodeName:  the name found in the previous @+body sentinel.
    gnx:        the gnx of the found node.
    offset:     the offset within the node of the desired line.
    delim:      the comment delim from the @+leo sentinel.
    '''

    trace = False and not g.unitTesting
    c = self.c
    # g.trace('lines...\n',g.listToString(lines))
    gnx = None
    delim,readVersion5,thinFile = self.setDelimFromLines(lines)
    if not delim:
        g.es('no sentinels in:',root.h)
        return None,None,None,None

    nodeLine,offset = self.findNodeSentinel(delim,lines,n)
    if nodeLine == -1:
        if n < len(lines):
            # The line precedes the first @+node sentinel
            g.trace('no @+node!!')
        return root.h,gnx,1,delim

    s = lines[nodeLine]
    gnx,vnodeName = self.getNodeLineInfo(readVersion5,s,thinFile)
    if delim and vnodeName:
        if trace: g.trace('offset: %s, vnodeName: %s' % (offset,vnodeName))
        return vnodeName,gnx,offset,delim
    else:
        g.es("bad @+node sentinel")
        return None,None,None,None
#@+node:ekr.20100216141722.5629: *7* findNodeSentinel & helper
def findNodeSentinel(self,delim,lines,n):

    '''
    Scan backwards from the line n, looking for an @-body line. When found,
    get the vnode's name from that line and set p to the indicated vnode. This
    will fail if vnode names have been changed, and that can't be helped.

    We compute the offset of the requested line **within the found node**.
    '''

    c = self.c
    offset = 0 # This is essentially the Tk line number.
    nodeSentinelLine = -1
    line = n - 1 # Start with the requested line.
    while len(lines) > line >= 0 and nodeSentinelLine == -1:
        progress = line
        s = lines[line]
        i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            line,nodeSentinelLine,offset = self.handleDelim(
                delim,s,i,line,lines,n,offset)
        else:
            line -= 1
        assert nodeSentinelLine > -1 or line < progress
    return nodeSentinelLine,offset
#@+node:ekr.20100216141722.5630: *8* handleDelim
def handleDelim (self,delim,s,i,line,lines,n,offset):

    '''Handle the delim while scanning backward.'''

    trace = False and not g.unitTesting
    c = self.c
    if line == n:
        g.es("line",str(n),"is a sentinel line")
    i += len(delim)
    nodeSentinelLine = -1

    # This code works for both old and new sentinels.
    if g.match(s,i,"-node"):
        # The end of a nested section.
        old_line = line
        line = self.skipToMatchingNodeSentinel(lines,line,delim)
        assert line < old_line
        if trace: g.trace('found',repr(lines[line]))
        nodeSentinelLine = line
        offset = n-line
    elif g.match(s,i,"+node"):
        if trace: g.trace('found',repr(lines[line]))
        nodeSentinelLine = line
        offset = n-line
    elif g.match(s,i,"<<") or g.match(s,i,"@first"):
        line -= 1
    else:
        line -= 1
        nodeSentinelLine = -1
    return line,nodeSentinelLine,offset
#@+node:ekr.20100216141722.5631: *7* getNodeLineInfo & helper
def getNodeLineInfo (self,readVersion5,s,thinFile):

    i = 0 ; gnx = None ; vnodeName = None

    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:   gnx = s[i:j]
            else:       i = len(s) # Force an error.
        else:
            i = len(s) # Force an error.

    # old sentinels: vnode name is everything following the first or second':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
        if readVersion5: # new sentinels: remove level stars.
            vnodeName = self.removeLevelStars(vnodeName)
    else:
        vnodeName = None
        g.es_print("bad @+node sentinel",color='red')

    return gnx,vnodeName
#@+node:ekr.20100728074713.5843: *8* removeLevelStars
def removeLevelStars (self,s):

    i = g.skip_ws(s,0)

    # Remove leading stars.
    while i < len(s) and s[i] == '*':
        i += 1
    # Remove optional level number.
    while i < len(s) and s[i].isdigit():
        i += 1
    # Remove trailing stars.
    while i < len(s) and s[i] == '*':
        i += 1
    # Remove one blank.
    if i < len(s) and s[i] == ' ':
        i += 1

    return s[i:]
#@+node:ekr.20100216141722.5632: *7* setDelimFromLines
def setDelimFromLines (self,lines):

    c = self.c ; at = c.atFileCommands

    # Find the @+leo line.
    i = 0 
    while i < len(lines) and lines[i].find("@+leo")==-1:
        i += 1
    leoLine = i # Index of the line containing the leo sentinel

    # Set delim and thinFile from the @+leo line.
    delim,thinFile = None,False

    if leoLine < len(lines):
        s = lines[leoLine]
        valid,newDerivedFile,start,end,thinFile = at.parseLeoSentinel(s)
        readVersion5 = at.readVersion5

        # New in Leo 4.5.1: only support 4.x files.
        if valid and newDerivedFile:
            delim = start + '@'
    else:
        readVersion5 = False

    return delim,readVersion5,thinFile
#@+node:ekr.20100216141722.5633: *7* skipToMatchingNodeSentinel (no longer used)
def skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
#@+node:ekr.20100216141722.5634: *6* getFileLines (leoEditCommands)
def getFileLines (self,root,fileName):

    '''Read the file into lines.'''

    c = self.c
    isAtEdit = root.isAtEditNode()
    isAtNoSent = root.isAtNoSentFileNode()

    if isAtNoSent or isAtEdit:
        # Write a virtual file containing sentinels.
        at = c.atFileCommands
        kind = g.choose(isAtNoSent,'@nosent','@edit')
        at.write(root,kind=kind,nosentinels=False,toString=True)
        lines = g.splitLines(at.stringOutput)
    else:
        # Calculate the full path.
        path = g.scanAllAtPathDirectives(c,root)
        # g.trace('path',path,'fileName',fileName)
        fileName = c.os_path_finalize_join(path,fileName)
        lines    = self.openFile(fileName)

    return lines
#@+node:ekr.20100216141722.5635: *6* openFile (gotoLineNumber)
def openFile (self,filename):
    """
    Open a file and check if a shadow file exists.
    Construct a line mapping. This ivar is empty if no shadow file exists.
    Otherwise it contains a mapping, shadow file number -> real file number.
    """

    c = self.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        if os.path.exists(shadow_filename):
            fn = shadow_filename
            lines = open(shadow_filename).readlines()
            x.line_mapping = x.push_filter_mapping(
                lines,
                x.markerFromFileLines(lines,shadow_filename))
        else:
            # Just open the original file.  This is not an error!
            fn = filename
            c.line_mapping = []
            lines = open(filename).readlines()
    except Exception:
        # Make sure failures to open a file generate clear messages.
        g.es_print('can not open',fn,color='blue')
        # g.es_exception()
        lines = []

    return lines
#@+node:ekr.20100216141722.5636: *6* setup_file
def setup_file (self,n,p):

    '''Return (lines,n) where:

    lines are the lines to be scanned.
    n is the effective line number (munged for @shadow nodes).
    '''

    c = self.c ; x = c.shadowController

    root,fileName = self.findRoot(p)

    if root and fileName:
        c.shadowController.line_mapping = [] # Set by open.
        lines = self.getFileLines(root,fileName)
            # This will set x.line_mapping for @shadow files.
        if len(x.line_mapping) > n:
            n = x.line_mapping[n]
    else:
        if not g.unitTesting:
            g.es("no ancestor @<file node>: using script line numbers",
                color="blue")
        lines = g.getScript(c,p,useSelectedText=False)
        lines = g.splitLines(lines)

    return fileName,lines,n,root
#@+node:ekr.20100216141722.5637: *6* setup_script
def setup_script (self,scriptData):

    c = self.c

    p = scriptData.get('p')
    root,fileName = self.findRoot(p)
    lines = scriptData.get('lines')

    return fileName,lines,p,root
#@+node:ekr.20100216141722.5638: *6* showResults
def showResults(self,found,p,n,n2,lines):

    trace = False and not g.unitTesting
    c = self.c ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.redraw(p)

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)
    else:
        ins = len(s)
        if len(lines) < n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    if trace:
        i,j = g.getLine(s,ins)
        g.trace('found: %5s %2s %2s %15s %s' % (
            found,n,n2,p.h,repr(s[i:j])))  

    w.setInsertPoint(ins)
    c.bodyWantsFocus()
    w.seeInsertPoint()
#@+node:ekr.20100216141722.5623: *5* countLines & helpers
def countLines (self,root,n):

    '''Scan through root's outline, looking for line n (one based).
    Return (p,i,found)
    p is the found node.
    i is the offset of the line within the node.
    found is True if the line was found.'''

    trace = False and not g.unitTesting
    c = self.c
    
    # if trace and not g.unitTesting and sys.platform.startswith('win'): os.system('cls')

    # Start the recursion.
    n = max(0,n-1)# Convert to zero based internally.
    if trace: g.trace('%s %s (zero-based) %s' % ('*' * 20,n,root.h))
    p,i,junk,found = self.countLinesHelper(root,n,trace)
    return p,i,found # The index is zero-based.
#@+node:ekr.20100216141722.5624: *6* countLinesHelper
def countLinesHelper (self,p,n,trace):

    '''Scan p's body text, looking for line n (zero-based).
    ao is the index of the line containing @others or None.

    Return (p,i,n,effective_lines,found)
    found: True if the line was found.
    if found:
        p:              The found node.
        i:              The offset of the line within the node.
        effective_lines:-1 (not used)
    if not found:
        p:              The original node.
        i:              -1 (not used)
        effective_lines:The number of lines in this node and
                        all descendant nodes.
    '''
    if trace: g.trace('='*10,n,p.h)
    c = self.c ; ao = None
    lines = g.splitLines(p.b)
    i = 0
        # The index of the line being scanning in this node.
    effective_lines = 0
        # The number of "counted" lines including the present line i.
    # Invariant 1: n never changes in this method(!)
    # Invariant 2: n is alway the target line.
    while i < len(lines):
        progress = i
        line = lines[i]
        if trace: g.trace('i %3s effective %3s %s' % (
            i,effective_lines,line.rstrip()))
        if line.strip().startswith('@'):
            if line.strip().startswith('@others'):
                if ao is None and p.hasChildren():
                    ao = i
                    # Count lines in inner nodes.
                    # Pass n-effective_lines as the targe line number.
                    new_n = n-effective_lines
                    p2,i2,effective_lines2,found = \
                        self.countLinesInChildren(new_n,p,trace)
                    if found:
                        return p2,i2,-1,True # effective_lines doesn't matter.
                    else:
                        # Assert that the line has not been found.
                        if effective_lines2 > new_n:
                            if trace: g.trace(
                                '***oops! effective_lines2: %s, new_n: %s' % (
                                effective_lines2,new_n))
                            if g.unitTesting: assert False
                        effective_lines += effective_lines2
                        # Do *not* change i: it will be bumped below.
                        # Invariant: n never changes!
                else:
                    pass # silently ignore erroneous @others.
            else:
                pass # A regular directive: don't change n or i here.
        else:
            # Bug fix 2011/01/21: use effective_lines, not i, in this comparison.
            # The line is now known to be effective.
            if effective_lines == n:
                if trace: g.trace('Found! n: %s i: %s %s' % (n,i,lines[i]))
                return p,i,-1,True # effective_lines doesn't matter.
            else:
                effective_lines += 1
        # This is the one and only place we update i in this loop.
        i += 1
        assert i > progress

    if trace:
        g.trace('Not found. n: %s effective_lines: %s %s' % (
            n,effective_lines,p.h))
    return p,-1,effective_lines,False # i doesn't matter.
#@+node:ekr.20100216141722.5625: *6* countLinesInChildren
def countLinesInChildren(self,n,p,trace):

    if trace: g.trace('-'*10,n,p.h)
    effective_lines = 0
    for child in p.children():
        if trace:g.trace('child %s' % child.h)
        # Recursively scan the children.
        # Pass n-effective_lines as the targe line number for each child.
        new_n = n-effective_lines
        p2,i2,effective_lines2,found = \
            self.countLinesHelper(child,new_n,trace)
        if found:
            if trace: g.trace('Found! i2: %s %s' % (i2,child.h))
            return p2,i2,-1,True # effective_lines doesn't matter.
        else:
            # Assert that the line has not been found.
            if effective_lines2 > new_n:
                if trace: g.trace(
                    '*** oops! effective_lines2: %s, new_n: %s n: %s %s' % (
                        effective_lines2,new_n,n,p.h))
                if g.unitTesting: assert False
            # i2 is not used
            effective_lines += effective_lines2
    
    if trace: g.trace('Not found. effective_lines: %s %s' % (
        effective_lines,p.h))
    return p,-1,effective_lines,False # i does not matter.
#@+node:ekr.20110124055400.12600: *4* Postions of non-tabbed windows are not restored
#@+node:ekr.20060919110638.36: *5* getWindowPositionAttributes
def getWindowPositionAttributes (self,attrs):

    trace = False and not g.unitTesting
    c = self.c

    if trace: g.trace(c.mFileName)

    d = {}

    if g.enableDB and c.mFileName:
        d = c.cacher.getCachedWindowPositionDict(c.mFileName)

    if not d and c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}

    if not d:
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    # if trace: g.trace(d)
    return d
#@+node:ekr.20100208082353.5922: *5* getCachedWindowPositionDict
def getCachedWindowPositionDict (self,fn):

    trace = False and not g.unitTesting
    c = self.c

    if not c:
        g.internalError('no commander')
        return {}

    globals_tag = g.choose(g.isPython3,'leo3k.globals','leo2k.globals')
    key = self.fileKey(fn,globals_tag)
    data = self.db.get('window_position_%s' % (key))

    if data:
        top,left,height,width = data
        top,left,height,width = int(top),int(left),int(height),int(width)
        d = {'top':top,'left':left,'height':height,'width':width}
    else:
        d = {}

    if trace: g.trace(fn,key,data)
    return d
#@+node:ekr.20060919110638.38: *5* startWinPos
def startWinPos (self,attrs):

    self.global_window_position = self.getWindowPositionAttributes(attrs)
#@+node:ekr.20110127085519.15074: *4* Fixed TL's Ctrl+U crash
@nocolor-node

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 1937, in makeMasterGuiBinding
    c.bind(w,bindStroke,masterBindKeyCallback)
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 6123, in bind
    w.bind(pattern,bindCallback,*args,**keys)
  File "c:\python26\lib\lib-tk\Tkinter.py", line 985, in bind
    return self._bind(('bind', self._w), sequence, func, add)
  File "c:\python26\lib\lib-tk\Tkinter.py", line 940, in _bind
    self.tk.call(what + (sequence, cmd))
TclError: bad event type or keysym "Key+U"
#@+node:ekr.20061031131434.103: *5* k.makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    trace = True and not g.unitTesting
    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)

    if stroke.lower().startswith('key'):
        g.trace('stroke',repr(stroke),'bindStroke',repr(bindStroke),g.callers(5))

    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        if 0: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke,event.w)
        return k.masterKeyHandler(event,stroke=stroke)

    if 0:
        if stroke.lower().endswith('+s') or stroke.lower().endswith('-s'):
            g.trace(sroke,widgets)
        if stroke in ('s','S'):
            g.trace(stroke,widgets)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                c.bind(w,bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')

                if g.app.unitTesting: raise
#@+node:ekr.20110127085519.15075: *5* dump k.bindingsDict
aList = list(c.k.bindingsDict.keys())
aList.sort()
for z in aList: print(z)
#@+node:ekr.20061031131434.191: *5* k.prettyPrintKey
def prettyPrintKey (self,stroke,brief=False,trace=False):

    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields',fields)
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    # g.trace('*'*10,s,g.callers())
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    if s.endswith(' '):
        s = s[:-1]+'Space' # 2010/11/06
    # g.trace(stroke,s)
    return g.choose(brief,s,'<%s>' % s)
#@+node:ekr.20061031131434.89: *5* bindKey
def bindKey (self,pane,shortcut,callback,commandName,_hash=None,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    _hash gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %30s %s' % (pane,shortcut,commandName,_hash))
        g.trace(g.callers())
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName,_hash=_hash)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90: *6* << give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@+node:ekr.20061031131434.92: *6* << remove previous conflicting definitions from bunchList >>
# b is the bunch for the new binding.

### This warning should never happen with the new code in makeBindingsFromCommandsDict.

if not modeFlag and self.warn_about_redefined_shortcuts:
    
    redefs = [b2 for b2 in bunchList
        if b2.commandName != commandName and
            # pane != b2.pane and # 2011/02/11: don't give warning for straight substitution.
            pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]

    if redefs:
        def pr(commandName,pane,theHash):
            g.es_print('%30s in %5s from %s' % (commandName,pane,theHash))
    
        g.warning('shortcut conflict for %s' % c.k.prettyPrintKey(shortcut))
        pr(commandName,pane,_hash)
        for z in redefs:
            pr(z.commandName,z.pane,z._hash)

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@+node:ekr.20110222090020.6060: *4* Fixed Python 3.2 ua problems
#@+node:ekr.20060919110638.7: *5* fc.createSaxVnode & helpers
def createSaxVnode (self,sax_node,parent_v,v=None):

    c = self.c
    trace = False and not g.unitTesting and c.shortFileName().find('test') > -1
    verbose = False
    h = sax_node.headString
    b = sax_node.bodyString

    if v:
        # The body of the later node overrides the earlier.
        # Don't set t.h: h is always empty.
        # This may be an internal error.
        if v.b == b:
            if trace and verbose: g.trace(
                '***no update\nold: %s\nnew: %s' % (v.b,b))
        else:
            if trace: g.trace(
                '***update\nold: %s\nnew: %s' % (v.b,b))
            v.b = b 
    else:
        v = leoNodes.vnode(context=c)
        v.setBodyString(b)
        v.setHeadString(h)

        if sax_node.tnx:
            v.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    index = self.canonicalTnodeIndex(sax_node.tnx)
    self.gnxDict [index] = v

    if trace and verbose: g.trace(
        'tnx','%-22s' % (index),'v',id(v),
        'len(body)','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,v)

    return v
#@+node:ekr.20060919110638.8: *6* handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.tnodeAttributes
    if trace and d: g.trace(sax_node,list(d.keys()))

    aDict = {}
    for key in d:
        val = g.toUnicode(d.get(key)) # 2011/02/22
        val2 = self.getSaxUa(key,val)
        # g.trace(key,val,val2)
        aDict[key] = val2

    if aDict:
        if trace: g.trace('uA',v,list(aDict.keys()))
        v.unknownAttributes = aDict
#@+node:ekr.20061004053644: *6* handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnodeUnknownAttributes.
# New in Leo 4.5: added descendentVnodeUnknownAttributes to native attributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.attributes

    s = d.get('a')
    if s:
        if trace and 'E' in s: g.trace('expand',v)
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnodeList will be resolved later.
        if trace: g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentTnodeUaDictList',aDict)
            self.descendentTnodeUaDictList.append(aDict)

    s = d.get('descendentVnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentVnodeUaDictList',aDict)
            self.descendentVnodeUaDictList.append((v,aDict),)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d:
        if key in self.nativeVnodeAttributes:
            # This is not a bug.
            if False and trace: g.trace(
                '****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # if trace: g.trace('uA',v,aDict)
        v.unknownAttributes = aDict
#@+node:EKR.20040627114602: *5* getDescendentUnknownAttributes
# Pre Leo 4.5 Only @thin vnodes had the descendentTnodeUnknownAttributes field.
# New in Leo 4.5: @thin & @shadow vnodes have descendentVnodeUnknownAttributes field.

def getDescendentUnknownAttributes (self,s,v=None):

    '''Unhexlify and unpickle t/v.descendentUnknownAttribute field.'''

    try:
        # Changed in version 3.2: Accept only bytestring or bytearray objects as input.
        s = g.toEncodedString(s) # 2011/02/22
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except:
        g.es_exception()
        g.trace('Can not unpickle',type(s),v and v.h,s[:40])
        return None
#@+node:ekr.20061003093021: *5* getSaxUa
def getSaxUa(self,attr,val,kind=None): # Kind is for unit testing.

    """Parse an unknown attribute in a <v> or <t> element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        # val = str(val)
        val = g.toEncodedString(val) # 2011/02/22.
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_'):
        if type(val) == type(''):
            return val
        elif type(val) == type(b''):
            # 2011/05/26.
            return g.toUnicode(val)

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except Exception:
        # Python 2.x throws TypeError
        # Python 3.x throws binascii.Error
        # Assume that Leo 4.1 wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw','unit test failed: kind=' % repr(kind)
        else:
            g.trace('can not unhexlify %s=%s' % (attr,val))
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError,AttributeError,ValueError):
        g.trace('can not unpickle %s=%s' % (attr,val))
        return val
#@+node:ekr.20110225061928.15452: *4* Fixed bug in p._adjustPostionBeforeUnlink and simplified code
#@+node:ekr.20110225061928.15456: *5*  Changed
#@+node:ekr.20040803140033.2: *6* c.rootPosition
_rootCount = 0

def rootPosition(self):

    """Return the root position.

    Root position is the first position in the document. Other
    top level positions are siblings of this node.
    """

    c = self
    
    # g.trace(self._rootCount) ; self._rootCount += 1

    # 2011/02/25: Compute the position directly.
    if c.hiddenRootNode.children:
        v = c.hiddenRootNode.children[0]
        return leoNodes.position(v,childIndex=0,stack=None)
    else:
        return c.nullPosition()

# For compatibiility with old scripts.
rootVnode = rootPosition
findRootPosition = rootPosition
#@+node:ekr.20040803140033.1: *6* c.setCurrentPosition
_currentCount = 0

def setCurrentPosition (self,p):

    """Set the presently selected position. For internal use only.

    Client code should use c.selectPosition instead."""

    trace = False and not g.unitTesting
    c = self ; cc = c.chapterController

    if trace:
        c._currentCount += 1
        g.trace(c._currentCount,p)
        
    # Always recompute the root position.
    # c.setRootPosition()

    if p and not c.positionExists(p): # 2011/02/25:
        g.warning('Invalid position',p)
        c._currentPosition = c.rootPosition()
        # g.trace('does not exists',p,'\n',g.callers())
        if g.unitTesting: assert False,p
        return

    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p == c._currentPosition:
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@+node:ekr.20040803140033.3: *6* c.setRootPosition (A do-nothing)
def setRootPosition(self,unused_p=None):

    """Set c._rootPosition."""
    
    # 2011/03/03: No longer used.
#@+node:ekr.20080427062528.4: *6* p._adjustPositionBeforeUnlink
def _adjustPositionBeforeUnlink (self,p2):

    '''Adjust position p before unlinking p2.'''

    # p will change if p2 is a previous sibling of p or
    # p2 is a previous sibling of any ancestor of p.

    trace = False and not g.unitTesting
    p = self ; sib = p.copy()

    if trace:
        g.trace('entry')
        g.trace('p ',p)
        g.trace('p2',p2)
        g.trace('p.stack',p.stack)

    # A special case for previous siblings.
    # Adjust p._childIndex, not the stack's childIndex.
    while sib.hasBack():
        sib.moveToBack()
        if sib == p2:
            p._childIndex -= 1
            if trace: g.trace('***new index: %s\n%s' % (
                p.h,p.stack))
            return

    # Adjust p's stack.
    stack = [] ; changed = False ; i = 0
    while i < len(p.stack):
        v,childIndex = p.stack[i]
        p3 = position(v=v,childIndex=childIndex,stack=stack[:i])
        while p3:
            if p2 == p3:
                # 2011/02/25: compare full positions, not just vnodes.
                # A match with the to-be-moved node.
                stack.append((v,childIndex-1),)
                changed = True
                break # terminate only the inner loop.
            p3.moveToBack()
        else:
            stack.append((v,childIndex),)
        i += 1

    if changed:
        if trace: g.trace('***new stack: %s\n%s' % (
            p.h,stack))
        p.stack = stack
#@+node:ekr.20060920203352: *6* p.findRootPosition
def findRootPosition (self):
    
    # 2011/02/25: always use c.rootPosition
    p = self
    c = p.v.context
    return c.rootPosition()
#@+node:ekr.20110225061928.15450: *4* Fixed crash in archivedPositionToPosition

c:\leo.repo\trunk>python3 launchLeo.py --gui=qt leo\test\test.leo --gui=qttabs --no-cache
@nocolor-node


c:\leo.repo\trunk>c:\python32\python.exe launchLeo.py --gui=qt leo\test\test.leo --gui=qttabs --no-cache
*** isPython3: True
scanOptions: disabling caching
Traceback (most recent call last):
  File "launchLeo.py", line 8, in <module>
    leo.core.runLeo.run()
  File "c:\leo.repo\trunk\leo\core\runLeo.py", line 121, in run
    files,options = doPrePluginsInit(fileName,pymacs)
  File "c:\leo.repo\trunk\leo\core\runLeo.py", line 163, in doPrePluginsInit
    g.app.config.readSettingsFiles(fn,verbose)
  File "c:\leo.repo\trunk\leo\core\leoConfig.py", line 1876, in readSettingsFiles
    c = self.openSettingsFile(path)
  File "c:\leo.repo\trunk\leo\core\leoConfig.py", line 1963, in openSettingsFile
    theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 882, in open
    silent=silent)
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 743, in getLeoFile
    self.setPositionsFromVnodes()
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 1400, in setPositionsFromVnodes
    current = self.archivedPositionToPosition(str_pos)
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 1407, in archivedPositionToPosition
    aList = s.split(',')
TypeError: Type str doesn't support the buffer API

c:\leo.repo\trunk>
#@+node:ekr.20061006104837.1: *5* archivedPositionToPosition
def archivedPositionToPosition (self,s):

    c = self.c
    s = g.toUnicode(s) # 2011/02/25
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.h,c)
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.h)
    return p
#@+node:ekr.20110227071546.15477: *4* Fixed top-level uA's
# There was a misspelling of 'unknownAttributes' in putVnode.
#@+node:ekr.20110227071546.15478: *5* Report
@nocolor-node

The uA for the first top level node in the outline is cleared on save
and by some copy paste op.s etc.

Easiest way to observe effect is to do Cmds -> Icons -> Insert-Icon and
make several copies, incl. on positioned at the top of the outline.
Depending on the order of copy paste you may have already seen the icon
disappear, if not Ctrl-S save and it will vanish.  I don't think it's
icon related though, I think uA is being cleared on this node.
#@+node:ekr.20040324080819.1: *5* putLeoFile & helpers
def putLeoFile (self):

    self.updateFixedStatus()
    self.putProlog()
    self.putHeader()
    self.putGlobals()
    self.putPrefs()
    self.putFindSettings()
    #start = g.getTime()
    self.putVnodes()
    #start = g.printDiffTime("vnodes ",start)
    self.putTnodes()
    #start = g.printDiffTime("tnodes ",start)
    self.putPostlog()
#@+node:ekr.20031218072017.3035: *6* putFindSettings
def putFindSettings (self):

    # New in 4.3:  These settings never get written to the .leo file.
    self.put("<find_panel_settings/>")
    self.put_nl()
#@+node:ekr.20031218072017.3037: *6* putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    trace = False and not g.unitTesting
    c = self.c

    use_db = g.enableDB and c.mFileName
    if use_db:
        if trace: g.trace(c.mFileName)
        c.cacher.setCachedGlobalsElement(c.mFileName)

    # Always put positions, to trigger sax methods.
    self.put("<globals")
    << put the body/outline ratios >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20031218072017.3038: *7* << put the body/outline ratios >>
self.put(" body_outline_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.ratio)))

self.put(" body_secondary_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.secondary_ratio)))

if trace: g.trace('fixed or use_db',c.fixed or use_db,
    '%1.2f %1.2f' % (c.frame.ratio,c.frame.secondary_ratio))
#@+node:ekr.20031218072017.3039: *7* << put the position of this frame >>
# New in Leo 4.5: support fixed .leo files.

if c.fixed or use_db:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@+node:ekr.20031218072017.3040: *7* << put the position of the log window >>
top = left = height = width = 0 # no longer used

self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@+node:ekr.20031218072017.3041: *6* putHeader
def putHeader (self):

    tnodes = 0 ; clone_windows = 0 # Always zero in Leo2.

    if 1: # For compatibility with versions before Leo 4.5.
        self.put("<leo_header")
        self.put(" file_format=") ; self.put_in_dquotes("2")
        self.put(" tnodes=") ; self.put_in_dquotes(str(tnodes))
        self.put(" max_tnode_index=") ; self.put_in_dquotes(str(0))
        self.put(" clone_windows=") ; self.put_in_dquotes(str(clone_windows))
        self.put("/>") ; self.put_nl()

    else:
        self.put('<leo_header file_format="2"/>\n')
#@+node:ekr.20031218072017.3042: *6* putPostlog
def putPostlog (self):

    self.put("</leo_file>") ; self.put_nl()
#@+node:ekr.20031218072017.2066: *6* putPrefs
def putPrefs (self):

    # New in 4.3:  These settings never get written to the .leo file.
    self.put("<preferences/>")
    self.put_nl()
#@+node:ekr.20031218072017.1246: *6* putProlog
def putProlog (self):

    c = self.c

    self.putXMLLine()
    
    # Put "created by Leo" line.
    self.put('<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->')
    self.put_nl()

    if c.config.stylesheet or c.frame.stylesheet:
        self.putStyleSheetLine()

    # Put the <leo_file> element.
    # New in Leo 4.9: this element contains a namespace.
    self.put('<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >')
    # self.put("<leo_file>")
    self.put_nl()
#@+node:ekr.20031218072017.1248: *6* putStyleSheetLine
def putStyleSheetLine (self):

    c = self.c

    # The stylesheet in the .leo file takes precedence over the default stylesheet.
    self.put("<?xml-stylesheet ")
    self.put(c.frame.stylesheet or c.config.stylesheet)
    self.put("?>")
    self.put_nl()
#@+node:ekr.20031218072017.1577: *6* putTnode
def putTnode (self,v):

    # Call put just once.
    gnx = g.app.nodeIndices.toString(v.fileIndex)
    ua = hasattr(v,'unknownAttributes') and self.putUnknownAttributes(v) or ''
    b = v.b
    if b:
        body = xml.sax.saxutils.escape(b)
    else:
        body = ''

    self.put('<t tx="%s"%s>%s</t>\n' % (gnx,ua,body))
#@+node:ekr.20031218072017.1575: *6* putTnodes
def putTnodes (self):

    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("<tnodes>\n")
    << write only those tnodes that were referenced >>
    self.put("</tnodes>\n")
#@+node:ekr.20031218072017.1576: *7* << write only those tnodes that were referenced >>
if self.usingClipboard: # write the current tree.
    theIter = c.p.self_and_subtree()
else: # write everything
    theIter = c.all_unique_positions()

# Populate tnodes
tnodes = {}
nodeIndices = g.app.nodeIndices
for p in theIter:
    # Make *sure* the file index has the proper form.
    # g.trace(p.v.fileIndex)
    try:
        theId,t,n = p.v.fileIndex
    except ValueError:
        try:
            theId,t,n = p.v.fileIndex,''
        except Exception:
            raise BadLeoFile('bad p.v.fileIndex: %s' % repr(p.v.fileIndex))

    if n is None:
        n = g.u('0')
    elif g.isPython3:
        n = str(n)
    else:
        n = unicode(n)
    index = theId,t,n
    tnodes[index] = p.v

# Put all tnodes in index order.
for index in sorted(tnodes):
    # g.trace(index)
    v = tnodes.get(index)
    if v:
        # Write only those tnodes whose vnodes were written.
        if v.isWriteBit():
            self.putTnode(v)
    else:
        g.trace('can not happen: no vnode for',repr(index))
        # This prevents the file from being written.
        raise BadLeoFile('no vnode for %s' % repr(index))
#@+node:ekr.20031218072017.1863: *6* putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # 2010/09/02: @edit nodes must not have children.
        # If they do, the entire tree is written to the outline.
    isFile   = p.isAtFileNode()
    isShadow = p.isAtShadowFileNode()
    isThin   = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # 2010/10/22: force writes of orphan @edit, @auto and @shadow trees.
    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = isOrphan  # Force write of orphan @auto trees.
    elif isEdit:   forceWrite = isOrphan  # Force write of orphan @edit trees.
    elif isFile:   forceWrite = isOrphan  # Force write of orphan @file trees.
    elif isShadow: forceWrite = isOrphan  # Force write of @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Force write of  orphan @thin trees.
    else:          forceWrite = True      # Write all other @<file> trees.

    << Set gnx = vnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s>' % (gnx,attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head+'</v>\n')
    else:
        fc.vnodesDict[gnx]=True
        v_head += '<vh>%s</vh>' % (xml.sax.saxutils.escape(p.v.headString()or''))
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            << issue informational messages >>
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent() # Restore p in the caller.
            fc.put('</v>\n')
        else:
            fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864: *7* << Set gnx = vnode index >>
gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
#@+node:ekr.20031218072017.1865: *7* << Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren() and c.putBitsFlag:
        attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = v.u
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    v.u = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@+node:ekr.20040324082713: *7* << Append unKnownAttributes to attrs>>
# v.unknownAttributes are now put in <t> elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
#@+node:ekr.20040702085529: *7* << issue informational messages >> (changed)
if 0: # It's strange to clear the orphan bit.
    if isOrphan and (isFile or isThin):
        g.es("writing erroneous:",p.h,color="blue")
        p.clearOrphan()
#@+node:ekr.20031218072017.1579: *6* putVnodes
def putVnodes (self):

    """Puts all <v> elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("<vnodes>\n")

    # Make only one copy for all calls.
    self.currentPosition = c.p 
    self.rootPosition    = c.rootPosition()
    # self.topPosition     = c.topPosition()
    self.vnodesDict = {}

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings():
            # New in Leo 4.4.2 b2 An optimization:
            self.putVnode(p,isIgnore=p.isAtIgnoreNode()) # Write the next top-level node.

    self.put("</vnodes>\n")
#@+node:ekr.20031218072017.1247: *6* putXMLLine
def putXMLLine (self):

    '''Put the **properly encoded** <?xml> element.'''

    # Use self.leo_file_encoding encoding.
    self.put('%s"%s"%s\n' % (
        g.app.prolog_prefix_string,
        self.leo_file_encoding,
        g.app.prolog_postfix_string))
#@+node:ekr.20031218072017.1863: *5* putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # 2010/09/02: @edit nodes must not have children.
        # If they do, the entire tree is written to the outline.
    isFile   = p.isAtFileNode()
    isShadow = p.isAtShadowFileNode()
    isThin   = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # 2010/10/22: force writes of orphan @edit, @auto and @shadow trees.
    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = isOrphan  # Force write of orphan @auto trees.
    elif isEdit:   forceWrite = isOrphan  # Force write of orphan @edit trees.
    elif isFile:   forceWrite = isOrphan  # Force write of orphan @file trees.
    elif isShadow: forceWrite = isOrphan  # Force write of @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Force write of  orphan @thin trees.
    else:          forceWrite = True      # Write all other @<file> trees.

    << Set gnx = vnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s>' % (gnx,attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head+'</v>\n')
    else:
        fc.vnodesDict[gnx]=True
        v_head += '<vh>%s</vh>' % (xml.sax.saxutils.escape(p.v.headString()or''))
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            << issue informational messages >>
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent() # Restore p in the caller.
            fc.put('</v>\n')
        else:
            fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864: *6* << Set gnx = vnode index >>
gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
#@+node:ekr.20031218072017.1865: *6* << Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren() and c.putBitsFlag:
        attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = v.u
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    v.u = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@+node:ekr.20040324082713: *6* << Append unKnownAttributes to attrs>>
# v.unknownAttributes are now put in <t> elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
#@+node:ekr.20040702085529: *6* << issue informational messages >> (changed)
if 0: # It's strange to clear the orphan bit.
    if isOrphan and (isFile or isThin):
        g.es("writing erroneous:",p.h,color="blue")
        p.clearOrphan()
#@+node:ekr.20110228083015.14114: *4* fixed bug in g.printGcAll
@nocolor-node

ERROR: runTest (leo.core.leoTest.generalTestCase)
@test g.printGcAll

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoTest.py", line 177, in runTest
    exec(script,d)
  File "<string>", line 3, in <module>
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 2798, in printGcAll
    d[t] = d.get(t,0) + 1
TypeError: unhashable type: 'ProxyType'
#@+node:ekr.20110228083015.14113: *4* mod_autosave plugin does not register redundant idle-time handlers
@nocolor-node

while I was experimenting with registering handler for "idle" events,
I have noticed
that there were about 40 registered handlers for "idle" event. What
was most interesting is the fact that those handlers were all about
the same function onIdle in mod_autosave plugin. At first I thought
that handler is registering itself over and over, but when I looked in
the source I couldn't find anything suspicious.

So I made small script to print number of registered handlers and
manually executed it from time to time to see when it increases.

g.es(len(g.app.pluginsController.getHandlersForOneTag("idle")))

Finally, I realized that every time when I invoke unit test command Alt
+5, number of registered handlers increased.

From the above it is obvious that I have enabled plugin mod_autosave.
From the Log
Leo Log Window
Leo 4.8 final, build 3752, November 26, 2010
Python 2.6.6, qt version 4.7.0
linux2

#@+node:ekr.20110227200312.15373: *4* Fixed bug 568452 re local @settings
@nocolor-node

file local @settings ignored if file opened from command line with absolute path

Report:
    
Given

  LEOPATH=/home/tbrown/Desktop/Package/leo/bzr/leo.repo/trunk
  HOME=/tmp python $LEOPATH/launchLeo.py foo/bar.leo

@settings in bar.leo are honored., but with

  HOME=/tmp python $LEOPATH/launchLeo.py /home/tbrown/Desktop/leotest/foo/bar.leo

(i.e. absolute path to same file), they're ignored.

(LEOPATH has nothing to do with anything here, just trying to make the example more clear)
#@+node:ekr.20041120064303: *5* readSettingsFiles & helpers (g.app.config)
def readSettingsFiles (self,fileName,verbose=True):

    '''Read settings from one file of the standard settings files.'''

    trace = False and not g.unitTesting
    verbose = verbose
    giveMessage = (verbose and not g.app.unitTesting and
        not self.silent and not g.app.batchMode)
    def message(s):
        # This occurs early in startup, so use the following.
        if not g.isPython3:
            s = g.toEncodedString(s,'ascii')
        g.es_print(s,color='blue')
    self.write_recent_files_as_needed = False # Will be set later.
    localConfigFile = self.getLocalConfigFile(fileName)
    if trace: g.trace(fileName,localConfigFile)
    table = self.defineSettingsTable(fileName,localConfigFile)
    for path,localFlag in table:
        assert path and g.os_path_exists(path)
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or path.endswith('.leo')
        if isLeo:
            c = self.openSettingsFile(path)
            if c:
                if giveMessage:
                    message('reading settings in %s' % path)
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool(
                    'write_recent_files_as_needed')
            else:
                if giveMessage:
                    message('error reading settings in %s' % path)

    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20101021041958.6008: *6* getLocalConfigFile
# This can't be done in initSettingsFiles because
# the local directory does not yet exist.

def getLocalConfigFile (self,fileName):

    if not fileName:
        return None

    theDir = g.os_path_dirname(fileName)
    path = g.os_path_join(theDir,'leoSettings.leo')

    if g.os_path_exists(path):
        return path
    else:
        return None
#@+node:ekr.20101021041958.6004: *6* defineSettingsTable
def defineSettingsTable (self,fileName,localConfigFile):

    trace = False and not g.unitTesting
    verbose = False

    global_table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        # (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        # (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
    )

    if fileName:
        if fileName.lower().endswith('leosettings.leo'):
            # 2011/02/28: don't read leoSettings.leo or myLeoSetings.leo twice.
            # This allows myLeoSettings.leo to take precedence.
            table1 = []
        else:
            path = g.os_path_finalize(fileName)
            theDir = g.os_path_dirname(fileName)
            myLocalConfigFile = g.os_path_join(theDir,'myLeoSettings.leo')
            local_table = (
                (localConfigFile,False),
                (myLocalConfigFile,False),
            )
            if trace and verbose:
                g.trace('localConfigFile:  ',localConfigFile)
                g.trace('myLocalConfigFile:',myLocalConfigFile)
    
            table1 = [z for z in local_table if z not in global_table]
            table1.append((path,True),)
    else:
        table1 = global_table

    seen = [] ; table = []
    for path,localFlag in table1:
        if trace and verbose: g.trace('exists',g.os_path_exists(path),path)
        if path and g.os_path_exists(path):
            # Make sure we mark files seen no matter how they are specified.
            path = g.os_path_realpath(g.os_path_finalize(path))
            if path.lower() not in seen:
                seen.append(path.lower())
                table.append((path,localFlag),)
    if trace: g.trace(repr(fileName),'table:',g.listToString(table))
    return table
#@+node:ekr.20041117085625: *6* openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@+node:ekr.20051013161232: *6* updateSettings
def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
#@+node:ekr.20101125041212.5846: *4* Fixed bug: ignore f-keys in find/replace patterns
#@+node:ekr.20060125093807: *5* searchWithPresentOptions
def searchWithPresentOptions (self,event):

    trace = False and not g.unitTesting
    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if trace: g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        self.setupSearchPattern(k.arg) # 2010/01/10: update the find text immediately.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@+node:ekr.20060210173041: *5* stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler,escapes=None):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)

    # g.trace(escapes,g.callers())
    if escapes is None: escapes = []
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
#@+node:ekr.20061031131434.128: *5* getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    if trace: g.trace(
        'state',state,'keysym',repr(keysym),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129: *6* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@+node:ekr.20110401084027.14476: *4* Inserting non-ascii characters
#@+node:ekr.20061031131434.108: *5* callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@+node:ekr.20061031131434.182: *5* isPlainKey
def isPlainKey (self,shortcut):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''

    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True

    for s in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(s) != -1:            
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut in ('Tab','\t')
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
#@+node:ekr.20051125080855: *5* selfInsertCommand, helpers
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    trace = False and not g.unitTesting # or c.config.getBool('trace_masterCommand')
    verbose = True
    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    if trace: g.trace('ch',repr(ch),'keysym',repr(keysym)) # ,'stroke',repr(stroke))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if trace and verbose:
        g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@+node:ekr.20061103114242: *6* << set local vars >>
c = self.c
p = c.p
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
# stroke = gui.eventStroke(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)
#@+node:ekr.20090213065933.14: *6* doPlainTab
def doPlainTab(self,s,i,tab_width,w):

    '''Insert spaces equivalent to one tab.'''

    start,end = g.getLine(s,i)
    s2 = s[start:i]
    width = g.computeWidth(s2,tab_width)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20060627091557: *6* flashCharacter
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
#@+node:ekr.20060627083506: *6* flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@+node:ekr.20060804095512: *6* initBracketMatcher
def initBracketMatcher (self,c):

    if len(self.openBracketsList) != len(self.closeBracketsList):

        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@+node:ekr.20051026171121: *6* insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    i,j = oldSel ; ch = '\n'
    if trace:
        s = w.widget.toPlainText()
        g.trace(i,j,len(s),w)

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        if (c.autoindent_in_nocolor or 
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@+node:ekr.20051026171121.1: *6* updateAutoIndent (leoEditCommands)
def updateAutoIndent (self,p,w):

    c = self.c ; d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@+node:ekr.20051027172949: *6* updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = c.scanAllDirectives(p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
#@+node:ekr.20051026092433: *6* updateTab
def updateTab (self,p,w,smartTab=True):

    c = self.c

    # g.trace('tab_width',tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        # w.delete(i,j)
        c.indentBody()
    else:
        d = c.scanAllDirectives(p)
        tab_width = d.get("tabwidth",c.tab_width)
        # Get the preceeding characters.
        s = w.getAllText()
        # start = g.skip_to_start_of_line(s,i)
        start,end = g.getLine(s,i)
        before = s[start:i]
        after = s[i:end]
        if after.endswith('\n'): after = after[:-1]
        ws = g.get_leading_ws(before)
        s2 = s[start:i] # The characters before the insert point.

        # Only do smart tab at the start of a blank line.
        doSmartTab = (smartTab and c.smart_tab and i == start)
            # Truly at the start of the line.
            # and not after # Nothing *at all* after the cursor.
        # g.trace(doSmartTab,'i %s start %s after %s' % (i,start,repr(after)))

        if doSmartTab:
            self.updateAutoIndent(p,w)
            # Add a tab if otherwise nothing would happen.
            if s == w.getAllText():
                self.doPlainTab(s,i,tab_width,w)
        else:
            self.doPlainTab(s,i,tab_width,w)
#@+node:ekr.20080510095819.1: *5* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)

    if trace and verbose: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return 'break'

    elif k.isFKey(stroke):
        if trace: g.trace('ignoring F-key',stroke)
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',stroke,keysym)
        return 'break'

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        if trace: g.trace('ignoring unbound non-ascii key',repr(stroke))
        return 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return 'break'

    else:
        if trace: g.trace('no func',stroke)
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@+node:ekr.20061031131434.110: *5* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    elif name.startswith('log'):
        if g.app.gui.guiName() == 'tkinter':
            return None
        else:
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event.stroke # 2010/05/04.
            if stroke.lower() == 'return': stroke = '\n'
            elif stroke.lower() == 'tab': stroke = '\t'
            elif stroke.lower() == 'backspace': stroke = '\b'
            elif stroke.lower() == 'period': stroke = '.'
            w.logCtrl.insert(i,stroke)

            return None
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(stroke))
        return None
#@+node:ekr.20061031131434.105: *5* masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            # if commandName == 'select-all': g.pdb()
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@+node:ekr.20061031131434.106: *6* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@+node:ekr.20061031131434.107: *6* << add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@+node:ekr.20061031131434.109: *6* callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
#@+node:ekr.20061031131434.110: *6* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    elif name.startswith('log'):
        if g.app.gui.guiName() == 'tkinter':
            return None
        else:
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event.stroke # 2010/05/04.
            if stroke.lower() == 'return': stroke = '\n'
            elif stroke.lower() == 'tab': stroke = '\t'
            elif stroke.lower() == 'backspace': stroke = '\b'
            elif stroke.lower() == 'period': stroke = '.'
            w.logCtrl.insert(i,stroke)

            return None
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(stroke))
        return None
#@+node:ekr.20061031131434.146: *5* masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'keysym:',
        repr(event.keysym),'ch:',repr(event.char),'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
            
    # if stroke == 'Tab': g.pdb()

    if k.inState():
        if trace: g.trace('   state %-10s %s' % (stroke,state))
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')
            
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            return k.handleUnboundKeys(event,char,keysym,stroke)

    # 2011/02/08: Use getPandBindings for *all* keys.
    b = k.getPaneBinding(stroke,w)
    if b:
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke)
        return k.masterCommand(event,b.func,b.stroke,b.commandName)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147: *6* << define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
stroke = event.stroke ### 2010/10/18
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@+node:ekr.20061031131434.108: *6* callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@+node:ekr.20091230094319.6244: *6* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode(event)
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
#@+node:ekr.20091230094319.6240: *6* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and b.commandName in table:
                        if trace: g.trace('***** special case',b.commandName)
                        pass
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(b.stroke),b.commandName))
                        return b
#@+node:ekr.20061031131434.152: *6* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape',):
            return False
        if k.isFKey(stroke): # 2010/10/23.
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event) ### ,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@+node:ekr.20110209083917.16004: *6* isAutoCompleteChar
def isAutoCompleteChar (self,stroke):
    
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction
    
    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                b = d.get(stroke)
                if b and b.commandName == 'auto-complete':
                    return True
    return False
#@+node:ekr.20080510095819.1: *6* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)

    if trace and verbose: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return 'break'

    elif k.isFKey(stroke):
        if trace: g.trace('ignoring F-key',stroke)
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',stroke,keysym)
        return 'break'

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        if trace: g.trace('ignoring unbound non-ascii key',repr(stroke))
        return 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return 'break'

    else:
        if trace: g.trace('no func',stroke)
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@+node:ekr.20110401123306.14504: *4* Fixed bugs in moveLinesUp/Down
def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    insert_pt = w.getInsertPoint() # 2011/04/01
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]

    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i
    # g.trace('moveLinesDown:',repr('%s[[%s|%s|%s]]%s' % (
    #    s[i-20:i], s[i:sel_1], s[sel_1:sel_2], s[sel_2:j], s[j:j+20])))

    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            next_i,next_j = g.getLine(s,j) # 2011/04/01: was j+1
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            if next_line.endswith('\n'):
                # Simply swap positions with next line
                new_lines = next_line+lines
            else:
                # Last line of the body to be moved up doesn't end in a newline
                # while we have to remove the newline from the line above moving down.
                new_lines = next_line+'\n'+lines[:-1]
                n2 += 1
            w.insert(i,new_lines)
            w.setSelectionRange(sel_1+n2,sel_2+n2,insert=insert_pt+n2)
            changed = True
    finally:
       self.endCommand(changed=changed,setLabel=True)

#@verbatim
#@+node:ekr.20060417183606.1: *4* moveLinesUp

def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    insert_pt = w.getInsertPoint() # 2011/04/01     
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    n = i2-i
    # g.trace('moveLinesUp:',repr('%s[[%s|%s|%s]]%s' % (
    #    s[max(0,i-20):i], s[i:sel_1], s[sel_1:sel_2], s[sel_2:j], s[j:j+20])))

    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i>0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            n2 = prev_j - prev_i
            w.delete(prev_i,j)
            if lines.endswith('\n'):
                # Simply swap positions with next line
                new_lines = lines+prev_line
            else:
                # Lines to be moved up don't end in a newline while the
                # previous line going down needs its newline taken off.
                new_lines = lines+'\n'+prev_line[:-1]
            w.insert(prev_i,new_lines)
            w.setSelectionRange(sel_1-n2,sel_2-n2,insert=insert_pt-n2)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20110401123306.14505: *5* Old code
def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    insert_pt = w.getInsertPoint() # 2011/04/01
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            # next_i,next_j = g.getLine(s,j+1)
            next_i,next_j = g.getLine(s,j) # 2011/04/01
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.p
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.redraw(p)

            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
        
def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    insert_pt = w.getInsertPoint() 
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i > 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.p
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()

            c.redraw(p)

            s = w.getAllText()
            if not s.endswith('\n'):
                i = w.getInsertPoint()
                w.insert(i,'\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)

#@+node:ekr.20060417183606: *5* moveLinesDown
def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    insert_pt = w.getInsertPoint() # 2011/04/01
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]

    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i
    # g.trace('moveLinesDown:',repr('%s[[%s|%s|%s]]%s' % (
    #    s[i-20:i], s[i:sel_1], s[sel_1:sel_2], s[sel_2:j], s[j:j+20])))
    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            next_i,next_j = g.getLine(s,j) # 2011/04/01: was j+1
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            if next_line.endswith('\n'):
                # Simply swap positions with next line
                new_lines = next_line+lines
            else:
                # Last line of the body to be moved up doesn't end in a newline
                # while we have to remove the newline from the line above moving down.
                new_lines = next_line+'\n'+lines[:-1]
                n2 += 1
            w.insert(i,new_lines)
            w.setSelectionRange(sel_1+n2,sel_2+n2,insert=insert_pt+n2)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20060417183606.1: *5* moveLinesUp
def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    insert_pt = w.getInsertPoint() # 2011/04/01     
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    n = i2-i
    # g.trace('moveLinesUp:',repr('%s[[%s|%s|%s]]%s' % (
    #    s[max(0,i-20):i], s[i:sel_1], s[sel_1:sel_2], s[sel_2:j], s[j:j+20])))
    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i>0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            n2 = prev_j - prev_i
            w.delete(prev_i,j)
            if lines.endswith('\n'):
                # Simply swap positions with next line
                new_lines = lines+prev_line
            else:
                # Lines to be moved up don't end in a newline while the
                # previous line going down needs its newline taken off.
                new_lines = lines+'\n'+prev_line[:-1]
            w.insert(prev_i,new_lines)
            w.setSelectionRange(sel_1-n2,sel_2-n2,insert=insert_pt-n2)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20110401133905.14482: *4* c.bringToFront now activates the window
#@+node:ekr.20080514131122.20: *5* c.outerUpdate
def outerUpdate (self):

    trace = False and not g.unitTesting
    verbose = True ; traceFocus = True
    c = self ; aList = []
    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    c.requestRedrawFlag = False
    
    if trace and (verbose or aList):
        g.trace('**start') # ,g.callers(2))
    
    if c.requestBringToFront:
        if hasattr(c.frame,'bringToFront'):
            c.frame.bringToFront()
        c.requestBringToFront = False

    # The iconify requests are made only by c.bringToFront.
    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        if trace: g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw')
        c.frame.tree.redraw_now(forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        # This should be the only call to c.recolor_now.
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if traceFocus: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We must not set the focus to the body pane here!
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and (verbose or aList):
        g.trace('** end',aList)

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''

    # g.trace('after')
#@+node:ekr.20080514131122.8: *5* c.bringToFront
def bringToFront(self,set_focus=True):

    c = self
    c.requestBringToFront = True
    c.requestedIconify = 'deiconify'
    c.requestedFocusWidget = c.frame.body.bodyCtrl

BringToFront = bringToFront # Compatibility with old scripts
#@+node:ekr.20110402084740.14489: *4* Fixed nav_qt plutin
#@+node:ekr.20110402084740.14490: *5* Icon bar
def goToNextHistory (self,event=None):
    
    c = self
    p = c.nodeHistory.goNext()
        # Returns None if the position does not exist.
    if not p: return
    c.nodeHistory.skipBeadUpdate = True
    try:
        c.selectPosition(p)
    finally:
        c.nodeHistory.skipBeadUpdate = False
    
def goToPrevHistory (self,event=None):
    
    c = self
    p = c.nodeHistory.goPrev()
        # Returns None if the position does not exist.
    if not p: return
    c.nodeHistory.skipBeadUpdate = True
    try:
        c.selectPosition(p)
    finally:
        c.nodeHistory.skipBeadUpdate = False
#@+node:ekr.20050920084036.188: *5* leoCommands.getPublicCommands
def getPublicCommands (self):

    '''(leoCommands) Return a dict of the 'legacy' Leo commands.'''

    k = self.k ; d2 = {}

    << define dictionary d of names and Leo commands >>

    # Create a callback for each item in d.
    for name in sorted(d):
        f = d.get(name)
        d2 [name] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))

    return d2
#@+node:ekr.20050920084036.189: *6* << define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'beautify':                     c.beautifyPythonCode,
    'beautify-all':                 c.beautifyAllPythonCode,
    'beautify-tree':                c.beautifyPythonTree,
    'cascade-windows':              f.cascade,
    # 'check-all-python-code':      c.checkAllPythonCode,
    'check-derived-file':           c.atFileCommands.checkDerivedFile,
    'check-leo-file':               c.fileCommands.checkLeoFile,
    'check-outline':                c.checkOutline,
    # 'check-python-code':          c.checkPythonCode,
    'clean-recent-files':           c.cleanRecentFiles,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'close-window':                 c.close,
    'contract-all':                 c.contractAllHeadlines,
    'contract-all-other-nodes':     c.contractAllOtherNodes,
    'contract-node':                c.contractNode,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-all-subheads':          c.expandAllSubheads,
        # Fixes bug 604037 Status of expandAllSubheads
    'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-python-method':        c.extractPythonMethod,
    'extract-section':              c.extractSection,
    'find-next-clone':              c.findNextClone,
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-first-visible-node':      c.goToFirstVisibleNode,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible-node':       c.goToLastVisibleNode,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-history-node':       c.goToNextHistory,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-history-node':       c.goToPrevHistory,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hide-invisibles':              c.hideInvisibles,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-body-time':             c.insertBodyTime,
    'insert-child':                 c.insertChild,
    'insert-headline-time':         f.insertHeadlineTime,
    'insert-node':                  c.insertHeadline,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    # 'mark-changed-roots':           c.markChangedRoots,
    # 'mark-clones':                c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-brackets':               c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-myLeoSettings-leo':       c.openMyLeoSettings,
    'open-offline-tutorial':        f.leoHelp,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-quickstart-leo':          c.leoQuickStart,
    'open-scripts-leo':             c.openLeoScripts,
    'open-users-guide':             c.leoUsersGuide,
    'open-with':                    c.openWith,
    'outline-to-cweb':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-auto-nodes':           c.readAtAutoNodes,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-at-shadow-nodes':         c.readAtShadowNodes,
    'read-file-into-node':          c.readFileIntoNode,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-all':                     c.saveAll,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-as-unzipped':        c.saveAsUnzipped,
    'save-file-as-zipped':          c.saveAsZipped,
    'save-file-to':                 c.saveTo,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'settings':                     c.preferences,
    'show-invisibles':              c.showInvisibles,
    'sort-children':                c.sortChildren,
    'sort-recent-files':            c.sortRecentFiles,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-invisibles':            c.toggleShowInvisibles,
    'toggle-sparse-move':           c.toggleSparseMove,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-auto-nodes':          c.atFileCommands.writeAtAutoNodes,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-at-shadow-nodes':        c.fileCommands.writeAtShadowNodes,
    'write-dirty-at-auto-nodes':    c.atFileCommands.writeDirtyAtAutoNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-dirty-at-shadow-nodes':  c.fileCommands.writeDirtyAtShadowNodes,
    'write-file-from-node':         c.writeFileFromNode,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}
#@+node:ekr.20070423101911: *5* selectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace:
        if old_p:
            g.trace('old: %s %s new: %s %s' % (
                len(old_p.b),old_p.h,len(p.b),p.h))
        else:
            g.trace('old: <none> new: %s %s' % (len(p.b),p.h))

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.p here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        # 2010/08/01: (qt only) update history when body text gets focus.
        # This is done in qtGui.py: onFocusIn.
        # 2011/04/02: Undo the change in rev 3194:
        # I have absolutely no idea what I was thinking about.
        if True: # g.app.gui.guiName() != 'qt':
            c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    if trace: g.trace('**** after old: %s new %s' % (
        old_p and len(old_p.b),len(p.b)))

    # what UNL.py used to do
    c.frame.clearStatusLine()
    c.frame.putStatusLine("-->".join(reversed(
        [i.h for i in p.self_and_parents()])))

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129: *6* << unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p != p: # 2010/02/11: Don't change the *new* node's insert point!
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
#@+node:ekr.20040803072955.130: *6* << select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@+node:ekr.20040803072955.133: *6* << set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

c.treeFocusHelper() # 2010/12/14
c.undoer.onSelect(old_p,p)
#@+node:ekr.20070615131604: *5* class nodeHistory
class nodeHistory:

    '''A class encapsulating knowledge of visited nodes.'''

    @others
#@+node:ekr.20070615131604.1: *6*  ctor (nodeHistory)
def __init__ (self,c):

    self.c = c
    self.beadList = []
        # list of (position,chapter) tuples for
        # nav_buttons and nodenavigator plugins.
    self.beadPointer = -1
    self.skipBeadUpdate = False
    self.trace = False
#@+node:ekr.20070615131604.3: *6* canGoToNext/Prev
def canGoToNextVisited (self):

    if self.trace:
        g.trace(
            self.beadPointer + 1 < len(self.beadList),
            self.beadPointer,len(self.beadList))

    return self.beadPointer + 1 < len(self.beadList)

def canGoToPrevVisited (self):

    if self.trace:
        g.trace(self.beadPointer > 0,
            self.beadPointer,len(self.beadList))

    return self.beadPointer > 0
#@+node:ekr.20070615132939: *6* clear
def clear (self):

    self.beadList = []
    self.beadPointer = -1
#@+node:ekr.20070615134813: *6* goNext/Prev
def goNext (self):

    '''Return the next visited node, or None.'''
    
    trace = (False or self.trace) and not g.unitTesting

    c = self.c
    while self.beadPointer + 1 < len(self.beadList):
        self.beadPointer += 1
        p,chapter = self.beadList[self.beadPointer]
        if c.positionExists(p):
            if trace: g.trace(p and p.h)
            break
        else:
            if trace: g.trace('does not exist',p and p.h)
    else:
        return None

    self.selectChapter(chapter)
    return p

def goPrev (self):

    '''Return the previous visited node, or None.'''

    trace = (False or self.trace) and not g.unitTesting
    c = self.c
    while self.beadPointer > 0:
        self.beadPointer -= 1
        p,chapter = self.beadList[self.beadPointer]
        if c.positionExists(p):
            if trace: g.trace(p and p.h)
            break
        else:
            if trace: g.trace('does not exist',p and p.h)
    else:
        return None

    self.selectChapter(chapter)
    return p
#@+node:ekr.20070615132939.1: *6* remove
def remove (self,p):

    '''Remove an item from the nav_buttons list.'''

    c = self.c
    target = self.beadPointer > -1 and self.beadList[self.beadPointer]

    self.beadList = [z for z in self.beadList
                        if z[0] != p and c.positionExists(z[0])]

    try:
        self.beadPointer = self.beadList.index(target)
    except ValueError:
        self.beadPointer = max(0,self.beadPointer-1)

    if self.trace:
        g.trace('bead list',p.h)
        g.pr([z[0].h for z in self.beadList])
#@+node:ekr.20070615140032: *6* selectChapter
def selectChapter (self,chapter):

    c = self.c ; cc = c.chapterController

    if cc and chapter and chapter != cc.getSelectedChapter():
        cc.selectChapterByName(chapter.name)
#@+node:ville.20090724234020.14676: *6* update
def update (self,p):
    
    trace = (False or self.trace) and not g.unitTesting
    
    c = self.c
    if self.skipBeadUpdate:
        return

    p = p.copy()
    if self.beadList and self.beadList[-1][0] == p:
        # do not re-append the same node
        return
        
    if trace: g.trace(p and p.h)

    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    data = (p,theChapter)

    if 0: # This makes no sense.
        if self.beadPointer < len(self.beadList) - 1:
            # if we came to new node, truncate bead list
            self.beadList = self.beadList[0:self.beadPointer]
            if True or trace: g.trace('truncating')

    self.beadList.append(data)
    self.beadPointer = len(self.beadList) - 1

    if trace:    
        # g.trace('bead list',p.h)
        g.trace([z[0].h for z in self.beadList])
#@+node:ekr.20070615140655: *6* visitedPositions
def visitedPositions (self):

    return [p.copy() for p,chapter in self.beadList]
#@+node:ekr.20110509064011.14562: *4* Fixed completer focus problem
#@+node:ekr.20110510070638.14644: *5*  What I did
@nocolor-node

- Created c.idle_focus_helper.

- Always call g.enableIdleTimeHook in runLeo.py:doPostPluginsInit.
    (That is, removed @bool allow_idle_time_hook setting.)

- Added c.in_qt_dialog flag: used only by c.idle_focus_helper.

- Improved tracing in c.outerUpdate.

- Improved tracing in various focus methods.
#@+node:ekr.20080514131122.9: *5* c.get/request/set_focus
def get_focus (self):

    c = self
    return g.app.gui and g.app.gui.get_focus(c)

def get_requested_focus (self):

    c = self
    return c.requestedFocusWidget

def request_focus(self,w):

    trace = False and not g.unitTesting
    c = self
    if trace: g.trace(g.app.gui.widget_name(w),w,g.callers())
    if w: c.requestedFocusWidget = w

def set_focus (self,w,force=False):

    trace = False and not g.unitTesting
    c = self
    if w and g.app.gui:
        if trace: print('c.set_focus:',g.app.gui.widget_name(w),w,g.callers())
            # w,c.shortFileName())
        g.app.gui.set_focus(c,w)
    else:
        if trace: print('c.set_focus: no w')

    c.requestedFocusWidget = None
#@+node:ekr.20110509064011.14563: *5* c.idle_focus_helper
idle_focus_count = 0

def idle_focus_helper (self,tag,keys):
    
    '''An idle-tme handler that ensures that focus is *somewhere*.'''
    
    trace = False and not g.unitTesting ; verbose = False
    
    c = self
    assert tag == 'idle'

    if g.app.unitTesting or keys.get('c') != c:
        return
        
    self.idle_focus_count += 1
        
    if c.in_qt_dialog:
        if trace and verbose: g.trace('in_qt_dialog')
        return
        
    if c.idle_callback:
        if trace: g.trace('calling c.idle_callback',c.idle_callback.__name__)
        c.idle_callback()
        c.idle_callback = None
        return

    w = g.app.gui.get_focus()

    if w:
        if trace and verbose:
            g.trace(self.idle_focus_count,w)
    else:
        if trace: g.trace('%s no focus -> body' % (self.idle_focus_count))
        c.bodyWantsFocusNow()
#@+node:ekr.20080514131122.20: *5* c.outerUpdate
def outerUpdate (self):

    trace = False and not g.unitTesting
    verbose = True ; traceFocus = True
    c = self ; aList = []
    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    c.requestRedrawFlag = False
    
    if trace and (verbose or aList):
        g.trace('**start') # ,g.callers(2))
    
    if c.requestBringToFront:
        if hasattr(c.frame,'bringToFront'):
            c.frame.bringToFront()
        c.requestBringToFront = False

    # The iconify requests are made only by c.bringToFront.
    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        if trace: g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw')
        c.frame.tree.redraw_now(forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        # This should be the only call to c.recolor_now.
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if traceFocus: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We must not set the focus to the body pane here!
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and (verbose or aList):
        g.trace('** end',aList)

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''

    # g.trace('after')
#@+node:ekr.20110517093705.14577: *4* Fixed bug 783617: Can't enter text directly in the Find panel
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/

After experimentation I have chosen simply to disable the Find/Change text areas
so that they are merely status indicators. Unlike the check boxes, which *are*
functional, it is basically pointless to type text into these areas. In the
absence of buttons that would execute various find/change commands, the user
must *still* do Ctrl-F.

BTW, the Tk Text boxes *are* functional, in the sense that they do update the
default find/change strings when the user types text into them. However, to make
this work, any in-progress minibuffer command must be aborted, so once again
typing into these boxes is pointless.

In other words, the Tk code should work like the Qt code. I'm not going to do
this because the Tk code is on its way out.

Happily, Leo's core remained unchanged. This is important because the Qt code is
horribly complex. After Tk is gone, significant simplifications can be made. But
I'm not going to do that now...
#@+node:ekr.20110517093705.14578: *4* Fixed bug 681797: Shift-Delete not working in Qt
@nocolor-node


https://bugs.launchpad.net/leo-editor/+bug/681797

Without bindings, typing these characters inserts strange character. The
solution was to add default bindings for these keys in leoSettings.leo.
#@+node:ekr.20110517102011.14578: *4* Fixed qcompleter bug
@nocolor-node

What I did:
    
- Define k.autoCompleteForceKey in k.initSpecialIvars.
- Test for k.autoCompleteForceKey (auto-complete-force) in auto_completer_state_handler.
- auto_completer_state_handler ignores all other non-plain keys.
- ac.calltip now selects the calltip.
- Corrected a but in ac.exit that disabled restoration of selections.
#@+node:ekr.20110517102011.14580: *5*   report
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/dad31c2f22f02206/ea70954e4c53aae1#ea70954e4c53aae1

I've tried combo from the screenshot, iow: c.frame.to and then
pressing ctrl-space. Pop-up dialog is shown and I can select one
entry, let's say 'top'.

However, let's assume, I did select wrong one, so I delete 'p' leaving
me with the same 'c.frame.to', wanting to select another option, then
ctrl-space gives following exception:

exception executing command
Traceback (most recent call last):
  File "/usr/home/gour/repos/bzr/leo-editor/leo/core/leoCommands.py", line 404, in doCommand
    val = command(event)
  File "/usr/home/gour/repos/bzr/leo-editor/leo/core/leoKeys.py", line 175, in autoCompleteForce
    return self.autoComplete(event,force=True)
  File "/usr/home/gour/repos/bzr/leo-editor/leo/core/leoKeys.py", line 165, in autoComplete
    self.start(event)
  File "/usr/home/gour/repos/bzr/leo-editor/leo/core/leoKeys.py", line 988, in start
    self.init_qcompleter(event)
  File "/usr/home/gour/repos/bzr/leo-editor/leo/core/leoKeys.py", line 836, in init_qcompleter
    self.qcompleter = w.init_completer(options)
  File "/usr/home/gour/repos/bzr/leo-editor/leo/plugins/qtGui.py", line 321, in init_completer
    assert not hasattr(self,'leo_qc')
AssertionError 
#@+node:ekr.20110517102011.14581: *5*  keyHandler methods...
#@+node:ekr.20061031131434.79: *6* << define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

# Keys whose bindings are computed by initSpecialIvars.
self.abortAllModesKey = None
self.autoCompleteForceKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
#@+node:ekr.20061031131434.101: *6* initSpecialIvars
def initSpecialIvars (self):

    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn  = c.config.getBool('warn_about_missing_settings')

    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey','auto-complete-force'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
#@+node:ekr.20061031131434.130: *6* keyboardQuit
def keyboardQuit (self,event,setFocus=True):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    if trace: g.trace(g.callers())

    if g.app.quitting:
        return

    # if not inAutoCompleter:
        # k.autoCompleter.exit()
    
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    if setFocus:
        c.endEditing()
        c.bodyWantsFocus()

    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    k.showStateAndMode()
#@+node:ekr.20061031131434.11: *5* auto_completer_state_handler
def auto_completer_state_handler (self,event):

    trace = False and not g.app.unitTesting
    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    ch = gui.eventChar(event)
    keysym = gui.eventKeysym(event)
    stroke = gui.eventStroke(event)
    is_plain = k.isPlainKey(stroke)

    if trace: g.trace('state: %s, ch: %s, keysym: %s, stroke: %s' % (
        state,repr(ch),repr(keysym),repr(stroke)))

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix,prefix,tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag,1,handler=self.auto_completer_state_handler)
        else:
            if trace: g.trace('abort: not tabList')
            self.exit()
    elif keysym == 'Return':
        self.exit()
    elif keysym == 'Escape':
        self.exit()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym in ('\b','BackSpace'):
        self.do_backspace()
    elif keysym == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = g.choose(self.verbose,'ON','OFF')
        c.frame.putStatusLine('verbose completions %s' % (
            kind),color='red')
        self.compute_completion_list()
    elif ch == 'Down' and hasattr(self,'onDown'):
        self.onDown()
    elif ch == 'Up' and hasattr(self,'onUp'):
        self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(ch,keysym)
    else:
        if stroke == k.autoCompleteForceKey:
            # This is probably redundant because completions will exist.
            # However, it doesn't hurt, and it may be useful rarely.
            if trace: g.trace('auto-complete-force',repr(stroke))
            common_prefix,prefix,tabList = self.compute_completion_list()
            if tabList:
                self.show_completion_list(common_prefix,prefix,tabList)
            else:
                g.es('No completions',color='blue')
                self.exit()
            return
        else:
            if trace: g.trace('ignore non plain key',repr(stroke))
            return 'do-standard-keys'
#@+node:ekr.20061031131434.20: *5* calltip & helpers
def calltip (self):
    
    '''Show the calltips for the present prefix.
    ch is '(' if the user has just typed it.
    '''

    trace = False and not g.unitTesting

    c = self.c
    obj,prefix = self.get_object()
    
    if obj:
        self.calltip_success(prefix,obj)
    else:
        self.calltip_fail(prefix)
        
    self.exit()
#@+node:ekr.20110512090917.14468: *6* calltip_fail
def calltip_fail(self,prefix):
    
    '''Evaluation of prefix failed.'''
    
   
    if not g.unitTesting:
        g.es('eval failed for "%s"' % repr(prefix))

    self.insert_string('(')
#@+node:ekr.20110512090917.14469: *6* calltip_success
def calltip_success(self,prefix,obj):
    
    trace = False and not g.unitTesting
    
    try:
        # Get the parenthesized argument list.
        s1,s2,s3,s4 = inspect.getargspec(obj)
        s = inspect.formatargspec(s1,s2,s3,s4)
        if trace: g.trace(obj,repr(s))
    except Exception:
        if trace: g.trace('inspect failed. obj: %s' % (obj))
        self.insert_string('(')
        return

    # Clean s and insert it: don't include the opening "(".
    if g.match(s,1,'self,'):
        s = s[6:].strip()
    elif g.match_word(s,1,'self'):
        s = s[5:].strip()
    else:
        s = s[1:].strip()

    self.insert_string("(",select=False)
    self.insert_string(s,select=True)
#@+node:ekr.20110512212836.14469: *5* exit
def exit (self):

    trace = False and not g.unitTesting
    if trace: g.trace(g.callers())

    c = self.c
    w = self.w or c.frame.body.bodyCtrl
    
    if trace: g.trace(g.callers())
    
    c.k.keyboardQuit(event=None)
        ### ,inAutoCompleter=True)
        # Suppress call to ac.exit inside keyboardQuit.
    
    if self.use_qcompleter:
        self.qw.end_completer()
    else:
        for name in (self.tabName,'Modules','Info'):
            c.frame.log.deleteTab(name)
        
    # Restore the selection range that may have been destroyed by changing tabs.
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    w.setSelectionRange(i,j,insert=j)
    
    # Was in finish.
    c.frame.body.onBodyChanged('Typing')
    c.recolor()

finish = exit
abort = exit
#@+node:ekr.20061031131434.31: *5* insert_string
def insert_string (self,s,select=False):

    '''Insert s at the insertion point.'''

    c = self.c ; w = self.w
    
    c.widgetWantsFocusNow(w)
    i = w.getInsertPoint()
    w.insert(i,s)
    if select:
        j = i + len(s)
        w.setSelectionRange(i,j,insert=j)
   
    c.frame.body.onBodyChanged('Typing')
    
    if self.use_qcompleter:
        # g.trace(self.qw.leo_qc)
        c.widgetWantsFocusNow(self.qw.leo_qc)
#@+node:ekr.20101024062147.6024: *4* Fixed bug 622819: Ctrl-Shift movement is incorrect
@nocolor-node

Ctrl-Shift movement (back-word-extend-selection, forward-word-extend-selection)
is incorrect when there is an existing selection, which was created by some
method other than Ctrl-Shift movement.

Expected behavior: it should extend/contract the existing selection

Actual behavior: it creates a new selection from the cursor position

The fix was new code in extendHelper.
#@+node:ekr.20060113130510: *5* extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; p = c.p
    extend = extend or self.extendMode

    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if trace: g.trace(
        'extend',extend,'ins',ins,'sel=',i,j,
        'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v != self.moveSpotNode:
        if trace: g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        # 2011/05/20: Fix bug 622819
        # Ctrl-Shift movement is incorrect when there is an unexpected selection.
        if i == j:
            if trace: g.trace('extend and no sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
        elif self.moveSpot in (i,j) and self.moveSpot != ins:
            if trace and verbose: g.trace('extend and movespot matches')
            pass # The bug fix, part 1.
        else:
            # The bug fix, part 2.
            # Set the moveCol to the *not* insert point.
            if ins == i: k = j
            elif ins == j: k = i
            else: k = ins
            if trace: g.trace('extend and unexpected spot',k)
            self.setMoveCol(w,k) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: # was j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@+node:ekr.20110520051220.18191: *4* Disabled the rst button bug
@nocolor-node

rst 3 button in contextmenu throws an error
https://bugs.launchpad.net/leo-editor/+bug/751976

I was not able to fix this button.  Instead, I merely disabled it.
http://groups.google.com/group/leo-editor/browse_thread/thread/8e67595ef156dba0
#@+node:ekr.20110521142955.18163: *4* Resolved bug 323967: leo overrides minibuffer background color
@nocolor-node

> Setting background-color on QLineEdit#lineEdit in the Qt stylesheet works, the
selected color is initially visible, but leo overrides the color during init.
The color should be set in the style sheet instead.

Technically, this bug is invalid. However, I'll add comments to data
qt-gui-plugin-style-sheet explaining what is going on.

Because Leo changes the color of the minibuffer dynamically, stylesheets can not
be used. Instead, set the desired colors using one of the following settings,
with defaults as shown:

    @color minibuffer-background-color = lightblue
    @color minibuffer-error-color = red
    @color minibuffer-warning-color = lightgrey
#@+node:ekr.20110521142955.18151: *4* Fixed actionscript colors for parens
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/ee09fb2c2a5316f2/490fa7cddab36fab

These are now colored with the "operator" setting, for example:
    
    @color operator_color = red
#@+node:ekr.20110522121957.18235: *4* Fixed horizontal scroll glitch in log pane (Python 2.x)
Example: e2.bat.  A workaround is in qtLog.put.
#@+node:ekr.20110522203356.18250: *4* Fixed Bug 760531:Spurious overwrite warnings
@nocolor-node

High-priority bug

https://bugs.launchpad.net/leo-editor/+bug/760531

Ville:
    
I get this error way too often compared to the amount of cases when
it's actually useful (I think Leo uses wrong logic here, but didn't
check): 

=====

Matt Wilkie

I don't know if it's related, but I get warning about overwriting an
existing file when I create a new @file node and the file does not
already exist (leo is creating the file):

1. insert node, edit headline to "@file deleteme.py"
2. [ctrl]-[s]
3. add some text to "@file deleteme.py" body pane
4. [ctrl]-[s], message pops up:

---------------------------
Overwrite existing file?
#@+node:ekr.20041005105605.21: *5* at.read & helpers
def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    trace = False and not g.unitTesting
    if trace: g.trace(root.h)
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    # Fix bug 760531: always mark the root as read, even if there was an error.
    root.v.at_read = True
    # Bug fix 2011/05/23: Restore orphan trees from the outline.
    if root.isOrphan():
        g.es("reading:",root.h)
        g.warning('The outline contains an orphan node!\nRetaining the outline')
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    at.fromString = fromString
    if at.errors:
        if trace: g.trace('Init error')
        return False
    fileName = at.openFileForReading(fromString=fromString)
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    elif fromString: # 2010/09/02.
        pass
    else:
        g.trace('No inputFile')
        return False

    # Get the file from the cache if possible.
    if fromString:
        s,loaded,fileKey = fromString,False,None
    else:
        s,loaded,fileKey = c.cacher.readFile(fileName,root)
    # Never read an external file with file-like sentinels from the cache.
    isFileLike = loaded and at.isFileLike(s)
    if not loaded or isFileLike:
        # if trace: g.trace('file-like file',fileName)
        force = True # Disable caching.
    if loaded and not force:
        if trace: g.trace('in cache',fileName)
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    if isFileLike:
        if g.unitTesting:
            if 0: print("converting @file format in",root.h)
            g.app.unitTestDict['read-convert']=True
        else:
            g.es("converting @file format in",root.h,color='red')
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width

    if trace: g.trace(fileName)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.deleteUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        at.copyAllTempBodyStringsToVnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if isFileLike and at.errors == 0: # Old-style sentinels.
        # 2010/02/24: Make the root @file node dirty so it will
        # be written automatically when saving the file.
        # Do *not* set the orphan bit here!
        root.clearOrphan()
        root.setDirty()
        c.setChanged(True) # Essential, to keep dirty bit set.
    elif at.errors > 0:
        # 2010/10/22: Dirty bits are *always* cleared.
        # Only the orphan bit is preserved.
        root.setDirty()
        root.setOrphan()
        c.setChanged(True)
    else:
        root.clearOrphan()
    if at.errors == 0 and not isFileLike and not fromString:
        c.cacher.writeFile(root,fileKey)

    if trace: g.trace('at.errors',at.errors)
    return at.errors == 0
#@+node:ekr.20041005105605.25: *6* at.deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
#@+node:ekr.20100122130101.6174: *6* at.deleteTnodeList
def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
#@+node:ekr.20071105164407: *6* at.deleteUnvisitedNodes & helpers
def deleteUnvisitedNodes (self,root):

    '''Delete unvisited nodes in root's subtree, not including root.

    Actually, instead of deleting the nodes, we move them to be children of the
    'Resurrected Nodes' r.
    '''

    at = self

    if not root.hasChildren():
        return

    # Carefully set up the arguments.
    aList = [z.copy() for z in root.subtree() if not z.isVisited()]
    if not aList: return

    r = at.createResurrectedNodesNode()
    assert r not in aList
    callback=at.defineResurrectedNodeCallback(r,root)

    # Now move the nodes.
    root.firstChild().deletePositionsInList(aList,callback)
#@+node:ekr.20100803073751.5817: *7* createResurrectedNodesNode
def createResurrectedNodesNode(self):

    '''Create a 'Resurrected Nodes' node as the last top-level node.'''

    at = self ; c = at.c ; tag = 'Resurrected Nodes'

    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()

    if last.h == tag:
        # The 'Resurrected Nodes' node already exists.
        p = last
    else:
        # Create the 'Resurrected Nodes' node after 'last'.
        p = last.insertAfter()
        p.setHeadString(tag)

    p.expand()
    return p
#@+node:ekr.20100803073751.5818: *7* defineResurrectedNodeCallback
def defineResurrectedNodeCallback (self,r,root):

    '''Define a callback that moves node p as r's last child.'''

    def callback(p,r=r.copy(),root=root):

        '''The resurrected nodes callback.'''

        child = r.insertAsLastChild()
        child.h = 'From %s' % root.h
        p.moveToLastChildOf(child)

        if g.unitTesting:
            # g.trace(p.h,r.h)
            pass 
        else:
            g.es('resurrected node:',p.h,color='red')
            g.es('in file:',root.h,color='blue')

    return callback


#@+node:ekr.20041005105605.22: *6* at.initFileName
def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "<string-file>"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName
#@+node:ekr.20100224050618.11547: *6* at.isFileLike
def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
#@+node:ekr.20090712050729.6017: *5* promptForDangerousWrite
def promptForDangerousWrite (self,fileName,kind):

    c = self.c

    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForDangerousWrite')
        return val in (None,True)

    # g.trace(timeStamp, timeStamp2)
    message = '%s %s\n%s\n%s' % (
        kind, fileName,
        g.tr('already exists.'),
        g.tr('Overwrite this file?'))

    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite existing file?',
        message = message)

    return ok == 'yes'
#@+node:ekr.20110518022449.6071: *4* Fixed important bug involving orphan nodes
@nocolor-node

This was an important bug.  It's been around for a very long time.

What I did:
    
- putVnode no longer clears the orphan bit.

- at.read issues a warning and does not read the external file if the orphan bit is set.
#@+node:ekr.20110522203356.18260: *5* Report
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/861a0d156b16090f

The document said that orphan children would be saved in leo file. See 'orphan
node' description at http://webpages.charter.net/edreamleo/glossary.html for
example.

I found, although they were saved in leo file (I checked the xml file), but
they didn't appear in outline pane if I closed and reloaded the leo file. The
same for named children nodes which were not referenced in parent file node.

Is the behavior a bug or expected behavior?

Here is the entry in the glossary::
    
Orphan node

    A node that would not be copied to a external file. Orphan nodes can arise
    because an @file tree has no @others or @all directives. Sections that are
    defined but not used also create orphan nodes.

    Leo issues a warning when attempting to write an @file tree containing
    orphan nodes, and does not save the external file. No information is lost;
    Leo saves the information in the @file tree in the .leo file. Leo will load
    the @file tree from the .leo file the next time Leo opens the .leo file.
#@+node:ekr.20041005105605.26: *5* at.readAll
def readAll(self,root,partialFlag=False):

    """Scan vnodes, looking for @<file> nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    force = partialFlag
    if partialFlag:
        # Capture the current headline only if
        # we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()

    scanned_tnodes = set()

    if partialFlag: after = p.nodeAfterTree()    
    else: after = c.nullPosition()

    while p and p != after:
        gnx = p.gnx
        #skip clones
        if gnx in scanned_tnodes:
            p.moveToNodeAfterTree()
            continue
        scanned_tnodes.add(gnx)

        if not p.h.startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,force=force)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtEditNode():
            fileName = p.atEditNodeName()
            at.readOneAtEditNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p,force=force)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                # However, the dirty bit gets cleared.
                p.setDirty() # Expensive, but it can't be helped.
                p.setOrphan() # 2010/10/22: the dirty bit gets cleared.
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            # 2010/7/28: set v.at_read bit if the @asis or @nosent
            # **node** exists.  We'll prompt for dangerous writes
            # if a) this bit is clear and b) the file exists.
            if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
                p.v.at_read = True # Remember that we have seen this node.
            p.moveToThreadNext()

    # 2010/10/22: Preserve the orphan bits: the dirty bits will be cleared!
    ### Clear all orphan bits.
    #for v in c.all_unique_nodes():
    #    v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @<file> nodes in the selected tree")

    if use_tracer: tt.stop()
#@+node:ekr.20041005105605.21: *5* at.read & helpers
def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    trace = False and not g.unitTesting
    if trace: g.trace(root.h)
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    # Fix bug 760531: always mark the root as read, even if there was an error.
    root.v.at_read = True
    # Bug fix 2011/05/23: Restore orphan trees from the outline.
    if root.isOrphan():
        g.es("reading:",root.h)
        g.warning('The outline contains an orphan node!\nRetaining the outline')
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    at.fromString = fromString
    if at.errors:
        if trace: g.trace('Init error')
        return False
    fileName = at.openFileForReading(fromString=fromString)
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    elif fromString: # 2010/09/02.
        pass
    else:
        g.trace('No inputFile')
        return False

    # Get the file from the cache if possible.
    if fromString:
        s,loaded,fileKey = fromString,False,None
    else:
        s,loaded,fileKey = c.cacher.readFile(fileName,root)
    # Never read an external file with file-like sentinels from the cache.
    isFileLike = loaded and at.isFileLike(s)
    if not loaded or isFileLike:
        # if trace: g.trace('file-like file',fileName)
        force = True # Disable caching.
    if loaded and not force:
        if trace: g.trace('in cache',fileName)
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    if isFileLike:
        if g.unitTesting:
            if 0: print("converting @file format in",root.h)
            g.app.unitTestDict['read-convert']=True
        else:
            g.es("converting @file format in",root.h,color='red')
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width

    if trace: g.trace(fileName)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.deleteUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        at.copyAllTempBodyStringsToVnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if isFileLike and at.errors == 0: # Old-style sentinels.
        # 2010/02/24: Make the root @file node dirty so it will
        # be written automatically when saving the file.
        # Do *not* set the orphan bit here!
        root.clearOrphan()
        root.setDirty()
        c.setChanged(True) # Essential, to keep dirty bit set.
    elif at.errors > 0:
        # 2010/10/22: Dirty bits are *always* cleared.
        # Only the orphan bit is preserved.
        root.setDirty()
        root.setOrphan()
        c.setChanged(True)
    else:
        root.clearOrphan()
    if at.errors == 0 and not isFileLike and not fromString:
        c.cacher.writeFile(root,fileKey)

    if trace: g.trace('at.errors',at.errors)
    return at.errors == 0
#@+node:ekr.20041005105605.25: *6* at.deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
#@+node:ekr.20100122130101.6174: *6* at.deleteTnodeList
def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
#@+node:ekr.20071105164407: *6* at.deleteUnvisitedNodes & helpers
def deleteUnvisitedNodes (self,root):

    '''Delete unvisited nodes in root's subtree, not including root.

    Actually, instead of deleting the nodes, we move them to be children of the
    'Resurrected Nodes' r.
    '''

    at = self

    if not root.hasChildren():
        return

    # Carefully set up the arguments.
    aList = [z.copy() for z in root.subtree() if not z.isVisited()]
    if not aList: return

    r = at.createResurrectedNodesNode()
    assert r not in aList
    callback=at.defineResurrectedNodeCallback(r,root)

    # Now move the nodes.
    root.firstChild().deletePositionsInList(aList,callback)
#@+node:ekr.20100803073751.5817: *7* createResurrectedNodesNode
def createResurrectedNodesNode(self):

    '''Create a 'Resurrected Nodes' node as the last top-level node.'''

    at = self ; c = at.c ; tag = 'Resurrected Nodes'

    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()

    if last.h == tag:
        # The 'Resurrected Nodes' node already exists.
        p = last
    else:
        # Create the 'Resurrected Nodes' node after 'last'.
        p = last.insertAfter()
        p.setHeadString(tag)

    p.expand()
    return p
#@+node:ekr.20100803073751.5818: *7* defineResurrectedNodeCallback
def defineResurrectedNodeCallback (self,r,root):

    '''Define a callback that moves node p as r's last child.'''

    def callback(p,r=r.copy(),root=root):

        '''The resurrected nodes callback.'''

        child = r.insertAsLastChild()
        child.h = 'From %s' % root.h
        p.moveToLastChildOf(child)

        if g.unitTesting:
            # g.trace(p.h,r.h)
            pass 
        else:
            g.es('resurrected node:',p.h,color='red')
            g.es('in file:',root.h,color='blue')

    return callback


#@+node:ekr.20041005105605.22: *6* at.initFileName
def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "<string-file>"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName
#@+node:ekr.20100224050618.11547: *6* at.isFileLike
def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
#@+node:ekr.20031218072017.1863: *5* putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # 2010/09/02: @edit nodes must not have children.
        # If they do, the entire tree is written to the outline.
    isFile   = p.isAtFileNode()
    isShadow = p.isAtShadowFileNode()
    isThin   = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # 2010/10/22: force writes of orphan @edit, @auto and @shadow trees.
    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = isOrphan  # Force write of orphan @auto trees.
    elif isEdit:   forceWrite = isOrphan  # Force write of orphan @edit trees.
    elif isFile:   forceWrite = isOrphan  # Force write of orphan @file trees.
    elif isShadow: forceWrite = isOrphan  # Force write of @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Force write of  orphan @thin trees.
    else:          forceWrite = True      # Write all other @<file> trees.

    << Set gnx = vnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s>' % (gnx,attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head+'</v>\n')
    else:
        fc.vnodesDict[gnx]=True
        v_head += '<vh>%s</vh>' % (xml.sax.saxutils.escape(p.v.headString()or''))
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            << issue informational messages >>
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent() # Restore p in the caller.
            fc.put('</v>\n')
        else:
            fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864: *6* << Set gnx = vnode index >>
gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
#@+node:ekr.20031218072017.1865: *6* << Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren() and c.putBitsFlag:
        attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = v.u
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    v.u = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@+node:ekr.20040324082713: *6* << Append unKnownAttributes to attrs>>
# v.unknownAttributes are now put in <t> elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
#@+node:ekr.20040702085529: *6* << issue informational messages >> (changed)
if 0: # It's strange to clear the orphan bit.
    if isOrphan and (isFile or isThin):
        g.es("writing erroneous:",p.h,color="blue")
        p.clearOrphan()
#@+node:ekr.20110522203356.18251: *4* Investigated bug 735938:file association crash
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/735938

This is a minor problem: the recommended way of starting Leo on Windows is with a batch file.
#@+node:ekr.20110523120944.18189: *5* Report 1
@nocolor-node

Yesterday I installed the new version of leo. I changed the path to leo and
wanted to associate .leo file with leo. I ran the commands:

> ftype LeoFile=C:\Python26\python.exe "C:\Python26\Lib\site-packages\leo\launchLeo.py" "%*"
> assoc .leo=LeoFile

But when I tried to start .leo file from console it gave me an error:

-------------------------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Python26\Lib\site-packages\leo\leo\core\leoGlobals.py", line 3497, in
 os_path_dirname
    path = g.toUnicodeFileEncoding(path)
  File "C:\Python26\Lib\site-packages\leo\leo\core\leoGlobals.py", line 3727, in
 toUnicodeFileEncoding
    if path: path = path.replace('\\', os.sep)
AttributeError: 'tuple' object has no attribute 'replace'

--------------------------------------------------------------------------------------
I added pprint.pprint(path) before the erroneous code. It printed many strings, but at the end
gave this:

u'C:\\Python26\\Lib\\site-packages\\leo\\leo\\config\\.leoRecentFiles.txt'
u'C:\\Python26\\Lib\\site-packages\\leo\\leo\\config\\.leoRecentFiles.txt'
(None, None)

Seems to be that nasty tuple at the end.

After I tried adding the code:

if isinstance(path, str):
 if path: path = path.replace('\\', os.sep)

It gave a new error:
-------------------------------------------------------------------------------------
  File "C:\Python26\Lib\site-packages\leo\leo\core\leoGlobals.py", line 4730, in
 toUnicode
    s = f(s,encoding,'replace')
TypeError: coercing to Unicode: need string or buffer, tuple found
-------------------------------------------------------------------------------------

How did this tuple emerge?
#@+node:ekr.20110523120944.18188: *5* Report 2
@nocolor-node

Traceback (most recent call last):
  File "C:\Python26\Lib\site-packages\leo\launchLeo.py", line 8, in <module>
    leo.core.runLeo.run()
  File "C:\Python26\Lib\site-packages\leo\leo\core\runLeo.py", line 121, in run
    files,options = doPrePluginsInit(fileName,pymacs)
  File "C:\Python26\Lib\site-packages\leo\leo\core\runLeo.py", line 139, in doPrePluginsInit
    g.computeStandardDirectories()
  File "C:\Python26\Lib\site-packages\leo\leo\core\leoGlobals.py", line 169, in computeStandardDirectories
    g.app.loadDir = g.computeLoadDir()
  File "C:\Python26\Lib\site-packages\leo\leo\core\leoGlobals.py", line 275, in computeLoadDir
    path = g.os_path_finalize(path)
  File "C:\Python26\Lib\site-packages\leo\leo\core\leoGlobals.py", line 3568, in os_path_finalize
    path = g.os_path_expanduser(path)
  File "C:\Python26\Lib\site-packages\leo\leo\core\leoGlobals.py", line 3553, in os_path_expanduser
    result = os.path.normpath(os.path.expanduser(path))
  File "C:\Python26\lib\ntpath.py", line 279, in expanduser
    if path[:1] != '~':
TypeError: 'NoneType' object is unsubscriptable
#@+node:ekr.20080921060401.13: *5* os_path_expanduser
def os_path_expanduser(path):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path)

    result = os.path.normpath(os.path.expanduser(path))

    return result
#@+node:ekr.20050328133444: *5* g.computeStandardDirectories & helpers
def computeStandardDirectories():

    '''Set g.app.loadDir, g.app.homeDir, g.app.homeLeoDir and g.app.globalConfigDir.'''

    g.app.loadDir = g.computeLoadDir()
    g.app.leoDir = g.computeLeoDir()
    g.app.homeDir = g.computeHomeDir()

    g.app.homeLeoDir = homeLeoDir = g.os_path_finalize(
        g.os_path_join(g.app.homeDir,'.leo'))

    if not g.os_path_exists(homeLeoDir):
        g.makeAllNonExistentDirectories(homeLeoDir,force=True)

    g.app.extensionsDir = g.os_path_finalize(
        g.os_path_join(g.app.loadDir,'..','extensions'))

    g.app.globalConfigDir = g.computeGlobalConfigDir()

    g.app.testDir = g.os_path_finalize(
        g.os_path_join(g.app.loadDir,'..','test'))

    g.app.user_xresources_path = g.os_path_join(
        g.app.homeDir,'.leo_xresources')
#@+node:ekr.20041117155521: *6* computeGlobalConfigDir
def computeGlobalConfigDir():

    import leo.core.leoGlobals as g

    # To avoid pylint complaints that sys.leo_config_directory does not exist.
    leo_config_dir = (
        hasattr(sys,'leo_config_directory') and
        getattr(sys,'leo_config_directory'))

    if leo_config_dir:
        theDir = leo_config_dir
    else:
        theDir = g.os_path_join(g.app.loadDir,"..","config")

    if theDir:
        theDir = g.os_path_finalize(theDir)

    if (
        not theDir or
        not g.os_path_exists(theDir) or
        not g.os_path_isdir(theDir)
    ):
        theDir = None

    return theDir
#@+node:ekr.20041117151301: *6* computeHomeDir
def computeHomeDir():

    """Returns the user's home directory."""

    import leo.core.leoGlobals as g

    home = os.path.expanduser("~")
        # Windows searches the HOME, HOMEPATH and HOMEDRIVE environment vars, then gives up.

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # Important: This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_finalize(home)
        if (
            not g.os_path_exists(home) or
            not g.os_path_isdir(home)
        ):
            home = None

    return home
#@+node:ekr.20060416113431: *6* computeLeoDir
def computeLeoDir ():

    loadDir = g.app.loadDir
    theDir = g.os_path_dirname(loadDir)

    # xxx remove this, we don't want to have this in sys.path
    if theDir not in sys.path:
        sys.path.append(theDir)

    return theDir
#@+node:ekr.20031218072017.1937: *6* computeLoadDir
def computeLoadDir():

    """Returns the directory containing leo.py."""

    import leo.core.leoGlobals as g
    import sys

    try:
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        # g.trace(repr(path))
        if path:
            # Possible fix for bug 735938:
            # Do the following only if path exists.
            << resolve symlinks >>
            if sys.platform=='win32':
                if len(path) > 2 and path[1]==':':
                    # Convert the drive name to upper case.
                    path = path[0].upper() + path[1:]
        
            
            path = g.os_path_finalize(path)
            loadDir = g.os_path_dirname(path)
        else: loadDir = None

        if (
            not loadDir or
            not g.os_path_exists(loadDir) or
            not g.os_path_isdir(loadDir)
        ):
            loadDir = os.getcwd()
            # From Marc-Antoine Parent.
            if loadDir.endswith("Contents/Resources"):
                loadDir += "/leo/plugins"
            else:
                g.pr("Exception getting load directory")
        loadDir = g.os_path_finalize(loadDir)
        # g.es("load dir:",loadDir,color="blue")
        return loadDir
    except:
        g.pr("Exception getting load directory")
        raise
#@+node:ville.20090703102253.6160: *7* << resolve symlinks >>
if path.endswith('pyc'):
    srcfile = path[:-1]
    if os.path.islink(srcfile):
        path = os.path.realpath(srcfile)    
#@+node:dan.20080410121257.1: *6* computeMachineName
def computeMachineName():
    """Returns the name of the current machine, i.e, HOSTNAME"""
    try:
        import os
        name = os.getenv('HOSTNAME')
        if not name:
            name = os.getenv('COMPUTERNAME')
        if not name:
            import socket
            name = socket.gethostname()
    except Exception:
        name = ''

    # g.trace(name)

    return name
#@+node:ekr.20110522203356.18252: *4* Investigated Bug 568452:file local @settings ignored if file opened from command line with absolute path
@nocolor-node

I don't believe that the diagnosis given in the report is valid.

To determine what is going on, enable the trace in readSettings.
#@+node:ekr.20110523130519.18189: *5* Report
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/568452

Given

  LEOPATH=/home/tbrown/Desktop/Package/leo/bzr/leo.repo/trunk
  HOME=/tmp python $LEOPATH/launchLeo.py foo/bar.leo

@settings in bar.leo are honored., but with

  HOME=/tmp python $LEOPATH/launchLeo.py /home/tbrown/Desktop/leotest/foo/bar.leo

(i.e. absolute path to same file), they're ignored.

(LEOPATH has nothing to do with anything here, just trying to make the example more clear)

==========================

Still seeing this, don't know why I thought it was fixed.

with the attached del.leo in $HOME/.leo

cd $HOME/.leo
python /home/tbrown/Desktop/Package/leo/bzr/leo.repo/trunk/launchLeo.py /home/tbrown/.leo/del.leo

-> icon bar is at top and running g.es(c.config.getString('qt-toolbar-location')) in 'test' node reports top

vs.

cd $HOME/.leo
python /home/tbrown/Desktop/Package/leo/bzr/leo.repo/trunk/launchLeo.py del.leo

-> icon bar is at left and running g.es(c.config.getString('qt-toolbar-location')) in 'test' node reports left

only difference is on the command line, '/home/tbrown/.leo/del.leo' vs. 'del.leo'

cd $HOME and '.leo/del.leo' also works, so it seems to be the absoluteness of the path which is making it not read the config.


====================

In case you don't know '2>&1', it means 'redirect stderr to the same
place as stdout'.

  python launchLeo.py del.leo >relative.log 2>&1

test script correctly reports 'left', tool bar correctly positioned

  python launchLeo.py $PWD/del.leo >absolute.log 2>&1

test script incorrectly reports 'top', tool bar incorrectly (although
consistently) positioned

md5sum *log

218398d7c0594365ba0589541a302ad0 absolute.log
218398d7c0594365ba0589541a302ad0 relative.log

So, absolute vs. relative makes no difference in the console output,
which is:

trunk> cat relative.log
*** isPython3: False
Leo 4.8 final, build 3752, November 26, 2010
Python 2.6.5, qt version 4.6.2
linux2
reading settings in /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/leo/config/leoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.leo/myLeoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.leo/mothLeoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/del.leo
Warning: shortcut conflict for <Ctrl+O>
            leoscreen-run-text in all from register-command
                  open-outline in all from leosettings.leo
Warning: shortcut conflict for <Ctrl+M>
               leoscreen-other in all from register-command
                          mark in all from leosettings.leo
Warning: shortcut conflict for <Ctrl+P>
            leoscreen-get-line in all from register-command
        repeat-complex-command in all from leosettings.leo
Warning: shortcut conflict for <Ctrl+B>
             quickmove_jump_to in all from register-command
                execute-script in all from leosettings.leo
createMenuEntries No inverse for makeallbuttonsherepermanent
createMenuEntries No inverse for clearallpermanentbuttonshere
wrote recent file: /home/tbrown/.leo/.leoRecentFiles.txt

The log pane is similar:

Leo Log Window
Leo 4.8 final, build 3752, November 26, 2010
Python 2.6.5, qt version 4.6.2
linux2
setting leoID from os.getenv('USER'): 'tbrown'
load dir: /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/leo/core
global config dir: /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/leo/config
home dir: /home/tbrown
reading settings in /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/leo/config/leoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.leo/myLeoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.leo/mothLeoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/del.leo
reading: /home/tbrown/Desktop/Package/leo/bzr/leo.repo/trunk/del.leo
local @command press-me
Warning: shortcut conflict for <Ctrl+O>
            leoscreen-run-text in all from register-command
                  open-outline in all from leosettings.leo
Warning: shortcut conflict for <Ctrl+M>
               leoscreen-other in all from register-command
                          mark in all from leosettings.leo
Warning: shortcut conflict for <Ctrl+P>
            leoscreen-get-line in all from register-com...
#@+node:ekr.20031218072017.2145: *5* os.path wrappers (leoGlobals.py)
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
#@+node:ekr.20031218072017.2146: *6* os_path_abspath
def os_path_abspath(path):

    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.abspath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
#@+node:ekr.20031218072017.2147: *6* os_path_basename
def os_path_basename(path):

    """Return the second half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.basename(path)

    path = g.toUnicodeFileEncoding(path)

    return path
#@+node:ekr.20031218072017.2148: *6* os_path_dirname
def os_path_dirname(path):

    """Return the first half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.dirname(path)

    path = g.toUnicodeFileEncoding(path)

    return path
#@+node:ekr.20031218072017.2149: *6* os_path_exists
def os_path_exists(path):

    """Return True if path exists."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.exists(path)
#@+node:ekr.20080922124033.6: *6* os_path_expandExpression
def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    trace = False
    s1 = s
    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    if not s: return ''

    i = s.find('{{')
    j = s.find('}}')
    if -1 < i < j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.p
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

        if trace: g.trace(s1,s)
    return s
#@+node:ekr.20080921060401.13: *6* os_path_expanduser
def os_path_expanduser(path):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path)

    result = os.path.normpath(os.path.expanduser(path))

    return result
#@+node:ekr.20080921060401.14: *6* g.os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c = keys.get('c')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path)

    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c = keys.get('c')

    if c:
        args = [g.os_path_expandExpression(path,**keys)
            for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@+node:ekr.20031218072017.2150: *6* os_path_getmtime
def os_path_getmtime(path):

    """Return the modification time of path."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.getmtime(path)
#@+node:ekr.20080729142651.2: *6* os_path_getsize
def os_path_getsize (path):

    '''Return the size of path.'''

    path = g.toUnicodeFileEncoding(path)

    return os.path.getsize(path)
#@+node:ekr.20031218072017.2151: *6* os_path_isabs
def os_path_isabs(path):

    """Return True if path is an absolute path."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isabs(path)
#@+node:ekr.20031218072017.2152: *6* os_path_isdir
def os_path_isdir(path):

    """Return True if the path is a directory."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isdir(path)
#@+node:ekr.20031218072017.2153: *6* os_path_isfile
def os_path_isfile(path):

    """Return True if path is a file."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isfile(path)
#@+node:ekr.20031218072017.2154: *6* os_path_join
def os_path_join(*args,**keys):

    trace = False and not g.unitTesting
    c = keys.get('c')

    uargs = [g.toUnicodeFileEncoding(arg) for arg in args]

    if trace: g.trace('1',uargs)

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z) for z in uargs if z]

    if trace: g.trace('2',uargs)

    path = os.path.join(*uargs)

    if trace: g.trace('3',path)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path)
    return path
#@+node:ekr.20031218072017.2156: *6* os_path_normcase
def os_path_normcase(path):

    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.normcase(path)

    path = g.toUnicodeFileEncoding(path)

    return path
#@+node:ekr.20031218072017.2157: *6* os_path_normpath
def os_path_normpath(path):

    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.normpath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
#@+node:ekr.20080605064555.2: *6* os_path_realpath
def os_path_realpath(path):


    path = g.toUnicodeFileEncoding(path)

    path = os.path.realpath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
#@+node:ekr.20031218072017.2158: *6* os_path_split
def os_path_split(path):

    path = g.toUnicodeFileEncoding(path)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)

    return head,tail
#@+node:ekr.20031218072017.2159: *6* os_path_splitext
def os_path_splitext(path):

    path = g.toUnicodeFileEncoding(path)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)

    return head,tail
#@+node:ekr.20090829140232.6036: *6* os_startfile
def os_startfile(fname):
    if sys.platform.startswith('win'):
        os.startfile(fname)
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            subprocess.call(['open', fname])
        except OSError:
            pass # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system("open '%s'" % (fname,))
    else:
        os.system('xdg-open ' + fname)
#@+node:ekr.20031218072017.2160: *6* toUnicodeFileEncoding
def toUnicodeFileEncoding(path):

    if path: path = path.replace('\\', os.sep)

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path)
#@+node:ekr.20041120064303: *5* readSettingsFiles & helpers (g.app.config)
def readSettingsFiles (self,fileName,verbose=True):

    '''Read settings from one file of the standard settings files.'''

    trace = False and not g.unitTesting
    verbose = verbose
    giveMessage = (verbose and not g.app.unitTesting and
        not self.silent and not g.app.batchMode)
    def message(s):
        # This occurs early in startup, so use the following.
        if not g.isPython3:
            s = g.toEncodedString(s,'ascii')
        g.es_print(s,color='blue')
    self.write_recent_files_as_needed = False # Will be set later.
    localConfigFile = self.getLocalConfigFile(fileName)
    if trace: g.trace(fileName,localConfigFile)
    table = self.defineSettingsTable(fileName,localConfigFile)
    for path,localFlag in table:
        assert path and g.os_path_exists(path)
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or path.endswith('.leo')
        if isLeo:
            c = self.openSettingsFile(path)
            if c:
                if giveMessage:
                    message('reading settings in %s' % path)
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool(
                    'write_recent_files_as_needed')
            else:
                if giveMessage:
                    message('error reading settings in %s' % path)

    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20101021041958.6008: *6* getLocalConfigFile
# This can't be done in initSettingsFiles because
# the local directory does not yet exist.

def getLocalConfigFile (self,fileName):

    if not fileName:
        return None

    theDir = g.os_path_dirname(fileName)
    path = g.os_path_join(theDir,'leoSettings.leo')

    if g.os_path_exists(path):
        return path
    else:
        return None
#@+node:ekr.20101021041958.6004: *6* defineSettingsTable
def defineSettingsTable (self,fileName,localConfigFile):

    trace = False and not g.unitTesting
    verbose = False

    global_table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        # (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        # (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
    )

    if fileName:
        if fileName.lower().endswith('leosettings.leo'):
            # 2011/02/28: don't read leoSettings.leo or myLeoSetings.leo twice.
            # This allows myLeoSettings.leo to take precedence.
            table1 = []
        else:
            path = g.os_path_finalize(fileName)
            theDir = g.os_path_dirname(fileName)
            myLocalConfigFile = g.os_path_join(theDir,'myLeoSettings.leo')
            local_table = (
                (localConfigFile,False),
                (myLocalConfigFile,False),
            )
            if trace and verbose:
                g.trace('localConfigFile:  ',localConfigFile)
                g.trace('myLocalConfigFile:',myLocalConfigFile)
    
            table1 = [z for z in local_table if z not in global_table]
            table1.append((path,True),)
    else:
        table1 = global_table

    seen = [] ; table = []
    for path,localFlag in table1:
        if trace and verbose: g.trace('exists',g.os_path_exists(path),path)
        if path and g.os_path_exists(path):
            # Make sure we mark files seen no matter how they are specified.
            path = g.os_path_realpath(g.os_path_finalize(path))
            if path.lower() not in seen:
                seen.append(path.lower())
                table.append((path,localFlag),)
    if trace: g.trace(repr(fileName),'table:',g.listToString(table))
    return table
#@+node:ekr.20041117085625: *6* openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@+node:ekr.20051013161232: *6* updateSettings
def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
#@+node:ekr.20041117083857.1: *5* g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    trace = False and not g.unitTesting
    if trace: g.trace('localFlag: %5s %s' % (localFlag, c and c.shortFileName()))

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()
    
    # g.trace(c.shortFileName(),len(list(d.keys())))

    return d
#@+node:ekr.20110523130519.19137: *4* Fixed bug: show-invisibles now correctly shows blank lines
# recolor must test self.showInvisibles.
#@+node:ekr.20110522121957.18234: *4* Fixed bug 766747: fill-paragraph doesn't respect setting from set-fill-column
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/766747

The fill-paragraph, center-line and center-region now all use the fill column
if it has been explicitly set (and greater than zero). Otherwise, these commands
use the @pagewidth value.

Previously, the fill-paragraph command used the page width set by the @pagewidth
directive, or an initial value from a @setting if no @pagewidth directive was in
effect.
#@+node:ekr.20101118113953.5839: *5* c.reformatParagraph & helpers
def reformatParagraph (self,event=None,undoType='Reformat Paragraph'):

    """Reformat a text paragraph

    Wraps the concatenated text to present page width setting. Leading tabs are
    sized to present tab width setting. First and second line of original text is
    used to determine leading whitespace in reformatted text. Hanging indentation
    is honored.

    Paragraph is bound by start of body, end of body and blank lines. Paragraph is
    selected by position of current insertion cursor.

"""

    c = self ; body = c.frame.body ; w = body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        i,j = w.getSelectionRange()
        w.setInsertPoint(i)

    oldSel,oldYview,original,pageWidth,tabWidth = c.rp_get_args()
    head,lines,tail = c.findBoundParagraph()
    if lines:
        indents,leading_ws = c.rp_get_leading_ws(lines,tabWidth)
        result = c.rp_wrap_all_lines(indents,leading_ws,lines,pageWidth)
        c.rp_reformat(head,oldSel,oldYview,original,result,tail,undoType)
#@+node:ekr.20031218072017.1825: *6* c.findBoundParagraph
def findBoundParagraph (self,event=None):

    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None

    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    for line in tail_lines:
        if not line or line.isspace() or line.startswith('@'):
            break
        i += 1

    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]

    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    return head,result,tail # string, list, string
#@+node:ekr.20031218072017.1826: *7* << trace head_lines, ins, tail_lines >>
if 0:
    g.pr("\nhead_lines")
    for line in head_lines:
        g.pr(line)
    g.pr("\nins", ins)
    g.pr("\ntail_lines")
    for line in tail_lines:
        g.pr(line)
else:
    g.es_print("head_lines: ",head_lines)
    g.es_print("ins: ",ins)
    g.es_print("tail_lines: ",tail_lines)
#@+node:ekr.20101118113953.5840: *6* rp_get_args
def rp_get_args (self):

    '''Compute and return oldSel,oldYview,original,pageWidth,tabWidth.'''

    c = self ; body = c.frame.body ;  w = body.bodyCtrl

    d = c.scanAllDirectives()

    if c.editCommands.fillColumn > 0:
        pageWidth = c.editCommands.fillColumn
    else:
        pageWidth = d.get("pagewidth")
        
    tabWidth  = d.get("tabwidth")
    original = w.getAllText()
    oldSel =  w.getSelectionRange()
    oldYview = body.getYScrollPosition()

    return oldSel,oldYview,original,pageWidth,tabWidth
#@+node:ekr.20101118113953.5841: *6* rp_get_leading_ws
def rp_get_leading_ws (self,lines,tabWidth):

    '''Compute and return indents and leading_ws.'''

    c = self

    indents = [0,0]
    leading_ws = ["",""]

    for i in (0,1):
        if i < len(lines):
            # Use the original, non-optimized leading whitespace.
            leading_ws[i] = ws = g.get_leading_ws(lines[i])
            indents[i] = g.computeWidth(ws,tabWidth)

    indents[1] = max(indents)

    if len(lines) == 1:
        leading_ws[1] = leading_ws[0]

    return indents,leading_ws
#@+node:ekr.20101118113953.5842: *6* rp_reformat
def rp_reformat (self,head,oldSel,oldYview,original,result,tail,undoType):

    '''Reformat the body and update the selection.'''

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    s = w.getAllText()

    # This destroys recoloring.
    junk, ins = body.setSelectionAreas(head,result,tail)

    changed = original != head + result + tail
    if changed:
        # 2010/11/16: stay in the paragraph.
        body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)
    else:
        # Advance to the next paragraph.
        ins += 1 # Move past the selection.
        while ins < len(s):
            i,j = g.getLine(s,ins)
            line = s[i:j]
            # 2010/11/16: it's annoying, imo, to treat @ lines differently.
            if line.isspace(): ### or line.startswith('@'):
                ins = j+1
            else:
                ins = i ; break

        # setSelectionAreas has destroyed the coloring.
        c.recolor()

    w.setSelectionRange(ins,ins,insert=ins)
    
    # Make the next line visible: this is a big improvement.
    w.see(ins+5)
#@+node:ekr.20101118113953.5843: *6* rp_wrap_all_lines
def rp_wrap_all_lines (self,indents,leading_ws,lines,pageWidth):

    '''compute the result of wrapping all lines.'''

    trailingNL = lines and lines[-1].endswith('\n')
    lines = [g.choose(z.endswith('\n'),z[:-1],z) for z in lines]

    # Wrap the lines, decreasing the page width by indent.
    result = g.wrap_lines(lines,
        pageWidth-indents[1],
        pageWidth-indents[0])

    # prefix with the leading whitespace, if any
    paddedResult = []
    paddedResult.append(leading_ws[0] + result[0])
    for line in result[1:]:
        paddedResult.append(leading_ws[1] + line)

    # Convert the result to a string.
    result = '\n'.join(paddedResult)
    if trailingNL: result = result + '\n'

    return result
#@+node:ekr.20050920084036.54: *5*  ctor (editCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.ccolumn = '0'   # For comment column functions.
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 0 # For line centering.
        # Set by the set-fill-column command.
        # If zero, @pagewidth value is used.
    self.moveSpotNode = None # A vnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.

    # Settings...
    cf = c.config
    self.autocompleteBrackets   = cf.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = cf.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = cf.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = cf.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = cf.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = cf.getBool('flash-matching-brackets')
    self.smartAutoIndent        = cf.getBool('smart_auto_indent')
    self.openBracketsList       = cf.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList      = cf.getString('close_flash_brackets') or ')]}'

    self.initBracketMatcher(c)
#@+node:ekr.20050920084036.103: *5* fillParagraph
def fillParagraph( self, event ):

    '''Fill the selected paragraph'''

    w = self.editWidget(event)
    if not w: return

    # Clear the selection range.
    i,j = w.getSelectionRange()
    w.setSelectionRange(i,i,insert=i)

    self.c.reformatParagraph(event)
#@+node:ekr.20050920084036.66: *5* fill column and centering
@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap

after an center-region command via Alt-x.
@c

@others
#@+node:ekr.20050920084036.67: *6* centerLine
def centerLine (self,event):

    '''Centers line within current fill column'''

    c,k,w = self.c,self.k,self.editWidget(event)
    if not w: return
    
    if self.fillColumn > 0:
        fillColumn = self.fillColumn
    else:
        d = c.scanAllDirectives()
        fillColumn = d.get("pagewidth")

    s = w.getAllText()
    i,j = g.getLine(s,w.getInsertPoint())
    line = s [i:j].strip()
    if not line or len(line) >= fillColumn: return

    self.beginCommand(undoType='center-line')
    n = (fillColumn-len(line)) / 2
    ws = ' ' * n
    k = g.skip_ws(s,i)
    if k > i: w.delete(i,k-i)
    w.insert(i,ws)
    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.68: *6* setFillColumn
def setFillColumn (self,event):

    '''Set the fill column used by the center-line and center-region commands.'''

    k = self.k ; state = k.getState('set-fill-column')

    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            # Bug fix: 2011/05/23: set the fillColumn ivar!
            self.fillColumn = n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
#@+node:ekr.20050920084036.69: *6* centerRegion
def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    c,k,w = self.c,self.k,self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)
    
    if self.fillColumn > 0:
        fillColumn = self.fillColumn
    else:
        d = c.scanAllDirectives()
        fillColumn = d.get("pagewidth")

    self.beginCommand(undoType='center-region')

    inserted = 0
    while ind < end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) >= fillColumn:
            ind = j
        else:
            n = int((fillColumn-len(line))/2)
            inserted += n
            k = g.skip_ws(s,i)
            if k > i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    w.setSelectionRange(sel_1,sel_2+inserted)

    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.70: *6* setFillPrefix
def setFillPrefix( self, event ):

    '''Make the selected text the fill prefix.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    self.fillPrefix = s[i:j]
#@+node:ekr.20050920084036.71: *6* _addPrefix
def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt
#@+node:ekr.20110523130519.18194: *4* Fixed bug 583878: Leo should warn about @comment/@delims clashes
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/583878

Leo should warn when a node contains both @comment and @delims directives.
#@+node:ekr.20041005105605.161: *5* at.putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    trace = False and not g.unitTesting
    at = self
    at_comment_seen,at_delims_seen,at_warning_given=False,False,False
        # 2011/05/25: warn if a node contains both @comment and @delims.

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.b)

    p.v.setVisited()
    if trace: g.trace('visit',p.h)
        # Make sure v is never expanded again.
        # Suppress orphans check.
    if not at.thinFile:
        p.v.setWriteBit() # Mark the vnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    at.raw = False # 2007/07/04: Bug fix exposed by new sentinels.
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert next_i > i,'putBody'
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()

    if not trailingNewlineFlag:
        if at.writeVersion5:
            if at.sentinels:
                pass # Never write @nonl
            elif at.atAuto and not at.atEdit:
                at.onl() # 2010/08/01: bug fix: ensure newline here.
        else:
            if at.sentinels:
                at.putSentinel("@nonl")
            elif at.atAuto and not at.atEdit:
                # Ensure all @auto nodes end in a newline!
                at.onl()
#@+node:ekr.20041005105605.162: *6* << Make sure all lines end in a newline >>
@ If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if not trailingNewlineFlag:
        if (at.sentinels or 
            (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
        ):
            # g.trace('Added newline',repr(s))
            s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@+node:ekr.20041005105605.163: *6* << handle line at s[i] >> (putBody)
if trace: g.trace(kind,repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif at.raw:
    if kind == at.endRawDirective:
        at.raw = False
        at.putSentinel("@@end_raw")
        i = g.skip_line(s,i)
    else:
        # Fix bug 784920: @raw mode does not ignore directives 
        at.putCodeLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert not at.pending,'putBody at.pending'
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    # Fix bug 784920: @raw mode does not ignore directives 
    at.error('unmatched @end_raw directive: %s' % p.h)
    # at.raw = False
    # at.putSentinel("@@end_raw")
    # i = g.skip_line(s,i)
elif kind == at.startVerbatim:
    # Fix bug 778204: @verbatim not a valid Leo directive.
    if g.unitTesting:
        # A hack: unit tests for @shadow use @verbatim as a kind of directive.
        pass
    else:
        g.trace(at.atShadow)
        at.error('@verbatim is not a Leo directive: %s' % p.h)
    if 0: # Old code.  This is wrong: @verbatim is not a directive!
        at.putSentinel("@verbatim")
        at.putIndent(at.indent)
        i = next_i
        next_i = g.skip_line(s,i)
        at.os(s[i:next_i])
elif kind == at.miscDirective:
    # Fix bug 583878: Leo should warn about @comment/@delims clashes.
    if g.match_word(s,i,'@comment'):
        at_comment_seen = True
    elif g.match_word(s,i,'@delims'):
        at_delims_seen = True
    if at_comment_seen and at_delims_seen and not at_warning_given:
        at_warning_given = True
        at.error('@comment and @delims in node %s' % p.h)
    at.putDirective(s,i)
else:
    at.error('putBody: can not happen: unknown directive kind: %s' % kind)
#@+node:ekr.20110523130519.18197: *4* Fixed bug 778204: @verbatim not forbidden in body text
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/778204

Leo now generates an error for sentinels that look like @verbatim.
#@+node:ekr.20080709062932.2: *5* atShadowTestCase
class atShadowTestCase (unittest.TestCase):

    '''Support @shadow-test nodes.

    These nodes should have two descendant nodes: 'before' and 'after'.

    '''

    @others

#@+node:ekr.20080709062932.6: *6* __init__
def __init__ (self,c,p,shadowController,lax,trace=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.lax = lax
    self.p = p.copy()
    self.shadowController=shadowController

    # Hard value for now.
    delims = '#','',''
    self.marker = shadowController.markerClass(delims)

    # For teardown...
    self.ok = True
#@+node:ekr.20080709062932.7: *6*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20080709062932.8: *6* setUp & helpers
def setUp (self):

    c = self.c ; p = self.p ; x = self.shadowController

    old = self.findNode (c,p,'old')
    new = self.findNode (c,p,'new')

    self.old_private_lines = self.makePrivateLines(old)
    self.new_private_lines = self.makePrivateLines(new)

    self.old_public_lines = self.makePublicLines(self.old_private_lines)
    self.new_public_lines = self.makePublicLines(self.new_private_lines)

    # We must change node:new to node:old
    self.expected_private_lines = self.mungePrivateLines(self.new_private_lines,'node:new','node:old')

#@+node:ekr.20080709062932.19: *7* findNode
def findNode(self,c,p,headline):
    p = g.findNodeInTree(c,p,headline)
    if not p:
        g.es_print('can not find',headline)
        assert False
    return p
#@+node:ekr.20080709062932.20: *7* createSentinelNode
def createSentinelNode (self,root,p):

    '''Write p's tree to a string, as if to a file.'''

    h = p.h
    p2 = root.insertAsLastChild()
    p2.setHeadString(h + '-sentinels')
    return p2

#@+node:ekr.20080709062932.21: *7* makePrivateLines
def makePrivateLines (self,p):

    c = self.c ; at = c.atFileCommands

    at.write (p,
        nosentinels = False,
        thinFile = False,  # Debatable.
        scriptWrite = True,
        toString = True)

    s = at.stringOutput
    return g.splitLines(s)
#@+node:ekr.20080709062932.22: *7* makePublicLines
def makePublicLines (self,lines):

    x = self.shadowController

    lines,mapping = x.strip_sentinels_with_map(lines,self.marker)

    return lines
#@+node:ekr.20080709062932.23: *7* mungePrivateLines
def mungePrivateLines (self,lines,find,replace):

    x = self.shadowController ; marker = self.marker

    i = 0 ; n = len(lines) ; results = []
    while i < n:
        line = lines[i]
        if marker.isSentinel(line):
            new_line = line.replace(find,replace)
            results.append(new_line)
            if marker.isVerbatimSentinel(line):
                i += 1
                if i < len(lines):
                    line = lines[i]
                    results.append(line)
                else:
                    x.verbatim_error()
        else:
            results.append(line)
        i += 1

    return results
#@+node:ekr.20080709062932.9: *6* tearDown
def tearDown (self):

    pass

    # No change is made to the outline.
    # self.c.redraw()
#@+node:ekr.20080709062932.10: *6* runTest (atShadowTestCase)
def runTest (self,define_g = True):

    x = self.shadowController
    p = self.p.copy()

    results = x.propagate_changed_lines(
        self.new_public_lines,self.old_private_lines,self.marker,p=p)

    if not self.lax and results != self.expected_private_lines:

        # g.pr('%s\natShadowTestCase.runTest:failure\n%s' % ('*' * 40,p.h))
        g.pr(p.h)

        for aList,tag in (
            (results,'results'),
            (self.expected_private_lines,'expected_private_lines')
        ):
            g.pr('%s...' % tag)
            for i, line in enumerate(aList):
                g.pr('%3s %s' % (i,repr(line)))
            g.pr('-' * 40)

        assert results == self.expected_private_lines

    assert self.ok
    return self.ok
#@+node:ekr.20080709062932.11: *6* shortDescription
def shortDescription (self):

    return self.p and self.p.h or '@test-shadow: no self.p'
#@+node:ekr.20100522090453.5912: *5* Fix bugs with @verbatim, @raw and @end_raw
@nocolor-node

> In the @file family of derived files (@thin, @nosent, etc.)  (i.e.,
> not @root), you can prevent any interpretation of the immediately
> following line with the "@verbatim" directive

This is not true, although it might appear to be true.

There is an @verbatim *sentinel*, but no @verbatim *directive*.

For example, I have just verified that the following does not work:

@verbatim
<< undefined ref >>

@raw and @end_raw do work as described.

There appear to be several bugs in this area:

1. Leo probably should warn that @verbatim does not exist as a
directive, although technically Leo is supposed to write anything that
looks like a sentinel but isn't "verbatim".

2. Leo does appear to read @raw and @end_raw properly in @thin files,
but Leo improperly issues the (red) log message,
converting @file format in @thin test_verbatim_sentinel.py
#@+node:ekr.20041005105605.161: *5* at.putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    trace = False and not g.unitTesting
    at = self
    at_comment_seen,at_delims_seen,at_warning_given=False,False,False
        # 2011/05/25: warn if a node contains both @comment and @delims.

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.b)

    p.v.setVisited()
    if trace: g.trace('visit',p.h)
        # Make sure v is never expanded again.
        # Suppress orphans check.
    if not at.thinFile:
        p.v.setWriteBit() # Mark the vnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    at.raw = False # 2007/07/04: Bug fix exposed by new sentinels.
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert next_i > i,'putBody'
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()

    if not trailingNewlineFlag:
        if at.writeVersion5:
            if at.sentinels:
                pass # Never write @nonl
            elif at.atAuto and not at.atEdit:
                at.onl() # 2010/08/01: bug fix: ensure newline here.
        else:
            if at.sentinels:
                at.putSentinel("@nonl")
            elif at.atAuto and not at.atEdit:
                # Ensure all @auto nodes end in a newline!
                at.onl()
#@+node:ekr.20041005105605.162: *6* << Make sure all lines end in a newline >>
@ If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if not trailingNewlineFlag:
        if (at.sentinels or 
            (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
        ):
            # g.trace('Added newline',repr(s))
            s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@+node:ekr.20041005105605.163: *6* << handle line at s[i] >> (putBody)
if trace: g.trace(kind,repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif at.raw:
    if kind == at.endRawDirective:
        at.raw = False
        at.putSentinel("@@end_raw")
        i = g.skip_line(s,i)
    else:
        # Fix bug 784920: @raw mode does not ignore directives 
        at.putCodeLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert not at.pending,'putBody at.pending'
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    # Fix bug 784920: @raw mode does not ignore directives 
    at.error('unmatched @end_raw directive: %s' % p.h)
    # at.raw = False
    # at.putSentinel("@@end_raw")
    # i = g.skip_line(s,i)
elif kind == at.startVerbatim:
    # Fix bug 778204: @verbatim not a valid Leo directive.
    if g.unitTesting:
        # A hack: unit tests for @shadow use @verbatim as a kind of directive.
        pass
    else:
        g.trace(at.atShadow)
        at.error('@verbatim is not a Leo directive: %s' % p.h)
    if 0: # Old code.  This is wrong: @verbatim is not a directive!
        at.putSentinel("@verbatim")
        at.putIndent(at.indent)
        i = next_i
        next_i = g.skip_line(s,i)
        at.os(s[i:next_i])
elif kind == at.miscDirective:
    # Fix bug 583878: Leo should warn about @comment/@delims clashes.
    if g.match_word(s,i,'@comment'):
        at_comment_seen = True
    elif g.match_word(s,i,'@delims'):
        at_delims_seen = True
    if at_comment_seen and at_delims_seen and not at_warning_given:
        at_warning_given = True
        at.error('@comment and @delims in node %s' % p.h)
    at.putDirective(s,i)
else:
    at.error('putBody: can not happen: unknown directive kind: %s' % kind)
#@+node:ekr.20110523201030.18294: *4* Fixed bug 784920: @raw mode does not ignore directives
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/784920

@raw/@end_raw sections do not ignore directives --- so for example, the following code:

@raw
@
bug
@c
@end_raw

produces the following output:

#@verbatim
#@@raw
#@verbatim
#@+at
# bug
#@verbatim
#@@c
#@verbatim
#@@end_raw
#@verbatim
#@-leo
#@+node:ekr.20041005105605.161: *5* at.putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    trace = False and not g.unitTesting
    at = self
    at_comment_seen,at_delims_seen,at_warning_given=False,False,False
        # 2011/05/25: warn if a node contains both @comment and @delims.

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.b)

    p.v.setVisited()
    if trace: g.trace('visit',p.h)
        # Make sure v is never expanded again.
        # Suppress orphans check.
    if not at.thinFile:
        p.v.setWriteBit() # Mark the vnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    at.raw = False # 2007/07/04: Bug fix exposed by new sentinels.
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert next_i > i,'putBody'
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()

    if not trailingNewlineFlag:
        if at.writeVersion5:
            if at.sentinels:
                pass # Never write @nonl
            elif at.atAuto and not at.atEdit:
                at.onl() # 2010/08/01: bug fix: ensure newline here.
        else:
            if at.sentinels:
                at.putSentinel("@nonl")
            elif at.atAuto and not at.atEdit:
                # Ensure all @auto nodes end in a newline!
                at.onl()
#@+node:ekr.20041005105605.162: *6* << Make sure all lines end in a newline >>
@ If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if not trailingNewlineFlag:
        if (at.sentinels or 
            (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
        ):
            # g.trace('Added newline',repr(s))
            s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@+node:ekr.20041005105605.163: *6* << handle line at s[i] >> (putBody)
if trace: g.trace(kind,repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif at.raw:
    if kind == at.endRawDirective:
        at.raw = False
        at.putSentinel("@@end_raw")
        i = g.skip_line(s,i)
    else:
        # Fix bug 784920: @raw mode does not ignore directives 
        at.putCodeLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert not at.pending,'putBody at.pending'
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    # Fix bug 784920: @raw mode does not ignore directives 
    at.error('unmatched @end_raw directive: %s' % p.h)
    # at.raw = False
    # at.putSentinel("@@end_raw")
    # i = g.skip_line(s,i)
elif kind == at.startVerbatim:
    # Fix bug 778204: @verbatim not a valid Leo directive.
    if g.unitTesting:
        # A hack: unit tests for @shadow use @verbatim as a kind of directive.
        pass
    else:
        g.trace(at.atShadow)
        at.error('@verbatim is not a Leo directive: %s' % p.h)
    if 0: # Old code.  This is wrong: @verbatim is not a directive!
        at.putSentinel("@verbatim")
        at.putIndent(at.indent)
        i = next_i
        next_i = g.skip_line(s,i)
        at.os(s[i:next_i])
elif kind == at.miscDirective:
    # Fix bug 583878: Leo should warn about @comment/@delims clashes.
    if g.match_word(s,i,'@comment'):
        at_comment_seen = True
    elif g.match_word(s,i,'@delims'):
        at_delims_seen = True
    if at_comment_seen and at_delims_seen and not at_warning_given:
        at_warning_given = True
        at.error('@comment and @delims in node %s' % p.h)
    at.putDirective(s,i)
else:
    at.error('putBody: can not happen: unknown directive kind: %s' % kind)
#@+node:ekr.20110523130519.18193: *4* Fixed bug 527717: Qt gui should enable/disable menu items
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/527717

What I did:

- qtMenuWrapper.onAboutToShow calls updateFileMenu, updateEditMenu, and
  self.updateOutlineMenu as appropriate.
  
- Completed leoQtMenu.enableMenu.

- added dummy qtBody.hasFocus.
#@+node:ekr.20031218072017.3776: *5* Gui-independent menu enablers
#@+node:ekr.20031218072017.3777: *6* updateAllMenus
def updateAllMenus (self):

    """The Tk "postcommand" callback called when a click happens in any menu.

    Updates (enables or disables) all menu items."""

    # Allow the user first crack at updating menus.
    c = self.c

    if c and c.exists:
        c.setLog()
        p = c.p

        if not g.doHook("menu-update",c=c,p=p,v=p):
            self.updateFileMenu()
            self.updateEditMenu()
            self.updateOutlineMenu()
#@+node:ekr.20031218072017.3778: *6* updateFileMenu
def updateFileMenu (self):

    c = self.c ; frame = c.frame
    if not c: return

    try:
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("File")
        if menu:
            enable(menu,"Revert To Saved", c.canRevert())
            enable(menu,"Open With...", g.app.hasOpenWithMenu)
    except:
        g.es("exception updating File menu")
        g.es_exception()
#@+node:ekr.20031218072017.836: *6* updateEditMenu
def updateEditMenu (self):

    c = self.c ; frame = c.frame
    w = c.frame.body.bodyCtrl
    if not c: return
    try:
        # Top level Edit menu...
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("Edit")
        c.undoer.enableMenuItems()
        << enable cut/paste >>
        if 0: # Always on for now.
            menu = frame.menu.getMenu("Find...")
            enable(menu,"Find Next",c.canFind())
            flag = c.canReplace()
            enable(menu,"Replace",flag)
            enable(menu,"Replace, Then Find",flag)
        # Edit Body submenu...
        menu = frame.menu.getMenu("Edit Body...")
        if menu:
            enable(menu,"Extract Section",c.canExtractSection())
            enable(menu,"Extract Names",c.canExtractSectionNames())
            enable(menu,"Extract",c.canExtract())
            enable(menu,"Match Brackets",c.canFindMatchingBracket())
    except:
        g.es("exception updating Edit menu")
        g.es_exception()
#@+node:ekr.20040130164211: *7* << enable cut/paste >>
if frame.body.hasFocus():
    data = w.getSelectedText()
    canCut = data and len(data) > 0
else:
    # This isn't strictly correct, but we can't get the Tk headline selection.
    canCut = True

enable(menu,"Cut",canCut)
enable(menu,"Copy",canCut)

data = g.app.gui.getTextFromClipboard()
canPaste = data and len(data) > 0
enable(menu,"Paste",canPaste)
#@+node:ekr.20031218072017.3779: *6* updateOutlineMenu
def updateOutlineMenu (self):

    c = self.c ; frame = c.frame
    if not c: return

    p = c.p
    hasParent = p.hasParent()
    hasBack = p.hasBack()
    hasNext = p.hasNext()
    hasChildren = p.hasChildren()
    isExpanded = p.isExpanded()
    isCloned = p.isCloned()
    isMarked = p.isMarked()

    try:
        enable = frame.menu.enableMenu
        << enable top level outline menu >>
        << enable expand/contract submenu >>
        << enable move submenu >>
        << enable go to submenu >>
        << enable mark submenu >>
    except:
        g.es("exception updating Outline menu")
        g.es_exception()
#@+node:ekr.20040131171020: *7* << enable top level outline menu >>
menu = frame.menu.getMenu("Outline")
if menu:
    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Paste Node As Clone",c.canPasteOutline())
    enable(menu,"Clone Node",c.canClone()) # 1/31/04
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Hoist",c.canHoist())
    enable(menu,"De-Hoist",c.canDehoist())
#@+node:ekr.20040131171020.1: *7* << enable expand/Contract submenu >>
menu = frame.menu.getMenu("Expand/Contract...")
if menu:
    enable(menu,"Contract Parent",c.canContractParent())
    enable(menu,"Contract Node",hasChildren and isExpanded)
    enable(menu,"Contract Or Go Left",(hasChildren and isExpanded) or hasParent)
    enable(menu,"Expand Node",hasChildren and not isExpanded)
    enable(menu,"Expand Prev Level",hasChildren and isExpanded)
    enable(menu,"Expand Next Level",hasChildren)
    enable(menu,"Expand To Level 1",hasChildren and isExpanded)
    enable(menu,"Expand Or Go Right",hasChildren)
    for i in range(2,9):
        frame.menu.enableMenu(menu,"Expand To Level " + str(i), hasChildren)
#@+node:ekr.20040131171020.2: *7* << enable move submenu >>
menu = frame.menu.getMenu("Move...")
if menu:
    enable(menu,"Move Down",c.canMoveOutlineDown())
    enable(menu,"Move Left",c.canMoveOutlineLeft())
    enable(menu,"Move Right",c.canMoveOutlineRight())
    enable(menu,"Move Up",c.canMoveOutlineUp())
    enable(menu,"Promote",c.canPromote())
    enable(menu,"Demote",c.canDemote())
#@+node:ekr.20040131171020.3: *7* << enable go to submenu >>
menu = frame.menu.getMenu("Go To...")
if menu:
    enable(menu,"Go To Prev Visited",c.nodeHistory.canGoToPrevVisited())
    enable(menu,"Go To Next Visited",c.nodeHistory.canGoToNextVisited())
    enable(menu,"Go To Prev Visible",c.canSelectVisBack())
    enable(menu,"Go To Next Visible",c.canSelectVisNext())
    if 0: # These are too slow.
        enable(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
        enable(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())
    enable(menu,"Go To Next Clone",isCloned)
    enable(menu,"Go To Prev Node",c.canSelectThreadBack())
    enable(menu,"Go To Next Node",c.canSelectThreadNext())
    enable(menu,"Go To Parent",hasParent)
    enable(menu,"Go To Prev Sibling",hasBack)
    enable(menu,"Go To Next Sibling",hasNext)
#@+node:ekr.20040131171020.4: *7* << enable mark submenu >>
menu = frame.menu.getMenu("Mark/Unmark...")
if menu:
    label = g.choose(isMarked,"Unmark","Mark")
    frame.menu.setMenuLabel(menu,0,label)
    enable(menu,"Mark Subheads",hasChildren)
    if 0: # These are too slow.
        enable(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
        enable(menu,"Mark Changed Roots",c.canMarkChangedRoots())
    enable(menu,"Mark Clones",isCloned)
#@+node:ekr.20031218072017.3780: *6* hasSelection
# Returns True if text in the outline or body text is selected.

def hasSelection (self):

    c = self.c ; w = c.frame.body.bodyCtrl

    if c.frame.body:
        first,last = w.getSelectionRange()
        return first != last
    else:
        return False
#@+node:ekr.20110525072142.18354: *4* Fixed bug 580328: c.frame.toggleSplitDirection() doesn't preserve existing ratio
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/580328

#@+node:ekr.20110525072142.18356: *4* Fixed bug 581031: Scrollbar position is not preserved when c.frame.toggleSplitDirection() is executed
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/581031

toggleSplitDirection new ensures that both the selected outline node *and* the
cursor in the body pane are visible.
#@+node:ekr.20110523130519.18195: *4* Investigated bug 590740: <ctl-b> in subnode of @auto-rst changes focus
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/590740

This works for me.  In any case, it would be a very minor problem.
#@+node:ekr.20110525072142.18357: *4* auto-rst gives spurious overwrite message
#@+node:ekr.20070806141607: *5* at.writeOneAtAutoNode & helpers
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName and not toString: return False

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)
    if not toString and exists and not hasattr(root.v,'at_read') and exists:
        # Prompt if writing a new @auto node would overwrite the existing file.
        ok = self.promptForDangerousWrite(fileName,kind='@auto')
        if not ok:
            g.es("not written:",fileName)
            return
            
    # Create the attribute for all clones.
    root.v.at_read = True
    
    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)

    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    isAtAutoRst = root.isAtAutoRstNode()
    if ok:
        if isAtAutoRst:
            ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
            if not ok2: at.errors += 1
        else:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        # g.trace('at.errors',at.errors)
        if at.errors == 0:
            # g.trace('toString',toString,'force',force,'isAtAutoRst',isAtAutoRst)
            at.replaceTargetFileIfDifferent(root,ignoreBlankLines=isAtAutoRst)
                # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",fileName)
            root.setDirty() # New in Leo 4.4.8.
            root.setOrphan() # 2010/10/22.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        root.setOrphan() # 2010/10/22.
        g.es("not written:",fileName)

    return ok
#@+node:ekr.20110525112110.18406: *4* Investigated bug 784922: No application menus appear on OSX
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/784922

After several hours of work it appears that nothing can be done:
this is a Qt bug.  The loss of menu is a direct result of the call to
tabw.addTab in TabbedFrameFactory.createFrame.

What I did:
    
* Renamed ivars to avoid clashes with ivars in the base class:
    - changed self.master to self.leo_master.
    - changed self.menubar to self.leo_menubar.
    - changed self.ui to self.leo_ui.
#@+node:ekr.20110526083709.18341: *4* Closed bugs 701261 & 583955: Key binding problems
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/701261
https://bugs.launchpad.net/leo-editor/+bug/583955

No changes needed.

- Make sure all widgets have bindings: they do.
    
- no keyboard method to swing focus away from the options panel:
  Invalid: ctrl-g works.
#@+node:ekr.20110526064139.18330: *4* Fixed bug in getSaxUa
#@+node:ekr.20061003093021: *5* getSaxUa
def getSaxUa(self,attr,val,kind=None): # Kind is for unit testing.

    """Parse an unknown attribute in a <v> or <t> element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        # val = str(val)
        val = g.toEncodedString(val) # 2011/02/22.
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_'):
        if type(val) == type(''):
            return val
        elif type(val) == type(b''):
            # 2011/05/26.
            return g.toUnicode(val)

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except Exception:
        # Python 2.x throws TypeError
        # Python 3.x throws binascii.Error
        # Assume that Leo 4.1 wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw','unit test failed: kind=' % repr(kind)
        else:
            g.trace('can not unhexlify %s=%s' % (attr,val))
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError,AttributeError,ValueError):
        g.trace('can not unpickle %s=%s' % (attr,val))
        return val
#@+node:ekr.20110528044139.18275: *4* Fixed recent blunder: Focus got yanked away from some tabs
Binding, Commands
#@+node:ekr.20061031131434.130: *5* keyboardQuit
def keyboardQuit (self,event,setFocus=True):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    if trace: g.trace(g.callers())

    if g.app.quitting:
        return

    # if not inAutoCompleter:
        # k.autoCompleter.exit()
    
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    if setFocus:
        c.endEditing()
        c.bodyWantsFocus()

    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    k.showStateAndMode()
#@+node:ekr.20110528051918.18328: *4* Added bindings to all text widgets in the tab frame
 
#@+node:ekr.20110304061301.14034: *3* Code & cleanup
#@+node:ekr.20110303210002.14033: *4* Eliminated _rootPosition
Also made c.findRootPosition() an alias for c.rootPosition()
#@+node:ekr.20040803140033.2: *5* c.rootPosition
_rootCount = 0

def rootPosition(self):

    """Return the root position.

    Root position is the first position in the document. Other
    top level positions are siblings of this node.
    """

    c = self
    
    # g.trace(self._rootCount) ; self._rootCount += 1

    # 2011/02/25: Compute the position directly.
    if c.hiddenRootNode.children:
        v = c.hiddenRootNode.children[0]
        return leoNodes.position(v,childIndex=0,stack=None)
    else:
        return c.nullPosition()

# For compatibiility with old scripts.
rootVnode = rootPosition
findRootPosition = rootPosition
#@+node:ekr.20110303210002.14032: *5* Found: _rootPosition
#@+node:ekr.20031218072017.2813: *6* << initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
# self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.doubleClickFlag = False
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui
self.ipythonController = None # Set only by the ipython plugin.

# Interlock to prevent setting c.changed when switching chapters.
c.suppressHeadChanged = False

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.changed = False # True if any data has been changed since the last save.
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.hookFunction = None
self.ignoreChangedPaths = False # True: disable path changed message in at.WriteAllHelper.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.nodeConflictList = [] # List of nodes with conflicting read-time data.
self.nodeConflictFileName = None # The fileName for c.nodeConflictList.
self.openDirectory = None
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.
self.timeStampDict = {} # New in Leo 4.6.

# For tangle/untangle
self.tangle_errors = 0

# Global options: set later in initConfigSettings
self.fixed = False
self.page_width = 132
self.sparse_find = True # 2010/02/02: created ivar.
self.sparse_move = True # 2010/02/02: created ivar.
self.sparse_spell = True # 2010/02/02: created ivar.
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False

# Default Tangle options
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = g.u('') # Must always be a string.
self.navTime = None
#@+node:ekr.20040803155551: *6* c.currentPositionIsRootPosition
def currentPositionIsRootPosition (self):

    """Return True if the current position is the root position.

    This method is called during idle time, so not generating positions
    here fixes a major leak.
    """

    c = self
    
    root = c.rootPosition()
    return c._currentPosition and root and c._currentPosition == root

    # return (
        # c._currentPosition and c._rootPosition and
        # c._currentPosition == c._rootPosition)
#@+node:ekr.20040803112450.1: *6* c.isRootPosition
def isRootPosition (self,p):

    c = self
    root = c.rootPosition()
    
    return p and root and p == root # 2011/03/03

    # if p is None or c._rootPosition is None:
        # return False
    # else:
        # return p == c._rootPosition
#@+node:ekr.20040803140033.1: *6* c.setCurrentPosition
_currentCount = 0

def setCurrentPosition (self,p):

    """Set the presently selected position. For internal use only.

    Client code should use c.selectPosition instead."""

    trace = False and not g.unitTesting
    c = self ; cc = c.chapterController

    if trace:
        c._currentCount += 1
        g.trace(c._currentCount,p)
        
    # Always recompute the root position.
    # c.setRootPosition()

    if p and not c.positionExists(p): # 2011/02/25:
        g.warning('Invalid position',p)
        c._currentPosition = c.rootPosition()
        # g.trace('does not exists',p,'\n',g.callers())
        if g.unitTesting: assert False,p
        return

    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p == c._currentPosition:
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@+node:ekr.20040803140033.3: *6* c.setRootPosition (A do-nothing)
def setRootPosition(self,unused_p=None):

    """Set c._rootPosition."""
    
    # 2011/03/03: No longer used.
#@+node:ekr.20110301172720.13971: *4* Investigated eliminating hasattr
# It's probably not worthwhile to try to eliminate these.
#@+node:ekr.20110301172720.13972: *5* qttabs...
#@+node:ekr.20031218072017.2834: *6* c.save
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            if g.app.qt_use_tabs and hasattr(c.frame,'top'):
                c.frame.top.leo_master.setTabName(c,c.mFileName)
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    # Done in fileCommands.save.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocus()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocus()
#@+node:ekr.20031218072017.2989: *6* c.setChanged
def setChanged (self,changedFlag):

    trace = False and not g.unitTesting
    c = self
    if not c.frame: return
    c.changed = changedFlag
    if c.loading: return # don't update while loading.

    if trace: g.trace(changedFlag,g.callers())

    # Clear all dirty bits _before_ setting the caption.
    if not changedFlag:
        for v in c.all_unique_nodes():
            if v.isDirty():
                v.clearDirty()

    if g.app.qt_use_tabs and hasattr(c.frame,'top'):
        c.frame.top.leo_master.setChanged(c,changedFlag)

    s = c.frame.getTitle()
    if len(s) > 2:
        if changedFlag:
            if s [0] != '*': c.frame.setTitle("* " + s)
        else:
            if s[0:2]=="* ": c.frame.setTitle(s[2:])
#@+node:ekr.20031218072017.2835: *6* c.saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
            # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        if g.app.qt_use_tabs and hasattr(c.frame,'top'):
            c.frame.top.leo_master.setTabName(c,c.mFileName)
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)

    # Done in fileCommands.saveAs.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocus()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocus()
#@+node:ekr.20110301172720.13973: *5* qt gui
#@+node:ekr.20040803140033: *6* c.currentPosition (changed)
def currentPosition (self):

    """Return the presently selected position."""

    c = self
    
    if hasattr(c,'_currentPosition') and getattr(c,'_currentPosition'):
        # New in Leo 4.4.2: *always* return a copy.
        return c._currentPosition.copy()
    else:
        return c.nullPosition()

# For compatibiility with old scripts.
currentVnode = currentPosition
#@+node:ekr.20031218072017.2140: *6* c.executeScript & helpers
def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False,
    namespace=None):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        oldLog = g.app.log # 2011/01/19
        log = c.frame.log
        g.app.log = log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # g.pr('*** script',script)
            try:
                p = c.p
                if p: c.setCurrentDirectoryFromContext(p)
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if namespace: d.update(namespace)
                if args:
                    # g.trace('setting sys.argv',args)
                    sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    if g.isPython3:
                        exec(compile(script,scriptFile,'exec'),d)
                    else:
                        execfile(scriptFile,d)
                else:
                    exec(script,d)
                if 0: # This message switches panes, and can be disruptive.
                    if not script1 and not silent:
                        # Careful: the script may have changed the log tab.
                        tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                        g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        g.app.log = oldLog # 2011/01/19
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143: *7* redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@+node:ekr.20110522121957.18230: *7* setCurrentDirectoryFromContext
def setCurrentDirectoryFromContext(self,p):
    
    trace = False and not g.unitTesting
    c = self
    
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    
    curDir = g.os_path_abspath(os.getcwd())

    # g.trace(p.h,'\npath  ',path,'\ncurDir',curDir)
    
    if path and path != curDir:
        if trace: g.trace('calling os.chdir(%s)' % (path))
        try:
            os.chdir(path)
        except Exception:
            pass
#@+node:EKR.20040627100424: *7* unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@+node:ekr.20070115135502: *7* writeScriptFile (changed)
def writeScriptFile (self,script):

    trace = False and not g.unitTesting
    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.homeLeoDir,'scriptFile.py')

    if trace: g.trace(path)                

    # Write the file.
    try:
        if g.isPython3:
            # Use the default encoding.
            f = open(path,encoding='utf-8',mode='w')
        else:
            f = open(path,'w')
        s = script
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,reportErrors=True)
        f.write(s)
        f.close()
    except Exception:
        g.es_exception()
        g.es("Failed to write script to %s" % path)
        # g.es("Check your configuration of script_file_path, currently %s" %
            # c.config.getString('script_file_path'))
        path = None

    return path
#@+node:bobjack.20080509080123.2: *6* c.universalCallback
def universalCallback(self, function):

    """Create a universal command callback.

    Create and return a callback that wraps a function with an rClick
    signature in a callback which adapts standard minibufer command
    callbacks to a compatible format.

    This also serves to allow rClick callback functions to handle
    minibuffer commands from sources other than rClick menus so allowing
    a single function to handle calls from all sources.

    A function wrapped in this wrapper can handle rclick generator
    and invocation commands and commands typed in the minibuffer.

    It will also be able to handle commands from the minibuffer even
    if rclick is not installed.
    """
    def minibufferCallback(event, function=function):

        # Avoid a pylint complaint.
        if hasattr(self,'theContextMenuController'):
            cm = getattr(self,'theContextMenuController')
            keywords = cm.mb_keywords
        else:
            cm = keywords = None

        if not keywords:
            # If rClick is not loaded or no keywords dict was provided
            #  then the command must have been issued in a minibuffer
            #  context.
            keywords = {'c': self, 'rc_phase': 'minibuffer'}

        keywords['mb_event'] = event     

        retval = None
        try:
            retval = function(keywords)
        finally:
            if cm:
                # Even if there is an error:
                #   clear mb_keywords prior to next command and
                #   ensure mb_retval from last command is wiped
                cm.mb_keywords = None
                cm.mb_retval = retval

    minibufferCallback.__doc__ = function.__doc__
    return minibufferCallback

#fix bobjacks spelling error
universallCallback = universalCallback
#@+node:ekr.20061031131434.112: *6* callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@+node:ekr.20070325063303.2: *6* cc.createChapterNode
def createChapterNode (self,chapterName,p=None):

    '''Create an @chapter node for the named chapter.
    Use p for the first child, or create a first child if p is None.'''

    cc = self ; c = cc.c
    current = c.p or c.rootPosition()

    # 2010/06/17: Create an @chapters node if necessary.
    # This is no longer done automatically when creating a new window.
    if not cc.chaptersNode and not cc.findChaptersNode():
        cc.createChaptersNode()
        if hasattr(c.frame.iconBar,'createChaptersIcon'):
            c.frame.iconBar.createChaptersIcon()

    # Create the node with a postion method
    # so we don't involve the undo logic.
    root = current.insertAsLastChild()
    root.initHeadString('@chapter ' + chapterName)
    root.moveToFirstChildOf(cc.chaptersNode)
    if p:
        # Clone p and move it to the first child of the root.
        clone = p.clone()
        clone.moveToFirstChildOf(root)
    else:
        cc.createChild(root,'%s node 1' % chapterName)
    c.setChanged(True)

    return root
#@+node:ekr.20070325104904: *6* cc.finishCreate
def finishCreate (self):

    '''Find or make the @chapters and @chapter trash nodes.'''

    # This must be called late in the init process:
    # at present, called by g.openWithFileName and c.new.

    # g.trace('(chapterController)',g.callers(4))

    cc = self ; c = cc.c

    # Create the @chapters node if needed, and set cc.chaptersNode.
    if 0: # Now done in cc.createChapterNode.
        if not cc.chaptersNode and not cc.findChaptersNode():
            cc.createChaptersNode()

    if cc.findChaptersNode():
        if hasattr(c.frame.iconBar,'createChaptersIcon'):
            c.frame.iconBar.createChaptersIcon()

    # Create the main chapter
    cc.chaptersDict['main'] = chapter(c=c,chapterController=cc,name='main',root=c.rootPosition())

    tag = '@chapter'
    for p in c.all_unique_positions():
        h = p.h
        if h.startswith(tag) and not h.startswith('@chapters'):
            tabName = h[len(tag):].strip()
            if tabName and tabName not in ('main',):
                if cc.chaptersDict.get(tabName):
                    self.error('duplicate chapter name: %s' % tabName)
                else:
                    cc.chaptersDict[tabName] = chapter(c=c,chapterController=cc,name=tabName,root=p)

    # Always select the main chapter.
    # It can be alarming to open a small chapter in a large .leo file.
    cc.selectChapterByName('main',collapse=False)
        # 2010/10/09: an important bug fix!
#@+node:ekr.20051025071455.38: *6* change (spellTab)
def change(self,event=None):
    """Make the selected change to the text"""

    c = self.c ; body = self.body ; w = body.bodyCtrl

    selection = self.tab.getSuggestion()
    if selection:
        # Use getattr to keep pylint happy.
        if hasattr(self.tab,'change_i') and getattr(self.tab,'change_i') is not None:
            start = getattr(self.tab,'change_i')
            end   = getattr(self.tab,'change_j')
            oldSel = start,end
            # g.trace('using',start,end)
        else:
            start,end = oldSel = w.getSelectionRange()
        if start is not None:
            if start > end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocus()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocus()
    return False
#@+node:ekr.20070422093128: *6* computeLabel
def computeLabel (self,w):

    s = w.leo_label_s

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter.name,s)

    return s
#@+node:ekr.20070422094710: *6* createChapterIvar
def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if not hasattr(w,'leo_chapter') or not w.leo_chapter:
        if cc and self.use_chapters:
            w.leo_chapter = cc.getSelectedChapter()
        else:
            w.leo_chapter = None
#@+node:ekr.20051022144825.1: *6* cycleFocus
def cycleFocus (self,event):

    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''

    c = self.c ; k = c.k ; w = event.widget

    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    # A hack for the Qt gui.
    if hasattr(w,'logCtrl'):
        w = w.logCtrl

    panes = [body,log,tree]

    # g.trace(w in panes,event.widget,panes)

    if w in panes:
        i = panes.index(w) + 1
        if i >= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body

    # Warning: traces mess up the focus
    # g.pr(g.app.gui.widget_name(w),g.app.gui.widget_name(pane))

    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    k.newMinibufferWidget = pane
    k.showStateAndMode()
#@+node:tbrown.20080509212202.7: *6* deleteRecentFilesMenuItems
def deleteRecentFilesMenuItems(self,menu):
    """Delete recent file menu entries"""

    toDrop = len(self.c.recentFiles)
    if hasattr(self, 'recentFilesStatic'):
        toDrop += len(self.recentFilesStatic)

    self.delete_range(menu,0,toDrop)

    if hasattr(self, 'groupedMenus'):
        for i in self.groupedMenus:
            menu = self.getMenu(i)
            if menu:
                self.destroy(menu)
                self.destroyMenu(i)
#@+node:ekr.20070301171901: *6* do nothings
def alert (self,message):
    pass

def attachLeoIcon (self,w):
    pass

def createRootWindow(self):
    pass

def destroySelf (self):
    pass

def finishCreate (self):
    pass

def getIconImage (self, name):
    return None

def getTreeImage(self,c,path):
    return None

def getTextFromClipboard (self):
    return self.clipboardContents

def get_focus(self,frame=None):
    if not frame: return None
    return self.focusWidget or (hasattr(frame,'body') and frame.body.bodyCtrl) or None 

def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    return g.app.config.defaultFont

def get_window_info (self,window):
    return 0,0,0,0

def replaceClipboardWith (self,s):
    self.clipboardContents = s

def set_focus(self,commander,widget):
    self.focusWidget = widget
#@+node:ekr.20070425180705: *6* findEditorForChapter (leoBody)
def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    c = self.c ; d = self.editorWidgets ; values = list(d.values())

    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w,'leo_p') and w.leo_p and w.leo_p == p
            ):
                # g.trace('***',id(w),'match chapter and p',p.h)
                return w

    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            # g.trace('***',id(w),'match only chapter',p.h)
            return w

    # As a last resort, return the present editor widget.
    # g.trace('***',id(self.bodyCtrl),'no match',p.h)
    return c.frame.body.bodyCtrl
#@+node:ekr.20031218072017.3085: *6* initBatchText, initNextText & init_s_ctrl
# Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self,ins=None):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.h, p.b)
    self.init_s_ctrl(s,ins)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self,ins=None):
    c,p = self.c,self.p
    s = g.choose(self.in_headline,p.h, p.b)
    if True:
        tree = c.frame and c.frame.tree
        if tree and hasattr(tree,'killEditing'):
            # g.trace('kill editing before find')
            tree.killEditing()
    self.init_s_ctrl(s,ins)

def init_s_ctrl (self,s,ins):

    w = self.s_ctrl
    w.setAllText(s)
    if ins is None:
        ins = g.choose(self.reverse,len(s),0)
        # print(g.choose(self.reverse,'.','*'),)
    else:
        pass # g.trace('ins',ins)
    w.setInsertPoint(ins)
#@+node:ekr.20050920084036.147: *6* measure
def measure (self,w):

    if hasattr(w,'linesPerPage'):
        # Preferred.  Qt implements this.
        n = w.linesPerPage()
        return max(2,n-3)
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        start, junk = g.convertPythonIndexToRowCol(s,ins)
        start += 1 ; delta = 0
        ustart = start - 1
        while ustart >= 1 and w.indexIsVisible('%s.0' % ustart):
            delta += 1 ; ustart -= 1

        ustart = start + 1
        while w.indexIsVisible('%s.0' % ustart):
            delta += 1 ; ustart += 1

        return delta
#@+node:ekr.20100109094541.6231: *6* moveWithinLineHelper
def moveWithinLineHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    # g.trace(hasattr(w,'leoMoveCursorHelper'))

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,j = g.getLine(s,ins)
        if spot == 'start-line':
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'end-line':
            # if g.match(s,i-1,'\n'): i -= 1
            self.moveToHelper(event,j,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@+node:ekr.20060530210057: *6* select/unselectLabel
def unselectLabel (self,w):

    self.createChapterIvar(w)
    self.packEditorLabelWidget(w)
    s = self.computeLabel(w)
    if hasattr(w,'leo_label') and w.leo_label:
        w.leo_label.configure(text=s,bg='LightSteelBlue1')

def selectLabel (self,w):

    if self.numberOfEditors > 1:
        self.createChapterIvar(w)
        self.packEditorLabelWidget(w)
        s = self.computeLabel(w)
        # g.trace(s,g.callers())
        if hasattr(w,'leo_label') and w.leo_label:
            w.leo_label.configure(text=s,bg='white')
    elif hasattr(w,'leo_label') and w.leo_label:
        w.leo_label.pack_forget()
        w.leo_label = None
#@+node:ekr.20070423102603: *6* selectEditorHelper
def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    trace = False

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if trace:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    self.inactivateActiveEditor(w)

    # The actual switch.
    c.frame.body.bodyCtrl = w
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if trace:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    # g.trace('expanding ancestors of ',w.leo_p.h,g.callers())
    c.redraw(w.leo_p)
    c.recolor()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocus()
    return 'break'
#@+node:ekr.20061017083312.1: *7* << restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
#@+node:ekr.20090608081524.6109: *6* setBodyTextAfterSelect
def setBodyTextAfterSelect (self,p,old_p):

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = p.v.b # Guaranteed to be unicode.
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s,new_p=p)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    p.restoreCursorAndScroll(w)
#@+node:ekr.20061031131434.192: *6* showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
        
    isText = g.app.gui.isTextWidget(w)

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()
    
    # 2011/02/12: get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree,'getWrapper'):
            if hasattr(w,'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2,item=None)
            isText = bool(w) # A benign hack.

    if trace: g.trace('state: %s text?: %s w: %s' % (
        state,isText,w))

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and isText:
        k.showStateColors(inOutline,w)
        k.showStateCursor(state,w)
#@+node:ekr.20080512115455.1: *6* showStateColors
def showStateColors (self,inOutline,w):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; state = k.unboundKeyAction

    # body = c.frame.body ; bodyCtrl = body.bodyCtrl
    w_name = g.app.gui.widget_name(w)

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    if trace: g.trace('%9s' % (state),w_name)
    
    if w_name.startswith('body'):
        w = c.frame.body
    elif w_name.startswith('head'):
        pass
    else:
        # Don't recolor the minibuffer, log panes, etc.
        if trace: g.trace('not body or head')
        return

    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    if hasattr(w,'setEditorColors'):
        # Note: fg color has no effect on Qt at present.
        w.setEditorColors(bg=bg,fg=fg) ### Was body.
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            pass # g.es_exception()
#@+node:ekr.20070424084012: *6* switchToChapter (leoBody)
def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocus()
#@+node:ekr.20110301172720.13975: *6* Uses leoMoveCursorHelper
#@+node:ekr.20060113105246.1: *7* moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    trace = False

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=direction,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        # Find the start of the next/prev line.
        row,col = g.convertPythonIndexToRowCol(s,ins)
        if trace:
            gui_ins = w.toGuiIndex(ins)
            bbox = w.bbox(gui_ins)
            if bbox:
                x,y,width,height = bbox
                # bbox: x,y,width,height;  dlineinfo: x,y,width,height,offset
                g.trace('gui_ins',gui_ins,'dlineinfo',w.dlineinfo(gui_ins),'bbox',bbox)
                g.trace('ins',ins,'row',row,'col',col,'event.x',event.x,'event.y',event.y)
                g.trace('subtracting line height',w.index('@%s,%s' % (x,y-height)))
                g.trace('adding      line height',w.index('@%s,%s' % (x,y+height)))
        i,j = g.getLine(s,ins)
        if direction == 'down':
            i2,j2 = g.getLine(s,j)
        else:
            i2,j2 = g.getLine(s,i-1)

        # The spot is the start of the line plus the column index.
        n = max(0,j2-i2-1) # The length of the new line.
        col2 = min(col,n)
        spot = i2 + col2
        if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

        self.extendHelper(w,extend,spot,upOrDown=True)
#@+node:ekr.20100109094541.6227: *7* moveToBufferHelper
def moveToBufferHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        if spot == 'home':
            self.moveToHelper(event,0,extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event,len(s),extend=extend)
        else:
            g.trace('can not happen: bad spot',spot)
#@+node:ekr.20100109094541.6228: *7* moveToCharacterHelper
def moveToCharacterHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i=max(0,i-1)
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'right':
            i = min(i+1,len(w.getAllText()))
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@+node:ekr.20050920084036.136: *7* exchangePointMark
def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind='exchange',extend=False)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange(sort=False)
        if i == j: return

        ins = w.getInsertPoint()
        ins = g.choose(ins==i,j,i)
        w.setInsertPoint(ins)
        w.setSelectionRange(i,j,insert=None)
#@+node:ekr.20090530181848.6035: *7* movePageHelper
def movePageHelper(self,event,kind,extend): # kind in back/forward.

    '''Move the cursor up/down one page, possibly extending the selection.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    linesPerPage = 15 # To do.

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(
            kind=g.choose(kind=='forward','page-down','page-up'),
            extend=extend,linesPerPage=linesPerPage)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row,col = g.convertPythonIndexToRowCol(s,ins)
        row2 = g.choose(kind=='back',
            max(0,row-linesPerPage),
            min(row+linesPerPage,len(lines)-1))
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s,row2,col,lines=lines)
        if trace: g.trace('spot',spot,'row2',row2)
        self.extendHelper(w,extend,spot,upOrDown=True)
#@+node:ekr.20110301172720.13976: *6* Uses scrollDelegate
#@+node:ekr.20060113082917: *7* scrollHelper
def scrollHelper (self,event,direction,distance):

    '''Scroll the present pane up or down one page
    kind is in ('up/down-half-page/line/page)'''

    k = self.k ; c = k.c ; gui = g.app.gui
    w = gui.eventWidget(event)

    if not w: return

    if hasattr(w,'scrollDelegate'):
        kind = direction + '-' + distance
        w.scrollDelegate(kind)
    else:
        self.tkScrollHelper(event,direction,distance)

def tkScrollHelper (self,event,direction,distance,extend=None):
    #Scroll body pane up/down (direction) by page/half-page/line (distance)
    #Note: Currently moves cursor, scrolls if needed to keep cursor visible
    k = self.k ; c = k.c ; gui = g.app.gui
    w = gui.eventWidget(event)
    if not w: return #  This does **not** require a text widget.

    if gui.isTextWidget(w):
        c.widgetWantsFocusNow(w)
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.getInsertPoint()
        s = w.getAllText()
        row,col = g.convertPythonIndexToRowCol(s,ins1)
        # Compute the spot.
        # assume scroll by "page"
        delta = self.measure(w)
        if distance == 'half-page':
            delta = delta / 2
        elif distance == 'line':
            delta = 1
        row1 = g.choose(direction=='down',row+delta,row-delta)
        row1 = max(0,row1)
        spot = g.convertRowColToPythonIndex(s,row1,col)
        # g.trace('spot',spot,'row1',row1)
        self.extendHelper(w,extend,spot)
        w.seeInsertPoint()
#@+node:ekr.20060309060654.1: *7* scrollOutlineUp/Down/Line/Page
def scrollOutlineDownLine (self,event=None):
    '''Scroll the outline pane down one line.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('down-line')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if b < 1.0: tree.canvas.yview_scroll(1,"unit")

def scrollOutlineDownPage (self,event=None):
    '''Scroll the outline pane down one page.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('down-page')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if b < 1.0: tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    '''Scroll the outline pane up one line.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('up-line')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if a > 0.0: tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    '''Scroll the outline pane up one page.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('up-page')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if a > 0.0: tree.canvas.yview_scroll(-1,"page")
#@+node:ekr.20060726154531: *7* scrollOutlineLeftRight
def scrollOutlineLeft (self,event=None):
    '''Scroll the outline left.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('left')
    elif hasattr(tree.canvas,'xview_scroll'):
        tree.canvas.xview_scroll(1,"unit")

def scrollOutlineRight (self,event=None):
    '''Scroll the outline left.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('right')
    elif hasattr(tree.canvas,'xview_scroll'):
        tree.canvas.xview_scroll(-1,"unit")
#@+node:ekr.20051206103652: *6* widget_name (leoGui)
def widget_name (self,w):

    # First try the widget's getName method.
    if not 'w':
        return '<no widget>'
    elif hasattr(w,'getName'):
        return w.getName()
    elif hasattr(w,'_name'):
        return w._name
    else:
        return repr(w)
#@+node:ekr.20110307195735.14243: *4* Can clicking an item set the current position?
#@+node:ekr.20031218072017.2997: *5* c.selectPosition
def selectPosition(self,p):

    """Select a new position."""

    c = self ; cc = c.chapterController

    if cc:
        cc.selectChapterForPosition(p)

    # g.trace(p.h,g.callers())

    c.frame.tree.select(p)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
#@+node:ekr.20040803072955.128: *5* leoTree.select & helpers
tree_select_lockout = False

def select (self,p,scroll=True):

    '''Select a node.
    Never redraws outline, but may change coloring of individual headlines.
    The scroll argument is used by tk to suppress scrolling while dragging.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        c = self.c ; old_p = c.p
        val = 'break'
        self.tree_select_lockout = True
        c.frame.tree.beforeSelectHint(p,old_p)
        val = self.selectHelper(p,scroll=scroll)
    finally:
        self.tree_select_lockout = False
        c.frame.tree.afterSelectHint(p,old_p)

    return val  # Don't put a return in a finally clause.
#@+node:ekr.20070423101911: *6* selectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace:
        if old_p:
            g.trace('old: %s %s new: %s %s' % (
                len(old_p.b),old_p.h,len(p.b),p.h))
        else:
            g.trace('old: <none> new: %s %s' % (len(p.b),p.h))

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.p here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        # 2010/08/01: (qt only) update history when body text gets focus.
        # This is done in qtGui.py: onFocusIn.
        # 2011/04/02: Undo the change in rev 3194:
        # I have absolutely no idea what I was thinking about.
        if True: # g.app.gui.guiName() != 'qt':
            c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    if trace: g.trace('**** after old: %s new %s' % (
        old_p and len(old_p.b),len(p.b)))

    # what UNL.py used to do
    c.frame.clearStatusLine()
    c.frame.putStatusLine("-->".join(reversed(
        [i.h for i in p.self_and_parents()])))

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129: *7* << unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p != p: # 2010/02/11: Don't change the *new* node's insert point!
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
#@+node:ekr.20040803072955.130: *7* << select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@+node:ekr.20040803072955.133: *7* << set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

c.treeFocusHelper() # 2010/12/14
c.undoer.onSelect(old_p,p)
#@+node:ekr.20090608081524.6109: *6* setBodyTextAfterSelect
def setBodyTextAfterSelect (self,p,old_p):

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = p.v.b # Guaranteed to be unicode.
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s,new_p=p)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    p.restoreCursorAndScroll(w)
#@+node:ekr.20110510052422.14617: *4* Use c.alert rather than g.alert
#@+node:ekr.20040310062332.1: *5* p.invalidOutline
def invalidOutline (self, message):

    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    p.v.context.alert("invalid outline: %s\n%s" % (message,node))
#@+node:ekr.20070910105044.1: *5* c.checkDrag
def checkDrag (self,root,target):

    """Return False if target is any descendant of root."""

    c = self
    message = "Can not drag a node into its descendant tree."

    for z in root.subtree():
        if z == target:
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            else:
                c.alert(message)
            return False
    return True
#@+node:ekr.20070910105044: *5* c.checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""
    
    c = self

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedVnodes = {}
    for ancestor in parent.self_and_parents():
        if ancestor.isCloned():
            v = ancestor.v
            clonedVnodes[v] = v

    if not clonedVnodes:
        return True

    for p in root.self_and_subtree():
        if p.isCloned() and clonedVnodes.get(p.v):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                c.alert(message)
            return False
    return True
#@+node:ekr.20031218072017.3105: *5* g.alert
def alert(message,c=None):
    
    '''Raise an alert.
    
    This method is deprecated: use c.alert instead.
    '''

    # The unit tests just tests the args.
    if not g.unitTesting:
        g.es(message)
        g.app.gui.alert(c,message)
#@+node:ekr.20110510052422.14618: *5* c.alert
def alert(self,message):
    
    c = self

    # The unit tests just tests the args.
    if not g.unitTesting:
        g.es(message)
        g.app.gui.alert(c,message)
#@+node:ekr.20101124124316.5841: *4* Menus & dialogs say "Flatten Selected Outline"
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/626587

I ask that you please look at this from the newbie perspective that I
have.

If the menu choice said Flatten Selected Outline, or even Flatten
Selected Node, then I would have understood immediately what would
happen on its execution. But the menu choice says neither of these -- it
says Flatten Outline. That gives me a different expectation of what it
will do.
#@+node:ekr.20110527084258.18381: *4* Removed show/hide/toggle minibuffer commands
#@+node:ekr.20061031131434.116: *5* k.show/hide/toggleMinibuffer
def hideMinibuffer (self,event):
    '''Hide the minibuffer.'''
    k = self ; c = k.c
    c.frame.hideMinibuffer()
    g.es('minibuffer hidden',color='red')
    for commandName in ('show-mini-buffer','toggle-mini-buffer'):
        shortcut = k.getShortcutForCommandName(commandName)
        if shortcut:
            g.es('',commandName,'is bound to:',shortcut)

def showMinibuffer (self,event):
    '''Show the minibuffer.'''
    k = self ; c = k.c
    c.frame.showMinibuffer()

def toggleMinibuffer (self,event):
    '''Show or hide the minibuffer.'''
    k = self ; c = k.c
    if c.frame.minibufferVisible:
        k.hideMinibuffer(event)
    else:
        k.showMinibuffer(event)
#@+node:ekr.20101218103123.5932: *3* Docs
#@+node:ekr.20101214101416.5950: *4* Creating minimal outlines
#@+node:ekr.20101214101416.5951: *5* script
import leo.core.leoGui as leoGui
nullGui = leoGui.nullGui("nullGui")
c2,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,gui=nullGui)
c2.frame.createFirstTreeNode()
for p in c2.all_positions():
    g.es(p.h)
#@+node:ekr.20031218072017.1623: *5* c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    # Send all log messages to the new frame.
    g.app.setLog(None)
    g.app.lockLog()
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)
    g.doHook("new",old_c=self,c=c,new_c=c)
    g.app.unlockLog()

    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c)
    c.setLog()
    c.redraw()
    return c # For unit test.
#@+node:ekr.20031218072017.2188: *5* app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leo.core.leoCommands as leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    << compute the window title >>

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    # This takes about 3/4 sec when called by the leoBridge module.
    c = leoCommands.Commands(frame,fileName,
        relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c)
            # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    return c,frame
#@+node:ekr.20031218072017.2189: *6* << compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@+node:ekr.20110111100539.9727: *4* Docs fixes
(Fixed) Using ZODB with Leo  Leo v4.8 documentation
http://diigo.com/0dw79

(Fixed) Embedding Leo with the leoBridge module  Leo v4.8 documentation
http://diigo.com/0dw77
#@+node:ekr.20110518103946.18181: *4* Clarification: we can not allow Leo settings to change qt-stylesheets
@nocolor-node

Are color-settings gui-toolkit dependent?

In my ~/.leo/myLeoSettings.leo I changed @settings->Colors-> @color body_text_selection_foreground_color = black
(the value before was `white`).

Unfortunately the foreground of the selected text still is white, at least if I use the qt gui (which is default on my system and which I like more).

So my questions:

Are the color-settings gui-toolkit dependent?

How (or where) can I change the colors used for qt?

Is there a way to print the settings files (with full path) which leo reads on startup?
(I think this would help to prevent confusion in the various ways to specify settings for new users.)

=====================================


At last I see what is going on.  The selection colors are set in the node:

@data qt-gui-plugin-style-sheet

Apparently the selection colors can *only* be set there: it looks like
the separate @color settings for selections do not work.

This is quite a mess.  It arose because originally I did not realize
that it was possible to use "mini" stylesheets to set individual
selector dynamically.  When I made the discovery, I supported some,
but not all settings.

Of course, I should support all settings.  I'll see what I can do...
#@+node:ekr.20110518140548.18148: *5* Response
@nocolor-node

After further reflection, there does not seem to be much that can be done.

Suppose, for example, that Leo converts an @setting node to a mini
stylesheet.  (In fact, Leo sometimes does do this, in other contexts.)
 We now have a conundrum: which should take precedence: the @data
qt-gui-plugin-style-sheet setting or the @color
body_text_selection_foreground_color setting?

Rather than open that can of worms, the best solution seems to be to
declare that yes, some settings *are* gui dependent.  Use @data
qt-gui-plugin-style-sheet to set those settings.
#@+node:ekr.20101218103123.5931: *3* Features
#@+node:ekr.20101127152442.5915: *4* Improved handling of @url nodes
@nocolor

The new rule is simple: if the body text contains any text the first line of the
body text is taken to be the url. There is no longer any need to put '--' in the
headline.

More importantly, you can put anything you like in the body text following the
first line. Other url's, notes, even .. graphics:: directives for the
viewrendered plugin.

These improvements allow Leo to be what it should have been a long time ago: the
world's best organizer of url's.

@color

My typical usage is::

    @url fizbatz: short description of fizbatz (headline)
    http://fizbatz.org (body text)
    @language rest
    Why I care about fizbatz.
#@+node:ekr.20031218072017.2312: *5* tree.OnIconDoubleClick (@url) & helper
# Several plugins handle url's, especially UNL.py.

def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.h.strip()
    if g.match_word(s,0,"@url"): 
        if p.b.strip():
            lines = p.b.split('\n',1)
            url = lines and lines[0].strip() or ''
        else:
            url = s[4:].strip()
        # g.trace(url,g.callers())

        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            g.handleUrlInUrlNode(url, c=c, p=p)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06
#@+node:ekr.20110119063247.6086: *4* Improved clean-all-lines command
@nocolor-node

It is now much faster and has better feedback.
#@+node:ekr.20060415112257: *5* cleanLines
def cleanLines (self,event):

    '''Removes leading whitespace from otherwise blanks lines.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()

    lines = [] ; changed = False
    for line in g.splitlines(s):
        if line.strip():
            lines.append(line)
        else:
            if line.endswith('\n'):
                lines.append('\n')
            changed = changed or '\n' != line

    if changed:
        self.beginCommand(undoType='clean-lines')
        result = ''.join(lines)
        if w.hasSelection():
            i,j = w.getSelectionRange()
            w.delete(i,j)
            w.insert(i,result)
            w.setSelectionRange(i,j+len(result))
        else:
            w.delete(0,'end')
            w.insert(0,result)
        self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20070325094935: *5* cleanAllLines
def cleanAllLines (self,event):

    '''Clean all lines in the selected tree.'''

    c = self.c ; current = c.p ; u = c.undoer
    w = c.frame.body.bodyCtrl
    if not w: return

    tag = 'clean-all-lines'
    u.beforeChangeGroup(c.p,tag)
    n = 0
    # g.es('cleaning',c.p.h)
    for p in c.p.self_and_subtree():
        lines = []
        for s in g.splitLines(p.b):
            if s.strip():
                lines.append(s)
            else:
                # Ensures a trailing newline.
                lines.append('\n')
        s2 = ''.join(lines)
        if s2 != p.b:
            print(p.h)
            bunch = u.beforeChangeNodeContents(p,oldBody=p.b,oldHead=p.h)
            p.b = s2
            p.v.setDirty()
            n += 1
            u.afterChangeNodeContents(p,tag,bunch)

    u.afterChangeGroup(c.p,tag)
    c.redraw_after_icons_changed()
    g.es('cleaned %s nodes' % n)
#@+node:ekr.20110120114224.12563: *4* The first loaded file sets tabbed gui size
#@+node:ekr.20110122083721.12582: *5* Reading...
#@+node:ekr.20090519143741.5917: *6* doPostPluginsInit & helpers (runLeo.py)
def doPostPluginsInit(args,files,options):

    '''Return True if the frame was created properly.'''

    g.init_sherlock(args)  # Init tracing and statistics.
    # if g.app and g.app.use_psyco: startPsyco()

    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.

    # Create the main frame.  Show it and all queued messages.
    c,c1,fileName = None,None,None
    for fileName in files:
        c,frame = createFrame(fileName,options)
        if frame:
            if not c1: c1 = c
        else:
            g.trace('createFrame failed',repr(fileName))
            return False
          
    # Put the focus in the first-opened file.  
    if not c:
        c,frame = createFrame(None,options)
        c1 = c
        if c and frame:
            fileName = c.fileName()
        else:
            g.trace('createFrame failed 2')
            return False
            
    # For qttabs gui, select the first-loaded tab.
    if hasattr(g.app.gui,'frameFactory'):
        factory = g.app.gui.frameFactory
        if factory and hasattr(factory,'setTabForCommander'):
            c = c1
            factory.setTabForCommander(c)

    # Do the final inits.
    c.setLog() # 2010/10/20
    g.app.logInited = True # 2010/10/20
    finishInitApp(c)
    p = c.p
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook(idleTimeDelay=500)
        # 2011/05/10: always enable this.
    initFocusAndDraw(c,fileName)

    screenshot_fn = options.get('screenshot_fn')
    if screenshot_fn:
        make_screen_shot(screenshot_fn)
        return False # Force an immediate exit.

    return True
#@+node:ekr.20031218072017.1624: *7* createFrame & helpers (runLeo.py)
def createFrame (fileName,options):

    """Create a LeoFrame during Leo's startup process."""
    
    # g.trace('(runLeo.py)',fileName)

    script = options.get('script')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(fileName,None)
        c2 = frame.c
        select = options.get('select')
        windowSize = options.get('windowSize')
        if select: doSelect(c2,select)
        if windowSize: doWindowSize(c2,windowSize)
        if ok: return c2,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        initEditCommanders=True)

    if not script:
        g.app.writeWaitingLog(c) # 2009/12/22: fixes bug 448886

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False)
            # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@+node:ekr.20100913171604.5888: *8* doSelect
def doSelect (c,s):

    '''Select the node with key s.'''

    p = findNode(c,s)

    if p:
        c.selectPosition(p)
    else:
        g.es_print('--select: not found:',s)
#@+node:ekr.20100913171604.5885: *8* doWindowSize
def doWindowSize (c,windowSize):

    w = c.frame.top

    try:
        h,w2 = windowSize.split('x')
        h,w2 = int(h.strip()),int(w2.strip())
        w.resize(w2,h) # 2010/10/08.
        c.k.simulateCommand('equal-sized-panes')
        c.redraw()
        w.repaint() # Essential
    except Exception:
        print('doWindowSize:unexpected exception')
        g.es_exception()
#@+node:ekr.20100913171604.5889: *8* findNode
def findNode (c,s):

    s = s.strip()

    # First, assume s is a gnx.
    for p in c.all_unique_positions():
        if p.gnx.strip() == s:
            return p

    for p in c.all_unique_positions():
        # g.trace(p.h.strip())
        if p.h.strip() == s:
            return p

    return None
#@+node:ekr.20080921060401.5: *7* finishInitApp (runLeo.py)
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@+node:ekr.20080921060401.6: *7* initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@+node:ekr.20100914142850.5894: *7* make_screen_shot
def make_screen_shot(fn):

    '''Create a screenshot of the present Leo outline and save it to path.'''

    # g.trace('runLeo.py',fn)

    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
#@+node:ekr.20110122083721.12583: *5* Writing...
#@+node:ekr.20031218072017.3037: *6* putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    trace = False and not g.unitTesting
    c = self.c

    use_db = g.enableDB and c.mFileName
    if use_db:
        if trace: g.trace(c.mFileName)
        c.cacher.setCachedGlobalsElement(c.mFileName)

    # Always put positions, to trigger sax methods.
    self.put("<globals")
    << put the body/outline ratios >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20031218072017.3038: *7* << put the body/outline ratios >>
self.put(" body_outline_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.ratio)))

self.put(" body_secondary_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.secondary_ratio)))

if trace: g.trace('fixed or use_db',c.fixed or use_db,
    '%1.2f %1.2f' % (c.frame.ratio,c.frame.secondary_ratio))
#@+node:ekr.20031218072017.3039: *7* << put the position of this frame >>
# New in Leo 4.5: support fixed .leo files.

if c.fixed or use_db:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@+node:ekr.20031218072017.3040: *7* << put the position of the log window >>
top = left = height = width = 0 # no longer used

self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@+node:ekr.20100208082353.5929: *6* setCachedGlobalsElement
def setCachedGlobalsElement(self,fn):

    trace = False and not g.unitTesting
    c = self.c

    if not c:
        return g.internalError('no commander')

    globals_tag = g.choose(g.isPython3,'leo3k.globals','leo2k.globals')
    key = self.fileKey(fn,globals_tag)

    if trace: g.trace(c.mFileName,key,g.callers(5))

    self.db['body_outline_ratio_%s' % key] = str(c.frame.ratio)
    self.db['body_secondary_ratio_%s' % key] = str(c.frame.secondary_ratio)
    if trace: g.trace('ratios: %1.2f %1.2f' % (
        c.frame.ratio,c.frame.secondary_ratio))

    width,height,left,top = c.frame.get_window_info()

    self.db['window_position_%s' % key] = (
        str(top),str(left),str(height),str(width))
    if trace:
        g.trace('top',top,'left',left,'height',height,'width',width)
#@+node:ekr.20110210081557.15387: *4* Show sources in print-bindings
#@+node:ekr.20061031131434.88: *5* k.Binding
#@+node:ekr.20061031131434.89: *6* bindKey
def bindKey (self,pane,shortcut,callback,commandName,_hash=None,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    _hash gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %30s %s' % (pane,shortcut,commandName,_hash))
        g.trace(g.callers())
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName,_hash=_hash)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90: *7* << give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@+node:ekr.20061031131434.92: *7* << remove previous conflicting definitions from bunchList >>
# b is the bunch for the new binding.

### This warning should never happen with the new code in makeBindingsFromCommandsDict.

if not modeFlag and self.warn_about_redefined_shortcuts:
    
    redefs = [b2 for b2 in bunchList
        if b2.commandName != commandName and
            # pane != b2.pane and # 2011/02/11: don't give warning for straight substitution.
            pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]

    if redefs:
        def pr(commandName,pane,theHash):
            g.es_print('%30s in %5s from %s' % (commandName,pane,theHash))
    
        g.warning('shortcut conflict for %s' % c.k.prettyPrintKey(shortcut))
        pr(commandName,pane,_hash)
        for z in redefs:
            pr(z.commandName,z.pane,z._hash)

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@+node:ekr.20061031131434.93: *6* bindKeyToDict
def bindKeyToDict (self,pane,stroke,func,commandName):

    k = self
    d =  k.masterBindingsDict.get(pane,{})

    stroke = g.stripBrackets(stroke)

    # if commandName == 'full-command':
        # g.trace('%-4s %-18s %-40s %s' % (
            # pane,repr(stroke),commandName,func and func.__name__),g.callers())

    # New in Leo 4.4.1: Allow redefintions.
    d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
    k.masterBindingsDict [pane] = d
#@+node:ekr.20061031131434.94: *6* bindOpenWith
def bindOpenWith (self,shortcut,name,data):

    '''Register an open-with command.'''

    k = self ; c = k.c

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
#@+node:ekr.20061031131434.95: *6* checkBindings
def checkBindings (self):

    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''

    k = self ; c = k.c

    if not c.config.getBool('warn_about_missing_settings'): return

    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@+node:ekr.20070218130238: *6* dumpMasterBindingsDict
def dumpMasterBindingsDict (self):

    k = self ; d = k.masterBindingsDict

    g.pr('\nk.masterBindingsDict...\n')

    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            b = d2.get(key2)
            g.pr('%20s %s' % (key2,b.commandName))
#@+node:ekr.20061031131434.96: *6* k.completeAllBindingsForWidget
def completeAllBindingsForWidget (self,w):

    k = self ; d = k.bindingsDict

    # g.trace('w',w,'Alt+Key-4' in d)

    for stroke in d:
        k.makeMasterGuiBinding(stroke,w=w)
#@+node:ekr.20061031131434.97: *6* k.completeAllBindings
def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict:
        k.makeMasterGuiBinding(stroke,w=w)
#@+node:ekr.20061031131434.98: *6* k.makeAllBindings
def makeAllBindings (self):

    k = self ; c = k.c

    # g.trace(c.fileName(),g.callers())

    k.bindingsDict = {}
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    if c.frame.statusLine: c.frame.statusLine.setBindings()
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
#@+node:ekr.20061031131434.99: *6* k.initAbbrev
def initAbbrev (self):

    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev:',key,'unknown command name:',commandName,color='blue')
#@+node:ekr.20061031131434.100: *6* addModeCommands (enterModeCallback)
def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d:

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        # g.trace(f.__name__,key)
#@+node:ekr.20061031131434.101: *6* initSpecialIvars
def initSpecialIvars (self):

    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn  = c.config.getBool('warn_about_missing_settings')

    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey','auto-complete-force'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
#@+node:ekr.20061031131434.102: *6* makeBindingsFromCommandsDict & helper
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bunches b with b.val equal to the stroke.
    d = c.commandsDict ; d2 = {} 
    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'move-outline-down': g.trace(bunchList)
        for b in bunchList:
            # Important: regularize the binding value here.
            val = k.shortcutFromSetting(b.val)
            b.commandName = commandName
            aList = d2.get(val,[])
            aList.append(b)
            d2[val] = aList

    # g.trace(list(d2.keys()))
    
    # Step 2: Remove overridden entries from the bunchlist for each stroke.
    if self.new_bindings:
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            aList = self.mergeShortcutList(aList,stroke)
            d2 [stroke] = aList

    # Step 3: make the bindings.
    if 1: # New code
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            # if stroke == 'Ctrl+q': g.trace('***',stroke,aList)
            for bunch in aList:
                commandName = bunch.commandName
                command = c.commandsDict.get(commandName)
                _hash = bunch.get('_hash') # 2011/02/10
                pane = bunch.pane
                if trace and not _hash:
                    g.trace('**** no hash for',commandName)
                if stroke and not pane.endswith('-mode'):
                    k.bindKey(pane,stroke,command,commandName,_hash=_hash)
    else: ### old code
        d = c.commandsDict
        for commandName in sorted(d):
            command = d.get(commandName)
            key, bunchList = c.config.getShortcut(commandName)
            # if commandName in ('full-command'): g.trace(key,bunchList)
            for bunch in bunchList:
                accel = bunch.val ; pane = bunch.pane
                _hash = bunch.get('_hash') # 2011/02/10
                if trace and not _hash: g.trace('**** no hash for',commandName)
                # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
                if accel and not pane.endswith('-mode'):
                    shortcut = k.shortcutFromSetting(accel)
                    k.bindKey(pane,shortcut,command,commandName,_hash=_hash)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@+node:ekr.20110211094454.15414: *7* mergeShortcutList
def mergeShortcutList (self,aList,stroke): # stroke is for debugging.

    '''aList is a list of binding bunches for stroke.
    
    Return a new list consisting only of bindings from the highest priority .leo file.'''
    
    # Find the higest priority hash.
    trace = False and not g.unitTesting
    verbose = False
    k = self.c.k
    sList,mList,fList = [],[],[]
    # if stroke == 'Alt-F4': g.pdb()
    for b in aList:
        _hash = b.get('_hash','<no hash>')
        if _hash.endswith('myleosettings.leo'):
            mList.append(b)
        elif _hash.endswith('leosettings.leo'):
            sList.append(b)
        elif _hash.endswith('.leo'):
            fList.append(b)

    result = fList or mList or sList or aList
            
    if trace:
        def pr(stroke,message,aList):
            print('mergeShortcutList: %15s %s %s' % (stroke,message,
                '...\n'.join(['%15s %5s %s' % (k.shortcutFromSetting(z.val),z.pane,z.commandName) for z in aList])))
        if fList and mList:
            pr(stroke,'ignoring  mList',mList)
            pr(stroke,'retaining fList',fList)
        if fList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining fList',fList)
        elif mList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining mList',mList)

    if trace and verbose and len(result) > 1: g.trace(stroke,result)
    return result
#@+node:ekr.20061031131434.103: *6* k.makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    trace = True and not g.unitTesting
    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)

    if stroke.lower().startswith('key'):
        g.trace('stroke',repr(stroke),'bindStroke',repr(bindStroke),g.callers(5))

    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        if 0: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke,event.w)
        return k.masterKeyHandler(event,stroke=stroke)

    if 0:
        if stroke.lower().endswith('+s') or stroke.lower().endswith('-s'):
            g.trace(sroke,widgets)
        if stroke in ('s','S'):
            g.trace(stroke,widgets)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                c.bind(w,bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')

                if g.app.unitTesting: raise
#@+node:ekr.20110210081557.15393: *5* Printing...
#@+node:ekr.20070418073400: *6* g.app.config.printSettings
def printSettings (self,c):

    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following shows where the active setting came from:

    -     leoSettings.leo,
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,

    '''

    legend = '''\
legend:
    leoSettings.leo
[D] default settings
[F] loaded .leo File
[M] myLeoSettings.leo
'''
    legend = g.adjustTripleString(legend,c.tab_width)
    result = []
    for name,val,c,letter in self.config_iter(c):
        kind = g.choose(letter==' ','   ','[%s]' % (letter))
        result.append('%s %s = %s\n' % (kind,name,val))

    # Use a single g.es statement.
    result.append('\n'+legend)
    g.es('',''.join(result),tabName='Settings')
#@+node:ekr.20061031131434.119: *6* k.printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[S] leoSettings.leo
[ ] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] mode
'''
    legend = g.adjustTripleString(legend,c.tab_width)

    data = [] ; n1 = 4 ; n2 = 20
    if not d: return g.es('no bindings')
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            s4 = b.get('_hash','<no hash>')
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3,s4),)

    # Print keys by type:
    result = []
    result.append('\n'+legend)
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
        'Meta+Ctrl+Shift', 'Meta+Shift', 'Meta+Ctrl', 'Meta+Key','Meta',
        # Meta support
    ):
        data2 = []
        for item in data:
            s1,s2,s3,s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        # g.es('','%s %s' % (sep, prefix),tabName=tabName)
        result.append('%s %s\n' % (sep, prefix))
        self.printBindingsHelper(result,data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('%s %s\n' % (sep, 'Plain Keys'))
    self.printBindingsHelper(result,data,n1,n2,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
    return result # for unit test.
#@+node:ekr.20061031131434.120: *7* printBindingsHelper
def printBindingsHelper (self,result,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.

    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        for s1,s2,s3,s4 in data:
            
            # 2011/02/10: Print the source of the binding: s4 is the _hash.
            s4 = s4.lower()
            if s4.endswith('myleosettings.leo'):
                letter = 'M'
            elif s4.endswith('leosettings.leo'):
                letter = 'S'
            elif s4.endswith('.leo'):
                letter = 'F'
            elif s4.find('mode') != -1:
                letter = '@' # the full mode.
            else:
                letter = ' '
            
            # g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
            result.append('%s %*s %*s %s\n' % (letter,-n1,s1,-(min(12,n2)),s2,s3))
#@+node:ekr.20110210081557.15392: *5* Reading settings
#@+node:ekr.20041119203941.3: *6* class settingsTreeParser (parserBaseClass)
class settingsTreeParser (parserBaseClass):

    '''A class that inits settings found in an @settings tree.

    Used by read settings logic.'''

    @others
#@+node:ekr.20041119204103: *7* ctor
def __init__ (self,c,localFlag=True):

    # Init the base class.
    parserBaseClass.__init__(self,c,localFlag)
#@+node:ekr.20041119204714: *7* visitNode (settingsTreeParser)
def visitNode (self,p):

    """Init any settings found in node p."""

    # g.trace(p.h)

    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.h)
    kind = munge(kind)

    if g.isPython3:
        isNone = val in ('None','none','',None)
    else:
        isNone = val in (
            unicode('None'),unicode('none'),unicode(''),
            'None','none','',None)

    if kind is None: # Not an @x node. (New in Leo 4.4.4)
        pass
    if kind == "settings":
        pass
    # elif kind in self.basic_types and val in (u'None',u'none','None','none','',None):
    elif kind in self.basic_types and isNone:
        # None is valid for all basic types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        if f:
            try:
                return f(p,kind,name,val)
            except Exception:
                g.es_exception()
        else:
            g.pr("*** no handler",kind)

    return None
#@+node:ekr.20041120064303: *6* readSettingsFiles & helpers (g.app.config)
def readSettingsFiles (self,fileName,verbose=True):

    '''Read settings from one file of the standard settings files.'''

    trace = False and not g.unitTesting
    verbose = verbose
    giveMessage = (verbose and not g.app.unitTesting and
        not self.silent and not g.app.batchMode)
    def message(s):
        # This occurs early in startup, so use the following.
        if not g.isPython3:
            s = g.toEncodedString(s,'ascii')
        g.es_print(s,color='blue')
    self.write_recent_files_as_needed = False # Will be set later.
    localConfigFile = self.getLocalConfigFile(fileName)
    if trace: g.trace(fileName,localConfigFile)
    table = self.defineSettingsTable(fileName,localConfigFile)
    for path,localFlag in table:
        assert path and g.os_path_exists(path)
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or path.endswith('.leo')
        if isLeo:
            c = self.openSettingsFile(path)
            if c:
                if giveMessage:
                    message('reading settings in %s' % path)
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool(
                    'write_recent_files_as_needed')
            else:
                if giveMessage:
                    message('error reading settings in %s' % path)

    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20101021041958.6008: *7* getLocalConfigFile
# This can't be done in initSettingsFiles because
# the local directory does not yet exist.

def getLocalConfigFile (self,fileName):

    if not fileName:
        return None

    theDir = g.os_path_dirname(fileName)
    path = g.os_path_join(theDir,'leoSettings.leo')

    if g.os_path_exists(path):
        return path
    else:
        return None
#@+node:ekr.20101021041958.6004: *7* defineSettingsTable
def defineSettingsTable (self,fileName,localConfigFile):

    trace = False and not g.unitTesting
    verbose = False

    global_table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        # (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        # (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
    )

    if fileName:
        if fileName.lower().endswith('leosettings.leo'):
            # 2011/02/28: don't read leoSettings.leo or myLeoSetings.leo twice.
            # This allows myLeoSettings.leo to take precedence.
            table1 = []
        else:
            path = g.os_path_finalize(fileName)
            theDir = g.os_path_dirname(fileName)
            myLocalConfigFile = g.os_path_join(theDir,'myLeoSettings.leo')
            local_table = (
                (localConfigFile,False),
                (myLocalConfigFile,False),
            )
            if trace and verbose:
                g.trace('localConfigFile:  ',localConfigFile)
                g.trace('myLocalConfigFile:',myLocalConfigFile)
    
            table1 = [z for z in local_table if z not in global_table]
            table1.append((path,True),)
    else:
        table1 = global_table

    seen = [] ; table = []
    for path,localFlag in table1:
        if trace and verbose: g.trace('exists',g.os_path_exists(path),path)
        if path and g.os_path_exists(path):
            # Make sure we mark files seen no matter how they are specified.
            path = g.os_path_realpath(g.os_path_finalize(path))
            if path.lower() not in seen:
                seen.append(path.lower())
                table.append((path,localFlag),)
    if trace: g.trace(repr(fileName),'table:',g.listToString(table))
    return table
#@+node:ekr.20041117085625: *7* openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@+node:ekr.20051013161232: *7* updateSettings
def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
#@+node:ekr.20041117083857.1: *6* g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    trace = False and not g.unitTesting
    if trace: g.trace('localFlag: %5s %s' % (localFlag, c and c.shortFileName()))

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()
    
    # g.trace(c.shortFileName(),len(list(d.keys())))

    return d
#@+node:ekr.20041120105609: *6* doShortcuts (ParserBaseClass)
def doShortcuts(self,p,kind,name,val,s=None):

    c = self.c ; d = self.shortcutsDict ; k = c.k
    trace = False or c.config.getBool('trace_bindings_verbose')
    verbose = False
    theHash = d.get('_hash')
    theHash = g.choose(theHash,g.shortFileName(theHash),'<no hash>')
    if trace: g.trace('localFlag: %s d._hash: %s %s' % (
        self.localFlag,theHash,c.shortFileName()))
    munge = k.shortcutFromSetting
    if s is None: s = p.b
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if bunch is not None:
                bunch._hash = theHash # 2011/02/10
                if bunch.val not in (None,'none','None'):
                    # A regular shortcut.
                    bunchList = d.get(name,[])
                    if bunch.pane in ('kill','Kill'):
                        if trace and verbose: g.trace('****** killing binding:',
                            bunch.val,'to',name)
                        bunchList = [z for z in bunchList
                            if munge(z.val) != munge(bunch.val)]
                        # g.trace(bunchList)
                    else:
                        if trace and verbose: g.trace('%6s %20s %s' % (
                            bunch.pane,bunch.val,name))
                        bunchList.append(bunch)
                    d [name] = bunchList
                    # if name in ('full-command'):
                        # g.trace('id(self.shortcutsDict)',id(d),bunchList)
                    self.set(p,"shortcut",name,bunchList)
                    self.setShortcut(name,bunchList)
#@+node:ekr.20110210081557.15394: *5* Remembering the source of bindings
#@+node:ekr.20041120105609: *6* doShortcuts (ParserBaseClass)
def doShortcuts(self,p,kind,name,val,s=None):

    c = self.c ; d = self.shortcutsDict ; k = c.k
    trace = False or c.config.getBool('trace_bindings_verbose')
    verbose = False
    theHash = d.get('_hash')
    theHash = g.choose(theHash,g.shortFileName(theHash),'<no hash>')
    if trace: g.trace('localFlag: %s d._hash: %s %s' % (
        self.localFlag,theHash,c.shortFileName()))
    munge = k.shortcutFromSetting
    if s is None: s = p.b
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if bunch is not None:
                bunch._hash = theHash # 2011/02/10
                if bunch.val not in (None,'none','None'):
                    # A regular shortcut.
                    bunchList = d.get(name,[])
                    if bunch.pane in ('kill','Kill'):
                        if trace and verbose: g.trace('****** killing binding:',
                            bunch.val,'to',name)
                        bunchList = [z for z in bunchList
                            if munge(z.val) != munge(bunch.val)]
                        # g.trace(bunchList)
                    else:
                        if trace and verbose: g.trace('%6s %20s %s' % (
                            bunch.pane,bunch.val,name))
                        bunchList.append(bunch)
                    d [name] = bunchList
                    # if name in ('full-command'):
                        # g.trace('id(self.shortcutsDict)',id(d),bunchList)
                    self.set(p,"shortcut",name,bunchList)
                    self.setShortcut(name,bunchList)
#@+node:ekr.20051013161232: *6* updateSettings
def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
#@+node:ekr.20041119204700.1: *6* traverse (parserBaseClass)
def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {'_hash': c.hash()} # 2011/02/10
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # if g.isPython3:
            # g.trace(result,p.h)
            # if p.h == 'Menus': g.pdb()
        if result == "skip":
            # g.es_print('skipping settings in',p.h,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
#@+node:ekr.20060102103625.1: *6* doMode (ParserBaseClass)
def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-<name>-mode command.'''

    c = self.c ; k = c.k ; name1 = name

    # g.trace('%20s' % (name),c.fileName())
    modeName = self.computeModeName(name)

    # Create a local shortcutsDict.
    old_d = self.shortcutsDict
    d = self.shortcutsDict = {'_hash':modeName,} # 2011/02/10

    s = p.b
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                bunch.val = k.strokeFromSetting(bunch.val)
                bunch.pane = modeName
                bunchList = d.get(name,[])
                # Important: use previous bindings if possible.
                key2,bunchList2 = c.config.getShortcut(name)
                bunchList3 = [b for b in bunchList2 if b.pane != modeName]
                if bunchList3:
                    # g.trace('inheriting',[b.val for b in bunchList3])
                    bunchList.extend(bunchList3)
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)

    # Restore the global shortcutsDict.
    self.shortcutsDict = old_d

    # Create the command, but not any bindings to it.
    self.createModeCommand(modeName,name1,d)
#@+node:ekr.20110210081557.15395: *5* Calls to k.bindKey
# Added _hash keyword arg to bindKey.
#@+node:ekr.20061031131434.89: *6* bindKey
def bindKey (self,pane,shortcut,callback,commandName,_hash=None,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    _hash gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %30s %s' % (pane,shortcut,commandName,_hash))
        g.trace(g.callers())
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName,_hash=_hash)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90: *7* << give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@+node:ekr.20061031131434.92: *7* << remove previous conflicting definitions from bunchList >>
# b is the bunch for the new binding.

### This warning should never happen with the new code in makeBindingsFromCommandsDict.

if not modeFlag and self.warn_about_redefined_shortcuts:
    
    redefs = [b2 for b2 in bunchList
        if b2.commandName != commandName and
            # pane != b2.pane and # 2011/02/11: don't give warning for straight substitution.
            pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]

    if redefs:
        def pr(commandName,pane,theHash):
            g.es_print('%30s in %5s from %s' % (commandName,pane,theHash))
    
        g.warning('shortcut conflict for %s' % c.k.prettyPrintKey(shortcut))
        pr(commandName,pane,_hash)
        for z in redefs:
            pr(z.commandName,z.pane,z._hash)

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@+node:ekr.20061031131434.131: *6* k.registerCommand
def registerCommand (self,commandName,shortcut,func,
    pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)

    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('redefining',commandName, color='red')

    # if commandName == 'full-command': g.trace(commandName,func.__name__)
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    if trace: g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName,g.callers(4))
        ok = k.bindKey (pane,stroke,func,commandName,_hash='register-command') # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif trace and verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@+node:ekr.20061031131434.102: *6* makeBindingsFromCommandsDict & helper
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bunches b with b.val equal to the stroke.
    d = c.commandsDict ; d2 = {} 
    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'move-outline-down': g.trace(bunchList)
        for b in bunchList:
            # Important: regularize the binding value here.
            val = k.shortcutFromSetting(b.val)
            b.commandName = commandName
            aList = d2.get(val,[])
            aList.append(b)
            d2[val] = aList

    # g.trace(list(d2.keys()))
    
    # Step 2: Remove overridden entries from the bunchlist for each stroke.
    if self.new_bindings:
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            aList = self.mergeShortcutList(aList,stroke)
            d2 [stroke] = aList

    # Step 3: make the bindings.
    if 1: # New code
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            # if stroke == 'Ctrl+q': g.trace('***',stroke,aList)
            for bunch in aList:
                commandName = bunch.commandName
                command = c.commandsDict.get(commandName)
                _hash = bunch.get('_hash') # 2011/02/10
                pane = bunch.pane
                if trace and not _hash:
                    g.trace('**** no hash for',commandName)
                if stroke and not pane.endswith('-mode'):
                    k.bindKey(pane,stroke,command,commandName,_hash=_hash)
    else: ### old code
        d = c.commandsDict
        for commandName in sorted(d):
            command = d.get(commandName)
            key, bunchList = c.config.getShortcut(commandName)
            # if commandName in ('full-command'): g.trace(key,bunchList)
            for bunch in bunchList:
                accel = bunch.val ; pane = bunch.pane
                _hash = bunch.get('_hash') # 2011/02/10
                if trace and not _hash: g.trace('**** no hash for',commandName)
                # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
                if accel and not pane.endswith('-mode'):
                    shortcut = k.shortcutFromSetting(accel)
                    k.bindKey(pane,shortcut,command,commandName,_hash=_hash)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@+node:ekr.20110211094454.15414: *7* mergeShortcutList
def mergeShortcutList (self,aList,stroke): # stroke is for debugging.

    '''aList is a list of binding bunches for stroke.
    
    Return a new list consisting only of bindings from the highest priority .leo file.'''
    
    # Find the higest priority hash.
    trace = False and not g.unitTesting
    verbose = False
    k = self.c.k
    sList,mList,fList = [],[],[]
    # if stroke == 'Alt-F4': g.pdb()
    for b in aList:
        _hash = b.get('_hash','<no hash>')
        if _hash.endswith('myleosettings.leo'):
            mList.append(b)
        elif _hash.endswith('leosettings.leo'):
            sList.append(b)
        elif _hash.endswith('.leo'):
            fList.append(b)

    result = fList or mList or sList or aList
            
    if trace:
        def pr(stroke,message,aList):
            print('mergeShortcutList: %15s %s %s' % (stroke,message,
                '...\n'.join(['%15s %5s %s' % (k.shortcutFromSetting(z.val),z.pane,z.commandName) for z in aList])))
        if fList and mList:
            pr(stroke,'ignoring  mList',mList)
            pr(stroke,'retaining fList',fList)
        if fList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining fList',fList)
        elif mList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining mList',mList)

    if trace and verbose and len(result) > 1: g.trace(stroke,result)
    return result
#@+node:ekr.20110227200312.15374: *4* Open leoSettings.leo only once
#@+node:ekr.20090519143741.5915: *5* doPrePluginsInit & helpers
def doPrePluginsInit(fileName,pymacs):

    ''' Scan options, set directories and read settings.'''

    trace = False
    g.computeStandardDirectories()
    adjustSysPath()
    
    # Scan the options as early as possible.
    options = scanOptions()

    # Post-process the options.
    fileName2 = options.get('fileName')
    if fileName2: fileName = fileName2

    if pymacs:
        options['script'] = script = None
        options['windowFlag'] = False
    else:
        script = options.get('script')
    verbose = script is None

    # Init the app.
    initApp(verbose)
    files = getFiles(fileName2)
    reportDirectories(verbose)

    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(None,verbose)
    for fn in files:
        g.app.config.readSettingsFiles(fn,verbose)

    if not files and not script:
        # This must be done *after* the standard settings have been read.
        fn = getDefaultFile()
        if fn:
            files = [fn]
            g.app.config.readSettingsFiles(fn,verbose=True)

    g.app.setGlobalDb()
    
    # Create the gui after reading options and settings.
    createGui(pymacs,options)

    # if no gui specified on command line, and qt not installed
    # set options['gui'] to 'tk' to match reality
    if g.app.guiArgName == 'tk':
        options['gui'] = 'tk'

    # We can't print the signon until we know the gui.
    g.app.computeSignon() # Set app.signon/signon2 for commanders.
    versionFlag = options.get('versionFlag')
    if versionFlag:
        print(g.app.signon)
    if versionFlag or not g.app.gui:
        options['exit'] = True

    return files,options
#@+node:ekr.20100914142850.5892: *6* createGui & helper
def createGui(pymacs,options):

    gui = options.get('gui')
    windowFlag = options.get('windowFlag')
    script = options.get('script')

    if g.app.gui:
        pass # initApp (setLeoID) created the gui.
    elif gui is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        createSpecialGui(gui,pymacs,script,windowFlag)


#@+node:ekr.20080921060401.4: *6* createSpecialGui
def createSpecialGui(gui,pymacs,script,windowFlag):

    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        assert g.app.guiArgName
        g.app.createDefaultGui() 
#@+node:ekr.20070306085724: *6* adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:

    1. g.importModule will import from the
       'external' or 'extensions' folders as needed
       without altering sys.path.

    2  Plugins now do fully qualified imports.
    '''
#@+node:ekr.20041124083125: *6* completeFileName
def completeFileName (fileName):

    trace = False
    if trace: print('completeFileName',fileName)

    if not (fileName and fileName.strip()):
        return None,None

    fileName = g.toUnicode(fileName)
    fileName = g.os_path_finalize(fileName)
    junk,ext = g.os_path_splitext(fileName)

    # Bug fix: don't add .leo to existing files.
    if g.os_path_exists(fileName):
        pass # use the fileName as is.
    elif ext != '.leo':
        fileName = fileName + ".leo"

    if trace: print('completeFileName',fileName)

    return fileName
#@+node:ekr.20101021101942.6010: *6* getDefaultFile
def getDefaultFile ():

    # Get the name of the workbook.
    fn = g.app.config.getString(c=None,setting='default_leo_file')
    fn = g.os_path_finalize(fn)
    if not fn: return

    # g.trace(g.os_path_exists(fn),fn)

    if g.os_path_exists(fn):
        return fn
    elif g.os_path_isabs(fn):
        # Create the file.
        g.es_print('Using default leo file name:\n%s' % (fn),color='red')
        return fn
    else:
        # It's too risky to open a default file if it is relative.
        return None
#@+node:ekr.20101020125657.5976: *6* getFiles
def getFiles(fileName):

    files = []
    if fileName:
        files.append(fileName)

    for arg in sys.argv[1:]:
        if not arg.startswith('-'):
            files.append(arg)

    files = [completeFileName(z) for z in files]
    return files
#@+node:ekr.20080921091311.2: *6* initApp
def initApp (verbose):

    assert g.app.guiArgName

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.config = leoConfig.configClass()
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.pluginsController.finishCreate() # 2010/09/09
#@+node:ekr.20041130093254: *6* reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@+node:ekr.20091007103358.6061: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''
    trace = False

    # Note: this automatically implements the --help option.
    parser = optparse.OptionParser()
    add = parser.add_option
    add('-c', '--config', dest="one_config_path",
        help = 'use a single configuration file')
    add('--debug',        action="store_true",dest="debug",
        help = 'enable debugging support')
    add('-f', '--file',   dest="fileName",
        help = 'load a file at startup')
    add('--gui',
        help = 'gui to use (qt/tk/qttabs)')
    add('--minimized',    action="store_true",
        help = 'start minimized (Qt only)')
    add('--maximized',    action="store_true",
        help = 'start maximized (Qt only)')
    add('--fullscreen',   action="store_true",
        help = 'start fullscreen (Qt only)')
    add('--ipython',      action="store_true",dest="use_ipython",
        help = 'enable ipython support')
    add('--no-cache',     action="store_true",dest='no_cache',
        help = 'disable reading of cached files')
    add('--no-splash',    action="store_true",dest='no_splash_screen',
        help = 'disable the splash screen')
    add('--silent',       action="store_true",dest="silent",
        help = 'disable all log messages')
    add('--screen-shot',  dest='screenshot_fn',
        help = 'take a screen shot and then exit')
    add('--script',       dest="script",
        help = 'execute a script and then exit')
    add('--script-window',dest="script_window",
        help = 'open a window for scripts')
    add('--select',       dest='select',
        help='headline or gnx of node to select')
    add('--version',      action="store_true",dest="version",
        help='print version number and exit')
    add('--window-size',  dest='window_size',
        help='initial window size in height x width format')

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    if trace: print('scanOptions:',sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --debug
    if options.debug:
        g.debug = True
        print('scanOptions: *** debug mode on')

    # -f or --file
    fileName = options.fileName
    if fileName:
        fileName = fileName.strip('"')
        if trace: print('scanOptions:',fileName)

    # --gui
    gui = options.gui

    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            gui = g.app.guiArgName = 'qt'
            g.app.qt_use_tabs = True
        elif gui in ('curses','tk','qt','null'): # 'wx',
            g.app.guiArgName = gui
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s' % gui)
            g.app.guiArgName = gui = 'qt'
            g.app.qt_use_tabs = True
    else:
        gui = g.app.guiArgName = 'qt'
        g.app.qt_use_tabs = True

    assert gui == g.app.guiArgName

    # --minimized
    # --maximized
    # --fullscreen
    g.app.start_minimized = options.minimized
    g.app.start_maximized = options.maximized
    g.app.start_fullscreen = options.fullscreen

    # --ipython
    g.app.useIpython = options.use_ipython

    # --no-cache
    if options.no_cache:
        print('scanOptions: disabling caching')
        g.enableDB = False
        
    # --no-splash
    # g.trace('--no-splash',options.no_splash_screen)
    g.app.use_splash_screen = not options.no_splash_screen

    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn',screenshot_fn)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        script,e = g.readFileIntoString(script_name,kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')

    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select',repr(select))

    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)

    # --version: print the version and exit.
    versionFlag = options.version

    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize',repr(windowSize))
        try:
            h,w = windowSize.split('x')
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:',size)

    # Compute the return values.
    windowFlag = script and script_path_w
    return {
        'fileName':fileName,
        'gui':gui,
        'screenshot_fn':screenshot_fn,
        'script':script,
        'select':select,
        'version':versionFlag,
        'windowFlag':windowFlag,
        'windowSize':windowSize,
    }
#@+node:ekr.20041120064303: *5* readSettingsFiles & helpers (g.app.config)
def readSettingsFiles (self,fileName,verbose=True):

    '''Read settings from one file of the standard settings files.'''

    trace = False and not g.unitTesting
    verbose = verbose
    giveMessage = (verbose and not g.app.unitTesting and
        not self.silent and not g.app.batchMode)
    def message(s):
        # This occurs early in startup, so use the following.
        if not g.isPython3:
            s = g.toEncodedString(s,'ascii')
        g.es_print(s,color='blue')
    self.write_recent_files_as_needed = False # Will be set later.
    localConfigFile = self.getLocalConfigFile(fileName)
    if trace: g.trace(fileName,localConfigFile)
    table = self.defineSettingsTable(fileName,localConfigFile)
    for path,localFlag in table:
        assert path and g.os_path_exists(path)
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or path.endswith('.leo')
        if isLeo:
            c = self.openSettingsFile(path)
            if c:
                if giveMessage:
                    message('reading settings in %s' % path)
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool(
                    'write_recent_files_as_needed')
            else:
                if giveMessage:
                    message('error reading settings in %s' % path)

    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20101021041958.6008: *6* getLocalConfigFile
# This can't be done in initSettingsFiles because
# the local directory does not yet exist.

def getLocalConfigFile (self,fileName):

    if not fileName:
        return None

    theDir = g.os_path_dirname(fileName)
    path = g.os_path_join(theDir,'leoSettings.leo')

    if g.os_path_exists(path):
        return path
    else:
        return None
#@+node:ekr.20101021041958.6004: *6* defineSettingsTable
def defineSettingsTable (self,fileName,localConfigFile):

    trace = False and not g.unitTesting
    verbose = False

    global_table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        # (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        # (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
    )

    if fileName:
        if fileName.lower().endswith('leosettings.leo'):
            # 2011/02/28: don't read leoSettings.leo or myLeoSetings.leo twice.
            # This allows myLeoSettings.leo to take precedence.
            table1 = []
        else:
            path = g.os_path_finalize(fileName)
            theDir = g.os_path_dirname(fileName)
            myLocalConfigFile = g.os_path_join(theDir,'myLeoSettings.leo')
            local_table = (
                (localConfigFile,False),
                (myLocalConfigFile,False),
            )
            if trace and verbose:
                g.trace('localConfigFile:  ',localConfigFile)
                g.trace('myLocalConfigFile:',myLocalConfigFile)
    
            table1 = [z for z in local_table if z not in global_table]
            table1.append((path,True),)
    else:
        table1 = global_table

    seen = [] ; table = []
    for path,localFlag in table1:
        if trace and verbose: g.trace('exists',g.os_path_exists(path),path)
        if path and g.os_path_exists(path):
            # Make sure we mark files seen no matter how they are specified.
            path = g.os_path_realpath(g.os_path_finalize(path))
            if path.lower() not in seen:
                seen.append(path.lower())
                table.append((path,localFlag),)
    if trace: g.trace(repr(fileName),'table:',g.listToString(table))
    return table
#@+node:ekr.20041117085625: *6* openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@+node:ekr.20051013161232: *6* updateSettings
def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
#@+node:ekr.20110125142807.17268: *4* Added save-all command
@nocolor-node

Saves all changed windows. 
#@+node:ekr.20031218072017.2834: *5* c.save
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            if g.app.qt_use_tabs and hasattr(c.frame,'top'):
                c.frame.top.leo_master.setTabName(c,c.mFileName)
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    # Done in fileCommands.save.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocus()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocus()
#@+node:ekr.20110228162720.13980: *5* c.saveAll
def saveAll (self,event=None):
    
    '''Save all open tabs windows/tabs.'''
    
    for f in g.app.windowList:
        c = f.c
        if c.isChanged():
            c.save()
            
    # Restore the present tab.
    c = self
    dw = c.frame.top # A DynamicWindow
    dw.select(c)
#@+node:ekr.20031218072017.1720: *5* save (fileCommands)
def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)

    if ok is None:
        c.endEditing() # Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        c.cacher.save(fileName,changeName=True)
        ok = c.checkFileTimeStamp(fileName)
        if ok:
            ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
        if ok:
            self.putSavedMessage(fileName)
            c.setChanged(False) # Clears all dirty bits.
            if c.config.save_clears_undo_buffer:
                g.es("clearing undo")
                c.undoer.clearUndoState()

        c.redraw_after_icons_changed()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
#@+node:ekr.20031218072017.2989: *5* c.setChanged
def setChanged (self,changedFlag):

    trace = False and not g.unitTesting
    c = self
    if not c.frame: return
    c.changed = changedFlag
    if c.loading: return # don't update while loading.

    if trace: g.trace(changedFlag,g.callers())

    # Clear all dirty bits _before_ setting the caption.
    if not changedFlag:
        for v in c.all_unique_nodes():
            if v.isDirty():
                v.clearDirty()

    if g.app.qt_use_tabs and hasattr(c.frame,'top'):
        c.frame.top.leo_master.setChanged(c,changedFlag)

    s = c.frame.getTitle()
    if len(s) > 2:
        if changedFlag:
            if s [0] != '*': c.frame.setTitle("* " + s)
        else:
            if s[0:2]=="* ": c.frame.setTitle(s[2:])
#@+node:ekr.20110202094848.12571: *4* Vim...
#@+node:ekr.20060927173836.6: *5* Give warning when unbound key ends a mode
#@+node:ekr.20091230094319.6244: *6* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode(event)
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
#@+node:ekr.20110210115239.15392: *5* Improved redefining messages
#@+node:ekr.20061031131434.102: *6* makeBindingsFromCommandsDict & helper
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bunches b with b.val equal to the stroke.
    d = c.commandsDict ; d2 = {} 
    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'move-outline-down': g.trace(bunchList)
        for b in bunchList:
            # Important: regularize the binding value here.
            val = k.shortcutFromSetting(b.val)
            b.commandName = commandName
            aList = d2.get(val,[])
            aList.append(b)
            d2[val] = aList

    # g.trace(list(d2.keys()))
    
    # Step 2: Remove overridden entries from the bunchlist for each stroke.
    if self.new_bindings:
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            aList = self.mergeShortcutList(aList,stroke)
            d2 [stroke] = aList

    # Step 3: make the bindings.
    if 1: # New code
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            # if stroke == 'Ctrl+q': g.trace('***',stroke,aList)
            for bunch in aList:
                commandName = bunch.commandName
                command = c.commandsDict.get(commandName)
                _hash = bunch.get('_hash') # 2011/02/10
                pane = bunch.pane
                if trace and not _hash:
                    g.trace('**** no hash for',commandName)
                if stroke and not pane.endswith('-mode'):
                    k.bindKey(pane,stroke,command,commandName,_hash=_hash)
    else: ### old code
        d = c.commandsDict
        for commandName in sorted(d):
            command = d.get(commandName)
            key, bunchList = c.config.getShortcut(commandName)
            # if commandName in ('full-command'): g.trace(key,bunchList)
            for bunch in bunchList:
                accel = bunch.val ; pane = bunch.pane
                _hash = bunch.get('_hash') # 2011/02/10
                if trace and not _hash: g.trace('**** no hash for',commandName)
                # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
                if accel and not pane.endswith('-mode'):
                    shortcut = k.shortcutFromSetting(accel)
                    k.bindKey(pane,shortcut,command,commandName,_hash=_hash)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@+node:ekr.20110211094454.15414: *7* mergeShortcutList
def mergeShortcutList (self,aList,stroke): # stroke is for debugging.

    '''aList is a list of binding bunches for stroke.
    
    Return a new list consisting only of bindings from the highest priority .leo file.'''
    
    # Find the higest priority hash.
    trace = False and not g.unitTesting
    verbose = False
    k = self.c.k
    sList,mList,fList = [],[],[]
    # if stroke == 'Alt-F4': g.pdb()
    for b in aList:
        _hash = b.get('_hash','<no hash>')
        if _hash.endswith('myleosettings.leo'):
            mList.append(b)
        elif _hash.endswith('leosettings.leo'):
            sList.append(b)
        elif _hash.endswith('.leo'):
            fList.append(b)

    result = fList or mList or sList or aList
            
    if trace:
        def pr(stroke,message,aList):
            print('mergeShortcutList: %15s %s %s' % (stroke,message,
                '...\n'.join(['%15s %5s %s' % (k.shortcutFromSetting(z.val),z.pane,z.commandName) for z in aList])))
        if fList and mList:
            pr(stroke,'ignoring  mList',mList)
            pr(stroke,'retaining fList',fList)
        if fList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining fList',fList)
        elif mList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining mList',mList)

    if trace and verbose and len(result) > 1: g.trace(stroke,result)
    return result
#@+node:ekr.20061031131434.89: *6* bindKey
def bindKey (self,pane,shortcut,callback,commandName,_hash=None,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    _hash gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %30s %s' % (pane,shortcut,commandName,_hash))
        g.trace(g.callers())
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName,_hash=_hash)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90: *7* << give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@+node:ekr.20061031131434.92: *7* << remove previous conflicting definitions from bunchList >>
# b is the bunch for the new binding.

### This warning should never happen with the new code in makeBindingsFromCommandsDict.

if not modeFlag and self.warn_about_redefined_shortcuts:
    
    redefs = [b2 for b2 in bunchList
        if b2.commandName != commandName and
            # pane != b2.pane and # 2011/02/11: don't give warning for straight substitution.
            pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]

    if redefs:
        def pr(commandName,pane,theHash):
            g.es_print('%30s in %5s from %s' % (commandName,pane,theHash))
    
        g.warning('shortcut conflict for %s' % c.k.prettyPrintKey(shortcut))
        pr(commandName,pane,_hash)
        for z in redefs:
            pr(z.commandName,z.pane,z._hash)

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@+node:ekr.20110209083917.15999: *5* Simple vim bindings
@language python
#@+node:ekr.20110209093958.15408: *6* To do
@nocolor-node

- Test with tk.  One test fails:  @test leoTree is a subset of leoTkTree.

- (not needed) @shortcuts node that kills all bindings.

- (done) Show source of bindings in print-bindings.

- (done) Improve conflict messages.
#@+node:ekr.20090629183608.8445: *6* Cursors
@nocolor-node

Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
#@+node:ekr.20061031131434.123: *7* set-xxx-State
def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
#@+node:ekr.20061031131434.133: *7* setInputState
def setInputState (self,state):

    k = self
    k.unboundKeyAction = state



#@+node:ekr.20061031131434.192: *7* showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
        
    isText = g.app.gui.isTextWidget(w)

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()
    
    # 2011/02/12: get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree,'getWrapper'):
            if hasattr(w,'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2,item=None)
            isText = bool(w) # A benign hack.

    if trace: g.trace('state: %s text?: %s w: %s' % (
        state,isText,w))

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and isText:
        k.showStateColors(inOutline,w)
        k.showStateCursor(state,w)
#@+node:ekr.20110202111105.15439: *7* showStateCursor
def showStateCursor (self,state,w):
    
    # g.trace(state,w)
    
    pass
    
    
#@+node:ekr.20061031131434.146: *6* masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'keysym:',
        repr(event.keysym),'ch:',repr(event.char),'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
            
    # if stroke == 'Tab': g.pdb()

    if k.inState():
        if trace: g.trace('   state %-10s %s' % (stroke,state))
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')
            
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            return k.handleUnboundKeys(event,char,keysym,stroke)

    # 2011/02/08: Use getPandBindings for *all* keys.
    b = k.getPaneBinding(stroke,w)
    if b:
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke)
        return k.masterCommand(event,b.func,b.stroke,b.commandName)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147: *7* << define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
stroke = event.stroke ### 2010/10/18
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@+node:ekr.20061031131434.108: *7* callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@+node:ekr.20091230094319.6244: *7* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode(event)
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
#@+node:ekr.20091230094319.6240: *7* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and b.commandName in table:
                        if trace: g.trace('***** special case',b.commandName)
                        pass
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(b.stroke),b.commandName))
                        return b
#@+node:ekr.20061031131434.152: *7* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape',):
            return False
        if k.isFKey(stroke): # 2010/10/23.
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event) ### ,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@+node:ekr.20110209083917.16004: *7* isAutoCompleteChar
def isAutoCompleteChar (self,stroke):
    
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction
    
    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                b = d.get(stroke)
                if b and b.commandName == 'auto-complete':
                    return True
    return False
#@+node:ekr.20080510095819.1: *7* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)

    if trace and verbose: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return 'break'

    elif k.isFKey(stroke):
        if trace: g.trace('ignoring F-key',stroke)
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',stroke,keysym)
        return 'break'

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        if trace: g.trace('ignoring unbound non-ascii key',repr(stroke))
        return 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return 'break'

    else:
        if trace: g.trace('no func',stroke)
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@+node:ekr.20110208115654.15911: *6* Body pane background colors
These settings are no longer used:
    
    @string selected-background-color
    @string selected-command-background-color
#@+node:ekr.20061031131434.192: *7* showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
        
    isText = g.app.gui.isTextWidget(w)

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()
    
    # 2011/02/12: get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree,'getWrapper'):
            if hasattr(w,'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2,item=None)
            isText = bool(w) # A benign hack.

    if trace: g.trace('state: %s text?: %s w: %s' % (
        state,isText,w))

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and isText:
        k.showStateColors(inOutline,w)
        k.showStateCursor(state,w)
#@+node:ekr.20080512115455.1: *7* showStateColors
def showStateColors (self,inOutline,w):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; state = k.unboundKeyAction

    # body = c.frame.body ; bodyCtrl = body.bodyCtrl
    w_name = g.app.gui.widget_name(w)

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    if trace: g.trace('%9s' % (state),w_name)
    
    if w_name.startswith('body'):
        w = c.frame.body
    elif w_name.startswith('head'):
        pass
    else:
        # Don't recolor the minibuffer, log panes, etc.
        if trace: g.trace('not body or head')
        return

    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    if hasattr(w,'setEditorColors'):
        # Note: fg color has no effect on Qt at present.
        w.setEditorColors(bg=bg,fg=fg) ### Was body.
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            pass # g.es_exception()
#@+node:ekr.20110209093958.15409: *6* Enter insert mode after ctrl-h
#@+node:ekr.20031218072017.2886: *7* c.editHeadline
def editHeadline (self,event=None):

    '''Begin editing the headline of the selected node.'''

    c = self ; k = c.k ; tree = c.frame.tree

    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return
        
    e,wrapper = tree.editLabel(c.p)

    if k:
        # k.setDefaultInputState()
        k.setEditingState()
        k.showStateAndMode(w=wrapper)

    #### tree.editLabel(c.p)
#@+node:ekr.20110209093958.15411: *7* setEditingState
def setEditingState (self):

    k = self ; state = k.defaultEditingAction
    
    # g.trace(state)
    
    k.setInputState(state)
#@+node:ekr.20110209093958.15413: *7* setDefaultEditingKeyAction (New)
def setDefaultEditingAction (self):

    k = self ; c = k.c

    action = c.config.getString('default_editing_state') or 'insert'
    action.lower()

    if action not in ('command','insert','overwrite'):
        g.trace('ignoring default_editing_state: %s' % (action))
        action = 'insert'

    self.defaultEditingAction = action
#@+node:ekr.20110212012742.15416: *6* Colorize headline text depending on state
#@+node:ekr.20031218072017.2886: *7* c.editHeadline
def editHeadline (self,event=None):

    '''Begin editing the headline of the selected node.'''

    c = self ; k = c.k ; tree = c.frame.tree

    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return
        
    e,wrapper = tree.editLabel(c.p)

    if k:
        # k.setDefaultInputState()
        k.setEditingState()
        k.showStateAndMode(w=wrapper)

    #### tree.editLabel(c.p)
#@+node:ekr.20061031131434.192: *7* showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
        
    isText = g.app.gui.isTextWidget(w)

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()
    
    # 2011/02/12: get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree,'getWrapper'):
            if hasattr(w,'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2,item=None)
            isText = bool(w) # A benign hack.

    if trace: g.trace('state: %s text?: %s w: %s' % (
        state,isText,w))

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and isText:
        k.showStateColors(inOutline,w)
        k.showStateCursor(state,w)
#@+node:ekr.20080512115455.1: *7* showStateColors
def showStateColors (self,inOutline,w):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; state = k.unboundKeyAction

    # body = c.frame.body ; bodyCtrl = body.bodyCtrl
    w_name = g.app.gui.widget_name(w)

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    if trace: g.trace('%9s' % (state),w_name)
    
    if w_name.startswith('body'):
        w = c.frame.body
    elif w_name.startswith('head'):
        pass
    else:
        # Don't recolor the minibuffer, log panes, etc.
        if trace: g.trace('not body or head')
        return

    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    if hasattr(w,'setEditorColors'):
        # Note: fg color has no effect on Qt at present.
        w.setEditorColors(bg=bg,fg=fg) ### Was body.
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            pass # g.es_exception()
#@+node:ekr.20110211024010.15393: *6* colon destroys alt-x binding
# This project reorganizes makeBindingFromCommandsDict
#@+node:ekr.20061031131434.76: *7*  ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.

    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''

    self.c = c
    self.dispatchEvent = None
    self.inited = False # Set at end of finishCreate.
    self.w = c.frame.miniBufferWidget
    self.new_bindings = True
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # These must be defined here to avoid memory leaks.
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter           = getBool('enable_autocompleter_initially')
    self.enable_calltips                = getBool('enable_calltips_initially')
    self.ignore_caps_lock               = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color    = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_warning_color       = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color         = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys                  = getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = getBool('trace_bind_key_exceptions')
    self.trace_masterClickHandler       = getBool('trace_masterClickHandler')
    self.traceMasterCommand             = getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = getBool('trace_key_event')
    self.trace_minibuffer               = getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings       = c.config.getBool('enable_alt_ctrl_bindings')
    << define externally visible ivars >>
    << define internal ivars >>

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    fn = c.shortFileName()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction() # 2011/02/09
#@+node:ekr.20061031131434.78: *8* << define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.argSelectedText = '' # The selected text in state 0.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.modePrompt = '' # The mode promopt.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
#@+node:ekr.20061031131434.79: *8* << define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

# Keys whose bindings are computed by initSpecialIvars.
self.abortAllModesKey = None
self.autoCompleteForceKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
#@+node:ekr.20041117062717.14: *7* getShortcut (g.app.config) (changed)
def getShortcut (self,c,shortcutName):

    '''Return rawKey,accel for shortcutName'''

    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&','') # Allow '&' in names.
    
    if c.k.new_bindings:
        bunchList = self.getShortcutHelper(c,key) # 2011/02/11
    else:
        bunchList = self.get(c,key,'shortcut')
    # g.trace(c.k.new_bindings) # 'bunchList',bunchList)
    if bunchList:
        bunchList = [bunch for bunch in bunchList
            if bunch.val and bunch.val.lower() != 'none']
        return key,bunchList
    else:
        return key,[]
#@+node:ekr.20110211041914.15415: *8* getShortcutHelper(g.app.config) (NEW)
def getShortcutHelper (self,c,key):
    
    '''Like get, but return *all* the found bunchLists's.'''

    trace = False and not g.unitTesting
    kind = 'shortcut'
    isLeoSettings = c and c.shortFileName().endswith('leoSettings.leo')
    result = []

    if c and not isLeoSettings:
        d = self.localOptionsDict.get(c.hash())
        if d:
            bunchList,junk = self.getValFromDict(d,key,kind)
            if bunchList: self.mergeShortcuts(result,bunchList,key)

    for d in self.localOptionsList:
        bunchList,junk = self.getValFromDict(d,key,kind)
        if bunchList: self.mergeShortcuts(result,bunchList,key)

    for d in self.dictList:
        bunchList,junk = self.getValFromDict(d,key,kind)
        if bunchList: self.mergeShortcuts(result,bunchList,key)

    # Use settings in leoSettings.leo *last*.
    if c and isLeoSettings:
        d = self.localOptionsDict.get(c.hash())
        if d:
            bunchList,junk = self.getValFromDict(d,key,kind)
            if bunchList: self.mergeShortcuts(result,bunchList,key)

    return result
#@+node:ekr.20110211041914.15418: *8* mergeShortcuts (NEW)
def mergeShortcuts (self,result,aList,key):
        # key is for debugging.
        # key is a conical command name, *not* a keystroke.
    
    '''Append all non-conflicting entries of aList to result.'''
    
    trace = False and not g.unitTesting
    # If there is a real override, **earlier** entries take precedence.
    # Don't add a bunch if it conflicts with a previous val, **regardless** of pane.
    
    vals = [z.val for z in result]
    aList = [z for z in aList if z.val not in vals]
    result.extend(aList)

    if trace and len(result) > 1:
        g.trace(key,['%s %s' % (z.val,z.pane) for z in result])
#@+node:ekr.20061031131434.89: *7* bindKey
def bindKey (self,pane,shortcut,callback,commandName,_hash=None,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    _hash gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %30s %s' % (pane,shortcut,commandName,_hash))
        g.trace(g.callers())
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName,_hash=_hash)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90: *8* << give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@+node:ekr.20061031131434.92: *8* << remove previous conflicting definitions from bunchList >>
# b is the bunch for the new binding.

### This warning should never happen with the new code in makeBindingsFromCommandsDict.

if not modeFlag and self.warn_about_redefined_shortcuts:
    
    redefs = [b2 for b2 in bunchList
        if b2.commandName != commandName and
            # pane != b2.pane and # 2011/02/11: don't give warning for straight substitution.
            pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]

    if redefs:
        def pr(commandName,pane,theHash):
            g.es_print('%30s in %5s from %s' % (commandName,pane,theHash))
    
        g.warning('shortcut conflict for %s' % c.k.prettyPrintKey(shortcut))
        pr(commandName,pane,_hash)
        for z in redefs:
            pr(z.commandName,z.pane,z._hash)

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@+node:ekr.20061031131434.102: *7* makeBindingsFromCommandsDict & helper
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bunches b with b.val equal to the stroke.
    d = c.commandsDict ; d2 = {} 
    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'move-outline-down': g.trace(bunchList)
        for b in bunchList:
            # Important: regularize the binding value here.
            val = k.shortcutFromSetting(b.val)
            b.commandName = commandName
            aList = d2.get(val,[])
            aList.append(b)
            d2[val] = aList

    # g.trace(list(d2.keys()))
    
    # Step 2: Remove overridden entries from the bunchlist for each stroke.
    if self.new_bindings:
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            aList = self.mergeShortcutList(aList,stroke)
            d2 [stroke] = aList

    # Step 3: make the bindings.
    if 1: # New code
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            # if stroke == 'Ctrl+q': g.trace('***',stroke,aList)
            for bunch in aList:
                commandName = bunch.commandName
                command = c.commandsDict.get(commandName)
                _hash = bunch.get('_hash') # 2011/02/10
                pane = bunch.pane
                if trace and not _hash:
                    g.trace('**** no hash for',commandName)
                if stroke and not pane.endswith('-mode'):
                    k.bindKey(pane,stroke,command,commandName,_hash=_hash)
    else: ### old code
        d = c.commandsDict
        for commandName in sorted(d):
            command = d.get(commandName)
            key, bunchList = c.config.getShortcut(commandName)
            # if commandName in ('full-command'): g.trace(key,bunchList)
            for bunch in bunchList:
                accel = bunch.val ; pane = bunch.pane
                _hash = bunch.get('_hash') # 2011/02/10
                if trace and not _hash: g.trace('**** no hash for',commandName)
                # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
                if accel and not pane.endswith('-mode'):
                    shortcut = k.shortcutFromSetting(accel)
                    k.bindKey(pane,shortcut,command,commandName,_hash=_hash)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@+node:ekr.20110211094454.15414: *8* mergeShortcutList
def mergeShortcutList (self,aList,stroke): # stroke is for debugging.

    '''aList is a list of binding bunches for stroke.
    
    Return a new list consisting only of bindings from the highest priority .leo file.'''
    
    # Find the higest priority hash.
    trace = False and not g.unitTesting
    verbose = False
    k = self.c.k
    sList,mList,fList = [],[],[]
    # if stroke == 'Alt-F4': g.pdb()
    for b in aList:
        _hash = b.get('_hash','<no hash>')
        if _hash.endswith('myleosettings.leo'):
            mList.append(b)
        elif _hash.endswith('leosettings.leo'):
            sList.append(b)
        elif _hash.endswith('.leo'):
            fList.append(b)

    result = fList or mList or sList or aList
            
    if trace:
        def pr(stroke,message,aList):
            print('mergeShortcutList: %15s %s %s' % (stroke,message,
                '...\n'.join(['%15s %5s %s' % (k.shortcutFromSetting(z.val),z.pane,z.commandName) for z in aList])))
        if fList and mList:
            pr(stroke,'ignoring  mList',mList)
            pr(stroke,'retaining fList',fList)
        if fList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining fList',fList)
        elif mList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining mList',mList)

    if trace and verbose and len(result) > 1: g.trace(stroke,result)
    return result
#@+node:ekr.20110304061301.14035: *4* Colorize url's in the qt gui
@nocolor-node

How did we ever live without this?

You can open url's by control-clicking on them, or by using the open-url command.
#@+node:ekr.20110325075339.14477: *4* Added namespace arg in c.executeScript
#@+node:ekr.20110314123359.14272: *4* Improved the autocompleter
@nocolor-node
    
What I did:
    
- Added @bool use_qcompleter setting.
- Added auto_tab_complete setting.

- Removed @bool use_codewise setting.
#@+node:ekr.20110518103946.18158: *4* Put Kent's Runwith class in scripts.leo and contrib
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b8e8fbf6d97fa9f2/a4537fafaf2442ba

#@+node:ekr.20110518140548.18150: *5* Description
@nocolor-node

This code contributed by Kent Tenney.

See http://groups.google.com/group/leo-editor/browse_thread/thread/b8e8fbf6d97fa9f2/a4537fafaf2442ba

I've had endless problems with interpreter versioning, leading me create the
Runwith class. It writes a file to disk, makes it executable, runs it, captures
exitcode, err and output, removes the files, provides reports.

This provides complete decoupling from Leo.

I have run-bash and run-python buttons in Leo which run the node
contents as shell or python.

I'm liking it a lot.

I'm currently extending it to provide command line sugar:

$ rw ln -s /home/ktenney/work/src/project/bin/myscript
/home/ktenney/bin --makelink.sh--

The "rw" script executes the command, and creates the script makelink.sh

The following is Outline -> Copy Node version of the Runwith class

It does some data gathering which probably don't apply: hashes of the code,
hostname, timestamps. These get stored in json.
#@+node:ekr.20110518140548.18161: *5* class Runwith
class Runwith(object):
   """Generate and manage scripts.

   >>> import getatdata

   """
   import tempfile
   import os
   import platform
   import json
   import md5
   import time
   import subprocess
   @others
#@+node:ekr.20110518140548.18162: *6* __init__
def __init__(self, interpreter, code,
            cleanup=True, autorun=True,
            ):
   """Init a Runwith object, will run ``code`` using ``interpreter``

   >>> import getatdata
   >>> rw = getatdata.Runwith('/bin/bash', 'ls -la /tmp')
   >>> rw.get_runfile()
   '/tmp/...

   >>> rw.get_runfile('/tmp/listing')
   '/tmp/listing'

   """

   self.interpreter = interpreter
   self.code = code
   self._normalize_code()
   self.cleanup = cleanup
   self.fbase = self.tempfile.mktemp()
   self.runfile = self.fbase + '.run'
   self.outfile = self.fbase + '.out'
   self.errfile = self.fbase + '.err'
   self.jsonfile = self.fbase + '.json'
   self.fileset = [self.outfile, self.errfile, self.runfile, self.jsonfile]
   self.hostname = platform.node()
   if autorun:
       self.run()

#@+node:ekr.20110518140548.18163: *6* _prepare_run
def _prepare_run(self):
   """
   """

   self.hashbang = "#!" + self.interpreter
   contents = self.hashbang + "\n" + self.code + "\n"
   with file(self.runfile, 'w') as f:
       f.write(self.hashbang + '\n' + self.code + '\n')
       f.close()
       self.os.chmod(self.runfile, 0500)
#@+node:ekr.20110518140548.18164: *6* _prepare_jsonfile
def _prepare_jsonfile(self):
   """
   """

   with file(self.jsonfile, 'w') as f:
       f.write(self.json_data)
#@+node:ekr.20110518140548.18165: *6* _normalize_code
def _normalize_code(self):
   """Normalize the spacing in a command line.

   We don't want whitespace variations to result in different hashes for
   the same command.
   """

   # don't try to normalize scripts
   fixed_code = self.code.strip()
   if '\n' in fixed_code:
       self.multiline = True

   else:
       self.multiline = False
       # normalize the command line
       chunks = self.code.split()
       fixed_code = ' '.join(chunks)

   self.code = fixed_code

   code_hash_obj = self.md5.md5(fixed_code)
   self.codehash = code_hash_obj.hexdigest()
#@+node:ekr.20110518140548.18166: *6* run
def run(self):
   """Do it.

   """

   #create output files for writing
   outfile = file(self.outfile, 'w')
   errfile = file(self.errfile, 'w')
   self._prepare_run()
   self.begintime = self.time.time()
   self.exitcode = self.subprocess.Popen(self.runfile, shell=True,
                             stdout=outfile, stderr=errfile).wait()
   self.endtime = self.time.time()
   outfile = file(self.outfile)
   errfile = file(self.errfile)
   self.out = outfile.read()
   self.err = errfile.read()
   outfile.close()
   errfile.close()
   self._report()
   if self.cleanup:
       self._cleanup()
#@+node:ekr.20110518140548.18167: *6* _report
def _report(self):
   """
   """

   rundict = {'exitcode':self.exitcode,
              'stdout':self.out, 'stderr':self.err}
   rundict['code'] = self.code
   rundict['hashbang'] = self.hashbang
   rundict['hostname'] = self.hostname
   rundict['codehash'] = self.codehash
   humantime = self.time.ctime(self.endtime)
   timestamps = {'begintime':self.begintime, 'endtime':self.endtime,
                 'humantime':humantime}
   rundict['timestamps'] = timestamps

   self.rundict = rundict
   self.json_data = self.json.dumps(rundict)

#@+node:ekr.20110518140548.18168: *6* _cleanup
def _cleanup(self):
   """Remove files.

   """

   for f in self.fileset:
       if os.path.exists(f):
           os.remove(f)
#@+node:ekr.20110518140548.18169: *6* get_runfile
def get_runfile(self, fname=None):
   """Create the executable and return it's filename.
   """

   if fname is not None:
       self.runfile = fname

   if fname is not self.runfile:
       self._prepare_run()

   return self.runfile



#@+node:ekr.20110518140548.18170: *6* get_jsonfile
def get_jsonfile(self, fname='codehash'):
   """Create the json file and return it's filename.
   """

   if fname is not None:
       if fname is 'codehash':
           # name according to the code and run timestamp
           hash = self.codehash
           ts = str(self.rundict['timestamps']['begintime'])
           jsonfile = hash + "-" + ts + ".json"

       else:
           # use the tempfile name
           jsonfile = fname

   dest_dir = self.os.path.dirname(self.fbase)
   self.jsonfile = os.path.join(dest_dir, jsonfile)
   self._prepare_jsonfile()
   return self.jsonfile



#@+node:ekr.20110519074734.6091: *4* Added first draft of per-node undo
@nocolor-node

What I did:
    
- Added the per_node_undo ivar.
- Inserted call to u.onSelect in leoTree.select.
- onSelect calls setIvarsFromVnode and putIvarsToTnode.
- setUndoTypingParams calls putIvarsToVnode.

That's all!
#@+node:ekr.20031218072017.3606: *5* undo.__init__
def __init__ (self,c):

    self.c = c
    self.debug = False # True: enable debugging code in new undo scheme.
    self.debug_print = False # True: enable print statements in debug code.

    self.granularity = c.config.getString('undo_granularity')
    if self.granularity: self.granularity = self.granularity.lower()
    if self.granularity not in ('node','line','word','char'):
        self.granularity = 'line'
    # g.trace('undoer',self.granularity)

    self.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if self.debug is on).
    self.new_mem = 0
    self.old_mem = 0

    # State ivars...
    self.beads = [] # List of undo nodes.
    self.bead = -1 # Index of the present bead: -1:len(beads)
    self.undoType = "Can't Undo"

    # These must be set here, _not_ in clearUndoState.
    self.redoMenuLabel = "Can't Redo"
    self.undoMenuLabel = "Can't Undo"
    self.realRedoMenuLabel = "Can't Redo"
    self.realUndoMenuLabel = "Can't Undo"
    self.undoing = False # True if executing an Undo command.
    self.redoing = False # True if executing a Redo command.
    
    self.per_node_undo = False # True: v may contain undo_info ivar.

    # New in 4.2...
    self.optionalIvars = []

    # Set the following ivars to keep pylint happy.
    self.afterTree = None
    self.beforeTree = None
    self.children = None
    self.dirtyVnodeList = None
    self.followingSibs = None
    self.kind = None
    self.newBack = None
    self.newBody = None
    self.newChanged = None
    self.newChildren = None
    self.newHead = None
    self.newMarked = None
    self.newN = None
    self.newP = None
    self.newParent = None
    self.newParent_v = None
    self.newRecentFiles = None
    self.newTree = None
    self.oldBack = None
    self.oldBody = None
    self.oldChanged = None
    self.oldChildren = None
    self.oldHead = None
    self.oldMarked = None
    self.oldN = None
    self.oldParent = None
    self.oldParent_v = None
    self.oldRecentFiles = None
    self.oldTree = None
    self.pasteAsClone = None
    self.sortChildren = None

def redoHelper(self):
    pass

def undoHelper(self):
    pass
#@+node:ekr.20110519074734.6094: *5* onSelect & helpers (new)
def onSelect (self,old_p,p):
    
    trace = False and not g.unitTesting
    u = self
    
    if trace: g.trace(old_p and old_p.h,p.h)

    if u.per_node_undo:
        
        if old_p and u.beads:
            u.putIvarsToVnode(old_p)

        u.setIvarsFromVnode(p)
        u.setUndoTypes()
#@+node:ekr.20110519074734.6096: *6* putIvarsToVnode (new)
def putIvarsToVnode(self,p):

    trace = False and not g.unitTesting
    u = self ; v = p.v
    
    assert self.per_node_undo

    bunch = g.bunch()
    
    for key in self.optionalIvars:
        bunch[key] = getattr(u,key)
        
    # Put these ivars by hand.
    for key in ('bead','beads','undoType',):
        bunch[key] = getattr(u,key)
        
    v.undo_info = bunch
        
    if trace: g.trace('****',v.h,bunch.bead)
#@+node:ekr.20110519074734.6095: *6* setIvarsFromVnode (new)
def setIvarsFromVnode(self,p):

    u = self ; v = p.v
    
    assert self.per_node_undo
    
    u.clearUndoState()

    if hasattr(v,'undo_info'):
        u.setIvarsFromBunch(v.undo_info)
#@+node:ekr.20031218072017.1490: *5* setUndoTypingParams (changed)
def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    trace = False and not g.unitTesting
    verbose = False
    u = self ; c = u.c
    << return if there is nothing to do >>
    if trace: g.trace(undo_type,oldSel,newSel)
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    
    if u.per_node_undo:
        u.putIvarsToVnode(p)
        
    return bunch # Never used.
#@+node:ekr.20040324061854: *6* << return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@+node:ekr.20040324061854.1: *6* << init the undo params >>
# Clear all optional params.
# for ivar in u.optionalIvars:
    # setattr(u,ivar,None)
u.clearOptionalIvars()

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@+node:ekr.20031218072017.1491: *6* << compute leading, middle & trailing  lines >>
@ Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace and verbose:
    g.pr("lead,trail",leading,trailing)
    g.pr("old mid,nls:",len(old_middle_lines),old_newlines,oldText)
    g.pr("new mid,nls:",len(new_middle_lines),new_newlines,newText)
    #g.pr("lead,trail:",leading,trailing)
    #g.pr("old mid:",old_middle_lines)
    #g.pr("new mid:",new_middle_lines)
    g.pr("---------------------")
#@+node:ekr.20031218072017.1492: *6* << save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.b.
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = '\n'.join(old_middle_lines)
    s2 = '\n'.join(new_middle_lines)
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@+node:ekr.20040324061854.2: *6* << save the selection and scrolling position >>
# Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@+node:ekr.20040324061854.3: *6* << adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we
may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()

# Bug fix: Leo 4.4.6: always add p to the list.
bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@+node:ekr.20050125220613: *7* << set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.trace('Unexpected exception...',color='blue')
            g.es_exception()
            newBead = True
#@+node:ekr.20050125203937: *8* << set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    # 2011/04/01: Patch by Sam Hartsfield
    old_row,old_col = g.convertPythonIndexToRowCol(oldText,old_start)
    new_row,new_col = g.convertPythonIndexToRowCol(newText,new_start)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        # 2011/04/01: Patch by Sam Hartsfield
        old_s = old_lines[old_row]
        new_s = new_lines[new_row]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            # g.trace(repr(old_ch),repr(new_ch))
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@+node:ekr.20110520051220.18185: *4* Added patch to g.wrap_lines from Jos Rojas Echenique
It regularizes the number of spaces after periods.

The fill-paragraph command and sentence spacing
http://groups.google.com/group/leo-editor/browse_thread/thread/1171df34dce14431

http://en.wikipedia.org/wiki/Sentence_spacing

Changed several unit tests for reformat-paragraph so they pass.
#@+node:ekr.20110520051220.18186: *4* Problems with per-node undo
@language rest

Per-node undo: impossible. Node versioning: possible.
http://groups.google.com/group/leo-editor/browse_thread/thread/e9348fbe22f547ad

Here I shall discuss the design difficulties in supporting per-node undo. As I
said earlier, the code itself is clean, but as we shall see it sweeps too much
under the rug.

To state my conclusion first: local undo is likely impossible. Otoh, node
versioning, which aims at recreating only the text (headline or body) of nodes,
is quite feasible.

There are two interrelated difficulties with local undo. The first is serious,
the second is fatal.

1. Per-node undo is not sufficient. We need *both* a global undo and a local undo.

The user must be able to choose which is desired. Naturally, this leads to
increased complexity in a frequently-used feature. This kind of change is always
problematic.

Furthermore, there are (or would be) grave difficulties in correlating local and
global undo operations. However, we can ignore these difficulties because the
next problem is intractable.

2. Per-node undo is invalid.

In effect, the present per-node undo partitions all actions by vnode. There is
no global undo at all. That is, each vnode has its *own* undo stack.

Alas, in general it is invalid to treat operations this way. For example,
suppose a local undo stack contains an entry for move-outline-up command. When
executed in a *global* context (that is, with a global undo stack), the Leo
outline is guaranteed to be in a state in which this undo operation is valid.

But the operation may not be valid when the undo entry appears in a *local*
context. To see this, suppose the global stack contains a promote or demote
operation. This operation affects children, but this operation does *not* appear
in the local undo stack for the children. Thus, a node may have a prior sibling
in a global context (after a series of global undos), but might *not* have such
a sibling after a series of local undos.

This is a show-stopper.
#@+node:ekr.20101118113953.5844: *4* Use new reformatParagraph code
#@+node:ekr.20101118113953.5839: *5* c.reformatParagraph & helpers
def reformatParagraph (self,event=None,undoType='Reformat Paragraph'):

    """Reformat a text paragraph

    Wraps the concatenated text to present page width setting. Leading tabs are
    sized to present tab width setting. First and second line of original text is
    used to determine leading whitespace in reformatted text. Hanging indentation
    is honored.

    Paragraph is bound by start of body, end of body and blank lines. Paragraph is
    selected by position of current insertion cursor.

"""

    c = self ; body = c.frame.body ; w = body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        i,j = w.getSelectionRange()
        w.setInsertPoint(i)

    oldSel,oldYview,original,pageWidth,tabWidth = c.rp_get_args()
    head,lines,tail = c.findBoundParagraph()
    if lines:
        indents,leading_ws = c.rp_get_leading_ws(lines,tabWidth)
        result = c.rp_wrap_all_lines(indents,leading_ws,lines,pageWidth)
        c.rp_reformat(head,oldSel,oldYview,original,result,tail,undoType)
#@+node:ekr.20031218072017.1825: *6* c.findBoundParagraph
def findBoundParagraph (self,event=None):

    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None

    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    for line in tail_lines:
        if not line or line.isspace() or line.startswith('@'):
            break
        i += 1

    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]

    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    return head,result,tail # string, list, string
#@+node:ekr.20031218072017.1826: *7* << trace head_lines, ins, tail_lines >>
if 0:
    g.pr("\nhead_lines")
    for line in head_lines:
        g.pr(line)
    g.pr("\nins", ins)
    g.pr("\ntail_lines")
    for line in tail_lines:
        g.pr(line)
else:
    g.es_print("head_lines: ",head_lines)
    g.es_print("ins: ",ins)
    g.es_print("tail_lines: ",tail_lines)
#@+node:ekr.20101118113953.5840: *6* rp_get_args
def rp_get_args (self):

    '''Compute and return oldSel,oldYview,original,pageWidth,tabWidth.'''

    c = self ; body = c.frame.body ;  w = body.bodyCtrl

    d = c.scanAllDirectives()

    if c.editCommands.fillColumn > 0:
        pageWidth = c.editCommands.fillColumn
    else:
        pageWidth = d.get("pagewidth")
        
    tabWidth  = d.get("tabwidth")
    original = w.getAllText()
    oldSel =  w.getSelectionRange()
    oldYview = body.getYScrollPosition()

    return oldSel,oldYview,original,pageWidth,tabWidth
#@+node:ekr.20101118113953.5841: *6* rp_get_leading_ws
def rp_get_leading_ws (self,lines,tabWidth):

    '''Compute and return indents and leading_ws.'''

    c = self

    indents = [0,0]
    leading_ws = ["",""]

    for i in (0,1):
        if i < len(lines):
            # Use the original, non-optimized leading whitespace.
            leading_ws[i] = ws = g.get_leading_ws(lines[i])
            indents[i] = g.computeWidth(ws,tabWidth)

    indents[1] = max(indents)

    if len(lines) == 1:
        leading_ws[1] = leading_ws[0]

    return indents,leading_ws
#@+node:ekr.20101118113953.5842: *6* rp_reformat
def rp_reformat (self,head,oldSel,oldYview,original,result,tail,undoType):

    '''Reformat the body and update the selection.'''

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    s = w.getAllText()

    # This destroys recoloring.
    junk, ins = body.setSelectionAreas(head,result,tail)

    changed = original != head + result + tail
    if changed:
        # 2010/11/16: stay in the paragraph.
        body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)
    else:
        # Advance to the next paragraph.
        ins += 1 # Move past the selection.
        while ins < len(s):
            i,j = g.getLine(s,ins)
            line = s[i:j]
            # 2010/11/16: it's annoying, imo, to treat @ lines differently.
            if line.isspace(): ### or line.startswith('@'):
                ins = j+1
            else:
                ins = i ; break

        # setSelectionAreas has destroyed the coloring.
        c.recolor()

    w.setSelectionRange(ins,ins,insert=ins)
    
    # Make the next line visible: this is a big improvement.
    w.see(ins+5)
#@+node:ekr.20101118113953.5843: *6* rp_wrap_all_lines
def rp_wrap_all_lines (self,indents,leading_ws,lines,pageWidth):

    '''compute the result of wrapping all lines.'''

    trailingNL = lines and lines[-1].endswith('\n')
    lines = [g.choose(z.endswith('\n'),z[:-1],z) for z in lines]

    # Wrap the lines, decreasing the page width by indent.
    result = g.wrap_lines(lines,
        pageWidth-indents[1],
        pageWidth-indents[0])

    # prefix with the leading whitespace, if any
    paddedResult = []
    paddedResult.append(leading_ws[0] + result[0])
    for line in result[1:]:
        paddedResult.append(leading_ws[1] + line)

    # Convert the result to a string.
    result = '\n'.join(paddedResult)
    if trailingNL: result = result + '\n'

    return result
#@+node:ekr.20110521065021.18163: *4* Added support for cython
#@+node:ekr.20031218072017.368: *5* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    "cython"        : "pyd",
    "cython"        : "pyi",
    "cython"        : "pyx",
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
#@+node:ekr.20110520051220.18192: *4* A bad idea: auto-edit nodes whose headline is "newHeadline"
@nocolor-node

Enter Headline Edit Mode when current node is the default
https://bugs.launchpad.net/leo-editor/+bug/701188

This seems to be impossible to do in the Qt gui code,
for reasons I don't fully understand, but are not really surprising.

Furthermore, doing this on a prototype basis in c.doCommand showed
that this is a bad idea.
#@+node:ekr.20110520051220.18198: *4* Added namespace and Leo comment lines to .leo files
# This is the easy part of the new file format.
#@+node:ekr.20031218072017.1246: *5* putProlog
def putProlog (self):

    c = self.c

    self.putXMLLine()
    
    # Put "created by Leo" line.
    self.put('<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->')
    self.put_nl()

    if c.config.stylesheet or c.frame.stylesheet:
        self.putStyleSheetLine()

    # Put the <leo_file> element.
    # New in Leo 4.9: this element contains a namespace.
    self.put('<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >')
    # self.put("<leo_file>")
    self.put_nl()
#@+node:ekr.20110518103946.18182: *4* Call os.chdir when executing scripts
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/4ea31ed2e0518866/3667f707b99ee9e3

Call os.chdir() to set the current directory to match any @path directives in
effect at the current node when a script is run or a button pushed?

Ville and Terry have convinced me that it is worth doing on an experimental
basis.


**Note**: only the scripts_menu plugin calls g.executeScript.
#@+node:ekr.20031218072017.3138: *5* g.executeScript
def executeScript (name):

    """Execute a script whose short python file name is given.

    This is called only from the scripts_menu plugin."""

    mod_name,ext = g.os_path_splitext(name)
    theFile = None
    try:
        # This code is in effect an import or a reload.
        # This allows the user to modify scripts without leaving Leo.
        import imp
        theFile,filename,description = imp.find_module(mod_name)
        imp.load_module(mod_name,theFile,filename,description)
    except Exception:
        g.es("exception executing",name,color="red")
        g.es_exception()

    if theFile:
        theFile.close()
#@+node:ekr.20031218072017.2140: *5* c.executeScript & helpers
def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False,
    namespace=None):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        oldLog = g.app.log # 2011/01/19
        log = c.frame.log
        g.app.log = log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # g.pr('*** script',script)
            try:
                p = c.p
                if p: c.setCurrentDirectoryFromContext(p)
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if namespace: d.update(namespace)
                if args:
                    # g.trace('setting sys.argv',args)
                    sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    if g.isPython3:
                        exec(compile(script,scriptFile,'exec'),d)
                    else:
                        execfile(scriptFile,d)
                else:
                    exec(script,d)
                if 0: # This message switches panes, and can be disruptive.
                    if not script1 and not silent:
                        # Careful: the script may have changed the log tab.
                        tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                        g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        g.app.log = oldLog # 2011/01/19
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143: *6* redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@+node:ekr.20110522121957.18230: *6* setCurrentDirectoryFromContext
def setCurrentDirectoryFromContext(self,p):
    
    trace = False and not g.unitTesting
    c = self
    
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    
    curDir = g.os_path_abspath(os.getcwd())

    # g.trace(p.h,'\npath  ',path,'\ncurDir',curDir)
    
    if path and path != curDir:
        if trace: g.trace('calling os.chdir(%s)' % (path))
        try:
            os.chdir(path)
        except Exception:
            pass
#@+node:EKR.20040627100424: *6* unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@+node:ekr.20070115135502: *6* writeScriptFile (changed)
def writeScriptFile (self,script):

    trace = False and not g.unitTesting
    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.homeLeoDir,'scriptFile.py')

    if trace: g.trace(path)                

    # Write the file.
    try:
        if g.isPython3:
            # Use the default encoding.
            f = open(path,encoding='utf-8',mode='w')
        else:
            f = open(path,'w')
        s = script
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,reportErrors=True)
        f.write(s)
        f.close()
    except Exception:
        g.es_exception()
        g.es("Failed to write script to %s" % path)
        # g.es("Check your configuration of script_file_path, currently %s" %
            # c.config.getString('script_file_path'))
        path = None

    return path
#@+node:ekr.20110522121957.18230: *5* setCurrentDirectoryFromContext
def setCurrentDirectoryFromContext(self,p):
    
    trace = False and not g.unitTesting
    c = self
    
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    
    curDir = g.os_path_abspath(os.getcwd())

    # g.trace(p.h,'\npath  ',path,'\ncurDir',curDir)
    
    if path and path != curDir:
        if trace: g.trace('calling os.chdir(%s)' % (path))
        try:
            os.chdir(path)
        except Exception:
            pass
#@+node:ekr.20110522121957.18231: *4* Don't select opening ( in calltips
#@+node:ekr.20110512090917.14469: *5* calltip_success
def calltip_success(self,prefix,obj):
    
    trace = False and not g.unitTesting
    
    try:
        # Get the parenthesized argument list.
        s1,s2,s3,s4 = inspect.getargspec(obj)
        s = inspect.formatargspec(s1,s2,s3,s4)
        if trace: g.trace(obj,repr(s))
    except Exception:
        if trace: g.trace('inspect failed. obj: %s' % (obj))
        self.insert_string('(')
        return

    # Clean s and insert it: don't include the opening "(".
    if g.match(s,1,'self,'):
        s = s[6:].strip()
    elif g.match_word(s,1,'self'):
        s = s[5:].strip()
    else:
        s = s[1:].strip()

    self.insert_string("(",select=False)
    self.insert_string(s,select=True)
#@+node:ekr.20110518103946.18183: *4* Fixed mod_http plugin
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/196d37a58bb2dd80/ca526f0be4101f09
#@+node:ekr.20110518103946.18180: *4* Leo is no longer supported for Tk on MacOS
@nocolor-node

The following two bugs are critical, and yet do not seem worth fixing.

Outline commands execute twice under OS X

http://groups.google.com/group/leo-editor/browse_thread/thread/2c86f8363c48dfa2/5a78221010366231

With OSX and Tk, some "Outline" commands execute twice when used called by a
keyboard shortcut for me. This is incredibly unnerving for commands such as Cut
Node, Paste Node, Delete Node or Paste Node as Clone. Using the commands from
the menu bar works as expected. Strangely enough, Insert Node is not affected.

I use OSX 10.6.6, python 2.6.1 and gui=tk

=======

Uncloseable modal window under OS X
		
http://groups.google.com/group/leo-editor/browse_thread/thread/653838b2112b781b/cc4ab2919f5785cd

I've been having trouble with an uncloseable modal Window under OS X that
prompts: "myfilename already exists. Overwrite this file?"

The options Yes, No and Cancel are displayed but not clickable and
there is no title bar. No keyboard shortcuts I tried closed the
window. The only possibility is to kill the python process running
leo, losing all changes made...
Strangely enough this window only appears from time to time, while
most of the time  saving changes just overwrites without asking.
I don't know what information to post about my environment. I use the
standard OSX python install (2.6.1) and launch leo with "./
launchLeo.py --gui=tk".
#@+node:ekr.20080806054207.3: *4* Rejected: Auto scroll outline pane
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/76789df8aac08c70

When using leo as outliner, I often use only node headlines to write
down some data. If the headline string is too long, the cursor goes
beyond the visible area. When modifying a node headline, is it
possible to make leo to auto-scroll, so the cursor is always visible?

I'm not going to do this.  You can use the scroll-outline-right/left commands.
#@+node:ekr.20110523130519.18192: *4* Now a wishlist: Bug 394309: PgUp/PgDown should scroll the body, not the tree
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/394309

This is followup to

https://bugs.launchpad.net/bugs/384336

Currently, pgup/pgdown move the scroll bar on tree widget, but don't move the
selection. This is very annoying when you have scrolled to a position and start
moving to alt+up/alt+down (it nudges back to the original position and starts
moving from there).

Since the old "default" behaviour can't be easily implemented, I suggest
another, better use for the pgup/pgdn navigation keys while in tree pane: use
them to scroll up/down the body, *but* retain the focus in tree. This allows you
to browse the body text while remaining in the tree.

EKR: I'm going to mark this (once again) as a wish-list item. There is no real
bug involved and the feature is both a bit too cute for my taste.

Having said that, this feature request could be called a preference. I'll accept
a patch if one appears.

#@+node:ekr.20101116100300.5827: *4* Rejected: Write script file to temp file if @bool write_script_file is False
@nocolor-node

Use a temp file to hold sources if @bool write_script_file is False.

This is a bad idea.  The existing settings are good enough.
#@+node:ekr.20110523130519.18196: *4* Fixed Bug 745824: @doc duplicates comment delims in html files
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/745824e

In the new sentinels scheme @doc parts written with block comment delims must
handled differently. This is done in the new at.massageAtDocPart method.


#@+node:ekr.20110523201030.18289: *5* Report
@nocolor-node

Since v4.8 notice the following:

@file node using @language html

Using @doc (or simply @ ) in these nodes properly writes the comment delimiters
(<!-- and -->) surrounding the @doc block on file save. However, on file open,
when Leo reads the @files, it raises the following error:

uncached read node changed NodeHeadline

and an entry is made in Recovered Nodes section. If not reverted back to the old
version (manually), a new file save command will insert additional comment
delimiters which then don't work (<!-- <1-- and --> -->).

May be related to https://bugs.launchpad.net/leo-editor/+bug/683867 The nodes
affected for me were all clones, but not across different @files, all within
distinct files.
#@+node:ekr.20110523201030.18287: *5* Changed
#@+node:ekr.20041005105605.98: *6* at.readEndOthers
def readEndOthers (self,unused_s,unused_i):

    """Read an @-others sentinel."""

    at = self

    at.popSentinelStack(at.endOthers)

    if at.readVersion5:
        # g.trace(at.readVersion5,repr(at.docOut))
        # Terminate the *previous* doc part if it exists.
        if at.docOut:
            s = ''.join(at.docOut)
            s = at.massageAtDocPart(s) # 2011/05/24
            at.appendToOut(s)
            at.docOut = []
            at.inCode = True

        # Restore the node continain the @others directive.
        # *Never* terminate new-sentinel nodes until the post-pass.
        at.raw = False # End raw mode.
        at.v = at.endSentinelNodeStack.pop()
        at.indent = at.endSentinelIndentStack.pop()
        oldLevel = len(at.thinNodeStack)
        newLevel = at.endSentinelLevelStack.pop()
        at.changeLevel(oldLevel,newLevel)
#@+node:ekr.20041005105605.106: *6* at.readDirective (@@)
def readDirective (self,s,i):

    """Read an @@sentinel."""

    trace = False and not g.unitTesting
    at = self
    assert g.match(s,i,"@"),'missing @@ sentinel'
        # The first '@' has already been eaten.

    if trace: g.trace(repr(s[i:]))
        # g.trace(g.get_line(s,i))

    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False

    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'

    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')

    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    # An @c ends the doc part when using new sentinels.
    if at.readVersion5 and s2 in ('@c','@c\n','@code','@code\n'):
        if at.docOut:
            s = ''.join(at.docOut)
            s = at.massageAtDocPart(s) # 2011/05/24
            at.appendToOut(s)
            at.docOut = []
        at.inCode = True # End the doc part.

    at.appendToOut(s2)
#@+node:ekr.20041005105605.107: *7* << handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

if trace:
    g.trace(g.get_line(s,i))
    g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @language sentinel:",line,color="red")
#@+node:ekr.20041005105605.108: *7* << handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @comment sentinel:",line,color="red")
#@+node:ekr.20110523201030.18288: *6* at.massageAtDocPart (new)
def massageAtDocPart (self,s):
    
    '''Compute the final @doc part when block comments are used.'''
    
    at = self
    
    if at.endSentinelComment:
        ok1 = s.startswith(at.startSentinelComment+'\n')
        ok2 = s.endswith(at.endSentinelComment+'\n')
        if ok1 and ok2:
            n1 = len(at.startSentinelComment)
            n2 = len(at.endSentinelComment)
            s = s[n1+1:-(n2+1)]
        else:
            at.error('invalid @doc part...\n%s' % repr(s))
            
    # g.trace(repr(s))
    return s
#@+node:ekr.20110525181446.18336: *4* Added a splash screen (Qt only)
@nocolor-node


The --no-splash command-line option suppresses the splash screen.  In addition,
Leo puts up no splash screen when the --silent or --script command-line options
are given. 

To change the splash screen, replace leo\Icons\SplashScreen.jpg with another image.

#@+node:ekr.20110527084258.18369: *5* Added --no-splash command-line option
@nocolor-node
 The --no-splash command-line option suppresses the splash screen.  In addition,
Leo puts up no splash screen when the --silent or --script command-line options
are given. 
#@+node:ekr.20031218072017.1416: *6* app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.atPathInBodyWarning = None # Set by get_directives_dict
        # The headline of the @<file> node containing
        # an @path directive in the body.
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.commandInterruptFlag = False # True: command within a command.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.db = None # Set to a leoCacher later.
    self.debug = False
        # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.disableSave = False
    self.dragging = False # Application-wide dragging flag.
    self.enableUnitTest = True
    self.extensionsDir = None
    self.globalConfigDir = None
        # The directory assumed to contain the global configuration files.
    self.globalOpenDir = None # The directory last used to open a file.
    self.gui = None # The gui class.
    self.guiArgName = None # The gui name given in --gui option.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.homeLeoDir = None
        # The '.leo' subdirectory of the user's home directory.
    self.homeSettingsPrefix = '.'
        # prepend to "myLeoSettings.leo" and <machineName>LeoSettings.leo
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100
        # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False
        # True: the global idleTimeHookHandler will reshedule itself.
    self.inBridge = False # True: running from leoBridge module.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.log = None # The LeoFrame containing the present log.
    self.logInited = False # False: all log message go to logWaiting list.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.oneConfigFilename = ''
        # If non-empty, the name of a single configuration file.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0
        # Used to generate temp file names for Open With command.
    self.openWithTable = None
        # The table passed to createOpenWithMenuFromTable.
    self.pluginsController = None # Set early in the init process.
    self.positions = 0 # Count of the number of positions generated.
    self.printWaiting = [] # Queue of messages to be sent to the printer.
    self.qt_use_tabs = False # True: allow tabbed main window.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {}
        # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scanErrors = 0 # The number of errors seen by g.scanError.
    self.scriptDict = {}
        # For communication between Execute Script command and scripts.
    self.signon_printed = False
    self.silentMode = False # True if signon is more silent.
    self.start_fullscreen = False # For qtGui plugin.
    self.start_maximized = False # For qtGui plugin.
    self.start_minimized = False # For qtGui plugin.
    self.statsDict = {}
        # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.trace_gc = False # defined in run()
    self.trace_gc_calls = False # defined in run()
    self.trace_gc_verbose = False # defined in run()
    self.trace_gc_inited = False
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.translateToUpperCase = False
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTestGui = None # A way to override the gui in external unit tests.
    self.unitTesting = False # True if unit testing.
    self.useIpython = False
    self.use_psyco = False
        # Can't be a config param because it is used
        # before config module can be inited.
    self.use_splash_screen = True
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.windowList = []
        # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None

    << Define global constants >>
    << Define global data structures >>
#@+node:ekr.20031218072017.1417: *7* << define global constants >>
# self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"
self.prolog_namespace_string = \
    'xmlns:leo="http://edreamleo.org/namespaces/leo-python-editor/1.1"'
#@+node:ekr.20031218072017.368: *7* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    "cython"        : "pyd",
    "cython"        : "pyi",
    "cython"        : "pyx",
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
#@+node:ekr.20091007103358.6061: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''
    trace = False

    # Note: this automatically implements the --help option.
    parser = optparse.OptionParser()
    add = parser.add_option
    add('-c', '--config', dest="one_config_path",
        help = 'use a single configuration file')
    add('--debug',        action="store_true",dest="debug",
        help = 'enable debugging support')
    add('-f', '--file',   dest="fileName",
        help = 'load a file at startup')
    add('--gui',
        help = 'gui to use (qt/tk/qttabs)')
    add('--minimized',    action="store_true",
        help = 'start minimized (Qt only)')
    add('--maximized',    action="store_true",
        help = 'start maximized (Qt only)')
    add('--fullscreen',   action="store_true",
        help = 'start fullscreen (Qt only)')
    add('--ipython',      action="store_true",dest="use_ipython",
        help = 'enable ipython support')
    add('--no-cache',     action="store_true",dest='no_cache',
        help = 'disable reading of cached files')
    add('--no-splash',    action="store_true",dest='no_splash_screen',
        help = 'disable the splash screen')
    add('--silent',       action="store_true",dest="silent",
        help = 'disable all log messages')
    add('--screen-shot',  dest='screenshot_fn',
        help = 'take a screen shot and then exit')
    add('--script',       dest="script",
        help = 'execute a script and then exit')
    add('--script-window',dest="script_window",
        help = 'open a window for scripts')
    add('--select',       dest='select',
        help='headline or gnx of node to select')
    add('--version',      action="store_true",dest="version",
        help='print version number and exit')
    add('--window-size',  dest='window_size',
        help='initial window size in height x width format')

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    if trace: print('scanOptions:',sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --debug
    if options.debug:
        g.debug = True
        print('scanOptions: *** debug mode on')

    # -f or --file
    fileName = options.fileName
    if fileName:
        fileName = fileName.strip('"')
        if trace: print('scanOptions:',fileName)

    # --gui
    gui = options.gui

    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            gui = g.app.guiArgName = 'qt'
            g.app.qt_use_tabs = True
        elif gui in ('curses','tk','qt','null'): # 'wx',
            g.app.guiArgName = gui
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s' % gui)
            g.app.guiArgName = gui = 'qt'
            g.app.qt_use_tabs = True
    else:
        gui = g.app.guiArgName = 'qt'
        g.app.qt_use_tabs = True

    assert gui == g.app.guiArgName

    # --minimized
    # --maximized
    # --fullscreen
    g.app.start_minimized = options.minimized
    g.app.start_maximized = options.maximized
    g.app.start_fullscreen = options.fullscreen

    # --ipython
    g.app.useIpython = options.use_ipython

    # --no-cache
    if options.no_cache:
        print('scanOptions: disabling caching')
        g.enableDB = False
        
    # --no-splash
    # g.trace('--no-splash',options.no_splash_screen)
    g.app.use_splash_screen = not options.no_splash_screen

    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn',screenshot_fn)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        script,e = g.readFileIntoString(script_name,kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')

    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select',repr(select))

    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)

    # --version: print the version and exit.
    versionFlag = options.version

    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize',repr(windowSize))
        try:
            h,w = windowSize.split('x')
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:',size)

    # Compute the return values.
    windowFlag = script and script_path_w
    return {
        'fileName':fileName,
        'gui':gui,
        'screenshot_fn':screenshot_fn,
        'script':script,
        'select':select,
        'version':versionFlag,
        'windowFlag':windowFlag,
        'windowSize':windowSize,
    }
#@+node:ekr.20110525112110.18395: *4* Improved expansion of abbreviations
@nocolor-node

Abbreviations are checked any time a non-word character is typed.

In particular, newlines trigger abbreviations, which I find very helpful,
although I did then have to remove newlines from my abbreviations.

Control sequences do not trigger expansions.

Renamed the 'abbrev-mode' to 'toggle-abbrev-mode'.
#@+node:ekr.20061007105001: *5* editWidget (baseEditCommandsClass)
def editWidget (self,event,forceFocus=True):

    c = self.c ; w = event and event.widget

    # g.trace(w,g.app.gui.isTextWidget(w))

    # New in Leo 4.5: single-line editing commands apply to minibuffer widget.
    if w and g.app.gui.isTextWidget(w):
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    if self.w and forceFocus:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@+node:ekr.20061031131434.105: *5* masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            # if commandName == 'select-all': g.pdb()
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@+node:ekr.20061031131434.106: *6* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@+node:ekr.20061031131434.107: *6* << add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@+node:ekr.20061031131434.109: *6* callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
#@+node:ekr.20061031131434.110: *6* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    elif name.startswith('log'):
        if g.app.gui.guiName() == 'tkinter':
            return None
        else:
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event.stroke # 2010/05/04.
            if stroke.lower() == 'return': stroke = '\n'
            elif stroke.lower() == 'tab': stroke = '\t'
            elif stroke.lower() == 'backspace': stroke = '\b'
            elif stroke.lower() == 'period': stroke = '.'
            w.logCtrl.insert(i,stroke)

            return None
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(stroke))
        return None
#@+node:ekr.20050920084036.27: *5* expandAbbrev
def expandAbbrev (self,event,stroke):

    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.

    Words start with '@'.
    '''

    trace = False and not g.unitTesting
    k = self.k ; c = self.c
    ch = event.char
    w = self.editWidget(event,forceFocus=False)
    if not w: return False
    if w.hasSelection(): return False
    if stroke=='BackSpace': return False
    d = {'Return':'\n','Tab':'\t','space':' ','underscore':'_'}
    if stroke:
        ch = d.get(stroke,stroke)
        if len(ch) > 1:
            if (stroke.find('Ctrl+') > -1 or
                stroke.find('Alt+') > -1 or
                stroke.find('Meta+') > -1
            ):
                ch = ''
            else:
                ch = event.char
    else:
        ch = event.char
        
    if trace: g.trace('event.char',repr(event.char),'ch',repr(ch),'stroke',repr(stroke))

    if len(ch) != 1 or (len(ch) == 1 and ch.isalpha()):
        # Normal chars other special chars abort abbreviations.
        return False

    # Get the text and insert point.
    s = w.getAllText()
    i = i1 = w.getInsertPoint()

    # Find the word to the left of the insert point.
    j = i ; i -= 1
    while 0 <= i < len(s) and g.isWordChar(s[i]):
        i -= 1
    if 0 <= i < len(s) and s[i] == '@':
        i -= 1
    i += 1
    word = s[i:j].strip()
    ### if ch: word = word + ch
    if trace: g.trace(i,j,repr(word))
    if not word: return False

    # First, look up the word without ch.
    val,tag = self.abbrevs.get(word,(None,None))
    if trace: g.trace(word,val,tag)
    
    if val:
        # Add ch to the result.
        if ch: val = val + ch
    else:
        # Look up the word with ch.
        if ch and not val:
            val,tag = self.abbrevs.get(word+ch,(None,None))
            if trace: g.trace(word+ch,val,tag)
    if val:
        if trace: g.trace('**inserting',repr(val))
        oldSel = j,j
        c.frame.body.onBodyChanged(undoType='Typing',oldSel=oldSel)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Abbreviation',oldSel=oldSel)

    return val is not None
#@+node:ekr.20110522121957.18233: *4* Many improvements and fixes to viewrendered plugin
@nocolor-node

This also fixes the following bug.
https://bugs.launchpad.net/leo-editor/+bug/755206

* Added support for @bool view-rendered-auto-create.

* Fixed numerous bugs, and made the code more robust.
#@+node:ekr.20110527084258.18376: *4* Improved scrolling after reformat-paragraph
@nocolor-node

The next line is now visible, which is a big improvement.
#@+node:ekr.20101118113953.5839: *5* c.reformatParagraph & helpers
def reformatParagraph (self,event=None,undoType='Reformat Paragraph'):

    """Reformat a text paragraph

    Wraps the concatenated text to present page width setting. Leading tabs are
    sized to present tab width setting. First and second line of original text is
    used to determine leading whitespace in reformatted text. Hanging indentation
    is honored.

    Paragraph is bound by start of body, end of body and blank lines. Paragraph is
    selected by position of current insertion cursor.

"""

    c = self ; body = c.frame.body ; w = body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        i,j = w.getSelectionRange()
        w.setInsertPoint(i)

    oldSel,oldYview,original,pageWidth,tabWidth = c.rp_get_args()
    head,lines,tail = c.findBoundParagraph()
    if lines:
        indents,leading_ws = c.rp_get_leading_ws(lines,tabWidth)
        result = c.rp_wrap_all_lines(indents,leading_ws,lines,pageWidth)
        c.rp_reformat(head,oldSel,oldYview,original,result,tail,undoType)
#@+node:ekr.20031218072017.1825: *6* c.findBoundParagraph
def findBoundParagraph (self,event=None):

    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None

    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    for line in tail_lines:
        if not line or line.isspace() or line.startswith('@'):
            break
        i += 1

    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]

    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    return head,result,tail # string, list, string
#@+node:ekr.20031218072017.1826: *7* << trace head_lines, ins, tail_lines >>
if 0:
    g.pr("\nhead_lines")
    for line in head_lines:
        g.pr(line)
    g.pr("\nins", ins)
    g.pr("\ntail_lines")
    for line in tail_lines:
        g.pr(line)
else:
    g.es_print("head_lines: ",head_lines)
    g.es_print("ins: ",ins)
    g.es_print("tail_lines: ",tail_lines)
#@+node:ekr.20101118113953.5840: *6* rp_get_args
def rp_get_args (self):

    '''Compute and return oldSel,oldYview,original,pageWidth,tabWidth.'''

    c = self ; body = c.frame.body ;  w = body.bodyCtrl

    d = c.scanAllDirectives()

    if c.editCommands.fillColumn > 0:
        pageWidth = c.editCommands.fillColumn
    else:
        pageWidth = d.get("pagewidth")
        
    tabWidth  = d.get("tabwidth")
    original = w.getAllText()
    oldSel =  w.getSelectionRange()
    oldYview = body.getYScrollPosition()

    return oldSel,oldYview,original,pageWidth,tabWidth
#@+node:ekr.20101118113953.5841: *6* rp_get_leading_ws
def rp_get_leading_ws (self,lines,tabWidth):

    '''Compute and return indents and leading_ws.'''

    c = self

    indents = [0,0]
    leading_ws = ["",""]

    for i in (0,1):
        if i < len(lines):
            # Use the original, non-optimized leading whitespace.
            leading_ws[i] = ws = g.get_leading_ws(lines[i])
            indents[i] = g.computeWidth(ws,tabWidth)

    indents[1] = max(indents)

    if len(lines) == 1:
        leading_ws[1] = leading_ws[0]

    return indents,leading_ws
#@+node:ekr.20101118113953.5842: *6* rp_reformat
def rp_reformat (self,head,oldSel,oldYview,original,result,tail,undoType):

    '''Reformat the body and update the selection.'''

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    s = w.getAllText()

    # This destroys recoloring.
    junk, ins = body.setSelectionAreas(head,result,tail)

    changed = original != head + result + tail
    if changed:
        # 2010/11/16: stay in the paragraph.
        body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)
    else:
        # Advance to the next paragraph.
        ins += 1 # Move past the selection.
        while ins < len(s):
            i,j = g.getLine(s,ins)
            line = s[i:j]
            # 2010/11/16: it's annoying, imo, to treat @ lines differently.
            if line.isspace(): ### or line.startswith('@'):
                ins = j+1
            else:
                ins = i ; break

        # setSelectionAreas has destroyed the coloring.
        c.recolor()

    w.setSelectionRange(ins,ins,insert=ins)
    
    # Make the next line visible: this is a big improvement.
    w.see(ins+5)
#@+node:ekr.20101118113953.5843: *6* rp_wrap_all_lines
def rp_wrap_all_lines (self,indents,leading_ws,lines,pageWidth):

    '''compute the result of wrapping all lines.'''

    trailingNL = lines and lines[-1].endswith('\n')
    lines = [g.choose(z.endswith('\n'),z[:-1],z) for z in lines]

    # Wrap the lines, decreasing the page width by indent.
    result = g.wrap_lines(lines,
        pageWidth-indents[1],
        pageWidth-indents[0])

    # prefix with the leading whitespace, if any
    paddedResult = []
    paddedResult.append(leading_ws[0] + result[0])
    for line in result[1:]:
        paddedResult.append(leading_ws[1] + line)

    # Convert the result to a string.
    result = '\n'.join(paddedResult)
    if trailingNL: result = result + '\n'

    return result
#@+node:ekr.20110527084258.18379: *4* Created ua commands
#@+node:ekr.20050920084036.55: *5*  getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    c = self.c

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body and c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-to-home':                         self.backToHome,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-page':                            self.backPage,
        'back-page-extend-selection':           self.backPageExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-delete-word':                 self.backwardDeleteWord,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-all-lines':                      self.cleanAllLines,
        'clean-lines':                          self.cleanLines,
        'clear-all-caches':                     self.clearAllCaches,
        'clear-all-uas':                        self.clearAllUas,
        'clear-cache':                          self.clearCache,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-node-uas':                       self.clearNodeUas,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'clone-marked':                         c.cloneMarked,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        # 'delete-all-icons':                   self.deleteAllIcons,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-first-icon':                    self.deleteFirstIcon,
        'delete-indentation':                   self.deleteIndentation,
        'delete-last-icon':                     self.deleteLastIcon,
        'delete-node-icons':                    self.deleteNodeIcons,
        'delete-spaces':                        self.deleteSpaces,
        'delete-word':                          self.deleteWord,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'find-word-in-line':                    self.findWordInLine,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-page':                         self.forwardPage,
        'forward-page-extend-selection':        self.forwardPageExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-icon':                          self.insertIcon,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'print-all-uas':                        self.printAllUas,
        'print-node-uas':                       self.printUas,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'reverse-sort-lines':                   self.reverseSortLines,
        'reverse-sort-lines-ignoring-case':     self.reverseSortLinesIgnoringCase,
        'scroll-down-half-page':                self.scrollDownHalfPage,                
        'scroll-down-line':                     self.scrollDownLine,
        'scroll-down-page':                     self.scrollDownPage,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up-half-page':                  self.scrollUpHalfPage,                        
        'scroll-up-line':                       self.scrollUpLine,
        'scroll-up-page':                       self.scrollUpPage,
        'select-all':                           self.selectAllText,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'set-ua':                               self.setUa,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'sort-lines-ignoring-case':             self.sortLinesIgnoringCase,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@+node:ekr.20061031131434.128: *5* getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    if trace: g.trace(
        'state',state,'keysym',repr(keysym),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129: *6* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@+node:ekr.20110527105255.18384: *5* uA's (leoEditCommands)
#@+node:ekr.20110527105255.18387: *6* clearNodeUas & clearAllUas
def clearNodeUas (self,event=None):
    
    '''Clear the uA's in the selected vnode.'''
    
    if self.c.p:
        self.c.p.v.u = {}
    
def clearAllUas (self,event=None):
    
    '''Clear all uAs in the entire outline.'''

    for v in self.c.all_unique_nodes():
        v.u = {}
#@+node:ekr.20110527105255.18385: *6* printUas & printAllUas
def printAllUas (self,event=None):
    
    g.es_print('Dump of uAs...')
    for v in self.c.all_unique_nodes():
        if v.u:
            self.printUas(v=v)

def printUas (self,event=None,v=None):
    
    c = self.c
    if v: d,h = v.u,v.h
    else: d,h = c.p.v.u,c.p.h
    g.es_print(h)
    keys = list(d.keys())
    keys.sort()
    n = 4
    for key in keys:
        n = max(len(key),n)
    for key in keys:
        pad = ' '*(len(key)-n)
        g.es_print('    %s%s: %s' % (pad,key,d.get(key)))
#@+node:ekr.20110527105255.18386: *6* setUa
def setUa (self,event):
    
    c,k = self.c,self.k
    tag = 'set-ua' ; state = k.getState(tag)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if w:
            k.setLabelBlue('Set uA: ',protect=True)
            k.getArg(event,tag,1,self.setUa)
    elif state == 1:
        self.uaName = k.arg
        s = 'Set uA: %s To: ' % (self.uaName)
        k.setLabelBlue(s,protect=True)
        k.getArg(event,tag,2,self.setUa,completion=False,prefix=s)
    else:
        assert state == 2,state
        val = k.arg
        d = c.p.v.u
        d[self.uaName] = val
        self.printUas()
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
#@+node:ekr.20051104051733: *4* Handle click events like alt-x or ctrl-g
@nocolor-node

http://sourceforge.net/forum/message.php?msg_id=3412640

Clicking in the minibuffer now is equivalent to alt-x, provided that the minibuffer is not in use.

Clicking most places outside the minibuffer is equivalent to ctrl-g.

Catching clicks is much safer than catching focus events.

What I did:
    
leoKeys.py:
    
- Removed the inAutoCompleter arg to k.keyboardQuit.
  This should be safe because k.keyboardQuit no longer calls k.autoCompleter.exit.
    
baseNativeTree.py:
    
- Call k.keyboardQuit at end of onItemClicked.

qtGui.py:
    
- Monkeypatched QLineEdit.mouseReleaseEvent in ctor for leoQtMinibuffer.  

- Renamed leoQtBaseTextWidget.onClick to onCursorPositionChanged.

- Monkey patched QTextBrowser.mouseReleaseEvent in ctor for leoQtBaseTextWidget

To undo this, if it doesn't turn out well:
    
- Remove the call to k.fullCommand or k.keyboardQuit in the two mouseReleaseEvent methods.
- Remove the call to k.keyboardQuit in baseNativeTree.onItemClicked.
#@+node:ekr.20061031131434.130: *5* keyboardQuit
def keyboardQuit (self,event,setFocus=True):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    if trace: g.trace(g.callers())

    if g.app.quitting:
        return

    # if not inAutoCompleter:
        # k.autoCompleter.exit()
    
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    if setFocus:
        c.endEditing()
        c.bodyWantsFocus()

    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    k.showStateAndMode()
#@+node:ekr.20090402072059.2: *4* Improved the clone-find-all command
@nocolor-node

The descendants of previously found (cloned) nodes don't get added again.
#@+node:ekr.20031218072017.3073: *5* findAll & helper
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    skip = {} # Nodes that should be skipped.
        # Keys are vnodes, values not important.
    count,found = 0,None
    while 1:
        pos, newpos = self.findNextMatch() # sets self.p.
        if pos is None: break
        if self.clone_find_all and self.p.v in skip:
            continue
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if self.clone_find_all:
            if not skip:
                undoData = u.beforeInsertNode(c.p)
                found = self.createCloneFindAllNode()
            # Don't look at the node or it's descendants.
            for p2 in self.p.self_and_subtree():
                skip[p2.v] = True
            # Create a clone of self.p under the find node.
            p2 = self.p.clone()
            p2.moveToLastChildOf(found)
        else:
            self.printLine(line,allFlag=True)

    if self.clone_find_all and skip:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")
#@+node:ekr.20051113110735: *6* createCloneFindAllNode
def createCloneFindAllNode(self):
    
    c = self.c
    oldRoot = c.rootPosition()
    found = oldRoot.insertAfter()
    found.moveToRoot(oldRoot)
    c.setHeadString(found,'Found: ' + self.find_text)
    return found
#@+node:ekr.20110528034751.18275: *4* Allow *plain* arrow keys in editing headline mode
@nocolor-node

In effect, the Up/Down keys should work just like Alt-Up/Down:
they should move to the next/prev node and should put the focus in the tree.

The fix was a beautiful/ugly hack in g.getPaneBinding.

Also selectVisNext/Back now call c.endEditing() if there is no next/previous node,
so an arrow "out of" editing mode actually always ends the editing.

#@+node:ekr.20091230094319.6240: *5* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and b.commandName in table:
                        if trace: g.trace('***** special case',b.commandName)
                        pass
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(b.stroke),b.commandName))
                        return b
#@-all
#@-leo
