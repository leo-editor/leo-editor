#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20090831095817.6067:Leo 4.6.3
- Put caching bug fixes into 46-maint branch
- Fixed bug in g.adjustTripleString.
- Created .nsi script.
#@nonl
#@-node:ekr.20090831095817.6067:Leo 4.6.3
#@+node:ekr.20090907080624.6082:Leo 4.6.4
#@+node:ekr.20090907080624.6083:Added new plugins
@nocolor-node

New command-line option
    --gui=qttabs

new plugins:
    spydershell,
    qtframecommands
    mod_framesize.

Improved plugin:  "show folder" in rclick menu.

Improved plugin: contextmenu.py

    If you rclick on @thin / whatever item, you should see "open
    /home/ville/foo" (or equivalent) menu entry. It open up the file manager on
    that folder (using xdg-open on linux, os.startfile on windows). I have no
    idea what to do with mac, now it runs xdg-open and probably fails.
#@nonl
#@-node:ekr.20090907080624.6083:Added new plugins
#@-node:ekr.20090907080624.6082:Leo 4.6.4
#@+node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20091221094815.6383:Urgent (voted up) bugs to fix
#@+node:ekr.20091221123255.6375:Fixed
#@+node:ekr.20091221145433.6384:Calltips don't work on leo3k
@nocolor-node

They wipe out the newly-inserted selection range.

  File "/home/edreamleo/leo.repo/trunk/leo/core/leoKeys.py", line 545, in calltip
    isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType
AttributeError: 'module' object has no attribute 'StringType'

-----------------

Traceback (most recent call last):

  File "/home/edreamleo/leo.repo/trunk/leo/core/leoKeys.py", line 174, in defineClassesDict
    name = z.__class__.__name__

ReferenceError: weakly-referenced object no longer exists


#@+node:ekr.20061031131434.20:calltip
def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        << try to set s from a Python global function >>

    if not s:
        << get s using inspect >>

    << remove 'self' from s, but not from args >>
    if isStringMethod:
        << remove 's' from s *and* args >>

    # s = s.rstrip(')') # Not so convenient.
    << insert the text and set j1 and j2 >>

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    << put the status line >>
#@+node:ekr.20061031131434.21:<< try to set s from a Python global function >>
# The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i > -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
#@-node:ekr.20061031131434.21:<< try to set s from a Python global function >>
#@+node:ekr.20061031131434.22:<< get s using inspect >>
isStringMethod = (
    self.prevObjects and
    # type(self.prevObjects[-1]) == types.StringType
    g.isString(self.prevObjects[-1]))

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
#@-node:ekr.20061031131434.22:<< get s using inspect >>
#@+node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
#@-node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
#@+node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
#@-node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
#@+node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
#@-node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
#@+node:ekr.20061031131434.26:<< put the status line >>
c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
#@-node:ekr.20061031131434.26:<< put the status line >>
#@-node:ekr.20061031131434.20:calltip
#@+node:ekr.20061031131434.5: ctor (autocompleter)
def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfVnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.theObject = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    if g.isPython3:
        for z in gc.get_objects():
            try:
                name = z.__class__.__name__
            except ReferenceError:
                pass
            self.allClassesDict [name] = z
    else:
        for z in gc.get_objects():
            t = type(z)
            if t == types.ClassType:
                name = z.__name__
            elif t == types.InstanceType:
                name = z.__class__.__name__
            elif repr(t).startswith('<class'): # A wretched kludge.
                name = z.__class__.__name__
            elif t == types.TypeType:
                name = z.__name__
            else:
                name = None
            if name:
                # if name == 'position': g.trace(t,z)
                self.allClassesDict [name] = z

    # g.printList(list(self.allClassesDict.keys()),tag='Classes',sort=True)
    # g.trace(len(list(self.allClassesDict.keys())))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@+node:ekr.20061031131434.7:defineObjectDict
def defineObjectDict (self,table=None):

    c = self.c ; k = c.k ; p = c.p

    # g.trace(g.callers(4))

    if table is None: table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p.copy()), # 2009/12/21
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        # (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
#@-node:ekr.20061031131434.7:defineObjectDict
#@-node:ekr.20061031131434.5: ctor (autocompleter)
#@-node:ekr.20091221145433.6384:Calltips don't work on leo3k
#@+node:ekr.20091221094815.6385:zpcspm Headline scrolling
@nocolor-node

My biggest annoyance is the invalid bug 409442, I have to use the tk
GUI because of it.

I've also complained about it in this thread:
http://groups.google.com/group/leo-editor/browse_thread/thread/07cdbb... 

----- Ville +1
I feel your pain.

Please try this workaround (run with ctrl+b):

tree = c.frame.tree.treeWidget
tree.setColumnCount(2)

-----
> Isn't it possible to stick this tree.setColumnCount(2) into some
> constructor in the leo qt GUI plugin so the outline pane would have
> the horizontal scrollbar by default?

Yes, but it's not sure we want to have 2 columns in the tree widget -
and it would create scrollbar on many occasions when it's not
necessary.

So this is not a simple fix for your problem, it has implications
beyond your problem. 
#@nonl
#@-node:ekr.20091221094815.6385:zpcspm Headline scrolling
#@+node:ekr.20091221145433.6379:TL Undo renames headline (tk only)
@nocolor-node

Bug 498692: Undo deleted node renames current node's headline

Tested with: Rev2518, Tk GUI, Vim emulation not active

Created three nodes at the same level with Header and body text containing "Node
1", "Node 2", and "Node 3", saved and closed Leo file, opened Leo file, selected
Node 2's headline with the mouse (headline shows blue background). Performed the
following steps:

Delete Node 2 (Ctrl-Shift-X):
 Node 2 deleted
 Node 1 Headline has focus (Blue background)

Undo (Ctrl-Z) Note: Text in undo's menu item showed "Undo typing"
 Node 1's Headline renamed to "Node 2"
 Node 1's body has focus

Undo (Ctrl-Z) Note: Text in undo's menu item showed "Undo delete node"
 Node 2 restored
 Node 2's body has focus
 Node 1's headline remains "Node 2"

Problem 1: The first executed Undo command should not have existed on the "undo
stack". No user "typing" was performed that needs to be undone.

Problem 2: After an Undo of the delete node (the second undo above), the focus
should be in the restored node's headline instead of in its body.
#@+node:ekr.20080514131122.14:c.redrawing...
#@+node:ekr.20090110073010.1:c.redraw
def redraw (self,p=None,setFocus=False):
    '''Redraw the screen immediately.'''

    c = self
    if not p: p = c.p or c.rootPosition()

    c.expandAllAncestors(p)
    c.frame.tree.redraw(p)
    c.selectPosition(p)

    if setFocus: c.treeFocusHelper()

# Compatibility with old scripts
force_redraw = redraw
redraw_now = redraw
#@-node:ekr.20090110073010.1:c.redraw
#@+node:ekr.20090110131802.2:c.redraw_after_contract
def redraw_after_contract (self,p=None,setFocus=False):

    c = self

    c.endEditing()

    if p:
        c.setCurrentPosition(p)
    else:
        p = c.currentPosition()

    if p.isCloned():
        c.redraw(p=p,setFocus=setFocus)
    else:
        c.frame.tree.redraw_after_contract(p)
        if setFocus: c.treeFocusHelper()
#@-node:ekr.20090110131802.2:c.redraw_after_contract
#@+node:ekr.20090112065525.1:c.redraw_after_expand
def redraw_after_expand (self,p=None,setFocus=False):

    c = self

    c.endEditing()

    if p:
        c.setCurrentPosition(p)
    else:
        p = c.currentPosition()

    if p.isCloned():
        c.redraw(p=p,setFocus=setFocus)
    else:
        c.frame.tree.redraw_after_expand(p)
        if setFocus: c.treeFocusHelper()
#@-node:ekr.20090112065525.1:c.redraw_after_expand
#@+node:ekr.20090110073010.2:c.redraw_after_head_changed
def redraw_after_head_changed(self):

    '''Redraw the screen (if needed) when editing ends.
    This may be a do-nothing for some gui's.'''

    return self.frame.tree.redraw_after_head_changed()
#@-node:ekr.20090110073010.2:c.redraw_after_head_changed
#@+node:ekr.20090110073010.3:c.redraw_afer_icons_changed
def redraw_after_icons_changed(self):

    '''Update the icon for the presently selected node,
    or all icons if the 'all' flag is true.'''

    c = self

    c.frame.tree.redraw_after_icons_changed()

    # c.treeFocusHelper()
#@-node:ekr.20090110073010.3:c.redraw_afer_icons_changed
#@+node:ekr.20090110073010.4:c.redraw_after_select
def redraw_after_select(self,p):

    '''Redraw the screen after node p has been selected.'''

    trace = False and not g.unitTesting
    if trace: g.trace('(Commands)',p and p.h or '<No p>', g.callers(4))

    c = self

    flag = c.expandAllAncestors(p)
    if flag:
        c.frame.tree.redraw_after_select(p)
#@-node:ekr.20090110073010.4:c.redraw_after_select
#@-node:ekr.20080514131122.14:c.redrawing...
#@+node:ekr.20031218072017.3704:class leoTree
# This would be useful if we removed all the tree redirection routines.
# However, those routines are pretty ingrained into Leo...

class leoTree:

    """The base class for the outline pane in Leo windows."""

    @others
#@+node:ekr.20031218072017.3705:  tree.__init__ (base class)
def __init__ (self,frame):

    self.frame = frame
    self.c = frame.c

    self.edit_text_dict = {}
        # New in 3.12: keys vnodes, values are edit_widget (Tk.Text widgets)
        # New in 4.2: keys are vnodes, values are pairs (p,Tk.Text).

    # Debugging.
    self.redrawCount = 0

    # "public" ivars: correspond to setters & getters.
    self.drag_p = None
    self._editPosition = None
    self.redrawCount = 0 # For traces
    self.revertHeadline = None
    self.use_chapters = False # May be overridden in subclasses.

    # Define these here to keep pylint happy.
    self.canvas = None
    self.stayInTree = True
    self.trace_select = None
#@+node:ekr.20081005065934.7:leoTree.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'initAfterLoad', # New in Leo 4.6.
    'treeSelectHint', # New in Leo 4.6.
)
#@nonl
#@-node:ekr.20081005065934.7:leoTree.mustBeDefined
#@+node:ekr.20061109164512:leoTree.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    # Getters & setters.
    'editPosition',
    'getEditTextDict',
    'setEditPosition',
    # Others.
    'endEditLabel',
    # 'expandAllAncestors', # Now defined in Commands class.
    'injectCallbacks',
    'OnIconDoubleClick',
    'onHeadChanged',
    'onHeadlineKey',
    'updateHead',
    'oops',
)
#@nonl
#@-node:ekr.20061109164512:leoTree.mustBeDefinedOnlyInBaseClass
#@+node:ekr.20061109164610:leoTree.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Colors & fonts.
    'getFont',
    'setFont',
    'setFontFromConfig ',
    # Drawing & scrolling.
    'drawIcon',
    'redraw_now',
    'scrollTo',
    # Headlines.
    'editLabel',
    # 'setEditLabelState',
    # Selecting.
    # 'select', # Defined in base class, may be overridden in do-nothing subclasses.
)
#@-node:ekr.20061109164610:leoTree.mustBeDefinedInSubclasses
#@-node:ekr.20031218072017.3705:  tree.__init__ (base class)
#@+node:ekr.20031218072017.3706: Must be defined in subclasses
# Bidings.
def setBindings (self):                         self.oops()

# Fonts.
def getFont(self):                              self.oops()
def setFont(self,font=None,fontName=None):      self.oops()
def setFontFromConfig (self):                   self.oops()

# Drawing & scrolling.
def drawIcon(self,p):                                       self.oops()
def redraw(self,p=None,scroll=True,forceDraw=False):        self.oops()
def redraw_now(self,p=None,scroll=True,forceDraw=False):    self.oops()
def scrollTo(self,p):                           self.oops()
idle_scrollTo = scrollTo # For compatibility.

# Headlines.
def editLabel(self,v,selectAll=False,selection=None): self.oops()
def edit_widget (self,p):                       self.oops() ; return None
def headWidth(self,p=None,s=''):                self.oops() ; return 0
def setEditLabelState(self,v,selectAll=False):  self.oops()
def setSelectedLabelState(self,p):              self.oops()
def setUnselectedLabelState(self,p):            self.oops()
#@nonl
#@-node:ekr.20031218072017.3706: Must be defined in subclasses
#@+node:ekr.20061109165848:Must be defined in base class
#@+node:ekr.20031218072017.3716:Getters/Setters (tree)
def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition

def setEditPosition(self,p):
    self._editPosition = p
#@-node:ekr.20031218072017.3716:Getters/Setters (tree)
#@+node:ekr.20040803072955.90:head key handlers (leoTree)
#@+node:ekr.20040803072955.91:onHeadChanged (leoTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    trace = False and not g.unitTesting
    c = self.c ; u = c.undoer
    w = self.edit_widget(p)

    if c.suppressHeadChanged: return
    if not w:
        if trace: g.trace('****** no w for p: %s',repr(p))
        return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    if trace:
        g.trace('*** leoTree',g.callers(5))
        g.trace(p and p.h,'w',repr(w),'s',repr(s))
    << truncate s if it has multiple lines >>
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed',changed,'new',repr(s))
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    if changed:
        c.redraw_after_head_changed()
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged (leoTree)
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):

    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # g.trace(repr(ch),g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):

    '''Update a headline from an event.

    The headline officially changes only when editing ends.'''

    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i

    # g.trace('w',w,'ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i-1,i-1,insert=i-1)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):

    '''End editing of a headline and update p.h.'''

    trace = False and g.unitTesting
    c = self.c ; k = c.k ; p = c.p

    if trace: g.trace('leoTree',p and p.h,g.callers(4))

    self.setEditPosition(None) # That is, self._editPosition = None

    # Important: this will redraw if necessary.
    self.onHeadChanged(p)

    if 0: # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
        k.setDefaultInputState()
        k.showStateAndMode()

    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
#@-node:ekr.20040803072955.126:endEditLabel
#@-node:ekr.20040803072955.90:head key handlers (leoTree)
#@+node:ekr.20040803072955.21:tree.injectCallbacks
def injectCallbacks(self):

    c = self.c

    << define callbacks to be injected in the position class >>

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):

        g.funcToMethod(f,leoNodes.position)
#@nonl
#@+node:ekr.20040803072955.22:<< define callbacks to be injected in the position class >>
# N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
#@+node:ekr.20040803072955.23:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event=None,c=c):

    """Callback injected into position class."""

    p = self
    if not c or not c.exists:
        return

    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.selectPosition(p)
            c.redraw()
            c.frame.body.bodyCtrl.setInsertPoint(0) # 2007/10/27
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
#@-node:ekr.20040803072955.23:OnHyperLinkControlClick
#@+node:ekr.20040803072955.24:OnHyperLinkEnter
def OnHyperLinkEnter (self,event=None,c=c):

    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.body.bodyCtrl.tag_config(p.tagName,background="green") # 10/27/07
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")
#@-node:ekr.20040803072955.24:OnHyperLinkEnter
#@+node:ekr.20040803072955.25:OnHyperLinkLeave
def OnHyperLinkLeave (self,event=None,c=c):

    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.body.bodyCtrl.tag_config(p.tagName,background="white") # 2007/20/25

        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")
#@-node:ekr.20040803072955.25:OnHyperLinkLeave
#@-node:ekr.20040803072955.22:<< define callbacks to be injected in the position class >>
#@-node:ekr.20040803072955.21:tree.injectCallbacks
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url) & helper & test
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.h.strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.b.split('\n')
            url = lines and lines[0] or ''
        else:
            << stop the url after any whitespace >>
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            g.handleUrlInUrlNode(url)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            z_url = url[i:]
            g.es("ignoring characters after space in url:",z_url)
            g.es("use %20 instead of spaces")
        url = url[:i]
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20090529205043.6027:@test OnIconDoubleClick
if g.unitTesting:

    c,p = g.getTestVars()

    c.frame.tree.OnIconDoubleClick(p.firstChild())
#@+node:ekr.20060217111834:@url http://docs.python.org/lib/re-syntax.html
#@-node:ekr.20060217111834:@url http://docs.python.org/lib/re-syntax.html
#@-node:ekr.20090529205043.6027:@test OnIconDoubleClick
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url) & helper & test
#@-node:ekr.20061109165848:Must be defined in base class
#@+node:ekr.20081005065934.8:May be defined in subclasses
# These are new in Leo 4.6.

def initAfterLoad (self):
    '''Do late initialization.
    Called in g.openWithFileName after a successful load.'''

def afterSelectHint(self,p,old_p):
    '''Called at end of tree.select.'''
    pass

def beforeSelectHint (self,p,old_p):
    '''Called at start of tree.select.'''
    pass

# These are hints for optimization.
# The proper default is c.redraw()
def redraw_after_clone(self):                   self.c.redraw()
def redraw_after_contract(self,p=None):         self.c.redraw()
def redraw_after_expand(self,p=None):           self.c.redraw()
def redraw_after_head_changed(self):            self.c.redraw()
def redraw_after_icons_changed(self,all=False): self.c.redraw()
def redraw_after_select(self,p=None):           self.c.redraw()
#@-node:ekr.20081005065934.8:May be defined in subclasses
#@+node:ekr.20040803072955.128:leoTree.select & helpers
tree_select_lockout = False

def select (self,p,scroll=True):

    '''Select a node.
    Never redraws outline, but may change coloring of individual headlines.
    The scroll argument is used by tk to suppress scrolling while dragging.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        c = self.c ; old_p = c.p
        val = 'break'
        self.tree_select_lockout = True
        c.frame.tree.beforeSelectHint(p,old_p)
        val = self.selectHelper(p,scroll=scroll)
    finally:
        self.tree_select_lockout = False
        c.frame.tree.afterSelectHint(p,old_p)

    return val  # Don't put a return in a finally clause.
#@+node:ekr.20070423101911:selectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace:
        if old_p:
            g.trace('old: %s %s new: %s %s' % (
                len(old_p.b),old_p.h,len(p.b),p.h))
        else:
            g.trace('old: <none> new: %s %s' % (len(p.b),p.h))

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.p here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    if trace: g.trace('**** after old: %s new %s' % (
        old_p and len(old_p.b),len(p.b)))

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p:
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20070423101911:selectHelper
#@+node:ekr.20090608081524.6109:setBodyTextAfterSelect
def setBodyTextAfterSelect (self,p,old_p):

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = g.toUnicode(p.v._bodyString,"utf-8")
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s,new_p=p)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    if p.v and p.v.scrollBarSpot != None:
        first,last = p.v.scrollBarSpot
        w.setYScrollPosition(first)

    if p.v and p.v.insertSpot != None:
        spot = p.v.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
        # g.trace(spot)
    else:
        w.setInsertPoint(0)
#@-node:ekr.20090608081524.6109:setBodyTextAfterSelect
#@-node:ekr.20040803072955.128:leoTree.select & helpers
#@+node:ekr.20031218072017.3718:oops
def oops(self):

    g.pr("leoTree oops:", g.callers(4), "should be overridden in subclass")
#@-node:ekr.20031218072017.3718:oops
#@-node:ekr.20031218072017.3704:class leoTree
#@+node:ekr.20031218072017.3614:setRedoType
# These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame

    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'

    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel
#@-node:ekr.20031218072017.3614:setRedoType
#@+node:ekr.20091221145433.6381:setUndoType
def setUndoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
#@-node:ekr.20091221145433.6381:setUndoType
#@+node:ekr.20040803072955.91:onHeadChanged (leoTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    trace = False and not g.unitTesting
    c = self.c ; u = c.undoer
    w = self.edit_widget(p)

    if c.suppressHeadChanged: return
    if not w:
        if trace: g.trace('****** no w for p: %s',repr(p))
        return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    if trace:
        g.trace('*** leoTree',g.callers(5))
        g.trace(p and p.h,'w',repr(w),'s',repr(s))
    << truncate s if it has multiple lines >>
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed',changed,'new',repr(s))
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    if changed:
        c.redraw_after_head_changed()
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged (leoTree)
#@-node:ekr.20091221145433.6379:TL Undo renames headline (tk only)
#@+node:ekr.20091221145433.6378:TL undo bug: window dirty bit not preserved
@nocolor-node

Bug 498688: Undo back to last saved content still shows file as
modified ("*" in title)

Steps:
   1. Open leo file
   2. Delete node
   3. Perform "Undo"
       Undo works as designed but the file is still a "*" in the title bar
   4. Close Leo
       Leo issues prompt to save file before closing.
#@nonl
#@+node:ekr.20031218072017.3605:class undoer
class undoer:
    """A class that implements unlimited undo and redo."""
    @others
#@+node:ekr.20031218072017.3606:undo.__init__ & clearIvars
def __init__ (self,c):

    self.c = c
    self.debug = False # True: enable debugging code in new undo scheme.
    self.debug_print = False # True: enable print statements in debug code.

    self.granularity = c.config.getString('undo_granularity')
    if self.granularity: self.granularity = self.granularity.lower()
    if self.granularity not in ('node','line','word','char'):
        self.granularity = 'line'
    # g.trace('undoer',self.granularity)

    self.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if self.debug is on).
    self.new_mem = 0
    self.old_mem = 0

    # State ivars...
    self.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    self.redoMenuLabel = "Can't Redo"
    self.undoMenuLabel = "Can't Undo"
    self.realRedoMenuLabel = "Can't Redo"
    self.realUndoMenuLabel = "Can't Undo"
    self.undoing = False # True if executing an Undo command.
    self.redoing = False # True if executing a Redo command.

    # New in 4.2...
    self.optionalIvars = []

    # Set the following ivars to keep pylint happy.
    self.afterTree = None
    self.beforeTree = None
    self.children = None
    self.dirtyVnodeList = None
    self.followingSibs = None
    self.kind = None
    self.newBack = None
    self.newBody = None
    self.newChanged = None
    self.newChildren = None
    self.newHead = None
    self.newMarked = None
    self.newN = None
    self.newP = None
    self.newParent = None
    self.newParent_v = None
    self.newRecentFiles = None
    self.newTree = None
    self.oldBack = None
    self.oldBody = None
    self.oldChanged = None
    self.oldChildren = None
    self.oldHead = None
    self.oldMarked = None
    self.oldN = None
    self.oldParent = None
    self.oldParent_v = None
    self.oldRecentFiles = None
    self.oldTree = None
    self.pasteAsClone = None
    self.sortChildren = None

def redoHelper(self):
    pass

def undoHelper(self):
    pass
#@+node:ekr.20031218072017.3607:clearIvars
def clearIvars (self):

    u = self

    # g.trace(g.callers(5))

    u.p = None # The position/node being operated upon for undo and redo.

    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
#@-node:ekr.20031218072017.3607:clearIvars
#@-node:ekr.20031218072017.3606:undo.__init__ & clearIvars
#@+node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20060127052111.1:cutStack
def cutStack (self):

    u = self ; n = u.max_undo_stack_size

    if n > 0 and u.bead >= n and not g.app.unitTesting:

        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i >= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads),g.callers())
#@-node:ekr.20060127052111.1:cutStack
#@+node:ekr.20080623083646.10:dumpBead
def dumpBead (self,n):

    u = self
    if n < 0 or n >= len(u.beads):
        return 'no bead: n = ',n

    bunch = u.beads[n] ; result = []
    result.append('-' * 10)
    result.append('len(u.beads): %s, n: %s' % (len(u.beads),n))
    for ivar in ('kind','newP','newN','p','oldN','undoHelper'):
        result.append('%s = %s' % (ivar,getattr(self,ivar)))
    return '\n'.join(result)

def dumpTopBead(self):

    u = self
    n = len(u.beads)
    if n > 0:
        return self.dumpBead(n-1)
    else:
        return '<no top bead>'
#@-node:ekr.20080623083646.10:dumpBead
#@+node:EKR.20040526150818:getBead
def getBead (self,n):

    '''Set undoer ivars from the bunch at the top of the undo stack.'''

    u = self
    if n < 0 or n >= len(u.beads):
        return None

    bunch = u.beads[n]

    self.setIvarsFromBunch(bunch)

    return bunch
#@-node:EKR.20040526150818:getBead
#@+node:EKR.20040526150818.1:peekBead
def peekBead (self,n):

    u = self
    if n < 0 or n >= len(u.beads):
        return None
    bunch = u.beads[n]
    # g.trace(n,len(u.beads),bunch)
    return bunch
#@-node:EKR.20040526150818.1:peekBead
#@+node:ekr.20060127113243:pushBead
def pushBead (self,bunch):

    u = self

    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.bead >= 0 and u.bead < len(u.beads) and u.beads[u.bead]

    if bunch2 and hasattr(bunch2,'kind') and bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
        # g.trace('u.bead',u.bead,'len u.beads',len(u.beads),g.callers())

        # Recalculate the menu labels.
        u.setUndoTypes()
#@-node:ekr.20060127113243:pushBead
#@+node:ekr.20060127070008:setIvarsFromBunch
def setIvarsFromBunch (self,bunch):

    u = self

    u.clearIvars()

    if 0: # Debugging.
        g.pr('-' * 40)
        for key in sorted(bunch):
            g.trace(key,bunch.get(key))
        g.pr('-' * 20)

    # bunch is not a dict, so bunch.keys() is required.
    for key in list(bunch.keys()): 
        val = bunch.get(key)
        # g.trace(key,val)
        setattr(u,key,val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
#@-node:ekr.20060127070008:setIvarsFromBunch
#@+node:ekr.20050126081529:recognizeStartOfTypingWord
def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''

    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
#@-node:ekr.20050126081529:recognizeStartOfTypingWord
#@+node:ekr.20031218072017.3613:redoMenuName, undoMenuName
def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name
#@-node:ekr.20031218072017.3613:redoMenuName, undoMenuName
#@+node:ekr.20031218072017.3614:setRedoType
# These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame

    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'

    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel
#@-node:ekr.20031218072017.3614:setRedoType
#@+node:ekr.20091221145433.6381:setUndoType
def setUndoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
#@-node:ekr.20091221145433.6381:setUndoType
#@+node:ekr.20031218072017.3616:setUndoTypes
def setUndoTypes (self):

    u = self

    # g.trace(g.callers(7))

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")

    u.cutStack()
#@-node:ekr.20031218072017.3616:setUndoTypes
#@+node:EKR.20040530121329:u.restoreTree & helpers
def restoreTree (self,treeInfo):

    """Use the tree info to restore all vnode data,
    including all links."""

    u = self

    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
#@+node:ekr.20050415170737.2:restoreVnodeUndoInfo
def restoreVnodeUndoInfo (self,bunch):

    """Restore all ivars saved in the bunch."""

    v = bunch.v

    v.statusBits = bunch.statusBits
    v.children   = bunch.children
    v.parents    = bunch.parents

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170737.2:restoreVnodeUndoInfo
#@+node:ekr.20050415170812.2:restoreTnodeUndoInfo
def restoreTnodeUndoInfo (self,bunch):

    v = bunch.v
    v._headString  = bunch.headString
    v._bodyString  = bunch.bodyString
    v.statusBits  = bunch.statusBits

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170812.2:restoreTnodeUndoInfo
#@-node:EKR.20040530121329:u.restoreTree & helpers
#@+node:EKR.20040528075307:u.saveTree & helpers
def saveTree (self,p,treeInfo=None):

    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    << about u.saveTree >>

    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
#@+node:EKR.20040530114124:<< about u.saveTree >>
@ 
The old code made a free-standing copy of the tree using v.copy and t.copy. This
looks "elegant" and is WRONG. The problem is that it can not handle clones
properly, especially when some clones were in the "undo" tree and some were not.
Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to
properly restore the vnodes and tnodes. It creates a list of tuples, on tuple
for each vnode in the tree. Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the
nodes. The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to
the old v.copy and t.copy methods.

Aside: Prior to 4.2 Leo used a scheme that was equivalent to the
createUndoInfoDict info, but quite a bit uglier.
#@nonl
#@-node:EKR.20040530114124:<< about u.saveTree >>
#@+node:ekr.20050415170737.1:createVnodeUndoInfo
def createVnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode for undo."""

    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parents    = v.parents[:],
        children   = v.children[:],
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170737.1:createVnodeUndoInfo
#@+node:ekr.20050415170812.1:createTnodeUndoInfo
def createTnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        v = v,
        headString = v._headString,
        bodyString = v._bodyString,
        statusBits = v.statusBits,
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170812.1:createTnodeUndoInfo
#@-node:EKR.20040528075307:u.saveTree & helpers
#@+node:ekr.20050525151449:u.trace
def trace (self):

    ivars = ('kind','undoType')

    for ivar in ivars:
        g.pr(ivar, getattr(self,ivar))
#@-node:ekr.20050525151449:u.trace
#@+node:ekr.20050410095424:updateMarks
def updateMarks (self,oldOrNew):

    '''Update dirty and marked bits.'''

    u = self ; c = u.c

    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    marked = g.choose(isOld,u.oldMarked, u.newMarked)

    if marked:  c.setMarked(u.p)
    else:       c.clearMarked(u.p)

    # Bug fix: Leo 4.4.6: Undo/redo always set changed/dirty bits
    # because the file may have been saved.
    u.p.setDirty(setDescendentsDirty=False)
    u.p.setAllAncestorAtFileNodesDirty(setDescendentsDirty=False) # Bug fix: Leo 4.4.6
    u.c.setChanged(True)
#@-node:ekr.20050410095424:updateMarks
#@-node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050315134017.4:afterChangeGroup
def afterChangeGroup (self,p,undoType,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

    bunch = u.beads[u.bead]
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:
        g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)

    # Set the types & helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = undoType

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newP = p.copy()
    bunch.newSel = w.getSelectionRange()

    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag

    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@-node:ekr.20050315134017.4:afterChangeGroup
#@+node:ekr.20050315134017.2:afterChangeNodeContents
def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.b
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.h
    bunch.newMarked = p.isMarked()
    bunch.newSel = w.getSelectionRange()

    u.pushBead(bunch)
#@-node:ekr.20050315134017.2:afterChangeNodeContents
#@+node:ekr.20050315134017.3:afterChangeTree
def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = w.getSelectionRange()
    bunch.newText = w.getAllText()
    bunch.newTree = u.saveTree(p)

    u.pushBead(bunch)
#@-node:ekr.20050315134017.3:afterChangeTree
#@+node:ekr.20050424161505:afterClearRecentFiles
def afterClearRecentFiles (self,bunch):

    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]

    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles

    u.pushBead(bunch)

    return bunch
#@-node:ekr.20050424161505:afterClearRecentFiles
#@+node:ekr.20050411193627.5:afterCloneNode
def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'clone'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050411193627.5:afterCloneNode
#@+node:ekr.20050411193627.6:afterDehoist
def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    u.pushBead(bunch)
#@-node:ekr.20050411193627.6:afterDehoist
#@+node:ekr.20050411193627.8:afterDeleteNode
def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'delete'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050411193627.8:afterDeleteNode
#@+node:ekr.20080425060424.8:afterDemote
def afterDemote (self,p,followingSibs,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'demote'
    bunch.undoType = 'Demote'

    bunch.undoHelper = u.undoDemote
    bunch.redoHelper = u.redoDemote

    bunch.followingSibs = followingSibs

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@-node:ekr.20080425060424.8:afterDemote
#@+node:ekr.20050411193627.7:afterHoist
def afterHoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'hoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    u.pushBead(bunch)
#@-node:ekr.20050411193627.7:afterHoist
#@+node:ekr.20050411193627.9:afterInsertNode
def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())

    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            v = bunch2.v
            afterTree.append(
                g.Bunch(v=v,head=v._headString[:],body=v._bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)
#@-node:ekr.20050411193627.9:afterInsertNode
#@+node:ekr.20050526124257:afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node for mark and unmark commands.'''

    # 'command' unused, but present for compatibility with similar methods.

    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark

    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050526124257:afterMark
#@+node:ekr.20050410110343:afterMoveNode
def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'move'
    bunch.undoType = command

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newN = p.childIndex()
    bunch.newParent_v = p._parentVnode()
    bunch.newP = p.copy()

    u.pushBead(bunch)
#@-node:ekr.20050410110343:afterMoveNode
#@+node:ekr.20080425060424.12:afterPromote
def afterPromote (self,p,children,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'promote'
    bunch.undoType = 'Promote'

    bunch.undoHelper = u.undoPromote
    bunch.redoHelper = u.redoPromote

    bunch.children = children

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@-node:ekr.20080425060424.12:afterPromote
#@+node:ekr.20080425060424.2:afterSort
def afterSort (self,p,bunch,dirtyVnodeList):

    '''Create an undo node for sort operations'''

    u = self ; c = self.c
    if u.redoing or u.undoing: return

    bunch.dirtyVnodeList = dirtyVnodeList

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@-node:ekr.20080425060424.2:afterSort
#@-node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20050315134017.7:beforeChangeGroup
def beforeChangeGroup (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command

    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
#@-node:ekr.20050315134017.7:beforeChangeGroup
#@+node:ekr.20050315133212.2:beforeChangeNodeContents
def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):

    '''Return data that gets passed to afterChangeNode'''

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBody = oldBody or p.b
    bunch.oldHead = oldHead or p.h

    return bunch
#@-node:ekr.20050315133212.2:beforeChangeNodeContents
#@+node:ekr.20050315134017.6:beforeChangeTree
def beforeChangeTree (self,p):

    # g.trace(p.h)

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    bunch = u.createCommonBunch(p)
    bunch.oldSel = w.getSelectionRange()
    bunch.oldText = w.getAllText()
    bunch.oldTree = u.saveTree(p)

    return bunch
#@-node:ekr.20050315134017.6:beforeChangeTree
#@+node:ekr.20050424161505.1:beforeClearRecentFiles
def beforeClearRecentFiles (self):

    u = self ; p = u.c.p

    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch
#@-node:ekr.20050424161505.1:beforeClearRecentFiles
#@+node:ekr.20050412080354:beforeCloneNode
def beforeCloneNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    return bunch
#@-node:ekr.20050412080354:beforeCloneNode
#@+node:ekr.20050411193627.3:beforeDeleteNode
def beforeDeleteNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()

    return bunch
#@-node:ekr.20050411193627.3:beforeDeleteNode
#@+node:ekr.20050411193627.4:beforeInsertNode
def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):

    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone

    if pasteAsClone:
        # Save the list of bunched.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
#@-node:ekr.20050411193627.4:beforeInsertNode
#@+node:ekr.20050526131252:beforeMark
def beforeMark (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command

    return bunch
#@-node:ekr.20050526131252:beforeMark
#@+node:ekr.20050410110215:beforeMoveNode
def beforeMoveNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldN = p.childIndex()
    bunch.oldParent_v = p._parentVnode()

    return bunch
#@-node:ekr.20050410110215:beforeMoveNode
#@+node:ekr.20080425060424.3:beforeSort
def beforeSort (self,p,undoType,oldChildren,newChildren,sortChildren):

    '''Create an undo node for sort operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'sort'
    bunch.undoType = undoType

    bunch.undoHelper = u.undoSort
    bunch.redoHelper = u.redoSort

    bunch.oldChildren = oldChildren
    bunch.newChildren = newChildren
    bunch.sortChildren = sortChildren # A bool

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    return bunch
#@-node:ekr.20080425060424.3:beforeSort
#@+node:ekr.20050318085432.2:createCommonBunch
def createCommonBunch (self,p):

    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = w and w.getSelectionRange() or None,
        p = p.copy(),
    )
#@-node:ekr.20050318085432.2:createCommonBunch
#@-node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20031218072017.3610:canRedo & canUndo
# Translation does not affect these routines.

def canRedo (self):

    u = self

    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self

    return u.undoMenuLabel != "Can't Undo"
#@-node:ekr.20031218072017.3610:canRedo & canUndo
#@+node:ekr.20031218072017.3609:clearUndoState
def clearUndoState (self):

    """Clears then entire Undo state.

    All non-undoable commands should call this method."""

    u = self
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()
#@-node:ekr.20031218072017.3609:clearUndoState
#@+node:ekr.20031218072017.3611:enableMenuItems
def enableMenuItems (self):

    u = self ; frame = u.c.frame

    menu = frame.menu.getMenu("Edit")
    if menu:
        frame.menu.enableMenu(menu,u.redoMenuLabel,u.canRedo())
        frame.menu.enableMenu(menu,u.undoMenuLabel,u.canUndo())
#@-node:ekr.20031218072017.3611:enableMenuItems
#@+node:ekr.20031218072017.1490:setUndoTypingParams
def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False and not g.unitTesting # Can cause unit tests to fail.
    verbose = False
    << return if there is nothing to do >>
    if trace: g.trace(undo_type,oldSel,newSel,g.callers(5))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    return bunch
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@
Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace and verbose:
    g.pr("lead,trail",leading,trailing)
    g.pr("old mid,nls:",len(old_middle_lines),old_newlines,oldText)
    g.pr("new mid,nls:",len(new_middle_lines),new_newlines,newText)
    #g.pr("lead,trail:",leading,trailing)
    #g.pr("old mid:",old_middle_lines)
    #g.pr("new mid:",new_middle_lines)
    g.pr("---------------------")
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.b.
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = '\n'.join(old_middle_lines)
    s2 = '\n'.join(new_middle_lines)
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
# Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()

# Bug fix: Leo 4.4.6: always add p to the list.
bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('exception in','setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@-node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self,event=None):

    '''Redo the operation undone by the last undo.'''

    trace = False and not g.unitTesting
    u = self ; c = u.c
    w = c.frame.body.bodyCtrl

    if not u.canRedo():
        if trace: g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.p:
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.redoing = True 
    u.groupCount = 0

    c.endEditing()
    if u.redoHelper: u.redoHelper()
    else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    if u.newChanged is None: u.newChanged = True
    c.setChanged(u.newChanged) # 2009/12/21
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    c.bodyWantsFocusNow()
    # g.trace(i,j,ins)
    w.setSelectionRange(i,j,insert=ins)
    w.seeInsertPoint()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):

    u = self ; c = u.c

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20080425060424.9:redoDemote
def redoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = u.p.childIndex()

    # Move the demoted nodes from the old parent to the new parent.
    parent_v.children = parent_v.children[:n+1]
    u.p.v.children.extend(u.followingSibs)

    # Adjust the parent links of the moved nodes.
    # There is no need to adjust descendant links.
    for v in u.followingSibs:
        v.parents.remove(parent_v)
        v.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.9:redoDemote
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                # g.trace(z.redoHelper)
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('new') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty()

    if not g.unitTesting:
        g.es("redo",count,"instances")

    c.selectPosition(p)
    if newSel: c.frame.body.setSelectionRange(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    if u.pasteAsClone:
        for bunch in u.afterTree:
            v = bunch.v
            if u.newP.v == v:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
            # g.trace(v,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050526125801:redoMark
def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty()

        c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.oldParent_v.children[u.oldN] == v
    del u.oldParent_v.children[u.oldN]

    parent_v = u.newParent_v
    parent_v.children.insert(u.newN,v)
    v.parents.append(u.newParent_v)
    v.parents.remove(u.oldParent_v)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setBodyString(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)

    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20080425060424.13:redoPromote
def redoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()

    # Add the children to parent_v's children.
    n = u.p.childIndex() + 1

    old_children = parent_v.children[:]
    parent_v.children = old_children[:n]
        # Add children up to the promoted nodes.
    parent_v.children.extend(u.children)
        # Add the promoted nodes.
    parent_v.children.extend(old_children[n:])
        # Add the children up to the promoted nodes.

    # Remove the old children.
    u.p.v.children = []

    # Adjust the parent links in the moved children.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(u.p.v)
        child.parents.append(parent_v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.13:redoPromote
#@+node:ekr.20080425060424.4:redoSort
def redoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.newChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
#@nonl
#@-node:ekr.20080425060424.4:redoSort
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self,event=None):

    """Undo the operation described by the undo parameters."""

    trace = False and not g.unitTesting
    u = self ; c = u.c
    w = c.frame.body.bodyCtrl

    if not u.canUndo():
        if trace: g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.p:
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.undoing = True
    u.groupCount = 0

    c.endEditing()
    if u.undoHelper: u.undoHelper()
    else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    if u.oldChanged is None: u.oldChanged = True
    c.setChanged(u.oldChanged) # 2009/12/21
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    c.bodyWantsFocusNow()
    # g.trace(i,j,ins)
    w.setSelectionRange(i,j,insert=ins)
    w.seeInsertPoint()
    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6

    c.selectPosition(u.p)
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p._linkAfter(u.oldBack)
    elif u.oldParent:
        u.p._linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p._linkAsRoot(oldRoot)

    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20080425060424.10:undoDemote
def undoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)

    # Remove the demoted nodes from p's children.
    u.p.v.children = u.p.v.children[:-n]

    # Add the demoted nodes to the parent's children.
    parent_v.children.extend(u.followingSibs)

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for sib in u.followingSibs:
        sib.parents.remove(u.p.v)
        sib.parents.append(parent_v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.10:undoDemote
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            # g.trace(z.undoHelper)
            if z.undoHelper:
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('old') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if not g.unitTesting:
        g.es("undo",count,"instances")

    c.selectPosition(p)
    if oldSel: c.frame.body.setSelectionRange(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)

    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            v = bunch.v
            if u.p.v == v:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty() # Bug fix: Leo 4.4.6.

        c.selectPosition(u.p)
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.newParent_v.children[u.newN] == v
    del u.newParent_v.children[u.newN]
    u.oldParent_v.children.insert(u.oldN,v)

    # Recompute the parent links.
    v.parents.append(u.oldParent_v)
    v.parents.remove(u.newParent_v)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.p)
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setBodyString(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)

    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20080425060424.14:undoPromote
def undoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode() # The parent of the all the *promoted* nodes.

    # Remove the promoted nodes from parent_v's children.
    n = u.p.childIndex() + 1

    # Adjust the old parents children
    old_children = parent_v.children
    parent_v.children = old_children[:n]
        # Add the nodes before the promoted nodes.
    parent_v.children.extend(old_children[n+len(u.children):])
        # Add the nodes after the promoted nodes.

    # Add the demoted nodes to v's children.
    u.p.v.children = u.children[:]

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(parent_v)
        child.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.14:undoPromote
#@+node:ekr.20031218072017.1493:undoRedoText
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    # newNewlines is unused, but it has symmetry.

    trace = False and not g.unitTesting

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setBodyString(result)
    w.setAllText(result)
    sel = g.choose(tag=='undo',u.oldSel,u.newSel)
    if trace: g.trace(sel)
    i,j = sel
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.recolor(p,incremental=False)
    w.seeInsertPoint() # 2009/12/21
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.b
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = '\n'.join(s)
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.b)

    return p # Nothing really changes.
#@-node:ekr.20050408100042:undoRedoTree
#@+node:ekr.20080425060424.5:undoSort
def undoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.oldChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
#@nonl
#@-node:ekr.20080425060424.5:undoSort
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
#@-node:ekr.20050318085713.2:undoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@-node:ekr.20031218072017.2039:undo & helpers...
#@-node:ekr.20031218072017.3605:class undoer
#@-node:ekr.20091221145433.6378:TL undo bug: window dirty bit not preserved
#@+node:ekr.20091222102020.6532:no log when notebook does not exist
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    defaultFileName = None
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')
            defaultFileName = fileName

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    if not fileName: fileName = defaultFileName

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)

    g.app.writeWaitingLog(c) # 2009/12/22: fixes bug 448886

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20031218072017.2619:app.writeWaitingLog
def writeWaitingLog (self,c,forceLog=False):

    app = self
    # Do not call g.es, g.es_print, g.pr or g.trace here!
    # print('writeWaitingLog',c,g.callers(4))
    table = [
        ('Leo Log Window','red'),
        (app.signon,'black'),
        (app.signon2,'black'),
    ]
    table.reverse()

    if app.log:
        if not app.logInited:
            app.logInited = True # Prevent recursive call.
            print(app.signon)
            print(app.signon2)
            for s,color in table:
                app.logWaiting.insert(0,(s+'\n',color),)
        elif forceLog:
            for s,color in table:
                app.logWaiting.insert(0,(s+'\n',color),)
        # The test for isNull would probably interfere with batch mode.
        for s in app.printWaiting:
            print(s)
        app.printWaiting = []
        for s,color in app.logWaiting:
            g.es('',s,color=color,newline=0)
                # The caller must write the newlines.
        app.logWaiting = []
    else:
        print('writeWaitingLog: still no log!')
#@-node:ekr.20031218072017.2619:app.writeWaitingLog
#@-node:ekr.20091222102020.6532:no log when notebook does not exist
#@+node:ekr.20091221145433.6380:TL Undo messes with selection & view
@nocolor-node

Bug 362950: during body text undo selection goes nuts and view moves
+1 by Terry Brown.

Ubuntu 8.10, latest leo, qt gui, python 2.5.2

In the Qt gui, when you undo editing in the body text, the selected text does
odd things (selects from start of buffer to current position or something) and
the view jumps about in the body text, assuming it's long enough.

This is very disconcerting, when I undo things I like to see them change back,
but instead you lose track of where you were writing and how much has been
undone. This makes undo almost unusable, because you can't keep track of how
much undoing has been done.

===========

Undoing multi-line edits on body texts too long to fit in a single view results
in odd selection extents and the view returning to the top of the text, both of
which make it impossible to keep track of how much has been undone. After each
step in undoing the cursor needs to be at the end of the region where the undo
occurred, and the view should only shift if necessary to include the cursor.

============

I've posted a small movie of the problem here:

http://131.212.123.124/~tbrown/tmp/out.avi

There's some editing, and then I start undoing it, and when the whole text
becomes selected (which never happened during the editing), that's the problem.

Note, this was done with the editor window detached to make the video small,
although I suppose having the rest of the leo window in frame would make no
difference if it doesn't change, frame compression wise.

=============

Hmm, the only way I'm getting it now (just pulled the trunk prior to trying) is
to use mouse select / drag editing.

- Paste some paras into the body

- Select some text with the mouse

- click-drag the text somewhere else with the mouse

so, I guess that particular kind of editing isn't interacting with the undo
system the same way other editing does.

But undo is working, its just its recreation of the selection / insert point
that's missing. So it's picking up the changes, but perhaps only as whole text
changes?

Maybe, and I'm trying to be as helpful as possible here because I'm sure you'll
want to curse all mouse users and leave it as is :-), maybe, if I'm right that
this style of editing looks like atomic whole text changes to the undo system,
and that can't be addressed directly, and the situation can be detected (one way
would be that the selection is the whole text and the cursor position is the
beginning of the body), a best attempt at not confusing the user would be to (a)
not select the whole text, because it never was wholly selected, and (b), move
the insert point to the first difference between the new and old text.
#@nonl
#@+node:ekr.20090608081524.6109:setBodyTextAfterSelect
def setBodyTextAfterSelect (self,p,old_p):

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = g.toUnicode(p.v._bodyString,"utf-8")
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s,new_p=p)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    if p.v and p.v.scrollBarSpot != None:
        first,last = p.v.scrollBarSpot
        w.setYScrollPosition(first)

    if p.v and p.v.insertSpot != None:
        spot = p.v.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
        # g.trace(spot)
    else:
        w.setInsertPoint(0)
#@-node:ekr.20090608081524.6109:setBodyTextAfterSelect
#@+node:ekr.20070423101911:selectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace:
        if old_p:
            g.trace('old: %s %s new: %s %s' % (
                len(old_p.b),old_p.h,len(p.b),p.h))
        else:
            g.trace('old: <none> new: %s %s' % (len(p.b),p.h))

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.p here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    if trace: g.trace('**** after old: %s new %s' % (
        old_p and len(old_p.b),len(p.b)))

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p:
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20070423101911:selectHelper
#@+node:ekr.20091221145433.6383:Example
@nocolor-node


so, I guess that particular kind of editing isn't interacting with the undo
system the same way other editing does.

But undo is working, its just its recreation of the selection / insert point
that's missing. So it's picking up the changes, but perhaps only as whole text
changes?

Maybe, and I'm trying to be as helpful as possible here because I'm sure you'll
want to curse all mouse users and leave it as is :-), maybe, if I'm right that
this style of editing looks like atomic whole text changes to the undo system,
and that can't be addressed directly, and the situation can be detected (one way
would be that the selection is the whole text and the cursor position is the
beginning of the body), a best attempt at not confusing the user would be to (a)
not select the whole text, because it never was wholly selected, and (b), move
the insert point to the first difference between the new and old text.
#@nonl
#@-node:ekr.20091221145433.6383:Example
#@+node:ekr.20031218072017.3605:class undoer
class undoer:
    """A class that implements unlimited undo and redo."""
    @others
#@+node:ekr.20031218072017.3606:undo.__init__ & clearIvars
def __init__ (self,c):

    self.c = c
    self.debug = False # True: enable debugging code in new undo scheme.
    self.debug_print = False # True: enable print statements in debug code.

    self.granularity = c.config.getString('undo_granularity')
    if self.granularity: self.granularity = self.granularity.lower()
    if self.granularity not in ('node','line','word','char'):
        self.granularity = 'line'
    # g.trace('undoer',self.granularity)

    self.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if self.debug is on).
    self.new_mem = 0
    self.old_mem = 0

    # State ivars...
    self.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    self.redoMenuLabel = "Can't Redo"
    self.undoMenuLabel = "Can't Undo"
    self.realRedoMenuLabel = "Can't Redo"
    self.realUndoMenuLabel = "Can't Undo"
    self.undoing = False # True if executing an Undo command.
    self.redoing = False # True if executing a Redo command.

    # New in 4.2...
    self.optionalIvars = []

    # Set the following ivars to keep pylint happy.
    self.afterTree = None
    self.beforeTree = None
    self.children = None
    self.dirtyVnodeList = None
    self.followingSibs = None
    self.kind = None
    self.newBack = None
    self.newBody = None
    self.newChanged = None
    self.newChildren = None
    self.newHead = None
    self.newMarked = None
    self.newN = None
    self.newP = None
    self.newParent = None
    self.newParent_v = None
    self.newRecentFiles = None
    self.newTree = None
    self.oldBack = None
    self.oldBody = None
    self.oldChanged = None
    self.oldChildren = None
    self.oldHead = None
    self.oldMarked = None
    self.oldN = None
    self.oldParent = None
    self.oldParent_v = None
    self.oldRecentFiles = None
    self.oldTree = None
    self.pasteAsClone = None
    self.sortChildren = None

def redoHelper(self):
    pass

def undoHelper(self):
    pass
#@+node:ekr.20031218072017.3607:clearIvars
def clearIvars (self):

    u = self

    # g.trace(g.callers(5))

    u.p = None # The position/node being operated upon for undo and redo.

    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
#@-node:ekr.20031218072017.3607:clearIvars
#@-node:ekr.20031218072017.3606:undo.__init__ & clearIvars
#@+node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20060127052111.1:cutStack
def cutStack (self):

    u = self ; n = u.max_undo_stack_size

    if n > 0 and u.bead >= n and not g.app.unitTesting:

        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i >= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads),g.callers())
#@-node:ekr.20060127052111.1:cutStack
#@+node:ekr.20080623083646.10:dumpBead
def dumpBead (self,n):

    u = self
    if n < 0 or n >= len(u.beads):
        return 'no bead: n = ',n

    bunch = u.beads[n] ; result = []
    result.append('-' * 10)
    result.append('len(u.beads): %s, n: %s' % (len(u.beads),n))
    for ivar in ('kind','newP','newN','p','oldN','undoHelper'):
        result.append('%s = %s' % (ivar,getattr(self,ivar)))
    return '\n'.join(result)

def dumpTopBead(self):

    u = self
    n = len(u.beads)
    if n > 0:
        return self.dumpBead(n-1)
    else:
        return '<no top bead>'
#@-node:ekr.20080623083646.10:dumpBead
#@+node:EKR.20040526150818:getBead
def getBead (self,n):

    '''Set undoer ivars from the bunch at the top of the undo stack.'''

    u = self
    if n < 0 or n >= len(u.beads):
        return None

    bunch = u.beads[n]

    self.setIvarsFromBunch(bunch)

    return bunch
#@-node:EKR.20040526150818:getBead
#@+node:EKR.20040526150818.1:peekBead
def peekBead (self,n):

    u = self
    if n < 0 or n >= len(u.beads):
        return None
    bunch = u.beads[n]
    # g.trace(n,len(u.beads),bunch)
    return bunch
#@-node:EKR.20040526150818.1:peekBead
#@+node:ekr.20060127113243:pushBead
def pushBead (self,bunch):

    u = self

    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.bead >= 0 and u.bead < len(u.beads) and u.beads[u.bead]

    if bunch2 and hasattr(bunch2,'kind') and bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
        # g.trace('u.bead',u.bead,'len u.beads',len(u.beads),g.callers())

        # Recalculate the menu labels.
        u.setUndoTypes()
#@-node:ekr.20060127113243:pushBead
#@+node:ekr.20060127070008:setIvarsFromBunch
def setIvarsFromBunch (self,bunch):

    u = self

    u.clearIvars()

    if 0: # Debugging.
        g.pr('-' * 40)
        for key in sorted(bunch):
            g.trace(key,bunch.get(key))
        g.pr('-' * 20)

    # bunch is not a dict, so bunch.keys() is required.
    for key in list(bunch.keys()): 
        val = bunch.get(key)
        # g.trace(key,val)
        setattr(u,key,val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
#@-node:ekr.20060127070008:setIvarsFromBunch
#@+node:ekr.20050126081529:recognizeStartOfTypingWord
def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''

    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
#@-node:ekr.20050126081529:recognizeStartOfTypingWord
#@+node:ekr.20031218072017.3613:redoMenuName, undoMenuName
def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name
#@-node:ekr.20031218072017.3613:redoMenuName, undoMenuName
#@+node:ekr.20031218072017.3614:setRedoType
# These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame

    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'

    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel
#@-node:ekr.20031218072017.3614:setRedoType
#@+node:ekr.20091221145433.6381:setUndoType
def setUndoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
#@-node:ekr.20091221145433.6381:setUndoType
#@+node:ekr.20031218072017.3616:setUndoTypes
def setUndoTypes (self):

    u = self

    # g.trace(g.callers(7))

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")

    u.cutStack()
#@-node:ekr.20031218072017.3616:setUndoTypes
#@+node:EKR.20040530121329:u.restoreTree & helpers
def restoreTree (self,treeInfo):

    """Use the tree info to restore all vnode data,
    including all links."""

    u = self

    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
#@+node:ekr.20050415170737.2:restoreVnodeUndoInfo
def restoreVnodeUndoInfo (self,bunch):

    """Restore all ivars saved in the bunch."""

    v = bunch.v

    v.statusBits = bunch.statusBits
    v.children   = bunch.children
    v.parents    = bunch.parents

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170737.2:restoreVnodeUndoInfo
#@+node:ekr.20050415170812.2:restoreTnodeUndoInfo
def restoreTnodeUndoInfo (self,bunch):

    v = bunch.v
    v._headString  = bunch.headString
    v._bodyString  = bunch.bodyString
    v.statusBits  = bunch.statusBits

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170812.2:restoreTnodeUndoInfo
#@-node:EKR.20040530121329:u.restoreTree & helpers
#@+node:EKR.20040528075307:u.saveTree & helpers
def saveTree (self,p,treeInfo=None):

    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    << about u.saveTree >>

    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
#@+node:EKR.20040530114124:<< about u.saveTree >>
@ 
The old code made a free-standing copy of the tree using v.copy and t.copy. This
looks "elegant" and is WRONG. The problem is that it can not handle clones
properly, especially when some clones were in the "undo" tree and some were not.
Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to
properly restore the vnodes and tnodes. It creates a list of tuples, on tuple
for each vnode in the tree. Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the
nodes. The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to
the old v.copy and t.copy methods.

Aside: Prior to 4.2 Leo used a scheme that was equivalent to the
createUndoInfoDict info, but quite a bit uglier.
#@nonl
#@-node:EKR.20040530114124:<< about u.saveTree >>
#@+node:ekr.20050415170737.1:createVnodeUndoInfo
def createVnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode for undo."""

    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parents    = v.parents[:],
        children   = v.children[:],
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170737.1:createVnodeUndoInfo
#@+node:ekr.20050415170812.1:createTnodeUndoInfo
def createTnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        v = v,
        headString = v._headString,
        bodyString = v._bodyString,
        statusBits = v.statusBits,
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170812.1:createTnodeUndoInfo
#@-node:EKR.20040528075307:u.saveTree & helpers
#@+node:ekr.20050525151449:u.trace
def trace (self):

    ivars = ('kind','undoType')

    for ivar in ivars:
        g.pr(ivar, getattr(self,ivar))
#@-node:ekr.20050525151449:u.trace
#@+node:ekr.20050410095424:updateMarks
def updateMarks (self,oldOrNew):

    '''Update dirty and marked bits.'''

    u = self ; c = u.c

    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    marked = g.choose(isOld,u.oldMarked, u.newMarked)

    if marked:  c.setMarked(u.p)
    else:       c.clearMarked(u.p)

    # Bug fix: Leo 4.4.6: Undo/redo always set changed/dirty bits
    # because the file may have been saved.
    u.p.setDirty(setDescendentsDirty=False)
    u.p.setAllAncestorAtFileNodesDirty(setDescendentsDirty=False) # Bug fix: Leo 4.4.6
    u.c.setChanged(True)
#@-node:ekr.20050410095424:updateMarks
#@-node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050315134017.4:afterChangeGroup
def afterChangeGroup (self,p,undoType,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

    bunch = u.beads[u.bead]
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:
        g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)

    # Set the types & helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = undoType

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newP = p.copy()
    bunch.newSel = w.getSelectionRange()

    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag

    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@-node:ekr.20050315134017.4:afterChangeGroup
#@+node:ekr.20050315134017.2:afterChangeNodeContents
def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.b
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.h
    bunch.newMarked = p.isMarked()
    bunch.newSel = w.getSelectionRange()

    u.pushBead(bunch)
#@-node:ekr.20050315134017.2:afterChangeNodeContents
#@+node:ekr.20050315134017.3:afterChangeTree
def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = w.getSelectionRange()
    bunch.newText = w.getAllText()
    bunch.newTree = u.saveTree(p)

    u.pushBead(bunch)
#@-node:ekr.20050315134017.3:afterChangeTree
#@+node:ekr.20050424161505:afterClearRecentFiles
def afterClearRecentFiles (self,bunch):

    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]

    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles

    u.pushBead(bunch)

    return bunch
#@-node:ekr.20050424161505:afterClearRecentFiles
#@+node:ekr.20050411193627.5:afterCloneNode
def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'clone'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050411193627.5:afterCloneNode
#@+node:ekr.20050411193627.6:afterDehoist
def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    u.pushBead(bunch)
#@-node:ekr.20050411193627.6:afterDehoist
#@+node:ekr.20050411193627.8:afterDeleteNode
def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'delete'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050411193627.8:afterDeleteNode
#@+node:ekr.20080425060424.8:afterDemote
def afterDemote (self,p,followingSibs,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'demote'
    bunch.undoType = 'Demote'

    bunch.undoHelper = u.undoDemote
    bunch.redoHelper = u.redoDemote

    bunch.followingSibs = followingSibs

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@-node:ekr.20080425060424.8:afterDemote
#@+node:ekr.20050411193627.7:afterHoist
def afterHoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'hoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    u.pushBead(bunch)
#@-node:ekr.20050411193627.7:afterHoist
#@+node:ekr.20050411193627.9:afterInsertNode
def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())

    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            v = bunch2.v
            afterTree.append(
                g.Bunch(v=v,head=v._headString[:],body=v._bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)
#@-node:ekr.20050411193627.9:afterInsertNode
#@+node:ekr.20050526124257:afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node for mark and unmark commands.'''

    # 'command' unused, but present for compatibility with similar methods.

    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark

    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050526124257:afterMark
#@+node:ekr.20050410110343:afterMoveNode
def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'move'
    bunch.undoType = command

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newN = p.childIndex()
    bunch.newParent_v = p._parentVnode()
    bunch.newP = p.copy()

    u.pushBead(bunch)
#@-node:ekr.20050410110343:afterMoveNode
#@+node:ekr.20080425060424.12:afterPromote
def afterPromote (self,p,children,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'promote'
    bunch.undoType = 'Promote'

    bunch.undoHelper = u.undoPromote
    bunch.redoHelper = u.redoPromote

    bunch.children = children

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@-node:ekr.20080425060424.12:afterPromote
#@+node:ekr.20080425060424.2:afterSort
def afterSort (self,p,bunch,dirtyVnodeList):

    '''Create an undo node for sort operations'''

    u = self ; c = self.c
    if u.redoing or u.undoing: return

    bunch.dirtyVnodeList = dirtyVnodeList

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@-node:ekr.20080425060424.2:afterSort
#@-node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20050315134017.7:beforeChangeGroup
def beforeChangeGroup (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command

    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
#@-node:ekr.20050315134017.7:beforeChangeGroup
#@+node:ekr.20050315133212.2:beforeChangeNodeContents
def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):

    '''Return data that gets passed to afterChangeNode'''

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBody = oldBody or p.b
    bunch.oldHead = oldHead or p.h

    return bunch
#@-node:ekr.20050315133212.2:beforeChangeNodeContents
#@+node:ekr.20050315134017.6:beforeChangeTree
def beforeChangeTree (self,p):

    # g.trace(p.h)

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    bunch = u.createCommonBunch(p)
    bunch.oldSel = w.getSelectionRange()
    bunch.oldText = w.getAllText()
    bunch.oldTree = u.saveTree(p)

    return bunch
#@-node:ekr.20050315134017.6:beforeChangeTree
#@+node:ekr.20050424161505.1:beforeClearRecentFiles
def beforeClearRecentFiles (self):

    u = self ; p = u.c.p

    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch
#@-node:ekr.20050424161505.1:beforeClearRecentFiles
#@+node:ekr.20050412080354:beforeCloneNode
def beforeCloneNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    return bunch
#@-node:ekr.20050412080354:beforeCloneNode
#@+node:ekr.20050411193627.3:beforeDeleteNode
def beforeDeleteNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()

    return bunch
#@-node:ekr.20050411193627.3:beforeDeleteNode
#@+node:ekr.20050411193627.4:beforeInsertNode
def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):

    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone

    if pasteAsClone:
        # Save the list of bunched.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
#@-node:ekr.20050411193627.4:beforeInsertNode
#@+node:ekr.20050526131252:beforeMark
def beforeMark (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command

    return bunch
#@-node:ekr.20050526131252:beforeMark
#@+node:ekr.20050410110215:beforeMoveNode
def beforeMoveNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldN = p.childIndex()
    bunch.oldParent_v = p._parentVnode()

    return bunch
#@-node:ekr.20050410110215:beforeMoveNode
#@+node:ekr.20080425060424.3:beforeSort
def beforeSort (self,p,undoType,oldChildren,newChildren,sortChildren):

    '''Create an undo node for sort operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'sort'
    bunch.undoType = undoType

    bunch.undoHelper = u.undoSort
    bunch.redoHelper = u.redoSort

    bunch.oldChildren = oldChildren
    bunch.newChildren = newChildren
    bunch.sortChildren = sortChildren # A bool

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    return bunch
#@-node:ekr.20080425060424.3:beforeSort
#@+node:ekr.20050318085432.2:createCommonBunch
def createCommonBunch (self,p):

    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = w and w.getSelectionRange() or None,
        p = p.copy(),
    )
#@-node:ekr.20050318085432.2:createCommonBunch
#@-node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20031218072017.3610:canRedo & canUndo
# Translation does not affect these routines.

def canRedo (self):

    u = self

    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self

    return u.undoMenuLabel != "Can't Undo"
#@-node:ekr.20031218072017.3610:canRedo & canUndo
#@+node:ekr.20031218072017.3609:clearUndoState
def clearUndoState (self):

    """Clears then entire Undo state.

    All non-undoable commands should call this method."""

    u = self
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()
#@-node:ekr.20031218072017.3609:clearUndoState
#@+node:ekr.20031218072017.3611:enableMenuItems
def enableMenuItems (self):

    u = self ; frame = u.c.frame

    menu = frame.menu.getMenu("Edit")
    if menu:
        frame.menu.enableMenu(menu,u.redoMenuLabel,u.canRedo())
        frame.menu.enableMenu(menu,u.undoMenuLabel,u.canUndo())
#@-node:ekr.20031218072017.3611:enableMenuItems
#@+node:ekr.20031218072017.1490:setUndoTypingParams
def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False and not g.unitTesting # Can cause unit tests to fail.
    verbose = False
    << return if there is nothing to do >>
    if trace: g.trace(undo_type,oldSel,newSel,g.callers(5))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    return bunch
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@
Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace and verbose:
    g.pr("lead,trail",leading,trailing)
    g.pr("old mid,nls:",len(old_middle_lines),old_newlines,oldText)
    g.pr("new mid,nls:",len(new_middle_lines),new_newlines,newText)
    #g.pr("lead,trail:",leading,trailing)
    #g.pr("old mid:",old_middle_lines)
    #g.pr("new mid:",new_middle_lines)
    g.pr("---------------------")
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.b.
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = '\n'.join(old_middle_lines)
    s2 = '\n'.join(new_middle_lines)
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
# Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()

# Bug fix: Leo 4.4.6: always add p to the list.
bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('exception in','setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@-node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self,event=None):

    '''Redo the operation undone by the last undo.'''

    trace = False and not g.unitTesting
    u = self ; c = u.c
    w = c.frame.body.bodyCtrl

    if not u.canRedo():
        if trace: g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.p:
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.redoing = True 
    u.groupCount = 0

    c.endEditing()
    if u.redoHelper: u.redoHelper()
    else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    if u.newChanged is None: u.newChanged = True
    c.setChanged(u.newChanged) # 2009/12/21
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    c.bodyWantsFocusNow()
    # g.trace(i,j,ins)
    w.setSelectionRange(i,j,insert=ins)
    w.seeInsertPoint()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):

    u = self ; c = u.c

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20080425060424.9:redoDemote
def redoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = u.p.childIndex()

    # Move the demoted nodes from the old parent to the new parent.
    parent_v.children = parent_v.children[:n+1]
    u.p.v.children.extend(u.followingSibs)

    # Adjust the parent links of the moved nodes.
    # There is no need to adjust descendant links.
    for v in u.followingSibs:
        v.parents.remove(parent_v)
        v.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.9:redoDemote
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                # g.trace(z.redoHelper)
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('new') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty()

    if not g.unitTesting:
        g.es("redo",count,"instances")

    c.selectPosition(p)
    if newSel: c.frame.body.setSelectionRange(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    if u.pasteAsClone:
        for bunch in u.afterTree:
            v = bunch.v
            if u.newP.v == v:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
            # g.trace(v,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050526125801:redoMark
def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty()

        c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.oldParent_v.children[u.oldN] == v
    del u.oldParent_v.children[u.oldN]

    parent_v = u.newParent_v
    parent_v.children.insert(u.newN,v)
    v.parents.append(u.newParent_v)
    v.parents.remove(u.oldParent_v)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setBodyString(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)

    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20080425060424.13:redoPromote
def redoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()

    # Add the children to parent_v's children.
    n = u.p.childIndex() + 1

    old_children = parent_v.children[:]
    parent_v.children = old_children[:n]
        # Add children up to the promoted nodes.
    parent_v.children.extend(u.children)
        # Add the promoted nodes.
    parent_v.children.extend(old_children[n:])
        # Add the children up to the promoted nodes.

    # Remove the old children.
    u.p.v.children = []

    # Adjust the parent links in the moved children.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(u.p.v)
        child.parents.append(parent_v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.13:redoPromote
#@+node:ekr.20080425060424.4:redoSort
def redoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.newChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
#@nonl
#@-node:ekr.20080425060424.4:redoSort
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self,event=None):

    """Undo the operation described by the undo parameters."""

    trace = False and not g.unitTesting
    u = self ; c = u.c
    w = c.frame.body.bodyCtrl

    if not u.canUndo():
        if trace: g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.p:
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.undoing = True
    u.groupCount = 0

    c.endEditing()
    if u.undoHelper: u.undoHelper()
    else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    if u.oldChanged is None: u.oldChanged = True
    c.setChanged(u.oldChanged) # 2009/12/21
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    c.bodyWantsFocusNow()
    # g.trace(i,j,ins)
    w.setSelectionRange(i,j,insert=ins)
    w.seeInsertPoint()
    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6

    c.selectPosition(u.p)
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p._linkAfter(u.oldBack)
    elif u.oldParent:
        u.p._linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p._linkAsRoot(oldRoot)

    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20080425060424.10:undoDemote
def undoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)

    # Remove the demoted nodes from p's children.
    u.p.v.children = u.p.v.children[:-n]

    # Add the demoted nodes to the parent's children.
    parent_v.children.extend(u.followingSibs)

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for sib in u.followingSibs:
        sib.parents.remove(u.p.v)
        sib.parents.append(parent_v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.10:undoDemote
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            # g.trace(z.undoHelper)
            if z.undoHelper:
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('old') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if not g.unitTesting:
        g.es("undo",count,"instances")

    c.selectPosition(p)
    if oldSel: c.frame.body.setSelectionRange(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)

    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            v = bunch.v
            if u.p.v == v:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty() # Bug fix: Leo 4.4.6.

        c.selectPosition(u.p)
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.newParent_v.children[u.newN] == v
    del u.newParent_v.children[u.newN]
    u.oldParent_v.children.insert(u.oldN,v)

    # Recompute the parent links.
    v.parents.append(u.oldParent_v)
    v.parents.remove(u.newParent_v)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.p)
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setBodyString(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)

    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20080425060424.14:undoPromote
def undoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode() # The parent of the all the *promoted* nodes.

    # Remove the promoted nodes from parent_v's children.
    n = u.p.childIndex() + 1

    # Adjust the old parents children
    old_children = parent_v.children
    parent_v.children = old_children[:n]
        # Add the nodes before the promoted nodes.
    parent_v.children.extend(old_children[n+len(u.children):])
        # Add the nodes after the promoted nodes.

    # Add the demoted nodes to v's children.
    u.p.v.children = u.children[:]

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(parent_v)
        child.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.14:undoPromote
#@+node:ekr.20031218072017.1493:undoRedoText
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    # newNewlines is unused, but it has symmetry.

    trace = False and not g.unitTesting

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setBodyString(result)
    w.setAllText(result)
    sel = g.choose(tag=='undo',u.oldSel,u.newSel)
    if trace: g.trace(sel)
    i,j = sel
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.recolor(p,incremental=False)
    w.seeInsertPoint() # 2009/12/21
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.b
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = '\n'.join(s)
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.b)

    return p # Nothing really changes.
#@-node:ekr.20050408100042:undoRedoTree
#@+node:ekr.20080425060424.5:undoSort
def undoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.oldChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
#@nonl
#@-node:ekr.20080425060424.5:undoSort
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
#@-node:ekr.20050318085713.2:undoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@-node:ekr.20031218072017.2039:undo & helpers...
#@-node:ekr.20031218072017.3605:class undoer
#@+node:ekr.20031218072017.1490:setUndoTypingParams
def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False and not g.unitTesting # Can cause unit tests to fail.
    verbose = False
    << return if there is nothing to do >>
    if trace: g.trace(undo_type,oldSel,newSel,g.callers(5))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    return bunch
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@
Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace and verbose:
    g.pr("lead,trail",leading,trailing)
    g.pr("old mid,nls:",len(old_middle_lines),old_newlines,oldText)
    g.pr("new mid,nls:",len(new_middle_lines),new_newlines,newText)
    #g.pr("lead,trail:",leading,trailing)
    #g.pr("old mid:",old_middle_lines)
    #g.pr("new mid:",new_middle_lines)
    g.pr("---------------------")
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.b.
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = '\n'.join(old_middle_lines)
    s2 = '\n'.join(new_middle_lines)
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
# Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()

# Bug fix: Leo 4.4.6: always add p to the list.
bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('exception in','setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@+node:ekr.20031218072017.1493:undoRedoText
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    # newNewlines is unused, but it has symmetry.

    trace = False and not g.unitTesting

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setBodyString(result)
    w.setAllText(result)
    sel = g.choose(tag=='undo',u.oldSel,u.newSel)
    if trace: g.trace(sel)
    i,j = sel
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.recolor(p,incremental=False)
    w.seeInsertPoint() # 2009/12/21
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.b
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = '\n'.join(s)
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20091221145433.6380:TL Undo messes with selection & view
#@+node:ekr.20091227085627.6538:Removed unsettling @auto warning
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    # New in Leo 4.4.7: honor @path directives.
    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>
    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Remember that we have read this file.
        # Fixes bug 488894: unsettling dialog when saving Leo file
        # after creating and populating an @auto node
        p.v.at_auto_read = True # Create the attribute

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ville.20090701144325.14942:g.guessExternalEditor
def guessExternalEditor():
    """ Return a 'sensible' external editor """

    editor = (
        os.environ.get("LEO_EDITOR") or
        os.environ.get("EDITOR") or
        g.app.db.get("LEO_EDITOR"))

    if editor: return editor

    # fallbacks
    platform = sys.platform.lower()
    if platform.startwith('win'):
        return "notepad"
    elif platform.startswith('linux'):
        return 'gedit'
    else:
        g.es('''No editor set.
Please set LEO_EDITOR or EDITOR environment variable,
or do g.app.db['LEO_EDITOR'] = "gvim"''')
        return None
#@-node:ville.20090701144325.14942:g.guessExternalEditor
#@+node:ekr.20070806105721.1:readAtAutoNodes (commands)
def readAtAutoNodes (self,event=None):

    '''Read all @auto nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.p
    c.endEditing()

    undoData = u.beforeChangeTree(p)
    c.importCommands.readAtAutoNodes()
    u.afterChangeTree(p,'Read @auto Nodes',undoData)
    c.redraw()
#@-node:ekr.20070806105721.1:readAtAutoNodes (commands)
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    try:
        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(p, fileContent)
    except IOError:
        cachefile = None

    # Remember that we have read this file.
    p.v.at_auto_read = True # Create the attribute

    if cachefile is not None and cachefile in c.db:        
        # g.es('uncache:',p.h)
        aList = c.db[cachefile]
        p.v.createOutlineFromCacheList(c,aList)
        return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        # c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        self.writeCachedTree(p, cachefile)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.p ; after = p.nodeAfterTree()

    found = False
    while p and p != after:
        if p.isAtAutoNode():
            if p.isAtIgnoreNode():
                g.es_print('ignoring',p.h,color='blue')
                p.moveToThreadNext()
            else:
                self.readOneAtAutoNode(p)
                found = True
                p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    message = g.choose(found,'finished','no @auto nodes in the selected tree')
    g.es(message,color='blue')
    c.redraw()

#@+node:ekr.20070807084545:readOneAtAutoNode (leoImport)
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # Force an update of the body pane.
    self.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20070807084545:readOneAtAutoNode (leoImport)
#@-node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
#@-node:ekr.20091227085627.6538:Removed unsettling @auto warning
#@+node:ekr.20091221094815.6386:at-auto-rst problems
@nocolor-node


#@+node:ekr.20091227092342.6545:Description
@nocolor-node

I'm not able to import many of the example rst files I've come across. Sometimes
I can figure out what changes to make to the file to get it to import, other
times it's not worth the effort. I just open it in another editor.

Also, @auto-rst is not well documented.

=============================
http://groups.google.com/group/leo-editor/browse_thread/thread/b84659e608ba44d5

- Create @auto myfile.rst
- save, close, open Leo file
- change to @auto-rst myfile.rst
- save Leo file: myfile.rst is now empty

The solution: Do not write @auto files with orphan nodes!

The data is lost because @auto-rst mostly ignores the top-level node.
#@-node:ekr.20091227092342.6545:Description
#@+node:ekr.20031218072017.3348:at...FileNodeName & tests
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName (self,h=None):
    # # Prevent conflicts with autotrees plugin: don't allow @auto-whatever to match.
    # return g.match_word(h,0,tag) and not g.match(h,0,tag+'-') and h[len(tag):].strip()
    names = ("@auto","@auto-rst",)
    return self.findAtFileName(names,h=h)

def atAutoRstNodeName (self,h=None):
    names = ("@auto-rst",)
    return self.findAtFileName(names,h=h)

def atEditNodeName (self):
    names = ("@edit",)
    return self.findAtFileName(names)

def atFileNodeName (self):
    names = ("@file",)
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atShadowFileNodeName (self):
    names = ("@shadow",)
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName
#@+node:ekr.20090521064955.5905:@test v.atAutoNodeName & v.atAutoRstNodeName
if g.unitTesting:

    c,p = g.getTestVars()

    table = (
        ('@auto-rst rst-file','rst-file','rst-file'),
        ('@auto x','x',''),
        ('xyz','',''),
    )

    for s,expected1,expected2 in table:
        result1 = p.v.atAutoNodeName(h=s)
        result2 = p.v.atAutoRstNodeName(h=s)
        assert result1 == expected1,'fail1: given %s expected %s got %s' % (
            repr(s),repr(expected1),repr(result1))
        assert result2 == expected2,'fail2: given %s expected %s got %s' % (
            repr(s),repr(expected2),repr(result2))
#@-node:ekr.20090521064955.5905:@test v.atAutoNodeName & v.atAutoRstNodeName
#@-node:ekr.20031218072017.3348:at...FileNodeName & tests
#@+node:ekr.20091219132601.6279:Reading
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    # New in Leo 4.4.7: honor @path directives.
    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>
    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Remember that we have read this file.
        # Fixes bug 488894: unsettling dialog when saving Leo file
        # after creating and populating an @auto node
        p.v.at_auto_read = True # Create the attribute

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Use @verbatim to escape section references
    if self.escapeSectionRefs: # 2009/12/27
        s = self.escapeFalseSectionReferences(s)

    # Check for intermixed blanks and tabs.
    if self.strict or self.atAutoWarnsAboutLeadingWhitespace:
        if not self.isRst:
            self.checkBlanksAndTabs(s)

    # Regularize leading whitespace for strict languages only.
    if self.strict: s = self.regularizeWhitespace(s) 

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20071110105107:checkBlanksAndTabs
def checkBlanksAndTabs(self,s):

    '''Check for intermixed blank & tabs.'''

    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0

    for line in g.splitLines(s):
        lws = line[0:g.skip_ws(line,0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')

    ok = blanks == 0 or tabs == 0

    if not ok:
        self.report('intermixed blanks and tabs')

    return ok
#@-node:ekr.20071110105107:checkBlanksAndTabs
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed:
        action = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
        message = 'inconsistent leading whitespace. %s' % action
        self.report(message)

    return ''.join(result)
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070707072749:run (baseScannerClass)
#@+node:sps.20081111154528.5:escapeFalseSectionReferences
def escapeFalseSectionReferences(self,s):

    result = []
    for line in g.splitLines(s):
        r1 = line.find('<<')
        r2 = line.find('>>')
        if r1>=0 and r2>=0 and r1<r2:
            result.append("@verbatim\n")
            result.append(line)
        else:
            result.append(line)
    return ''.join(result)
#@-node:sps.20081111154528.5:escapeFalseSectionReferences
#@+node:ekr.20070703122141.65:<< class baseScannerClass >>
class baseScannerClass (scanUtility):

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c

    self.atAutoWarnsAboutLeadingWhitespace = c.config.getBool('at_auto_warns_about_leading_whitespace')
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.escapeSectionRefs = True
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.file_s = '' # The complete text to be parsed.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.functionSpelling = 'function' # for error message.
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.isRst = False
    self.language = language
    self.lastParent = None # The last generated parent node (used only by rstScanner).
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.methodsSeen = False
    self.mismatchWarningGiven = False
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = None # Set in run: the tab width in effect in the c.currentPosition.
    self.tab_ws = '' # Set in run: the whitespace equivalent to one tab.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'

    # Compute language ivars.
    delim1,junk,junk = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # May be overridden in subclasses.
    self.anonymousClasses = [] # For Delphi Pascal interfaces.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockCommentDelim1_2 = None
    self.blockCommentDelim2_2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.blockDelim2Cruft = [] # Stuff that can follow .blockDelim2.
    self.classTags = ['class',] # tags that start a tag.
    self.functionTags = []
    self.hasClasses = True
    self.hasFunctions = True
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = True
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,unused_s,unused_parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        if self.isRst: # Errors writing file at present...
            outputFile = StringIO()
            c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
            s1,s2 = self.file_s,outputFile.getvalue()
        else:
            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True)
            s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)

    if self.isRst:
        lines1 = self.adjustRstLines(lines1)
        lines2 = self.adjustRstLines(lines2)

    n1,n2 = len(lines1), len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@-node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
#@+node:ekr.20070730093735:compareHelper & helpers
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    trace = False and not g.unitTesting

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i >= len(lines1):
        ### if self.isRst:
        ###    return True # ignore extra lines.
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif self.isRst and self.compareRstUnderlines(line1,line2):
        return True
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    # if trace:
        # g.es_print('original line: ',line1)
        # g.es_print('generated line:',line2)
        # return True # continue checking.

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
#@+node:ekr.20091227115606.6468:adjustRstLines
def adjustRstLines(self,lines):

    '''Ignore newlines.

    This fudge allows the rst code generators to insert needed newlines freely.'''

    return [z for z in lines if z.strip(' \t') != '\n']
#@-node:ekr.20091227115606.6468:adjustRstLines
#@+node:ekr.20090513073632.5735:compareRstUnderlines
def compareRstUnderlines(self,s1,s2):

    s1,s2 = s1.rstrip(),s2.rstrip()
    if s1 == s2:
        return True # Don't worry about trailing whitespace.

    n1, n2 = len(s1),len(s2)
    ch1 = n1 and s1[0] or ''
    ch2 = n2 and s2[0] or ''

    val = (
        n1 >= 2 and n2 >= 2 and # Underlinings must be at least 2 long.
        ch1 == ch2 and # The underlining characters must match.
        s1 == ch1 * n1 and # The line must consist only of underlining characters.
        s2 == ch2 * n2)

    return val
#@-node:ekr.20090513073632.5735:compareRstUnderlines
#@-node:ekr.20070730093735:compareHelper & helpers
#@+node:ekr.20071110144948:checkLeadingWhitespace
def checkLeadingWhitespace (self,line):

    tab_width = self.tab_width
    lws = line[0:g.skip_ws(line,0)]
    w = g.computeWidth(lws,tab_width)
    ok = (w % abs(tab_width)) == 0

    if not ok:
        self.report('leading whitespace not consistent with @tabwidth %d' % tab_width)
        g.es_print('line:',repr(line),color='red')

    return ok
#@-node:ekr.20071110144948:checkLeadingWhitespace
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    trace = True and not g.unitTesting
    verbose = True

    kind = g.choose(self.atAuto,'@auto','import command')

    x2 = max(0,min(bad_i,len(lines2)-1))
    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d\n%s' % (
            kind,self.root.h,bad_i,repr(lines2[x2])))

    # maxlines = 300
    if trace: # or len(lines1) < maxlines:
        aList = []
        if True: # intermix lines.
            n1,n2 = len(lines1),len(lines2)
            # for i in range(min(maxlines,max(n1,n2))):
            for i in range(max(0,bad_i-2),min(bad_i+3,max(n1,n2))):
                if i < n1: line1 = repr(lines1[i])
                else:      line1 = '<eof>'
                if i < n2: line2 = repr(lines2[i])
                else:      line2 = '<eof>'
                if verbose or line1 != line2:
                    aList.append('%3d %s' % (i,line1))
                    aList.append('%3d %s' % (i,line2))
        else:
            aList.append('input...')
            for i in range(len(lines1)):
                aList.append('%3d %s' % (i,repr(lines1[i])))
            aList.append('output...')
            for i in range(len(lines2)):
                aList.append('%3d %s' % (i,repr(lines2[i])))

        if g.unitTesting:
            assert '\n'.join(aList)
        else:
            g.es_print('\n'.join(aList),color='blue')

    return False
#@+node:ekr.20090517020744.5785:@test reportMismatch
if g.unitTesting:

    import leo.core.leoImport as leoImport
    c,p = g.getTestVars()

    ic = c.importCommands
    scanner = leoImport.rstScanner(importCommands=ic,atAuto=True)
    scanner.root = p
    s1 = ["abc",]
    s2 = ["xyz",]

    scanner.reportMismatch(s1,s2,1)

    # Why is leoSettings.leo scanned twice in dynamicUnitTest.leo?
#@-node:ekr.20090517020744.5785:@test reportMismatch
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20090512080015.5800:adjustParent
def adjustParent (self,parent,headline):

    '''Return the effective parent.

    This is overridden by the rstScanner class.'''

    return parent
#@-node:ekr.20090512080015.5800:adjustParent
#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.isRst and not self.atAuto:
        return

    if self.treeType == '@file':
        self.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        self.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20090122201952.6:appendStringToBody & setBodyString (baseScannerClass)
def appendStringToBody (self,p,s,encoding="utf-8"):

    '''Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.appendStringToBody(p,s,encoding)

def setBodyString (self,p,s,encoding="utf-8"):

    '''Similar to c.setBodyString,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.setBodyString(p,s,encoding)
#@-node:ekr.20090122201952.6:appendStringToBody & setBodyString (baseScannerClass)
#@+node:ekr.20090512153903.5806:computeBody (baseScannerClass)
def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start > 0 and s[start-1] in (' ','\t'):
            start -= 1

    if self.isRst:
        # Never indent any text; discard the entire signature.
        body1 = s[start:sigStart]
        body2 = s[self.sigEnd+1:codeEnd]
        if trace: g.trace('body1: %s body2: %s' % (repr(body1),repr(body2)))
    else:
        body1 = self.undentBody(s[start:sigStart],ignoreComments=False)
        body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2

    if trace: g.trace('body: %s' % repr(body))

    tail = body[len(body.rstrip()):]
    if not '\n' in tail:
        self.warning(
            '%s %s does not end with a newline; one will be added\n%s' % (
            self.functionSpelling,self.sigId,g.get_line(s,codeEnd)))

    return body
#@nonl
#@-node:ekr.20090512153903.5806:computeBody (baseScannerClass)
#@+node:ekr.20090513073632.5737:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = '%s declarations' % self.methodName
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20090513073632.5737:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    return self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent.h,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20090502071837.1:endGen
def endGen (self,s):

    '''Do any language-specific post-processing.'''
    pass
#@-node:ekr.20090502071837.1:endGen
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class,
    and a child of c for each def in the class.'''

    trace = False and not g.unitTesting
    if trace:
        # g.trace('tab_width',self.tab_width)
        g.trace('sig',s[i:sigEnd])

    # Enter a new class 1: save the old class info.
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    headline = headline.strip()
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        self.sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    # Remember the indentation of the class line.
    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,bodyIndent,classDelim,decls,trailing = self.putClassHelper(
        s,i,codeEnd,class_node)
    # g.trace('bodyIndent',bodyIndent,'undentVal',undentVal)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name) or ''

    if trace: g.trace('undentVal',undentVal,'bodyIndent',bodyIndent)

    # Give ref the same indentation as the body of the class.
    if ref:
        bodyWs = g.computeLeadingWhitespace (bodyIndent,self.tab_width)
        ref = '%s%s' % (bodyWs,ref)

    # Remove the leading whitespace.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        self.undentBy(decls,undentVal) +
        self.undentBy(ref,undentVal) +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    self.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070703122141.106:getClassNodeRef
def getClassNodeRef (self,class_name):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    return '%s\n' % (s)
#@-node:ekr.20070703122141.106:getClassNodeRef
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    trace = False and not g.unitTesting

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    j = i ; i = self.skipDecls(s,i,end,inClass=True)
    decls = s[j:i]

    # Set the body indent if there are real decls.
    bodyIndent = decls.strip() and self.getIndent(s,i) or None
    if trace: g.trace('bodyIndent',bodyIndent)

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,bodyIndent2 = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,bodyIndent2 = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    if bodyIndent is None: bodyIndent = bodyIndent2

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,bodyIndent,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction (baseScannerClass)
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and not g.unitTesting
    verbose = False

    # if trace: g.trace(start,sigStart,self.sigEnd,codeEnd)

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body = self.computeBody(s,start,sigStart,codeEnd)

    if trace:
        g.trace('parent',parent.h)
        if verbose: g.trace('**body...\n',body)

    parent = self.adjustParent(parent,headline)
    self.lastParent = self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction (baseScannerClass)
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    self.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20090122201952.5:setBodyString
#@-node:ekr.20090122201952.5:setBodyString
#@+node:ekr.20070703122141.88:undentBody
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    if self.isRst:
        return s # Never unindent rst code.

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result
#@-node:ekr.20070703122141.88:undentBody
#@+node:ekr.20081216090156.1:undentBy
def undentBy (self,s,undentVal):

    '''Remove leading whitespace equivalent to undentVal from each line.
    add an underindentEscapeString for underindented line.'''

    trace = False and not g.app.unitTesting

    if self.isRst:
        return s # Never unindent rst code.

    tag = self.c.atFileCommands.underindentEscapeString
    result = [] ; tab_width = self.tab_width
    for line in g.splitlines(s):
        lws_s = g.get_leading_ws(line)
        lws = g.computeWidth(lws_s,tab_width)
        s = g.removeLeadingWhitespace(line,undentVal,tab_width)
        n = lws - undentVal
        if s.strip() and lws < undentVal:
            if trace: g.trace('undentVal: %s, lws: %s, %s' % (
                undentVal,lws,repr(line)))
            result.append("%s%s%s" % (tag,undentVal-lws,s.lstrip()))
        else:
            result.append(s)

    return ''.join(result)

#@-node:ekr.20081216090156.1:undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    if self.atAutoWarnsAboutLeadingWhitespace:
        self.warning(
            'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error, oops, report and warning
def error (self,s):
    self.errors += 1
    self.importCommands.errors += 1
    if g.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict ['actualErrorMessage'] = s
        g.app.unitTestDict ['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.trace(g.callers())
            g.es_print('',s,color='red')
    else:
        g.es_print('error:',s,color='red')

def oops (self):
    g.pr('baseScannerClass oops: %s must be overridden in subclass' % g.callers())

def report (self,message):
    if self.strict: self.error(message)
    else:           self.warning(message)

def warning (self,s):
    if not g.unitTesting:
        g.es_print('warning:',s,color='red')
#@-node:ekr.20070703122141.78:error, oops, report and warning
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20071201072917:adjustDefStart
def adjustDefStart (self,unused_s,i):

    '''A hook to allow the Python importer to adjust the 
    start of a class or function to include decorators.'''

    return i
#@-node:ekr.20071201072917:adjustDefStart
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,unused_s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,junk = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Init the parser status ivars.
    self.methodsSeen = False

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.appendStringToBody(parent,s[start:])

    # Do any language-specific post-processing.
    self.endGen(s)
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    # g.trace(g.callers())
    # g.trace('i',i,g.get_line(s,i))
    assert kind in ('class','outer')
    start = i ; putRef = False ; bodyIndent = None
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i)
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            # Bug fix: 2007/11/8: do *not* set start: we are just skipping the block.
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,bodyIndent
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level <= 0:
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    self.error('no block')
    if 1:
        g.pr('** no block **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    start = i

    # Skip the opening delim.
    if g.match(s,i,self.blockCommentDelim1):
        delim2 = self.blockCommentDelim2
        i += len(self.blockCommentDelim1)
    elif g.match(s,i,self.blockCommentDelim1_2):
        i += len(self.blockCommentDelim1_2)
        delim2 = self.blockCommentDelim2_2
    else:
        assert False

    # Find the closing delim.
    k = s.find(delim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(delim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.

    The decls *must* end in a newline.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    if trace: g.trace(g.callers())
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsFunction(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            if self.outerBlockEndsDecls:
                break
            else:
                i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None:
        i = g.find_line_start(s,prefix) # i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@-node:ekr.20070707080042:skipDecls
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasClasses and self.startsHelper(s,i,kind='class',tags=self.classTags)
    return val

def startsFunction (self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasFunctions and self.startsHelper(s,i,kind='function',tags=self.functionTags)
    return val
#@+node:ekr.20070711134534:getSigId
def getSigId (self,ids):

    '''Return the signature's id.

    By default, this is the last id in the ids list.'''

    return ids and ids[-1]
#@-node:ekr.20070711134534:getSigId
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i,kind):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    # if not tags: return False

    trace = False or self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    if kind == 'class' and self.sigId in self.anonymousClasses:
        # A hack for Delphi Pascal: interfaces have no id's.
        # g.trace('anonymous',self.sigId)
        classId = theId
        sigId = ''
    else:
        i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
        sigId = self.getSigId(ids)
        if not sigId:
            if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
            return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if kind == 'class' and self.sigId in self.anonymousClasses:
            pass # Allow weird Pascal unit's.
        elif not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Issue this warning only if we have a real class or function.
    if 0: # wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
#@-node:ekr.20070712112008:startsHelper
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1) or
        g.match(s,i,self.blockCommentDelim1_2)
    )
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Use @verbatim to escape section references
    if self.escapeSectionRefs: # 2009/12/27
        s = self.escapeFalseSectionReferences(s)

    # Check for intermixed blanks and tabs.
    if self.strict or self.atAutoWarnsAboutLeadingWhitespace:
        if not self.isRst:
            self.checkBlanksAndTabs(s)

    # Regularize leading whitespace for strict languages only.
    if self.strict: s = self.regularizeWhitespace(s) 

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20071110105107:checkBlanksAndTabs
def checkBlanksAndTabs(self,s):

    '''Check for intermixed blank & tabs.'''

    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0

    for line in g.splitLines(s):
        lws = line[0:g.skip_ws(line,0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')

    ok = blanks == 0 or tabs == 0

    if not ok:
        self.report('intermixed blanks and tabs')

    return ok
#@-node:ekr.20071110105107:checkBlanksAndTabs
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed:
        action = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
        message = 'inconsistent leading whitespace. %s' % action
        self.report(message)

    return ''.join(result)
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65:<< class baseScannerClass >>
#@+node:ekr.20090501095634.41:class rstScanner
class rstScanner (baseScannerClass):

    @others
#@+node:ekr.20090501095634.42: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='rest')

    # Scanner overrides
    self.blockDelim1 = self.blockDelim2 = None
    self.classTags = []
    self.escapeSectionRefs = False
    self.functionSpelling = 'section'
    self.functionTags = []
    self.hasClasses = False
    self.isRst = True
    self.lineCommentDelim = '..'
    self.outerBlockDelim1 = None
    self.sigFailTokens = []
    self.strict = False # Mismatches in leading whitespace are irrelevant.

    # Ivars unique to rst scanning & code generation.
    self.lastParent = None # The previous parent.
    self.lastSectionLevel = 0 # The section level of previous section.
    self.sectionLevel = 0 # The section level of the just-parsed section.
    self.underlineCh = '' # The underlining character of the last-parsed section.
    self.underlines = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~" # valid rst underlines.
    self.underlines1 = [] # Underlining characters for underlines.
    self.underlines2 = [] # Underlining characters for over/underlines.
#@-node:ekr.20090501095634.42: __init__
#@+node:ekr.20090512080015.5798:adjustParent
def adjustParent (self,parent,headline):

    '''Return the proper parent of the new node.'''

    trace = False and not g.unitTesting

    level,lastLevel = self.sectionLevel,self.lastSectionLevel
    lastParent = self.lastParent

    if trace: g.trace('**entry level: %s lastLevel: %s lastParent: %s' % (
        level,lastLevel,lastParent and lastParent.h or '<none>'))

    if self.lastParent:

        if level <= lastLevel:
            parent = lastParent.parent()
            while level < lastLevel:
                level += 1
                parent = parent.parent()
        else: # level > lastLevel.
            level -= 1
            parent = lastParent
            while level > lastLevel:
                level -= 1
                h2 = '@rst-no-head %s' % headline
                body = ''
                parent = self.createFunctionNode(h2,body,parent)

    else:
        assert self.root
        self.lastParent = self.root

    if not parent: parent = self.root

    if trace: g.trace('level %s lastLevel %s %s returns %s' % (
        level,lastLevel,headline,parent.h))

    #self.lastSectionLevel = self.sectionLevel
    self.lastParent = parent.copy()
    return parent.copy()
#@-node:ekr.20090512080015.5798:adjustParent
#@+node:ekr.20090512080015.5797:computeSectionLevel
def computeSectionLevel (self,ch,kind):

    '''Return the section level of the underlining character ch.'''

    # Can't use g.choose here.
    if kind == 'over':
        assert ch in self.underlines2
        level = 0
    else:
        level = 1 + self.underlines1.index(ch)

    if False:
        g.trace('level: %s kind: %s ch: %s under2: %s under1: %s' % (
            level,kind,ch,self.underlines2,self.underlines1))

    return level
#@-node:ekr.20090512080015.5797:computeSectionLevel
#@+node:ekr.20090512153903.5810:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = '@rst-no-head %s declarations' % self.methodName
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20090512153903.5810:createDeclsNode
#@+node:ekr.20090502071837.2:endGen
def endGen (self,s):

    '''Remember the underlining characters in the root's uA.'''

    p = self.root
    if p:
        tag = 'rst-import'
        d = p.v.u.get(tag,{})
        underlines1 = ''.join([str(z) for z in self.underlines1])
        underlines2 = ''.join([str(z) for z in self.underlines2])
        d ['underlines1'] = underlines1
        d ['underlines2'] = underlines2
        self.underlines1 = underlines1
        self.underlines2 = underlines2
        # g.trace(repr(underlines1),repr(underlines2))
        p.v.u [tag] = d

    # Append a warning to the root node.
    warningLines = (
        'Warning: this node is ignored when writing this file.',
        'However, @ @rst-options are recognized in this node.',
    )
    lines = ['.. %s' % (z) for z in warningLines]
    warning = '\n%s\n' % '\n'.join(lines)
    self.root.b = self.root.b + warning
#@-node:ekr.20090502071837.2:endGen
#@+node:ekr.20090501095634.46:isUnderLine
def isUnderLine(self,s):

    '''Return True if s consists of only rST underline characters.'''

    if not s: return False

    for ch in s:
        if ch not in self.underlines:
            return False

    return True
#@-node:ekr.20090501095634.46:isUnderLine
#@+node:ekr.20090501095634.50:startsComment/ID/String
# These do not affect parsing.

def startsComment (self,s,i):
    return False

def startsID (self,s,i):
    return False

def startsString (self,s,i):
    return False
#@-node:ekr.20090501095634.50:startsComment/ID/String
#@+node:ekr.20090501095634.45:startsHelper
def startsHelper(self,s,i,kind,tags):

    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = False and not g.unitTesting
    verbose = False
    kind,name,next,ch = self.startsSection(s,i)
    if kind == 'plain': return False

    self.underlineCh = ch
    self.lastSectionLevel = self.sectionLevel
    self.sectionLevel = self.computeSectionLevel(ch,kind)
    self.sigStart = g.find_line_start(s,i)
    self.sigEnd = next
    self.sigId = name
    i = next + 1

    if trace: g.trace('sigId',self.sigId,'next',next)

    while i < len(s):
        progress = i
        i,j = g.getLine(s,i)
        kind,name,next,ch = self.startsSection(s,i)
        if trace and verbose: g.trace(kind,repr(s[i:j]))
        if kind in ('over','under'):
            break
        else:
            i = j
        assert i > progress

    self.codeEnd = i

    if trace:
        if verbose:
            g.trace('found...\n%s' % s[self.sigStart:self.codeEnd])
        else:
            g.trace('level %s %s' % (self.sectionLevel,self.sigId))
    return True
#@-node:ekr.20090501095634.45:startsHelper
#@+node:ekr.20090501095634.47:startsSection
def startsSection (self,s,i):

    '''Scan a line and possible one or two other lines,
    looking for an underlined or overlined/underlined name.

    Return (kind,name,i):
        kind: in ('under','over','plain')
        name: the name of the underlined or overlined line.
        i: the following character if kind is not 'plain'
        ch: the underlining and possibly overlining character.
    '''

    trace = False and not g.unitTesting
    i1,j = g.getLine(s,i)
    # 2009/12/27: sections can not begin with whitespace.

    ### line = s[i1:j].strip() #
    line = s[i1:j]
    nows = i1 == g.skip_ws(s,i1)
    line = line.strip()
    ch,kind = '','plain' # defaults.

    if nows and self.isUnderLine(line): # an overline.
        name_i = g.skip_line(s,i1)
        name_i,name_j = g.getLine(s,name_i)
        name = s[name_i:name_j].strip()
        next_i = g.skip_line(s,name_i)
        i,j = g.getLine(s,next_i)
        # line2 = s[i:j].strip() #
        line2 = s[i:j]
        nows = i == g.skip_ws(s,i)
        line2 = line2.strip()
        n1,n2,n3 = len(line),len(name),len(line2)
        ch1,ch3 = line[0],line2 and line2[0]
        ok = (nows and self.isUnderLine(line2) and
            n1 >= n2 and n2 > 0 and n3 >= n2 and ch1 == ch3)
        if ok:
            i += n3
            # Eliminate the need for the "little fib" in writeBody.
            if i < len(s) and s[i] == '\n': i += 1
            ch,kind = ch1,'over'
            if ch1 not in self.underlines2:
                self.underlines2.append(ch1)
                # if trace: g.trace('underlines2',self.underlines2,name)
            if trace: g.trace('\nline  %s\nname  %s\nline2 %s' % (
                repr(line),repr(name),repr(line2)))
    else:
        name = line.strip()
        i = g.skip_line(s,i1)
        i,j = g.getLine(s,i)
        # line2 = s[i:j].strip() #
        line2 = s[i:j]
        nows2 = i == g.skip_ws(s,i)
        line2 = line2.strip()
        n1,n2 = len(name),len(line2)
        # look ahead two lines.
        i3,j3 = g.getLine(s,j)
        name2 = s[i3:j3].strip()
        i4,j4 = g.getLine(s,j3)
        # line4 = s[i4:j4].strip() #
        line4 = s[i4:j4]
        nows4 = i4 == g.skip_ws(s,i4)
        line4 = line4.strip()
        n3,n4 = len(name2),len(line4)
        overline = (
            nows2 and self.isUnderLine(line2) and
            nows4 and self.isUnderLine(line4) and
            n3 > 0 and n2 >= n3 and n4 >= n3)
        ok = (not overline and nows2 and self.isUnderLine(line2) and
            n1 > 0 and n2 >= n1)
        if ok:
            i += n2
            # Eliminate the need for the "little fib" in writeBody.
            if i < len(s) and s[i] == '\n': i += 1
            ch,kind = line2[0],'under'
            if ch not in self.underlines1:
                self.underlines1.append(ch)
                # if trace: g.trace('underlines1',self.underlines1,name)
            if trace: g.trace('\nname  %s\nline2 %s' % (
                repr(name),repr(line2)))
    return kind,name,i,ch
#@-node:ekr.20090501095634.47:startsSection
#@-node:ekr.20090501095634.41:class rstScanner
#@-node:ekr.20091219132601.6279:Reading
#@+node:ekr.20091219132601.6354:Writing
#@+node:ekr.20041005105605.147:writeAll (atFile)
def writeAll(self,
    writeAtFileNodesFlag=False,
    writeDirtyAtFileNodesFlag=False,
    toString=False
):

    """Write @file nodes in all or part of the outline"""

    trace = False and not g.unitTesting
    at = self ; c = at.c
    if trace: scanAtPathDirectivesCount = c.scanAtPathDirectivesCount
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False ; atOk = True
    force = writeAtFileNodesFlag

    if writeAtFileNodesFlag:
        # The Write @<file> Nodes command.
        # Write all nodes in the selected tree.
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    atOk = True
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    if trace: g.trace('%s calls to c.scanAtPathDirectives()' % (
        c.scanAtPathDirectivesCount-scanAtPathDirectivesCount))
    return mustAutoSave,atOk
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree():
    v2.clearOrphan()
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
    pathChanged = False
else:
    oldPath = at.getPathUa(p)
    newPath = at.fullPath(p)
    # if trace: g.trace('p %s\noldPath %s\nnewPath %s' % (
        # p.h,repr(oldPath),repr(newPath)))
    pathChanged = oldPath and oldPath != newPath
    if pathChanged:
        at.setPathUa(p,newPath) # Remember that we have changed paths.
        g.es_print('path changed for',p.h,color='blue')

if p.v.isDirty() or pathChanged or writeAtFileNodesFlag or p.v in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p,toString=toString,force=force)
        writtenFiles.append(p.v) # No need for autosave
    elif p.isAtEditNode():
        at.writeOneAtEditNode(p,toString=toString)
        writtenFiles.append(p.v) # No need for autosave
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,kind='@nosent',nosentinels=True,toString=toString)
        writtenFiles.append(p.v) # No need for autosave
    elif p.isAtShadowFileNode():
        at.writeOneAtShadowNode(p,toString=toString,force=force or pathChanged)
        writtenFiles.append(p.v) ; autoSave = True # 2008/7/29
    elif p.isAtThinFileNode():
        at.write(p,kind='@thin',thinFile=True,toString=toString)
        writtenFiles.append(p.v) # No need for autosave.
    elif p.isAtFileNode():
        if g.convert_at_file:
            at.write(p,kind='@file',thinFile=True,toString=toString)
            writtenFiles.append(p.v)
            autoSave = True # Clears root.v.tnodeList, so we must save.
        else:
            at.write(p,kind='@file',thinFile=False,toString=toString)
            writtenFiles.append(p.v)
            autoSave = True # Updates root.v.tnodeList, so we must save.

    if at.errors: atOk = False

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @<file> nodes in the selected tree")
    else:
        g.es("no dirty @<file> nodes")
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll (atFile)
#@+node:ekr.20041005105605.144:write & helper (atFile)
def write (self,root,
    kind = '@unknown', # Should not happen.
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
):
    """Write a 4.x derived file.
    root is the position of an @<file> node"""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    if hasattr(root.v,'tnodeList'):
        has_list,old_list = True,root.v.tnodeList[:]
    else:
        has_list,old_list = False,[]

    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString)

    # "look ahead" computation of eventual fileName.
    eventualFileName = c.os_path_finalize_join(
        at.default_directory,at.targetFileName)
    exists = g.os_path_exists(eventualFileName)
    # g.trace('eventualFileName',eventualFileName,
        # 'at.targetFileName',at.targetFileName)

    if not scriptWrite and not toString:
        if nosentinels:
            if not self.shouldWriteAtNosentNode(root,exists):
                return
        elif not hasattr(root.v,'at_read') and exists:
            # Prompt if writing a new @file or @thin node would
            # overwrite an existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind)
            if ok:
                root.v.at_read = True # Create the attribute for all clones.
            else:
                g.es("not written:",eventualFileName)
                return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        assert root==at.root
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            root.v.tnodeList = []
            root.v._p_changed = True
        else:
            at.closeWriteFile()
            if at.errors > 0 or root.isOrphan():
                << set dirty and orphan bits >>
                g.es("not written:",at.outputFileName)
            else:
                at.replaceTargetFileIfDifferent(root)
                    # Sets/clears dirty and orphan bits.
            if has_list:
                if at.errors == 0 and g.convert_at_file:
                    # Clear the tnodeList in the root.
                    # Future writes will write thin-like sentinels.
                    # This will also clear the tnodeList attributes in
                    # <v> elements when the .leo file is written later.
                    root.v.tnodeList = []
                    root.v._p_changed = True
                else:
                    root.v.tnodeList = old_list

    except Exception:
        if toString:
            at.exception("exception preprocessing script")
            root.v.tnodeList = []
            root.v._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
            if has_list: root.v.tnodeList = old_list
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
    if not at.targetFileName:
        # We have an @file node.
        at.targetFileName = root.atFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits >>
# Setting the orphan and dirty flags tells Leo to write the tree..
root.setOrphan()
root.setDirty()
# Delete the temp file.
self.remove(at.outputFileName) 

#@-node:ekr.20041005105605.146:<< set dirty and orphan bits >>
#@+node:ekr.20080620095343.1:shouldWriteAtNosentNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.That ' s too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the.leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtNosentNode (self,p,exists):

    '''Return True if we should write the @auto node at p.'''

    if not exists: # We can write a non-existent file without danger.
        return True
    elif self.isSignificantTree(p):
        return True # Assume the tree contains what should be written.
    else:
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='blue')
        return False
#@-node:ekr.20080620095343.1:shouldWriteAtNosentNode
#@-node:ekr.20041005105605.144:write & helper (atFile)
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers (atFile)
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName and not toString: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # Prompt if writing a new @auto node would overwrite an existing file.
    if (not toString and not hasattr(p.v,'at_auto_read') and
        g.os_path_exists(fileName)
    ):
        ok = self.promptForDangerousWrite(fileName,kind='@auto')
        if ok:
            p.v.at_auto_read = True # Create the attribute
        else:
            g.es("not written:",fileName)
            return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        if root.isAtAutoRstNode():
            ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
            if not ok2: at.errors += 1
        else:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        if at.errors == 0:
            at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",at.outputFileName)
            root.setDirty() # New in Leo 4.4.8.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("not written:",at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers (atFile)
#@+node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
#@nonl
#@+node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.initWrite(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.

    # Do the overrides.
    self.outputFile = outputFile
    self.outputFileName = fileName

    # Set underlining characters.
    d = self.tnodeOptionDict.get(p.v) # Set by preprocessTree.
    underlines = d.get('underline_characters')
    if underlines:
        self.atAutoWriteUnderlines = underlines
    else:
        d = p.v.u.get('rst-import',{})
        underlines2 = d.get('underlines2')
        if not underlines2: underlines2 = '#'
        underlines1 = d.get('underlines1')
        if not underlines1: underlines1 = '=+*^~"\'`-:><_'
            # The standard defaults.
        if len(underlines2) > 1:
            underlines2 = underlines2[0]
            g.trace('too many top-level underlines, using %s' % (
                underlines2),color='blue')
        self.atAutoWriteUnderlines = underlines2 + underlines1
        self.underlines1 = underlines1
        self.underlines2 = underlines2
#@+node:ekr.20090702084917.6033:@test initAtAutoWrite
if g.unitTesting:

    c,p = g.getTestVars()

    rst = c.rstCommands
    rst.initAtAutoWrite(p,fileName='<test file>',outputFile=None)

    # Ensure we are actually testing the default logic.
    d = p.v.u.get('rst-import',{})
    underlines = d.get('underline_characters')
    assert underlines is None,underlines
    assert d == {},d
    # Now test the logic.
    assert rst.underlines2 == '#',rst.underlines2
    assert rst.underlines1 == '=+*^~"\'`-:><_',rst.underlines1
    assert rst.atAutoWriteUnderlines == '#=+*^~"\'`-:><_',\
        rst.atAutoWriteUnderlines
#@-node:ekr.20090702084917.6033:@test initAtAutoWrite
#@-node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
#@+node:ekr.20091228080620.6499:isSafeWrite
def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite:
        return False # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
#@-node:ekr.20091228080620.6499:isSafeWrite
#@-node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
#@+node:ekr.20090502071837.58:write methods (leoRst)
#@+node:ekr.20090502071837.68:getDocPart
def getDocPart (self,lines,n):

    # g.trace('n',n,repr(''.join(lines)))

    result = []
    << Append whatever follows @doc or @space to result >>
    while n < len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
#@nonl
#@+node:ekr.20090502071837.69:<< Append whatever follows @doc or @space to result >>
if n > 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
#@-node:ekr.20090502071837.69:<< Append whatever follows @doc or @space to result >>
#@-node:ekr.20090502071837.68:getDocPart
#@+node:ekr.20090502071837.72:handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
#@+node:ekr.20090502071837.73:formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
#@nonl
#@-node:ekr.20090502071837.73:formatCodeModeLine
#@+node:ekr.20090502071837.74:rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
#@-node:ekr.20090502071837.74:rstripList
#@+node:ekr.20090502071837.75:finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
#@nonl
#@-node:ekr.20090502071837.75:finishCodePart
#@-node:ekr.20090502071837.72:handleCodeMode & helper
#@+node:ekr.20090502071837.76:handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
#@nonl
#@-node:ekr.20090502071837.76:handleDocOnlyMode
#@+node:ekr.20090502071837.81:handleSpecialDocParts
def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
#@-node:ekr.20090502071837.81:handleSpecialDocParts
#@+node:ekr.20090502071837.77:isAnyDocPart
def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
#@nonl
#@-node:ekr.20090502071837.77:isAnyDocPart
#@+node:ekr.20090502071837.79:isAnySpecialDocPart
def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
#@-node:ekr.20090502071837.79:isAnySpecialDocPart
#@+node:ekr.20090502071837.78:isSpecialDocPart
def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) > 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result
#@nonl
#@-node:ekr.20090502071837.78:isSpecialDocPart
#@+node:ekr.20090502071837.80:removeLeoDirectives
def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
#@nonl
#@-node:ekr.20090502071837.80:removeLeoDirectives
#@+node:ekr.20090502071837.82:replaceCodeBlockDirectives
def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
#@nonl
#@-node:ekr.20090502071837.82:replaceCodeBlockDirectives
#@+node:ekr.20090502071837.70:skip_literal_block
def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n < len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 <= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
#@nonl
#@-node:ekr.20090502071837.70:skip_literal_block
#@+node:ekr.20090502071837.94:write (leoRst)
def write (self,s):

    if self.trialWrite:
        pass
    else:
        s = self.encode(s)

    # g.trace(repr(s),g.callers(2))

    self.outputFile.write(s)
#@-node:ekr.20090502071837.94:write (leoRst)
#@+node:ekr.20090502071837.71:writeBody
def writeBody (self,p):

    # g.trace(p.h,p.b)

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
#@-node:ekr.20090502071837.71:writeBody
#@+node:ekr.20090502071837.83:writeHeadline & helper
def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             =  self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.writeHeadlineHelper(p)
#@nonl
#@+node:ekr.20090502071837.84:writeHeadlineHelper
def writeHeadlineHelper (self,p):

    h = p.h
    if not self.atAutoWrite:
        h = h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in (
            self.getOption('option_prefix'),
            self.getOption('options_prefix'),
            self.getOption('ignore_headline_prefix'), # Bug fix: 2009-5-13
            self.getOption('ignore_headlines_prefix'),  # Bug fix: 2009-5-13
        ):
            return
        # Remove all other headline commands from the headline.
        for prefix in self.headlineCommands:
            if word == prefix:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write(self.underline(h,p)) # Used by @auto-rst.
        else:
            self.write('\n%s\n\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
#@nonl
#@-node:ekr.20090502071837.84:writeHeadlineHelper
#@-node:ekr.20090502071837.83:writeHeadline & helper
#@+node:ekr.20090502071837.85:writeNode (rst)
def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
#@-node:ekr.20090502071837.85:writeNode (rst)
#@+node:ekr.20090502071837.86:writePreformat
def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''

    # g.trace(p.h,g.callers())

    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')

    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
#@-node:ekr.20090502071837.86:writePreformat
#@+node:ekr.20090502071837.87:writeTree
def writeTree(self,p):

    '''Write p's tree to self.outputFile.'''

    self.scanAllOptions(p)

    # g.trace(self.getOption('generate_rst_header_comment'))

    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % self.outputFileName))

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p) # Side effect: advances p.
#@-node:ekr.20090502071837.87:writeTree
#@-node:ekr.20090502071837.58:write methods (leoRst)
#@-node:ekr.20091219132601.6354:Writing
#@+node:ekr.20091227115606.6467:Comparison
#@+node:ekr.20031218072017.3195:splitLines & joinLines
def splitLines (s):

    '''Split s into lines, preserving the number of lines and
    the endings of all lines, including the last line.'''

    # g.stat()

    if s:
        return s.splitlines(True) # This is a Python string function!
    else:
        return []

splitlines = splitLines

def joinLines (aList):

    return ''.join(aList)

joinlines = joinLines
#@-node:ekr.20031218072017.3195:splitLines & joinLines
#@+node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        if self.isRst: # Errors writing file at present...
            outputFile = StringIO()
            c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
            s1,s2 = self.file_s,outputFile.getvalue()
        else:
            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True)
            s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)

    if self.isRst:
        lines1 = self.adjustRstLines(lines1)
        lines2 = self.adjustRstLines(lines2)

    n1,n2 = len(lines1), len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@-node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
#@+node:ekr.20070730093735:compareHelper & helpers
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    trace = False and not g.unitTesting

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i >= len(lines1):
        ### if self.isRst:
        ###    return True # ignore extra lines.
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif self.isRst and self.compareRstUnderlines(line1,line2):
        return True
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    # if trace:
        # g.es_print('original line: ',line1)
        # g.es_print('generated line:',line2)
        # return True # continue checking.

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
#@+node:ekr.20091227115606.6468:adjustRstLines
def adjustRstLines(self,lines):

    '''Ignore newlines.

    This fudge allows the rst code generators to insert needed newlines freely.'''

    return [z for z in lines if z.strip(' \t') != '\n']
#@-node:ekr.20091227115606.6468:adjustRstLines
#@+node:ekr.20090513073632.5735:compareRstUnderlines
def compareRstUnderlines(self,s1,s2):

    s1,s2 = s1.rstrip(),s2.rstrip()
    if s1 == s2:
        return True # Don't worry about trailing whitespace.

    n1, n2 = len(s1),len(s2)
    ch1 = n1 and s1[0] or ''
    ch2 = n2 and s2[0] or ''

    val = (
        n1 >= 2 and n2 >= 2 and # Underlinings must be at least 2 long.
        ch1 == ch2 and # The underlining characters must match.
        s1 == ch1 * n1 and # The line must consist only of underlining characters.
        s2 == ch2 * n2)

    return val
#@-node:ekr.20090513073632.5735:compareRstUnderlines
#@-node:ekr.20070730093735:compareHelper & helpers
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    trace = True and not g.unitTesting
    verbose = True

    kind = g.choose(self.atAuto,'@auto','import command')

    x2 = max(0,min(bad_i,len(lines2)-1))
    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d\n%s' % (
            kind,self.root.h,bad_i,repr(lines2[x2])))

    # maxlines = 300
    if trace: # or len(lines1) < maxlines:
        aList = []
        if True: # intermix lines.
            n1,n2 = len(lines1),len(lines2)
            # for i in range(min(maxlines,max(n1,n2))):
            for i in range(max(0,bad_i-2),min(bad_i+3,max(n1,n2))):
                if i < n1: line1 = repr(lines1[i])
                else:      line1 = '<eof>'
                if i < n2: line2 = repr(lines2[i])
                else:      line2 = '<eof>'
                if verbose or line1 != line2:
                    aList.append('%3d %s' % (i,line1))
                    aList.append('%3d %s' % (i,line2))
        else:
            aList.append('input...')
            for i in range(len(lines1)):
                aList.append('%3d %s' % (i,repr(lines1[i])))
            aList.append('output...')
            for i in range(len(lines2)):
                aList.append('%3d %s' % (i,repr(lines2[i])))

        if g.unitTesting:
            assert '\n'.join(aList)
        else:
            g.es_print('\n'.join(aList),color='blue')

    return False
#@+node:ekr.20090517020744.5785:@test reportMismatch
if g.unitTesting:

    import leo.core.leoImport as leoImport
    c,p = g.getTestVars()

    ic = c.importCommands
    scanner = leoImport.rstScanner(importCommands=ic,atAuto=True)
    scanner.root = p
    s1 = ["abc",]
    s2 = ["xyz",]

    scanner.reportMismatch(s1,s2,1)

    # Why is leoSettings.leo scanned twice in dynamicUnitTest.leo?
#@-node:ekr.20090517020744.5785:@test reportMismatch
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20091227115606.6467:Comparison
#@+node:ekr.20091228080620.6498:Warn about dangerous writes
#@+node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
#@nonl
#@+node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.initWrite(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.

    # Do the overrides.
    self.outputFile = outputFile
    self.outputFileName = fileName

    # Set underlining characters.
    d = self.tnodeOptionDict.get(p.v) # Set by preprocessTree.
    underlines = d.get('underline_characters')
    if underlines:
        self.atAutoWriteUnderlines = underlines
    else:
        d = p.v.u.get('rst-import',{})
        underlines2 = d.get('underlines2')
        if not underlines2: underlines2 = '#'
        underlines1 = d.get('underlines1')
        if not underlines1: underlines1 = '=+*^~"\'`-:><_'
            # The standard defaults.
        if len(underlines2) > 1:
            underlines2 = underlines2[0]
            g.trace('too many top-level underlines, using %s' % (
                underlines2),color='blue')
        self.atAutoWriteUnderlines = underlines2 + underlines1
        self.underlines1 = underlines1
        self.underlines2 = underlines2
#@+node:ekr.20090702084917.6033:@test initAtAutoWrite
if g.unitTesting:

    c,p = g.getTestVars()

    rst = c.rstCommands
    rst.initAtAutoWrite(p,fileName='<test file>',outputFile=None)

    # Ensure we are actually testing the default logic.
    d = p.v.u.get('rst-import',{})
    underlines = d.get('underline_characters')
    assert underlines is None,underlines
    assert d == {},d
    # Now test the logic.
    assert rst.underlines2 == '#',rst.underlines2
    assert rst.underlines1 == '=+*^~"\'`-:><_',rst.underlines1
    assert rst.atAutoWriteUnderlines == '#=+*^~"\'`-:><_',\
        rst.atAutoWriteUnderlines
#@-node:ekr.20090702084917.6033:@test initAtAutoWrite
#@-node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
#@+node:ekr.20091228080620.6499:isSafeWrite
def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite:
        return False # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
#@-node:ekr.20091228080620.6499:isSafeWrite
#@-node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
#@-node:ekr.20091228080620.6498:Warn about dangerous writes
#@-node:ekr.20091221094815.6386:at-auto-rst problems
#@-node:ekr.20091221123255.6375:Fixed
#@-node:ekr.20091221094815.6383:Urgent (voted up) bugs to fix
#@+node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:bwmulder.20050101094804:openForWrite (atFile)
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
#@-node:bwmulder.20050101094804:openForWrite (atFile)
#@+node:ekr.20090103070824.11:c.checkFileTimeStamp
def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    trace = False and not g.unitTesting
    c = self

    # Don't assume the file still exists.
    if not g.os_path_exists(fn):
        if trace: g.trace('file no longer exists',fn)
        return True

    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        if trace: g.trace('no time stamp',fn)
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        if trace: g.trace('time stamps match',fn,timeStamp)
        return True

    if g.app.unitTesting:
        return False

    if trace:
        g.trace('mismatch',timeStamp,timeStamp2)

    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090103070824.11:c.checkFileTimeStamp
#@-node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:ekr.20090812165611.5973:Fixed registerHandler bug
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/8616f4e171e1a24b

On Aug 10, 12:25 pm, tfer <tfethers...@aol.com> wrote:
> Well from vim.py:
> When properly installed, this plugin does the following:
>
> 1. - Double clicking on a node's icon opens that node in VIM. You can
> open nodes in VIM with
>         a single-click if you set useDoubleClick = False.

I tried setting "useDoubleClick = False" under the vim plugin node in
leoPluginsRef.leo work. It doesn't seem to work. I get the message:

exception loading plugin
Traceback (most recent call last):

 File "C:\Program Files\Leo-4-6-2-final\leo\core\leoPlugins.py", line
437, in loadOnePlugin
   init_result = result.init()

 File "C:\Program Files\Leo-4-6-2-final\leo\plugins\vim.py", line
232, in init
   leoPlugins.registerHandler(event,open_in_vim,val=True)

TypeError: registerHandler() got an unexpected keyword argument 'val'

The variable val doesn't get modified in the "open_in_vim
(tag,keywords,val=None)" function.
- Show quoted text -
#@nonl
#@-node:ekr.20090812165611.5973:Fixed registerHandler bug
#@+node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
# at_read attribute in the tnode, not the vnode.
#@nonl
#@+node:ekr.20090712050729.6017:promptForDangerousWrite
def promptForDangerousWrite (self,fileName,kind):

    c = self.c

    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForDangerousWrite')
        return val in (None,True)

    # g.trace(timeStamp, timeStamp2)
    message = '%s %s\n%s\n%s' % (
        kind, fileName,
        g.tr('already exists.'),
        g.tr('Overwrite this file?'))

    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite existing file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090712050729.6017:promptForDangerousWrite
#@-node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
#@+node:ekr.20090804091109.5985:Fixed double prompt in c.close()
#@+node:ekr.20091109103928.6372:Notes
@nocolor

This bug happens only on Linux.
#@nonl
#@-node:ekr.20091109103928.6372:Notes
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    # g.trace('frame',frame,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c) # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocus()
        frame.c.outerUpdate()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@-node:ekr.20090804091109.5985:Fixed double prompt in c.close()
#@+node:ekr.20090817080059.5995:Select main chapter initially
It can be alarming to select a small chapter in a large outline.
#@nonl
#@-node:ekr.20090817080059.5995:Select main chapter initially
#@+node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/33e87adbff5d69d9

Latest trunk.  qt gui

I used multiple body editors (2) for the first time in a long time and the
scroll position was moving at times that it shouldn't.

For example if I scrolled partially down the page and copied some text and then
pasted the text somewhere else that was visible without scrolling, the scroll
position would change significantly although the new text would remain visible.

It may not sound particularly serious but I found it very difficult to use.

The fix was to leoQtGui.updateEditors.
#@nonl
#@-node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
#@+node:ekr.20090822060128.6035:Improved the install docs
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/add6242d6f4fc476

From Matt Wilkie

I've installed Leo several times on windows, yet this morning still
took me a few minutes to find the section you reference above because
there are at least two other document sections with phrases similar to
"installing leo". Anyway, this is my simplified recipe for a virgin
install:

-------------------------
Installing Leo On Windows
-------------------------
//skip any step not needed//

1. Install Python - There are many sources, but from
http://www.python.org/download/releases/ is good

2. Install PyQt - acquire and run Binary Package from
http://www.riverbankcomputing.co.uk/software/pyqt/download which
matches installed Python version (so for python 2.5 scan for the
"Py2.5" in filename)

3. Install Leo
   - Head to http://sourceforge.net/projects/leo/ and slap [Download Now]
   - Unpack python *site-packages* folder, e.g.
C:\Python25\Lib\site-packages\leo-4-6-2-final

   - [optional] Generate/update a junction link from unpacked
leo-4-6-2-final to ...\site-packages\leo

      cd C:\Python25\Lib\site-packages\
      junction leo leo-4-6-2-final

   - Create windows shortcut (edit paths as necessary):

      Target   =  C:\Python25\pythonw.exe
"C:\Python25\Lib\site-packages\leo\launchLeo.py" --gui=qt
      Start in =  D:\code

   - Associate .leo filetype batch file:

      ftype LeoFile=C:\Python25\pythonw.exe
"C:\Python25\Lib\site-packages\leo\launchLeo.py" "--gui=qt" "%1"
      assoc .leo=LeoFile

   - [optional] Put this leo.bat in %PATH%:

      @C:\Python25\python.exe -i
"C:\Python25\Lib\site-packages\leo\launchLeo.py" --gui=qt %*

-------------------------

Further reading / Sources used:

   Junction links -
http://technet.microsoft.com/en-gb/sysinternals/bb896768.aspx,
http://groups.google.com/group/leo-editor/msg/30116f9193241dc4
   FTYPE - http://ss64.com/nt/ftype.html
   ASSOC - http://ss64.com/nt/assoc.html


=====================
Ville's comments

On Thu, Aug 20, 2009 at 10:49 PM, Matt Wilkie<map...@gmail.com> wrote:
> 3. Install Leo
>   - Head to http://sourceforge.net/projects/leo/ and slap [Download Now]
>   - Unpack python *site-packages* folder, e.g.
> C:\Python25\Lib\site-packages\leo-4-6-2-final

I don't think you need to use site-packages. Just extract it anywhere
you want (e.g. c:/opt/leo). But I could be wrong.

>   - Associate .leo filetype batch file:
>n
>      ftype LeoFile=C:\Python25\pythonw.exe
> "C:\Python25\Lib\site-packages\leo\launchLeo.py" "--gui=qt" "%1"
>      assoc .leo=LeoFile

--gui=qt us not needed anymore. 
#@nonl
#@-node:ekr.20090822060128.6035:Improved the install docs
#@+node:ekr.20090829175108.6133:Marked @<file> nodes dirty if nodes change during read.
#@+node:ekr.20041005105605.21:read (atFile) & helper
def read(self,root,
    importFileName=None,thinFile=False,
    fromString=None,atShadow=False,
    force=False
):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName and isAtFile >>
    if isAtFile:
        # The @file node has file-like sentinels iff a tnodeList exists.
        thinFile = not (hasattr(root.v,'tnodeList') and root.v.tnodeList)
    doCache = g.enableDB and (thinFile or atShadow) and not force
    at.initReadIvars(root,fileName,
        importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root, fileContent)

    # Remember that we have read this file.
    root.v.at_read = True # Create the attribute for all clones.

    if doCache and cachefile in c.db:
        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        aList = c.db[cachefile]
        root.v.createOutlineFromCacheList(c,aList)
        at.inputFile.close()
        root.clearDirty()
        return

    # Delete all children, but **not** for @file and @nosent nodes!
    # (We do delete all children for @file nodes with thin-like sentinels.)
    if thinFile or atShadow:
        root.v.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if not g.unitTesting:
        g.es("reading:",root.h)

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName and isAtFile >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False

isAtFile = (
    not thinFile and
    not importFileName and
    not atShadow and
    not fromString and
    root.h.startswith('@file'))
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName and isAtFile >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
resurrected = 0
for p in root.self_and_subtree():
    if p.v.isVisited():
        pass
        # g.trace('visited',p.v,p.h)
    else:
        g.trace('**** not visited',p.v,p.h)
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for v in c.all_unique_nodes():

    if hasattr(v,"tempBodyString"):
        delattr(v,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile) & helper
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    try:
        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(p, fileContent)
    except IOError:
        cachefile = None

    # Remember that we have read this file.
    p.v.at_auto_read = True # Create the attribute

    if cachefile is not None and cachefile in c.db:        
        # g.es('uncache:',p.h)
        aList = c.db[cachefile]
        p.v.createOutlineFromCacheList(c,aList)
        return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        # c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        self.writeCachedTree(p, cachefile)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20040311113514:p.clearDirty
def clearDirty (self):

    p = self
    p.v.clearDirty()
#@-node:ekr.20040311113514:p.clearDirty
#@+node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):

    p = self
    return p.v.findAllPotentiallyDirtyNodes()
#@-node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
#@+node:ekr.20040702104823:p.inAtIgnoreRange
def inAtIgnoreRange (self):

    """Returns True if position p or one of p's parents is an @ignore node."""

    p = self

    for p in p.self_and_parents():
        if p.isAtIgnoreNode():
            return True

    return False
#@-node:ekr.20040702104823:p.inAtIgnoreRange
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    trace = False and not g.unitTesting
    verbose = False
    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()

    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.setDirty()

    if trace: g.trace("position",dirtyVnodeList,g.callers(5))

    return dirtyVnodeList
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):

    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []

    # g.trace(p.h,g.callers(4))

    if not p.v.isDirty():
        p.v.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)

    return dirtyVnodeList
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20090830051712.6151: v.Dirty bits
#@+node:ekr.20031218072017.3390:v.clearDirty
def clearDirty (self):
    v = self
    v.statusBits &= ~ v.dirtyBit

#@-node:ekr.20031218072017.3390:v.clearDirty
#@+node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):

    trace = False and not g.unitTesting
    v = self ; c = v.context

    # Set the starting nodes.
    nodes = []
    newNodes = [v]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]

    # Remove the hidden vnode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root',c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)

    if trace: g.trace(nodes)
    return nodes
#@nonl
#@-node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes
#@+node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty
# Unlike p.setAllAncestorAtFileNodesDirty,
# there is no setDescendentsDirty arg.

def setAllAncestorAtFileNodesDirty (self):

    trace = False and not g.unitTesting
    verbose = False
    v = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = v.findAllPotentiallyDirtyNodes()

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]

    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.setDirty() # Do not call v.setDirty here!

    if trace: g.trace("vnode",dirtyVnodeList)

    return dirtyVnodeList
#@-node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty
#@+node:ekr.20080429053831.12:v.setDirty
def setDirty (self):

    self.statusBits |= self.dirtyBit
#@-node:ekr.20080429053831.12:v.setDirty
#@-node:ekr.20090830051712.6151: v.Dirty bits
#@+node:ekr.20090829064400.6040:v.createOutlineFromCacheList & helpers
def createOutlineFromCacheList(self,c,aList):
    """ Create outline structure from recursive aList
    built by p.makeCacheList.

    Clones will be automatically created by gnx,
    but *not* for the top-level node.
    """

    parent_v = self

    #import pprint ; pprint.pprint(tree)
    parent_v = self
    h,b,gnx,children = aList
    if h is not None:
        v = parent_v
        v._headString = h    
        v._bodyString = b

    for z in children:
        h,b,gnx,grandChildren = z
        isClone,child_v = parent_v.fastAddLastChild(c,gnx)
        if isClone:
            if child_v.b != b: # or child_v.h
                # Bug fix: the last seen clone rules.
                child_v.h = h
                child_v.b = b
                # Bug fix: mark @<file> nodes dirty.
                child_v.setAllAncestorAtFileNodesDirty()
                child_v.setMarked()
                g.es("changed:",child_v.h,color="blue")
        else:
            child_v.createOutlineFromCacheList(c,z)
#@+node:ekr.20090829064400.6042:v.fastAddLastChild
# Similar to createThinChild4
def fastAddLastChild(self,c,gnxString):
    '''Create new vnode as last child of the receiver.

    If the gnx exists already, create a clone instead of new vnode.
    '''

    trace = False and not g.unitTesting
    parent_v = self
    indices = g.app.nodeIndices
    gnxDict = c.fileCommands.gnxDict

    if gnxString is None: v = None
    else:                 v = gnxDict.get(gnxString)
    is_clone = v is not None

    if trace: g.trace(
        'clone','%-5s' % (is_clone),
        'parent_v',parent_v,'gnx',gnxString,'v',repr(v))

    if not is_clone:
        v = vnode(context=c)
        if gnxString:
            gnx = indices.scanGnx(gnxString,0)
            v.fileIndex = gnx
        gnxDict[gnxString] = v

    child_v = v
    child_v._linkAsNthChild(parent_v,parent_v.numberOfChildren())
    child_v.setVisited() # Supress warning/deletion of unvisited nodes.

    return is_clone,child_v
#@-node:ekr.20090829064400.6042:v.fastAddLastChild
#@-node:ekr.20090829064400.6040:v.createOutlineFromCacheList & helpers
#@-node:ekr.20090829175108.6133:Marked @<file> nodes dirty if nodes change during read.
#@+node:ekr.20090901175503.6096:Fixed bug in g.adjustTripleString
#@+node:ekr.20050211120242.2:g.removeExtraLws & test
def removeExtraLws (s,tab_width):

    '''Remove extra indentation from one or more lines.

    Warning: used by getScript.  This is *not* the same as g.adjustTripleString.'''

    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w = g.computeWidth(lws,tab_width)
            break
    else: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            g.pr(repr(line))

    return result
#@+node:ekr.20090517020744.5881:@test g.removeExtraLws
if g.unitTesting:

    c,p = g.getTestVars()

    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@-node:ekr.20090517020744.5881:@test g.removeExtraLws
#@-node:ekr.20050211120242.2:g.removeExtraLws & test
#@+node:ekr.20051014175117:g.adjustTripleString
def adjustTripleString (s,tab_width):

    '''Remove leading indentation from a triple-quoted string.

    This works around the fact that Leo nodes can't represent underindented strings.
    '''

    # Compute the minimum leading whitespace of all non-blank lines.
    trace = True and not g.unitTesting
    lines = g.splitLines(s)
    w = 0 ; val = -1
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w2 = g.computeWidth(lws,tab_width)
            # The sign of w does not matter.
            if w == 0 or abs(w2) < w:
                w = abs(w2)

    if w == 0: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    return result
#@+node:ekr.20090901175503.6098:@test g.adjustTripleString
if g.unitTesting:

    c,p = g.getTestVars()

    s = '''\
    a
      b

c
    d'''

    s2 = 'a\n  b\n\nc\nd'

    result = g.adjustTripleString(s,c.tab_width)
    assert result == s2,repr(result)


#@-node:ekr.20090901175503.6098:@test g.adjustTripleString
#@-node:ekr.20051014175117:g.adjustTripleString
#@+node:ekr.20031218072017.3202:removeLeadingWhitespace
# Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0 ; first_ws = abs(first_ws)
    for ch in s:
        if ws >= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j > 0:
        s = s[j:]
    return s
#@-node:ekr.20031218072017.3202:removeLeadingWhitespace
#@-node:ekr.20090901175503.6096:Fixed bug in g.adjustTripleString
#@+node:ekr.20090907140408.6123:Fixed startup reversion when .leoID.txt does not exist
#@+node:ekr.20041113113140:loadOnePlugin & test
def loadOnePlugin (moduleOrFileName,tag='open0',verbose=False):

    trace = False # and not g.unitTesting

    global loadedModules,loadingModuleNameStack

    # Prevent Leo from crashing if .leoID.txt does not exist.
    if g.app.config is None:
        print ('No g.app.config, making stub...')
        class StubConfig(g.nullObject):
            pass
        g.app.config = StubConfig()

    # Fixed reversion: do this after possibly creating stub config class.
    verbose = False or verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if trace or verbose:
            g.trace('plugin',moduleName,'already loaded',color="blue")
        return module

    assert g.app.loadDir

    plugins_path = g.os_path_finalize_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path,pluginName=moduleName,verbose=True)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)

        if tag == 'unit-test-load':
            pass # Keep the result, but do no more.
        elif hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                # g.trace('result',result,'init_result',init_result)
                if init_result:
                    loadedModules[moduleName] = result
                    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es_print('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.

            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                g.trace('no init()',moduleName)
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.app.batchMode or g.app.inBridge: # or g.unitTesting
        pass
    elif result:
        if trace or verbose:
            g.trace('loaded plugin:',moduleName,color="blue")
    else:
        if trace or warn_on_failure or (verbose and not g.app.initing):
            if trace or tag == 'open0':
                g.trace('can not load enabled plugin:',moduleName,color="red")

    return result
#@+node:ekr.20090522161156.5886:@test class StubConfig
if g.unitTesting:

    c,p = g.getTestVars()

    class StubConfig(g.nullObject):
        pass

    x = StubConfig()
    assert not x.getBool(c,'mySetting')
    assert not x.enabledPluginsFileName
#@-node:ekr.20090522161156.5886:@test class StubConfig
#@-node:ekr.20041113113140:loadOnePlugin & test
#@-node:ekr.20090907140408.6123:Fixed startup reversion when .leoID.txt does not exist
#@+node:ekr.20090930103947.6085:Fixed elisp bug
> Here is the fix:
> 'startsFunction' in 'elispScanner' should use
>    j = self.skipId(s,i)
> instead of
>    j = g.skip_id(s,i)
> skip_id doesn't take extraIdChars ('-' in elisp case) into
> consideration. 
#@nonl
#@+node:ekr.20070711060113:class elispScanner
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,unused_s,unused_i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.startSigIndent = self.getLeadingIndent(s,i)
    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False

    end = self.skipBlock(s,i)
    # g.trace('%3s %15s block: %s' % (i,repr(s[i:i+10]),repr(s[i:end])))
    if not g.match(s,end-1,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len('defun')
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = self.skipId(s,i) # Bug fix: 2009/09/30
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner
#@-node:ekr.20090930103947.6085:Fixed elisp bug
#@+node:ekr.20090930151626.6086:Made add-comments and delete-comments commands work with shortcuts
@language python

ab
#@nonl
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self,event=None):

    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('no text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',d3+' '

    # Comment out non-blank lines.
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            result.append(line[0:i]+openDelim+line[i:]+closeDelim)
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self,event=None):

    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('no text selected',color='blue')
        return

    if d1:
        # Remove the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in range(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es('',"'%s'" % (d2),"not found",color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es('',"'%s'" % (d3),"not found",color='blue')
                    return

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',
            repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        << handle special cases for plain keys >>

    << handle per-pane bindings >>

    if traceGC: g.printNewObjects('masterKey 5')

    return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.

if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function',k.state.kind) # k.state.handler)
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20080510153327.4:<< handle special cases for plain keys >>
#g.trace('plain key','state',k.unboundKeyAction,'stroke',stroke)

# Important: only keys bound somewhere have a stroke.
# All unbound plain keys will be handled by handleUnboundKeys.

if k.unboundKeyAction in ('insert','overwrite'):

    for key in (k.unboundKeyAction,'body','log','text','all'):
        # Ignore bindings for all plain keys in insert/overwrite mode *except* auto-complete.
        d = k.masterBindingsDict.get(key,{})
        if d:
            b = d.get(stroke)
            if b and b.commandName == 'auto-complete':
                if trace: g.trace('%s: auto-complete key in %s mode' % (stroke,k.unboundKeyAction))
                k.masterCommand(event,b.func,b.stroke,b.commandName)
                return 'break'

    if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
    k.masterCommand(event,func=None,stroke=stroke,commandName=None)
    return 'break'

# Bound   plain keys in command mode are by the per-pane logic.
# Unbound plain keys in command mode are ignored by handleUnboundKeys.

# This code ignores all command-state keys if we are not in a text widget.
elif k.unboundKeyAction == 'command':
    if not g.app.gui.isTextWidget(w):
        c.onCanvasKey(event)
        return 'break'
#@nonl
#@-node:ekr.20080510153327.4:<< handle special cases for plain keys >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
keyStatesTuple = ('command','insert','overwrite')

if True and trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
    'isTextWidget(w)',g.app.gui.isTextWidget(w))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None),
    ('all',None),
):
    if (
        # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        if trace:
            g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
            # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif keysym.find('Escape') != -1:
        # Never insert escape characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20061031131434.102:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c ; d = c.commandsDict

    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'keyboard-quit': g.trace(key,bunchList)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@-node:ekr.20061031131434.102:makeBindingsFromCommandsDict
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: g.trace(pane,shortcut,commandName)
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print ('redefining shortcut %30s from %s to %s in %s' % (
            shortcut,
            g.choose(pane=='button',z,commandName),
            g.choose(pane=='button',commandName,z),
            pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return

    trace = False
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        # Bug fix: 2009/09/30: use canonical stroke.
        accelerator = k.shortcutFromSetting(accel,addKey=False) or ''
        stroke = k.shortcutFromSetting(accel,addKey=True) or ''
        if accelerator:
            accelerator = g.stripBrackets(k.prettyPrintKey(accelerator))
        if trace: # and commandName == 'add-comments':
            g.trace(bunch.val,repr(stroke),repr(accelerator),commandName)
        def masterMenuCallback (c=c,k=k,stroke=stroke,command=command,commandName=commandName,event=None):
            # if trace: g.trace('stroke',stroke)
            return k.masterMenuHandler(stroke,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>

        # c.add_command ensures that c.outerUpdate is called.
        if menu:
            c.add_command(menu,label=realLabel,
                accelerator=accelerator,
                command=masterMenuCallback,
                underline=amp_index)
#@+node:ekr.20051021091958:<< get label & command or continue >>
if g.isString(data):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            if trace: g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            if trace: g.trace('2','%20s' % (bunch.val),commandName)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val
                    if trace: g.trace('3','%20s' % (bunch.val),commandName)
                    break
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
def shortcutFromSetting (self,setting,addKey=True):

    k = self

    trace = False and not g.unitTesting
    if not setting:return None

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    if trace: g.trace('%20s %s' % (setting,shortcut))
    return shortcut

canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting = shortcutFromSetting
#@+node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
meta  = s2.find("meta") >= 0
#@-node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
#@+node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
#@-node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
#@+node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@-node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
#@+node:ekr.20061031131434.188:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", s)
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
#@-node:ekr.20061031131434.188:<< compute the last field >>
#@+node:ekr.20061031131434.189:<< compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
#@-node:ekr.20061031131434.189:<< compute shortcut >>
#@-node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
#@-node:ekr.20090930151626.6086:Made add-comments and delete-comments commands work with shortcuts
#@+node:ekr.20091003171114.6465:Fixed contractOrGoRight
@nocolor-node

The culprit was the sparse_goto_parent option.
It never worked properly, and it caused the expansion
state of nodes as seen by Leo to get out-of-synch
with the expansion state as seen by the qt tree code.

To exercise the bug, do the following in test.leo:

- Expand the "prototypes" node.
- Expand any child node.
- Move beyond the now-expanded child node.
- Hit Alt-Left.  This will select the prototype node.
  The expanded child node will be marked by Leo as being contracted,
  but it *wont* be contracted actually, which confuses moveToVisNext.
#@nonl
#@+node:ekr.20031218072017.2996:selectVisNext
def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisNext(): return

    p.moveToVisNext(c)
    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2996:selectVisNext
#@+node:ekr.20031218072017.2995:selectVisBack
# This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisBack(): return

    p.moveToVisBack(c)

    # g.trace(p.h)
    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2995:selectVisBack
#@+node:ekr.20031218072017.2920:goToParent
def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.p

    # g.trace(p.parent())

    c.treeSelectHelper(p and p.parent())
#@-node:ekr.20031218072017.2920:goToParent
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    trace = False and not g.unitTesting
    c = self ; p = c.p
    redraw = False ; fullRedraw = False
    if p.hasChildren() and p.isExpanded():
        if trace: g.trace('contract',p.h)
        c.contractNode()
        redraw = True # New in one-node world.
    elif p.hasParent() and p.parent().isVisible(c):
        redraw = False
        p.contract() # Make sure we know this node is contracted.
        # This "feature" is dubious.
        # To work properly, it requires a full redraw.
        if False: # self.sparse_goto_parent:
            for child in p.self_and_siblings():
                if child != p and child.isExpanded():
                    child.contract()
                    redraw = True ; fullRedraw = True
        if trace: g.trace('goto parent',p.h)
        c.goToParent()

    if redraw:
        if fullRedraw or p.isCloned():
            if trace: g.trace('full redraw',p.h)
            c.redraw()
        else:
            c.redraw_after_contract(p=p,setFocus=True)
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    trace = False and not g.unitTesting
    c = self ; p = c.p

    # New code.
    if p.hasChildren():
        if p.isExpanded():
            p.moveToFirstChild()
            if trace: g.trace('select',p.h)
            c.selectPosition(p)
        else:
            if trace: g.trace('expand',p.h)
            c.expandNode() # Calls redraw_after_expand.
    elif p.hasNext():
        c.goToNextSibling()
    else:
        while p.hasParent():
            p.moveToParent()
            if p.hasNext():
                p.moveToNext()
                break
        c.selectPosition(p)
    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode() # Calls redraw_after_expand.
        else:
            c.redraw_after_expand(p.firstChild(),setFocus=True)
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20031218072017.2901:contractNode
def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.p

    p.contract()

    if p.isCloned():
        c.redraw() # A full redraw is necessary to handle clones.
    else:
        c.redraw_after_contract(p=p,setFocus=True)
#@-node:ekr.20031218072017.2901:contractNode
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    trace = False and not g.unitTesting
    c = self ; p = c.p

    p.expand()

    if p.isCloned():
        if trace: g.trace('***redraw')
        c.redraw() # Bug fix: 2009/10/03.
    else:
        c.redraw_after_expand(p,setFocus=True)

#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20070226113916: treeSelectHelper
def treeSelectHelper (self,p):

    c = self

    if not p: p = c.p

    if p:
        # Do not call expandAllAncestors here.
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeFocusHelper()
#@-node:ekr.20070226113916: treeSelectHelper
#@+node:ekr.20080416161551.210:p.moveToVisBack
def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    trace = False and not g.unitTesting
    verbose = True
    p = self ; limit,limitIsVisible = c.visLimit()
    if trace and verbose:
        g.trace(p,'limit',limit,'limitIsVisible',limitIsVisible)
    if trace: g.trace('***entry','parent',p.parent(),'p',p,g.callers(5))
    while p:
        # Short-circuit if possible.
        back = p.back()
        if trace: g.trace(
            'back',back,'hasChildren',bool(back and back.hasChildren()),
            'isExpanded',bool(back and back.isExpanded()))

        if back and back.hasChildren() and back.isExpanded():
            p.moveToThreadBack()
        elif back:
            p.moveToBack()
        else:
            p.moveToParent() # Same as p.moveToThreadBack()
        # if back and (not back.hasChildren() or not back.isExpanded()):
            # p.moveToBack()
        # else:
            # p.moveToThreadBack()
        if trace: g.trace(p.parent(),p)
        if p:
            if trace and verbose: g.trace('**p',p)
            done,val = self.checkVisBackLimit(limit,limitIsVisible,p)
            if done:
                if trace and verbose: g.trace('done',p)
                return val
            if p.isVisible(c):
                if trace and verbose: g.trace('isVisible',p)
                return p
    else:
        # assert not p.
        return p
#@+node:ekr.20090715145956.6166:checkVisBackLimit
def checkVisBackLimit (self,limit,limitIsVisible,p):

    '''Return done, return-val'''

    trace = True and not g.unitTesting
    c = p.v.context

    if limit:
        if limit == p:
            if trace: g.trace('at limit',p)
            if limitIsVisible and p.isVisible(c):
                return True,p
            else:
                return True,None
            #return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
        elif limit.isAncestorOf(p):
            return False,None
        else:
            if trace: g.trace('outside limit tree',limit,p)
            return True,None
    else:
        return False,None
#@-node:ekr.20090715145956.6166:checkVisBackLimit
#@-node:ekr.20080416161551.210:p.moveToVisBack
#@+node:ekr.20080416161551.211:p.moveToVisNext
def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    trace = False and not g.unitTesting
    verbose = False
    p = self ; limit,limitIsVisible = c.visLimit()
    while p:
        if trace: g.trace('1',p.h)
        # if trace: g.trace('hasChildren %s, isExpanded %s %s' % (
            # p.hasChildren(),p.isExpanded(),p.h))
        # Short-circuit if possible.
        if p.hasNext() and p.hasChildren() and p.isExpanded():
            p.moveToFirstChild()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if trace: g.trace('2',p.h)
        if p:
            done,val = self.checkVisNextLimit(limit,p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        return p
#@+node:ekr.20090715145956.6167:checkVisNextLimit
def checkVisNextLimit (self,limit,p):

    '''Return done, return-val'''

    trace = False and not g.unitTesting

    if limit:
        # Unlike moveToVisBack, being at the limit does not terminate.
        if limit == p:
            return False, None
        elif limit.isAncestorOf(p):
            return False,None
        else:
            if trace: g.trace('outside limit tree')
            return True,None
    else:
        return False,None
#@-node:ekr.20090715145956.6167:checkVisNextLimit
#@-node:ekr.20080416161551.211:p.moveToVisNext
#@-node:ekr.20091003171114.6465:Fixed contractOrGoRight
#@+node:ekr.20091007105735.6462:Fixed bug: @nosent should warn about orphan nodes
#@+node:ekr.20041005105605.154:asisWrite
def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        # Note: @asis always writes all nodes,
        # so there can be no orphan or ignored nodes.
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            # openFileForWriting calls root.setDirty() if there are errors.
            return
        for p in root.self_and_subtree():
            << Write p's headline if it starts with @@ >>
            << Write p's body >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
    except Exception:
        at.writeException(root) # Sets dirty and orphan bits.

silentWrite = asisWrite # Compatibility with old scripts.
#@+node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
s = p.h

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) > 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)
#@-node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
#@+node:ekr.20041005105605.156:<< Write p's body >>
s = p.b

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
#@-node:ekr.20041005105605.156:<< Write p's body >>
#@-node:ekr.20041005105605.154:asisWrite
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,
    nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v._bodyString)

    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
    if not toString:
        at.warnAboutOrphandAndIgnoredNodes()
#@-node:ekr.20041005105605.157:writeOpenFile
#@-node:ekr.20091007105735.6462:Fixed bug: @nosent should warn about orphan nodes
#@+node:ekr.20091016055503.6059:Color sections references in @root trees
#@+node:ekr.20090214075058.9:g.get_directives_dict (must be fast)
# The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

g_noweb_root = re.compile('<'+'<'+'*'+'>'+'>'+'=',re.MULTILINE)

def get_directives_dict(p,root=None):

    """Scan p for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    trace = False and not g.unitTesting

    if root: root_node = root[0]
    d = {}

    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat,re.MULTILINE)

    # The headline has higher precedence because it is more visible.
    for kind,s in (('body',p.h),('head',p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(0)[1:] # Omit the @
            i = m.start(0)
            if word.strip() not in d:
                j = i + 1 + len(word)
                k = g.skip_line(s,j)
                val = s[j:k].strip()
                if trace: g.trace(word,repr(val))
                d[word.strip()] = val

    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"]=0 # value not immportant
            else:
                g.es('%s= requires @root in the headline' % (
                    g.angleBrackets('*')))
            break

    if trace: g.trace('%4d' % (len(p.h) + len(p.b)),g.callers(5))
    return d
#@+node:ekr.20090214075058.10:compute_directives_re
def compute_directives_re ():

    '''Return an re pattern which will match all Leo directives.'''

    global globalDirectiveList

    aList = ['^@%s' % z for z in globalDirectiveList
                if z != 'others']

    # @others can have leading whitespace.
    aList.append(r'^\s@others')

    return '|'.join(aList)
#@-node:ekr.20090214075058.10:compute_directives_re
#@-node:ekr.20090214075058.9:g.get_directives_dict (must be fast)
#@+node:ekr.20031218072017.1385:g.findReference
# Called from the syntax coloring method that colorizes section references.

def findReference(c,name,root):

    '''Find the section definition for name.

    If a search of the descendants fails,
    and an ancestor is an @root node,
    search all the descendants of the @root node.
    '''

    for p in root.subtree():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # New in Leo 4.7: expand the search for @root trees.
    for p in root.self_and_parents():
        d = g.get_directives_dict(p)
        if 'root' in d:
            for p2 in p.subtree():
                if p2.matchHeadline(name) and not p2.isAtIgnoreNode():
                    return p2

    # g.trace("not found:",name,root)
    return c.nullPosition()
#@-node:ekr.20031218072017.1385:g.findReference
#@-node:ekr.20091016055503.6059:Color sections references in @root trees
#@+node:ekr.20091103082258.6084:Fixed bug: Sometimes 'redefining shortcut' message is backwards
#@+node:ekr.20061031131434.131:k.registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)

    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('redefining',commandName, color='red')

    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    if trace: g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName,g.callers(4))
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@-node:ekr.20061031131434.131:k.registerCommand
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: g.trace(pane,shortcut,commandName)
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print ('redefining shortcut %30s from %s to %s in %s' % (
            shortcut,
            g.choose(pane=='button',z,commandName),
            g.choose(pane=='button',commandName,z),
            pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@-node:ekr.20091103082258.6084:Fixed bug: Sometimes 'redefining shortcut' message is backwards
#@+node:ekr.20091201125021.6067:Fixed publish-argv-for-missing-stylesheets
# The parsing in writeToDocutils had to be rewritten.
#@nonl
#@+node:ekr.20090502071837.65:writeToDocutils (sets argv) & helper
def writeToDocutils (self,s):

    '''Send s to docutils using the writer implied by self.ext and return the result.'''

    trace = True and not g.unitTesting
    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }

    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()

    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.es_print('unknown docutils extension: %s' % (self.ext),color='red')
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if self.getOption('stylesheet_embed') == False:
        rel_path = g.os_path_join(
            rel_stylesheet_path,self.getOption('stylesheet_name'))
        overrides['stylesheet'] = rel_path
        overrides['stylesheet_path'] = None
        overrides['embed_stylesheet'] = None
    elif g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.es_print('stylesheet not found: %s' % (path),color='red')
    else:
        g.es_print('stylesheet not found\n',path,color='red')
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        if trace: g.trace('overrides',overrides)
        result = None # Ensure that result is defined.
        result = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError as error:
        # g.es_print('Docutils error (%s):' % (
            # error.__class__.__name__),color='red')
        g.es_print('Docutils error:',color='red')
        g.es_print(error,color='blue')
    except Exception:
        g.es_print('Unexpected docutils exception')
        g.es_exception()
    return result
#@+node:ekr.20090502071837.66:handleMissingStyleSheetArgs
def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    force = False
    if force:
        # See http://docutils.sourceforge.net/docs/user/config.html#documentclass
        return {'documentclass':'report', 'documentoptions':'english,12pt,lettersize'}

    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return {}

    # Handle argument lists such as this:
    # --language=en,--documentclass=report,--documentoptions=[english,12pt,lettersize]
    d = {}
    while s:
        s = s.strip()
        if not s.startswith('--'): break
        s = s[2:].strip()
        eq = s.find('=')
        cm = s.find(',')
        if eq == -1 or (-1 < cm < eq): # key[nl] or key,
            val = ''
            cm = s.find(',')
            if cm == -1:
                key = s.strip()
                s = ''
            else:
                key = s[:cm].strip()
                s = s[cm+1:].strip()
        else: # key = val
            key = s[:eq].strip()
            s = s[eq+1:].strip()
            if s.startswith('['): # [...]
                rb = s.find(']')
                if rb == -1: break # Bad argument.
                val = s[:rb+1]
                s = s[rb+1:].strip()
                if s.startswith(','):
                    s = s[1:].strip()
            else: # val[nl] or val,
                cm = s.find(',')
                if cm == -1:
                    val = s
                    s = ''
                else:
                    val = s[:cm].strip()
                    s = s[cm+1:].strip()

        # g.trace('key',repr(key),'val',repr(val),'s',repr(s))
        if not key: break
        if not val.strip(): val = '1'
        d[str(key)] = str(val)

    return d
#@nonl
#@-node:ekr.20090502071837.66:handleMissingStyleSheetArgs
#@-node:ekr.20090502071837.65:writeToDocutils (sets argv) & helper
#@-node:ekr.20091201125021.6067:Fixed publish-argv-for-missing-stylesheets
#@+node:ekr.20091217190731.6075:Recover from bad chars in .leo files
#@+node:ekr.20090525144314.6526:cleanSaxInputString & test
def cleanSaxInputString(self,s):

    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
#@+node:ekr.20090525144314.6527:@test cleanSaxInputString
if g.unitTesting:

    c,p = g.getTestVars()

    s = 'test%cthis' % 27

    assert c.fileCommands.cleanSaxInputString(s) == 'test this'
#@-node:ekr.20090525144314.6527:@test cleanSaxInputString
#@-node:ekr.20090525144314.6526:cleanSaxInputString & test
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                pass
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20091217190731.6075:Recover from bad chars in .leo files
#@-node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090817080059.5996:Features
#@+node:ekr.20090815073537.5991:Added options to vim plugin
@nocolor-node

The setting::

    @string vim_trigger_event = icondclick2

is the default.  It opens vim when the user double-clicks the icon box.

Alternatives are::

    @string vim_trigger_event = iconclick2
    @string vim_trigger_event = select2

The former opens vim on single clicks in the icon bar.
The latter opens vim whenever a new node is selected in Leo.
#@nonl
#@-node:ekr.20090815073537.5991:Added options to vim plugin
#@+node:ekr.20090822054806.6002:Merged clean-sys-path branch
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b868abd65fb57759

I noted that leo adds all of its directories to sys.path. This is
considered "bad form" and can cause nasty surprises. I believe this is
an artifact of the old "leo-as-package" work; now that leo-as-package
stuff works well, I don't think this is needed anymore.

It's not a lot of work to fix either - it's just a matter of removing
the call to adjustSysPath in runLeo.py, and fixing some plugins. (yes,
I tried it). e.g. quicksearch.py needed this trivial change:

+++ leo/plugins/quicksearch.py  2009-08-15 20:22:20 +0000

-import qt_quicksearch
+from leo.plugins import qt_quicksearch 

What I did:

- disabled adjustSysPath.
- g.importModule now imports from 'extensions' and 'external' directories as needed.
- Modified two plugins to import from leo.plugins.
- Added __init__.py to 'extensions' folder.
#@nonl
#@-node:ekr.20090822054806.6002:Merged clean-sys-path branch
#@+node:ekr.20091007104807.6469:Added support for --version and --help
Actually, --help was supported already.
#@nonl
#@-node:ekr.20091007104807.6469:Added support for --version and --help
#@+node:ekr.20091005145253.6057:Convert @file nodes so they use file-like sentinels
@nocolor-node

Leo will now automatically write @file nodes as if they were @thin nodes
(thin-like sentinels). Leo will read @file correctly regardless of whether the
corresponding external file has file-like (legacy) or thin-like (recommended)
sentinels. Once thin-like sentinels are written, Leo deletes the problematic
tnodeList attribute in the .leo file.

**Important**: The conversion to thin-like sentinels happens *only* if Leo
actually writes the @file node, and that happens only if the @file node or one
of its descendants changes. As usual with @file nodes, writing any @file node
forces Leo to write the .leo file. This is necessary so that the tnodeList
attribute in the .leo file remains up- to-date. Thus, the conversion process
should be as safe as using @file nodes ever was, which is to say, *usually* safe
but subject to problems in a cooperative environment.

In short, I recommend that you use Shift-Ctrl-W (write-at-files-nodes)
to force the conversion of all your legacy @file nodes.  Please back
up your .leo file and all your external files first.
#@nonl
#@-node:ekr.20091005145253.6057:Convert @file nodes so they use file-like sentinels
#@+node:ekr.20091007105735.6463:Made show-fonts work with qt gui
#@-node:ekr.20091007105735.6463:Made show-fonts work with qt gui
#@+node:ekr.20091103082258.6085:Removed 'end of script' message
#@+node:ekr.20031218072017.2140:c.executeScript & helpers
def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # g.pr('*** script',script)
            try:
                p = c.p
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if args:
                    # g.trace('setting sys.argv',args)
                    sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                exec(script,d)
                if 0: # This message switches panes, and can be disruptive.
                    if not script1 and not silent:
                        # Careful: the script may have changed the log tab.
                        tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                        g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143:redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@-node:ekr.20031218072017.2143:redirectScriptOutput
#@+node:EKR.20040627100424:unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@-node:EKR.20040627100424:unredirectScriptOutput
#@+node:ekr.20070115135502:writeScriptFile
def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.homeLeoDir,'scriptFile.py')                    

    # Write the file.
    try:
        f = open(path,'w')
        f.write(script)
        f.close()
    except Exception:
        g.es("Failed to write script to %s" % path)
        g.es("Check your configuration of script_file_path, currently %s" % c.config.getString('script_file_path'))
        path = None

    return path
#@nonl
#@-node:ekr.20070115135502:writeScriptFile
#@-node:ekr.20031218072017.2140:c.executeScript & helpers
#@-node:ekr.20091103082258.6085:Removed 'end of script' message
#@-node:ekr.20090817080059.5996:Features
#@+node:ekr.20091007104807.6470:Code
#@+node:ekr.20091001141621.6042:iters -> generators & code cleanup
@nocolor-node
@

What I did:

- Removed t from leoGui.leo.
- Removed t from scripts.leo.
- Renamed xTnodeY to xVnodeY in a few places.
- Removed putDescendantTnodeUas: it was redundant.
- Revised scripting chapter.

Will not do:

- Remove t from leoPlugins.leo.
  This could cause problems that I am not willing to solve.
- v.tnodeList will not change in this branch.
  This must be done in a separate branch as part of the deprecation of @file.



#@+node:ekr.20091003023754.6105:Not used
#@+node:ekr.20091001141621.6067:c.Old iterators
if not g.new_generators:

    @others
#@nonl
#@+node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
def allNodes_iter (self,copy=False):

    r = self.rootPosition()
    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p
    return r.iter_class(r, cp)

all_positions_iter = allNodes_iter
#@nonl
#@-node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
#@+node:EKR.20040529091232.1:c.all_tnodes_iter
def all_tnodes_iter (self):

    return self.rootPosition().tnodes_iter()
#@-node:EKR.20040529091232.1:c.all_tnodes_iter
#@+node:EKR.20040529091232.2:c.all_unique_tnodes_iter
def all_unique_tnodes_iter (self):

    return self.rootPosition().unique_tnodes_iter()
#@-node:EKR.20040529091232.2:c.all_unique_tnodes_iter
#@+node:EKR.20040529091232.3:c.all_vnodes_iter
def all_vnodes_iter (self):
    return self.rootPosition().vnodes_iter()
#@-node:EKR.20040529091232.3:c.all_vnodes_iter
#@+node:EKR.20040529091232.4:c.all_unique_vnodes_iter
def all_unique_vnodes_iter (self):

    return self.rootPosition().unique_vnodes_iter()
#@-node:EKR.20040529091232.4:c.all_unique_vnodes_iter
#@+node:sps.20080317144948.3:c.all_positions_with_unique_tnodes_iter
def all_positions_with_unique_tnodes_iter (self):

    r = self.rootPosition()
    return r.unique_iter_class(r, lambda p: p)
#@-node:sps.20080317144948.3:c.all_positions_with_unique_tnodes_iter
#@+node:sps.20080327174748.4:c.all_positions_with_unique_vnodes_iter
def all_positions_with_unique_vnodes_iter (self):

    r = self.rootPosition()
    return r.unique_iter_class(r, lambda p: p, lambda u: u.v)
#@-node:sps.20080327174748.4:c.all_positions_with_unique_vnodes_iter
#@-node:ekr.20091001141621.6067:c.Old iterators
#@+node:ekr.20091002072933.6096:p.Old iterators
if not g.new_generators:

    @others
#@+node:ekr.20040305172211.1:p.children_iter
class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):

    return self.children_iter_class(self,copy)
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:p.children_iter
#@+node:sps.20080331123552.3:p.iter
class iter_class:

    """Returns a list of mappings of positions in a subtree,
    possibly including the root of the subtree."""

    @others

def tnodes_iter (self):

    return self.iter_class(self, lambda p: p.v.t)

def vnodes_iter (self):

    return self.iter_class(self, lambda p: p.v)
#@+node:sps.20080331123552.1:__init__ & __iter__ (p.iter)
def __init__(self,p,mapping):

    # g.trace('p.tnodes_iter.__init','p',p)

    self.first = p.copy()
    self.p = None
    self.mapping = mapping

def __iter__(self):

    return self
#@-node:sps.20080331123552.1:__init__ & __iter__ (p.iter)
#@+node:sps.20080331123552.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None
    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.mapping(self.p)

    raise StopIteration

__next__ = next
#@nonl
#@-node:sps.20080331123552.2:next
#@-node:sps.20080331123552.3:p.iter
#@+node:ekr.20040305172855:p.parents_iter
class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)

def self_and_parents_iter(self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:p.parents_iter
#@+node:ekr.20040305173343:p.siblings_iter
class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):

    return self.siblings_iter_class(self,copy,following)

self_and_siblings_iter = siblings_iter

def following_siblings_iter (self,copy=False):

    return self.siblings_iter_class(self,copy,following=True)
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):

    # We always include p, even if following is True.

    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:p.siblings_iter
#@+node:ekr.20040305173559:p.subtree_iter
class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=False)

def self_and_subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:p.subtree_iter
#@+node:sps.20080331123552.12:p.subtree_unique_iter
class subtree_unique_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_with_unique_tnodes_iter (self,copy=False):

    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p

    return self.subtree_unique_iter_class(self,
        cp,
        lambda p: p.v.t,
        includeSelf=False)

def subtree_with_unique_vnodes_iter (self,copy=False):

    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p

    return self.subtree_unique_iter_class(self,
        cp,
        lambda p: p.v,
        includeSelf=False)
#@+node:sps.20080331123552.9:__init__ & __iter__
def __init__(self,p,mapping,unique,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.mapping = mapping
    self.unique = unique
    self.d = {}

def __iter__(self):

    return self
#@-node:sps.20080331123552.9:__init__ & __iter__
#@+node:sps.20080331123552.10:next
# moveToThreadNextUnique raises StopIteration
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.moveToThreadNextUnique()

    return self.mapping(self.p)

__next__ = next
#@nonl
#@-node:sps.20080331123552.10:next
#@+node:sps.20080331123552.11:moveToThreadNextUnique
def moveToThreadNextUnique (self):

    """Move a position to threadNext position."""

    p = self.p
    u = self.unique

    if p:
        # We've been visited
        self.d[u(p)]=True

        # First, try to find an unmarked child
        if p.v.t.children:
            p.moveToFirstChild()
            if p == self.after:
                raise StopIteration
            while p and self.d.get(u(p)):
                if p.hasNext():
                    p.moveToNext()
                else:
                    p.moveToParent()
                if p == self.after:
                    raise StopIteration

        # If we didn't find an unmarked child,
        # try to find an unmarked sibling
        if p and self.d.get(u(p)):
            while p.hasNext():
                p.moveToNext()
                if p == self.after:
                    raise StopIteration
                if not self.d.get(u(p)):
                    break

        # If we didn't find an unmarked sibling,
        # find a parent with an unmarked sibling
        if p and self.d.get(u(p)):
            p.moveToParent()
            # if p.equal(self.after):
            if p == self.after:
                raise StopIteration
            while p:
                while p.hasNext():
                    p.moveToNext()
                    if p == self.after:
                        raise StopIteration
                    if not self.d.get(u(p)):
                        break
                # if we run out of siblings, go to parent
                if self.d.get(u(p)):
                    p.moveToParent()
                    if p == self.after:
                        raise StopIteration
                else:
                    break # found
            # At this point, either (not p.d[p.v.t]) and found
            # or (not p) and we're finished

    return p 
#@-node:sps.20080331123552.11:moveToThreadNextUnique
#@-node:sps.20080331123552.12:p.subtree_unique_iter
#@+node:sps.20080331123552.8:p.unique_iter
class unique_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def unique_tnodes_iter (self):

    return self.unique_iter_class(self, lambda p: p.v.t)

def unique_vnodes_iter (self):

    return self.unique_iter_class(self, lambda p: p.v)
#@+node:sps.20080331123552.4:__init__ & __iter__ (p.unique_tnodes_iter)
def __init__(self,p,mapping,unique=lambda p: p.v.t):

    # g.trace('p.unique_tnodes_iter.__init','p',p,)

    self.d = {}
    self.first = p.copy()
    self.p = None
    self.mapping = mapping
    self.unique=unique

def __iter__(self):

    return self
#@-node:sps.20080331123552.4:__init__ & __iter__ (p.unique_tnodes_iter)
#@+node:sps.20080331123552.5:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.moveToThreadNextUnique()

    if self.p:
        return self.mapping(self.p)

    raise StopIteration

__next__ = next
#@-node:sps.20080331123552.5:next
#@+node:sps.20080331123552.7:moveToThreadNextUnique
def moveToThreadNextUnique (self):

    """Move a position to threadNext position."""

    p = self.p
    u = self.unique

    self_d_get = self.d.get
    if p:
        # We've been visited
        self.d[u(p)]=True

        # First, try to find an unmarked child
        if p.v.t.children:
            p.moveToFirstChild()
            while p and self_d_get(u(p)):
                if p.hasNext():
                    p.moveToNext()
                else:
                    p.moveToParent()

        # If we didn't find an unmarked child,
        # try to find an unmarked sibling
        if p and self_d_get(u(p)):
            while p.hasNext():
                p.moveToNext()
                if not self_d_get(u(p)):
                    break

        # If we didn't find an unmarked sibling,
        # find a parent with an unmarked sibling
        if p and self_d_get(u(p)):
            p.moveToParent()
            while p:
                while p.hasNext():
                    p.moveToNext()
                    if not self_d_get(u(p)):
                        break
                # if we run out of siblings, go to parent
                if self_d_get(u(p)):
                    p.moveToParent()
                else:
                    break # found
            # At this point, either (not p.d[p.v.t]) and found
            # or (not p) and we're finished

    return p 
#@-node:sps.20080331123552.7:moveToThreadNextUnique
#@-node:sps.20080331123552.8:p.unique_iter
#@-node:ekr.20091002072933.6096:p.Old iterators
#@+node:ekr.20031218072017.2009:newVnode (fileCommands) (not used)
def newVnode(self,index):

    c = self.c

    v = leoNodes.vnode(context=c)

    if index in self.tnodesDict:
        g.es("bad tnode index:",str(index),"using empty text.")
        return v
    else:
        # Create the tnode.
        # Use the _original_ index as the key in tnodesDict.
        self.tnodesDict[index] = v

        if not g.isString(index):
            g.es("newVnode: unexpected index type:",type(index),index,color="red")

        # Convert any pre-4.1 index to a gnx.
        junk,theTime,junk = gnx = g.app.nodeIndices.scanGnx(index,0)
        if theTime != None:
            v.fileIndex = gnx

        return v
#@-node:ekr.20031218072017.2009:newVnode (fileCommands) (not used)
#@-node:ekr.20091003023754.6105:Not used
#@+node:ekr.20091001141621.6061:c.generators
#@+node:ekr.20091001141621.6043:c.all_nodes & all_unique_nodes
def all_nodes(self):
    c = self
    for p in c.all_positions():
        yield p.v
    raise StopIteration

def all_unique_nodes(self):
    c = self
    for p in c.all_unique_positions():
        yield p.v
    raise StopIteration

# Compatibility with old code.
all_tnodes_iter = all_nodes
all_vnodes_iter = all_nodes
all_unique_tnodes_iter = all_unique_nodes
all_unique_vnodes_iter = all_unique_nodes
#@-node:ekr.20091001141621.6043:c.all_nodes & all_unique_nodes
#@+node:ekr.20091001141621.6062:c.all_unique_positions
def all_unique_positions(self):
    c = self
    p = c.rootPosition() # Make one copy.
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p
            p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
all_positions_with_unique_tnodes_iter = all_unique_positions
all_positions_with_unique_vnodes_iter = all_unique_positions
#@nonl
#@-node:ekr.20091001141621.6062:c.all_unique_positions
#@+node:ekr.20091001141621.6044:c.all_positions
def all_positions (self):
    c = self
    p = c.rootPosition() # Make one copy.
    while p:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
all_positions_iter = all_positions
allNodes_iter = all_positions
#@-node:ekr.20091001141621.6044:c.all_positions
#@-node:ekr.20091001141621.6061:c.generators
#@+node:ekr.20091001141621.6060:p.generators
#@+node:ekr.20091001141621.6055:p.children
def children(self):

    '''Return all children of p.'''

    p = self
    p = p.firstChild()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
children_iter = children
#@-node:ekr.20091001141621.6055:p.children
#@+node:ekr.20091002083910.6102:p.following_siblings
def following_siblings(self):
    '''
    Return all siblings that follow p, not including p.
    '''

    p = self
    p = p.copy() # Always include the original node.
    p = p.next()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
following_siblings_iter = following_siblings
#@-node:ekr.20091002083910.6102:p.following_siblings
#@+node:ekr.20091002083910.6104:p.nodes
def nodes (self):

    p = self
    p = p.copy()
    while p:
        yield p.v
        p.moveToThreadNext()

# Compatibility with old code.
tnodes_iter = nodes
vnodes_iter = nodes
#@-node:ekr.20091002083910.6104:p.nodes
#@+node:ekr.20091001141621.6058:p.parents
def parents(self):

    '''Return all parents of p.'''

    p = self
    p = p.parent()
    while p:
        yield p
        p.moveToParent()
    raise StopIteration

# Compatibility with old code.
parents_iter = parents
#@-node:ekr.20091001141621.6058:p.parents
#@+node:ekr.20091002083910.6099:p.self_and_parents
def self_and_parents(self):

    '''Return p and all parents of p.'''

    p = self
    p = p.copy()
    while p:
        yield p
        p.moveToParent()
    raise StopIteration

# Compatibility with old code.
self_and_parents_iter = self_and_parents
#@-node:ekr.20091002083910.6099:p.self_and_parents
#@+node:ekr.20091001141621.6057:p.self_and_siblings
def self_and_siblings(self):
    '''Return all siblings of p including p.
    '''

    p = self
    p = p.copy()
    while p.hasBack():
        p.moveToBack()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
self_and_siblings_iter = self_and_siblings
#@nonl
#@-node:ekr.20091001141621.6057:p.self_and_siblings
#@+node:ekr.20091001141621.6066:p.self_and_subtree
def self_and_subtree(self):

    '''Return p's entire subtree, including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
self_and_subtree_iter = self_and_subtree
#@-node:ekr.20091001141621.6066:p.self_and_subtree
#@+node:ekr.20091001141621.6056:p.subtree
def subtree(self):

    '''Return all descendants of p, not including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
subtree_iter = subtree
#@-node:ekr.20091001141621.6056:p.subtree
#@+node:ekr.20091002083910.6105:p.unique_nodes
def unique_nodes (self):

    p = self
    p = p.copy()
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p.v
            p.moveToThreadNext()

# Compatibility with old code.
unique_tnodes_iter = unique_nodes
unique_vnodes_iter = unique_nodes
#@-node:ekr.20091002083910.6105:p.unique_nodes
#@+node:ekr.20091002083910.6103:p.unique_subtree
def unique_subtree (self):
    '''Return unique positions in p's entire subtree, including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    seen = set()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p
            p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
subtree_with_unique_tnodes_iter = unique_subtree
subtree_with_unique_vnodes_iter = unique_subtree
#@-node:ekr.20091002083910.6103:p.unique_subtree
#@-node:ekr.20091001141621.6060:p.generators
#@+node:tbrown.20080119085249.1:setIconList & helpers
def setIconList(self, p, l):
    """Set list of icons for position p to l"""

    trace = False and not g.unitTesting

    current = self.getIconList(p)
    if not l and not current: return  # nothing to do
    lHash = ''.join([self.dHash(i) for i in l])
    cHash = ''.join([self.dHash(i) for i in current])
    # if trace: g.trace('lHash:',lHash)
    # if trace: g.trace('cHash:',cHash)
    if lHash == cHash:
        # no difference between original and current list of dictionaries
        return

    if trace: g.trace(l)

    self._setIconListHelper(p, l, p.v)

#@+node:ekr.20090701125429.6012:_setIconListHelper
def _setIconListHelper(self, p, subl, uaLoc):
    """icon setting code common between v and t nodes

    p - postion
    subl - list of icons for the v or t node
    uaLoc - the v or t node"""

    trace = False and not g.unitTesting

    if subl: # Update the uA.
        if not hasattr(uaLoc,'unknownAttributes'):
            uaLoc.unknownAttributes = {}
        uaLoc.unknownAttributes['icons'] = list(subl)
        # g.es((p.h,uaLoc.unknownAttributes['icons']))
        uaLoc.unknownAttributes["lineYOffset"] = 3
        uaLoc._p_changed = 1
        p.setDirty()
        if trace: g.trace('uA',uaLoc.u,uaLoc)
    else: # delete the uA.
        if hasattr(uaLoc,'unknownAttributes'):
            if 'icons' in uaLoc.unknownAttributes:
                del uaLoc.unknownAttributes['icons']
                uaLoc.unknownAttributes["lineYOffset"] = 0
                uaLoc._p_changed = 1
                p.setDirty()
        if trace: g.trace('del uA[icons]',uaLoc)
#@-node:ekr.20090701125429.6012:_setIconListHelper
#@-node:tbrown.20080119085249.1:setIconList & helpers
#@+node:ekr.20080805071954.1:putDescendentTnodeUas
def putDescendentTnodeUas (self,p):

    ### In the one-node world, there are no such things as independent tnodes.
    g.trace('*** ERROR: should not be called')
    return

    trace = False
    if trace: g.trace(p.h)

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = [] ; aList = []
    for p2 in p.self_and_subtree():
        v = p2.v
        if hasattr(v,"unknownAttributes"):
            if v not in tnodes :
                # g.trace(p2.h,v)
                tnodes.append(v)
                aList.append((p2.copy(),v),)

    # Create a list of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create s, an enclosing dict to hold all the inner dicts.
    d = {}
    nodeIndices = g.app.nodeIndices
    for v,d2 in aList:
        # Could be eliminated.
        # New in Leo 4.4.8.  Assign v.fileIndex here as needed.
        if not v.fileIndex:
            v.fileIndex = g.app.nodeIndices.getNewIndex()
        gnx = nodeIndices.toString(v.fileIndex)
        d[gnx]=d2

    if trace: g.trace(g.dictToString(d))

    # Pickle and hexlify d.
    return d and self.pickle(
        torv=p.v,val=d,tag="descendentTnodeUnknownAttributes") or ''
#@-node:ekr.20080805071954.1:putDescendentTnodeUas
#@-node:ekr.20091001141621.6042:iters -> generators & code cleanup
#@+node:ekr.20091219151045.6361:Simplified g.create_temp_file
# We can do this now that we require Python 2.5+
#@nonl
#@+node:ekr.20031218072017.3117:g.create_temp_file & test
def create_temp_file (textMode=False):
    '''Return a tuple (theFile,theFileName)

    theFile: a file object open for writing.
    theFileName: the name of the temporary file.'''

    try:
        # fd is an handle to an open file as would be returned by os.open()
        fd,theFileName = tempfile.mkstemp(text=textMode)
        mode = g.choose(textMode,'w','wb')
        theFile = os.fdopen(fd,mode)
    except Exception:
        g.es('unexpected exception in g.create_temp_file',color='red')
        g.es_exception()
        theFile,theFileName = None,''

    return theFile,theFileName
#@+node:ekr.20090517020744.5873:@test g.create_temp_file
if g.unitTesting:

    c,p = g.getTestVars()

    theFile,fn = g.create_temp_file()
    assert theFile
    assert g.isString(fn)
#@-node:ekr.20090517020744.5873:@test g.create_temp_file
#@-node:ekr.20031218072017.3117:g.create_temp_file & test
#@-node:ekr.20091219151045.6361:Simplified g.create_temp_file
#@-node:ekr.20091007104807.6470:Code
#@-node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20091203060018.6100:leo-3k
@nocolor-node

To do:

- Run all tests in this file (Alt-6).

- Fix plugins that fail with Python3k.

#@+node:ekr.20091203060018.6067:2to3 output
#@+node:ekr.20091203165343.6144:2to3 args
Available transformations for the -f/--fix option:
apply
basestring
buffer
callable
dict
except
exec
execfile
filter
funcattrs
future
getcwdu
has_key
idioms
import
imports
imports2
input
intern
isinstance
itertools
itertools_imports
long
map
metaclass
methodattrs
ne
next
nonzero
numliterals
paren
### print
raise
raw_input
reduce
renames
repr
set_literal
standarderror
sys_exc
throw
tuple_params
types
unicode
urllib
ws_comma
xrange
xreadlines
zip
#@-node:ekr.20091203165343.6144:2to3 args
#@-node:ekr.20091203060018.6067:2to3 output
#@+node:ekr.20091206084842.6197:Details, surprises
@nocolor-node

- add list for .keys(), .values(), .items()
- changes to library & exceptions.

*** Happy surprises ***

Python 3k does significantly better in catching type errors involving arithmetic types.
#@nonl
#@-node:ekr.20091206084842.6197:Details, surprises
#@+node:ekr.20091206161352.6230:Fixed unit tests
#@+node:ekr.20091206150342.6202:print statement in unit tests
ERROR: @test unindent in triple string does not end function

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 32
    print 'h',h
            ^
SyntaxError: invalid syntax
#@-node:ekr.20091206150342.6202:print statement in unit tests
#@+node:ekr.20091206150342.6193:u' in unit tests
======================================================================
ERROR: @test selfInsertCommand-1

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 12
    u = u'(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aBcz):\n'
                                          ^
SyntaxError: invalid syntax

ERROR: @test open non-existent non-ascii directory
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 6
    file = u''

ERROR: @test atFile.printError
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 9
    s = u'La Pe\xf1a'
                    ^
SyntaxError: invalid syntax

ERROR: @test failure to convert unicode characters to ascii
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 13
    s = u''
           ^
SyntaxError: invalid syntax

ERROR: @test g.reportBadChars
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 8
    (u'ab', 'ascii'),
             ^
SyntaxError: invalid syntax
#@-node:ekr.20091206150342.6193:u' in unit tests
#@+node:ekr.20091206150342.6207:string.strip does not exist
#@-node:ekr.20091206150342.6207:string.strip does not exist
#@+node:ekr.20091206150342.6192:sortLines: string.lower does not exist
======================================================================
ERROR: @test reverse-sort-lines-ignoring-case

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4650, in reverseSortLinesIgnoringCase
    return self.sortLines(event,ignoreCase=True,reverse=True)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4676, in sortLines
    if ignoreCase:  aList.sort(key=string.lower)
AttributeError: 'module' object has no attribute 'lower'
#@-node:ekr.20091206150342.6192:sortLines: string.lower does not exist
#@+node:ekr.20091206150342.6191:centerRegion
ERROR: @test center-region

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 2125, in centerRegion
    w.insert(i,' '*n)
TypeError: can't multiply sequence by non-int of type 'float'
#@+node:ekr.20050920084036.69:centerRegion
def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)

    self.beginCommand(undoType='center-region')

    inserted = 0
    while ind < end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) >= self.fillColumn:
            ind = j
        else:
            n = int((self.fillColumn-len(line))/2)
            inserted += n
            k = g.skip_ws(s,i)
            if k > i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    w.setSelectionRange(sel_1,sel_2+inserted)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.69:centerRegion
#@-node:ekr.20091206150342.6191:centerRegion
#@+node:ekr.20091206150342.6195:setInsertPoint
ERROR: @test moveUpOrDownHelper

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 7, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 1105, in setInsertPoint
    i = max(0,min(i,len(s)))
TypeError: unorderable types: int() < str()
#@nonl
#@-node:ekr.20091206150342.6195:setInsertPoint
#@+node:ekr.20091206150342.6201:skipBlock (elisp)
ERROR: @test elisp functions

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 23, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1506, in elispUnitTest
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.el')
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1557, in scannerUnitTest
    self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 862, in createOutline
    func(s,p,atAuto=atAuto)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1610, in scanElispText
    scanner.run(s,parent)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 3096, in run
    self.scan(s,parent)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2554, in scan
    i = self.skipDecls(s,0,len(s),inClass=False)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2786, in skipDecls
    elif self.startsFunction(s,i):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 3254, in startsFunction
    end = self.skipBlock(s,i)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2654, in skipBlock
    if indent < startIndent and line.strip():
TypeError: unorderable types: int() < NoneType()
#@+node:ekr.20070711060113:class elispScanner
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,unused_s,unused_i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.startSigIndent = self.getLeadingIndent(s,i)
    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False

    end = self.skipBlock(s,i)
    # g.trace('%3s %15s block: %s' % (i,repr(s[i:i+10]),repr(s[i:end])))
    if not g.match(s,end-1,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len('defun')
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = self.skipId(s,i) # Bug fix: 2009/09/30
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level <= 0:
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    self.error('no block')
    if 1:
        g.pr('** no block **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@-node:ekr.20091206150342.6201:skipBlock (elisp)
#@+node:ekr.20091206150342.6194:sortColumns
ERROR: @test sort-columns

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4709, in sortColumns
    zlist.sort()
AttributeError: 'zip' object has no attribute 'sort'

#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):

    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not self._chckSel(event): return
    self.beginCommand(undoType='sort-columns')
    try:
        s = w.getAllText()
        ins = w.getInsertPoint()
        sel_1,sel_2 = w.getSelectionRange()
        sint1,sint2 = g.convertPythonIndexToRowCol(s,sel_1)
        sint3,sint4 = g.convertPythonIndexToRowCol(s,sel_2)
        sint1 += 1 ; sint3 += 1
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        txt = s[i:j]
        columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
            for z in range(sint1,sint3+1)]
        aList = g.splitLines(txt)
        zlist = list(zip(columns,aList))
        zlist.sort()
        s = g.joinLines([z[1] for z in zlist])
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_1+len(s),insert=sel_1+len(s))
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.119:sortColumns
#@-node:ekr.20091206150342.6194:sortColumns
#@+node:ekr.20091206150342.6196:setSelectionRangeHelper
ERROR: @test paste from menu into headline sticks

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 10, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 382, in setSelectionRange
    return self.setSelectionRangeHelper(i,j,insert)
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 1594, in setSelectionRangeHelper
    insert = max(0,min(insert,n))
TypeError: unorderable types: int() < str()
#@-node:ekr.20091206150342.6196:setSelectionRangeHelper
#@+node:ekr.20091206150342.6199:flattenHeadline
ERROR: ImportExportTestCase: flattenOutline /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/output/flattenOutline.txt
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1545, in flattenOutline
    c.importCommands.flattenOutline(fileName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 409, in flattenOutline
    theFile.write(head + nl)
TypeError: can't concat bytes to str
#@+node:ekr.20031218072017.1147:flattenOutline
def flattenOutline (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.currentVnode()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    # 10/14/02: support for output_newline setting.
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return

    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel)
        s = g.toEncodedString(head + nl,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
        body = p.moreBody() # Inserts escapes.
        if len(body) > 0:
            s = g.toEncodedString(body + nl,self.encoding,reportErrors=True)
            theFile.write(s)
    theFile.close()
#@-node:ekr.20031218072017.1147:flattenOutline
#@-node:ekr.20091206150342.6199:flattenHeadline
#@+node:ekr.20091206150342.6198:exportHeadlines
ERROR: ImportExportTestCase: exportHeadlines /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/output/exportHeadlines.txt
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1523, in exportHeadlines
    c.importCommands.exportHeadlines(fileName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 384, in exportHeadlines
    theFile.write(head + nl)
TypeError: can't concat bytes to str

#@+node:ekr.20031218072017.1462:exportHeadlines
def exportHeadlines (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.p
    if not p: return
    self.setEncoding()
    firstLevel = p.level()
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return
    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel,useVerticalBar=True)
        s = g.toEncodedString(head + nl,self.encoding,reportErrors=True)
        theFile.write(s)
    theFile.close()
#@-node:ekr.20031218072017.1462:exportHeadlines
#@-node:ekr.20091206150342.6198:exportHeadlines
#@+node:ekr.20091206150342.6200:scanWebFile
ERROR: ImportExportTestCase: importCWEBFiles /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/input/cweave.w
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1626, in importCWEBFiles
    c.importCommands.importWebCommand(names,"cweb")
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1212, in importWebCommand
    p = self.createOutlineFromWeb(fileName,current)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1195, in createOutlineFromWeb
    self.scanWebFile(path,p)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1332, in scanWebFile
    if k > -1: self.cstEnter(s[j:k])
TypeError: unorderable types: NoneType() > int()
#@nonl
#@+node:ekr.20031218072017.3176:find_on_line
def find_on_line(s,i,pattern):

    j = s.find('\n',i)
    if j == -1: j = len(s)
    k = s.find(pattern,i,j)
    return k
#@-node:ekr.20031218072017.3176:find_on_line
#@+node:ekr.20031218072017.3231:scanWebFile (handles limbo)
def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@<","<<")
    rb = g.choose(theType=="cweb","@>",">>")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except Exception:
        g.es("can not import",fileName, color="blue")
        return

    << Create a symbol table of all section names >>
    << Create nodes for limbo text and the root section >>
    while i < len(s):
        outer_progress = i
        << Create a node for the next module >>
        assert(i > outer_progress)
#@nonl
#@+node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
i = 0 ; self.web_st = []

while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k > -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i > progress)

# g.trace(self.cstDump())
#@-node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
#@+node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
i = 0
while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i > progress)

j = g.skip_ws(s,0)
if j < i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i > progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

# g.trace(g.get_line(s,i))
#@-node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
#@+node:ekr.20031218072017.3234:<< Create a node for the next module >>
if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i < len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i > progress)
    << Handle cweb @d, @f, @c and @p directives >>
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i > progress)

body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
#@+node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i > progress)
    i = g.skip_ws_and_nl(s,i)

while i < len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i > progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i < len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i > progress)
#@-node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
#@-node:ekr.20031218072017.3234:<< Create a node for the next module >>
#@-node:ekr.20031218072017.3231:scanWebFile (handles limbo)
#@-node:ekr.20091206150342.6200:scanWebFile
#@+node:ekr.20091206150342.6189:outputStringWithLineEndings
Traceback (most recent call last):

  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoAtFile.py", line 3175, in asisWrite
    at.outputStringWithLineEndings(s)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoAtFile.py", line 4324, in outputStringWithLineEndings
    self.os(s.replace('\n',self.output_newline))
TypeError: expected an object with the buffer interface
#@nonl
#@+node:ekr.20041005105605.205:outputStringWithLineEndings
# Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):
    at = self
    # Calling self.onl() runs afoul of queued newlines.

    if 1: # g.u(s) == s when isPython3.
        if g.isPython3:
            s = g.ue(s,at.encoding)
        s = s.replace('\n',at.output_newline)
        self.os(s)
    else:
        if g.isPython3:
            s = g.ue(s,at.encoding)
            s = s.replace(g.u('\n'),g.u(at.output_newline))
        else:
            s = s.replace('\n',at.output_newline)
        self.os(s)
#@-node:ekr.20041005105605.205:outputStringWithLineEndings
#@-node:ekr.20091206150342.6189:outputStringWithLineEndings
#@+node:ekr.20091206150342.6190:parse_leo_file
 File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoFileCommands.py", line 1445, in parse_leo_file
    theFile = StringIO(s)

TypeError: initial_value must be str or None, not bytes
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                pass
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20091206150342.6190:parse_leo_file
#@+node:ekr.20091206224118.6260:unicode failures
FAIL: @test failure to convert unicode characters to ascii
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 11, in <module>
AssertionError: toUnicodeWithErrorCode returns True for  with ascii encoding

======================================================================
FAIL: @test of round-tripping toUnicode & toEncodedString
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 19, in <module>
AssertionError: Round-trip one fails for a

======================================================================
FAIL: @test failure with ascii encodings
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 10, in <module>
AssertionError: toUnicodeWithErrorCode returns True for  with ascii encoding

======================================================================
FAIL: @test round trip toUnicode toEncodedString
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 27, in <module>
AssertionError: Round-trip one failed for a
#@+node:ekr.20080816125725.2:g.isBytes, isChar, isString & isUnicode
# The syntax of these functions must be valid on Python2K and Python3K.

def isBytes(s):
    '''Return True if s is Python3k bytes type.'''
    if g.isPython3:
        # Generates a pylint warning, but that can't be helped.
        return type(s) == type(bytes('a','utf-8'))
    else:
        return False

def isChar(s):
    '''Return True if s is a Python2K character type.'''
    if g.isPython3:
        return False
    else:
        return type(s) == types.StringType

def isString(s):
    '''Return True if s is any string, but not bytes.'''
    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) in types.StringTypes

def isUnicode(s):
    '''Return True if s is a unicode string.'''
    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) == types.UnicodeType
#@-node:ekr.20080816125725.2:g.isBytes, isChar, isString & isUnicode
#@+node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20050208093800:g.toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if g.isUnicode(s):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors: g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@-node:ekr.20050208093800:g.toEncodedString
#@+node:ekr.20080919065433.2:toEncodedStringWithErrorCode (for unit testing)
def toEncodedStringWithErrorCode (s,encoding,reportErrors=False):

    ok = True

    if g.isUnicode(s):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors: g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
            ok = False
    return s, ok
#@-node:ekr.20080919065433.2:toEncodedStringWithErrorCode (for unit testing)
#@+node:ekr.20050208093800.1:g.toUnicode
def toUnicode (s,encoding,reportErrors=False):

    if isPython3:
        convert,mustConvert,nullVal = str,g.isBytes,''
    else:
        convert,nullVal = unicode,unicode('')
        def mustConvert (s):
            return type(s) != types.UnicodeType

    if not s:
        s = nullVal
    elif mustConvert(s):
        try:
            s = convert(s,encoding,'strict')
        except UnicodeError:
            s = convert(s,encoding,'replace')
            if reportErrors: g.reportBadChars(s,encoding)
    else:
        pass

    return s
#@nonl
#@-node:ekr.20050208093800.1:g.toUnicode
#@+node:ekr.20091206161352.6232:g.u & g.ue
if isPython3: # g.not defined yet.
    def u(s):
        return s
    def ue(s,encoding):
        return str(s,encoding)
else:
    def u(s):
        return unicode(s)
    def ue(s,encoding):
        return unicode(s,encoding)
#@-node:ekr.20091206161352.6232:g.u & g.ue
#@+node:ekr.20080919065433.1:toUnicodeWithErrorCode (for unit testing)
def toUnicodeWithErrorCode (s,encoding,reportErrors=False):

    ok = True
    if g.isPython3: f = str
    else: f = unicode
    if s is None:
        s = g.u('')
    if not g.isUnicode(s):
        try:
            s = f(s,encoding,'strict')
        except (UnicodeError,ValueError):
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = f(s,encoding,'replace')
            ok = False
    return s,ok
#@-node:ekr.20080919065433.1:toUnicodeWithErrorCode (for unit testing)
#@-node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@-node:ekr.20091206224118.6260:unicode failures
#@+node:ekr.20091207194815.6264:t1.next
ERROR: @test find_h / find_b / select_h / select_b

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 23, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoNodes.py", line 2842, in select_b
    first = t1.next()
AttributeError: 'itertools.tee' object has no attribute 'next'
#@+node:ville.20090311195550.1:select_b
def select_b(self, regex, flags = re.IGNORECASE ):
    """ Find all the nodes in poslist where body matches regex

    You can chain find_h / find_b with select_h / select_b like this
    to refine an outline search::

        pl = c.find_h('@thin.*py').select_h('class.*').select_b('import (.*)')
    """
    pat = re.compile(regex, flags)
    res = poslist()
    for p in self:
        m = re.finditer(pat, p.b)
        t1,t2 = itertools.tee(m,2)
        try:
            if g.isPython3:
                first = t1.__next__()
            else:
                first = t1.next()
            # if does not raise StopIteration...
            pc = p.copy()
            pc.matchiter = t2
            res.append(pc)

        except StopIteration:
            pass

    return res
#@-node:ville.20090311195550.1:select_b
#@+node:ville.20090311200059.1:c.find_b
def find_b(self, regex, flags = re.IGNORECASE | re.MULTILINE):
    """ Return list (a poslist) of all nodes whose body matches the regex

    You can chain find_h / find_b with select_h / select_b like this
    to refine an outline search::

    pl = c.find_h('@thin.*py').select_h('class.*').select_b('import (.*)')    
    """

    c = self
    pat = re.compile(regex, flags)
    res = leoNodes.poslist()
    for p in c.all_positions():
        m = re.finditer(pat, p.b)
        t1,t2 = itertools.tee(m,2)
        try:
            if g.isPython3:
                first = t1.__next__()
            else:
                first = t1.next()
        except StopIteration:
            continue
        pc = p.copy()
        pc.matchiter = t2
        res.append(pc)
    return res
#@-node:ville.20090311200059.1:c.find_b
#@-node:ekr.20091207194815.6264:t1.next
#@+node:ekr.20091207194815.6265:putDescendentVnodeUas
FAIL: @test putDescendentVnodeUas

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 19, in <module>
AssertionError: expected: ' descendentVnodeUnknownAttributes="7d7100285503302e3071017d7102550f756e69745f746573745f6368696c6471035504616263647104735505302e302e3071057d71065514756e69745f746573745f6772616e646368696c64710755047778797a710873752e"', got: ' descendentVnodeUnknownAttributes="b\'7d7100285803000000302e3071017d7102580f000000756e69745f746573745f6368696c6471035804000000616263647104735805000000302e302e3071057d71065814000000756e69745f746573745f6772616e646368696c64710758040000007778797a710873752e\'"'
#@-node:ekr.20091207194815.6265:putDescendentVnodeUas
#@+node:ekr.20041001161108:doPlugins
ignoringMessageGiven = False

def doPlugins(tag,keywords):

    global ignoringMessageGiven

    if g.app.killed:
        return

    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
#@-node:ekr.20041001161108:doPlugins
#@-node:ekr.20091206161352.6230:Fixed unit tests
#@+node:ekr.20091209095640.6218:Output tnodes in proper order
#@+node:ekr.20031218072017.1997:scanGnx
def scanGnx (self,s,i):

    """Create a gnx from its string representation"""

    if not g.isString(s):
        g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
        return None,None,None

    s = s.strip()

    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if theId == None or len(theId) == 0:
        theId = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except Exception: pass

    return theId,t,n
#@-node:ekr.20031218072017.1997:scanGnx
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):

    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("<tnodes>\n")
    << write only those tnodes that were referenced >>
    self.put("</tnodes>\n")
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
if self.usingClipboard: # write the current tree.
    theIter = c.p.self_and_subtree()
else: # write everything
    theIter = c.all_unique_positions()

# Populate tnodes
tnodes = {}
nodeIndices = g.app.nodeIndices
for p in theIter:
    # Make *sure* the file index has the proper form.
    # g.trace(p.v.fileIndex)
    try:
        theId,t,n = p.v.fileIndex
    except ValueError:
        try:
            theId,t,n = p.v.fileIndex,''
        except Exception:
            raise BadLeoFile('bad p.v.fileIndex' % repr(p.v.fileIndex))

    if n is None:
        n = g.u('0')
    elif g.isPython3:
        n = str(n)
    else:
        n = unicode(n)
    index = theId,t,n
    tnodes[index] = p.v

# Put all tnodes in index order.
for index in sorted(tnodes):
    # g.trace(index)
    v = tnodes.get(index)
    if v:
        # Write only those tnodes whose vnodes were written.
        if v.isWriteBit():
            self.putTnode(v)
    else:
        g.trace('can not happen: no vnode for',repr(index))
        # This prevents the file from being written.
        raise BadLeoFile('no vnode for %s' % repr(index))
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@-node:ekr.20091209095640.6218:Output tnodes in proper order
#@+node:ekr.20091217191310.6304:Remove bad chars from .leo files
#@+node:ekr.20090525144314.6526:cleanSaxInputString & test
def cleanSaxInputString(self,s):

    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
#@+node:ekr.20090525144314.6527:@test cleanSaxInputString
if g.unitTesting:

    c,p = g.getTestVars()

    s = 'test%cthis' % 27

    assert c.fileCommands.cleanSaxInputString(s) == 'test this'
#@-node:ekr.20090525144314.6527:@test cleanSaxInputString
#@-node:ekr.20090525144314.6526:cleanSaxInputString & test
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                pass
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20091217191310.6304:Remove bad chars from .leo files
#@+node:ekr.20091209114435.6223:Fixed caching
#@+node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.doubleClickFlag = False
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui
self.ipythonController = None # Set only by the ipython plugin.

# Interlock to prevent setting c.changed when switching chapters.
c.suppressHeadChanged = False

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None
self.timeStampDict = {} # New in Leo 4.6.

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False

# Default Tangle options
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = g.u('') # Must always be a string.
self.navTime = None

pth, bname = os.path.split(self.mFileName)
if pth and bname and g.enableDB:
    fn = self.mFileName.lower()
    fn = g.toEncodedString(fn,'utf-8') # Required for Python 3.x.
    dbdirname = '%s/db/%s_%s' % (
        g.app.homeLeoDir,bname,hashlib.md5(fn).hexdigest())
    # Use compressed pickles (handy for @thin caches)
    self.db = leo.external.pickleshare.PickleShareDB(dbdirname,protocol='picklez')
else:
    self.db = {}
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
#@+node:ekr.20091204132346.6078:<< imports >> (pickleshare.py)
import leo.core.leoGlobals as g
from leo.external.path import path as Path
import glob
import os
import stat
import sys
import time
import warnings

isPython3 = sys.version_info >= (3,0,0)

try:
    import marshal
except ImportError:
    marshal = None

if isPython3:
    import pickle
else:
    import cPickle as pickle

try:
    import simplejson
except ImportError:
    simplejson = None

try:
    import zlib
except ImportError:
    zlib = None
#@-node:ekr.20091204132346.6078:<< imports >> (pickleshare.py)
#@+node:ekr.20041005105605.21:read (atFile) & helper
def read(self,root,
    importFileName=None,thinFile=False,
    fromString=None,atShadow=False,
    force=False
):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName and isAtFile >>
    if isAtFile:
        # The @file node has file-like sentinels iff a tnodeList exists.
        thinFile = not (hasattr(root.v,'tnodeList') and root.v.tnodeList)
    doCache = g.enableDB and (thinFile or atShadow) and not force
    at.initReadIvars(root,fileName,
        importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root, fileContent)

    # Remember that we have read this file.
    root.v.at_read = True # Create the attribute for all clones.

    if doCache and cachefile in c.db:
        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        aList = c.db[cachefile]
        root.v.createOutlineFromCacheList(c,aList)
        at.inputFile.close()
        root.clearDirty()
        return

    # Delete all children, but **not** for @file and @nosent nodes!
    # (We do delete all children for @file nodes with thin-like sentinels.)
    if thinFile or atShadow:
        root.v.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if not g.unitTesting:
        g.es("reading:",root.h)

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName and isAtFile >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False

isAtFile = (
    not thinFile and
    not importFileName and
    not atShadow and
    not fromString and
    root.h.startswith('@file'))
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName and isAtFile >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
resurrected = 0
for p in root.self_and_subtree():
    if p.v.isVisited():
        pass
        # g.trace('visited',p.v,p.h)
    else:
        g.trace('**** not visited',p.v,p.h)
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for v in c.all_unique_nodes():

    if hasattr(v,"tempBodyString"):
        delattr(v,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile) & helper
#@+node:ekr.20091204132346.6080:class PickleShareDB
_sentinel = object()

class PickleShareDB:
    """ The main 'connection' object for PickleShare database """
    @others
#@+node:ekr.20091204132346.6081: __init__
def __init__(self,root, protocol = 'pickle'):
    """ Initialize a PickleShare object that will manage the specied directory

    root: The directory that contains the data. Created if it doesn't exist.

    protocol: one of 

        * 'pickle' (universal, default) 
        * 'picklez' (compressed pickle)         
        * 'marshal' (fast, limited type support)
        * 'json' : brief, human-readable, very limited type support

    Protol 'json' requires installation of simplejson module
    """
    self.root = Path(root).expanduser().abspath()
    if not self.root.isdir():
        self.root.makedirs()
    # cache has { 'key' : (obj, orig_mod_time) }
    self.cache = {}

    if protocol == 'pickle':
        self.loader = pickle.load
        self.dumper = pickle.dump
    elif protocol == 'marshal':
        if marshal:
            self.loader = marshal.load
            self.dumper = marshal.dump
    elif protocol == 'json':
        if simplejson:
            self.loader = simplejson.load
            self.dumper = simplejson.dump
    elif protocol == 'picklez':
        if zlib:
            def loadz(fileobj):
                val = pickle.loads(zlib.decompress(fileobj.read()))
                return val

            def dumpz(val, fileobj):
                compressed = zlib.compress(pickle.dumps(val, pickle.HIGHEST_PROTOCOL))
                fileobj.write(compressed)

            self.loader = loadz
            self.dumper = dumpz
#@-node:ekr.20091204132346.6081: __init__
#@+node:ekr.20091216103214.6305:__contains__
def __contains__(self, key):

    return self.has_key(key)
#@-node:ekr.20091216103214.6305:__contains__
#@+node:ekr.20091204132346.6088:__delitem__
def __delitem__(self,key):

    """ del db["key"] """

    fil = self.root / key
    # g.trace('(PickleShareDB)',key) # ,g.shortFileName(fil))
    self.cache.pop(fil,None)
    try:
        fil.remove()
    except OSError:
        # notfound and permission denied are ok - we
        # lost, the other process wins the conflict
        pass
#@-node:ekr.20091204132346.6088:__delitem__
#@+node:ekr.20091204132346.6082:__getitem__
def __getitem__(self,key):

    """ db['key'] reading """

    fil = self.root / key
    # g.trace('(PickleShareDB)',key) #,g.shortFileName(fil))
    try:
        mtime = (fil.stat()[stat.ST_MTIME])
    except OSError:
        raise KeyError(key)

    if fil in self.cache and mtime == self.cache[fil][1]:
        return self.cache[fil][0]
    try:
        # The cached item has expired, need to read
        obj = self.loader(fil.open("rb"))
    except:
        raise KeyError(key)

    self.cache[fil] = (obj,mtime)
    return obj
#@-node:ekr.20091204132346.6082:__getitem__
#@+node:ekr.20091216103214.6303:__iter__
def __iter__(self):

    for k in list(self.keys()):
        yield k
#@-node:ekr.20091216103214.6303:__iter__
#@+node:ekr.20091204132346.6094:__repr__
def __repr__(self):

    return "PickleShareDB('%s')" % self.root



#@-node:ekr.20091204132346.6094:__repr__
#@+node:ekr.20091204132346.6083:__setitem__
def __setitem__(self,key,value):

    """ db['key'] = 5 """

    fil = self.root / key
    parent = fil.parent
    if parent and not parent.isdir():
        parent.makedirs()
    pickled = self.dumper(value,fil.open('wb'))
    # g.trace('(PickleShareDB)',key) # ,g.shortFileName(fil))
    try:
        self.cache[fil] = (value,fil.mtime)
    except OSError as e:
        if e.errno != 2:
            raise

#@-node:ekr.20091204132346.6083:__setitem__
#@+node:ekr.20091204132346.6089:_normalized
def _normalized(self, p):
    """ Make a key suitable for user's eyes """
    return str(self.root.relpathto(p)).replace('\\','/')

#@-node:ekr.20091204132346.6089:_normalized
#@+node:ekr.20091224075120.6536:get
def get(self, key, default=None):
    try:
        return self[key]
    except KeyError:
        return default
#@nonl
#@-node:ekr.20091224075120.6536:get
#@+node:ekr.20091204132346.6093:getlink
def getlink(self,folder):
    """ Get a convenient link for accessing items  """
    return PickleShareLink(self, folder)

#@-node:ekr.20091204132346.6093:getlink
#@+node:ekr.20091216103214.6304:has_key
def has_key(self, key):

    try:
        value = self[key]
    except KeyError:
        return False

    return True
#@-node:ekr.20091216103214.6304:has_key
#@+node:ekr.20091204132346.6087:hcompress
def hcompress(self, hashroot):
    """ Compress category 'hashroot', so hset is fast again

    hget will fail if fast_only is True for compressed items (that were
    hset before hcompress).

    """
    hfiles = self.keys(hashroot + "/*")
    all = {}
    for f in hfiles:
        # print("using",f)
        all.update(self[f])
        self.uncache(f)

    self[hashroot + '/xx'] = all
    for f in hfiles:
        p = self.root / f
        if p.basename() == 'xx':
            continue
        p.remove()



#@-node:ekr.20091204132346.6087:hcompress
#@+node:ekr.20091204132346.6086:hdict
def hdict(self, hashroot):
    """ Get all data contained in hashed category 'hashroot' as dict """
    hfiles = self.keys(hashroot + "/*")
    hfiles.sort()
    last = len(hfiles) and hfiles[-1] or ''
    if last.endswith('xx'):
        # print("using xx")
        hfiles = [last] + hfiles[:-1]

    all = {}

    for f in hfiles:
        # print("using",f)
        try:
            all.update(self[f])
        except KeyError:
            print("Corrupt",f,"deleted - hset is not threadsafe!")
            del self[f]

        self.uncache(f)

    return all
#@-node:ekr.20091204132346.6086:hdict
#@+node:ekr.20091204132346.6085:hget
def hget(self, hashroot, key, default = _sentinel, fast_only = True):
    """ hashed get """
    hroot = self.root / hashroot
    hfile = hroot / gethashfile(key)
    d = self.get(hfile, _sentinel )
    g.trace("got dict",d,"from",g.shortFileName(hfile))
    if d is _sentinel:
        if fast_only:
            if default is _sentinel:
                raise KeyError(key)
            return default
        # slow mode ok, works even after hcompress()
        d = self.hdict(hashroot)

    return d.get(key, default)
#@nonl
#@-node:ekr.20091204132346.6085:hget
#@+node:ekr.20091204132346.6084:hset
def hset(self, hashroot, key, value):
    """ hashed set """
    hroot = self.root / hashroot
    if not hroot.isdir():
        hroot.makedirs()
    hfile = hroot / gethashfile(key)
    d = self.get(hfile, {})
    d.update( {key : value})
    self[hfile] = d                



#@-node:ekr.20091204132346.6084:hset
#@+node:ekr.20091216103214.6306:iteritems & iterkeys
def iteritems(self):
    for k in self:
        yield (k, self[k])

def iterkeys(self):
    return self.__iter__()
#@-node:ekr.20091216103214.6306:iteritems & iterkeys
#@+node:ekr.20091204132346.6090:keys
def keys(self, globpat = None):
    """ All keys in DB, or all keys matching a glob"""

    if globpat is None:
        files = self.root.walkfiles()
    else:
        files = [Path(p) for p in glob.glob(self.root/globpat)]

    return [self._normalized(p) for p in files if p.isfile()]

#@-node:ekr.20091204132346.6090:keys
#@+node:ekr.20091204132346.6091:uncache
def uncache(self,*items):
    """ Removes all, or specified items from cache

    Use this after reading a large amount of large objects
    to free up memory, when you won't be needing the objects
    for a while.

    """
    if not items:
        self.cache = {}
    for it in items:
        self.cache.pop(it,None)

#@-node:ekr.20091204132346.6091:uncache
#@+node:ekr.20091204132346.6092:waitget
def waitget(self,key, maxwaittime = 60 ):
    """ Wait (poll) for a key to get a value

    Will wait for `maxwaittime` seconds before raising a KeyError.
    The call exits normally if the `key` field in db gets a value
    within the timeout period.

    Use this for synchronizing different processes or for ensuring
    that an unfortunately timed "db['key'] = newvalue" operation 
    in another process (which causes all 'get' operation to cause a 
    KeyError for the duration of pickling) won't screw up your program 
    logic. 
    """

    wtimes = [0.2] * 3 + [0.5] * 2 + [1]
    tries = 0
    waited = 0
    while 1:
        try:
            val = self[key]
            return val
        except KeyError:
            pass

        if waited > maxwaittime:
            raise KeyError(key)

        time.sleep(wtimes[tries])
        waited+=wtimes[tries]
        if tries < len(wtimes) -1:
            tries+=1
#@-node:ekr.20091204132346.6092:waitget
#@-node:ekr.20091204132346.6080:class PickleShareDB
#@-node:ekr.20091209114435.6223:Fixed caching
#@+node:ekr.20091218143600.6302:Fixed doctest problems on Linux
#@+node:ekr.20051104075904.99:createUnitTestsFromDoctests
def createUnitTestsFromDoctests (modules,verbose=True):

    created = False # True if suite is non-empty.

    suite = unittest.makeSuite(unittest.TestCase)

    for module in list(modules):
        # New in Python 4.2: n may be zero.
        try:
            test = doctest.DocTestSuite(module)
            n = test.countTestCases()
            if n > 0:
                suite.addTest(test)
                created = True
                if verbose:
                    g.pr("found %2d doctests for %s" % (n,module.__name__))
        except ValueError:
            g.pr('no doctests in %s' % module.__name__)
            pass # No tests found.

    return g.choose(created,suite,None)
#@-node:ekr.20051104075904.99:createUnitTestsFromDoctests
#@+node:ekr.20051104075904.102:importAllModulesInPath
def importAllModulesInPath (path,exclude=[]):

    path = g.os_path_finalize(path)

    if not g.os_path_exists(path):
        g.es("path does not exist:",path)
        return []

    path2 = g.os_path_join(path,"leo*.py")
    files = glob.glob(path2)
    files2 = []
    for theFile in files:
        for z in exclude:
            if theFile.endswith(z):
                break
        else:
            files2.append(theFile)
    modules = []

    for theFile in files2:
        module = safeImportModule(theFile)
        if module:
            modules.append(module)

    # g.trace(modules)
    return modules
#@nonl
#@-node:ekr.20051104075904.102:importAllModulesInPath
#@+node:ekr.20051104075904.103:safeImportModule & test
@ Warning: do NOT use g.importFromPath here!

g.importFromPath uses imp.load_module, and that is equivalent to reload!
reloading Leo files while running will crash Leo.
@c

def safeImportModule (fileName):

    fileName = g.os_path_finalize(fileName)
    head,tail = g.os_path_split(fileName)
    moduleName,ext = g.os_path_splitext(tail)
    oldUnitTesting = g.unitTesting

    if ext == ".py":
        try:
            # g.trace(moduleName)
            g.unitTesting = False # Disable @test nodes!
            g.app.unitTesting = False
            try:
                # for base in ('leo.core','leo.plugins','leo.external',):
                    # fullName = '%s.%s' % (base,moduleName)
                    # m = __import__(fullName) # 'leo.core.%s' % moduleName)
                    # if m is not None:
                        # return sys.modules.get(fullName)
                fullName = 'leo.core.%s' % (moduleName)
                __import__(fullName)
                return sys.modules.get(fullName)
            finally:
                g.unitTesting = oldUnitTesting
                g.app.unitTesting = oldUnitTesting
        except Exception:
            # g.trace('can not import',moduleName,fileName)
            # leoScriptModule.py, for example, can throw other exceptions.
            return None
    else:
        g.pr("Not a .py file:",fileName)
        return None
#@+node:ekr.20090703155133.6418:@test safeImportModule
if g.unitTesting:

    d = g.app.unitTestDict
    c,p = g.getTestVars()
    assert d.get('getTestVars') is True
    d['getTestVars'] = False

    # Do lots of imports.
    import leo.core.leoTest as leoTest
    path = g.os_path_join(g.app.loadDir,"..","core")
    modules = leoTest.importAllModulesInPath(path)

    # Assert that g.getTestVars has not been called.
    val = d.get('getTestVars')
    assert val is False, val

#@-node:ekr.20090703155133.6418:@test safeImportModule
#@-node:ekr.20051104075904.103:safeImportModule & test
#@-node:ekr.20091218143600.6302:Fixed doctest problems on Linux
#@+node:ekr.20091218173731.6717:Fixed completer crash
#@+node:ekr.20060221083356:g.prettyPrintType
def prettyPrintType (obj):

    if g.isPython3:
        if type(obj) in (types.MethodType,types.BuiltinMethodType):
            return 'method'
        elif type(obj) in (types.BuiltinFunctionType,types.FunctionType):
            return 'function'
        elif type(obj) == types.ModuleType:
            return 'module'
        elif g.isString(obj):
            return 'string'
        else:
            theType = str(type(obj))
            if theType.startswith("<type '"): theType = theType[7:]
            if theType.endswith("'>"): theType = theType[:-2]
            return theType
    else:
        if type(obj) in (
            types.MethodType,types.UnboundMethodType,types.BuiltinMethodType):
            return 'method'
        elif type(obj) in (types.BuiltinFunctionType,types.FunctionType):
            return 'function'
        elif type(obj) == types.ModuleType:
            return 'module'
        elif type(obj) == types.InstanceType:
            return 'object'
        elif type(obj) in (types.UnicodeType,types.StringType):
            return 'string'
        else:
            theType = str(type(obj))
            if theType.startswith("<type '"): theType = theType[7:]
            if theType.endswith("'>"): theType = theType[:-2]
            return theType
#@-node:ekr.20060221083356:g.prettyPrintType
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    if g.isPython3:
        for z in gc.get_objects():
            try:
                name = z.__class__.__name__
            except ReferenceError:
                pass
            self.allClassesDict [name] = z
    else:
        for z in gc.get_objects():
            t = type(z)
            if t == types.ClassType:
                name = z.__name__
            elif t == types.InstanceType:
                name = z.__class__.__name__
            elif repr(t).startswith('<class'): # A wretched kludge.
                name = z.__class__.__name__
            elif t == types.TypeType:
                name = z.__name__
            else:
                name = None
            if name:
                # if name == 'position': g.trace(t,z)
                self.allClassesDict [name] = z

    # g.printList(list(self.allClassesDict.keys()),tag='Classes',sort=True)
    # g.trace(len(list(self.allClassesDict.keys())))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@-node:ekr.20091218173731.6717:Fixed completer crash
#@+node:ekr.20091218182246.6722:Added entries for haxe language
#@+node:ekr.20031218072017.368:<< define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lua"           : "--",  # ddm 13/02/06
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--', # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    "rst"           : "rst",
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
#@-node:ekr.20031218072017.368:<< define global data structures >> (leoApp.py)
#@-node:ekr.20091218182246.6722:Added entries for haxe language
#@+node:ekr.20091220131901.6364:Unicode bug
#@+node:ekr.20091206161352.6232:g.u & g.ue
if isPython3: # g.not defined yet.
    def u(s):
        return s
    def ue(s,encoding):
        return str(s,encoding)
else:
    def u(s):
        return unicode(s)
    def ue(s,encoding):
        return unicode(s,encoding)
#@-node:ekr.20091206161352.6232:g.u & g.ue
#@+node:ekr.20070412082527:g.openLeoOrZipFile & tests
# This is used in several places besides g.openWithFileName.

def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            if not theFile: return None,False
            # Read the file into an StringIO file.
            aList = theFile.namelist()
            name = aList and len(aList) == 1 and aList[0]
            if not name: return None,False
            s = theFile.read(name)
            if g.isPython3:
                theStringFile = StringIO(g.ue(s,'utf-8'))
            else:
                theStringFile =  StringIO(s)
            return theStringFile,True
        else:
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@+node:ekr.20090526083112.5838:@test g.openLeoOrZipFile
if g.unitTesting:

    import zipfile

    # Create a zip file for testing.
    s = 'this is a test file'
    testDir = g.os_path_join(g.app.loadDir,'..','test')
    assert g.os_path_exists(testDir)
    path = g.os_path_finalize_join(testDir,'testzip.zip')
    theFile = zipfile.ZipFile(path,'w')
    theFile.writestr('leo-zip-file',s)
    theFile.close()

    # Open the file, and use read (with no args) to get the contents.
    theFile,ok = g.openLeoOrZipFile(path)
    assert ok,'not ok'
    s2 = theFile.read()
    assert s == s2,'s:  %s\ns2: %s' % (repr(s),repr(s2))
#@-node:ekr.20090526083112.5838:@test g.openLeoOrZipFile
#@-node:ekr.20070412082527:g.openLeoOrZipFile & tests
#@+node:ekr.20091220131901.6365:leoAtFile
#@+node:ekr.20090525144314.6526:cleanSaxInputString & test
def cleanSaxInputString(self,s):

    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
#@+node:ekr.20090525144314.6527:@test cleanSaxInputString
if g.unitTesting:

    c,p = g.getTestVars()

    s = 'test%cthis' % 27

    assert c.fileCommands.cleanSaxInputString(s) == 'test this'
#@-node:ekr.20090525144314.6527:@test cleanSaxInputString
#@-node:ekr.20090525144314.6526:cleanSaxInputString & test
#@+node:ekr.20041005105605.205:outputStringWithLineEndings
# Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):
    at = self
    # Calling self.onl() runs afoul of queued newlines.

    if 1: # g.u(s) == s when isPython3.
        if g.isPython3:
            s = g.ue(s,at.encoding)
        s = s.replace('\n',at.output_newline)
        self.os(s)
    else:
        if g.isPython3:
            s = g.ue(s,at.encoding)
            s = s.replace(g.u('\n'),g.u(at.output_newline))
        else:
            s = s.replace('\n',at.output_newline)
        self.os(s)
#@-node:ekr.20041005105605.205:outputStringWithLineEndings
#@+node:ekr.20080712150045.1:replaceFileWithString (atFile)
def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    at = self ; testing = g.app.unitTesting

    # g.trace('fn',fn,'s','\n',s)
    # g.trace(g.callers())

    exists = g.os_path_exists(fn)

    if exists: # Read the file.  Return if it is the same.
        try:
            f = open(fn,'rb')
            s2 = f.read()
            f.close()
        except IOError:
            at.error('unexpected exception creating %s' % fn)
            g.es_exception()
            return False
        if s == s2:
            if not testing: g.es('unchanged:',fn)
            return False

    # Issue warning if directory does not exist.
    theDir = g.os_path_dirname(fn)
    if theDir and not g.os_path_exists(theDir):
        if not g.unitTesting:
            g.es('not written: %s directory not found' % fn,color='red')
        return False

    # Replace
    try:
        f = open(fn,'wb')
        if g.isPython3:
            s = g.toEncodedString(s,encoding=self.encoding)
        f.write(s)
        f.close()
        if not testing:
            if exists:
                g.es('wrote:    ',fn)
            else:
                # g.trace('created:',fn,g.callers())
                g.es('created:',fn)
        return True
    except IOError:
        at.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
#@+node:ekr.20090530055015.6873:@test at.replaceFileWithString
if g.unitTesting:

    c,p = g.getTestVars()
    at = c.atFileCommands

    fn = 'does/not/exist'
    assert not g.os_path_exists(fn)
    assert not at.replaceFileWithString (fn,'abc')
#@-node:ekr.20090530055015.6873:@test at.replaceFileWithString
#@-node:ekr.20080712150045.1:replaceFileWithString (atFile)
#@+node:ekr.20041005105605.204:os
def os (self,s):

    """Write a string to the output stream.

    All output produced by leoAtFile module goes here."""

    trace = False
    at = self ; tag = self.underindentEscapeString
    f = at.outputFile

    if s and f:
        try:
            if trace: g.trace(repr(s))
            if s.startswith(tag):
                junk,s = self.parseUnderindentTag(s)
            # Bug fix: this must be done last.
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            f.write(s)
        except Exception:
            at.exception("exception writing:" + s)
#@-node:ekr.20041005105605.204:os
#@-node:ekr.20091220131901.6365:leoAtFile
#@+node:ekr.20091220131901.6366:leoFileCommands
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                pass
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):

    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("<tnodes>\n")
    << write only those tnodes that were referenced >>
    self.put("</tnodes>\n")
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
if self.usingClipboard: # write the current tree.
    theIter = c.p.self_and_subtree()
else: # write everything
    theIter = c.all_unique_positions()

# Populate tnodes
tnodes = {}
nodeIndices = g.app.nodeIndices
for p in theIter:
    # Make *sure* the file index has the proper form.
    # g.trace(p.v.fileIndex)
    try:
        theId,t,n = p.v.fileIndex
    except ValueError:
        try:
            theId,t,n = p.v.fileIndex,''
        except Exception:
            raise BadLeoFile('bad p.v.fileIndex' % repr(p.v.fileIndex))

    if n is None:
        n = g.u('0')
    elif g.isPython3:
        n = str(n)
    else:
        n = unicode(n)
    index = theId,t,n
    tnodes[index] = p.v

# Put all tnodes in index order.
for index in sorted(tnodes):
    # g.trace(index)
    v = tnodes.get(index)
    if v:
        # Write only those tnodes whose vnodes were written.
        if v.isWriteBit():
            self.putTnode(v)
    else:
        g.trace('can not happen: no vnode for',repr(index))
        # This prevents the file from being written.
        raise BadLeoFile('no vnode for %s' % repr(index))
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@+node:ekr.20080805085257.2:pickle
def pickle (self,torv,val,tag):

    '''Pickle val and return the hexlified result.'''

    trace = False and g.unitTesting
    try:
        s = pickle.dumps(val,protocol=1)
        s2 = binascii.hexlify(s)
        s3 = g.ue(s2,'utf-8')
        if trace: g.trace('\n',
            type(val),val,'\n',type(s),repr(s),'\n',
            type(s2),s2,'\n',type(s3),s3)
        field = ' %s="%s"' % (tag,s3)
        return field

    except pickle.PicklingError:
        if tag: # The caller will print the error if tag is None.
            g.es_print("ignoring non-pickleable value",val,"in",torv,color="blue")
        return ''

    except Exception:
        g.es("fc.pickle: unexpected exception in",torv,color='red')
        g.es_exception()
        return ''
#@-node:ekr.20080805085257.2:pickle
#@-node:ekr.20091220131901.6366:leoFileCommands
#@-node:ekr.20091220131901.6364:Unicode bug
#@-node:ekr.20091203060018.6100:leo-3k
#@+node:ekr.20091211111443.6264:Batch operations on nodes
#@+node:ekr.20091211111443.6265:c.doBatchOperations & helpers
def doBatchOperations (self,aList):
    # Validate aList and create the parents dict
    ok, d = self.checkBatchOperationsList()
    if not ok:
        return g.es('do-batch-operations: invalid list argument',
            color='red')

    for v in list(d.keys()):
        aList2 = d.get(v,[])
        if aList2:
            aList.sort()
            for n,op in aList2:
                if op == 'insert':
                    g.trace('insert:',v.h,n)
                else:
                    g.trace('delete:',v.h,n)
#@+node:ekr.20091211111443.6266:checkBatchOperationsList
def checkBatchOperationsList(self,aList):
    ok = True ; d = {}
    for z in aList:
        try:
            op,p,n = z
            ok= (op in ('insert','delete') and
                isinstance(p,leoNodes.position) and
                type(n) == type(9))
            if ok:
                aList2 = d.get(p.v,[])
                data = n,op
                aList2.append(data)
                d[p.v] = aList2
        except ValueError:
            ok = False
        if not ok: break
    return ok,d
#@nonl
#@-node:ekr.20091211111443.6266:checkBatchOperationsList
#@-node:ekr.20091211111443.6265:c.doBatchOperations & helpers
#@+node:ekr.20091210082012.6231:Comparing positions
#@+node:ekr.20080416161551.190: p.__init__
def __init__ (self,v,childIndex=0,stack=None,trace=False):

    '''Create a new position with the given childIndex and parent stack.'''

    # To support ZODB the code must set v._p_changed = 1
    # whenever any mutable vnode object changes.

    self._childIndex = childIndex
    self.v = v

    # New in Leo 4.5: stack entries are tuples (v,childIndex).
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())

    self.txtOffset = None # see self.textOffset()
#@-node:ekr.20080416161551.190: p.__init__
#@+node:ekr.20080920052058.3:p.__eq__ & __ne__
def __eq__(self,p2):

    """Return True if two postions are equivalent."""

    p1 = self

    # Don't use g.trace: it might call p.__eq__ or p.__ne__.
    # print ('p.__eq__: %s %s' % (
        # p1 and p1.v and p1.h,p2 and p2.v and p2.h))

    if p2 is None or p2.v is None:
        return p1.v is None
    else:
        return ( p1.v == p2.v and
            p1._childIndex == p2._childIndex and
            p1.stack == p2.stack )

def __ne__(self,p2):

    """Return True if two postions are not equivalent."""

    return not self.__eq__(p2) # For possible use in Python 2.x.
#@-node:ekr.20080920052058.3:p.__eq__ & __ne__
#@+node:ekr.20091210082012.6230:p.__ge__ & __le__& __lt__
def __ge__ (self,other):

    return self.__eq__(other) or self.__gt__(other)

def __le__ (self,other):

    return self.__eq__(other) or self.__lt__(other)

def __lt__ (self,other):

    return not self.__eq__(other) and not self.__gt__(other)
#@-node:ekr.20091210082012.6230:p.__ge__ & __le__& __lt__
#@+node:ekr.20091210082012.6233:p.__gt__
def __gt__ (self,other):

    '''Return True if self appears after other in outline order.'''

    stack1,stack2 = self.stack,other.stack
    n1,n2 = len(stack1),len(stack2) ; n = min(n1,n2)
    # Compare the common part of the stacks.
    for item1,item2 in zip(stack1,stack2):
        v1,x1 = item1 ; v2,x2 = item2
        if x1 > x2: return True
        elif x1 < x2: return False
    # Finish the comparison.
    if n1 == n2:
        x1,x2 = self._childIndex,other._childIndex
        return x1 > x2
    elif n1 < n2:
        x1 = self._childIndex; v2,x2 = other.stack[n]
        return x1 > x2
    else:
        return True
#@nonl
#@-node:ekr.20091210082012.6233:p.__gt__
#@+node:ekr.20091210082012.6232:@test p rich comparison methods
if g.unitTesting:

    c,p = g.getTestVars()

    last = None

    for p in c.all_positions():
        if last:
            assert p > last,'%s <= %s' % (p.h,last.h)
        last = p.copy()
#@nonl
#@-node:ekr.20091210082012.6232:@test p rich comparison methods
#@+node:ekr.20080427062528.4:p._adjustPositionBeforeUnlink
def _adjustPositionBeforeUnlink (self,p2):

    '''Adjust position p before unlinking p2.'''

    # p will change if p2 is a previous sibling of p or
    # p2 is a previous sibling of any ancestor of p.

    trace = False and not g.unitTesting
    p = self ; sib = p.copy()

    if trace: g.trace('entry',p.stack)

    # A special case for previous siblings.
    # Adjust p._childIndex, not the stack's childIndex.
    while sib.hasBack():
        sib.moveToBack()
        if sib == p2:
            p._childIndex -= 1
            if trace: g.trace('***new index: %s\n%s' % (
                p.h,p.stack))
            return

    # Adjust p's stack.
    stack = [] ; changed = False ; i = 0
    while i < len(p.stack):
        v,childIndex = p.stack[i]
        p3 = position(v=v,childIndex=childIndex,stack=stack[:i])
        while p3:
            if p2.v == p3.v: # A match with the to-be-moved node?
                stack.append((v,childIndex-1),)
                changed = True
                break # terminate only the inner loop.
            p3.moveToBack()
        else:
            stack.append((v,childIndex),)
        i += 1

    if changed:
        if trace: g.trace('***new stack: %s\n%s' % (
            p.h,stack))
        p.stack = stack
#@nonl
#@+node:ekr.20090713125326.6116:@test p.adjustPositionBeforeUnlink
if g.unitTesting:

    c,p = g.getTestVars()

    table = (
        '1',
        '1-1','1-1-1','1-1-2',
        '1-2','1-2-1','1-2-2',
        '2',
        '2-1','2-1-1','2-1-2',
        '2-2','2-2-1','2-2-2',
        '3',
        '3-1','3-1-1','3-1-2',
        '3-2','3-2-1','3-2-2',
    )

    for suffix in table:
        h = 'node %s' % suffix
        p2 = g.findNodeInTree(c,p,h)
        assert p2,h

    table2 = (
        ('2-1-2','2-1-1','2-1-1'),
        ('3','2','2'),
    )  

    for h1,h2,h3 in table2:
        p1 = g.findNodeInTree(c,p,'node %s' % h1)
        p2 = g.findNodeInTree(c,p,'node %s' % h2)
        p3 = g.findNodeInTree(c,p,'node %s' % h3)
        p1._adjustPositionBeforeUnlink(p2)
        result = p1
        assert result.stack == p3.stack,'expected %s got %s' % (
            p3.h,result and result.h or '<none>')

    # Data.
    @others
#@+node:ekr.20090713125326.6117:node 1
# Node 1
#@nonl
#@+node:ekr.20090713125326.6118:node 1-1
# node 1-1
#@nonl
#@+node:ekr.20090713125326.6119:node 1-1-1
# node 1-1-1
#@nonl
#@-node:ekr.20090713125326.6119:node 1-1-1
#@+node:ekr.20090713125326.6135:node 1-1-2
# node 1-1-2
#@nonl
#@-node:ekr.20090713125326.6135:node 1-1-2
#@-node:ekr.20090713125326.6118:node 1-1
#@+node:ekr.20090713125326.6133:node 1-2
# node 1-2
#@nonl
#@+node:ekr.20090713125326.6134:node 1-2-1
# node 1-2-1
#@nonl
#@-node:ekr.20090713125326.6134:node 1-2-1
#@+node:ekr.20090713125326.6136:node 1-2-2
# node 1-2-2
#@nonl
#@-node:ekr.20090713125326.6136:node 1-2-2
#@-node:ekr.20090713125326.6133:node 1-2
#@-node:ekr.20090713125326.6117:node 1
#@+node:ekr.20090713125326.6124:node 2
# node 2
#@nonl
#@+node:ekr.20090713125326.6125:node 2-1
# node 2-1
#@nonl
#@+node:ekr.20090713125326.6126:node 2-1-1
# node 2-1-1
#@nonl
#@-node:ekr.20090713125326.6126:node 2-1-1
#@+node:ekr.20090713125326.6137:node 2-1-2
# node 2-1-2
#@-node:ekr.20090713125326.6137:node 2-1-2
#@-node:ekr.20090713125326.6125:node 2-1
#@+node:ekr.20090713125326.6142:node 2-2
# node 2-2
#@nonl
#@+node:ekr.20090713125326.6143:node 2-2-1
# node 2-2-1
#@nonl
#@-node:ekr.20090713125326.6143:node 2-2-1
#@+node:ekr.20090713125326.6144:node 2-2-2
# node 2-2-2
#@-node:ekr.20090713125326.6144:node 2-2-2
#@-node:ekr.20090713125326.6142:node 2-2
#@-node:ekr.20090713125326.6124:node 2
#@+node:ekr.20090713125326.6130:node 3
# node 3
#@nonl
#@+node:ekr.20090713125326.6131:node 3-1
# node 3-1
#@+node:ekr.20090713125326.6132:node 3-1-1
# node 3-1-1
#@nonl
#@-node:ekr.20090713125326.6132:node 3-1-1
#@+node:ekr.20090713125326.6138:node 3-1-2
# node 3-1-2
#@-node:ekr.20090713125326.6138:node 3-1-2
#@-node:ekr.20090713125326.6131:node 3-1
#@+node:ekr.20090713125326.6148:node 3-2
# node 3-2
#@+node:ekr.20090713125326.6149:node 3-2-1
# node 3-2-1
#@nonl
#@-node:ekr.20090713125326.6149:node 3-2-1
#@+node:ekr.20090713125326.6150:node 3-2-2
# node 3-2-2
#@-node:ekr.20090713125326.6150:node 3-2-2
#@-node:ekr.20090713125326.6148:node 3-2
#@-node:ekr.20090713125326.6130:node 3
#@-node:ekr.20090713125326.6116:@test p.adjustPositionBeforeUnlink
#@-node:ekr.20080427062528.4:p._adjustPositionBeforeUnlink
#@-node:ekr.20091210082012.6231:Comparing positions
#@-node:ekr.20091211111443.6264:Batch operations on nodes
#@+node:ekr.20091220103056.6363:pylint
@nocolor-node

pylint is a python script in /usr/bin

python is in /usr/lib/

pylint sources are **not** in /usr/lib/pymodules/python2.6
(these are just links !!)

Shared sources are in usr/share/pyshared/pylint

$ echo $PATH
/usr/local/sbin: (empty)
/usr/local/bin: (4 items, no leo)
/usr/sbin: (256 items, no leo)
/usr/bin: (1876 items, no leo)
/sbin: (162 items, no leo)
/bin: (118 items, no leo)
/usr/games (28 items, no leo)

_psyco.so is in /usr/local/lib/python2.6
#@nonl
#@+node:ekr.20050405141130:<< imports >> (leoFileCommands)
import leo.core.leoGlobals as g

if g.app and g.app.use_psyco:
    # g.pr("enabled psyco classes",__file__)
    try: from psyco.classes import *
    except ImportError: pass

import leo.core.leoNodes as leoNodes

import binascii

if g.isPython3:
    import io # Python 3.x
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    import cStringIO # Python 2.x
    StringIO = cStringIO.StringIO

import os
import pickle
import string
import sys
import types
import zipfile

try:
    # IronPython has problems with this.
    import xml.sax
    import xml.sax.saxutils
except Exception:
    pass

# The following is sometimes used.
# import time
#@-node:ekr.20050405141130:<< imports >> (leoFileCommands)
#@+node:ekr.20091220130303.6365:Linux messages
@nocolor-node

************* Module leo.core.leoApp
E0611:346:LeoApp.createDefaultGui: No name 'QtGui' in module 'PyQt4'
E1101:757:LeoApp.computeSignon: Module 'sys' has no 'getwindowsversion' member
************* Module leo.core.leoAtFile
E0211:4045:atFile.syntaxErrorTest: Method has no argument
************* Module leo.core.leoCommands
E1101:1079:baseCommands.openWith: Module 'os' has no 'startfile' member
************* Module leo.core.leoFileCommands
E1101:1066:baseFileCommands.cleanSaxInputString: Class 'str' has no 'maketrans' member
************* Module leo.core.leoGlobals
E1101:4249:os_startfile: Module 'os' has no 'startfile' member
E1101:5473:getpreferredencoding: Module '_locale' has no '_getdefaultlocale' member
#@-node:ekr.20091220130303.6365:Linux messages
#@-node:ekr.20091220103056.6363:pylint
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
