#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20090623072844.10385:4.6 rc1
#@+node:ekr.20090623072844.10386:Bugs
#@+node:ekr.20090623072844.10383:Fixed Tangle bug
#@+node:ekr.20090623072844.10384:Report
@nocolor-node

Oh yeah .... still won't tangle for me.

name = name.lower().name.replace('\t',' ').replace('  ',' ')

exception executing command
Traceback (most recent call last):
 File "C:\Leo-4-6-b2\leo\core\leoCommands.py", line 387, in doCommand
   val = command(event)
 File "C:\Leo-4-6-b2\leo\core\leoCommands.py", line 1476, in tangleAll
   c.tangleCommands.tangleAll()
 File "C:\Leo-4-6-b2\leo\core\leoTangle.py", line 604, in tangleAll
   ok = self.tangleTree(p,dont_report_errors)
 File "C:\Leo-4-6-b2\leo\core\leoTangle.py", line 723, in tangleTree
   self.tanglePass1(p) # sets self.p
 File "C:\Leo-4-6-b2\leo\core\leoTangle.py", line 671, in tanglePass1
   self.skip_body(p)
 File "C:\Leo-4-6-b2\leo\core\leoTangle.py", line 1142, in skip_body
   k, code = self.skip_code(s,j)
 File "C:\Leo-4-6-b2\leo\core\leoTangle.py", line 1217, in skip_code
   i, done = self.handle_newline(s,i)
 File "C:\Leo-4-6-b2\leo\core\leoTangle.py", line 997, in handle_newline
   self.st_enter_section_name(ref,None,None,unused_parts_flag)
 File "C:\Leo-4-6-b2\leo\core\leoTangle.py", line 2078, in
st_enter_section_name
   return self.st_enter(name,code,doc,multiple_parts_flag,not_root_name)
 File "C:\Leo-4-6-b2\leo\core\leoTangle.py", line 2018, in st_enter
   section = self.st_lookup(name,is_root_flag)
 File "C:\Leo-4-6-b2\leo\core\leoTangle.py", line 2088, in st_lookup
   key = self.standardize_name(name)
 File "C:\Leo-4-6-b2\leo\core\leoTangle.py", line 3393, in standardize_name
   name = name.lower().name.replace('\t',' ').replace('  ',' ')
AttributeError: 'unicode' object has no attribute 'name'
#@nonl
#@-node:ekr.20090623072844.10384:Report
#@+node:ekr.20031218072017.3598:standardize_name
def standardize_name (self,name):

    """Removes leading and trailing brackets, converts white space to a single blank and converts to lower case."""

    # Convert to lowercase.
    # Convert whitespace to a single space.
    name = name.lower().replace('\t',' ').replace('  ',' ')

    # Remove leading '<'
    i = 0 ; n = len(name)
    while i < n and name[i] == '<':
        i += 1
    j = i

    # Find the first '>'
    while i < n and name [i] != '>':
        i += 1
    name = string.strip(name[j:i])

    return name
#@-node:ekr.20031218072017.3598:standardize_name
#@-node:ekr.20090623072844.10383:Fixed Tangle bug
#@+node:ekr.20090624081006.8407:Restored print_mode init in tangle.scanAllDirectives
@nocolor-node

Except that now I am getting structure comments appearing in my
tangled code even with the @silent directive before my @root directive

eg: I now see amongst my tangled code

# << Rebol Header >> (1 of 3)

I didn't see this with 4.5.1 final which is what I have been using.

===

I rewrote scanAllDirectives, and the init of print_mode got deleted. 
#@nonl
#@+node:ekr.20090214075058.9:g.get_directives_dict (must be fast)
# The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

g_noweb_root = re.compile('<'+'<'+'*'+'>'+'>'+'=',re.MULTILINE)

def get_directives_dict(p,root=None):

    """Scan p for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    trace = False and not g.unitTesting

    if root: root_node = root[0]
    d = {}

    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat,re.MULTILINE)

    # The headline has higher precedence because it is more visible.
    for kind,s in (('body',p.h),('head',p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(0)[1:] # Omit the @
            i = m.start(0)
            if word.strip() not in d:
                j = i + 1 + len(word)
                k = g.skip_line(s,j)
                val = s[j:k].strip()
                if trace: g.trace(word,repr(val))
                d[word.strip()] = val

    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"]=0 # value not immportant
            else:
                g.es('%s= requires @root in the headline' % (
                    g.angleBrackets('*')))
            break

    if trace: g.trace('%4d' % (len(p.h) + len(p.b)),g.callers(5))
    return d
#@+node:ekr.20090214075058.10:compute_directives_re
def compute_directives_re ():

    '''Return an re pattern which will match all Leo directives.'''

    global globalDirectiveList

    aList = ['^@%s' % z for z in globalDirectiveList
                if z != 'others']

    # @others can have leading whitespace.
    aList.append(r'^\s@others')

    return '|'.join(aList)
#@-node:ekr.20090214075058.10:compute_directives_re
#@-node:ekr.20090214075058.9:g.get_directives_dict (must be fast)
#@+node:ekr.20090624081006.8422:tangle.scanAllDirectives (Leo 4.5.1)
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    # __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
    # For unit testing.
    return {
        "encoding"  : self.encoding,
        "language"  : self.language,
        "lineending": self.output_newline,
        "pagewidth" : self.page_width,
        "path"      : self.tangle_directory,
        "tabwidth"  : self.tab_width,
    }
#@+node:ekr.20090624081006.8423:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
#@-node:ekr.20090624081006.8423:<< Collect @first attributes >>
#@+node:ekr.20090624081006.8424:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
    pass # Do nothing more.

elif theDict.has_key("comment"):

    z = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(z)
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: @comment",z)

elif theDict.has_key("language"):

    z = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(z,0)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20090624081006.8424:<< Test for @comment and @language >>
#@+node:ekr.20090624081006.8425:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(theDict)
    if e:
        self.encoding = e
#@-node:ekr.20090624081006.8425:<< Test for @encoding >>
#@+node:ekr.20090624081006.8426:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20090624081006.8426:<< Test for @lineending >>
#@+node:ekr.20090624081006.8427:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20090624081006.8427:<< Test for print modes directives >>
#@+node:ekr.20090624081006.8428:<< Test for @path >> (tangle.scanAllDirectives)
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    path = theDict["path"]
    theDir = relative_path = g.computeRelativePath(path)

    if len(theDir) > 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20090624081006.8429:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir,c=c)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory:",base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive:",relative_path)
#@-node:ekr.20090624081006.8429:<< handle absolute @path >>
#@-node:ekr.20090624081006.8428:<< Test for @path >> (tangle.scanAllDirectives)
#@+node:ekr.20090624081006.8430:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@-node:ekr.20090624081006.8430:<< Test for @pagewidth >>
#@+node:ekr.20090624081006.8431:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):
    z = theDict["root"]
    self.setRootFromText(z,issue_error_flag)
#@-node:ekr.20090624081006.8431:<< Test for @root >>
#@+node:ekr.20090624081006.8432:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20090624081006.8432:<< Test for @tabwidth >>
#@+node:ekr.20090624081006.8433:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.

elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20090624081006.8433:<< Test for @header and @noheader >>
#@+node:ekr.20090624081006.8434:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # g.pr("root_dir:", root_dir)

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # g.pr("base,theDir:",base,theDir)
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20090624081006.8435:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir,c=c)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory:",base)
        if dir2 and len(dir2) > 0:
            g.es('',kind,"directory:",dir2)
#@-node:ekr.20090624081006.8435:<< handle absolute path >>
#@-node:ekr.20090624081006.8434:<< Set self.tangle_directory >>
#@-node:ekr.20090624081006.8422:tangle.scanAllDirectives (Leo 4.5.1)
#@+node:ekr.20080923124254.16:tangle.scanAllDirectives
def scanAllDirectives(self,p,require_path_flag,issue_error_flag):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    self.init_directive_ivars()
    if p:
        s = p.b
        << Collect @first attributes >>

    # delims = (self.single_comment_string,self.start_comment_string,self.end_comment_string)
    lang_dict = {'language':self.language,'delims':None,} # Delims not used

    table = (
        ('encoding',    self.encoding,  g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives), 
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process.
    lang_dict       = d.get('lang-dict')
    lineending      = d.get('lineending')
    if lineending:
        self.output_newline = lineending
    self.encoding             = d.get('encoding')
    self.language             = lang_dict.get('language')
    self.page_width           = d.get('pagewidth')
    self.default_directory    = d.get('path')
    self.tab_width            = d.get('tabwidth')

    # Handle the print-mode directives.
    self.print_mode = None
    for d in aList:
        for key in ('verbose','terse','quiet','silent'):
            if d.get(key) is not None:
                self.print_mode = key ; break
        if self.print_mode: break
    if not self.print_mode: self.print_mode = 'verbose'

    # For unit testing.
    return {
        "encoding"  : self.encoding,
        "language"  : self.language,
        "lineending": self.output_newline,
        "pagewidth" : self.page_width,
        "path"      : self.default_directory,
        "tabwidth"  : self.tab_width,
    }
#@+node:ekr.20080923124254.17:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
#@-node:ekr.20080923124254.17:<< Collect @first attributes >>
#@-node:ekr.20080923124254.16:tangle.scanAllDirectives
#@-node:ekr.20090624081006.8407:Restored print_mode init in tangle.scanAllDirectives
#@+node:ekr.20090626123815.5989:Fixed unicode problem with spell checker
#@+node:ekr.20070228074228.1:class stringTextWidget (baseTextWidget)
class stringTextWidget (baseTextWidget):

    '''A class that represents text as a Python string.'''

    @others
#@+node:ekr.20070228074228.2:ctor
def __init__ (self,c,name):

    # Init the base class
    baseTextWidget.__init__ (self,c=c,
        baseClassName='stringTextWidget',name=name,widget=None)

    self.ins = 0
    self.sel = 0,0
    self.s = ''
    self.trace = False
#@-node:ekr.20070228074228.2:ctor
#@+node:ekr.20070228074228.3:Overrides
def _appendText(self,s):
    #if self.trace: g.trace(self,'len(s)',len(s))
    if self.trace: g.trace(self,'ins',self.ins,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    self.s = self.s + s
    self.ins = len(self.s)
    self.sel = self.ins,self.ins
def _get(self,i,j):                 return self.s[i:j]
def _getAllText(self):              return self.s
def _getFocus(self):                return self
def _getInsertPoint(self):
    # if self.trace: g.trace(self,self.ins)
    return self.ins
def _getLastPosition(self):         return len(self.s)
def _getSelectedText(self):         i,j = self.sel ; return self.s[i:j]
def _getSelectionRange(self):       return self.sel
def _getYScrollPosition(self):      return None # A flag.
def _hitTest(self,pos):             pass
def _insertText(self,i,s):
    s1 = s
    self.s = self.s[:i] + s1 + self.s[i:]
    # if self.trace: g.trace(self,'s',repr(s),'self.s',repr(self.s))
    # if self.trace: g.trace(self,'i',i,'len(s)',len(s),g.callers())
    if self.trace: g.trace(self,'i',i,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    i += len(s1)
    self.ins = i
    self.sel = i,i
def _scrollLines(self,n):           pass
def _see(self,i):                   pass
def _setAllText(self,s):
    if self.trace: g.trace(self,'len(s)',len(s),g.callers())
    if self.trace: g.trace(self,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i,i
def _setBackgroundColor(self,color): pass
def _setForegroundColor(self,color): pass
def _setFocus(self):                pass
def _setInsertPoint(self,i):
    if self.trace: g.trace(self,'i',i)
    self.ins = i
    self.sel = i,i
#@nonl
#@-node:ekr.20070228074228.3:Overrides
#@+node:ekr.20070228111853:setSelectionRange (stringText)
def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    self.sel = i,j

    if insert is not None: 
        self.ins = w.toPythonIndex(insert)
    else:
        self.ins = j

    if self.trace: g.trace('i',i,'j',j,'insert',repr(insert))
#@nonl
#@-node:ekr.20070228111853:setSelectionRange (stringText)
#@-node:ekr.20070228074228.1:class stringTextWidget (baseTextWidget)
#@+node:ekr.20051020120306.6:class findTab (leoFind)
class findTab (leoFind):

    '''An adapter class that implements Leo's Find tab.'''

    @others
#@+node:ekr.20051020120306.11:__init__ & initGui
def __init__(self,c,parentFrame):

    # g.trace('findTab',c)

    # Init the base class...
    leoFind.__init__(self,c,title='Find Tab')

    self.c = c
    self.parentFrame = parentFrame
    self.frame = self.outerFrame = self.top = None

    self.optionsOnly = c.config.getBool('show_only_find_tab_options')

    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.initGui()
    self.createFrame(parentFrame)
    self.createBindings()
    self.init(c) # New in 4.3: init only once.
#@-node:ekr.20051020120306.11:__init__ & initGui
#@+node:ekr.20060221074900:Callbacks
#@+node:ekr.20060221074900.1:findButtonCallback
def findButtonCallback(self,event=None):

    self.findButton()
    return 'break'
#@-node:ekr.20060221074900.1:findButtonCallback
#@+node:ekr.20051020120306.25:hideTab
def hideTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@-node:ekr.20051020120306.25:hideTab
#@-node:ekr.20060221074900:Callbacks
#@+node:ekr.20051024192602: Top level
#@+node:ekr.20051024192642.3:change/ThenFindCommand
def changeCommand (self,event=None):

    self.setup_command()
    self.change()

def changeThenFindCommand(self,event=None):

    self.setup_command()
    self.changeThenFind()
#@-node:ekr.20051024192642.3:change/ThenFindCommand
#@+node:ekr.20070105123638:changeAllCommand
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
#@-node:ekr.20070105123638:changeAllCommand
#@+node:ekr.20060128075225:cloneFindAllCommand
def cloneFindAllCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@-node:ekr.20060128075225:cloneFindAllCommand
#@+node:ekr.20060204120158.1:findAgainCommand
def findAgainCommand (self):

    s = self.find_ctrl.getAllText()

    if s and s != '<find pattern here>':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
#@-node:ekr.20060204120158.1:findAgainCommand
#@+node:ekr.20060209064832:findAllCommand
def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
#@-node:ekr.20060209064832:findAllCommand
#@+node:ekr.20051024192642.2:findNext/PrefCommand
def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()

def findPrevCommand (self,event=None):

    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
#@-node:ekr.20051024192642.2:findNext/PrefCommand
#@-node:ekr.20051024192602: Top level
#@+node:ekr.20061212092124:Defined in subclasses
def createBindings (self):
    self.oops()

def createFrame (self,parent):
    self.oops()

def getOption (self,ivar):
    self.oops()

def init (self,c):
    self.oops()

def initGui (self):
    pass # Optional method.

def setOption (self,ivar,val):
    self.oops()

def toggleOption (self,ivar):
    self.oops()

# self.oops is defined in the leoFind class.
#@-node:ekr.20061212092124:Defined in subclasses
#@-node:ekr.20051020120306.6:class findTab (leoFind)
#@+node:ekr.20061212084717:class leoFind
class leoFind:

    """The base class for Leo's Find commands."""

    @others
#@+node:ekr.20031218072017.3053:leoFind.__init__ & helpers
def __init__ (self,c,title=None):

    self.c = c
    self.trace = False

    # g.trace('leoFind',c)

    # Spell checkers use this class, so we can't always compute a title.
    if title:
        self.title = title
    else:
        << compute self.title >>

    << init the gui-independent ivars >>

def init (self,c):
    self.oops()
#@+node:ekr.20041121145452:<< compute self.title >>
if not c.mFileName:
    s = "untitled"
else:
    path,s = g.os_path_split(c.mFileName)

self.title = "Find/Change for %s" %  s
#@-node:ekr.20041121145452:<< compute self.title >>
#@+node:ekr.20031218072017.3054:<< init the gui-independent ivars >>
self.backwardAttempts = 0
self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False
self.re_obj = None

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated by update_ivars just before doing any find.
@c

<< do dummy initialization to keep Pychecker happy >>

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = searchWidget() # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos >= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
#@+node:ekr.20050123164539:<< do dummy initialization to keep Pychecker happy >>
if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.wrap = None
    self.whole_word = None

if 1:
    self.change_ctrl = None
    self.find_ctrl = None
    self.frame = None
    self.svarDict = {}
#@-node:ekr.20050123164539:<< do dummy initialization to keep Pychecker happy >>
#@-node:ekr.20031218072017.3054:<< init the gui-independent ivars >>
#@-node:ekr.20031218072017.3053:leoFind.__init__ & helpers
#@+node:ekr.20060123065756.1:Top Level Buttons
#@+node:ekr.20031218072017.3057:changeAllButton
# The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_change:
        self.doChangeAllScript()
    else:
        self.changeAll()
#@-node:ekr.20031218072017.3057:changeAllButton
#@+node:ekr.20031218072017.3056:changeButton
# The user has pushed the "Change" button from the find panel.

def changeButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
    else:
        self.change()
#@-node:ekr.20031218072017.3056:changeButton
#@+node:ekr.20031218072017.3058:changeThenFindButton
# The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
        if self.script_search:
            self.doFindScript()
        else:
            self.findNext()
    else:
        if self.script_search:
            self.change()
            self.doFindScript()
        else:
            self.changeThenFind()
#@-node:ekr.20031218072017.3058:changeThenFindButton
#@+node:ekr.20031218072017.3060:findAllButton
# The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    else:
        self.findAll()
#@-node:ekr.20031218072017.3060:findAllButton
#@+node:ekr.20031218072017.3059:findButton
# The user has pushed the "Find" button from the find panel.

def findButton(self):

    self.setup_button()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
#@-node:ekr.20031218072017.3059:findButton
#@+node:ekr.20031218072017.3065:setup_button
# Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

    c = self.c
    self.p = c.p

    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()

    self.update_ivars()
#@-node:ekr.20031218072017.3065:setup_button
#@-node:ekr.20060123065756.1:Top Level Buttons
#@+node:ekr.20031218072017.3055:Top Level Commands
#@+node:ekr.20031218072017.3061:changeCommand
# The user has selected the "Replace" menu item.

def changeCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
    else:
        self.change()
#@-node:ekr.20031218072017.3061:changeCommand
#@+node:ekr.20031218072017.3062:changeThenFindCommand
# The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
        self.doFindScript()
    else:
        self.changeThenFind()
#@-node:ekr.20031218072017.3062:changeThenFindCommand
#@+node:ekr.20051013084200.1:dismiss: defined in subclass class
def dismiss (self):
    pass
#@-node:ekr.20051013084200.1:dismiss: defined in subclass class
#@+node:ekr.20031218072017.3063:findNextCommand
# The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
#@-node:ekr.20031218072017.3063:findNextCommand
#@+node:ekr.20031218072017.3064:findPreviousCommand
# The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

    self.setup_command()

    self.reverse = not self.reverse

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()

    self.reverse = not self.reverse
#@-node:ekr.20031218072017.3064:findPreviousCommand
#@+node:EKR.20040503070514:handleUserClick
def handleUserClick (self,p):

    """Reset suboutline-only search when the user clicks a headline."""

    try:
        if self.c and self.suboutline_only:
            # g.trace(p)
            self.onlyPosition = p.copy()
    except: pass
#@-node:EKR.20040503070514:handleUserClick
#@+node:ekr.20031218072017.3066:setup_command
# Initializes a search when a command is invoked from the menu.

def setup_command(self):

    # g.trace('leoFind')

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()

    self.update_ivars()
#@-node:ekr.20031218072017.3066:setup_command
#@-node:ekr.20031218072017.3055:Top Level Commands
#@+node:ekr.20031218072017.3067:Find/change utils
#@+node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; w = self.s_ctrl
    # Replace the selection with self.change_text
    if pos1 > pos2: pos1,pos2=pos2,pos1
    s = w.getAllText()
    if pos1 != pos2: w.delete(pos1,pos2)
    w.insert(pos1,self.change_text)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+len(self.change_text))
    w.setSelectionRange(insert,insert)
    w.setInsertPoint(insert)
    # Update the node
    s = w.getAllText() # Used below.
    if self.in_headline:
        << change headline >>
    else:
        << change body >>
#@+node:ekr.20031218072017.2294:<< change headline >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.h:

    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Headline',undoData)
#@-node:ekr.20031218072017.2294:<< change headline >>
#@+node:ekr.20031218072017.2295:<< change body >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.b:

    undoData = u.beforeChangeNodeContents(p)

    c.setBodyString(p,s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Body',undoData)
#@-node:ekr.20031218072017.2295:<< change body >>
#@-node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
#@+node:ekr.20031218072017.3068:change
def change(self,event=None):

    if self.checkArgs():
        self.initInHeadline()
        self.changeSelection()
#@-node:ekr.20031218072017.3068:change
#@+node:ekr.20031218072017.3069:changeAll (leoFind)
def changeAll(self):

    # g.trace('leoFind',g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.p
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    u.beforeChangeGroup(current,undoType)
    while 1:
        pos1, pos2 = self.findNextMatch()
        if pos1 is None: break
        count += 1
        self.batchChange(pos1,pos2)
        s = w.getAllText()
        i,j = g.getLine(s,pos1)
        line = s[i:j]
        # self.printLine(line,allFlag=True)
    p = c.p
    u.afterChangeGroup(p,undoType,reportFlag=True)
    g.es("changed:",count,"instances")
    c.redraw(p)
    self.restore(saveData)
#@-node:ekr.20031218072017.3069:changeAll (leoFind)
#@+node:ekr.20031218072017.3070:changeSelection
# Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p
    bodyCtrl = c.frame.body and c.frame.body.bodyCtrl
    w = g.choose(self.in_headline,c.edit_widget(p),bodyCtrl)
    if not w:
        self.in_headline = False
        w = bodyCtrl
    if not w: return

    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start > end: start,end = end,start
    if start == end:
        g.es("no text selected") ; return False

    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text

    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    if self.mark_changes:
        p.setMarked()
    if self.in_headline:
        c.frame.tree.onHeadChanged(p,'Change')
    else:
        c.frame.body.onBodyChanged('Change',oldSel=oldSel)

    c.frame.tree.drawIcon(p) # redraw only the icon.

    return True
#@+node:ekr.20060526201951:makeRegexSubs
def makeRegexSubs(self,s,groups):

    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''

    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j < n:
        k = s.find('\\',j)
        if k == -1 or k + 1 >= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn < len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
#@-node:ekr.20060526201951:makeRegexSubs
#@-node:ekr.20031218072017.3070:changeSelection
#@+node:ekr.20031218072017.3071:changeThenFind
def changeThenFind(self):

    if not self.checkArgs():
        return

    self.initInHeadline()
    if self.changeSelection():
        self.findNext(False) # don't reinitialize
#@-node:ekr.20031218072017.3071:changeThenFind
#@+node:ekr.20031218072017.2417:doChange...Script
def doChangeScript (self):

    g.app.searchDict["type"] = "change"
    self.runChangeScript()

def doChangeAllScript (self):

    """The user has just pressed the Change All button with script-change box checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "changeAll"
    while 1:
        self.runChangeScript()
        if not g.app.searchDict.get("continue"):
            break

def runChangeScript (self):

    try:
        assert(self.script_change)
        exec(self.change_text,{},{})
    except Exception:
        g.es("exception executing change script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
#@-node:ekr.20031218072017.2417:doChange...Script
#@+node:ekr.20031218072017.3072:doFind...Script
def doFindScript (self):

    g.app.searchDict["type"] = "find"
    self.runFindScript()

def doFindAllScript (self):

    """The user has just pressed the Find All button with script-find radio button checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "findAll"
    while 1:
        self.runFindScript()
        if not g.app.searchDict.get("continue"):
            break

def runFindScript (self):

    try:
        exec(self.find_text,{},{})
    except:
        g.es("exception executing find script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
#@-node:ekr.20031218072017.3072:doFind...Script
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.h)
            if not clones:
                undoData = u.beforeInsertNode(c.p)
                << create the found node >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>

    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")
#@+node:ekr.20051113110735:<< create the found node >>
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
#@-node:ekr.20051113110735:<< create the found node >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
q = self.p.clone()
q.moveToLastChildOf(found)
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20031218072017.3074:findNext
def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos is None:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found","'%s'" % (self.find_text))
        self.restore(data)
    else:
        self.showSuccess(pos,newpos)
#@-node:ekr.20031218072017.3074:findNext
#@+node:ekr.20031218072017.3075:findNextMatch
# Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    trace = False and not g.unitTesting
    c = self.c ; p = self.p

    if trace: g.trace('entry','p',p and p.h,
        'search_headline',self.search_headline,
        'search_body',self.search_body)

    if not self.search_headline and not self.search_body:
        if trace: g.trace('nothing to search')
        return None, None

    if len(self.find_text) == 0:
        if trace: g.trace('no find text')
        return None, None

    self.errors = 0
    attempts = 0
    self.backwardAttempts = 0

    # New in Leo 4.4.8: precompute the regexp for regexHelper.
    if self.pattern_match:
        try: # Precompile the regexp.
            flags = re.MULTILINE
            if self.ignore_case: flags |= re.IGNORECASE
            # New in Leo 4.5: escape the search text.
            self.re_obj = re.compile(self.find_text,flags)
            # self.re_obj = re.compile(re.escape(self.find_text),flags)
        except Exception:
            g.es('invalid regular expression:',self.find_text,color='blue')
            self.errors += 1 # Abort the search.
            return None,None

    while p:
        pos, newpos = self.search()
        if trace: g.trace('attempt','pos',pos,'p',p.h,'in_headline',self.in_headline)
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            if trace: g.trace('success',pos,newpos)
            return pos, newpos
        elif self.errors:
            g.trace('find errors')
            return None,None # Abort the search.
        elif self.node_only:
            # Bug fix: 2009-5-31.
            # Attempt to switch from headline to body.
            if self.in_headline:
                self.in_headline = False
                self.initNextText()
            else: 
                if trace: g.trace('fail: node only')
                return None,None # We are only searching one node.
        else:
            if trace: g.trace('failed attempt',p)
            attempts += 1
            p = self.p = self.selectNextPosition()

    if trace: g.trace('attempts',attempts,'backwardAttempts',self.backwardAttempts)
    return None, None
#@-node:ekr.20031218072017.3075:findNextMatch
#@+node:ekr.20031218072017.3076:resetWrap
def resetWrap (self,event=None):

    self.wrapPosition = None
    self.onlyPosition = None
#@-node:ekr.20031218072017.3076:resetWrap
#@+node:ekr.20031218072017.3077:search & helpers
def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.

    Returns (pos, newpos) or (None,None)."""

    trace = False and not g.unitTesting
    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()
    s = w.getAllText()

    if trace: g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)

    if trace: g.trace('pos,newpos',pos,newpos)
    if pos == -1:
        if trace: g.trace('** pos is -1',pos,newpos)
        return None,None
    << fail if we are passed the wrap point >>
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)

    if trace: g.trace('** returns',pos,newpos)
    return pos,newpos
#@+node:ekr.20060526140328:<< fail if we are passed the wrap point >>
if self.wrapping and self.wrapPos is not None and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos < self.wrapPos:
        if trace: g.trace("** reverse wrap done",pos,newpos)
        return None, None

    if not self.reverse and newpos > self.wrapPos:
        if trace: g.trace('** wrap done',pos,newpos)
        return None, None
#@-node:ekr.20060526140328:<< fail if we are passed the wrap point >>
#@+node:ekr.20060526081931:searchHelper & allies
def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):

    trace = self.trace

    if swapij and backwards: i,j = j,i

    if trace: g.trace('back,nocase,regexp,word,',
        backwards,nocase,regexp,word,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        if trace: g.trace('empty',i,j,'len(s)',len(s),'pattern',pattern)
        return -1,-1

    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    if trace: g.trace('returns',pos,newpos)
    return pos,newpos
#@+node:ekr.20060526092203:regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):

    re_obj = self.re_obj # Use the pre-compiled object
    if not re_obj:
        g.trace('can not happen: no re_obj')
        return -1,-1

    if backwards: # Scan to the last match.  We must use search here.
        last_mo = None ; i = 0
        while i < len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1 ; last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)

    if 0:
        g.trace('i',i,'j',j,'s[i:j]',repr(s[i:j]),
            'mo.start',mo and mo.start(),'mo.end',mo and mo.end())

    while mo and 0 <= i < len(s):
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 <= i < len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
#@-node:ekr.20060526092203:regexHelper
#@+node:ekr.20060526140744:backwardsHelper
debugIndices = []

@
rfind(sub [,start [,end]])

Return the highest index in the string where substring sub is found, such that
sub is contained within s[start,end]. Optional arguments start and end are
interpreted as in slice notation. Return -1 on failure.
@c

def backwardsHelper (self,s,i,j,pattern,nocase,word):

    debug = False
    if nocase:
        s = s.lower() ; pattern = pattern.lower() # Bug fix: 10/5/06: At last the bug is found!
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)

    if i < 0 or i > len(s) or j < 0 or j > len(s):
        g.trace('bad index: i = %s, j = %s' % (i,j))
        i = 0 ; j = len(s)

    if debug and (s and i == 0 and j == 0):
        g.trace('two zero indices')

    self.backwardAttempts += 1

    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        if debug:
            self.debugCount += 1
            if self.debugCount < 50:
                g.trace(i,j,'len(s)',len(s),self.p.h)
        return -1,-1

    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            if debug: g.trace('**word** %3s %3s %5s -> %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.h))
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        if debug: g.trace('%3s %3s %5s -> %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.h))
        if k == -1:
            return -1, -1
        else:
            return k,k+n
#@-node:ekr.20060526140744:backwardsHelper
#@+node:ekr.20060526093531:plainHelper
def plainHelper (self,s,i,j,pattern,nocase,word):

    trace = self.trace

    # if trace: g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if trace: g.trace(i,j,repr(s[i:i+20]))

    if nocase:
        s = s.lower() ; pattern = pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1:
                if trace: g.trace('no match word',i)
                return -1, -1
            elif self.matchWord(s,k,pattern):
                if trace: g.trace('match word',k)
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            if trace: g.trace('no match word',i)
            return -1, -1
        else:
            if trace: g.trace('match', k)
            return k, k + n
#@-node:ekr.20060526093531:plainHelper
#@+node:ekr.20060526140744.1:matchWord
def matchWord(self,s,i,pattern):

    trace = self.trace

    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        if trace: g.trace('empty')
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 <= i-1 < len(s) and s[i-1] or '.'
    ch2 = 0 <= i+n < len(s) and s[i+n] or '.'

    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)

    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))

    inWord = isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2
    if trace: g.trace('returns',not inWord)
    return not inWord

#@-node:ekr.20060526140744.1:matchWord
#@+node:ekr.20070105165924:replaceBackSlashes
def replaceBackSlashes (self,s):

    '''Carefully replace backslashes in a search pattern.'''

    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.

    i = 0
    while i + 1 < len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1

    if self.trace: g.trace(repr(s))
    return s
#@-node:ekr.20070105165924:replaceBackSlashes
#@-node:ekr.20060526081931:searchHelper & allies
#@-node:ekr.20031218072017.3077:search & helpers
#@+node:ekr.20031218072017.3081:selectNextPosition
# Selects the next node to be searched.

def selectNextPosition(self):

    trace = False and not g.unitTesting
    c = self.c ; p = self.p

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        if trace: g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()

    # if trace: g.trace(p and p.h or 'None')

    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        if trace: g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
#@-node:ekr.20031218072017.3081:selectNextPosition
#@-node:ekr.20031218072017.3067:Find/change utils
#@+node:ekr.20061212095134.1:General utils
#@+node:ekr.20051020120306.26:bringToFront (leoFind)
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; w = self.find_ctrl

    g.trace(g.callers(4))

    c.widgetWantsFocusNow(w)
    # g.app.gui.selectAllText(w)
    w.selectAllText()
    c.widgetWantsFocus(w)
#@-node:ekr.20051020120306.26:bringToFront (leoFind)
#@+node:ekr.20061111084423.1:oops (leoFind)
def oops(self):
    g.pr(("leoFind oops:",
        g.callers(10),"should be overridden in subclass"))
#@-node:ekr.20061111084423.1:oops (leoFind)
#@+node:ekr.20051020120306.27:selectAllFindText (leoFind)
def selectAllFindText (self,event=None):

    # This is called only when the user presses ctrl-a in the find panel.

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        w.selectAllText()

    return "break"
#@-node:ekr.20051020120306.27:selectAllFindText (leoFind)
#@-node:ekr.20061212095134.1:General utils
#@+node:ekr.20031218072017.3082:Initing & finalizing
#@+node:ekr.20031218072017.3083:checkArgs
def checkArgs (self):

    val = True
    if not self.search_headline and not self.search_body:
        g.es("not searching headline or body")
        val = False
    if len(self.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val
#@-node:ekr.20031218072017.3083:checkArgs
#@+node:ekr.20031218072017.3084:initBatchCommands
# Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c
    self.in_headline = self.search_headline # Search headlines first.
    self.errors = 0

    # Select the first node.
    if self.suboutline_only or self.node_only:
        self.p = c.p
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p

    # Set the insert point.
    self.initBatchText()
#@-node:ekr.20031218072017.3084:initBatchCommands
#@+node:ekr.20031218072017.3085:initBatchText, initNextText & init_s_ctrl
# Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self,ins=None):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.h, p.b)
    self.init_s_ctrl(s,ins)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self,ins=None):
    c,p = self.c,self.p
    s = g.choose(self.in_headline,p.h, p.b)
    if True:
        tree = c.frame and c.frame.tree
        if tree and hasattr(tree,'killEditing'):
            # g.trace('kill editing before find')
            tree.killEditing()
    self.init_s_ctrl(s,ins)

def init_s_ctrl (self,s,ins):

    w = self.s_ctrl
    w.setAllText(s)
    if ins is None:
        ins = g.choose(self.reverse,len(s),0)
        # print(g.choose(self.reverse,'.','*'),)
    else:
        pass # g.trace('ins',ins)
    w.setInsertPoint(ins)
#@-node:ekr.20031218072017.3085:initBatchText, initNextText & init_s_ctrl
#@+node:ekr.20031218072017.3086:initInHeadline
# Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    trace = False
    c = self.c ; p = self.p

    # Do not change this without careful thought and extensive testing!
    if self.search_headline and self.search_body:
        # A temporary expedient.
        if self.reverse:
            self.in_headline = False
        else:
            editPosition = c.frame.tree.editPosition()
            focus = c.get_focus()
            # Search headline first.
            self.in_headline = (
                p == editPosition and
                focus != c.frame.body.bodyCtrl)
            if trace: g.trace(
                '** p: %s, editPosition: %s, focus: %s, bodyCtrl: %s' % (
                p and p.h,editPosition,focus, c.frame.body.bodyCtrl))
    else:
        self.in_headline = self.search_headline
#@nonl
#@-node:ekr.20031218072017.3086:initInHeadline
#@+node:ekr.20031218072017.3087:initInteractiveCommands
def initInteractiveCommands(self):

    c = self.c ; p = self.p
    bodyCtrl = c.frame.body and c.frame.body.bodyCtrl

    w = g.choose(self.in_headline,c.edit_widget(p),bodyCtrl)
    if not w:
        self.in_headline = False
        w = bodyCtrl
    if not w: return

    self.errors = 0

    # We only use the insert point, *never* the selection range.
    ins = w.getInsertPoint()
    # g.trace('ins',ins)
    self.debugCount = 0
    self.initNextText(ins=ins)
    c.widgetWantsFocus(w)

    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = ins
        # Do not set self.wrapPosition here: that must be done after the first search.
#@-node:ekr.20031218072017.3087:initInteractiveCommands
#@+node:ekr.20031218072017.3088:printLine
def printLine (self,line,allFlag=False):

    both = self.search_body and self.search_headline
    context = self.batch # "batch" now indicates context

    if allFlag and both and context:
        g.es('','-' * 20,'',self.p.h)
        theType = g.choose(self.in_headline,"head: ","body: ")
        g.es('',theType + line)
    elif allFlag and context and not self.p.isVisited():
        # We only need to print the context once.
        g.es('','-' * 20,'',self.p.h)
        g.es('',line)
        self.p.setVisited()
    else:
        g.es('',line)
#@-node:ekr.20031218072017.3088:printLine
#@+node:ekr.20031218072017.3089:restore
# Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data

    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    if p:
        c.selectPosition(p)
    else:
        c.selectPosition(c.rootPosition()) # New in Leo 4.5.

    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()

    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        c.k.showStateAndMode(c.frame.body.bodyCtrl)
    else:
        c.widgetWantsFocusNow(t)
#@nonl
#@-node:ekr.20031218072017.3089:restore
#@+node:ekr.20031218072017.3090:save (leoFind)
def save (self):

    c = self.c ; p = self.p

    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)

    if w:
        insert = w.getInsertPoint()
        sel = w.getSelectionRange()
        if len(sel) == 2:
            start,end = sel
        else:
            start,end = None,None
    else:
        insert,start,end = None,None,None

    return (self.in_headline,p,w,insert,start,end)
#@-node:ekr.20031218072017.3090:save (leoFind)
#@+node:ekr.20031218072017.3091:showSuccess (leoFind)
def showSuccess(self,pos,newpos,showState=True):

    '''Display the result of a successful find operation.'''

    trace = False
    c = self.c ; p = self.p
    if not p:
        return g.trace('can not happen: self.p is None')

    current = c.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac

    # Expand ancestors and set redraw if a redraw is needed.
    redraw1 = not p.isVisible(c)
    if sparseFind:
        # Show only the 'sparse' tree when redrawing.
        for p2 in c.p.self_and_parents_iter():
            if p2.isAncestorOf(p):
                break
            p2.contract()
            redraw1 = True # Important bug fix. Was redraw = True.

    redraw2 = c.expandAllAncestors(self.p)
    redraw = redraw1 or redraw2

    # Set state vars.
    # Ensure progress in backwards searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p

    if trace: g.trace('in_headline',self.in_headline)
    if self.in_headline:
        selection = pos,newpos,insert
        c.redrawAndEdit(p,
            selection=selection,
            keepMinibuffer=True)
        w = c.edit_widget(p)
    else:
        w = c.frame.body.bodyCtrl
        # This is like the logic in c.selectPosition.
        if redraw:
            c.redraw(p)
        else:
            c.selectPosition(p)
            c.redraw_after_select(p)
        c.bodyWantsFocus()
        if showState:
            c.k.showStateAndMode(w)
        # g.trace(pos,newpos,insert)
        w.setSelectionRange(pos,newpos,insert=insert)
        w.seeInsertPoint()
        c.outerUpdate()
    return w # Support for isearch.
#@-node:ekr.20031218072017.3091:showSuccess (leoFind)
#@+node:ekr.20031218072017.1460:update_ivars (leoFind)
# New in Leo 4.4.3: This is now gui-independent code.

def update_ivars (self):

    """Called just before doing a find to update ivars from the find panel."""

    trace = False and not g.unitTesting

    self.p = self.c.p
    self.v = self.p.v

    for key in self.intKeys:
        # g.trace(self.svarDict.get(key))
        val = self.svarDict[key].get()
        setattr(self, key, val) # No more _flag hack.

    # Set ivars from radio buttons. Convert these to 1 or 0.
    search_scope = self.svarDict["radio-search-scope"].get()
    # g.trace('radio-search-scope',search_scope)
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0)

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.getAllText()
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.getAllText()
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@-node:ekr.20031218072017.1460:update_ivars (leoFind)
#@-node:ekr.20031218072017.3082:Initing & finalizing
#@-node:ekr.20061212084717:class leoFind
#@+node:ekr.20090626123815.5990:Report
@nocolor-node

ubuntu 9.04, qt, py 2.6.2, current trunk

Running into a word like relev makes the spell checker:

Traceback (most recent call last):
  File "/mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/leo/core/leoEditCommands.py", line 8463, in findNextMisspelledWord
    alts = aspell.processWord(word)
  File "/mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/leo/core/leoEditCommands.py", line 8734, in processWord
    if self.check(self.spell_checker,word,len(word)):
ArgumentError: argument 2: <type 'exceptions.UnicodeEncodeError'>: 'ascii' codec can't encode character u'\xe9' in position 5: ordinal not in range(128)
no more misspellings
#@nonl
#@-node:ekr.20090626123815.5990:Report
#@+node:ekr.20051025071455:Spell classes
@others
#@+node:ekr.20051025071455.1:class spellCommandsClass
class spellCommandsClass (baseEditCommandsClass):

    '''Commands to support the Spell Tab.'''

    @others
#@+node:ekr.20051025080056:ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.handler = None

    # All the work happens when we first open the frame.
#@-node:ekr.20051025080056:ctor
#@+node:ekr.20051025080420:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):

    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
#@-node:ekr.20051025080420:getPublicCommands (searchCommandsClass)
#@+node:ekr.20051025080633:openSpellTab
def openSpellTab (self,event=None):

    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        self.handler = spellTabHandler(c,tabName)
        if not self.handler.loaded:
            log.deleteTab(tabName,force=True)
#@-node:ekr.20051025080633:openSpellTab
#@+node:ekr.20051025080420.1:commands...(spellCommandsClass)
# Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.
# self.handler is a spellTabHandler object (inited by openSpellTab)

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        # A workaround for a pylint warning:
        # self.handler.changeThenFind()
        f = getattr(self.handler,'changeThenFind')
        f()
    else:
        self.openSpellTab()

def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
#@-node:ekr.20051025080420.1:commands...(spellCommandsClass)
#@-node:ekr.20051025071455.1:class spellCommandsClass
#@+node:ekr.20051025071455.18:class spellTabHandler (leoFind.leoFind)
class spellTabHandler (leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""

    @others
#@+node:ekr.20051025071455.19:Birth & death
#@+node:ekr.20051025071455.20:spellTabHandler.__init__
def __init__(self,c,tabName):

    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = g.app.gui.plainTextWidget(c.frame.top)
        # A text widget for scanning.
        # Must have a parent frame even though it is not packed.

    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.tab = g.app.gui.createSpellTab(c,self,tabName)
#@-node:ekr.20051025071455.20:spellTabHandler.__init__
#@+node:ekr.20051025094004:init_aspell
def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))

    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('can not open dictionary file:',dictionaryFileName, color='red')
        return False

    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)

    if self.aspell.aspell:
        self.dictionary = self.readDictionary(dictionaryFileName)
    else:
        self.dictionary = False
        # g.es_print('can not open Aspell',color='red')

    return self.aspell.aspell
#@-node:ekr.20051025094004:init_aspell
#@+node:ekr.20051025071455.16:readDictionary
def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary

    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""

    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("can not open local dictionary",fileName,"using a blank one instead")
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            word = g.toUnicode(word,'utf-8', reportErrors=True)
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
#@-node:ekr.20051025071455.16:readDictionary
#@-node:ekr.20051025071455.19:Birth & death
#@+node:ekr.20051025071455.36:Commands
#@+node:ekr.20051025071455.37:add (spellTab)
def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    if not self.currentWord: return

    # g.trace(self.currentWord)

    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % g.toEncodedString(word,'utf-8',reportErrors=True))
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("adding ", color= "blue", newline= False) 
                g.es('','%s' % self.currentWord)
        except IOError:
            g.es("can not add",self.currentWord,"to dictionary",color="red")
    finally:
        if f: f.close()

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
#@-node:ekr.20051025071455.37:add (spellTab)
#@+node:ekr.20051025071455.38:change (spellTab)
def change(self,event=None):
    """Make the selected change to the text"""

    c = self.c ; body = self.body ; w = body.bodyCtrl

    selection = self.tab.getSuggestion()
    if selection:
        if hasattr(self.tab,'change_i') and self.tab.change_i is not None:
            start,end = oldSel = self.tab.change_i,self.tab.change_j
            # g.trace('using',start,end)
        else:
            start,end = oldSel = w.getSelectionRange()
        if start is not None:
            if start > end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
#@-node:ekr.20051025071455.38:change (spellTab)
#@+node:ekr.20051025071455.40:find & helpers
def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        # Save the selection range.
        ins = w.getInsertPoint()
        i,j = w.getSelectionRange()
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Restore the selection range.
        w.setSelectionRange(i,j,insert=ins)
        w.see(ins)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
#@+node:ekr.20051025071455.45:findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.p
    w = c.frame.body.bodyCtrl
    aspell = self.aspell ; alts = None ; word = None
    sparseFind = c.config.getBool('collapse_nodes_while_spelling')
    trace = False
    try:
        while 1:
            i,j,p,word = self.findNextWord(p)
            # g.trace(i,j,p and p.h or '<no p>')
            if not p or not word:
                alts = None
                break
            << Skip word if ignored or in local dictionary >>
            alts = aspell.processWord(word)
            if trace: g.trace('alts',alts and len(alts) or 0,i,j,word,p and p.h or 'None')
            if alts:
                redraw = not p.isVisible(c)
                # New in Leo 4.4.8: show only the 'sparse' tree when redrawing.
                if sparseFind and not c.p.isAncestorOf(p):
                    for p2 in c.p.self_and_parents_iter():
                        p2.contract()
                        redraw = True
                for p2 in p.parents_iter():
                    if not p2.isExpanded():
                        p2.expand()
                        redraw = True
                if redraw:
                    c.redraw(p)
                else:
                    c.selectPosition(p)
                w.setSelectionRange(i,j,insert=j)
                break
    except Exception:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if word.lower() in self.dictionary:
    continue
#@-node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
#@-node:ekr.20051025071455.45:findNextMisspelledWord
#@+node:ekr.20051025071455.47:findNextWord (spellTab)
def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    trace = False and not g.unitTesting
    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i < len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.h,'i',i,'len(s)',len(s))
        if i < len(s):
            # A non-empty word has been found.
            j = i
            while j < len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            if trace: g.trace(i,j,word,p.h)
            return i,j,p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.b)
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
            if trace: g.trace(0,0,'-->',p.h)

    return None,None,None,None
#@nonl
#@-node:ekr.20051025071455.47:findNextWord (spellTab)
#@-node:ekr.20051025071455.40:find & helpers
#@+node:ekr.20051025121408:hide
def hide (self,event=None):

    self.c.frame.log.selectTab('Log')

    for message in self.messages:
        g.es(message,color='blue')

    self.messages = []
#@-node:ekr.20051025121408:hide
#@+node:ekr.20051025071455.41:ignore
def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""

    if not self.currentWord: return

    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("ignoring ",color= "blue", newline= False)
        g.es('','%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
#@-node:ekr.20051025071455.41:ignore
#@-node:ekr.20051025071455.36:Commands
#@-node:ekr.20051025071455.18:class spellTabHandler (leoFind.leoFind)
#@+node:ekr.20051025071455.6:class AspellClass
class AspellClass:

    """A wrapper class for Aspell spell checker"""

    @others
#@+node:ekr.20051025071455.7:Birth & death
#@+node:ekr.20051025071455.8:__init__
def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = c.os_path_finalize(c.config.getString('aspell_dir'))
    self.aspell_bin_dir = c.os_path_finalize(c.config.getString('aspell_bin_dir'))
    self.diagnose = c.config.getBool('diagnose-aspell-installation')

    self.local_language_code = local_language_code or 'en'
    self.local_dictionary_file = c.os_path_finalize(local_dictionary_file)
    self.local_dictionary = "%s.wl" % os.path.splitext(self.local_dictionary_file) [0]

    # g.trace('code',self.local_language_code,'dict',self.local_dictionary_file)
    # g.trace('dir',self.aspell_dir,'bin_dir',self.aspell_bin_dir)

    self.aspell = self.sc = None

    if ctypes:
        self.getAspellWithCtypes()
    else:
        self.getAspell()
#@-node:ekr.20051025071455.8:__init__
#@+node:ekr.20061017125710:getAspell
def getAspell (self):

    if sys.platform.startswith('linux'):
        self.report('You must be using Python 2.5 or above to use aspell on Linux')
        return

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=None,verbose=False)

    if not aspell:
        self.report('can not import aspell')

    self.aspell = aspell
    self.sc = aspell and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)
#@-node:ekr.20061017125710:getAspell
#@+node:ekr.20061018111331:getAspellWithCtypes
def getAspellWithCtypes (self):

    try:
        c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

        if sys.platform.startswith('win'):
            path = g.os_path_join(self.aspell_bin_dir, "aspell-15.dll")
            self.aspell = aspell = ctypes.CDLL(path)
        else:
            path = 'aspell'
            libname = ctypes.util.find_library(path)
            assert(libname)
            self.aspell = aspell = ctypes.CDLL(libname)
    except Exception:
        self.report('Can not load %s' % (path))
        self.aspell = self.check = self.sc = None
        return

    try:
        << define and configure aspell entry points >>
    except Exception:
        self.report('aspell checker not enabled')
        self.aspell = self.check = self.sc = None
        return

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
#@+node:ekr.20061018111933:<< define and configure aspell entry points >>
# new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    g.pr(sc )
    g.pr(aspell_config_replace(sc, "prefix", self.aspell_dir)) #1/0
    g.pr('prefix', self.aspell_dir, repr(aspell_config_retrieve(sc, "prefix")))
    g.pr(aspell_config_retrieve(sc, "lang"))
    g.pr(aspell_config_replace(sc, "lang",self.local_language_code))
    g.pr(aspell_config_retrieve(sc, "lang"))

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    self.report(aspell_error_message(possible_err))
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]
#@nonl
#@-node:ekr.20061018111933:<< define and configure aspell entry points >>
#@-node:ekr.20061018111331:getAspellWithCtypes
#@+node:ekr.20071111153009:report
def report (self,message):

    if self.diagnose:
        g.es_print(message,color='blue')
#@-node:ekr.20071111153009:report
#@-node:ekr.20051025071455.7:Birth & death
#@+node:ekr.20051025071455.10:processWord AspellClass
def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    & <original> <count> <offset>: <miss>, <miss>, ... 
    None: 
    # <original> <offset> 
    simplifyed to not create the string then make a list from it
    """

    # g.trace('word',word)

    if not self.aspell:
        g.trace('aspell not installed')
        return None
    elif ctypes:
        # g.trace(type(word),word)
        word = g.toEncodedString(word,'utf-8')
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
#@-node:ekr.20051025071455.10:processWord AspellClass
#@+node:ekr.20061018101455.4:suggestions
def suggestions(self,word):

    "return list of words found"

    aList = []
    sw = self.suggest(self.spell_checker, word, len(word))

    if self.word_list_size(sw):
        ewords = self.word_list_elements(sw)
        while 1: 
            x = self.string_enumeration_next(ewords)
            if x is None: break
            aList.append(x)
    return aList
#@nonl
#@-node:ekr.20061018101455.4:suggestions
#@+node:ekr.20051025071455.11:updateDictionary
def updateDictionary(self):

    """Update the aspell dictionary from a list of words.

    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl < %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception:
        junk, err, junk = sys.exc_info()
        g.pr("unable to update local aspell dictionary:",err)
        return False
#@-node:ekr.20051025071455.11:updateDictionary
#@-node:ekr.20051025071455.6:class AspellClass
#@-node:ekr.20051025071455:Spell classes
#@+node:ekr.20051025071455.45:findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.p
    w = c.frame.body.bodyCtrl
    aspell = self.aspell ; alts = None ; word = None
    sparseFind = c.config.getBool('collapse_nodes_while_spelling')
    trace = False
    try:
        while 1:
            i,j,p,word = self.findNextWord(p)
            # g.trace(i,j,p and p.h or '<no p>')
            if not p or not word:
                alts = None
                break
            << Skip word if ignored or in local dictionary >>
            alts = aspell.processWord(word)
            if trace: g.trace('alts',alts and len(alts) or 0,i,j,word,p and p.h or 'None')
            if alts:
                redraw = not p.isVisible(c)
                # New in Leo 4.4.8: show only the 'sparse' tree when redrawing.
                if sparseFind and not c.p.isAncestorOf(p):
                    for p2 in c.p.self_and_parents_iter():
                        p2.contract()
                        redraw = True
                for p2 in p.parents_iter():
                    if not p2.isExpanded():
                        p2.expand()
                        redraw = True
                if redraw:
                    c.redraw(p)
                else:
                    c.selectPosition(p)
                w.setSelectionRange(i,j,insert=j)
                break
    except Exception:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if word.lower() in self.dictionary:
    continue
#@-node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
#@-node:ekr.20051025071455.45:findNextMisspelledWord
#@+node:ekr.20051025071455.10:processWord AspellClass
def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    & <original> <count> <offset>: <miss>, <miss>, ... 
    None: 
    # <original> <offset> 
    simplifyed to not create the string then make a list from it
    """

    # g.trace('word',word)

    if not self.aspell:
        g.trace('aspell not installed')
        return None
    elif ctypes:
        # g.trace(type(word),word)
        word = g.toEncodedString(word,'utf-8')
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
#@-node:ekr.20051025071455.10:processWord AspellClass
#@+node:ekr.20051025071455.47:findNextWord (spellTab)
def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    trace = False and not g.unitTesting
    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i < len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.h,'i',i,'len(s)',len(s))
        if i < len(s):
            # A non-empty word has been found.
            j = i
            while j < len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            if trace: g.trace(i,j,word,p.h)
            return i,j,p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.b)
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
            if trace: g.trace(0,0,'-->',p.h)

    return None,None,None,None
#@nonl
#@-node:ekr.20051025071455.47:findNextWord (spellTab)
#@+node:ekr.20031218072017.2317:g.trace (revised)
# Convert all args to strings.

def trace (*args,**keys):

    # Compute the effective args.
    d = {'align':0,'newline':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    align = d.get('align')
    if align is None: align = 0

    # Compute the caller name.
    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except Exception: name = ''
    if name == "?":
        name = "<unknown>"

    # Pad the caller name.
    if align != 0 and len(name) < abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align > 0: name = name + pad
        else:         name = pad + name

    # Munge *args into s.
    # print ('g.trace:args...')
    # for z in args: print (g.isString(z),repr(z))
    result = [name]
    for arg in args:
        if g.isString(arg):
            pass
        elif g.isBytes(arg):
            arg = g.toUnicode(arg,'utf-8')
        else:
            arg = repr(arg)
        if result:
            result.append(" " + arg)
        else:
            result.append(arg)
    s = ''.join(result)

    # Not valid syntax in Python 3.x.
    # print s,
    # if newline: print
    g.pr(s,newline=newline)
#@-node:ekr.20031218072017.2317:g.trace (revised)
#@+node:ekr.20080710101653.1:g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    nl = g.choose(newline,'\n','')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.

    try: # We can't use any print keyword args in Python 2.x!
        s2 = g.toEncodedString(s,encoding)
        sys.stdout.write(s2+nl)
    except Exception:
        if not g.pr_warning_given:
            g.pr_warning_given = True
            print('unexpected Exception in g.pr')
            print('make sure your sitecustomize.py contains::')
            print('    sys.setdefaultencoding("utf-8")')
            g.es_exception()
            g.trace(g.callers())
        s2 = s.encode('ascii',"replace")
        sys.stdout.write(s2+nl)
#@nonl
#@-node:ekr.20080710101653.1:g.pr
#@+node:ekr.20080220111323:g.translateArgs
def translateArgs(args,d):

    '''Return the concatenation of s and all args,

    with odd args translated.'''

    if not hasattr(g,'consoleEncoding'):
        e = sys.getdefaultencoding()
        g.consoleEncoding = isValidEncoding(e) and e or 'utf-8'
        # print 'translateArgs',g.consoleEncoding

    result = [] ; n = 0 ; spaces = d.get('spaces')
    for arg in args:
        n += 1

        # print('g.translateArgs: arg',arg,type(arg),g.isString(arg),'will trans',(n%2)==1)

        # First, convert to unicode.
        if type(arg) == type('a'):
            arg = g.toUnicode(arg,g.consoleEncoding)

        # Now translate.
        if not g.isString(arg):
            arg = repr(arg)
        elif (n % 2) == 1:
            arg = g.translateString(arg)
        else:
            pass # The arg is an untranslated string.

        if arg:
            if result and spaces: result.append(' ')
            result.append(arg)

    return ''.join(result)
#@-node:ekr.20080220111323:g.translateArgs
#@+node:ekr.20080821073134.2:g.doKeywordArgs
def doKeywordArgs (keys,d=None):

    '''Return a result dict that is a copy of the keys dict
    with missing items replaced by defaults in d dict.'''

    if d is None: d = {}

    result = {}
    for key,default_val in d.items():
        isBool = default_val in (True,False)
        val = keys.get(key)
        if isBool and val in (True,'True','true'):
            result[key] = True
        elif isBool and val in (False,'False','false'):
            result[key] = False
        elif val is None:
            result[key] = default_val
        else:
            result[key] = val

    return result 
#@-node:ekr.20080821073134.2:g.doKeywordArgs
#@-node:ekr.20090626123815.5989:Fixed unicode problem with spell checker
#@+node:ekr.20090627063133.5992:Ensure newline at end of each @auto node
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers (atFile)
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName and not toString: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        if root.isAtAutoRstNode():
            c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
        else:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        if at.errors == 0:
            at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",at.outputFileName)
            root.setDirty() # New in Leo 4.4.8.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("not written:",at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers (atFile)
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,
    nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v.t._bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if self.atAuto or (not toString and not nosentinels):
        at.warnAboutOrphandAndIgnoredNodes()
#@-node:ekr.20041005105605.157:writeOpenFile
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    at = self

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.b)

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    s = self.cleanLines(p,s)
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if not trailingNewlineFlag:
        if at.sentinels:
            at.putSentinel("@nonl")
        elif at.atAuto and not at.atEdit:
            # New in Leo 4.6 rc1: ensure all @auto nodes end in a newline!
            at.onl()

#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
@

If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if not trailingNewlineFlag:
        if (at.sentinels or 
            (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
        ):
            # g.trace('Added newline',repr(s))
            s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
# g.trace(kind,repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.startVerbatim:
    at.putSentinel("@verbatim")
    at.putIndent(at.indent)
    i = next_i
    next_i = g.skip_line(s,i)
    at.os(s[i:next_i])
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@+node:ekr.20051104075904.44:at-File test code (leoTest.py)
def runAtFileTest(c,p):

    """Common code for testing output of @file, @thin, etc."""

    at = c.atFileCommands
    child1 = p.firstChild()
    child2 = child1.next()
    h1 = child1.h.lower().strip()
    h2 = child2.h.lower().strip()
    assert(g.match(h1,0,"#@"))
    assert(g.match(h2,0,"output"))
    expected = child2.b

    # Compute the type from child1's headline.
    j = g.skip_c_id(h1,2)
    theType = h1[1:j]
    assert theType in ("@auto","@edit","@file","@thin","@nosent",
        "@noref","@asis","@root",), "bad type: %s" % type

    thinFile = theType == "@thin"
    nosentinels = theType in ("@asis","edit","@nosent")

    if theType == "@root":
        c.tangleCommands.tangle_output = ''
        c.tangleCommands.tangle(event=None,p=child1)
        at.stringOutput = c.tangleCommands.tangle_output
    elif theType == "@asis":
        at.asisWrite(child1,toString=True)
    elif theType == "@auto":
        at.writeOneAtAutoNode(child1,toString=True,force=True)
    elif theType == "@edit":
        at.writeOneAtEditNode(child1,toString=True)
    elif theType == "@noref":
        at.norefWrite(child1,toString=True)
    else:
        at.write(child1,thinFile=thinFile,nosentinels=nosentinels,toString=True)
    try:
        result = g.toUnicode(at.stringOutput,"ascii")
        assert(result == expected)
    except AssertionError:
        << dump result and expected >>
        raise
#@+node:ekr.20051104075904.45:<< dump result and expected >>
print('\n','-' * 20)
print("result...")
for line in g.splitLines(result):
    print("%3d" % len(line),repr(line))
print('-' * 20)
print("expected...")
for line in g.splitLines(expected):
    print("%3d" % len(line),repr(line))
print('-' * 20)
#@-node:ekr.20051104075904.45:<< dump result and expected >>
#@-node:ekr.20051104075904.44:at-File test code (leoTest.py)
#@-node:ekr.20090627063133.5992:Ensure newline at end of each @auto node
#@+node:ekr.20090627063133.5991:Fixed bugs with goto-global-line and @auto
#@+node:ekr.20080710082231.10:c.gotoLineNumber and helpers
def goToLineNumber (self,n,p=None,scriptData=None):

    '''Place the cursor on the n'th line of a derived file or script.
    When present scriptData is a dict with 'root' and 'lines' keys.'''

    trace = False and not g.unitTesting
    c = self
    delim = None ; gnx = None ; vnodeName = None
    if n < 0: return
    if n == 0: n = 1

    fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n,p,scriptData)
    if trace: g.trace(isRaw,g.listToString(lines,sort=False))

    if n==1 and not isRaw:
        p = root ; n2 = 1 ; found = True
    elif n > len(lines): # was >=
        p = root ; n2 = root.b.count('\n') ; found = False
    elif isRaw:
        p,n2,found = c.goto_countLines(root,n)
    else:
        vnodeName,gnx,n2,delim = c.goto_findVnode(root,lines,n,ignoreSentinels)
        if delim:
            p,found = c.goto_findPosition(
                root,lines,vnodeName,gnx,n,delim)
        else:
            p,found = root,False
    if 0:
        << trace gotoLineNumber results >>
    c.goto_showResults(found,p or root,n,n2,lines)
#@+node:ekr.20080905130513.40:<< trace gotoLineNumber results >>
g.trace(
    '\n  found',found,'n2',n2,'gnx',gnx,'delim',repr(delim),
    '\n  vnodeName',vnodeName,
    '\n  p        ',p and p.h,
    '\n  root     ',root and root.h)
#@-node:ekr.20080905130513.40:<< trace gotoLineNumber results >>
#@+node:ekr.20080708094444.65:goto_applyLineNumberMapping
def goto_applyLineNumberMapping(self, n):

    c = self ; x = c.shadowController

    if len(x.line_mapping) > n:
        return x.line_mapping[n]
    else:
        return n
#@-node:ekr.20080708094444.65:goto_applyLineNumberMapping
#@+node:ekr.20080904071003.12:goto_countLines
def goto_countLines (self,root,n):

    '''Scan through root's outline, looking for line n.
    Return (p,n2,found) where p is the found node,
    n2 is the actural line found, and found is True if the line was found.'''

    trace = False and not g.unitTesting
    p = lastv = root
    prev = 0 ; found = False
    isNosent = root.isAtNoSentFileNode()
    isAuto = root.isAtAutoNode()

    if trace: g.trace('=' * 10)
    for p in p.self_and_subtree_iter():
        lastv = p.copy()
        s = p.b
        if isNosent or isAuto:
            lines = [z for z in g.splitLines(s) if not z.startswith('@')]
            s = ''.join(lines)
        else:
            lines = g.splitLines(s)
        n_lines = len(lines)
        if trace: g.trace('prev: %3s node: %s lines...\n%s' % (
            prev,p.h,g.listToString(lines)))
        if prev + n_lines >= n:
            if trace: g.trace('***found',n-prev)
            found = True ; break
        prev += n_lines

    p = lastv
    n2 = max(0,n-prev)

    return p,n2,found
#@-node:ekr.20080904071003.12:goto_countLines
#@+node:ekr.20080904071003.4:goto_findPosition & helpers
def goto_findPosition(self,root,lines,vnodeName,gnx,n,delim):

    c = self

    # if scriptFind:
        # p,found = c.scanForVnodeName(root,vnodeName

    if gnx:
        p,found = c.goto_findGnx(root,gnx,vnodeName)
    else:
        p,found = c.goto_scanTnodeList(root,delim,lines,n,vnodeName)

    # if not found:
        # g.es("not found:",vnodeName,color="red")

    return p,found
#@+node:ekr.20080904071003.18:goto_findGnx
def goto_findGnx (self,root,gnx,vnodeName):

    '''Scan root's tree for a node with the given gnx and vnodeName.

    return (p,found)'''

    gnx = g.app.nodeIndices.scanGnx(gnx,0)

    for p in root.self_and_subtree_iter():
        if p.matchHeadline(vnodeName):
            if p.v.t.fileIndex == gnx:
                return p.copy(),True

    return None,False
#@-node:ekr.20080904071003.18:goto_findGnx
#@+node:ekr.20080904071003.19:goto_scanTnodeList
def goto_scanTnodeList (self,root,delim,lines,n,vnodeName):

    # This is about the best that can be done without replicating the entire atFile write logic.
    found = False
    ok = hasattr(root.v.t,"tnodeList")

    if ok:
        # Use getattr to keep pylint happy.
        tnodeList = getattr(root.v.t,'tnodeList')
        << set tnodeIndex to the number of +node sentinels before line n >>
        tnodeIndex = max(0,tnodeIndex)
        << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
    else:
        g.es_print("no child index for",root.h,color="red")

    if not ok:
        # Fall back to the old logic.
        << set p to the first node whose headline matches vnodeName >>

    return p,found
#@+node:ekr.20080904071003.8:<< set tnodeIndex to the number of +node sentinels before line n >>

tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@-node:ekr.20080904071003.8:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20080904071003.9:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.h.strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.h,vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False
#@-node:ekr.20080904071003.9:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20080904071003.10:<< set p to the first node whose headline matches vnodeName >>
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@-node:ekr.20080904071003.10:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20080904071003.19:goto_scanTnodeList
#@-node:ekr.20080904071003.4:goto_findPosition & helpers
#@+node:ekr.20031218072017.2877:goto_findVnode
def goto_findVnode (self,root,lines,n,ignoreSentinels):

    '''Search the lines of a derived file containing sentinels for a vnode.
    return (vnodeName,gnx,offset,delim):

    vnodeName:  the name found in the previous @+body sentinel.
    gnx:        the gnx of the found node.
    offset:     the offset within the node of the desired line.
    delim:      the comment delim from the @+leo sentinel.
    '''

    c = self ; at = c.atFileCommands
    # g.trace('lines...\n',g.listToString(lines))
    gnx = None
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es('no sentinels in:',root.h)
        return None,None,None,None

    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        g.trace('no @+node!!')
        return root.h,gnx,1,delim

    s = lines[nodeSentinelLine]

    << set gnx and vnodeName from s >>
    if delim and vnodeName:
        # g.trace('offset',offset)
        return vnodeName,gnx,offset,delim
    else:
        g.es("bad @+node sentinel")
        return None,None,None,None
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

# Set delim from the @+leo line.
delim = None
if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,thinFile = at.parseLeoSentinel(s)
    # New in Leo 4.5.1: only support 4.x files.
    if valid and newDerivedFile:
        delim = start + '@'
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
@
Scan backwards from the requested line, looking for an @-body line. When found,
we get the vnode's name from that line and set p to the indicated vnode. This
will fail if vnode names have been changed, and that can't be helped.

We compute the offset of the requested line **within the found node**.
@c

offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1 # Start with the requested line.
while line >= 0:
    progress = line
    s = lines[line]
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        # offset += 1 # Assume the line is real.  A dubious assumption.
        line -= 1
    assert line < progress
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line",str(n),"is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    old_line = line
    line = c.goto_skipToMatchingNodeSentinel(lines,line,delim)
    assert line < old_line
    # g.trace('found',repr(lines[line]))
    nodeSentinelLine = line
    offset = n-line
    break
elif g.match(s,i,"+node"):
    # g.trace('found',repr(lines[line]))
    nodeSentinelLine = line
    offset = n-line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    # if not ignoreSentinels:
        # offset += 1 # Count these as a "real" lines.
    line -= 1
else:
    line -= 1
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set gnx and vnodeName from s >>
i = 0 ; gnx = None ; vnodeName = None

if thinFile:
    # gnx is lies between the first and second ':':
    i = s.find(':',i)
    if i > 0:
        i += 1
        j = s.find(':',i)
        if j > 0:   gnx = s[i:j]
        else:       i = len(s) # Force an error.
    else:
        i = len(s) # Force an error.

# vnode name is everything following the first or second':'
i = s.find(':',i)
if i > -1:
    vnodeName = s[i+1:].strip()
else:
    vnodeName = None
    g.es_print("bad @+node sentinel",color='red')
#@-node:ekr.20031218072017.2881:<< set gnx and vnodeName from s >>
#@-node:ekr.20031218072017.2877:goto_findVnode
#@+node:ekr.20080904071003.28:goto_setup & helpers
def goto_setup (self,n,p=None,scriptData=None):

    '''Return (fileName,isRaw,lines,n,p,root) where:

    fileName is the name of the nearest @file node, or None.
    isRaw is True if there are no sentinels in the file.
    lines are the lines to be scanned.
    n is the effective line number (munged for @shadow nodes).
    root is the nearest @file node, or c.currentPosition.'''

    c = self

    if scriptData:
        assert p is None
        lines = scriptData.get('lines')
        p = scriptData.get('p')
        root,fileName = c.goto_findRoot(p)
    else:
        # p is for unit testing only!
        if not p: p = c.p
        root,fileName = c.goto_findRoot(p)
        if root and fileName:
            c.shadowController.line_mapping = [] # Set by goto_open.
            lines = c.goto_getFileLines(root,fileName)
            n = c.goto_applyLineNumberMapping(n)
        else:
            lines = c.goto_getScriptLines(p)

    isRaw = not root or (
        root.isAtAsisFileNode() or root.isAtNoSentFileNode() or root.isAtAutoNode())

    ignoreSentinels = root and root.isAtNoSentFileNode()

    if scriptData:
        if not root: root = p.copy()
    else:
        if not root: root = c.p

    return fileName,ignoreSentinels,isRaw,lines,n,root
#@+node:ekr.20080904071003.25:goto_findRoot
def goto_findRoot (self,p):

    '''Find the closest ancestor @file node, of any type, except @all nodes.

    return root, fileName.'''

    c = self ; p1 = p.copy()

    # First look for ancestor @file node.
    for p in p.self_and_parents_iter():
        fileName = not p.isAtAllNode() and p.anyAtFileNodeName()
        if fileName:
            return p.copy(),fileName

    # Search the entire tree for joined nodes.
    # Bug fix: Leo 4.5.1: *must* search *all* positions.
    for p in c.all_positions_iter():
        # if p.v.t == p1.v.t: g.trace('p1',p1,'p',p)
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p2 in p.self_and_parents_iter():
                fileName = not p2.isAtAllNode() and p2.anyAtFileNodeName()
                if fileName:
                    return p2.copy(),fileName

    return None,None
#@-node:ekr.20080904071003.25:goto_findRoot
#@+node:ekr.20080904071003.26:goto_getFileLines
def goto_getFileLines (self,root,fileName):

    '''Read the file into lines.'''

    c = self

    if root.isAtNoSentFileNode():
        # Write a virtual file containing sentinels.
        at = c.atFileCommands
        at.write(root,nosentinels=False,toString=True)
        lines = g.splitLines(at.stringOutput)
    else:
        # Calculate the full path.
        d = g.scanDirectives(c,p=root)
        path = d.get("path")
        # g.trace('path',path,'fileName',fileName)
        fileName = c.os_path_finalize_join(path,fileName)
        lines    = c.goto_open(fileName)

    return lines
#@-node:ekr.20080904071003.26:goto_getFileLines
#@+node:ekr.20080904071003.27:goto_getScriptLines
def goto_getScriptLines (self,p):

    c = self

    if not g.unitTesting:
        g.es("no ancestor @file node: using script line numbers", color="blue")

    lines = g.getScript (c,p,useSelectedText=False)
    lines = g.splitLines(lines)

    return lines
#@-node:ekr.20080904071003.27:goto_getScriptLines
#@+node:ekr.20080708094444.63:goto_open
def goto_open (self,filename):
    """
    Open a file for "goto linenumber" command and check if a shadow file exists.
    Construct a line mapping. This ivar is empty i no shadow file exists.
    Otherwise it contains a mapping shadow file number -> real file number.
    """

    c = self ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        if os.path.exists(shadow_filename):
            fn = shadow_filename
            lines = open(shadow_filename).readlines()
            x.line_mapping = x.push_filter_mapping(
                lines,
                x.markerFromFileLines(lines,shadow_filename))
        else:
            # Just open the original file.  This is not an error!
            fn = filename
            c.line_mapping = []
            lines = open(filename).readlines()
    except Exception:
        # Make sure failures to open a file generate clear messages.
        g.es_print('can not open',fn,color='blue')
        # g.es_exception()
        lines = []

    return lines
#@-node:ekr.20080708094444.63:goto_open
#@-node:ekr.20080904071003.28:goto_setup & helpers
#@+node:ekr.20080904071003.14:goto_showResults
def goto_showResults(self,found,p,n,n2,lines):

    c = self ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.redraw(p)

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)    
    else:
        ins = len(s)
        if len(lines) < n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    # g.trace(p.h,g.callers())

    w.setInsertPoint(ins)
    c.bodyWantsFocusNow()
    w.seeInsertPoint()
#@nonl
#@-node:ekr.20080904071003.14:goto_showResults
#@+node:ekr.20031218072017.2882:goto_skipToMatchingNodeSentinel
def goto_skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
#@-node:ekr.20031218072017.2882:goto_skipToMatchingNodeSentinel
#@-node:ekr.20080710082231.10:c.gotoLineNumber and helpers
#@-node:ekr.20090627063133.5991:Fixed bugs with goto-global-line and @auto
#@+node:ekr.20090627143802.6007:Allow bindings in log pane
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',
            repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        << handle special cases for plain keys >>

    << handle per-pane bindings >>

    if traceGC: g.printNewObjects('masterKey 5')

    return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.

if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function',k.state.kind) # k.state.handler)
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20080510153327.4:<< handle special cases for plain keys >>
# g.trace('plain key','state',k.unboundKeyAction,'stroke',stroke)

# Important: only keys bound somewhere have a stroke.
# All unbound plain keys will be handled by handleUnboundKeys.

if k.unboundKeyAction in ('insert','overwrite'):

    for key in (k.unboundKeyAction,'body','log','text','all'):
        # Ignore bindings for all plain keys in insert/overwrite mode *except* auto-complete.
        d = k.masterBindingsDict.get(key,{})
        if d:
            b = d.get(stroke)
            if b and b.commandName == 'auto-complete':
                if trace: g.trace('%s: auto-complete key in %s mode' % (stroke,k.unboundKeyAction))
                k.masterCommand(event,b.func,b.stroke,b.commandName)
                return 'break'

    if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
    k.masterCommand(event,func=None,stroke=stroke,commandName=None)
    return 'break'

# Bound   plain keys in command mode are by the per-pane logic.
# Unbound plain keys in command mode are ignored by handleUnboundKeys.

# This code ignores all command-state keys if we are not in a text widget.
elif k.unboundKeyAction == 'command':
    if not g.app.gui.isTextWidget(w):
        c.onCanvasKey(event)
        return 'break'
#@nonl
#@-node:ekr.20080510153327.4:<< handle special cases for plain keys >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
keyStatesTuple = ('command','insert','overwrite')

if True and trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
    'isTextWidget(w)',g.app.gui.isTextWidget(w))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None),
    ('all',None),
):
    if (
        # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        if trace: g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
        # g.trace(key,'keys',g.listToString(d.keys(),sort=True)) # [:5])
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif keysym.find('Escape') != -1:
        # Never insert escape characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20061031131434.105:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@nonl
#@+node:ekr.20061031131434.106:<< define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@nonl
#@-node:ekr.20061031131434.106:<< define specialKeysyms >>
#@+node:ekr.20061031131434.107:<< add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@-node:ekr.20061031131434.107:<< add character to history >>
#@+node:ekr.20061031131434.109:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
#@-node:ekr.20061031131434.109:callKeystrokeFunction (not used)
#@+node:ekr.20061031131434.110:k.handleDefaultChar
def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if stroke and (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    elif name.startswith('log'):
        if g.app.gui.guiName() == 'tkinter':
            return None
        else:
            if trace: g.trace(w)
            i = w.logCtrl.getInsertPoint()
            if stroke.lower() == 'return': stroke = '\n'
            elif stroke.lower() == 'tab': stroke = '\t'
            elif stroke.lower() == 'backspace': stroke = '\b'
            w.logCtrl.insert(i,stroke)
            return None
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(stroke))
        return None
#@nonl
#@-node:ekr.20061031131434.110:k.handleDefaultChar
#@-node:ekr.20061031131434.105:masterCommand & helpers
#@-node:ekr.20090627143802.6007:Allow bindings in log pane
#@+node:ekr.20090628094153.5995:Investigated check-derived-file bug
# The check-derived-file command appears to work properly.
#@nonl
#@+node:ekr.20090628094153.5996:Report
@nocolor-node

To reproduce (in the latest bzr version, qt-plugin enabled):

create a node "@thin a_directory/a_file" where a_file has some text in it but no
sentinels/leo-specific data.

Select File-> read/write -> check derived file. The log window shows:

Bad @+leo sentinel in: check-derived-file
can not open: '@file /home/user/a_directory/check-derived-file'

Clearly the file is not named 'check-derived-file', so there is a bug somewhere.
#@nonl
#@-node:ekr.20090628094153.5996:Report
#@+node:ekr.20070919133659:checkDerivedFile (atFile)
def checkDerivedFile (self, event=None):

    at = self ; c = at.c ; p = c.p

    if not p.isAtFileNode() and not p.isAtThinFileNode():
        return g.es('Please select an @thin or @file node',color='red')

    fn = p.anyAtFileNodeName()
    path = g.os_path_dirname(c.mFileName)
    fn = g.os_path_finalize_join(g.app.loadDir,path,fn)
    if not g.os_path_exists(fn):
        return g.es_print('file not found: %s' % (fn),color='red')

    try:
        s = open(fn,'r').read()
    except IOError:
        return g.es_print('can not open %s' % (fn),color='red')

    # Create a dummy, unconnected, vnode as the root.
    root_v = leoNodes.vnode(context=c)
    root = leoNodes.position(root_v)
    theFile = g.fileLikeObject(fromString=s)
    thinFile = at.scanHeaderForThin (theFile,fn)
    at.initReadIvars(root,fn,thinFile=thinFile)
    if at.errors: return
    at.openFileForReading(fn,fromString=s)
    if not at.inputFile: return
    at.readOpenFile(root,at.inputFile,fn)
    at.inputFile.close()
    if at.errors == 0:
        g.es_print('check-derived-file passed',color='blue')
#@-node:ekr.20070919133659:checkDerivedFile (atFile)
#@+node:ekr.20041005105605.27:readOpenFile
def readOpenFile(self,root,theFile,fileName):

    '''Read an open derived file.

    Leo 4.5 and later can only read 4.x derived files.'''

    at = self ; ok = True

    firstLines,read_new,junk = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        firstLines = [] ; lastLines = []
        ok = False
        if at.atShadow:
            g.trace(g.callers())
            g.trace('invalid @shadow private file',fileName)
            at.error('invalid @shadow private file',fileName)
        else:
            at.error('can not read 3.x derived file',fileName)
            g.es('you may upgrade these file using Leo 4.0 through 4.4.x')
            g.trace('root',root and root.h,fileName)

    if root:
        root.v.t.setVisited() # Disable warning about set nodes.

    << handle first and last lines >>

    return ok
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.t.tempBodyString
except Exception:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@-node:ekr.20041005105605.27:readOpenFile
#@-node:ekr.20090628094153.5995:Investigated check-derived-file bug
#@+node:ekr.20090628114617.5997:Honor split ratios
#@+node:ekr.20031218072017.3689:initialRatios (leoFrame)
def initialRatios (self):

    c = self.c

    s = c.config.get("initial_splitter_orientation","string")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2
#@-node:ekr.20031218072017.3689:initialRatios (leoFrame)
#@-node:ekr.20090628114617.5997:Honor split ratios
#@+node:ekr.20090628164349.5999:Click in body after editing activates body
#@+node:ekr.20031218072017.2992:c.endEditing (calls tree.endEditLabel)
# Ends the editing in the outline.

def endEditing(self):

    c = self ; k = c.k

    p = c.p

    if p:
        c.frame.tree.endEditLabel()
        c.frame.tree.setSelectedLabelState(p)

    # The following code would be wrong; c.endEditing is a utility method.
    # if k:
        # k.setDefaultInputState()
        # # Recolor the *body* text, **not** the headline.
        # k.showStateAndMode(w=c.frame.body.bodyCtrl)
#@-node:ekr.20031218072017.2992:c.endEditing (calls tree.endEditLabel)
#@+node:ekr.20040803072955.91:onHeadChanged (leoTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    trace = False and g.unitTesting
    c = self.c ; u = c.undoer
    w = self.edit_widget(p)

    if c.suppressHeadChanged: return
    if not w:
        if trace: g.trace('****** no w for p: %s',repr(p))
        return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    if trace: g.trace('w',repr(w),'s',repr(s))
    << truncate s if it has multiple lines >>
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed',changed,'new',repr(s))
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    if changed:
        c.redraw_after_head_changed()
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged (leoTree)
#@-node:ekr.20090628164349.5999:Click in body after editing activates body
#@+node:ekr.20090628192135.6006:Rewrote string-rectangle for speed
#@+node:ekr.20050920084036.232:stringRectangle
def stringRectangle (self,event):

    '''Prompt for a string, then replace the contents of a rectangle
    with a string on each line.'''

    c = self.c ; k = self.k ; state = k.getState('string-rect')
    if g.app.unitTesting:
        state = 1 ; k.arg = 's...s' # This string is known to the unit test.
        w = self.editWidget(event)
        self.stringRect = self.getRectanglePoints(w)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w or not self.check(event): return
        self.stringRect = self.getRectanglePoints(w)
        k.setLabelBlue('String rectangle: ',protect=True)
        k.getArg(event,'string-rect',1,self.stringRectangle)
    else:
        k.clearState()
        k.resetLabel()
        c.bodyWantsFocus()
        w = self.w
        self.beginCommand('string-rectangle')
        r1, r2, r3, r4 = self.stringRect

        #g.trace(self.stringRect)
        s = w.getAllText()
        for r in range(r1,r3+1):
            i = g.convertRowColToPythonIndex(s,r-1,r2)
            j = g.convertRowColToPythonIndex(s,r-1,r4)
            s = s[:i] + k.arg + s[j:]
        w.setAllText(s)
        i = g.convertRowColToPythonIndex(s,r1-1,r2)
        j = g.convertRowColToPythonIndex(s,r3-1,r2+len(k.arg))
        w.setSelectionRange(i,j)

        # Can be very slow.
        # for r in range(r1,r3+1):
            # w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))
            # w.insert('%s.%s' % (r,r2),k.arg)
        # w.setSelectionRange('%d.%d' % (r1,r2),'%d.%d' % (r3,r2+len(k.arg)))

        self.endCommand()
#@nonl
#@-node:ekr.20050920084036.232:stringRectangle
#@-node:ekr.20090628192135.6006:Rewrote string-rectangle for speed
#@+node:ekr.20090629192235.5984:Investigated rst report bug
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/336864

Leo: trunk as of today
GUI: qt
OS: Ubuntu 8.10 (up to date as of today)
Python: 2.5.2

The rst error reporting from rev. 1361

a) breaks rst writing on Ubuntu if the shell from which leo is launched is closed. I.e.
  stdout/err don't exist any more, and this doesn't seem to bother leo (shouldn't, either)
  but is breaking docutils.

b) doesn't work on Ubuntu even when the shell isn't closed
#@nonl
#@+node:ekr.20090502071837.65:writeToDocutils (sets argv) & helper
def writeToDocutils (self,s):

    '''Send s to docutils using the writer implied by self.ext and return the result.'''

    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }

    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()

    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.es_print('unknown docutils extension: %s' % (self.ext),color='red')
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.es_print('stylesheet not found: %s' % (path),color='red')
    else:
        g.es_print('stylesheet not found\n',path,color='red')
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        result = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError, error:
        g.es_print('Error (%s): %s' % (error.__class__.__name__, error))
    except Exception:
        g.es_print('Unexpected docutils exception')
        g.es_exception()
    return result
#@+node:ekr.20090502071837.66:handleMissingStyleSheetArgs
def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    d = {}
    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return d

    args = s.strip()
    if args.find(',') == -1:
        args = [args]
    else:
        args = args.split(',')

    for arg in args:
        data = arg.split('=')
        if len(data) == 1:
            key = data[0]
            d[str(key)] = ""
        elif len(data) == 2:
            key,value = data
            d[str(key)] = str(value)
        else:
            g.es_print('bad option: %s' % s,color='red')
            break

    return d
#@-node:ekr.20090502071837.66:handleMissingStyleSheetArgs
#@-node:ekr.20090502071837.65:writeToDocutils (sets argv) & helper
#@-node:ekr.20090629192235.5984:Investigated rst report bug
#@+node:ekr.20090630115919.5992:Fixed read-at-auto-nodes bug
#@+node:ekr.20070806105721.1:readAtAutoNodes (commands)
def readAtAutoNodes (self,event=None):

    '''Read all @auto nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.p
    c.endEditing()

    undoData = u.beforeChangeTree(p)
    c.importCommands.readAtAutoNodes()
    u.afterChangeTree(p,'Read @auto Nodes',undoData)
    c.redraw()
#@-node:ekr.20070806105721.1:readAtAutoNodes (commands)
#@+node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.p ; after = p.nodeAfterTree()

    found = False
    while p and p != after:
        if p.isAtAutoNode():
            if p.isAtIgnoreNode():
                g.es_print('ignoring',p.h,color='blue')
                p.moveToThreadNext()
            else:
                self.readOneAtAutoNode(p)
                found = True
                p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    message = g.choose(found,'finished','no @auto nodes in the selected tree')
    g.es(message,color='blue')
    c.redraw()

#@+node:ekr.20070807084545:readOneAtAutoNode (leoImport)
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # Force an update of the body pane.
    self.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20070807084545:readOneAtAutoNode (leoImport)
#@-node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
#@-node:ekr.20090630115919.5992:Fixed read-at-auto-nodes bug
#@+node:ekr.20090630115919.6059:Fixed major focus problems
@nocolor-node

Various get-focus methods must translate from wrapped widget to wrapper widget.
This happens in g.app.gui.get_focus, which needs a c arg to work properly in some cases!
#@nonl
#@+node:ekr.20070130115927.5:copyText
def copyText (self,event=None):

    '''Copy the selected text from the widget to the clipboard.'''

    f = self ; c = f.c ; w = event and event.widget
    # g.trace(w,g.callers(5))
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = w.getSelectionRange()
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)

OnCopyFromMenu = copyText
#@-node:ekr.20070130115927.5:copyText
#@+node:ekr.20061031131434.155:masterMenuHandler
def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c
    w = c.frame.getFocus()

    # g.trace('focus',w)
    # g.trace('stroke',stroke,'func',func and func.__name__,commandName,g.callers())

    # Create a minimal event for commands that require them.
    event = g.Bunch(c=c,char='',keysym='',widget=w)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
#@-node:ekr.20061031131434.155:masterMenuHandler
#@-node:ekr.20090630115919.6059:Fixed major focus problems
#@+node:ekr.20090630145606.5996:Fixed problem with read-at-file/shadow-nodes
#@+node:ekr.20090630145606.5997:Changed
#@+node:ekr.20041005105605.21:read (atFile)
def read(self,root,importFileName=None,thinFile=False,fromString=None,atShadow=False):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName >>

    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fileName,fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root, fileContent)

    if cachefile in c.db:
        # This isn't so useful.
        # if not g.unitTesting: # g.es('uncache:',root.h)
        tree = c.db[cachefile]
        g.create_tree_at_vnode(c, root.v, tree)
        at.inputFile.close() # Bug fix.
        return

    if not g.unitTesting:
        g.es("reading:",root.h)

    # Delete all children.
    while root.hasChildren():
        root.firstChild().doDelete()

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
resurrected = 0
for p in root.self_and_subtree_iter():

    if not p.v.t.isVisited():
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for t in c.all_unique_tnodes_iter():

    if hasattr(t,"tempBodyString"):
        delattr(t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile)
#@+node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

    fn = c.os_path_finalize_join(at.default_directory,fn)
    shadow_fn     = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    if shadow_exists:
        # at.read (via at.openFileForReading) calls x.updatePublicAndPrivateFiles.
        at.read(p,thinFile=True,atShadow=True)
    else:
        if not g.unitTesting: g.es("reading:",p.h)
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p,toString=False,force=True)
#@+node:ekr.20080712080505.1:importAtShadowNode
def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True,atShadow=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
#@-node:ekr.20080712080505.1:importAtShadowNode
#@-node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
#@-node:ekr.20090630145606.5997:Changed
#@-node:ekr.20090630145606.5996:Fixed problem with read-at-file/shadow-nodes
#@-node:ekr.20090623072844.10386:Bugs
#@+node:ekr.20090628075121.8434:Features
#@+node:ekr.20090628075121.8433:Added open-quickstart-leo
#@+node:ekr.20090628075121.5994:leoQuickStart
def leoQuickStart (self,event=None):

    '''Open quickstart.leo in a new Leo window.'''

    c = self ; name = "quickstart.leo"

    fileName = g.os_path_join(g.app.loadDir,"..","doc",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found:",name)
#@-node:ekr.20090628075121.5994:leoQuickStart
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'beautify-all':                 c.beautifyAllPythonCode,
    'beautify-tree':                c.beautifyPythonTree,
    'beautify':                     c.beautifyPythonCode,
    'cascade-windows':              f.cascade,
    'check-derived-file':           c.atFileCommands.checkDerivedFile,
    'check-leo-file':               c.fileCommands.checkLeoFile,
    'clear-recent-files':           c.clearRecentFiles,
    'clean-recent-files':           c.cleanRecentFiles,
    'sort-recent-files':            c.sortRecentFiles,
    'close-window':                 c.close,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'check-python-code':            c.checkPythonCode,
    'check-all-python-code':        c.checkAllPythonCode,
    'check-outline':                c.checkOutline,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'contract-node':                c.contractNode,
    'contract-all':                 c.contractAllHeadlines,
    'contract-all-other-nodes':     c.contractAllOtherNodes,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-section':              c.extractSection,
    'find-next-clone':              c.findNextClone,
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-visible-node':      c.goToFirstVisibleNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible-node':       c.goToLastVisibleNode,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hide-invisibles':              c.hideInvisibles,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-child':                 c.insertChild,
    'insert-node':                  c.insertHeadline,
    'insert-body-time':             c.insertBodyTime,
    'insert-headline-time':         f.insertHeadlineTime,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    'mark-changed-roots':           c.markChangedRoots,
    'mark-clones':                  c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-brackets':               c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-myLeoSettings-leo':       c.openMyLeoSettings,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-offline-tutorial':        f.leoHelp,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-quickstart-leo':          c.leoQuickStart,
    'open-scripts-leo':             c.openLeoScripts,
    'open-users-guide':             c.leoUsersGuide,
    'open-with':                    c.openWith,
    'outline-to-cweb':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-auto-nodes':           c.readAtAutoNodes,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-at-shadow-nodes':         c.readAtShadowNodes,
    'read-outline-only':            c.readOutlineOnly,
    'read-file-into-node':          c.readFileIntoNode,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-as-unzipped':        c.saveAsUnzipped,
    'save-file-as-zipped':          c.saveAsZipped,
    'save-file-to':                 c.saveTo,
    'settings':                     c.preferences,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'show-invisibles':              c.showInvisibles,
    'sort-children':                c.sortChildren,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-invisibles':            c.toggleShowInvisibles,
    'toggle-sparce-move':           c.toggleSparseMove,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-auto-nodes':          c.atFileCommands.writeAtAutoNodes,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-at-shadow-nodes':        c.fileCommands.writeAtShadowNodes,
    'write-dirty-at-auto-nodes':    c.atFileCommands.writeDirtyAtAutoNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-dirty-at-shadow-nodes':  c.fileCommands.writeDirtyAtShadowNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
    'write-file-from-node':         c.writeFileFromNode,
}
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@-node:ekr.20090628075121.8433:Added open-quickstart-leo
#@+node:ekr.20090629192235.5986:Added tree bindings for page-up/down commands
@nocolor

This was a binding issue. Leo has a full range of scrolling commands. They work.

The old bindings bound the PageUp/Down keys to back/forward page commands, and
these commands work only for text.

The new default bindings in leoSettings.leo: @keys EKR bindings are:

back-page                       ! text = PageUp
back-page-extend-selection      ! text = Shift-PageUp
forward-page                    ! text = PageDn
forward-page-extend-selection   ! text = Shift-PageDn

scroll-down-half-page   ! tree = Shift-PageDn
scroll-down-page        ! tree = PageDn
scroll-up-half-page     ! tree = Shift-PageUp
scroll-up-page          ! tree = PageUp         
#@-node:ekr.20090629192235.5986:Added tree bindings for page-up/down commands
#@+node:ekr.20090629192235.5985:Issue error message re non-existent plugins
@nocolor-node

leo now prints an error message when @enabled-plugins node contains a plugin
that does not exist.
#@nonl
#@+node:ekr.20031218072017.3440:loadHandlers & helper
def loadHandlers(tag):

    """Load all enabled plugins from the plugins directory"""

    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    def pr (*args,**keys):
        if not g.app.unitTesting:
            g.es_print(*args,**keys)

    plugins_path = g.os_path_finalize_join(g.app.loadDir,"..","plugins")
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_finalize(theFile) for theFile in files]

    s = g.app.config.getEnabledPlugins()
    if not s: return

    if tag == 'open0' and not g.app.silentMode and not g.app.batchMode:
        # g.trace(tag,g.callers(4))
        pr('@enabled-plugins found in %s' % (
            g.app.config.enabledPluginsFileName),color='blue')

    enabled_files = getEnabledFiles(s,plugins_path)

    # Load plugins in the order they appear in the enabled_files list.
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                loadOnePlugin(theFile,tag=tag)

    # Warn about any non-existent enabled file.
    if warn_on_failure and tag == 'open0':
        for z in enabled_files:
            if z not in files:
                g.es_print('plugin does not exist:',
                    g.shortFileName(z),color="red")

    # Note: g.plugin_signon adds module names to g.app.loadedPlugins
    if 0:
        if g.app.loadedPlugins:
            pr("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
#@+node:ekr.20070224082131:getEnabledFiles
def getEnabledFiles (s,plugins_path):

    '''Return a list of plugins mentioned in non-comment lines of s.'''

    enabled_files = []
    for s in g.splitLines(s):
        s = s.strip()
        if s and not s.startswith('#'):
            path = g.os_path_finalize_join(plugins_path,s)
            enabled_files.append(path)

    return enabled_files
#@-node:ekr.20070224082131:getEnabledFiles
#@-node:ekr.20031218072017.3440:loadHandlers & helper
#@-node:ekr.20090629192235.5985:Issue error message re non-existent plugins
#@-node:ekr.20090628075121.8434:Features
#@-node:ekr.20090623072844.10385:4.6 rc1
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
