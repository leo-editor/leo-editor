#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20080408060320.4:4.5 b1
@
The first 4.5 release will be 4.5 b1.

The b1 release featured several major code reorgs:

- New drawing code.
- New node organization: replaced links with arrays.
    This is compatible with the node structure needed by the graph world.
- Completed the transition to sax-based parsing.
#@nonl
#@+node:ekr.20080506135044.2:Unposted posting about removing .parents list
@nocolor

Unless I hear a truly convincing reason why I shouldn't, I plan to removed v.parents entirely from the sax-graph world. My reasons are as follows:

1. v.parents is actually used in exactly one place, namely p.setAllAncestorAtFileNodesDirty.  Because this is a position method, the full position stack is available, so the vnodes of all direct parents are available.  This means, in turn, that v.t.vnodeList is available, so at each level all clones of v are also available.

This is only a special case.  In general, given a position, it is possible to *compute* all information about parents.

2. As a result, all the work following work is essentially wasted: initing v.parents during reads, and updating v.parents during moves, clones, insertions, deletions, promotions, demotions, and the corresponding undo/redo for all these operations.

It's not so much that the work is odious: it's not.  It's just that conceptually it is completely unnecessary.  Because the work exists, it must be checked: unit tests written, code added to the check-outline command, etc.  All for nothing.

3. Conceptually, the big aha in the unified node world, and *also* in the graph world, is that the *combination* of positions and nodes is what defines the graph.  In any context containing a position p, the combination of p and p.v.t.children is the minimum needed to get *all* information about the graph.  That being so, the parents list adds nothing. 

4. Continuing with the idea in 3, good things often happen when one eliminates an entire area of complexity.  Not only does eliminating the parents list give us the "simplest thing that could possibly work", there is the as-yet-unexplored possibility of future improvements.  That is, this is not merely an implementation issue--by generalizing and simplifying the data structure we open the door to using that data structure in previously unimagined contexts.

So to repeat, I am very likely to get rid of v.parents. I must rewrite p.setAllAncestorAtFileNodesDirty first, so there is still time to voice any objections.  They had better be good :-)

Edward
#@nonl
#@-node:ekr.20080506135044.2:Unposted posting about removing .parents list
#@+node:ekr.20080408060320.782:Bug fixes
#@+node:ekr.20080506135044.13:Recent graph-world bugs
#@+node:ekr.20080506135044.14:Fixed paste outline
#@-node:ekr.20080506135044.14:Fixed paste outline
#@+node:ekr.20080506135044.15:Fixed two recent node bugs
@nocolor

1. clone-find-all truncated the outline.
   The fix was in p.linkAsRoot.

2. The move outline down command skipped nodes.
   The fix was to p.moveAfter.

3. Added defensive code to p.unlink.

@color
#@nonl
#@-node:ekr.20080506135044.15:Fixed two recent node bugs
#@+node:ekr.20080506135044.16:Fixed bug: Deleting the root didn't select another node
#@-node:ekr.20080506135044.16:Fixed bug: Deleting the root didn't select another node
#@+node:ekr.20080506135044.17:The str_leo_pos uA was not being cleared
#@-node:ekr.20080506135044.17:The str_leo_pos uA was not being cleared
#@+node:ekr.20080506135044.18:Fixed bug: Moving a clone to the root lost the clone mark
#@-node:ekr.20080506135044.18:Fixed bug: Moving a clone to the root lost the clone mark
#@+node:ekr.20080506135044.19:Fixed paste-retaining-clones
# getLeoOutlineFromClipboard now recreates the tnodesDict as needed.
#@nonl
#@-node:ekr.20080506135044.19:Fixed paste-retaining-clones
#@+node:ekr.20080506135044.20:Rewrote sort code
#@-node:ekr.20080506135044.20:Rewrote sort code
#@+node:ekr.20080506135044.21:Rewrote promote/demote code
#@-node:ekr.20080506135044.21:Rewrote promote/demote code
#@+node:ekr.20080506135044.22:Fixed undo/redo move
#@-node:ekr.20080506135044.22:Fixed undo/redo move
#@+node:ekr.20080506135044.23:Fixed inconsistencies between parents and children arrays
#@-node:ekr.20080506135044.23:Fixed inconsistencies between parents and children arrays
#@+node:ekr.20080506135044.24:Rewrote scanForClonedSibs
#@-node:ekr.20080506135044.24:Rewrote scanForClonedSibs
#@+node:ekr.20080506135044.25:Fixed bug: ancestors were not being marked dirty properly
#@-node:ekr.20080506135044.25:Fixed bug: ancestors were not being marked dirty properly
#@+node:ekr.20080506135044.26:Bug: Undo move crashes
@nocolor

This was fixed by calling p._adjustPositionBeforeUnlink.

Traceback (most recent call last):
  File "C:\leo.repo\sax-graph\leo\src\leoCommands.py", line 289, in doCommand
    val = command(event)
  File "C:\leo.repo\sax-graph\leo\src\leoUndo.py", line 1736, in undo
    if u.undoHelper: u.undoHelper()
  File "C:\leo.repo\sax-graph\leo\src\leoUndo.py", line 1921, in undoMove
    assert u.newParent_v.t.children[u.newN] == v
IndexError: list index out of range

#@-node:ekr.20080506135044.26:Bug: Undo move crashes
#@+node:ekr.20080506135044.27:Bug: Selection gets lost
# when moving node down into child
# when expanding node with alt-rtArrow

# This was fixed by calling p._adjustPositionBeforeUnlink.
#@nonl
#@-node:ekr.20080506135044.27:Bug: Selection gets lost
#@+node:ekr.20080506135044.28:Fixed bug involving p._unlink
#@+node:ekr.20080506135044.29:Posting
@nocolor

A brief period of testing revealed two, possibly three bugs that must be
fixed before the sax-graph branch will be usable.  One bug in particular is
interesting.  Code similar to the following code appears in several places
in leoNodes.py:

def insertAsNthChild(self,parent):
    p = self
    p._unlink()
    p._linkAsNthChild(parent)

This works in the "linked" world, but it must be modified for the graph
world.  Indeed, unlinking p can change the position at which p is to be
linked.  For example, suppose we have:

A
B
C

And we wish to move B to the first child of C.  After unlinking B, we will
have:

A
C

Notice: C's childIndex has changed from 2 to 1 but it has *not* changed in
the parent arg to p._linkAsNthChild(parent).  To handle this, Leo will need
code such as:

def insertAsNthChild(self,parent):
    p = self
    p._unlink()
    parent = p._adjustPositionAfterUnlink(parent)
    p._linkAsNthChild(parent)

p._adjustPositionAfterUnlink(parent) can adjust the parent position as
needed **provided** that p._unlink() does *not* change position p, but only
changes p.v.t.children, p.v.t.parents and p.v.t.vnodeList.  In particular,
p._adjustPositionAfterUnlink(parent) only needs to compare the stacks of
positions p and parent in order to adjust parent.  This breaks the circular
dependency: the position can be adjusted even after the actual links
(parents, children arrays) have be changed. 
#@nonl
#@-node:ekr.20080506135044.29:Posting
#@-node:ekr.20080506135044.28:Fixed bug involving p._unlink
#@+node:ekr.20080506135044.30:Moved parents ivar into vnodes
#@-node:ekr.20080506135044.30:Moved parents ivar into vnodes
#@+node:ekr.20080506135044.31:Bug: clone-find-all fails check-outline
#@-node:ekr.20080506135044.31:Bug: clone-find-all fails check-outline
#@+node:ekr.20080506135044.32:Linking/unlinking all clones into parents list
#@-node:ekr.20080506135044.32:Linking/unlinking all clones into parents list
#@+node:ekr.20080506135044.33:Fixed bug: check-outline failed after clone and clone-find-all
#@-node:ekr.20080506135044.33:Fixed bug: check-outline failed after clone and clone-find-all
#@+node:ekr.20080506135044.34:Fixed bug: sort did not select a node
#@-node:ekr.20080506135044.34:Fixed bug: sort did not select a node
#@+node:ekr.20080506135044.35:Fixed bug in clone (caused undo to fail)
#@-node:ekr.20080506135044.35:Fixed bug in clone (caused undo to fail)
#@+node:ekr.20080506135044.36:Fixed bug in createChapterByName
#@-node:ekr.20080506135044.36:Fixed bug in createChapterByName
#@-node:ekr.20080506135044.13:Recent graph-world bugs
#@+node:ekr.20080425062953.1:Fixed bug in appendToRecentFiles
#@+node:ekr.20041201080436:appendToRecentFiles (g.app.config)
def appendToRecentFiles (self,files):

    files = [theFile.strip() for theFile in files]

    # g.trace(files)

    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles[:]:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@-node:ekr.20041201080436:appendToRecentFiles (g.app.config)
#@-node:ekr.20080425062953.1:Fixed bug in appendToRecentFiles
#@+node:ekr.20080408060320.2:Fixed bug in install script
@nocolor

On Mon, Apr 7, 2008 at 7:07 PM, SegundoBob <bhossley@ieee.org> wrote:

I installed Leo 4.4..8 final on Ubuntu.  The installation failed
because the installation put files in /usr/lib/leo/leo.  The
duplicated leo is a mistake.
On line 13 of install I changed:
LEO_LIB_DIR="${LEO_PREFIX}/lib/leo"
to
LEO_LIB_DIR="${LEO_PREFIX}/lib"

With the change the installation worked.
#@nonl
#@-node:ekr.20080408060320.2:Fixed bug in install script
#@+node:ekr.20080506135044.12:Fixed bug: no focus after save-as and save-to commands
#@-node:ekr.20080506135044.12:Fixed bug: no focus after save-as and save-to commands
#@+node:ekr.20080501180847.1:Fixed find bug
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/294866696257802e

For some reason if you remove the key mapping for the "replace-string"
entry in myLeoSettings or leoSettings.leo ( replace-string = None)
then the "search-with-present-options" function (ctrl-f) or the
"search-forward" function (if mapped) displays the request for a
search string in the mini-buffer but returns immediately when any key
is pressed and searches with the "Find:" entry in the "Find" tab.

@color
#@nonl
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    # g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or (c.config.getBool('trace_modes') and not g.app.unitTesting)
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20060205170335.1:aproposFindCommands
def aproposFindCommands (self, event=None):

    '''Prints a discussion of of Leo's find commands.'''

    c = self.c

    << define s >>

    # Remove indentation from s: a workaround of a Leo bug.
    s = g.adjustTripleString(s,c.tab_width)

    if not g.app.unitTesting:
        g.es_print('',s)
#@+node:ekr.20060209082023.1:<< define s >>
s = '''
Note: all bindings shown are the default bindings for these commands.  You may change any of these bindings using @shortcuts nodes in leoSettings.leo.

Settings

leoSettings.leo now contains several settings related to the Find tab:

- @bool show_only_find_tab_options = True

When True (recommended), the Find tab does not show the 'Find', 'Change', 'Change, Then Find', 'Find All' and 'Change All' buttons.

- @bool minibufferSearchesShowFindTab = True

When True, Leo shows the Find tab when executing most of the commands discussed below.

Basic find commands

- open-find-tab makes the Find tab visible.  The Find tab does **not** need to be visible to execute any search command discussed below.

- hide-find-tab hides the Find tab, but retains all the present settings.

- search-with-present-options (Control-F) prompts for a search string.  Typing the <Return> key puts the search string in the Find tab and executes a search based on all the settings in the Find tab. This is a recommended default search command.

- show-search-options shows the present search options in the status line.  This command also makes the Find tab visible.

- find-next (F3) is the same as search-with-present-options, except that it uses the search string in the find-tab.  Recommended as the default 'search again' command.

- Similarly, find-previous (F2) repeats the command specified by the Find tab, but in reverse.

- find-again is the same as find-next if a search pattern is not '<find pattern here>'.
  Otherwise, find-again is the same as search-with-present-options.

Setting find options

- Several minibuffer commands toggle the checkboxes and radio buttons in the Find tab, and thus affect the operation of the search-with-present-options command. Some may want to bind these commands to keys. Others, will prefer to toggle options in a mode.

Here are the commands that toggle checkboxes: toggle-find-ignore-case-option, toggle-find-in-body-option, toggle-find-in-headline-option, toggle-find-mark-changes-option, toggle-find-mark-finds-option, toggle-find-regex-option, toggle-find-reverse-option, toggle-find-word-option, and toggle-find-wrap-around-option.

Here are the commands that set radio buttons: set-find-everywhere, set-find-node-only, and set-find-suboutline-only.

- enter-find-options-mode (Ctrl-Shift-F) enters a mode in which you may change all checkboxes and radio buttons in the Find tab with plain keys.  As always, you can use the mode-help (Tab) command to see a list of key bindings in effect for the mode.

Search commands that set options as a side effect

The following commands set an option in the Find tab, then work exactly like the search-with-present-options command.

- search-backward and search-forward set the 'Whole Word' checkbox to False.

- word-search-backward and word-search-forward set the 'Whole Word' checkbox to True.

- re-search-forward and re-search-backward set the 'Regexp' checkbox to True.

Find all commands

- find-all prints all matches in the log pane.

- clone-find-all replaces the previous 'Clone Find' checkbox.  It prints all matches in the log pane, and creates a node at the beginning of the outline containing clones of all nodes containing the 'find' string.  Only one clone is made of each node, regardless of how many clones the node has, or of how many matches are found in each node.

Note: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by the find-all and clone-find-all commands.

Search and replace commands

- replace-string prompts for a search string.  Type <Return> to end the search string.  The command will then prompt for the replacement string.  Typing a second <Return> key will place both strings in the Find tab and executes a **find** command, that is, search-with-present-options.

So the only difference between replace-string and search-with-present-options is that replace-string has the side effect of setting 'change' string in the Find tab.  However, this is an extremely useful side effect, because of the following commands...

- change (Ctrl-=) replaces the selected text with the 'change' text in the Find tab.

- change-then-find (Ctrl--) replaces the selected text with the 'change' text in the Find tab, then executes the find command again.

find-next, change and change-then-find can simulate any kind of query-replace command.  **Important**: Leo presently has separate query-replace and query-replace-regex commands, but they are buggy and 'under-powered'.  Fixing these commands has low priority.

- change-all changes all occurrences of the 'find' text with the 'change' text.  Important: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by this command.

Incremental search commands

Leo's incremental search commands are completely separate from Leo's legacy search commands.  At present, incremental search commands do not cross node boundaries: they work only in the body text of single node.

Eventually, the incremental commands will maintain a list of previous matches.  This allows for

a) support for backspace and
b) an incremental-search-again command.

Furthermore, this list makes it easy to detect the end of a wrapped incremental search.

Here is the list of incremental find commands: isearch-backward, isearch-backward-regexp, isearch-forward and
isearch-forward-regexp.'''
#@-node:ekr.20060209082023.1:<< define s >>
#@-node:ekr.20060205170335.1:aproposFindCommands
#@-node:ekr.20080501180847.1:Fixed find bug
#@+node:ekr.20080406075855.1:Fixed find completion bug
@nocolor

Trying to edit the minibuffer, when I backspace to a character and
press delete the cursor moves to the end of the buffer and deletes the
last character instead.

@nocolor
#@nonl
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.177:k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c ; w = self.widget

    if 0:
        g.trace('(keyHandler)',g.callers(4))
        g.trace('completion',completion,
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    # Step 1: actually delete the character.
    ins = w.getInsertPoint()
    s = w.getAllText()
    if ins <= len(k.mb_prefix):
        # g.trace('at start')
        return
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)

    # Step 2: compute completions.
    if not completion: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
#@-node:ekr.20061031131434.177:k.doBackSpace
#@-node:ekr.20080406075855.1:Fixed find completion bug
#@+node:ekr.20080407090400.1:Fixed how-many, find-word and goto-character commands
@nocolor

find-word
=========
This command is supposed to:

"Put the cursor at the next word (on a line) that starts with a
character"

It does not. You have to type in a whole word to get any result and
even then
it only selects the word it does not move the cursor to it.


goto-charachter
==============
'''Put the cursor at the n'th character of the buffer.'''

Doesn't do anything.

@color
#@nonl
#@+node:ekr.20050920084036.1:<< define class baseEditCommandsClass >>
class baseEditCommandsClass:

    '''The base class for all edit command classes'''

    @others
#@+node:ekr.20050920084036.2: ctor, finishCreate, init (baseEditCommandsClass)
def __init__ (self,c):

    self.c = c
    self.k = self.k = None
    self.registers = {} # To keep pychecker happy.
    self.undoData = None

def finishCreate(self):

    # Class delegators.
    self.k = self.k = self.c.k
    try:
        self.w = self.c.frame.body.bodyCtrl # New in 4.4a4.
    except AttributeError:
        self.w = None

def init (self):

    '''Called from k.keyboardQuit to init all classes.'''

    pass
#@nonl
#@-node:ekr.20050920084036.2: ctor, finishCreate, init (baseEditCommandsClass)
#@+node:ekr.20051214132256:begin/endCommand (baseEditCommands)
#@+node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
def beginCommand (self,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
#@+node:ekr.20051215102349:beingCommandHelper
# New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  w.getSelectionRange()
        oldText = p.bodyString()
        self.undoData = b = g.Bunch()
        # To keep pylint happy.
        b.ch=ch
        b.name=name
        b.oldSel=oldSel
        b.oldText=oldText
        b.w=w
        b.undoType=undoType
    else:
        self.undoData = None

    return w
#@-node:ekr.20051215102349:beingCommandHelper
#@-node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
#@+node:ekr.20051214133130.1:endCommand
# New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):

    '''Do the common processing at the end of each command.'''

    c = self.c ; b = self.undoData ; k = self.k

    # g.trace('changed',changed)

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)

    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()

    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
#@-node:ekr.20051214133130.1:endCommand
#@-node:ekr.20051214132256:begin/endCommand (baseEditCommands)
#@+node:ekr.20061007105001:editWidget (baseEditCommandsClass)
def editWidget (self,event):

    c = self.c ; w = event and event.widget

    # New in Leo 4.5: single-line editing commands apply to minibuffer widget.
    if w and g.app.gui.isTextWidget(w):
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    # g.trace(self.w)

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@nonl
#@-node:ekr.20061007105001:editWidget (baseEditCommandsClass)
#@+node:ekr.20050920084036.5:getPublicCommands & getStateCommands
def getPublicCommands (self):

    '''Return a dict describing public commands implemented in the subclass.
    Keys are untranslated command names.  Values are methods of the subclass.'''

    return {}
#@-node:ekr.20050920084036.5:getPublicCommands & getStateCommands
#@+node:ekr.20050920084036.6:getWSString
def getWSString (self,s):

    return ''.join([g.choose(ch=='\t',ch,' ') for ch in s])
#@-node:ekr.20050920084036.6:getWSString
#@+node:ekr.20050920084036.7:oops
def oops (self):

    g.pr("baseEditCommandsClass oops:",
        g.callers(),
        "must be overridden in subclass")
#@-node:ekr.20050920084036.7:oops
#@+node:ekr.20050929161635:Helpers
#@+node:ekr.20050920084036.249:_chckSel
def _chckSel (self,event,warning='no selection'):

    c = self.c ; k = self.k

    w = self.editWidget(event)

    val = w and w.hasSelection()

    if warning and not val:
        k.setLabelGrey(warning)

    return val
#@-node:ekr.20050920084036.249:_chckSel
#@+node:ekr.20050920084036.250:_checkIfRectangle
def _checkIfRectangle (self,event):

    k = self.k ; key = event.keysym.lower()

    val = self.registers.get(key)

    if val and type(val) == type([]):
        k.clearState()
        k.setLabelGrey("Register contains Rectangle, not text")
        return True

    return False
#@-node:ekr.20050920084036.250:_checkIfRectangle
#@+node:ekr.20050920084036.233:getRectanglePoints
def getRectanglePoints (self,w):

    c = self.c
    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    r1,r2 = g.convertPythonIndexToRowCol(s,i)
    r3,r4 = g.convertPythonIndexToRowCol(s,j)

    return r1+1,r2,r3+1,r4
#@-node:ekr.20050920084036.233:getRectanglePoints
#@+node:ekr.20051002090441:keyboardQuit
def keyboardQuit (self,event):

    '''Clear the state and the minibuffer label.'''

    return self.k.keyboardQuit(event)
#@-node:ekr.20051002090441:keyboardQuit
#@-node:ekr.20050929161635:Helpers
#@-node:ekr.20050920084036.1:<< define class baseEditCommandsClass >>
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20061007105001:editWidget (baseEditCommandsClass)
def editWidget (self,event):

    c = self.c ; w = event and event.widget

    # New in Leo 4.5: single-line editing commands apply to minibuffer widget.
    if w and g.app.gui.isTextWidget(w):
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    # g.trace(self.w)

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@nonl
#@-node:ekr.20061007105001:editWidget (baseEditCommandsClass)
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or (c.config.getBool('trace_modes') and not g.app.unitTesting)
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20060417194232:find (quick)
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)

def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)

def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)

def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        k.setLabelBlue(s,protect=True)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            # start = s.rfind('\n',0,i)
            # if start == -1: start = 0
            start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            # end = s.find('\n',i)
            # if end == -1: end = len(s)
            end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
def findWord(self,event):

    '''Put the cursor at the next word that starts with a character.'''

    return self.findWordHelper(event,oneLine=False)

def findWordInLine(self,event):

    '''Put the cursor at the next word (on a line) that starts with a character.'''

    return self.findWordHelper(event,oneLine=True)

#@+node:ekr.20080408060320.1:findWordHelper
def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            g.choose(oneLine,'in line ','')))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg ; w = self.w ; c = k.c
        if ch:
            i = w.getInsertPoint()
            s = w.getAllText()
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            else:
                end = len(s)

            while i < end:
                i = s.find(ch,i+1,end) # Ensure progress and i > 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break

        k.resetLabel()
        k.clearState()
#@-node:ekr.20080408060320.1:findWordHelper
#@-node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n >= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.es('goto-char takes non-negative integer argument',color='blue')
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929115226:gotoCharacter
#@-node:ekr.20080407090400.1:Fixed how-many, find-word and goto-character commands
#@+node:ekr.20080424115643.5:Fixed import PHP bug
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/b068e88a577a0547

I have just started using Leo and though not familiar with Python, I
am finding it to be a great program.
I am however having difficulty understanding the ins & outs, for
example;

I am trying to use Leo to organize all my different php scripts I have
on my hard drive, when I try to import any php file I get errors. (see
example) I was able to import html files just fine but I don't
understand what I need to do to import my php files one by one so that
I can organize them in a useful manner.

ex error;
exception executing command
Traceback (most recent call last):
  File "C:\Program Files (x86)\Leo\src\leoCommands.py", line 275, in
doCommand
    val = command(event)
  File "C:\Program Files (x86)\Leo\src\leoCommands.py", line 1508, in
importAtFile
    c.importCommands.importFilesCommand(names,"@file")
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 1004, in
importFilesCommand
    v = self.createOutline(fileName,current)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 869, in
createOutline
    self.scanPHPText(s,p,atAuto=atAuto)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 1671, in
scanPHPText
    scanner.run(s,parent)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 2929, in
run
    self.scan(s,parent)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 2394, in
scan
    i = self.skipDecls(s,0,len(s),inClass=False)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 2615, in
skipDecls
    i = self.skipString(s,i)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 3461, in
skipString
    return self.skipString()
TypeError: skipString() takes exactly 3 arguments (1 given)

@color
#@nonl
#@+node:ekr.20070711090052.1:class phpScanner
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'

    self.hasClasses = False
    self.hasFunctions = True

    self.functionTags = ['function']

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php and ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return g.skip_string(s,i)
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner
#@-node:ekr.20080424115643.5:Fixed import PHP bug
#@+node:ekr.20080506135044.7:Fixed keyword handling in g.es and g.es_print
#@-node:ekr.20080506135044.7:Fixed keyword handling in g.es and g.es_print
#@+node:ekr.20080405074410.39:Fixed new @auto bug
@nocolor

Leo's running, so I create a new outline with File->New

Then I save as in a location where foo.py exists.

The I create a node '@auto foo.py'

Then I use File->Read/Write->Read @auto (with that node selected)

Leo says it can't read it.

I close the leo file, re-open in from the recent files menu of the
outline that spawned it, and the @auto file is read no problems.

@color
#@nonl
#@+node:ekr.20031218072017.1839:readAtFileNodes (commands)
def readAtFileNodes (self,event=None):

    '''Read all @file nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    c.fileCommands.readAtFileNodes()
    u.afterChangeTree(p,'Read @file Nodes',undoData)
    c.redraw()
#@-node:ekr.20031218072017.1839:readAtFileNodes (commands)
#@+node:ekr.20031218072017.3029:readAtFileNodes (fileCommands)
def readAtFileNodes (self):

    c = self.c ; p = c.currentPosition()

    # c.beginUpdate()
    # try:
    c.atFileCommands.readAll(p,partialFlag=True)
    # finally:
    c.redraw() # was c.endUpdate()

    # Force an update of the body pane.
    c.setBodyString(p,p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20031218072017.3029:readAtFileNodes (fileCommands)
#@+node:ekr.20041005105605.26:readAll (atFile)
def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if not p.headString().startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for v in c.all_unique_vnodes_iter():
        v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")

    if use_tracer: tt.stop()
#@-node:ekr.20041005105605.26:readAll (atFile)
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)

    g.trace(fileName)

    if not g.unitTesting:
        g.es("reading:",p.headString())

    # Delete all children.
    # c.beginUpdate()
    # try:
    while p.hasChildren():
        p.firstChild().doDelete()
    # finally:
    # c.endUpdate(False)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        #c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = g.os_path_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        # c.beginUpdate()
        # try:
        p.setBodyString('')
        # finally:
        # c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".js":
        self.scanJavaScriptText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    elif ext in ('.html','.htm','.xml'):
        self.scanXmlText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    z = g.choose(atAuto,'@auto ','')
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (z,fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

path = theDict["path"]
path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@-node:ekr.20080405074410.39:Fixed new @auto bug
#@+node:ekr.20080424061644.1:Fixed recent files bug
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/c6c4faf6fdead672

To reproduce:

Run leo.
Go to "File->Save as" and save the empty outline template somewhere,
for example to /tmp/test.leo
It will appear in "File->Recent files"
When trying to open it from there, I get the following traceback:

---
Error: 1
<type 'exceptions.AttributeError'> Exception in Tk callback
 Function: <function recentFilesCallback at 0x8ba8df4> (type: <type
'function'>)
 Args: ()
Traceback (innermost last):
 File "/home/shadow/leo/extensions/Pmw/Pmw_1_3/lib/PmwBase.py", line
1747, in __call__
   return apply(self.func, args)
 File "/home/shadow/leo/src/leoMenu.py", line 1599, in
recentFilesCallback
   c.openRecentFile(name)
 File "/home/shadow/leo/src/leoCommands.py", line 1173, in
openRecentFile
   c = frame.c # Switch to the new commander so the "recentfiles2"
hook doesn't crash.
<type 'exceptions.AttributeError'>: leoTkinterFrame instance has no
attribute 'c'
---

leo seems to crash, I hit Ctrl-C to stop it.
When I run leo again, there is no entry for test.leo in "File->Recent
files"

Leo 4.4.8 final, build  1.244 , April 6, 2008
python 2.5.1, Tk 8.4.16, Pmw 1.3
OS: Linux

This behaviour doesn't hurt me at all, I've found it accidentally.

@color
#@nonl
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            frame.c.outerUpdate()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)
    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    # c.beginUpdate()
    # try:
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        app.lockLog()
        frame.c.fileCommands.open(
            theFile,fileName,
            readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
        app.unlockLog()
        for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
            # The recent files list has been updated by c.updateRecentFiles.
            z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.currentPosition()
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # finally:
    c.redraw() # was c.endUpdate()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2079:Recent Files submenu & allies
#@+node:ekr.20031218072017.2080:clearRecentFiles
def clearRecentFiles (self,event=None):

    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer

    bunch = u.beforeClearRecentFiles()

    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.deleteRecentFilesMenuItems(recentFilesMenu)

    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.relativeFileName())

    g.app.config.appendToRecentFiles(c.recentFiles)

    # g.trace(c.recentFiles)

    u.afterClearRecentFiles(bunch)

    # New in Leo 4.4.5: write the file immediately.
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:ekr.20031218072017.2080:clearRecentFiles
#@+node:ekr.20031218072017.2081:openRecentFile
def openRecentFile(self,name=None):

    if not name: return

    c = self ; v = c.currentVnode()
    << Set closeFlag if the only open window is empty >>

    fileName = name
    if not g.doHook("recentfiles1",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag and frame != c.frame:
            g.app.destroyWindow(c.frame) # 12/12/03
            c = frame.c # Switch to the new commander so the "recentfiles2" hook doesn't crash.
            c.setLog() # Sets the log stream for g.es

    g.doHook("recentfiles2",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
#@+node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2081:openRecentFile
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    if g.app.unitTesting: return

    def munge(name):
        return g.os_path_normpath(name or '').lower()
    def munge2(name):
        return g.os_path_abspath(g.os_path_join(g.app.loadDir,name or ''))

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if munge(fileName) == munge(name) or munge2(fileName) == munge2(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace('adding',fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@+node:tbrown.20080509212202.6:cleanRecentFiles
def cleanRecentFiles(self,event=None):

    c = self

    dat = c.config.getData('path-demangle')
    if not dat:
        g.es('No @data path-demangle setting')
        return

    changes = []
    replace = None
    for line in dat:
        text = line.strip()
        if text.startswith('REPLACE: '):
            replace = text.split(None, 1)[1].strip()
        if text.startswith('WITH:') and replace is not None:
            with_ = text[5:].strip()
            changes.append((replace, with_))
            g.es('%s -> %s' % changes[-1])

    orig = [i for i in c.recentFiles if i.startswith("/")]
    c.clearRecentFiles()

    for i in orig:
        t = i
        for change in changes:
            t = t.replace(*change)

        c.updateRecentFiles(t)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:tbrown.20080509212202.6:cleanRecentFiles
#@+node:tbrown.20080509212202.8:sortRecentFiles
def sortRecentFiles(self,event=None):

    c = self

    orig = c.recentFiles[:]
    c.clearRecentFiles()
    import os
    orig.sort(cmp=lambda a,b:cmp(os.path.basename(b).lower(),     
        os.path.basename(a).lower()))
    for i in orig:
        c.updateRecentFiles(i)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:tbrown.20080509212202.8:sortRecentFiles
#@-node:ekr.20031218072017.2079:Recent Files submenu & allies
#@-node:ekr.20080424061644.1:Fixed recent files bug
#@+node:ekr.20080418154703.1:Fixed Tangle bugs
#@+node:ekr.20031218072017.2062:getPrefs
# Note: Leo 4.3 does not write these settings to local .leo files.
# Instead, corresponding settings are contained in leoConfig.leo files.

def getPrefs (self):

    c = self.c

    if self.getOpenTag("<preferences"):
        return # <preferences/> seen

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))

    done = False
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                    # g.trace(var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag("/>"):
                done = True ; break
            if self.matchTag(">"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    if not done:
        while 1:
            if self.matchTag("<defaultDirectory>"):
                # New in version 0.16.
                c.tangle_directory = self.getEscapedString()
                self.getTag("</defaultDirectory>")
                if not g.os_path_exists(c.tangle_directory):
                    g.es("default tangle directory not found:",c.tangle_directory)
            elif self.matchTag("<TSyntaxMemo_options>"):
                self.getEscapedString() # ignored
                self.getTag("</TSyntaxMemo_options>")
            else: break
        self.getTag("</preferences>")
#@+node:ekr.20031218072017.2063:getTargetLanguage
def getTargetLanguage (self):

    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language

    return "c" # default
#@-node:ekr.20031218072017.2063:getTargetLanguage
#@-node:ekr.20031218072017.2062:getPrefs
#@+node:ekr.20031218072017.3579:error, pathError, warning
def error (self,s):
    self.errors += 1
    g.es_error(g.translateString(s))

def pathError (self,s):
    if not self.path_warning_given:
        self.path_warning_given = True
        self.error(s)

def warning (self,s):
    g.es_error(g.translateString(s))
#@-node:ekr.20031218072017.3579:error, pathError, warning
#@-node:ekr.20080418154703.1:Fixed Tangle bugs
#@+node:ekr.20080506135044.8:Greatly increased speed of undo clone-find-all
# findAll now just creates undo info for clone-find-all for one inserted node.
#@nonl
#@+node:ekr.20080506135044.9:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                undoData = u.beforeInsertNode(c.currentPosition())
                << create the found node >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        # u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    self.restore(data)
    c.redraw_now()
    g.es("found",count,"matches")

#@+node:ekr.20080506135044.10:<< create the found node >>
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
#@-node:ekr.20080506135044.10:<< create the found node >>
#@+node:ekr.20080506135044.11:<< create a clone of p under the find node >>
q = self.p.clone()
q.moveToLastChildOf(found)
#@-node:ekr.20080506135044.11:<< create a clone of p under the find node >>
#@-node:ekr.20080506135044.9:findAll
#@-node:ekr.20080506135044.8:Greatly increased speed of undo clone-find-all
#@+node:ekr.20080502114149.2:Temporary fix for php import bug
#@+node:ekr.20080502114149.3:file
ok here is short form of the php file for your review; I am trying to
explain that this is the way Leo imported the file into 2 sections,
instead of having the complete begining and end php tags on the same
'section', it separated them.  I hope this helps.

***FIST SECTION BEGINS***

//@+leo-ver=4
//@+node:@file C:\inetpub\wwwroot\0_PHP_Template\incl\0_sitedef.php
//@@language php
//@@tabwidth -4
//@+others
//@+node:0_sitedef declarations
<?php /*Cascade Style Sheet style1.css*/
?>
<link href="../stex.css" rel="stylesheet" type="text/css" />

<?php
/*
Choice of language for website yes/no
*/
$ADD_LANGUAGE_CHOICE = 'yes';
/*
If 'Yes' you need to create images based on content/filename.htm
ex: /imgs/bttns_index.jpg
$NAV_IMAGES ='yes';
*/

?>

<?php /* Contact information */
$domain = "domain.com";

?>

<?php /* Content Script; reads .htm files in Content Directory */

*** FIRST SECTION ENDS => NOTICE THE LAST LINE OF FILE IS A BEGINING <?
PHP TAG THAT SHOULD BE FIRST LINE ON SECOND SECTION ***

*** SECOND SECTION BEGINS ***

//@-node:0_sitedef declarations
//@+node:include
include('language.php');

$mycontentdir = "content"."/".$mylanguage;
if ($main_page == "") $main_page = "index";


$pagename = $main_page;
$ptitle = $company . " " . $main_page . " page " . $tel ." " . $city .
" " . $state . " " . $zip;

$main_page = "" . $main_page . ".htm";

/* if (is_file("$mycontentdir/$main_page")) {
$open = fopen("$mycontentdir/$main_page", "r");
$size = filesize("$mycontentdir/$main_page");
$content = fread($open, $size); */
//}
?>

<?php
/*Echo's Website*/
function hpo(){
echo '<div class="hpo">whatever text goes here</a> </div>';
}
//@-node:include
//@-others
?>
//@-node:@file C:\inetpub\wwwroot\0_PHP_Template\incl\0_sitedef.php
//@-leo

*** SECOND SECTION ENDS ***
#@nonl
#@-node:ekr.20080502114149.3:file
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = g.os_path_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        # c.beginUpdate()
        # try:
        p.setBodyString('')
        # finally:
        # c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".js":
        self.scanJavaScriptText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    elif ext in ('.html','.htm','.xml'):
        self.scanXmlText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    z = g.choose(atAuto,'@auto ','')
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (z,fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20070711090122:scanPHPText
def scanPHPText (self,s,parent,atAuto=False):

    scanner = phpScanner(importCommands=self,atAuto=atAuto)
    scanner.run(s,parent)

    # if scanner.isPurePHP(s):
        # scanner.run(s,parent)
    # else:
        # fileName = scanner.fileName
        # if atAuto:
            # g.pr('seems to be mixed HTML and PHP:',fileName)
        # else:
            # g.es_print('seems to be mixed HTML and PHP:',fileName)
        # scanner.createHeadline(
            # parent,body=s,headline=fileName)
#@-node:ekr.20070711090122:scanPHPText
#@+node:ekr.20070711090052.1:class phpScanner
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'

    self.hasClasses = False
    self.hasFunctions = True

    self.functionTags = ['function']

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php and ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return g.skip_string(s,i)
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner
#@-node:ekr.20080502114149.2:Temporary fix for php import bug
#@+node:ekr.20080517075806.21:Fixed unbounded loop in autocompleter.findAnchor
#@-node:ekr.20080517075806.21:Fixed unbounded loop in autocompleter.findAnchor
#@+node:ekr.20080517184420.1:Fixed insert-newline bug
exception executing command
Traceback (most recent call last):
 File "C:\_Proj\Leo\key-handling\leo\src\leoCommands.py", line 298, in doCommand
   val = command(event)
 File "C:\_Proj\Leo\key-handling\leo\src\leoEditCommands.py", line 2946, in insertNewLine
   self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
 File "C:\_Proj\Leo\key-handling\leo\src\leoEditCommands.py", line 3104, in insertNewlineHelper
   w.setInsertPoint(i+1)
TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'
truncating headline to one line
#@+node:ekr.20050920084036.138:insertNewLine (changed)
def insertNewLine (self,event):

    '''Insert a newline at the cursor.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    assert g.app.gui.isTextWidget(w)
    name = c.widget_name(w)
    if name.startswith('head'): return

    oldSel =  w.getSelectionRange()

    self.beginCommand(undoType='newline')

    # New in Leo 4.5: use the same logic as in selfInsertCommand.
    self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
    k.setInputState('insert')
    k.showStateAndMode()

    self.endCommand()

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine (changed)
#@+node:ekr.20050920084036.86:insertNewLineAndTab (changed)
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab at the cursor.'''

    c = self.c ; k = c.k
    w = self.editWidget(event) ; p = c.currentPosition()
    if not w: return

    assert g.app.gui.isTextWidget(w)
    name = c.widget_name(w)
    if name.startswith('head'): return

    self.beginCommand(undoType='insert-newline-and-indent')

    # New in Leo 4.5: use the same logic as in selfInsertCommand.
    oldSel = w.getSelectionRange()
    self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
    self.updateTab(p,w)
    k.setInputState('insert')
    k.showStateAndMode()

    self.endCommand(changed=True,setLabel=False)
#@-node:ekr.20050920084036.86:insertNewLineAndTab (changed)
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper
#@-node:ekr.20080517184420.1:Fixed insert-newline bug
#@+node:ekr.20080520084355.2:Single click did not color body correctly
#@+node:ekr.20061031131434.192:showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return

    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return

    # g.trace(w, state, mode,g.callers(5))

    wname = g.app.gui.widget_name(w).lower()

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    elif w and (wname.startswith('canvas') or wname.startswith('head')):
        s = 'In Outline'
        inOutline = True
    else:
        s = '%s State' % state.capitalize()

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and g.app.gui.isTextWidget(w):
        k.showStateColors(inOutline,w)
#@-node:ekr.20061031131434.192:showStateAndMode
#@+node:ekr.20080512115455.1:showStateColors
def showStateColors (self,inOutline,w):

    k = self ; c = k.c ; state = k.unboundKeyAction

    body = c.frame.body ; bodyCtrl = body.bodyCtrl

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    # g.trace(state,w,g.app.gui.widget_name(w),g.callers(4))

    # if inOutline and w == bodyCtrl:
        # return # Don't recolor the body.
    if w != bodyCtrl and not g.app.gui.widget_name(w).startswith('head'):
        # Don't recolor the minibuffer, log panes, etc.
        return

    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    # g.trace(id(w),bg,fg,self)

    if w == bodyCtrl:
        body.setEditorColors(bg=bg,fg=fg)
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
#@-node:ekr.20080512115455.1:showStateColors
#@+node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
def OnBodyClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
            self.OnActivateBody(event=event)
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
#@-node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
#@+node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if event and not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
            c.editCommands.extendToWord(event) # Handles unicode properly.
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodydclick")

    return "break" # Restore this to handle proper double-click logic.
#@-node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
#@-node:ekr.20080520084355.2:Single click did not color body correctly
#@+node:ekr.20080520084355.1:Body not colored correctly after find
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.body.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible(c)
    # c.beginUpdate()
    # try:
    if sparseFind and not c.currentPosition().isAncestorOf(p):
        # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
        for p2 in c.currentPosition().self_and_parents_iter():
            p2.contract()
            redraw = True
    for p in self.p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw = True
    p = self.p
    if not p: g.trace('can not happen: self.p is None')
    c.selectPosition(p)
    # finally:
    if redraw: c.redraw() # was c.endUpdate(redraw)

    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    c.widgetWantsFocusNow(w)
    c.k.showStateAndMode(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@+node:ekr.20031218072017.3089:restore
# Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data

    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    if p:
        c.selectPosition(p)
    else:
        c.selectPosition(c.rootPosition()) # New in Leo 4.5.

    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()

    #g.trace(c.widget_name(t))

    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        c.k.showStateAndMode(c.frame.body.bodyCtrl)
    else:
        c.widgetWantsFocusNow(t)
#@-node:ekr.20031218072017.3089:restore
#@+node:ekr.20061031131434.192:showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return

    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return

    # g.trace(w, state, mode,g.callers(5))

    wname = g.app.gui.widget_name(w).lower()

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    elif w and (wname.startswith('canvas') or wname.startswith('head')):
        s = 'In Outline'
        inOutline = True
    else:
        s = '%s State' % state.capitalize()

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and g.app.gui.isTextWidget(w):
        k.showStateColors(inOutline,w)
#@-node:ekr.20061031131434.192:showStateAndMode
#@-node:ekr.20080520084355.1:Body not colored correctly after find
#@+node:ekr.20080527084425.2:Fixed big performance bug in contract-all command
#@+node:ekr.20040803072955.6:Allocation...
#@+node:ekr.20040803072955.7:newBox
def newBox (self,p,x,y,image):

    canvas = self.canvas ; tag = "plusBox"

    if self.freeBoxes:
        # theId = self.freeBoxes.pop(0)
        d = self.freeBoxes ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x,y)
        canvas.itemconfigure(theId,image=image)
    else:
        theId = canvas.create_image(x,y,image=image,tag=tag)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleBoxes: 
        self.visibleBoxes.append(theId)

    if p:
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.7:newBox
#@+node:ekr.20040803072955.8:newClickBox
def newClickBox (self,p,x1,y1,x2,y2):

    canvas = self.canvas ; defaultColor = ""
    tag = g.choose(p.hasChildren(),'clickBox','selectBox')

    if self.freeClickBoxes:
        # theId = self.freeClickBoxes.pop(0)
        d = self.freeClickBoxes ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x1,y1,x2,y2)
        canvas.itemconfig(theId,tag=tag)
    else:
        theId = self.canvas.create_rectangle(x1,y1,x2,y2,tag=tag)
        canvas.itemconfig(theId,fill=defaultColor,outline=defaultColor)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleClickBoxes:
        self.visibleClickBoxes.append(theId)
    if p:
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.8:newClickBox
#@+node:ekr.20040803072955.9:newIcon
def newIcon (self,p,x,y,image):

    canvas = self.canvas ; tag = "iconBox"

    if self.freeIcons:
        # theId = self.freeIcons.pop(0)
        d = self.freeIcons ; theId = d.keys()[0] ; del d[theId]
        canvas.itemconfigure(theId,image=image)
        canvas.coords(theId,x,y)
    else:
        theId = canvas.create_image(x,y,image=image,anchor="nw",tag=tag)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleIcons:
        self.visibleIcons.append(theId)

    if p:
        data = p,self.generation
        self.iconIds[theId] = data # Remember which vnode belongs to the icon.
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.9:newIcon
#@+node:ekr.20040803072955.10:newLine
def newLine (self,p,x1,y1,x2,y2):

    canvas = self.canvas

    if self.freeLines:
        # theId = self.freeLines.pop(0)
        d = self.freeLines ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x1,y1,x2,y2)
    else:
        theId = canvas.create_line(x1,y1,x2,y2,tag="lines",fill="gray50") # stipple="gray25")
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if p:
        self.ids[theId] = p

    if theId not in self.visibleLines:
        self.visibleLines.append(theId)

    return theId
#@-node:ekr.20040803072955.10:newLine
#@+node:ekr.20040803072955.11:newText (tkTree) and helper
def newText (self,p,x,y):

    canvas = self.canvas ; tag = "textBox"
    c = self.c ;  k = c.k
    if self.freeText:
        # w,theId = self.freeText.pop()
        d = self.freeText ; data = d.keys()[0] ; w,theId = data ; del d[data]
        canvas.coords(theId,x,y) # Make the window visible again.
            # theId is the id of the *window* not the text.
    else:
        # Tags are not valid in Tk.Text widgets.
        self.textNumber += 1
        w = g.app.gui.plainTextWidget(
            canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
        w.bindtags(self.textBindings) # Set the bindings for this widget.

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>

        theId = canvas.create_window(x,y,anchor="nw",window=w,tag=tag)
        w.leo_window_id = theId # Never changes.

        if self.trace_alloc: g.trace('%3d %6s' % (theId,id(w)),align=-20)

    # Common configuration.
    if 0: # Doesn't seem to work.
        balloon = Pmw.Balloon(canvas,initwait=700)
        balloon.tagbind(canvas,theId,balloonHelp='Headline')

    if p:
        self.ids[theId] = p # Add the id of the *window*
        self.setHeadlineText(theId,w,p.headString())
        w.configure(width=self.headWidth(p=p))
        w.leo_position = p # This p never changes.
            # *Required*: onHeadlineClick uses w.leo_position to get p.

        # Keys are p.key().  Entries are (w,theId)
        self.visibleText [p.key()] = w,theId
        ### self.visibleText[id(p.v)] = w,theId
    else:
        g.trace('**** can not happen.  No p')

    return w
#@+node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

instance_tag = w.bindtags()[0]
w.bind_class(instance_tag, "<Button-4>", PropagateButton4)
w.bind_class(instance_tag, "<Button-5>", PropagateButton5)
w.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
#@-node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@+node:ekr.20040803072955.32:tree.setHeadlineText
def setHeadlineText (self,theId,w,s):

    """All changes to text widgets should come here."""

    # __pychecker__ = '--no-argsused' # theId not used.

    # if self.trace_alloc: g.trace('%4d %6s %s' % (theId,self.textAddr(w),s),align=-20)

    state = w.cget("state")
    if state != "normal":
        w.configure(state="normal")
    w.delete(0,"end")
    # Important: do not allow newlines in headlines.
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    w.insert("end",s)
    # g.trace(repr(s))
    if state != "normal":
        w.configure(state=state)
#@-node:ekr.20040803072955.32:tree.setHeadlineText
#@-node:ekr.20040803072955.11:newText (tkTree) and helper
#@+node:ekr.20040803072955.12:recycleWidgets
def recycleWidgets (self):

    canvas = self.canvas

    for theId in self.visibleBoxes:
        # if theId not in self.freeBoxes:
            # self.freeBoxes.append(theId)
        self.freeBoxes[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleBoxes = []

    for theId in self.visibleClickBoxes:
        # if theId not in self.freeClickBoxes:
            # self.freeClickBoxes.append(theId)
        self.freeClickBoxes[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleClickBoxes = []

    for theId in self.visibleIcons:
        # if theId not in self.freeIcons:
            # self.freeIcons.append(theId)
        self.freeIcons[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleIcons = []

    for theId in self.visibleLines:
        # if theId not in self.freeLines:
            # self.freeLines.append(theId)
        self.freeLines[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleLines = []

    aList = self.visibleText.values()
    for data in aList:
        w,theId = data
        # assert theId == w.leo_window_id
        canvas.coords(theId,-100,-100)
        w.leo_position = None # Allow the position to be freed.
        # if data not in self.freeText:
            # self.freeText.append(data)
        self.freeText[data] = data
    self.visibleText = {}

    # g.trace('deleting visible user icons!')
    for theId in self.visibleUserIcons:
        # The present code does not recycle user Icons.
        self.canvas.delete(theId)
    self.visibleUserIcons = []
#@-node:ekr.20040803072955.12:recycleWidgets
#@+node:ekr.20040803072955.13:destroyWidgets
def destroyWidgets (self):

    self.ids = {}

    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleUserIcons = []

    self.visibleText = {}

    self.freeText = {}
    self.freeBoxes = {}
    self.freeClickBoxes = {}
    self.freeIcons = {}
    self.freeLines = {}

    self.canvas.delete("all")
#@-node:ekr.20040803072955.13:destroyWidgets
#@+node:ekr.20060202125419:showStats
def showStats (self):

    z = []
    for kind,a,b in (
        ('boxes',self.visibleBoxes,self.freeBoxes),
        ('clickBoxes',self.visibleClickBoxes,self.freeClickBoxes),
        ('icons',self.visibleIcons,self.freeIcons),
        ('lines',self.visibleLines,self.freeLines),
        ('tesxt',self.visibleText.values(),self.freeText),
    ):
        z.append('%10s used: %4d free: %4d' % (kind,len(a),len(b)))

    s = '\n' + '\n'.join(z)
    g.es_print('',s)
#@-node:ekr.20060202125419:showStats
#@-node:ekr.20040803072955.6:Allocation...
#@+node:ekr.20031218072017.2900:contractAllHeadlines
def contractAllHeadlines (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self

    # c.beginUpdate()
    # try: # update...
    for p in c.all_positions_with_unique_vnodes_iter():
        p.contract()
    # Select the topmost ancestor of the presently selected node.
    p = c.currentPosition()
    while p and p.hasParent():
        p.moveToParent()
    c.selectPosition(p)
    # finally:
    c.redraw() # was c.endUpdate()
    c.treeFocusHelper()

    c.expansionLevel = 1 # Reset expansion level.
#@-node:ekr.20031218072017.2900:contractAllHeadlines
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):

    self.updateCount += 1
    # g.trace('tree',id(self),self.updateCount,g.callers())

def endUpdate (self,flag,scroll=False):

    self.updateCount -= 1
    # g.trace(self.updateCount,'scroll',scroll,g.callers())

    if self.updateCount <= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount",g.callers())
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:tree.redraw_now & helper
# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False,forceDraw=False):

    '''Redraw immediately: used by Find so a redraw doesn't mess up selections in headlines.'''

    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return

    c = self.c

    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary()
        if self.trace_redraw or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            # g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()

    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()

redraw = redraw_now # Compatibility
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True,forceDraw=False):

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        if trace: g.trace('bbox',bbox,g.callers())
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:tree.redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):

    c = self.c

    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)

    if 0:
        self.canvas.delete("all")

    self.drawTopTree()

    if self.trace:
        g.trace(self.redrawCount)
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7

    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)

    if theId is None:
        # if self.trace_gc: g.printNewObjects(tag='box 1')
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        # if self.trace_gc: g.printNewObjects(tag='box 2')
        return theId
    else:
        return theId
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height

    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):

    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    # if self.trace_gc: g.printNewObjects(tag='icon 1')

    c = self.c ; v = p.v
    << compute x,y and iconVal >>
    v.iconVal = val

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)

    return 0,self.icon_width # dummy icon height,width
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.computeIcon()
assert(0 <= val <= 15)
# g.trace(v,val)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):

    theId = self.newLine(p,x1,y1,x2,y2)

    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

    c = self.c

    # g.trace(x,y,p,id(self.canvas))

    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0

    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)

    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.

    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2

    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)

    self.drawClickBox(p,y)

    return h,indent
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):

    """draw text for position p at nominal coordinates x,y."""

    assert(p)

    c = self.c
    x += self.text_indent

    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    self.newText(p,x,y+self.lineyoffset)

    self.configureTextState(p)

    return self.line_height
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons & helper
def drawUserIcons(self,p,where,x,y):

    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""

    h,w = 0,0 ; t = p.v.t

    com = self.c.editCommands
    iconsList = com.getIconList(p)
    if not iconsList:
        return h,w

    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    # g.trace(where,h,w)

    return h,w
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):

    c = self.c ; h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # if self.trace_gc: g.printNewObjects(tag='userIcon 1')

    # g.trace(where,x,y,theDict)

    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        ### not ready yet.
        # s = theDict.get("icon")
        pass
    elif theType == "file":
        theFile = theDict.get("file")
        relPath = theDict.get('relPath')
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>

    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    # if self.trace_gc: g.printNewObjects(tag='userIcon 2')

    return h,w
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
if relPath:
    fullname = g.os_path_join(g.app.loadDir,"..","Icons",relPath)
else:
    fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
fullname = g.os_path_normpath(fullname)

# Bug fix: the key must include distinguish nodes.
key = (fullname,p.v.t)
image = self.iconimages.get(key)

if not image:
    try:
        from PIL import Image, ImageTk
        image1 = Image.open(fullname)
        image = ImageTk.PhotoImage(image1)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if not image:
    try:
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image)

    tag='userIcon-%s' % theId
    self.canvas.itemconfigure(theId,tag=(tag,'userIcon')) #BJ
    self.ids[theId] = p.copy()

    def deleteButtonCallback(event=None,c=c,p=p,fullname=fullname,relPath=relPath):
        #g.trace()
        c.editCommands.deleteIconByName(p,fullname,relPath)
        self._block_canvas_menu = True
        return 'break'

    c.tag_bind(self.canvas,tag,'<3>',deleteButtonCallback)

    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad
#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@-node:ekr.20040803072955.46:drawUserIcons & helper
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,g.callers()) # 'len(c.hoistStack)',len(c.hoistStack))
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    hoistFlag = c.hoistStack
    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
        h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            hoistFlag = False
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.

    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest. BJ:Not now
    canvas.lift("plusBox")
    canvas.lift("userIcon")
    self.redrawing = False
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y ; h1 = None
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data

    while p: # Do not use iterator.
        # This is the ONLY copy of p that needs to be made;
        # no other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h # Set h1 *after* calling drawNode.
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
    # Draw the vertical line.
    if h1 is None: h1 = h
    y2 = g.choose(level==0,yfirst+(h1-1)/2,yfirst-h1/2-1)
    self.drawLine(None,x,y2,x,ylast+self.hline_y-h)
    return y
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]

    # g.trace(name)

    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("exception loading:",fullname)
        g.es_exception()
        return None
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):

    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.

def inExpandedVisibleArea (self,y1):

    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):

    c = self.c

    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext(c)
    return n
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
    if not hasattr(self,'c'):
        return

    # __pychecker__ = '--no-argsused' # event not used.
    # __pychecker__ = '--no-intdivide' # suppress warning about integer division.

    c = self.c ; frame = c.frame ; trace = False
    if not p or not c.positionExists(p):
        p = c.currentPosition()
        if trace: g.trace('*** current position',p,p.stack)
    if not p or not c.positionExists(p):
        if trace: g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not c.positionExists(p):
        if trace: g.trace('no position')
        return
    try:
        if trace: g.trace('***',p,p.stack,'exists',c.positionExists(p))
        h1 = self.yoffset(p)
        if self.center_selected_tree_node: # New in Leo 4.4.3.
            << compute frac0 >>
            delta = abs(self.prevMoveToFrac-frac0)
            if trace: g.trace('delta',delta)
            if delta > 0.0:
                self.prevMoveToFrac = frac0
                self.canvas.yview("moveto",frac0)
                if trace: g.trace("frac0 %1.2f h1 %3d htot %3d wtot %3d" % (
                    frac0,h1,htot,wtot),g.callers())
        else:
            last = c.lastVisible()
            nextToLast = last.visBack(c)
            h2 = self.yoffset(last)
            << compute approximate line height >>
            << Compute the fractions to scroll down/up >>
            if frac <= lo: # frac is for scrolling down.
                if self.prevMoveToFrac != frac:
                    self.prevMoveToFrac = frac
                    self.canvas.yview("moveto",frac)
                    if trace: g.trace("frac  %1.2f h1 %3d h2 %3d lo %1.2f hi %1.2f" % (
                        frac, h1,h2,lo,hi),g.callers())
            elif frac2 + (hi - lo) >= hi: # frac2 is for scrolling up.
                if self.prevMoveToFrac != frac2:
                    self.prevMoveToFrac = frac2
                    self.canvas.yview("moveto",frac2)
                    if trace: g.trace("frac2 %1.2f h1 %3d h2 %3d lo %1.2f hi %1.2f" % (
                        frac2,h1,h2,lo,hi),g.callers())

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)

        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.

    except:
        g.es_exception()

idle_scrollTo = scrollTo # For compatibility.
#@+node:ekr.20061030091926:<< compute frac0 >>
# frac0 attempt to put the 
scrollRegion = self.canvas.cget('scrollregion')
geom = self.canvas.winfo_geometry()

if scrollRegion and geom:
    scrollRegion = scrollRegion.split(' ')
    # if trace: g.trace('scrollRegion',repr(scrollRegion))
    htot = int(scrollRegion[3])
    wh,junk,junk = geom.split('+')
    junk,h = wh.split('x')
    if h: wtot = int(h)
    else: wtot = 500
    # if trace: g.trace('geom',geom,'wtot',wtot,'htot',htot)
    if htot > 0.1:
        frac0 = float(h1-wtot/2)/float(htot)
        frac0 = max(min(frac0,1.0),0.0)
    else:
        frac0 = 0.0
else:
    frac0 = 0.0 ; htot = wtot = 0
#@-node:ekr.20061030091926:<< compute frac0 >>
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.canvas.leo_treeBar.get() # Get the previous values of the scrollbar.
try: lo, hi = data
except: lo,hi = 0.0,1.0

# h1 and h2 are the y offsets of the present and last nodes.
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.

frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.70:yoffset (tkTree)
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): g.pr("yoffset not visible:",p1)
    if not p1: return 0
    c = self.c
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        root = bunch.p.copy()
    else:
        root = self.c.rootPosition()
    if root:
        h,flag = self.yoffsetTree(root,p1,isTop=True)
        # flag can be False during initialization.
        # if not flag: g.pr("*** yoffset fails:",'root',root,'p1',p1,'returns',h)
        return h
    else:
        return 0

def yoffsetTree(self,p,p1,isTop):
    c = self.c ; h = 0 ; trace = False ; verbose = True
    if trace: g.trace('entry','root',p,p.stack,'target',p1,p1.stack)
    if not c.positionExists(p):
        if trace: g.trace('*** does not exist',p.headString())
        return h,False # An extra precaution.
    p = p.copy()
    if trace and verbose and isTop and c.hoistStack:
        g.trace('c.hoistStack',c.hoistStack[-1].p.headString())
    if isTop and c.hoistStack:
        if p.firstChild():  theIter = [p.firstChild()]
        else:               theIter = []
    else:
        theIter = p.self_and_siblings_iter() # Bug fix 10/27/07: was p.siblings_iter()

    for p2 in theIter:
        if trace and p1.headString() == p2.headString():
            g.trace('loop',p1,p2)
            g.trace(p1.stack,p2.stack)
        if p2 == p1:
            if trace and verbose: g.trace('returns',h,p1.headString())
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            if trace and verbose: g.trace('recursive call')
            h2, flag = self.yoffsetTree(child,p1,isTop=False)
            h += h2
            if flag:
                if trace and verbose: g.trace('returns',h,p1.headString())
                return h, True

    if trace: g.trace('not found',h,p1.headString())
    return h, False
#@-node:ekr.20040803072955.70:yoffset (tkTree)
#@-node:ekr.20040803072955.62:Helpers...
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True,forceDraw=False):

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        if trace: g.trace('bbox',bbox,g.callers())
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20040803072955.59:redrawHelper
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,g.callers()) # 'len(c.hoistStack)',len(c.hoistStack))
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    hoistFlag = c.hoistStack
    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
        h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            hoistFlag = False
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.

    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest. BJ:Not now
    canvas.lift("plusBox")
    canvas.lift("userIcon")
    self.redrawing = False
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y ; h1 = None
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data

    while p: # Do not use iterator.
        # This is the ONLY copy of p that needs to be made;
        # no other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h # Set h1 *after* calling drawNode.
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
    # Draw the vertical line.
    if h1 is None: h1 = h
    y2 = g.choose(level==0,yfirst+(h1-1)/2,yfirst-h1/2-1)
    self.drawLine(None,x,y2,x,ylast+self.hline_y-h)
    return y
#@-node:ekr.20040803072955.53:drawTree
#@+node:ekr.20040803072955.12:recycleWidgets
def recycleWidgets (self):

    canvas = self.canvas

    for theId in self.visibleBoxes:
        # if theId not in self.freeBoxes:
            # self.freeBoxes.append(theId)
        self.freeBoxes[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleBoxes = []

    for theId in self.visibleClickBoxes:
        # if theId not in self.freeClickBoxes:
            # self.freeClickBoxes.append(theId)
        self.freeClickBoxes[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleClickBoxes = []

    for theId in self.visibleIcons:
        # if theId not in self.freeIcons:
            # self.freeIcons.append(theId)
        self.freeIcons[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleIcons = []

    for theId in self.visibleLines:
        # if theId not in self.freeLines:
            # self.freeLines.append(theId)
        self.freeLines[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleLines = []

    aList = self.visibleText.values()
    for data in aList:
        w,theId = data
        # assert theId == w.leo_window_id
        canvas.coords(theId,-100,-100)
        w.leo_position = None # Allow the position to be freed.
        # if data not in self.freeText:
            # self.freeText.append(data)
        self.freeText[data] = data
    self.visibleText = {}

    # g.trace('deleting visible user icons!')
    for theId in self.visibleUserIcons:
        # The present code does not recycle user Icons.
        self.canvas.delete(theId)
    self.visibleUserIcons = []
#@-node:ekr.20040803072955.12:recycleWidgets
#@-node:ekr.20080527084425.2:Fixed big performance bug in contract-all command
#@+node:ekr.20080527084425.5:Changed bindings so Home and end keys work as expected when editing a headline
#@-node:ekr.20080527084425.5:Changed bindings so Home and end keys work as expected when editing a headline
#@+node:ekr.20080509153731.1:Fixed bug: myLeoSettings.leo sometimes read twice
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/35a8ea2024036623s

> Leo will read myLeoSettings.leo twice if that's the file you are
> actually opening.  It's not worth "fixing".

It's not the file I'm actually opening, it's $HOME/myLeoSettings.leo
and $PWD/myLeoSettings.leo (using $PWD as notation for the directory
from which python was run).

I.e. when $PWD == $HOME, a command like

  python path/to/leo.py foo.leo

will read mySettings.leo and leoSettings.leo twice. 

@color
#@nonl
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    if g.app.oneConfigFilename:
        table = ((g.app.oneConfigFilename,False),)
    else:
        table = (
            (self.globalConfigFile,False),
            (self.homeFile,False),
            (localConfigFile,False),
            (self.myGlobalConfigFile,False),
            (self.myHomeConfigFile,False),
            (self.machineConfigFile,False),
            (myLocalConfigFile,False),
            (fileName,True),
        )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_abspath(g.os_path_normpath(path)))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20080605064555.2:os_path_realpath
def os_path_realpath(path,encoding=None):


    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.realpath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20080605064555.2:os_path_realpath
#@-node:ekr.20080509153731.1:Fixed bug: myLeoSettings.leo sometimes read twice
#@+node:ekr.20080129103436:Compute menus list for each c
@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1858451&forum_id=10228

If I create a @settings->@menus->@menu node in a file, open 
the file, then open another Leo file, the next file opens with the 
redefined menu. 

@color
#@nonl
#@+node:ekr.20080603052650.464:Reference
#@+node:ekr.20041118104831.1:class configSettings (leoCommands)
class configSettings:

    """A class to hold config settings for commanders."""

    @others
#@+node:ekr.20041118104831.2:configSettings.__init__ (c.configSettings)
def __init__ (self,c):

    self.c = c

    # Init these here to keep pylint happy.
    self.default_derived_file_encoding = None
    self.new_leo_file_encoding = None
    self.redirect_execute_script_output_to_log_pane = None
    self.tkEncoding = None

    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultMenuFontSize = g.app.config.defaultMenuFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize

    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)

    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    # New in 4.4b3: use the global setting as a last resort.
    if encoding:
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)
    else:
        encoding = getattr(g.app.config,encodingName)
        # g.trace('g.app.config',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad", "%s: %s" % (encodingName,encoding))
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__ (c.configSettings)
#@+node:ekr.20041118053731:Getters (c.configSettings)
def get (self,setting,theType):
    '''A helper function: return the commander's setting, checking the type.'''
    return g.app.config.get(self.c,setting,theType)

def getAbbrevDict (self):
    '''return the commander's abbreviation dictionary.'''
    return g.app.config.getAbbrevDict(self.c)

def getBool (self,setting,default=None):
    '''Return the value of @bool setting, or the default if the setting is not found.'''
    return g.app.config.getBool(self.c,setting,default=default)

def getButtons (self):
    '''Return a list of tuples (x,y) for common @button nodes.'''
    return g.app.config.atCommonButtonsList # unusual.

def getColor (self,setting):
    '''Return the value of @color setting.'''
    return g.app.config.getColor(self.c,setting)

def getCommands (self):
    '''Return the list of tuples (headline,script) for common @command nodes.'''
    return g.app.config.atCommonCommandsList # unusual.

def getData (self,setting):
    '''Return a list of non-comment strings in the body text of @data setting.'''
    return g.app.config.getData(self.c,setting)

def getDirectory (self,setting):
    '''Return the value of @directory setting, or None if the directory does not exist.'''
    return g.app.config.getDirectory(self.c,setting)

def getFloat (self,setting):
    '''Return the value of @float setting.'''
    return g.app.config.getFloat(self.c,setting)

def getFontFromParams (self,family,size,slant,weight,defaultSize=12):

    '''Compute a font from font parameters.

    Arguments are the names of settings to be use.
    Default to size=12, slant="roman", weight="normal".

    Return None if there is no family setting so we can use system default fonts.'''

    return g.app.config.getFontFromParams(self.c,
        family, size, slant, weight, defaultSize = defaultSize)

def getInt (self,setting):
    '''Return the value of @int setting.'''
    return g.app.config.getInt(self.c,setting)

def getLanguage (self,setting):
    '''Return the value of @string setting.

    The value of this setting should be a language known to Leo.'''
    return g.app.config.getLanguage(self.c,setting)

def getMenusList (self):
    '''Return the list of entries for the @menus tree.'''
    return g.app.config.getMenusList(self.c) # Changed in Leo 4.5.

def getOpenWith (self):
    '''Return a list of dictionaries corresponding to @openwith nodes.'''
    return g.app.config.getOpenWith(self.c)

def getRatio (self,setting):
    '''Return the value of @float setting.
    Warn if the value is less than 0.0 or greater than 1.0.'''
    return g.app.config.getRatio(self.c,setting)

def getRecentFiles (self):
    '''Return the list of recently opened files.'''
    return g.app.config.getRecentFiles()

def getShortcut (self,shortcutName):
    '''Return the tuple (rawKey,accel) for shortcutName in @shortcuts tree.'''
    return g.app.config.getShortcut(self.c,shortcutName)

def getString (self,setting):
    '''Return the value of @string setting.'''
    return g.app.config.getString(self.c,setting)
#@-node:ekr.20041118053731:Getters (c.configSettings)
#@+node:ekr.20041118195812:Setters... (c.configSettings)
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):

    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):

    # __pychecker__ = '--no-argsused' # p not used.

    return g.app.config.setString(self.c,setting,val)

setString = set
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters... (c.configSettings)
#@-node:ekr.20041118104831.1:class configSettings (leoCommands)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    if g.app.oneConfigFilename:
        table = ((g.app.oneConfigFilename,False),)
    else:
        table = (
            (self.globalConfigFile,False),
            (self.homeFile,False),
            (localConfigFile,False),
            (self.myGlobalConfigFile,False),
            (self.myHomeConfigFile,False),
            (self.machineConfigFile,False),
            (myLocalConfigFile,False),
            (fileName,True),
        )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_abspath(g.os_path_normpath(path)))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace('=' * 20, c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@+node:ekr.20041119203941.3:class settingsTreeParser (parserBaseClass)
class settingsTreeParser (parserBaseClass):

    '''A class that inits settings found in an @settings tree.

    Used by read settings logic.'''

    @others
#@+node:ekr.20041119204103:ctor
def __init__ (self,c,localFlag=True):

    # Init the base class.
    parserBaseClass.__init__(self,c,localFlag)
#@-node:ekr.20041119204103:ctor
#@+node:ekr.20041119204714:visitNode (settingsTreeParser)
def visitNode (self,p):

    """Init any settings found in node p."""

    # g.trace(p.headString())

    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.headString())
    kind = munge(kind)

    if kind is None: # Not an @x node. (New in Leo 4.4.4)
        pass
    if kind == "settings":
        pass
    elif kind in self.basic_types and val in (u'None',u'none','None','none','',None):
        # None is valid for all basic types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        if f:
            try:
                return f(p,kind,name,val)
            except Exception:
                g.es_exception()
        else:
            g.pr("*** no handler",kind)

    return None
#@-node:ekr.20041119204714:visitNode (settingsTreeParser)
#@-node:ekr.20041119203941.3:class settingsTreeParser (parserBaseClass)
#@+node:ekr.20041119203941.2:<< class parserBaseClass >>
class parserBaseClass:

    """The base class for settings parsers."""

    << parserBaseClass data >>

    @others
#@+node:ekr.20041121130043:<< parserBaseClass data >>
# These are the canonicalized names.  Case is ignored, as are '_' and '-' characters.

basic_types = [
    # Headlines have the form @kind name = var
    'bool','color','directory','int','ints',
    'float','path','ratio','shortcut','string','strings']

control_types = [
    'abbrev','buttons','commands','data','enabledplugins','font',
    'if','ifgui','ifhostname','ifplatform','ignore','mode',
    'openwith','page','settings','shortcuts',
    'buttons','menus', # New in Leo 4.4.4.
    'menuat', 'popup', # New in Leo 4.4.8.
    ]

# Keys are settings names, values are (type,value) tuples.
settingsDict = {}
#@-node:ekr.20041121130043:<< parserBaseClass data >>
#@+node:ekr.20041119204700: ctor (parserBaseClass)
def __init__ (self,c,localFlag):

    self.c = c
    self.localFlag = localFlag
        # True if this is the .leo file being opened,
        # as opposed to myLeoSettings.leo or leoSettings.leo.
    self.recentFiles = [] # List of recent files.
    self.shortcutsDict = {}
        # Keys are cononicalized shortcut names, values are bunches.
    self.openWithList = []
        # A list of dicts containing 'name','shortcut','command' keys.

    # Keys are canonicalized names.
    self.dispatchDict = {
        'abbrev':       self.doAbbrev, # New in 4.4.1 b2.
        'bool':         self.doBool,
        'buttons':      self.doButtons, # New in 4.4.4
        'color':        self.doColor,
        'commands':     self.doCommands, # New in 4.4.8.
        'data':         self.doData, # New in 4.4.6
        'directory':    self.doDirectory,
        'enabledplugins': self.doEnabledPlugins,
        'font':         self.doFont,
        'if':           self.doIf,
        # 'ifgui':        self.doIfGui,  # Removed in 4.4 b3.
        'ifhostname':   self.doIfHostname,
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'menus':        self.doMenus, # New in 4.4.4
        'menuat':       self.doMenuat,
        'popup': self.doPopup, # New in 4.4.8

        'mode':         self.doMode, # New in 4.4b1.
        'openwith':     self.doOpenWith, # New in 4.4.3 b1.
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        # 'shortcut':     self.doShortcut, # Removed in 4.4.1 b1.
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }
#@-node:ekr.20041119204700: ctor (parserBaseClass)
#@+node:ekr.20080514084054.4:computeModeName (parserBaseClass)
def computeModeName (self,name):

    s = name.strip().lower()
    j = s.find(' ')
    if j > -1: s = s[:j]
    if s.endswith('mode'):
        s = s[:-4].strip()
    if s.endswith('-'):
        s = s[:-1]

    i = s.find('::')
    if i > -1:
        # The actual mode name is everything up to the "::"
        # The prompt is everything after the prompt.
        s = s[:i]

    modeName = s + '-mode'
    return modeName
#@-node:ekr.20080514084054.4:computeModeName (parserBaseClass)
#@+node:ekr.20060102103625:createModeCommand (parserBaseClass)
def createModeCommand (self,modeName,name,modeDict):

    modeName = 'enter-' + modeName.replace(' ','-')

    i = name.find('::')
    if i > -1:
        # The prompt is everything after the '::'
        prompt = name[i+2:].strip()
        modeDict ['*command-prompt*'] = prompt
        # g.trace('modeName',modeName,'*command-prompt*',prompt)

    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    # New in 4.4.1 b2: silently allow redefinitions of modes.
    d [modeName] = modeDict
#@-node:ekr.20060102103625:createModeCommand (parserBaseClass)
#@+node:ekr.20041120103012:error
def error (self,s):

    g.pr(s)

    # Does not work at present because we are using a null Gui.
    g.es(s,color="blue")
#@-node:ekr.20041120103012:error
#@+node:ekr.20041120094940:kind handlers (parserBaseClass)
#@+node:ekr.20060608221203:doAbbrev
def doAbbrev (self,p,kind,name,val):

    d = {}
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseAbbrevLine(line)
            if name: d [val] = name

    self.set (p,'abbrev','abbrev',d)
#@-node:ekr.20060608221203:doAbbrev
#@+node:ekr.20041120094940.1:doBool
def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.1:doBool
#@+node:ekr.20070925144337:doButtons
def doButtons (self,p,kind,name,val):

    '''Handle an @buttons tree.'''

    # __pychecker__ = '--no-argsused' # kind,name,val not used.

    aList = [] ; c = self.c ; tag = '@button'
    for p in p.subtree_with_unique_tnodes_iter():
        h = p.headString()
        if g.match_word(h,0,tag):
            # We can not assume that p will be valid when it is used.
            script = g.getScript(c,p,useSelectedText=False,forcePythonSentinels=True,useSentinels=True)
            aList.append((p.headString(),script),)

    # g.trace(g.listToString([h for h,script in aList]))

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    g.app.config.atCommonButtonsList = aList
    g.app.config.buttonsFileName = c and c.shortFileName() or '<no settings file>'

#@-node:ekr.20070925144337:doButtons
#@+node:ekr.20080312071248.6:doCommands
def doCommands (self,p,kind,name,val):

    '''Handle an @commands tree.'''

    # __pychecker__ = '--no-argsused' # kind,name,val not used.

    aList = [] ; c = self.c ; tag = '@command'
    for p in p.subtree_iter():
        h = p.headString()
        if g.match_word(h,0,tag):
            # We can not assume that p will be valid when it is used.
            script = g.getScript(c,p,useSelectedText=False,forcePythonSentinels=True,useSentinels=True)
            aList.append((p.headString(),script),)

    # g.trace(g.listToString(aList))

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    g.app.config.atCommonCommandsList = aList


#@-node:ekr.20080312071248.6:doCommands
#@+node:ekr.20041120094940.2:doColor
def doColor (self,p,kind,name,val):

    # At present no checking is done.
    val = val.lstrip('"').rstrip('"')
    val = val.lstrip("'").rstrip("'")

    self.set(p,kind,name,val)
#@-node:ekr.20041120094940.2:doColor
#@+node:ekr.20071214140900:doData
def doData (self,p,kind,name,val):

    s = p.bodyString()
    lines = g.splitLines(s)
    data = [z.strip() for z in lines if z.strip() and not z.startswith('#')]

    self.set(p,kind,name,data)
#@-node:ekr.20071214140900:doData
#@+node:ekr.20041120094940.3:doDirectory & doPath
def doDirectory (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory
#@-node:ekr.20041120094940.3:doDirectory & doPath
#@+node:ekr.20070224075914:doEnabledPlugins
def doEnabledPlugins (self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c
    s = p.bodyString()

    # This setting is handled differently from all other settings,
    # because the last setting must be retrieved before any commander exists.

    # g.trace('len(s)',len(s))

    # Set the global config ivars.
    g.app.config.enabledPluginsString = s
    g.app.config.enabledPluginsFileName = c and c.shortFileName() or '<no settings file>'
#@-node:ekr.20070224075914:doEnabledPlugins
#@+node:ekr.20041120094940.6:doFloat
def doFloat (self,p,kind,name,val):

    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.6:doFloat
#@+node:ekr.20041120094940.4:doFont
def doFont (self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # kind not used.

    trace = False

    if trace: g.trace(p and p.headString(),kind,name,self.c.mFileName)

    d = self.parseFont(p)

    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
            if trace and val not in (None,'none','None'): g.trace(key,val)
#@-node:ekr.20041120094940.4:doFont
#@+node:ekr.20041120103933:doIf
def doIf(self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # args not used.

    g.trace("'if' not supported yet")
    return None
#@-node:ekr.20041120103933:doIf
#@+node:ekr.20041121125416:doIfGui
@ Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.
@c

if 0:

    def doIfGui (self,p,kind,name,val):

        # __pychecker__ = '--no-argsused' # args not used.

        # g.trace(repr(name))

        if not g.app.gui or not g.app.gui.guiName():
            s = '@if-gui has no effect: g.app.gui not defined yet'
            g.es_print(s,color='blue')
            return "skip"
        elif g.app.gui.guiName().lower() == name.lower():
            return None
        else:
            return "skip"
#@-node:ekr.20041121125416:doIfGui
#@+node:dan.20080410121257.2:doIfHostname
def doIfHostname (self,p,kind,name,val):
    """headline: @ifhostname bob,!harry,joe

    Logical AND with the comma-separated list of host names, NO SPACES.

    descends this node iff:
        h = os.environ('HOSTNAME')
        h == 'bob' and h != 'harry' and h == 'joe'"""

    __pychecker__ = '--no-argsused' # args not used.

    h = g.computeMachineName()
    names = name.split(',')

    for n in names:
        if (n[0] == '!' and h == n[1:]) or (h != n):
            # g.trace('skipping', name)
            return 'skip'

    return None

#@-node:dan.20080410121257.2:doIfHostname
#@+node:ekr.20041120104215:doIfPlatform
def doIfPlatform (self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # args not used.

    # g.trace(sys.platform,repr(name))

    if sys.platform.lower() == name.lower():
        return None
    else:
        return "skip"
#@-node:ekr.20041120104215:doIfPlatform
#@+node:ekr.20041120104215.1:doIgnore
def doIgnore(self,p,kind,name,val):

    return "skip"
#@-node:ekr.20041120104215.1:doIgnore
#@+node:ekr.20041120094940.5:doInt
def doInt (self,p,kind,name,val):

    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.5:doInt
#@+node:ekr.20041217132253:doInts
def doInts (self,p,kind,name,val):

    '''We expect either:
    @ints [val1,val2,...]aName=val
    @ints aName[val1,val2,...]=val'''

    name = name.strip() # The name indicates the valid values.
    i = name.find('[')
    j = name.find(']')

    # g.trace(kind,name,val)

    if -1 < i < j:
        items = name[i+1:j]
        items = items.split(',')
        name = name[:i]+name[j+1:].strip()
        # g.trace(name,items)
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,'ints[]',name,val)
            return
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        try:
            val = int(val)
        except ValueError:
            self.valueError(p,'int',name,val)
            return
        if val not in items:
            self.error("%d is not in %s in %s" % (val,kind,name))
            return

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
#@-node:ekr.20041217132253:doInts
#@+node:ekr.20070925144337.2:doMenus & helper (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c ; aList = [] ; tag = '@menu'
    p = p.copy() ; after = p.nodeAfterTree()
    while p and p != after:
        h = p.headString()
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if not g.app.unitTesting:
            g.es_print('Using menus from',c.shortFileName(),color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    p = p.copy() ; after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        h = p.headString()
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@nonl
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helper (ParserBaseClass)
#@+node:ekr.20060102103625.1:doMode (ParserBaseClass)
def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-<name>-mode command.'''

    # __pychecker__ = '--no-argsused' # val not used.

    c = self.c ; k = c.k ; name1 = name

    # g.trace('%20s' % (name),c.fileName())
    modeName = self.computeModeName(name)

    # Create a local shortcutsDict.
    old_d = self.shortcutsDict
    d = self.shortcutsDict = {}

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                bunch.val = k.strokeFromSetting(bunch.val)
                bunch.pane = modeName
                bunchList = d.get(name,[])
                # Important: use previous bindings if possible.
                key2,bunchList2 = c.config.getShortcut(name)
                bunchList3 = [b for b in bunchList2 if b.pane != modeName]
                if bunchList3:
                    # g.trace('inheriting',[b.val for b in bunchList3])
                    bunchList.extend(bunchList3)
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)

    # Restore the global shortcutsDict.
    self.shortcutsDict = old_d

    # Create the command, but not any bindings to it.
    self.createModeCommand(modeName,name1,d)
#@-node:ekr.20060102103625.1:doMode (ParserBaseClass)
#@+node:ekr.20070411101643.1:doOpenWith (ParserBaseClass)
def doOpenWith (self,p,kind,name,val):

    # g.trace('kind',kind,'name',name,'val',val,'c',self.c)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
#@-node:ekr.20070411101643.1:doOpenWith (ParserBaseClass)
#@+node:ekr.20041120104215.2:doPage
def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.
#@-node:ekr.20041120104215.2:doPage
#@+node:ekr.20041121125741:doRatio
def doRatio (self,p,kind,name,val):

    try:
        val = float(val)
        if 0.0 <= val <= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041121125741:doRatio
#@+node:ekr.20041120105609:doShortcuts (ParserBaseClass)
def doShortcuts(self,p,kind,name,val,s=None):

    # __pychecker__ = '--no-argsused' # kind,val.

    # g.trace(self.c.fileName(),name)

    c = self.c ; d = self.shortcutsDict ; k = c.k
    trace = False or c.config.getBool('trace_bindings_verbose')
    munge = k.shortcutFromSetting
    if s is None: s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            # if name in ('save-file','enter-tree-save-file-mode'): g.pdb()
            if bunch is not None:
                if bunch.val not in (None,'none','None'):
                    # A regular shortcut.
                    bunchList = d.get(name,[])
                    if bunch.pane in ('kill','Kill'):
                        if trace: g.trace('****** killing binding:',bunch.val,'to',name)
                        bunchList = [z for z in bunchList
                            if munge(z.val) != munge(bunch.val)]
                        # g.trace(bunchList)
                    else:
                        if trace: g.trace('%6s %20s %s' % (bunch.pane,bunch.val,name))
                        bunchList.append(bunch)
                    d [name] = bunchList
                    self.set(p,"shortcut",name,bunchList)
                    self.setShortcut(name,bunchList)
#@-node:ekr.20041120105609:doShortcuts (ParserBaseClass)
#@+node:ekr.20041217132028:doString
def doString (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)
#@-node:ekr.20041217132028:doString
#@+node:ekr.20041120094940.8:doStrings
def doStrings (self,p,kind,name,val):

    '''We expect one of the following:
    @strings aName[val1,val2...]=val
    @strings [val1,val2,...]aName=val'''

    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 < i < j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]
        name = name[:i]+name[j+1:].strip()
        kind = "strings[%s]" % (','.join(items))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
#@-node:ekr.20041120094940.8:doStrings
#@+node:bobjack.20080324141020.4:doPopup & helper
def doPopup (self,p,kind,name,val):

    """
    Handle @popup menu items in @settings trees.
    """

    # __pychecker__ = '--no-argsused' # kind, not used.

    popupName = name
    popupType = val

    c = self.c ; aList = [] ; tag = '@menu'

    #g.trace(p, kind, name, val, c)

    aList = []
    p = p.copy()
    self.doPopupItems(p,aList)


    if not hasattr(g.app.config, 'context_menus'):
        g.app.config.context_menus = {}

    #if popupName in g.app.config.context_menus:
        #g.pr('*** duplicate popup ***', popupName)


    g.app.config.context_menus[popupName] = aList
#@+node:bobjack.20080324141020.5:doPopupItems
def doPopupItems (self,p,aList):

    p = p.copy() ; after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        h = p.headString()
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s' % itemName
                        body = p.bodyString()
                        self.doPopupItems(p,aList2)
                        aList.append((kind + '\n' + body, aList2),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@nonl
#@-node:bobjack.20080324141020.5:doPopupItems
#@-node:bobjack.20080324141020.4:doPopup & helper
#@+node:tbrown.20080514112857.124:doMenuat
def doMenuat (self,p,kind,name,val):

    if g.app.config.menusList:
        g.es_print("Patching menu tree: " + name)

        # get the patch fragment
        patch = []
        if p.hasChildren():
            # self.doMenus(p.copy().firstChild(),kind,name,val,storeIn=patch)
            self.doItems(p.copy(),patch)
            self.dumpMenuTree(patch)

        # setup        
        parts = name.split()
        if len(parts) != 3:
            parts.append('subtree')
        targetPath,mode,source = parts
        if not targetPath.startswith('/'): targetPath = '/'+targetPath

        ans = self.patchMenuTree(g.app.config.menusList, targetPath)

        if ans:
            g.es_print("Patching ("+mode+' '+source+") at "+targetPath)

            list_, idx = ans

            if mode not in ('copy', 'cut'):
                if source != 'clipboard':
                    use = patch # [0][1]
                else:
                    if isinstance(self.clipBoard, list):
                        use = self.clipBoard
                    else:
                        use = [self.clipBoard]
                g.es_print(str(use))
            if mode == 'replace':
                list_[idx] = use.pop(0)
                while use:
                    idx += 1
                    list_.insert(idx, use.pop(0))
            elif mode == 'before':
                while use:
                    list_.insert(idx, use.pop())
            elif mode == 'after':
                while use:
                    list_.insert(idx+1, use.pop())
            elif mode == 'cut':
                self.clipBoard = list_[idx]
                del list_[idx]
            elif mode == 'copy':
                self.clipBoard = list_[idx]
                g.es_print(str(self.clipBoard))
            else:  # append
                list_.extend(use)
        else:
            g.es_print("ERROR: didn't find menu path " + targetPath)

    else:
        g.es_print("ERROR: @menuat found but no menu tree to patch")
#@+node:tbrown.20080514180046.9:getName
def getName(self, val, val2=None):
    if val2 and val2.strip(): val = val2
    val = val.split('\n',1)[0]
    for i in "*.-& \t\n":
        val = val.replace(i,'')
    return val.lower()
#@nonl
#@-node:tbrown.20080514180046.9:getName
#@+node:tbrown.20080514180046.2:dumpMenuTree
def dumpMenuTree (self,aList,level=0,path=''):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            name = self.getName(val, val2)
            g.es_print('%s %s (%s) [%s]' % ('    '*(level+0), val, val2, path+'/'+name))
        else:
            name = self.getName(kind.replace('@menu ',''))
            g.es_print('%s %s... [%s]' % ('    '*(level), kind, path+'/'+name))
            self.dumpMenuTree(val,level+1,path=path+'/'+name)
#@-node:tbrown.20080514180046.2:dumpMenuTree
#@+node:tbrown.20080514180046.8:patchMenuTree
def patchMenuTree(self, orig, targetPath, path=''):

    for n,z in enumerate(orig):
        kind,val,val2 = z
        if kind == '@item':
            name = self.getName(val, val2)
            curPath = path+'/'+name
            if curPath == targetPath:
                g.es_print('Found '+targetPath)
                return orig, n
        else:
            name = self.getName(kind.replace('@menu ',''))
            curPath = path+'/'+name
            if curPath == targetPath:
                g.es_print('Found '+targetPath)
                return orig, n
            ans = self.patchMenuTree(val, targetPath, path=path+'/'+name)
            if ans:
                return ans

    return None
#@-node:tbrown.20080514180046.8:patchMenuTree
#@-node:tbrown.20080514112857.124:doMenuat
#@-node:ekr.20041120094940:kind handlers (parserBaseClass)
#@+node:ekr.20041124063257:munge
def munge(self,s):

    return g.app.config.canonicalizeSettingName(s)
#@-node:ekr.20041124063257:munge
#@+node:ekr.20041119204700.2:oops
def oops (self):
    g.pr("parserBaseClass oops:",
        g.callers(),
        "must be overridden in subclass")
#@-node:ekr.20041119204700.2:oops
#@+node:ekr.20041213082558:parsers
#@+node:ekr.20041213083651:fontSettingNameToFontKind
def fontSettingNameToFontKind (self,name):

    s = name.strip()
    if s:
        for tag in ('_family','_size','_slant','_weight'):
            if s.endswith(tag):
                return tag[1:]

    return None
#@-node:ekr.20041213083651:fontSettingNameToFontKind
#@+node:ekr.20041213082558.1:parseFont & helper
def parseFont (self,p):

    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(line,d)

    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)

    return d
#@+node:ekr.20041213082558.2:parseFontLine
def parseFontLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip()
            val = s[i+1:].strip()
            val = val.lstrip('"').rstrip('"')
            val = val.lstrip("'").rstrip("'")

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.
#@-node:ekr.20041213082558.2:parseFontLine
#@-node:ekr.20041213082558.1:parseFont & helper
#@+node:ekr.20041119205148:parseHeadline
def parseHeadline (self,s):

    """Parse a headline of the form @kind:name=val
    Return (kind,name,val)."""

    kind = name = val = None

    if g.match(s,0,'@'):
        i = g.skip_id(s,1,chars='-')
        kind = s[1:i].strip()
        if kind:
            # name is everything up to '='
            j = s.find('=',i)
            if j == -1:
                name = s[i:].strip()
            else:
                name = s[i:j].strip()
                # val is everything after the '='
                val = s[j+1:].strip()

    # g.trace("%50s %10s %s" %(name,kind,val))
    return kind,name,val
#@-node:ekr.20041119205148:parseHeadline
#@+node:ekr.20070411101643.2:parseOpenWith & helper
def parseOpenWith (self,p):

    d = {'command': None,}

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseOpenWithLine(line,d)

    return d
#@+node:ekr.20070411101643.4:parseOpenWithLine
def parseOpenWithLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if not g.match(s,0,'#'):
        d['command'] = s
#@-node:ekr.20070411101643.4:parseOpenWithLine
#@-node:ekr.20070411101643.2:parseOpenWith & helper
#@+node:ekr.20041120112043:parseShortcutLine (g.app.config)
def parseShortcutLine (self,s):

    '''Parse a shortcut line.  Valid forms:

    --> entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name -> mode-name = binding
    command-name -> same = binding
    '''

    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)

    if g.match(s,i,'-->'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        return None,g.Bunch(entryCommandName=entryCommandName)

    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'->'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]

    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]

    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(nextMode=nextMode,pane=pane,val=val)
#@-node:ekr.20041120112043:parseShortcutLine (g.app.config)
#@+node:ekr.20060608222828:parseAbbrevLine (g.app.config)
def parseAbbrevLine (self,s):

    '''Parse an abbreviation line:
    command-name = abbreviation
    return (command-name,abbreviation)
    '''

    i = j = g.skip_ws(s,0)
    i = g.skip_id(s,i,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    i = g.skip_ws(s,i)
    if not g.match(s,i,'='): return None,None

    i = g.skip_ws(s,i+1)
    val = s[i:].strip()
    # Ignore comments after the shortcut.
    i = val.find('#')
    if i > -1: val = val[:i].strip()

    if val: return name,val
    else:   return None,None
#@-node:ekr.20060608222828:parseAbbrevLine (g.app.config)
#@-node:ekr.20041213082558:parsers
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    # __pychecker__ = '--no-argsused' # p used in subclasses, not here.

    c = self.c ; key = self.munge(name)
    # if kind and kind.startswith('setting'): g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting:",name,"from",path)

    # N.B.  We can't use c here: it may be destroyed!
    # if key == 'shortcut':
        # g.trace('*****',key,val)

    d [key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')

#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041227071423:setShortcut (ParserBaseClass)
def setShortcut (self,name,bunchList):

    c = self.c

    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&','')
    self.set(c,rawKey,"shortcut",bunchList)

    if 0:
        for b in bunchList:
            g.trace('%20s %45s %s' % (b.val,rawKey,b.pane))
#@-node:ekr.20041227071423:setShortcut (ParserBaseClass)
#@+node:ekr.20041119204700.1:traverse (parserBaseClass)
def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # g.trace(result,p.headString())
        if result == "skip":
            # g.es_print('skipping settings in',p.headString(),color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
#@-node:ekr.20041119204700.1:traverse (parserBaseClass)
#@+node:ekr.20041120094940.10:valueError
def valueError (self,p,kind,name,val):

    """Give an error: val is not valid for kind."""

    # __pychecker__ = '--no-argsused' # p not used, but needed.

    self.error("%s is not a valid %s for %s" % (val,kind,name))
#@-node:ekr.20041120094940.10:valueError
#@+node:ekr.20041119204700.3:visitNode (must be overwritten in subclasses)
def visitNode (self,p):

    # __pychecker__ = '--no-argsused' # p not used, but needed.

    self.oops()
#@-node:ekr.20041119204700.3:visitNode (must be overwritten in subclasses)
#@-node:ekr.20041119203941.2:<< class parserBaseClass >>
#@+node:ekr.20041117081009:Getters... (g.app.config)
#@+node:ekr.20041123070429:canonicalizeSettingName (munge)
def canonicalizeSettingName (self,name):

    if name is None:
        return None

    name = name.lower()
    for ch in ('-','_',' ','\n'):
        name = name.replace(ch,'')

    return g.choose(name,name,None)

munge = canonicalizeSettingName
#@-node:ekr.20041123070429:canonicalizeSettingName (munge)
#@+node:ekr.20041123092357:config.findSettingsPosition
# This was not used prior to Leo 4.5.

def findSettingsPosition (self,c,setting):

    """Return the position for the setting in the @settings tree for c."""

    munge = self.munge

    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()

    setting = munge(setting)

    for p in root.subtree_iter():
        #BJ munge will return None if a headstring is empty
        h = munge(p.headString()) or ''
        if h.startswith(setting):
            return p.copy()

    return c.nullPosition()
#@-node:ekr.20041123092357:config.findSettingsPosition
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):

    """Get the setting and make sure its type matches the expected type."""

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # if setting == 'targetlanguage':
                    # g.trace(c.shortFileName(),setting,val,g.callers())
                return val

    for d in self.localOptionsList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # if setting == 'targetlanguage':
                # g.trace(kind,setting,val,g.callers())
            return val

    for d in self.dictList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # if setting == 'targetlanguage':
                # g.trace(kind,setting,val,g.callers())
            return val

    return None
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,warn=True):

    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val
    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            g.es_print('warning: ignoring',bunch.kind,'',setting,'is not',requestedType,color='red')
            g.es_print('there may be conflicting settings!',color='red')
        return None, False
    elif val in (u'None',u'none','None','none','',None):
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True
#@-node:ekr.20041121143823:getValFromDict
#@+node:ekr.20051015093141:typesMatch
def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts',)

    return (
        type1 == None or type2 == None or
        type1.startswith('string') or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
#@-node:ekr.20051015093141:typesMatch
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@+node:ekr.20051011105014:exists (g.app.config)
def exists (self,c,setting,kind):

    '''Return true if a setting of the given kind exists, even if it is None.'''

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            junk,found = self.getValFromDict(d,setting,kind)
            if found: return True

    for d in self.localOptionsList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    for d in self.dictList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    # g.trace('does not exist',setting,kind)
    return False
#@-node:ekr.20051011105014:exists (g.app.config)
#@+node:ekr.20060608224112:getAbbrevDict
def getAbbrevDict (self,c):

    """Search all dictionaries for the setting & check it's type"""

    d = self.get(c,'abbrev','abbrev')
    return d or {}
#@-node:ekr.20060608224112:getAbbrevDict
#@+node:ekr.20041117081009.3:getBool
def getBool (self,c,setting,default=None):

    '''Return the value of @bool setting, or the default if the setting is not found.'''

    val = self.get(c,setting,"bool")

    if val in (True,False):
        return val
    else:
        return default
#@-node:ekr.20041117081009.3:getBool
#@+node:ekr.20070926082018:getButtons
def getButtons (self):

    '''Return a list of tuples (x,y) for common @button nodes.'''

    return g.app.config.atCommonButtonsList
#@-node:ekr.20070926082018:getButtons
#@+node:ekr.20080312071248.7:getCommonCommands
def getCommonAtCommands (self):

    '''Return the list of tuples (headline,script) for common @command nodes.'''

    return g.app.config.atCommonCommandsList
#@-node:ekr.20080312071248.7:getCommonCommands
#@+node:ekr.20041122070339:getColor
def getColor (self,c,setting):

    '''Return the value of @color setting.'''

    return self.get(c,setting,"color")
#@-node:ekr.20041122070339:getColor
#@+node:ekr.20071214140900.1:getData
def getData (self,c,setting):

    '''Return a list of non-comment strings in the body text of @data setting.'''

    return self.get(c,setting,"data")
#@-node:ekr.20071214140900.1:getData
#@+node:ekr.20041117093009.1:getDirectory
def getDirectory (self,c,setting):

    '''Return the value of @directory setting, or None if the directory does not exist.'''

    theDir = self.getString(c,setting)

    if g.os_path_exists(theDir) and g.os_path_isdir(theDir):
         return theDir
    else:
        return None
#@-node:ekr.20041117093009.1:getDirectory
#@+node:ekr.20070224075914.1:getEnabledPlugins
def getEnabledPlugins (self):

    '''Return the body text of the @enabled-plugins node.'''

    return g.app.config.enabledPluginsString
#@-node:ekr.20070224075914.1:getEnabledPlugins
#@+node:ekr.20041117082135:getFloat
def getFloat (self,c,setting):

    '''Return the value of @float setting.'''

    val = self.get(c,setting,"float")
    try:
        val = float(val)
        return val
    except TypeError:
        return None
#@-node:ekr.20041117082135:getFloat
#@+node:ekr.20041117062717.13:getFontFromParams (config)
def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    Default to size=12, slant="roman", weight="normal".

    Return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize

    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"

    # g.trace(g.callers(3),family,size,slant,weight,g.shortFileName(c.mFileName))

    return g.app.gui.getFontFromParams(family,size,slant,weight)
#@-node:ekr.20041117062717.13:getFontFromParams (config)
#@+node:ekr.20041117081513:getInt
def getInt (self,c,setting):

    '''Return the value of @int setting.'''

    val = self.get(c,setting,"int")
    try:
        val = int(val)
        return val
    except TypeError:
        return None
#@-node:ekr.20041117081513:getInt
#@+node:ekr.20041117093009.2:getLanguage
def getLanguage (self,c,setting):

    '''Return the setting whose value should be a language known to Leo.'''

    language = self.getString(c,setting)
    # g.trace(setting,language)

    return language
#@-node:ekr.20041117093009.2:getLanguage
#@+node:ekr.20070926070412:getMenusList (c.config)
def getMenusList (self,c):

    '''Return the list of entries for the @menus tree.'''

    aList = self.get(c,'menus','menus')
    # g.trace(aList and len(aList) or 0)

    return aList or g.app.config.menusList
#@-node:ekr.20070926070412:getMenusList (c.config)
#@+node:ekr.20070411101643:getOpenWith
def getOpenWith (self,c):

    '''Return a list of dictionaries corresponding to @openwith nodes.'''

    val = self.get(c,'openwithtable','openwithtable')

    return val
#@-node:ekr.20070411101643:getOpenWith
#@+node:ekr.20041122070752:getRatio
def getRatio (self,c,setting):

    '''Return the value of @float setting.

    Warn if the value is less than 0.0 or greater than 1.0.'''

    val = self.get(c,setting,"ratio")
    try:
        val = float(val)
        if 0.0 <= val <= 1.0:
            return val
        else:
            return None
    except TypeError:
        return None
#@-node:ekr.20041122070752:getRatio
#@+node:ekr.20041117062717.11:getRecentFiles
def getRecentFiles (self):

    '''Return the list of recently opened files.'''

    return self.recentFiles
#@-node:ekr.20041117062717.11:getRecentFiles
#@+node:ekr.20041117062717.14:getShortcut (config)
def getShortcut (self,c,shortcutName):

    '''Return rawKey,accel for shortcutName'''

    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&','') # Allow '&' in names.

    bunchList = self.get(c,key,"shortcut")
    if bunchList:
        bunchList = [bunch for bunch in bunchList
            if bunch.val and bunch.val.lower() != 'none']
        return key,bunchList
    else:
        return key,[]
#@-node:ekr.20041117062717.14:getShortcut (config)
#@+node:ekr.20041117081009.4:getString
def getString (self,c,setting):

    '''Return the value of @string setting.'''

    return self.get(c,setting,"string")
#@-node:ekr.20041117081009.4:getString
#@+node:ekr.20041120074536:settingsRoot
def settingsRoot (self,c):

    '''Return the position of the @settings tree.'''

    # g.trace(c,c.rootPosition())

    for p in c.all_positions_with_unique_tnodes_iter():
        if p.headString().rstrip() == "@settings":
            return p.copy()
    else:
        return c.nullPosition()
#@-node:ekr.20041120074536:settingsRoot
#@-node:ekr.20041117081009:Getters... (g.app.config)
#@-node:ekr.20080603052650.464:Reference
#@+node:ekr.20080603052650.465:Changed
#@+node:ekr.20070925144337.2:doMenus & helper (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c ; aList = [] ; tag = '@menu'
    p = p.copy() ; after = p.nodeAfterTree()
    while p and p != after:
        h = p.headString()
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if not g.app.unitTesting:
            g.es_print('Using menus from',c.shortFileName(),color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    p = p.copy() ; after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        h = p.headString()
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@nonl
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helper (ParserBaseClass)
#@+node:ekr.20070926070412:getMenusList (c.config)
def getMenusList (self,c):

    '''Return the list of entries for the @menus tree.'''

    aList = self.get(c,'menus','menus')
    # g.trace(aList and len(aList) or 0)

    return aList or g.app.config.menusList
#@-node:ekr.20070926070412:getMenusList (c.config)
#@+node:ekr.20041118053731:Getters (c.configSettings)
def get (self,setting,theType):
    '''A helper function: return the commander's setting, checking the type.'''
    return g.app.config.get(self.c,setting,theType)

def getAbbrevDict (self):
    '''return the commander's abbreviation dictionary.'''
    return g.app.config.getAbbrevDict(self.c)

def getBool (self,setting,default=None):
    '''Return the value of @bool setting, or the default if the setting is not found.'''
    return g.app.config.getBool(self.c,setting,default=default)

def getButtons (self):
    '''Return a list of tuples (x,y) for common @button nodes.'''
    return g.app.config.atCommonButtonsList # unusual.

def getColor (self,setting):
    '''Return the value of @color setting.'''
    return g.app.config.getColor(self.c,setting)

def getCommands (self):
    '''Return the list of tuples (headline,script) for common @command nodes.'''
    return g.app.config.atCommonCommandsList # unusual.

def getData (self,setting):
    '''Return a list of non-comment strings in the body text of @data setting.'''
    return g.app.config.getData(self.c,setting)

def getDirectory (self,setting):
    '''Return the value of @directory setting, or None if the directory does not exist.'''
    return g.app.config.getDirectory(self.c,setting)

def getFloat (self,setting):
    '''Return the value of @float setting.'''
    return g.app.config.getFloat(self.c,setting)

def getFontFromParams (self,family,size,slant,weight,defaultSize=12):

    '''Compute a font from font parameters.

    Arguments are the names of settings to be use.
    Default to size=12, slant="roman", weight="normal".

    Return None if there is no family setting so we can use system default fonts.'''

    return g.app.config.getFontFromParams(self.c,
        family, size, slant, weight, defaultSize = defaultSize)

def getInt (self,setting):
    '''Return the value of @int setting.'''
    return g.app.config.getInt(self.c,setting)

def getLanguage (self,setting):
    '''Return the value of @string setting.

    The value of this setting should be a language known to Leo.'''
    return g.app.config.getLanguage(self.c,setting)

def getMenusList (self):
    '''Return the list of entries for the @menus tree.'''
    return g.app.config.getMenusList(self.c) # Changed in Leo 4.5.

def getOpenWith (self):
    '''Return a list of dictionaries corresponding to @openwith nodes.'''
    return g.app.config.getOpenWith(self.c)

def getRatio (self,setting):
    '''Return the value of @float setting.
    Warn if the value is less than 0.0 or greater than 1.0.'''
    return g.app.config.getRatio(self.c,setting)

def getRecentFiles (self):
    '''Return the list of recently opened files.'''
    return g.app.config.getRecentFiles()

def getShortcut (self,shortcutName):
    '''Return the tuple (rawKey,accel) for shortcutName in @shortcuts tree.'''
    return g.app.config.getShortcut(self.c,shortcutName)

def getString (self,setting):
    '''Return the value of @string setting.'''
    return g.app.config.getString(self.c,setting)
#@-node:ekr.20041118053731:Getters (c.configSettings)
#@-node:ekr.20080603052650.465:Changed
#@-node:ekr.20080129103436:Compute menus list for each c
#@+node:ekr.20080509065556.1:Fixed minor spelling bug
http://groups.google.com/group/leo-editor/browse_thread/thread/d2a9aeac0d0082f6

If the mis-spelled word  starts at position 0, it is detected but can
not be replaced.
#@+node:ekr.20051025071455.52:updateButtons (spellTab)
def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c ; w = c.frame.body.bodyCtrl

    start, end = w.getSelectionRange()

    # Bug fix: enable buttons when start = 0.
    state = g.choose(self.suggestions and start is not None,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
#@-node:ekr.20051025071455.52:updateButtons (spellTab)
#@-node:ekr.20080509065556.1:Fixed minor spelling bug
#@+node:ekr.20080315083057.6:Fixed spell bug: words containing unicode characters aren't saved properly
#@+node:ekr.20051025071455.16:readDictionary
def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary

    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""

    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("can not open local dictionary",fileName,"using a blank one instead")
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            word = g.toUnicode(word,'utf-8', reportErrors=True)
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
#@-node:ekr.20051025071455.16:readDictionary
#@+node:ekr.20051025071455.37:add (spellTab)
def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    if not self.currentWord: return

    # g.trace(self.currentWord)

    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % g.toEncodedString(word,'utf-8',reportErrors=True))
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("adding ", color= "blue", newline= False) 
                g.es('','%s' % self.currentWord)
        except IOError:
            g.es("can not add",self.currentWord,"to dictionary",color="red")
    finally:
        if f: f.close()

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
#@-node:ekr.20051025071455.37:add (spellTab)
#@-node:ekr.20080315083057.6:Fixed spell bug: words containing unicode characters aren't saved properly
#@+node:ekr.20080612060621.1:Fixed coloring bugs in reformatParagraph and c.redraw
#@+node:ekr.20080514131122.20:c.outerUpdate
def outerUpdate (self):

    c = self ; aList = [] ; trace = False ; verbose = False

    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    scrollFlag = c.requestRedrawScrollFlag
    c.requestRedrawFlag = False
    c.requestRedrawScrollFlag = False

    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        # g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw') # : scroll: %s' % (c.requestRedrawScrollFlag))
        c.frame.tree.redraw_now(scroll=scrollFlag,forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if verbose: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList),c.shortFileName() or '<no name>',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''
    c.requestedRedrawScrollFlag = False
#@-node:ekr.20080514131122.20:c.outerUpdate
#@+node:ekr.20080514131122.12:c.recolor & requestRecolor
def requestRecolor (self):

    c = self
    c.requestRecolorFlag = True

recolor = requestRecolor
#@-node:ekr.20080514131122.12:c.recolor & requestRecolor
#@+node:ekr.20031218072017.1825:c.findBoundParagraph
def findBoundParagraph (self,event=None):

    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None

    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    for line in tail_lines:
        if not line or line.isspace() or line.startswith('@'):
            break
        i += 1

    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]

    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    return head,result,tail # string, list, string
#@nonl
#@+node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
if 0:
    g.pr("\nhead_lines")
    for line in head_lines:
        g.pr(line)
    g.pr("\nins", ins)
    g.pr("\ntail_lines")
    for line in tail_lines:
        g.pr(line)
else:
    g.es_print("head_lines: ",head_lines)
    g.es_print("ins: ",ins)
    g.es_print("tail_lines: ",tail_lines)
#@-node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
#@-node:ekr.20031218072017.1825:c.findBoundParagraph
#@+node:ekr.20031218072017.1329:onBodyChanged (leoBody)
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):

    '''Update Leo after the body has been changed.'''

    trace = False
    body = self ; c = self.c
    bodyCtrl = w = body.bodyCtrl
    p = c.currentPosition()
    insert = w.getInsertPoint()
    ch = g.choose(insert==0,'',w.get(insert-1))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    if trace: g.trace('w',w,'newText',repr(newText),g.callers())
    newSel = w.getSelectionRange()
    if not oldText:
        oldText = p.bodyString() ; changed = True
    else:
        changed = oldText != newText
    if trace: g.trace(repr(ch),'changed:',changed,'newText:',repr(newText))
    if not changed: return
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setBodyString(newText)
    p.v.t.insertSpot = body.getInsertPoint()
    << recolor the body >>
    if not c.changed: c.setChanged(True)
    self.updateEditors()
    << redraw the screen if necessary >>
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False

if g.app.unitTesting:
    g.app.unitTestDict['colorized'] = True
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
# c.beginUpdate()
# try:

redraw_flag = False
# Update dirty bits.
# p.setDirty() sets all cloned and @file dirty bits.
if not p.isDirty() and p.setDirty():
    redraw_flag = True

# Update icons. p.v.iconVal may not exist during unit tests.
val = p.computeIcon()
# g.trace('new val:',val,'old val:',hasattr(p.v,'iconVal') and p.v.iconVal or '<None>')
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True
#finally:
if redraw_flag: c.redraw() # was c.endUpdate(redraw_flag)
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1329:onBodyChanged (leoBody)
#@+node:ekr.20031218072017.1833:reformatParagraph
def reformatParagraph (self,event=None,undoType='Reformat Paragraph'):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; w = body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        i,j = w.getSelectionRange()
        w.setInsertPoint(i)

    << compute vars for reformatParagraph >>
    if lines:
        << compute the leading whitespace >>
        << compute the result of wrapping all lines >>
        << update the body, selection & undo state >>
#@nonl
#@+node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = w.getAllText()
oldSel =  w.getSelectionRange()
oldYview = body.getYScrollPosition()

head,lines,tail = c.findBoundParagraph()
#@-node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
#@+node:ekr.20031218072017.1835:<< compute the leading whitespace >>
indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i < len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)

indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
#@-node:ekr.20031218072017.1835:<< compute the leading whitespace >>
#@+node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
trailingNL = lines and lines[-1].endswith('\n')
lines = [g.choose(z.endswith('\n'),z[:-1],z) for z in lines]

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult)
if trailingNL: result = result + '\n'
#@nonl
#@-node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
#@+node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
# This destroys recoloring.
junk, ins = body.setSelectionAreas(head,result,tail)

# Advance to the next paragraph.
s = w.getAllText()
ins += 1 # Move past the selection.
while ins < len(s):
    i,j = g.getLine(s,ins)
    line = s[i:j]
    if line.startswith('@') or line.isspace():
        ins = j+1
    else:
        ins = i ; break

changed = original != head + result + tail
if changed:
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)
else:
    # We must always recolor, even if the text has not changed,
    # because setSelectionAreas above destroys the coloring.
    c.recolor()

w.setSelectionRange(ins,ins,insert=ins)
w.see(ins)
#@-node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
#@-node:ekr.20031218072017.1833:reformatParagraph
#@-node:ekr.20080612060621.1:Fixed coloring bugs in reformatParagraph and c.redraw
#@+node:ekr.20080605064555.5:Fixed missing redraw problem
# Changed c.outerUpdate.
# Added temp fix (created tag_bind_callback in setCanvasBindings)
# To do: generalize this temp fix: change w.tag_bind to c.tag_bind(w,...)
#@nonl
#@+node:ekr.20070327103016:tkTree.setCanvasBindings
def setCanvasBindings (self,canvas):

    c = self.c ; k = c.k

    c.bind(canvas,'<Key>',k.masterKeyHandler)
    c.bind(canvas,'<Button-1>',self.onTreeClick)
    c.bind(canvas,'<Button-3>',self.onTreeRightClick)
    # c.bind(canvas,'<FocusIn>',self.onFocusIn)

    << make bindings for tagged items on the canvas >>
    << create baloon bindings for tagged items on the canvas >>
#@nonl
#@+node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '<Button-1>',self.onClickBoxClick),
    ('iconBox','<Button-1>',self.onIconBoxClick),
    ('iconBox','<Double-1>',self.onIconBoxDoubleClick),
    ('iconBox','<Button-3>',self.onIconBoxRightClick),
    ('iconBox','<Double-3>',self.onIconBoxRightClick),
    ('iconBox','<B1-Motion>',self.onDrag),
    ('iconBox','<Any-ButtonRelease-1>',self.onEndDrag),

    ('plusBox','<Button-3>', self.onPlusBoxRightClick),
    ('plusBox','<Button-1>', self.onClickBoxClick),
    ('clickBox','<Button-3>',  self.onClickBoxRightClick),
)
for tag,event_kind,callback in table:
    c.tag_bind(canvas,tag,event_kind,callback)
#@-node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
#@+node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
#@-node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
#@-node:ekr.20070327103016:tkTree.setCanvasBindings
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event,p=None):

    c = self.c ; tree = self

    if not p: p = self.eventToPosition(event)
    if not p:
        return

    c.setLog()

    if self.trace and self.verbose: g.trace()

    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p,scroll=False)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)

    return "break" # disable expanded box handling.
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20080514131122.20:c.outerUpdate
def outerUpdate (self):

    c = self ; aList = [] ; trace = False ; verbose = False

    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    scrollFlag = c.requestRedrawScrollFlag
    c.requestRedrawFlag = False
    c.requestRedrawScrollFlag = False

    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        # g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw') # : scroll: %s' % (c.requestRedrawScrollFlag))
        c.frame.tree.redraw_now(scroll=scrollFlag,forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if verbose: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList),c.shortFileName() or '<no name>',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''
    c.requestedRedrawScrollFlag = False
#@-node:ekr.20080514131122.20:c.outerUpdate
#@+node:ekr.20040803072955.58:tree.redraw_now & helper
# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False,forceDraw=False):

    '''Redraw immediately: used by Find so a redraw doesn't mess up selections in headlines.'''

    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return

    c = self.c

    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary()
        if self.trace_redraw or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            # g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()

    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()

redraw = redraw_now # Compatibility
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True,forceDraw=False):

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        if trace: g.trace('bbox',bbox,g.callers())
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:tree.redraw_now & helper
#@+node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20080514131122.7:c.begin/endUpdate

def beginUpdate(self):

    '''Deprecated: does nothing.'''

    g.trace('***** c.beginUpdate is deprecated',g.callers())
    if g.app.unitTesting: assert(False)

def endUpdate(self,flag=True,scroll=True):

    '''Request a redraw of the screen if flag is True.'''

    g.trace('***** c.endUpdate is deprecated',g.callers())
    if g.app.unitTesting: assert(False)

    c = self
    if flag:
        c.requestRedrawFlag = True
        c.requestRedrawScrollFlag = scroll
        # g.trace('flag is True',c.shortFileName(),g.callers())

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20080514131122.7:c.begin/endUpdate
#@+node:ekr.20080515053412.1:c.add_command, c.bind, c.bind2 & c.tag_bind
# These wrappers ensure that c.outerUpdate get called.
#@nonl
#@+node:ekr.20080610085158.2:c.add_command
def add_command (self,menu,**keys):

    c = self ; command = keys.get('command')

    if command:

        def add_commandCallback(c=c,command=command):
            val = command()
            # Careful: func may destroy c.
            if c.exists: c.outerUpdate()
            return val

        keys ['command'] = add_commandCallback

        menu.add_command(**keys)

    else:
        g.trace('can not happen: no "command" arg')
#@-node:ekr.20080610085158.2:c.add_command
#@+node:ekr.20080610085158.3:c.bind and c.bind2
def bind (self,w,pattern,func,*args,**keys):

    c = self ; callers = g.callers()

    def bindCallback(event,c=c,func=func,callers=callers):
        # g.trace('w',w,'binding callers',callers)
        val = func(event)
        # Careful: func may destroy c.
        if c.exists: c.outerUpdate()
        return val

    w.bind(pattern,bindCallback,*args,**keys)

def bind2 (self,w,pattern,func,*args,**keys):

    c = self

    def bindCallback2(event,c=c,func=func):
        val = func(event)
        # Careful: func may destroy c.
        if c.exists: c.outerUpdate()
        return val

    w.bind(pattern,bindCallback2,*args,**keys)
#@-node:ekr.20080610085158.3:c.bind and c.bind2
#@+node:ekr.20080610085158.4:c.tag_bind
def tag_bind (self,w,tag,event_kind,func):

    c = self
    def tag_bindCallback(event,c=c,func=func):
        val = func(event)
        # Careful: func may destroy c.
        if c.exists: c.outerUpdate()
        return val

    w.tag_bind(tag,event_kind,tag_bindCallback)
#@-node:ekr.20080610085158.4:c.tag_bind
#@-node:ekr.20080515053412.1:c.add_command, c.bind, c.bind2 & c.tag_bind
#@+node:ekr.20080514131122.8:c.bringToFront
def bringToFront(self,set_focus=True):

    c = self
    c.requestedIconify = 'deiconify'
    c.requestedFocusWidget = c.frame.body.bodyCtrl

BringToFront = bringToFront # Compatibility with old scripts
#@-node:ekr.20080514131122.8:c.bringToFront
#@+node:ekr.20080514131122.9:c.get/request/set_focus
def get_focus (self):

    c = self
    return g.app.gui and g.app.gui.get_focus(c)

def get_requested_focus (self):

    c = self
    return c.requestedFocusWidget

def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w

def set_focus (self,w,force=False):

    c = self
    if w and g.app.gui and c.requestedFocusWidget:
        g.app.gui.set_focus(c,w)

    c.requestedFocusWidget = None
#@-node:ekr.20080514131122.9:c.get/request/set_focus
#@+node:ekr.20080514131122.10:c.invalidateFocus
def invalidateFocus (self):

    '''Indicate that the focus is in an invalid location, or is unknown.'''

    # c = self
    # c.requestedFocusWidget = None
    pass
#@nonl
#@-node:ekr.20080514131122.10:c.invalidateFocus
#@+node:ekr.20080514131122.11:c.masterFocusHandler
def masterFocusHandler (self):

    pass # No longer used.

restoreRequestedFocus = masterFocusHandler
#@-node:ekr.20080514131122.11:c.masterFocusHandler
#@+node:ekr.20080514131122.20:c.outerUpdate
def outerUpdate (self):

    c = self ; aList = [] ; trace = False ; verbose = False

    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    scrollFlag = c.requestRedrawScrollFlag
    c.requestRedrawFlag = False
    c.requestRedrawScrollFlag = False

    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        # g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw') # : scroll: %s' % (c.requestRedrawScrollFlag))
        c.frame.tree.redraw_now(scroll=scrollFlag,forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if verbose: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList),c.shortFileName() or '<no name>',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''
    c.requestedRedrawScrollFlag = False
#@-node:ekr.20080514131122.20:c.outerUpdate
#@+node:ekr.20080514131122.12:c.recolor & requestRecolor
def requestRecolor (self):

    c = self
    c.requestRecolorFlag = True

recolor = requestRecolor
#@-node:ekr.20080514131122.12:c.recolor & requestRecolor
#@+node:ekr.20080514131122.13:c.recolor_now
def recolor_now(self,p=None,incremental=False,interruptable=True):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,
        incremental=incremental,interruptable=interruptable)
#@-node:ekr.20080514131122.13:c.recolor_now
#@+node:ekr.20080514131122.14:c.redraw and c.redraw_now
def redraw (self,scroll=True):
    c = self
    c.requestRedrawFlag = True
    # This makes c.redraw *not quite* the same as c.endUpdate.
    c.requestRedrawScrollFlag = scroll

def redraw_now (self):
    c = self
    c.requestRedrawFlag = True
    c.outerUpdate()
    assert not c.requestRedrawFlag

# Compatibility with old scripts
force_redraw = redraw_now
#@-node:ekr.20080514131122.14:c.redraw and c.redraw_now
#@+node:ekr.20080514131122.15:c.restoreFocus
def restoreFocus (self):

    '''Ensure that the focus eventually gets restored.'''
    pass
    # g.trace(g.callers(5))

    # c =self
    # trace = not g.app.unitTesting and c.config.getBool('trace_focus')

    # if c.requestedFocusWidget:
        # c.hasFocusWidget = None # Force an update
    # elif c.hasFocusWidget:
        # c.requestedFocusWidget = c.hasFocusWidget
        # c.hasFocusWidget = None # Force an update
    # else:
        # # Should not happen, except during unit testing.
        # # c.masterFocusHandler sets c.hasFocusWidget,
        # # so if it is not set here it is because this method cleared it.
        # if not g.app.unitTesting: g.trace('oops: no requested or present widget.',g.callers())
        # c.bodyWantsFocusNow()

    # if c.inCommand:
        # if trace: g.trace('expecting later call to c.masterFocusHandler')
        # # A call to c.masterFocusHandler will surely happen.
    # else:
        # c.masterFocusHandler() # Do it now.
#@-node:ekr.20080514131122.15:c.restoreFocus
#@+node:ekr.20080514131122.16:c.traceFocus
trace_focus_count = 0

def traceFocus (self,w):

    c = self

    if False or (not g.app.unitTesting and c.config.getBool('trace_focus')):
        c.trace_focus_count += 1
        g.pr('%4d' % (c.trace_focus_count),c.widget_name(w),g.callers(8))
#@-node:ekr.20080514131122.16:c.traceFocus
#@+node:ekr.20080514131122.17:c.widget_name
def widget_name (self,widget):

    c = self

    return g.app.gui and g.app.gui.widget_name(widget) or ''
#@-node:ekr.20080514131122.17:c.widget_name
#@+node:ekr.20080514131122.18:c.xWantsFocus (no change)
def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)

def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and c.edit_widget(p))

def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)

def minibufferWantsFocus(self):
    c = self ; k = c.k
    if k: k.minibufferWantsFocus()

def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)

def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
#@-node:ekr.20080514131122.18:c.xWantsFocus (no change)
#@+node:ekr.20080514131122.19:c.xWantsFocusNow
# widgetWantsFocusNow does an automatic update.
def widgetWantsFocusNow(self,w):
    c = self
    c.request_focus(w)
    c.outerUpdate()
    # Re-request widget so we don't use the body by default.
    c.request_focus(w) 

# All other "Now" methods wait.
bodyWantsFocusNow = bodyWantsFocus
headlineWantsFocusNow = headlineWantsFocus
logWantsFocusNow = logWantsFocus
minibufferWantsFocusNow = minibufferWantsFocus
treeWantsFocusNow = treeWantsFocus
#@-node:ekr.20080514131122.19:c.xWantsFocusNow
#@-node:ekr.20031218072017.2949:Drawing Utilities (commands)
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    # g.trace('c',self.c)

    c = self.c ; f = c.frame ; k = c.k ; trace = False
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (c=c,k=k,stroke=stroke,command=command,commandName=commandName):
            #k.clearState()
            #g.trace(stroke)
            return k.masterMenuHandler(stroke,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>

        # c.add_command ensures that c.outerUpdate is called.
        if menu:
            c.add_command(menu,label=realLabel,
                accelerator=accelerator,
                command=masterMenuCallback,
                underline=amp_index)
#@+node:ekr.20051021091958:<< get label & command or continue >>
if type(data) in (type(''),type(u'')): # Bug fix: 10/10/07: Allow unicode labels.
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                if trace: g.trace('1','%20s' % (bunch.val),commandName)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            if trace: g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            if trace: g.trace('2','%20s' % (bunch.val),commandName)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val
                    if trace: g.trace('3','%20s' % (bunch.val),commandName)
                    break
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20080515053412.1:c.add_command, c.bind, c.bind2 & c.tag_bind
# These wrappers ensure that c.outerUpdate get called.
#@nonl
#@+node:ekr.20080610085158.2:c.add_command
def add_command (self,menu,**keys):

    c = self ; command = keys.get('command')

    if command:

        def add_commandCallback(c=c,command=command):
            val = command()
            # Careful: func may destroy c.
            if c.exists: c.outerUpdate()
            return val

        keys ['command'] = add_commandCallback

        menu.add_command(**keys)

    else:
        g.trace('can not happen: no "command" arg')
#@-node:ekr.20080610085158.2:c.add_command
#@+node:ekr.20080610085158.3:c.bind and c.bind2
def bind (self,w,pattern,func,*args,**keys):

    c = self ; callers = g.callers()

    def bindCallback(event,c=c,func=func,callers=callers):
        # g.trace('w',w,'binding callers',callers)
        val = func(event)
        # Careful: func may destroy c.
        if c.exists: c.outerUpdate()
        return val

    w.bind(pattern,bindCallback,*args,**keys)

def bind2 (self,w,pattern,func,*args,**keys):

    c = self

    def bindCallback2(event,c=c,func=func):
        val = func(event)
        # Careful: func may destroy c.
        if c.exists: c.outerUpdate()
        return val

    w.bind(pattern,bindCallback2,*args,**keys)
#@-node:ekr.20080610085158.3:c.bind and c.bind2
#@+node:ekr.20080610085158.4:c.tag_bind
def tag_bind (self,w,tag,event_kind,func):

    c = self
    def tag_bindCallback(event,c=c,func=func):
        val = func(event)
        # Careful: func may destroy c.
        if c.exists: c.outerUpdate()
        return val

    w.tag_bind(tag,event_kind,tag_bindCallback)
#@-node:ekr.20080610085158.4:c.tag_bind
#@-node:ekr.20080515053412.1:c.add_command, c.bind, c.bind2 & c.tag_bind
#@-node:ekr.20080605064555.5:Fixed missing redraw problem
#@+node:ekr.20080612060621.3:Fixed new-headline problem
#@+node:ekr.20031218072017.1623:new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    # g.trace(g.callers())

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    # c.beginUpdate()
    # try:
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    v = leoNodes.vnode(context=c)
    p = leoNodes.position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    c.setRootVnode(v) # New in Leo 4.4.2.
    c.editPosition(p)
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(fileName=None)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # finally:
    # c.endUpdate(False)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    # Force a call to c.outerUpdate.
    # This is needed when we execute this command from a menu.
    c.redraw_now()

    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20080514131122.7:c.begin/endUpdate

def beginUpdate(self):

    '''Deprecated: does nothing.'''

    g.trace('***** c.beginUpdate is deprecated',g.callers())
    if g.app.unitTesting: assert(False)

def endUpdate(self,flag=True,scroll=True):

    '''Request a redraw of the screen if flag is True.'''

    g.trace('***** c.endUpdate is deprecated',g.callers())
    if g.app.unitTesting: assert(False)

    c = self
    if flag:
        c.requestRedrawFlag = True
        c.requestRedrawScrollFlag = scroll
        # g.trace('flag is True',c.shortFileName(),g.callers())

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20080514131122.7:c.begin/endUpdate
#@+node:ekr.20031218072017.2991:c.editPosition
# Selects v: sets the focus to p and edits p.

def editPosition(self,p,selectAll=False):

    c = self ; k = c.k

    if p:
        c.selectPosition(p)

        c.frame.tree.editLabel(p,selectAll=selectAll)

        if k:
            if selectAll:
                k.setInputState('insert')
            else:
                k.setDefaultInputState()

            k.showStateAndMode()
#@-node:ekr.20031218072017.2991:c.editPosition
#@+node:ekr.20080514131122.20:c.outerUpdate
def outerUpdate (self):

    c = self ; aList = [] ; trace = False ; verbose = False

    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    scrollFlag = c.requestRedrawScrollFlag
    c.requestRedrawFlag = False
    c.requestRedrawScrollFlag = False

    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        # g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw') # : scroll: %s' % (c.requestRedrawScrollFlag))
        c.frame.tree.redraw_now(scroll=scrollFlag,forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if verbose: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList),c.shortFileName() or '<no name>',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''
    c.requestedRedrawScrollFlag = False
#@-node:ekr.20080514131122.20:c.outerUpdate
#@+node:ekr.20040803072955.127:tree.editLabel
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c
    trace = (False or self.trace_edit)

    if p and p != self.editPosition():

        if trace:
            g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

        # c.beginUpdate()
        # try:
        self.endEditLabel()
        # finally:
        # This redraw *is* required so the c.edit_widget(p) will exist.
        c.redraw() # was c.endUpdate(True)
        c.outerUpdate()

    self.setEditPosition(p) # That is, self._editPosition = p
    w = c.edit_widget(p)

    if trace: g.trace('1','w',w,'focus',g.app.gui.get_focus(c))

    if p and w:
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
        c.k.showStateAndMode(w)

    if trace: g.trace('w',w,'focus',g.app.gui.get_focus(c))
#@-node:ekr.20040803072955.127:tree.editLabel
#@+node:ekr.20080612091459.1:Found: .redraw_now
#@+node:ekr.20080506135044.9:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                undoData = u.beforeInsertNode(c.currentPosition())
                << create the found node >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        # u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    self.restore(data)
    c.redraw_now()
    g.es("found",count,"matches")

#@+node:ekr.20080506135044.10:<< create the found node >>
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
#@-node:ekr.20080506135044.10:<< create the found node >>
#@+node:ekr.20080506135044.11:<< create a clone of p under the find node >>
q = self.p.clone()
q.moveToLastChildOf(found)
#@-node:ekr.20080506135044.11:<< create a clone of p under the find node >>
#@-node:ekr.20080506135044.9:findAll
#@+node:ekr.20080514131122.20:c.outerUpdate
def outerUpdate (self):

    c = self ; aList = [] ; trace = False ; verbose = False

    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    scrollFlag = c.requestRedrawScrollFlag
    c.requestRedrawFlag = False
    c.requestRedrawScrollFlag = False

    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        # g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw') # : scroll: %s' % (c.requestRedrawScrollFlag))
        c.frame.tree.redraw_now(scroll=scrollFlag,forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if verbose: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList),c.shortFileName() or '<no name>',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''
    c.requestedRedrawScrollFlag = False
#@-node:ekr.20080514131122.20:c.outerUpdate
#@+node:ekr.20080514131122.7:c.begin/endUpdate

def beginUpdate(self):

    '''Deprecated: does nothing.'''

    g.trace('***** c.beginUpdate is deprecated',g.callers())
    if g.app.unitTesting: assert(False)

def endUpdate(self,flag=True,scroll=True):

    '''Request a redraw of the screen if flag is True.'''

    g.trace('***** c.endUpdate is deprecated',g.callers())
    if g.app.unitTesting: assert(False)

    c = self
    if flag:
        c.requestRedrawFlag = True
        c.requestRedrawScrollFlag = scroll
        # g.trace('flag is True',c.shortFileName(),g.callers())

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20080514131122.7:c.begin/endUpdate
#@+node:ekr.20080514131122.14:c.redraw and c.redraw_now
def redraw (self,scroll=True):
    c = self
    c.requestRedrawFlag = True
    # This makes c.redraw *not quite* the same as c.endUpdate.
    c.requestRedrawScrollFlag = scroll

def redraw_now (self):
    c = self
    c.requestRedrawFlag = True
    c.outerUpdate()
    assert not c.requestRedrawFlag

# Compatibility with old scripts
force_redraw = redraw_now
#@-node:ekr.20080514131122.14:c.redraw and c.redraw_now
#@+node:ekr.20031218072017.1934:run
def run(fileName=None,pymacs=None,jyLeo=False,*args,**keywords):

    """Initialize and run Leo"""

    # __pychecker__ = '--no-argsused' # keywords not used.

    import pdb ; pdb = pdb.set_trace

    << import leoGlobals and leoApp >>
    if not jyLeo and not isValidPython(): return
    g.computeStandardDirectories()
    adjustSysPath(g)
    script,windowFlag = scanOptions(g)
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    if not fileName:
        fileName = getFileName()

    << import other early files >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName,relativeFileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif jyLeo:
        import leo.core.leoSwingGui as leoSwingGui
        g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    if g.app.oneConfigFilename: g.es_print('--one-config option in effect',color='red')
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    # Respect c's focus wishes if posssible.
    w = g.app.gui.get_focus(c)
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)
    c.outerUpdate()
    g.app.gui.runMainLoop()
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
if jyLeo:
    print('*** starting jyLeo',sys.platform) # will be something like java1.6.0_02

# Add the current directory to sys.path *before* importing g.
# This will fail if the current directory contains unicode characters...
path = os.getcwd()
if path not in sys.path:
    # print('appending %s to sys.path' % path)
    sys.path.append(path)

# Import leoGlobals, but do NOT set g.
import leo.core.leoGlobals as leoGlobals

# Set leoGlobals.g here, rather than in leoGlobals.py.
leoGlobals.g = leoGlobals

import leo.core.leoApp as leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

if jyLeo:
    startJyleo(g)
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import other early files>>
import leo.core.leoNodes as leoNodes
import leo.core.leoConfig as leoConfig

# There is a circular dependency between leoCommands and leoEditCommands.
import leo.core.leoCommands as leoCommands
#@-node:ekr.20041219072416.1:<< import other early files>>
#@-node:ekr.20031218072017.1934:run
#@+node:ekr.20031218072017.1623:new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    # g.trace(g.callers())

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    # c.beginUpdate()
    # try:
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    v = leoNodes.vnode(context=c)
    p = leoNodes.position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    c.setRootVnode(v) # New in Leo 4.4.2.
    c.editPosition(p)
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(fileName=None)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # finally:
    # c.endUpdate(False)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    # Force a call to c.outerUpdate.
    # This is needed when we execute this command from a menu.
    c.redraw_now()

    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20071001091231.80:reconfigureFromConfig (swingFrame)
def reconfigureFromConfig (self):

    frame = self ; c = frame.c

    frame.tree.setFontFromConfig()
    ### frame.tree.setColorFromConfig()

    frame.configureBarsFromConfig()

    frame.body.setFontFromConfig()
    frame.body.setColorFromConfigt()

    frame.setTabWidth(c.tab_width)
    frame.log.setFontFromConfig()
    frame.log.setColorFromConfig()

    c.redraw_now()
#@-node:ekr.20071001091231.80:reconfigureFromConfig (swingFrame)
#@+node:ekr.20070317085437.41:cc.renameChapter
# newName is for unitTesting.

def renameChapter (self,event=None,newName=None):

    '''Use the minibuffer to get a new name for the present chapter.'''

    cc = self ; c = cc.c ; k = cc.c.k ; tt = cc.tt
    tag = 'rename-chapter'
    theChapter = cc.selectedChapter
    if not theChapter: return
    if theChapter.name == 'main':
        return cc.error('Can not rename the main chapter')

    state = k.getState(tag)

    if state == 0 and not newName:
        names = cc.chaptersDict.keys()
        prefix = 'Rename this chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.renameChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if newName: k.arg = newName
        if k.arg and k.arg != theChapter.name:
            oldChapterName = theChapter.name
            del cc.chaptersDict[theChapter.name]
            cc.chaptersDict[k.arg] = theChapter
            theChapter.name = k.arg
            root = theChapter.root
            root.initHeadString('@chapter %s' % k.arg)
            if tt:
                tt.setTabLabel(k.arg)
                tt.destroyTab(oldChapterName)
                tt.createTab(k.arg)
            c.redraw_now()
#@-node:ekr.20070317085437.41:cc.renameChapter
#@+node:ekr.20031218072017.2817: doCommand
command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""

    c = self ; p = c.currentPosition()
    commandName = command and command.__name__
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_doCommand'):
        g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if c.exists and c.inCommand and not g.unitTesting:
        # g.trace('inCommand',c)
        g.es('ignoring command: already executing a command.',color='red')
        return 'break'

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            if c and c.exists: # Be careful: the command could destroy c.
                c.inCommand = False
                c.k.funcReturn = val
            # else: g.pr('c no longer exists',c)
        except:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es_print("exception executing command")
                g.es_exception(c=c)
                if c and c.exists and hasattr(c,'frame'):
                    c.redraw_now()

        if c and c.exists:
            if c.requestCloseWindow:
                g.trace('Closing window after command')
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)

    return "break" # Inhibit all other handlers.
#@-node:ekr.20031218072017.2817: doCommand
#@+node:ekr.20060202154734:freeTreeWidgets
def freeTreeWidgets (self,event=None):

    '''Free all widgets used in Leo's outline pane.'''

    c = self.c

    c.frame.tree.destroyWidgets()
    c.redraw_now()
#@-node:ekr.20060202154734:freeTreeWidgets
#@+node:ekr.20070921072910:createAllCompareClones & helper
def createAllCompareClones(self,inserted,deleted,changed):

    c = self.c # Always use the visible commander
    # c.beginUpdate()
    # try:
    # Create parent node at the start of the outline.
    u = c.undoer ; undoType = 'Compare .leo Files'
    u.beforeChangeGroup(c.currentPosition(),undoType)
    undoData = u.beforeInsertNode(c.currentPosition())
    parent = c.currentPosition().insertAfter()
    c.setHeadString(parent,undoType)
    u.afterInsertNode(parent,undoType,undoData,dirtyVnodeList=[])
    for d,kind in (
        (deleted,'deleted'),(inserted,'inserted'),(changed,'changed')
    ):
        self.createCompareClones(d,kind,parent)
    c.selectPosition(parent)
    u.afterChangeGroup(parent,undoType,reportFlag=True) 
    # finally:
    # c.endUpdate(False)

    c.redraw_now()
#@nonl
#@+node:ekr.20070921074410:createCompareClones
def createCompareClones (self,d,kind,parent):

    c = self.c # Always use the visible commander.

    if d.keys():
        parent = parent.insertAsLastChild()
        c.setHeadString(parent,kind)

        for key in d.keys():
            p = d.get(key)
            clone = p.clone()
            clone.moveToLastChildOf(parent)
#@-node:ekr.20070921074410:createCompareClones
#@-node:ekr.20070921072910:createAllCompareClones & helper
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    << warn on read-only files >>
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    c.loading = True # disable c.changed

    try:
        ok = True
        # t1 = time.clock()
        v = self.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            self.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            self.rootVnode = v
            c.setRootPosition(p)
            c.changed = False
    except BadLeoFile, message:
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    # Do this before reading derived files.
    self.resolveTnodeLists()

    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw_now()
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    # Do this after reading derived files.
    if readAtFileNodesFlag:
        # The descendent nodes won't exist unless we have read the @thin nodes!
        self.restoreDescendentAttributes()

    self.setPositionsFromVnodes()
    c.selectVnode(c.currentPosition()) # load body pane

    self.initAllParents()

    if c.config.getBool('check_outline_after_read'):
        g.trace('@bool check_outline_after_read = True',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, self.ratio
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False

if self.read_only:
    g.es("read only:",fileName,color="red")
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                undoData = u.beforeInsertNode(c.currentPosition())
                << create the found node >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        # u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    self.restore(data)
    c.redraw_now()
    g.es("found",count,"matches")
#@+node:ekr.20051113110735:<< create the found node >>
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
#@-node:ekr.20051113110735:<< create the found node >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
q = self.p.clone()
q.moveToLastChildOf(found)
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20031218072017.2246:reconfigureFromConfig (tkFrame)
def reconfigureFromConfig (self):

    frame = self ; c = frame.c

    frame.tree.setFontFromConfig()
    frame.configureBarsFromConfig()

    frame.body.setFontFromConfig()
    frame.body.setColorFromConfig()

    frame.setTabWidth(c.tab_width)
    frame.log.setFontFromConfig()
    frame.log.setColorFromConfig()

    c.redraw_now()
#@-node:ekr.20031218072017.2246:reconfigureFromConfig (tkFrame)
#@-node:ekr.20080612091459.1:Found: .redraw_now
#@-node:ekr.20080612060621.3:Fixed new-headline problem
#@+node:ekr.20080617073917.2:Fixed recent crasher
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 311, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoEditCommands.py", line 4781, in selectAllText
    return w.selectAllText()
AttributeError: Canvas instance has no attribute 'selectAllText'
#@+node:ekr.20061111223516:selectAllText (leoEditCommands)
def selectAllText (self,event):

    c = self.c 

    w = self.editWidget(event)
    if w:
        return w.selectAllText()
#@-node:ekr.20061111223516:selectAllText (leoEditCommands)
#@-node:ekr.20080617073917.2:Fixed recent crasher
#@+node:ekr.20080622082853.1:Encoding problems with paste from clipboard
#@+node:ekr.20070130115927.7:leoFrame.pasteText
def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    # g.trace('isText',g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()

    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()

    s = g.toUnicode(s,encoding=g.app.tkEncoding)

    # g.trace('pasteText','wname',wname,'s',s,g.callers())

    singleLine = wname.startswith('head') or wname.startswith('minibuffer')

    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)

        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                width = f.tree.headWidth(p=None,s=s)
                w.setWidth(width)
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.

    return 'break' # Essential

OnPasteFromMenu = pasteText
#@-node:ekr.20070130115927.7:leoFrame.pasteText
#@+node:ekr.20061113151148.6:insert
# The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.insert(w,i,s)

#@-node:ekr.20061113151148.6:insert
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20080622082853.1:Encoding problems with paste from clipboard
#@+node:ekr.20080528093133.3:Changed installer to support leo-as-a-package
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/8edc4e7b809189cf

I'm currently confused about leo-as-a-library(?) and leo-as-an-editor,
but I'm pretty sure the installer has not kept up.  Using trunk revno
441, if I "cd trunk; sudo /bin/sh ./install" I get

Password:

Prefix directory set to "/usr/local"
cp: cannot stat `src': no such file or directory
cp: cannot stat `config': no such file or directory

Leo installed successfully
Make sure /usr/local/bin is in your path then
type 'leo filename.leo' to use it.

...where /usr/local/bin/leo contains
python /usr/local/lib/src/leo.py "$1"

which is not going to work, since src/leo.py doesn't exist any more.
Changing that to

python /usr/local/lib/core/runLeo.py "$1"

seems to fix most things.  However, now that we're sending multiple
arguments to
leo, I suggest we use

python /usr/local/lib/core/runLeo.py "$@"
#@-node:ekr.20080528093133.3:Changed installer to support leo-as-a-package
#@+node:ekr.20080623083646.2:Fixed undo problem
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/794ca596f7c58ae5

Its difficult to nail down the exact circumstances and results.

The following does not show all the problems I have been experiencing
but it does serve to show that undo/redo is broken.

In a new window do  Ctrl-I 1, Ctrl-I 2, Ctrl-I 3, to insert three
headlines named 1,2 and 3. Go back to 1 and insert 1 in the body, same
with 2 and 3.

Now use undo repeatedly to go back as far as you can, then use redo to
go as far forward as you can.

Observe the results.

Now do the same but revert leo to a pre-big-change version first.

In the old leo you will end up with three nodes 1,2,3 with 1,2,3 in
there respective bodies, just as one should expect, but in the new leo
you won't.

I'll try to find repeatable ways of demonstrating some of the other
problems.

Bob

@color
#@nonl
#@+node:ekr.20080623083646.10:dumpBead
def dumpBead (self,n):

    u = self
    if n < 0 or n >= len(u.beads):
        return 'no bead: n = ',n

    bunch = u.beads[n] ; result = []
    result.append('-' * 10)
    result.append('len(u.beads): %s, n: %s' % (len(u.beads),n))
    for ivar in ('kind','newP','newN','p','oldN','undoHelper'):
        result.append('%s = %s' % (ivar,getattr(self,ivar)))
    return '\n'.join(result)

def dumpTopBead(self):

    u = self
    n = len(u.beads)
    if n > 0:
        return self.dumpBead(n-1)
    else:
        return '<no top bead>'
#@-node:ekr.20080623083646.10:dumpBead
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self,event=None):

    '''Redo the operation undone by the last undo.'''

    u = self ; c = u.c ; trace = False

    if not u.canRedo():
        if trace: g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.redoing = True 
    u.groupCount = 0

    # c.beginUpdate()
    # try:
    c.endEditing()
    if u.redoHelper: u.redoHelper()
    else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    # finally:
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.currentPosition())
    else:
        c.setCurrentPosition(c.currentPosition())
    c.setChanged(True)
    c.redraw() # was c.endUpdate()
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    c.redraw_now()
    c.recolor_now()
    c.bodyWantsFocusNow()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):

    u = self ; c = u.c

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    u.newP.v._computeParentsOfChildren()
    u.newP._parentVnode()._computeParentsOfChildren()

    c.selectPosition(u.newP)
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20080425060424.9:redoDemote
def redoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = u.p.childIndex()

    # Remove the moved nodes from the parent's children.
    parent_v.t.children = parent_v.t.children[:n+1]

    # Add the moved nodes to p's children
    u.p.v.t.children.extend(u.followingSibs)

    # Adjust the parent links of all moved nodes.
    u.p.v._computeParentsOfChildren(children=u.followingSibs)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.9:redoDemote
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # c.beginUpdate()
        # try:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                # g.trace(z.redoHelper)
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s' % u.undoType)
        # finally:
        # c.endUpdate(False)

    u.groupCount -= 1

    u.updateMarks('new') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.t.setDirty()

    if not g.unitTesting:
        g.es("redo",count,"instances")

    c.selectPosition(p)
    if newSel: c.frame.body.setSelectionRange(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    # Restore all vnodeLists (and thus all clone marks).
    u.newP._restoreLinksInTree()

    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                t.setBodyString(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050526125801:redoMark
def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.setDirty()

        c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.oldParent_v.t.children[u.oldN] == v
    del u.oldParent_v.t.children[u.oldN]
    u.newParent_v.t.children.insert(u.newN,v)

    # Recompute the parent links.
    u.newParent_v._computeParentsOfChildren()

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setBodyString(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20080425060424.13:redoPromote
def redoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()

    # Add the children to parent_v's children.
    n = u.p.childIndex() + 1
    z = parent_v.t.children[:]
    parent_v.t.children = z[:n]
    parent_v.t.children.extend(u.children)
    parent_v.t.children.extend(z[n:])

    # Remove v's children.
    u.p.v.t.children = []

    # Adjust the parent links of all moved nodes.
    parent_v._computeParentsOfChildren(children=u.children)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.13:redoPromote
#@+node:ekr.20080425060424.4:redoSort
def redoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.t.children = u.newChildren
    c.setPositionAfterSort(u.sortChildren)
#@nonl
#@-node:ekr.20080425060424.4:redoSort
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self,event=None):

    """Undo the operation described by the undo parameters."""

    u = self ; c = u.c ; trace = False

    if not u.canUndo():
        if trace: g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.undoing = True
    u.groupCount = 0

    # c.beginUpdate()
    # try:
    c.endEditing()
    if u.undoHelper: u.undoHelper()
    else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    # finally:
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.currentPosition())
    else:
        c.setCurrentPosition(c.currentPosition())
    c.setChanged(True)
    c.redraw() # was c.endUpdate()
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    c.redraw_now()
    c.recolor_now()
    c.bodyWantsFocusNow()
    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 4.4.6

    c.selectPosition(u.p)
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p._linkAfter(u.oldBack)
    elif u.oldParent:
        u.p._linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p._linkAsRoot(oldRoot)

    # Restore all vnodeLists (and thus all clone marks).
    u.p._restoreLinksInTree()
    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20080425060424.10:undoDemote
def undoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)

    # Remove the demoted nodes from p's children.
    u.p.v.t.children = u.p.v.t.children[:-n]

    # Add the demoted nodes to the parent's children.
    parent_v.t.children.extend(u.followingSibs)

    # Adjust the parent links of all moved nodes.
    parent_v._computeParentsOfChildren(children=u.followingSibs)

    c.setCurrentPosition(u.p)
#@nonl
#@-node:ekr.20080425060424.10:undoDemote
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        # c.beginUpdate()
        # try:
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            # g.trace(z.undoHelper)
            if z.undoHelper:
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s' % u.undoType)
        # finally:
        # c.endUpdate(False)

    u.groupCount -= 1

    u.updateMarks('old') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 4.4.6.

    if not g.unitTesting:
        g.es("undo",count,"instances")

    c.selectPosition(p)
    if oldSel: c.frame.body.setSelectionRange(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)

    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                t.setBodyString(bunch.body)
                t.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.setDirty() # Bug fix: Leo 4.4.6.

        c.selectPosition(u.p)
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.newParent_v.t.children[u.newN] == v
    del u.newParent_v.t.children[u.newN]
    u.oldParent_v.t.children.insert(u.oldN,v)

    # Recompute the parent links.
    u.oldParent_v._computeParentsOfChildren()

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    c.selectPosition(u.p)
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setBodyString(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 4.4.6.
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20080425060424.14:undoPromote
def undoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()

    # Remove the promoted nodes from parent_v's children.
    n = u.p.childIndex() + 1
    z = parent_v.t.children
    parent_v.t.children = z[:n]
    parent_v.t.children.extend(z[n+len(u.children):])

    # Add the demoted nodes to v's children.
    u.p.t.children = u.children[:]

    # Adjust the parent links of all moved nodes.
    u.p.v._computeParentsOfChildren(children=u.children)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.14:undoPromote
#@+node:ekr.20031218072017.1493:undoRedoText
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    # __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setBodyString(result)
    w.setAllText(result)
    c.frame.body.recolor(p,incremental=False)
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.bodyString())

    return p # Nothing really changes.
#@-node:ekr.20050408100042:undoRedoTree
#@+node:ekr.20080425060424.5:undoSort
def undoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.t.children = u.oldChildren
    c.setPositionAfterSort(u.sortChildren)

#@-node:ekr.20080425060424.5:undoSort
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
#@-node:ekr.20050318085713.2:undoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 4.4.6.

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@-node:ekr.20031218072017.2039:undo & helpers...
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.currentPosition()
    if not p: return

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    # c.beginUpdate()
    # try:
    c.endEditing() # Make sure we capture the headline for Undo.
    # finally:
    # c.endUpdate(False)

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.headString()
        if h.startswith(chapters):
            if p.hasChildren():
                return cc.error('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                return cc.removeChapterByName(name)

    # c.beginUpdate()
    # try:
    undoData = u.beforeDeleteNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.doDelete(newNode)
    c.selectPosition(newNode)
    c.setChanged(True)
    u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    # finally:
    c.redraw() # was c.endUpdate()

    c.validateOutline()
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)

    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                t.setBodyString(bunch.body)
                t.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setBodyString(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 4.4.6.
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20040803072955.90:head key handlers (leoTree)
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    c = self.c ; u = c.undoer ; w = c.edit_widget(p)
    if c.suppressHeadChanged: return
    if not w: return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    << truncate s if it has multiple lines >>
    # c.beginUpdate()
    # try:
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    # g.trace('changed',changed,'old',repr(oldRevert),'new',repr(s))
    # g.trace(g.callers())
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    # finally:
    if changed:
        c.redraw(scroll=False) # was c.endUpdate(flag=changed,scroll=False)
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):

    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # g.trace(repr(ch),g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):

    '''Update a headline from an event.

    The headline officially changes only when editing ends.'''

    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i

    # g.trace('w',w,'ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i-1,i-1,insert=i-1)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):

    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None

    # Important: this will redraw if necessary.
    self.onHeadChanged(p)

    if 0: # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
        k.setDefaultInputState()
        k.showStateAndMode()

    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
#@-node:ekr.20040803072955.126:endEditLabel
#@-node:ekr.20040803072955.90:head key handlers (leoTree)
#@+node:ekr.20040305223522:c.setBodyString
def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the tnode up-to-date.
    if v.t._bodyString != s:
        # c.beginUpdate()
        # try:
        v.setBodyString(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
        # finally:
        c.redraw() # was c.endUpdate()
#@-node:ekr.20040305223522:c.setBodyString
#@+node:ekr.20060127052111.1:cutStack
def cutStack (self):

    u = self ; n = u.max_undo_stack_size

    if n > 0 and u.bead >= n and not g.app.unitTesting:

        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i >= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads),g.callers())
#@-node:ekr.20060127052111.1:cutStack
#@+node:ekr.20050525151217:getMark & rollbackToMark (no longer used)
if 0:
    def getMark (self):

        # __pychecker__ = '--no-classattr' # self.bead does, in fact, exist.

        return self.bead

    def rollbackToMark (self,n):

        u = self

        u.bead = n
        u.beads = u.beads[:n+1]
        u.setUndoTypes()

    rollBackToMark = rollbackToMark
#@-node:ekr.20050525151217:getMark & rollbackToMark (no longer used)
#@-node:ekr.20080623083646.2:Fixed undo problem
#@+node:ekr.20080624120440.2:Fixed insert-file bug
@nocolor

Minor nit - insert-file to load a file into a node, text appears in the
body pane.  Without doing anything else to the body pane click on
another node.  Inserted text is lost - body for node is empty.  As long
as you move the cursor into the body frame and press a key after
inserting the contents, it's retained.

@color
#@nonl
#@+node:ekr.20050920084036.167:insertFile
def insertFile (self,event):

    '''Prompt for the name of a file and put the selected text into it.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    f, name = self.getReadableTextFile()
    if f:
        self.beginCommand(undoType='insert-file')

        txt = f.read()
        f.close()
        w.insert('insert',txt)
        w.seeInsertPoint()

        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.167:insertFile
#@-node:ekr.20080624120440.2:Fixed insert-file bug
#@+node:ekr.20080624120440.3:Fixed script button bug
@nocolor

c.beginUpdate()
try:
 add / change icons on some nodes
 c.setChanged(True)
finally:
 c.endUpdate()

seems not to give a redraw *after* a script button is pressed.

It does give one before the action is taken, so pressing the button
twice shows the change.

EKR: The fix was to mod_scripting.py.

@color
#@nonl
#@+node:ekr.20031218072017.3958:add
def add(self,*args,**keys):

    """Add a button containing text or a picture to the icon bar.

    Pictures take precedence over text"""

    c = self.c ; f = self.iconFrame
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    # First define n.
    try:
        g.app.iconWidgetCount += 1
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 1

    if command:
        def commandCallBack(c=c,command=command):
            val = command()
            if c.exists:
                c.bodyWantsFocus()
                c.outerUpdate()
            return val
    else:
        def commandCallback():
            g.pr("command for widget %s" % (n))
        command = commandCallback

    if imagefile or image:
        << create a picture >>
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        if not self.font:
            self.font = c.config.getFontFromParams(
                "button_text_font_family", "button_text_font_size",
                "button_text_font_slant",  "button_text_font_weight",)
        b.configure(font=self.font)
        # elif sys.platform.startswith('win'):
            # width = max(6,len(text))
            # b.configure(width=width,font=('verdana',7,'bold'))
        if bg: b.configure(bg=bg)
        b.pack(side="left", fill="none")
        return b

    return None
#@+node:ekr.20031218072017.3959:<< create a picture >>
try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)
        g.trace(image,imagefile)

        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []

        refs.append((imagefile,image),)

    if not bg:
        bg = f.cget("bg")

    try:
        b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    except Exception:
        g.es_print('image does not exist',image,color='blue')
        b = Tk.Button(f,relief='flat',bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b

except:
    g.es_exception()
    return None
#@-node:ekr.20031218072017.3959:<< create a picture >>
#@-node:ekr.20031218072017.3958:add
#@+node:ekr.20080514131122.20:c.outerUpdate
def outerUpdate (self):

    c = self ; aList = [] ; trace = False ; verbose = False

    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    scrollFlag = c.requestRedrawScrollFlag
    c.requestRedrawFlag = False
    c.requestRedrawScrollFlag = False

    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        # g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw') # : scroll: %s' % (c.requestRedrawScrollFlag))
        c.frame.tree.redraw_now(scroll=scrollFlag,forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if verbose: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList),c.shortFileName() or '<no name>',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''
    c.requestedRedrawScrollFlag = False
#@-node:ekr.20080514131122.20:c.outerUpdate
#@-node:ekr.20080624120440.3:Fixed script button bug
#@+node:ekr.20080625094201.1:Fixed dragging bug
# The fix was a major addition to p._adjustPositionBeforeUnlink.
#@nonl
#@+node:ekr.20080625094201.2:Report
@nocolor

This has taken me a bit to pin down, but here we go.  Run this script:

t = p.insertAfter()
c.setHeadString(t, 'test node 1')
t = t.insertAfter()
c.setHeadString(t, 'test node 2')
t = t.insertAfter()
c.setHeadString(t, 'test area')
for i in range(200):
   n = t.insertAsLastChild()
   c.setHeadString(n, str(i))
   if i == 3: x = n

for i in range(100):
   n = x.insertAsLastChild()
   c.setHeadString(n, str(i+500))

t.expand()

It creates an outline, you might need to click on the node from which
the script was run to see what was added.  It should look like this:

test node 1
test node 2
test area
   1
   2
  +3
   4
   5
   etc.

Now, use the mouse to drag test node 1 down to a position after node
4... for me at least this results in the outline view leaping to the
bottom of the tree, which it shouldn't do.

Scroll back up to the top, and drag test node 2 down to a position
after node 4, this time no leap.

It appears that the first time you drag something into the test area it
reacts as if 3 is expanded and repositions to allow for all those
actually not visible lines, but the second time you drag something in
it's ok, as if it has an accurate count on visible lines now.
#@-node:ekr.20080625094201.2:Report
#@+node:ekr.20031218072017.2353:c.dragAfter
def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,after): return
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    # c.beginUpdate()
    # try: # In update...
    c.endEditing()
    undoData = u.beforeMoveNode(current)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.moveAfter(after)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        dirtyVnodeList.extend(dirtyVnodeList2)
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    # finally:
    c.selectPosition(p) # Also sets root position.
    c.redraw() # was c.endUpdate()

    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2353:c.dragAfter
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):

    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    # c.beginUpdate()
    # try:
    << set vdrag, childFlag >>
    if self.allow_clone_drags:
        if not self.look_for_control_drag_on_mouse_down:
            self.controlDrag = c.frame.controlKeyIsDown

    redrawFlag = vdrag and vdrag.v.t != p.v.t
    if redrawFlag: # Disallow drag to joined node.
        << drag p to vdrag >>
    elif self.trace and self.verbose:
        g.trace("Cancel drag")

    # Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"
    self.dragging = False
    self.drag_p = None
    # finally:
    # Must set self.drag_p = None first.
    # c.endUpdate(False) # redrawFlag)
    if redrawFlag:
        c.redraw_now()
    c.recolor_now() # Dragging can affect coloring.

    # g.trace(redrawFlag)
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        p = c.dragToNthChildOf(p,vdrag,0)
    else:
        p = c.dragAfter(p,vdrag)
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20040803072955.70:yoffset (tkTree)
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): g.pr("yoffset not visible:",p1)
    if not p1: return 0
    c = self.c
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        root = bunch.p.copy()
    else:
        root = self.c.rootPosition()
    if root:
        h,flag = self.yoffsetTree(root,p1,isTop=True)
        # flag can be False during initialization.
        # if not flag: g.pr("*** yoffset fails:",'root',root,'p1',p1,'returns',h)
        return h
    else:
        return 0

def yoffsetTree(self,p,p1,isTop):
    c = self.c ; h = 0 ; trace = False ; verbose = True
    if trace: g.trace('entry','root',p,p.stack,'target',p1,p1.stack)
    if not c.positionExists(p):
        if trace: g.trace('*** does not exist',p.headString())
        return h,False # An extra precaution.
    p = p.copy()
    if trace and verbose and isTop and c.hoistStack:
        g.trace('c.hoistStack',c.hoistStack[-1].p.headString())
    if isTop and c.hoistStack:
        if p.firstChild():  theIter = [p.firstChild()]
        else:               theIter = []
    else:
        theIter = p.self_and_siblings_iter() # Bug fix 10/27/07: was p.siblings_iter()

    for p2 in theIter:
        if trace and p1.headString() == p2.headString():
            g.trace('loop',p1,p2)
            g.trace(p1.stack,p2.stack)
        if p2 == p1:
            if trace and verbose: g.trace('returns',h,p1.headString())
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            if trace and verbose: g.trace('recursive call')
            h2, flag = self.yoffsetTree(child,p1,isTop=False)
            h += h2
            if flag:
                if trace and verbose: g.trace('returns',h,p1.headString())
                return h, True

    if trace: g.trace('not found',h,p1.headString())
    return h, False
#@-node:ekr.20040803072955.70:yoffset (tkTree)
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
    if not hasattr(self,'c'):
        return

    # __pychecker__ = '--no-argsused' # event not used.
    # __pychecker__ = '--no-intdivide' # suppress warning about integer division.

    c = self.c ; frame = c.frame ; trace = False
    if not p or not c.positionExists(p):
        p = c.currentPosition()
        if trace: g.trace('*** current position',p,p.stack)
    if not p or not c.positionExists(p):
        if trace: g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not c.positionExists(p):
        if trace: g.trace('no position')
        return
    try:
        if trace: g.trace('***',p,p.stack,'exists',c.positionExists(p))
        h1 = self.yoffset(p)
        if self.center_selected_tree_node: # New in Leo 4.4.3.
            << compute frac0 >>
            delta = abs(self.prevMoveToFrac-frac0)
            if trace: g.trace('delta',delta)
            if delta > 0.0:
                self.prevMoveToFrac = frac0
                self.canvas.yview("moveto",frac0)
                if trace: g.trace("frac0 %1.2f h1 %3d htot %3d wtot %3d" % (
                    frac0,h1,htot,wtot),g.callers())
        else:
            last = c.lastVisible()
            nextToLast = last.visBack(c)
            h2 = self.yoffset(last)
            << compute approximate line height >>
            << Compute the fractions to scroll down/up >>
            if frac <= lo: # frac is for scrolling down.
                if self.prevMoveToFrac != frac:
                    self.prevMoveToFrac = frac
                    self.canvas.yview("moveto",frac)
                    if trace: g.trace("frac  %1.2f h1 %3d h2 %3d lo %1.2f hi %1.2f" % (
                        frac, h1,h2,lo,hi),g.callers())
            elif frac2 + (hi - lo) >= hi: # frac2 is for scrolling up.
                if self.prevMoveToFrac != frac2:
                    self.prevMoveToFrac = frac2
                    self.canvas.yview("moveto",frac2)
                    if trace: g.trace("frac2 %1.2f h1 %3d h2 %3d lo %1.2f hi %1.2f" % (
                        frac2,h1,h2,lo,hi),g.callers())

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)

        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.

    except:
        g.es_exception()

idle_scrollTo = scrollTo # For compatibility.
#@+node:ekr.20061030091926:<< compute frac0 >>
# frac0 attempt to put the 
scrollRegion = self.canvas.cget('scrollregion')
geom = self.canvas.winfo_geometry()

if scrollRegion and geom:
    scrollRegion = scrollRegion.split(' ')
    # if trace: g.trace('scrollRegion',repr(scrollRegion))
    htot = int(scrollRegion[3])
    wh,junk,junk = geom.split('+')
    junk,h = wh.split('x')
    if h: wtot = int(h)
    else: wtot = 500
    # if trace: g.trace('geom',geom,'wtot',wtot,'htot',htot)
    if htot > 0.1:
        frac0 = float(h1-wtot/2)/float(htot)
        frac0 = max(min(frac0,1.0),0.0)
    else:
        frac0 = 0.0
else:
    frac0 = 0.0 ; htot = wtot = 0
#@-node:ekr.20061030091926:<< compute frac0 >>
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.canvas.leo_treeBar.get() # Get the previous values of the scrollbar.
try: lo, hi = data
except: lo,hi = 0.0,1.0

# h1 and h2 are the y offsets of the present and last nodes.
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.

frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.58:tree.redraw_now & helper
# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False,forceDraw=False):

    '''Redraw immediately: used by Find so a redraw doesn't mess up selections in headlines.'''

    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return

    c = self.c

    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary()
        if self.trace_redraw or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            # g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()

    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()

redraw = redraw_now # Compatibility
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True,forceDraw=False):

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        if trace: g.trace('bbox',bbox,g.callers())
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:tree.redraw_now & helper
#@+node:ekr.20040303175026.10:p.moveAfter
def moveAfter (self,a):

    """Move a position after position a."""

    p = self # Do NOT copy the position!

    # g.trace('before','p',p,p.stack,'\na',a,a.stack)

    a._adjustPositionBeforeUnlink(p)
    p._unlink()
    p._linkAfter(a)

    # g.trace('before','p',p,p.stack,'\na',a,a.stack)

    return p
#@-node:ekr.20040303175026.10:p.moveAfter
#@+node:ekr.20080427062528.4:p._adjustPositionBeforeUnlink
def _adjustPositionBeforeUnlink (self,p2):

    '''Adjust position p before unlinking p2.'''

    p = self ; sib = p.copy()

    while sib.hasBack():
        sib.moveToBack()
        if sib == p2:
            p._childIndex -= 1
            break

    # Major bug fix: 6/26/2008. Adjust p's stack as well.
    stack = [] ; changed = False ; i = 0
    while i < len(p.stack):
        v,childIndex = p.stack[i]
        p3 = position(v=v,childIndex=childIndex,stack=stack[:i])
        while p3:
            if p2.v == p3.v: # A match with the to-be-moved node?
                stack.append((v,childIndex-1),)
                changed = True
                break
            p3.moveToBack()
        else:
            stack.append((v,childIndex),)
        i += 1

    if changed:
        # g.trace('***new stack','p',p,'stack',stack)
        p.stack = stack
#@-node:ekr.20080427062528.4:p._adjustPositionBeforeUnlink
#@+node:ekr.20080416161551.214:p._linkAfter
def _linkAfter (self,p_after):

    '''Link self after p_after.'''

    p = self
    parent_v = p_after._parentVnode()
        # Returns None if p.v is None

    # Init the ivars.
    p.stack = p_after.stack[:]
    p._childIndex = p_after._childIndex + 1

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # Add p.v to parent_v's children.
    parent_v.t.children.insert(p_after._childIndex+1,p.v)
    parent_v._p_changed = 1

    # Add all all nodes in parent_v.t.vnodeList to p.v.parents
    parent_v._computeParentsOfChildren()
#@-node:ekr.20080416161551.214:p._linkAfter
#@+node:ekr.20080416161551.217:p._unlink
def _unlink (self):

    '''Unlink the receiver p from the tree.'''

    trace = True
    p = self ; n = p._childIndex
    parent_v = p._parentVnode()
        # returns None if p.v is None
    assert(p.v)
    assert(parent_v)
    # g.trace('parent_v',parent_v)

    # Remove v from it's tnode's vnodeList.
    if p.v in p.v.t.vnodeList:
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # Delete p.v from parent_v's children.
    if 0 <= n < len(parent_v.t.children):
        if parent_v.t.children[n] == p.v:
            del parent_v.t.children[n]
            parent_v._p_changed = 1
        elif trace:
            g.trace('**can not happen: children[%s] != p.v' % (n))
            g.trace('parent_v.t.children...\n',g.listToString(parent_v.t.children))
            g.trace('parent_v',parent_v)
            g.trace('parent_v.t.children[n]',parent_v.t.children[n])
            g.trace('p.v',p.v)
            g.trace('** callers:',g.callers())
            if g.app.unitTesting: assert False, 'children[%s] != p.v'
    elif trace:
        g.trace('can not happen: bad child index: %s, len(children): %s' % (n,len(parent_v.t.children)))
        # g.trace('parent_v.t.children...\n',g.listToString(parent_v.t.children))
        g.trace('parent_v',parent_v,'p.v',p.v)
        g.trace('** callsers:',g.callers())
        if g.app.unitTesting: assert False, 'children[%s] != p.v'

    # Clear the entire parents array.
    if p.v.parents:
        p.v.parents = []
        p.v._p_changed = 1



#@-node:ekr.20080416161551.217:p._unlink
#@+node:ekr.20080416161551.212:p._parentVnode
def _parentVnode (self):

    '''Return the parent vnode.
    Return the hiddenRootNode if there is no other parent.'''

    p = self

    if p.v:
        data = p.stack and p.stack[-1]
        if data:
            v, junk = data
            return v
        else:
            return p.v.context.hiddenRootNode
    else:
        return None
#@-node:ekr.20080416161551.212:p._parentVnode
#@-node:ekr.20080625094201.1:Fixed dragging bug
#@-node:ekr.20080408060320.782:Bug fixes
#@+node:ekr.20080408060320.783:Features
#@+node:ekr.20080409081425.1:Remove useTextWidget option from leoKeys.py
#@-node:ekr.20080409081425.1:Remove useTextWidget option from leoKeys.py
#@+node:ekr.20080409111805.2:Set use_sax = True always
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding

    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    self.python23 = g.CheckVersion(version,'2.3')

    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5

    self.currentVnode = None
    self.rootVnode = None

    # For writing
    self.read_only = False
    self.rootPosition = None
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    # self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20060919110638.13:setPositionsFromVnodes & helper
def setPositionsFromVnodes (self):

    c = self.c ; p = c.rootPosition()

    current = None
    d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
    if d:
        s = d.get('str_leo_pos')
        if s:
            current = self.archivedPositionToPosition(s)

    c.setCurrentPosition(current or c.rootPosition())
#@nonl
#@+node:ekr.20061006104837.1:archivedPositionToPosition
def archivedPositionToPosition (self,s):

    c = self.c
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.headString(),c)
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.headString())
    return p
#@nonl
#@-node:ekr.20061006104837.1:archivedPositionToPosition
#@-node:ekr.20060919110638.13:setPositionsFromVnodes & helper
#@-node:ekr.20080409111805.2:Set use_sax = True always
#@+node:ekr.20080506135044.54:Added g.unified_nodes
@nocolor

- Made t arg optional in vnode ctor.

- Removed the t arg from insertAsX.  Affects these plugins:

wrote:     base64Packager.py
wrote:     macros.py
wrote:     table.py
wrote:     templates.py
wrote:     xsltWithNodes.py

Search for tnode.

@color
#@-node:ekr.20080506135044.54:Added g.unified_nodes
#@+node:ekr.20080407090400.3:Added install nodes re Leo's home directory
@nocolor

Leo puts several files in the home directory: .leoID.txt,
.leoRecentFiles.txt, and myLeoSettings.leo.  There are various fallback directories if there is no home directory.

If you want more details, you can do what I did: do a clone-find-all for homeDir.

As for how the home directory is set, the code to do this is g.computeHomeDir.  We get the home directory with

home = os.getenv('HOME',default=None)

There are some mind-numbing details to be handled if there os.getenv does, in fact, return a directory.

@color
#@nonl
#@+node:ekr.20080407090400.4:Found: homeDir
#@+node:ekr.20070224115832:readRecentFiles & helpers
def readRecentFiles (self,localConfigFile):

    '''Read all .leoRecentFiles.txt files.'''

    # The order of files in this list affects the order of the recent files list.
    seen = [] 
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path:
            path = g.os_path_realpath(g.os_path_abspath(g.os_path_normpath(path)))
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()
#@nonl
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
        if not g.unitTesting and not self.silent:
            g.pr(('reading %s' % fileName))
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)

    return ok
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@-node:ekr.20070224115832:readRecentFiles & helpers
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    written = False
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                if not self.recentFileMessageWritten:
                    g.pr(('wrote recent file: %s' % fileName))
                    written = True
                self.writeRecentFilesFileHelper(fileName)
                # Bug fix: Leo 4.4.6: write *all* recent files.

    if written:
        self.recentFileMessageWritten = True
    else:
        pass # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
            # g.trace(fileName,'lines\n%s' % lines)
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass

    except Exception:
        g.es('unexpected exception writing',fileName,color='red')
        g.es_exception()

    if theFile:
        theFile.close()
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@+node:ekr.20041117083857:initSettingsFiles
def initSettingsFiles (self):

    """Set self.globalConfigFile, self.homeFile, self.myGlobalConfigFile,
    self.myHomeConfigFile, and self.machineConfigFile."""

    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    machineConfigFile = g.computeMachineName() + 'LeoSettings.leo'

    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        #non-prefixed names take priority over prefixed names
        ('myHomeConfigFile',    g.app.homeDir,          g.app.homeSettingsPrefix + mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
        ('machineConfigFile',   g.app.homeDir,          g.app.homeSettingsPrefix + machineConfigFile),
        ('machineConfigFile',   g.app.homeDir,          machineConfigFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        #else:
            #if the path does not exist, only set to None if the ivar isn't already set.
            #dan: IMO, it's better to set the defaults to None in configClass.__init__().
            #     This avoids the creation of ivars in odd (non __init__) places.
            #setattr(self,ivar, getattr(self,ivar,None))
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)
#@nonl
#@-node:ekr.20041117083857:initSettingsFiles
#@+node:ekr.20080220082727:@scan_g.es_results
@first # -*- coding: utf-8 -*-

@ To be translated...

#if and #else parts have different braces:
%s dir:
(in
)
*** Two exclusive handlers for
***Updating:
...
:
= requires @root in the headline
@comment disables untangle for
Indentation error in
Leo Log Window...
ParserError in
Referenced from
This is for testing if g.es blocks in a thread
Token error in
TokenError in
\nauto-completer scan complete
\ntest of es_print: 
adding
after
all plugin handlers...
all tests enabled: this may take awhile
already loaded
auto-saving outline
bad
bad @+leo sentinel
bad @+node sentinel
bad abbrev:
bad encoding in derived file:
bad open/close_flash_brackets setting: using defaults
bad tnode index:
blanks converted to tabs in
buffers...
c.target_language:
can not add
can not create
can not create temp file
can not create: read only:
can not execute
can not import
can not import Image module from PIL
can not import ImageTk module
can not import gc module
can not load enabled plugin:
can not load image:
can not open
can not open Aspell
can not open dictionary file:
can not open local dictionary
can not open script file:
can not open:
can not write %s
can't happen: is_sentinel
can't move node out of
changed:
check complete
check-derived-file passed
check-leo-file failed:
check-leo-file passed
checking Python code
clearing undo
collapse_nodes_during_finds
command is not valid in batch mode
command not ready yet
conflicting @header and @noheader directives
correcting hidden node: t=
correcting line endings in:
count:
created
created chapter
created directory:
created in
created:
creating menu from
creating new window
creating:
current directory:
debugger does not exist:
default tangle directory not found:
deleting tnode list for
directory
directory:
disabling save commands
done
dubious brackets in
dummy created
empty
enabled brief gc stats
enabled plugins...
enabled verbose gc stats
end of script
error handling:
error parsing
error pretty-printing
error reading:
error:
errors
errors inhibited read @auto
event
exception binding
exception creating directory:
exception creating temp file
exception creating:
exception deleting backup file:
exception deleting:
exception executing
exception executing command
exception executing script
exception executing:
exception handling
exception in
exception in g.importFromPath
exception in os.chmod
exception loading plugin
exception opening:
exception removing:
exception renaming
exception writing:
extend mode
file not found
file not found:
finished
first mismatched line at line
from
g.app.config: bad encoding:
g.init_zodb: can not import ZODB
g.init_zodb: exception creating ZODB.DB instance
generated line:
get_focus:
gui does not support a stand-alone find dialog
gui does not support the compare window
handlers for
hasFocusWidget:
head_lines:
ignoring
ignoring 3.x sentinel:
ignoring bad @comment directive:
ignoring bad @comment sentinel:
ignoring bad @language directive:
ignoring bad @language sentinel:
ignoring bad unknownAttributes key
ignoring command: already executing a command.
ignoring invalid key binding:
ignoring non-dictionary unknownAttributes for
ignoring non-pickleable attribute
ignoring non-string attribute
ignoring redundant -noref in:
ignoring redundant -nosent in:
ignoring:
ignoring: @comment
imported
in
in file:
indentation error in
info string
inhibits untangle for
ins:
inserting @ignore
instances
invalid @+leo sentinel in
invalid @encoding:
invalid @lineending directive:
invalid Paste As Clone
invalid encoding in .leo file:
is a sentinel line
is also a prefix of
is bound to:
is not
is not in the outline
len
leoID=
line
line:
lines
load dir:
loadOnePlugin: failed to load module
loaded plugin:
looking for a parent to tangle...
lossage...
may be read-only or in use
minibuffer hidden
missing lines
missing vnode:
modes conflict in:
newTnode: unexpected index type:
no @auto nodes in the selected tree
no @file node in the selected tree
no @file nodes in the selected tree
no @test or @suite nodes in selected outline
no Find script node
no ancestor @file node: using script line numbers
no bindings
no child index for
no children and less than 10 characters (excluding directives)
no debugger found.
no dirty @auto nodes in the selected tree
no dirty @file nodes
no docstring for
no file name
no matching #endif:
no more clones
no more misspellings
no previous command
no script selected
no state function for
no such command:
no text selected
no tnode with index:
nodes
nodes checked
not a clone:
not a valid MORE file
not changed.
not found
not found in
not found:
not written:
nothing follows section name
offending line...
offending line:\n
only
or
original line:
over-riding setting:
parent node:
path does not exist:
plugin
probably an outline topology error.
psyco now logging to:
psyco now running
putCount
putDescendentUnknownAttributes can't happen 2
putDescendentUnknownAttributes: unexpected pickling exception
putUaHelper: unexpected pickling exception
read only
read only:
reading:
recreating:
redefining
redo
relative path in @path directive:
relative_path_base_directory:
rename failed: no file created!
reopening:
replacing
requestedFocusWidget:
restoring
resurrected node:
running
save commands disabled
saved:
scanGnx: unexpected index type:
scanning for auto-completer...
seems to be mixed HTML and PHP:
selected text should contain one or more section names
selected text should start with a section name
skipping settings in
surprise in checkPythonNode
swap-words command not ready yet
syntax error in class node: can not continue
syntax error in:
syntax error: deleting
tabs converted to blanks in
tail_lines:
tangle complete
tangling parent
tangling...
the
the clipboard is not valid
the current node is not a clone
the text will be discarded
there may be conflicting settings!
time.strftime not available on this platform
time/count:
time:
to
to dictionary
unchanged:
undo
unexpected exception converting hexlified string to string
unexpected exception in
unexpected exception in app.setLeoID
unexpected exception in c.openWith
unexpected exception in g.create_temp_file
unexpected exception in g.getScript
unexpected exception in g.importFromPath(%s)
unexpected exception parsing
unexpected exception writing
unit tests
unknown attributes for
unknown attributes for tnode
unknown command name:
unknown language: using Python comment delimiters
unknown option:
unmatched
untangle complete
untangling...
using
using -asis option in:
using -thin option in:
using a blank one instead
using empty text.
using os.getenv('USER'):
warning:
warning: conflicting values for
warning: ignoring
warning: possible duplicate definition of:
warning: updating changed text in
with
write the @file node or use the Import Derived File command
writing erroneous:
wrote:
you may want to delete ressurected nodes
@c
# Decls...
color='red'
newline=True
tabName='Log'
False = 'False'
aList = 'aList'
args = 'args'
at_DOT_outputFileName = 'at.outputFileName'
at_DOT_root_DOT_headString_PARENS_ = 'at.root.headString()'
attrDict_DOT_get_LP_key_RP_ = 'attrDict.get(key)'
b2_DOT_pane = 'b2.pane'
backupName = 'backupName'
badline = 'badline'
base = 'base'
bindStroke = 'bindStroke'
bindings = 'bindings'
bunch_DOT_kind = 'bunch.kind'
c_DOT_config_DOT_getBool_LP__SQ_collapse_nodes_during_finds_SQ__RP_ = 'c.config.getBool(\'collapse_nodes_during_finds\')'
c_DOT_disableCommandsMessage = 'c.disableCommandsMessage'
c_DOT_shortFileName_PARENS_ = 'c.shortFileName()'
c_DOT_tangle_directory = 'c.tangle_directory'
c_DOT_target_language = 'c.target_language'
c_DOT_widget_name_LP_c_DOT_get_focus_PARENS__RP_ = 'c.widget_name(c.get_focus())'
c_DOT_widget_name_LP_c_DOT_hasFocusWidget_RP_ = 'c.widget_name(c.hasFocusWidget)'
c_DOT_widget_name_LP_c_DOT_requestedFocusWidget_RP_ = 'c.widget_name(c.requestedFocusWidget)'
c_DOT_widget_name_LP_w_RP_ = 'c.widget_name(w)'
ch = 'ch'
command = 'command'
commandName = 'commandName'
computeProxyObject = 'computeProxyObject'
configDir = 'configDir'
count = 'count'
d_DOT_get_LP_ch_RP_ = 'd.get(ch)'
d2 = 'd2'
d3 = 'd3'
data = 'data'
debugger = 'debugger'
delim1 = 'delim1'
delim2 = 'delim2'
delim3 = 'delim3'
dictionaryFileName = 'dictionaryFileName'
dir2 = 'dir2'
doc = 'doc'
dst = 'dst'
e = 'e'
encoding = 'encoding'
encodingName = 'encodingName'
errors = 'errors'
eventName = 'eventName'
exctype_DOT___name__ = 'exctype.__name__'
fileName = 'fileName'
file_name = 'file_name'
filename = 'filename'
fn = 'fn'
g_DOT_angleBrackets_LP__DQ___DQ__RP_ = 'g.angleBrackets("*")'
g_DOT_app_DOT_globalOpenDir = 'g.app.globalOpenDir'
g_DOT_app_DOT_gui_DOT_getFullVersion_LP_c_RP_ = 'g.app.gui.getFullVersion(c)'
g_DOT_app_DOT_gui_DOT_guiName_PARENS_ = 'g.app.gui.guiName()'
g_DOT_app_DOT_leoID = 'g.app.leoID'
g_DOT_choose_LP_val_COMMA__SQ_on_SQ__COMMA__SQ_off_SQ__RP_ = 'g.choose(val,\'on\',\'off\')'
g_DOT_get_line_LP_s_COMMA_i_RP_ = 'g.get_line(s,i)'
g_DOT_plugin_date_LP_m_RP_ = 'g.plugin_date(m)'
g_DOT_shortFileName_LP_fileName_RP_ = 'g.shortFileName(fileName)'
g_DOT_shortFileName_LP_path_RP_ = 'g.shortFileName(path)'
h = 'h'
head_lines = 'head_lines'
headline = 'headline'
homeDir = 'homeDir'
i = 'i'
index = 'index'
inputFileName = 'inputFileName'
ins = 'ins'
ivar = 'ivar'
k_DOT_prettyPrintKey_LP_stroke_RP_ = 'k.prettyPrintKey(stroke)'
k_DOT_state_DOT_kind = 'k.state.kind'
key = 'key'
keys = 'keys'
kind = 'kind'
len_LP_lines_RP_ = 'len(lines)'
len_LP_s_RP_ = 'len(s)'
letter = 'letter'
line = 'line'
line1 = 'line1'
line2 = 'line2'
loadDir = 'loadDir'
lp = 'lp'
m = 'm'
m_DOT___name__ = 'm.__name__'
m_DOT___version__ = 'm.__version__'
message = 'message'
min_LP_12_COMMA_n2_RP_ = 'min(12,n2)'
min_LP_20_COMMA_n1_RP_ = 'min(20,n1)'
modeName = 'modeName'
moduleName = 'moduleName'
msg = 'msg'
n = 'n'
n1 = 'n1'
n2 = 'n2'
n3 = 'n3'
name = 'name'
newFileName = 'newFileName'
p_DOT_headString_PARENS_ = 'p.headString()'
p_DOT_parent_PARENS__DOT_headString_PARENS_ = 'p.parent().headString()'
pane = 'pane'
part_DOT_name = 'part.name'
path = 'path'
prefix = 'prefix'
ratio = 'ratio'
relative_path = 'relative_path'
repr_LP_at_DOT_t_RP_ = 'repr(at.t)'
repr_LP_ch_RP_ = 'repr(ch)'
repr_LP_data_RP_ = 'repr(data)'
repr_LP_g_DOT_app_DOT_leoID_RP_ = 'repr(g.app.leoID)'
repr_LP_line_RP_ = 'repr(line)'
repr_LP_theId_RP_ = 'repr(theId)'
repr_LP_val_RP_ = 'repr(val)'
requestedType = 'requestedType'
root_DOT_headString_PARENS_ = 'root.headString()'
rp = 'rp'
s = 's'
s_DOT_strip_PARENS_ = 's.strip()'
s1 = 's1'
s2 = 's2'
s3 = 's3'
section_DOT_name = 'section.name'
self_DOT_currentWord = 'self.currentWord'
self_DOT_fileName = 'self.fileName'
self_DOT_outputFileName = 'self.outputFileName'
self_DOT_print_mode = 'self.print_mode'
self_DOT_putCount = 'self.putCount'
self_DOT_shortFileName = 'self.shortFileName'
self_DOT_tabName = 'self.tabName'
self_DOT_targetFileName = 'self.targetFileName'
sep = 'sep'
setting = 'setting'
shortcut = 'shortcut'
signon = 'signon'
spaces = 'spaces'
sparseMove = 'sparseMove'
src = 'src'
start = 'start'
start_line = 'start_line'
str_LP_i_1_RP_ = 'str(i+1)'
str_LP_index_RP_ = 'str(index)'
str_LP_message_RP_ = 'str(message)'
str_LP_msg_RP_ = 'str(msg)'
str_LP_n_RP_ = 'str(n)'
str_LP_time_RP_ = 'str(time)'
stroke = 'stroke'
tag = 'tag'
tail_lines = 'tail_lines'
target = 'target'
theDir = 'theDir'
theFile = 'theFile'
time_DOT_clock_PARENS_ = 'time.clock()'
title = 'title'
torv = 'torv'
type_LP_index_RP_ = 'type(index)'
type_LP_s_RP_ = 'type(s)'
url = 'url'
v_DOT_headString_PARENS_ = 'v.headString()'
val = 'val'
value = 'value'
version = 'version'
vnodeName = 'vnodeName'
word = 'word'
z = 'z'
z_line = 'z_line'
z_opt = 'z_opt'
zipMark = 'zipMark'
g.app.translateToUpperCase=True
# ---- @thin leo.py 
g.es_print('','-------------------- @thin leo.py ',color='red')
# -- node run
g.es("disabling save commands",color="red")
# -- node createFrame (leo.py)
g.es("file not found:",fileName)
# -- node getBatchScript
g.es_print("can not open script file:",name, color="red")
# -- node reportDirectories
g.es("%s dir:" % (kind),theDir,color="blue")
# -- node startPsyco
g.es("psyco now logging to:",theFile,color="blue")
g.es("psyco now running",color="blue")
# ---- @thin leoApp.py
g.es_print('','-------------------- @thin leoApp.py',color='red')
# -- node < < return if we can set leoID from sys.leoID> >
# g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
g.es_print("leoID=",g_DOT_app_DOT_leoID,spaces=False,color='red')
# -- node < < return if we can set leoID from "leoID.txt" > >
# g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('leoID=',g_DOT_app_DOT_leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
g.es_print('unexpected exception in app.setLeoID',color='red')
# -- node < < return if we can set leoID from os.getenv('USER') > >
# g.es("using os.getenv('USER'):",repr(theId),color='red')
g.es("using os.getenv('USER'):",repr_LP_theId_RP_,color='red')
# -- node < < put up a dialog requiring a valid id > >
# g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
g.es('leoID=',repr_LP_g_DOT_app_DOT_leoID_RP_,spaces=False,color="blue")
# -- node < < attempt to create leoID.txt > >
g.es_print('',tag,'created in',theDir,color='red')
g.es('can not create',tag,'in',theDir,color='red')
# -- node app.writeWaitingLog
g.es('',s,color=color,newline=0)
# ---- @thin leoAtFile.py
g.es_print('','-------------------- @thin leoAtFile.py',color='red')
# -- node checkDerivedFile (atFile)
g.es_print('check-derived-file passed',color='blue')
# -- node < < warn on read-only file > >
g.es("read only:",fn,color="red")
# -- node read
# g.es("reading:",root.headString())
g.es("reading:",root_DOT_headString_PARENS_)
# -- node < < advise user to delete all unvisited nodes > >
# g.es('resurrected node:',p.headString(),color='blue')
g.es('resurrected node:',p_DOT_headString_PARENS_,color='blue')
g.es('in file:',fileName,color='blue')
g.es('you may want to delete ressurected nodes')
# -- node readAll (atFile)
g.es("no @file nodes in the selected tree")
# -- node readOneAtAutoNode (atFile)
# g.es("reading:",p.headString())
g.es("reading:",p_DOT_headString_PARENS_)
g.es_print('errors inhibited read @auto',fileName,color='red')
# -- node createNthChild3
g.es("dummy created")
# -- node handleLinesFollowingSentinel
g.es("using",s)
# g.es('',len(lines), "lines",m)
g.es('',len_LP_lines_RP_, "lines",m)
# -- node findChild4
g.es("write the @file node or use the Import Derived File command")
# -- node < < indicate that the node has been changed > >
# g.es("warning: updating changed text in",at.root.headString(),color="blue")
g.es("warning: updating changed text in",at_DOT_root_DOT_headString_PARENS_,color="blue")
# -- node < < bump at.correctedLines and tell about the correction > >
# g.es("correcting hidden node: t=",repr(at.t),color="red")
g.es("correcting hidden node: t=",repr_LP_at_DOT_t_RP_,color="red")
# -- node ignoreOldSentinel
g.es("ignoring 3.x sentinel:",s.strip(),color="blue")
# -- node < < handle @language > >
g.es("ignoring bad @language sentinel:",line,color="red")
# -- node < < handle @comment > >
g.es("ignoring bad @comment sentinel:",line,color="red")
# -- node copyAllTempBodyStringsToTnodes
# g.es("changed:",p.headString(),color="blue")
g.es("changed:",p_DOT_headString_PARENS_,color="blue")
# -- node < < read optional encoding param > >
g.es_print("bad encoding in derived file:",encoding)
# -- node < < set dirty and orphan bits on error > >
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# -- node < < say the command is finished > >
g.es("finished")
g.es("no @file nodes in the selected tree")
g.es("no dirty @file nodes")
# -- node writeAtAutoNodesHelper
g.es("finished")
g.es("no dirty @auto nodes in the selected tree")
g.es("no @auto nodes in the selected tree")
# -- node writeOneAtAutoNode & helpers
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# -- node shouldWriteAtAutoNode
# g.es_print(p.headString(),'not written:',color='red')
g.es_print(p_DOT_headString_PARENS_,'not written:',color='red')
g.es_print('no children and less than 10 characters (excluding directives)',color='red')
# -- node writeMissing
g.es("finished")
g.es("no @file node in the selected tree")
# -- node hasSectionName
g.es('dubious brackets in',line)
# -- node < < handle @language > >
g.es("ignoring bad @language directive:",line,color="blue")
# -- node < < handle @comment > >
g.es("ignoring bad @comment directive:",line,color="blue")
# -- node replaceTargetFileIfDifferent
# g.es('unchanged:',self.shortFileName)
g.es('unchanged:',self_DOT_shortFileName)
# g.es('wrote:    ',self.shortFileName)
g.es('wrote:    ',self_DOT_shortFileName)
# g.es('created:  ',self.targetFileName)
g.es('created:  ',self_DOT_targetFileName)
# -- node < < report if the files differ only in line endings > >
# g.es("correcting line endings in:",self.targetFileName,color="blue")
g.es("correcting line endings in:",self_DOT_targetFileName,color="blue")
# -- node warnAboutOrpanAndIgnoredNodes
# g.es("parent node:",p.parent().headString(),color="blue")
g.es("parent node:",p_DOT_parent_PARENS__DOT_headString_PARENS_,color="blue")
# -- node writeException
# g.es("exception writing:",self.targetFileName,color="red")
g.es("exception writing:",self_DOT_targetFileName,color="red")
# g.es("exception deleting:",self.outputFileName,color="red")
g.es("exception deleting:",self_DOT_outputFileName,color="red")
# -- node < < Test for @header and @noheader > >
g.es("conflicting @header and @noheader directives")
# -- node < < Set comment strings from delims > >
g.es("unknown language: using Python comment delimiters")
# g.es("c.target_language:",c.target_language)
g.es("c_DOT_target_language:",c_DOT_target_language)
g.es('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
# ---- @thin leoBridge.py
g.es_print('','-------------------- @thin leoBridge.py',color='red')
# -- node < < try to get leoID from sys.leoID> >
# g.es("leoID=",g.app.leoID,spaces=False,color='red')
g.es("leoID=",g_DOT_app_DOT_leoID,spaces=False,color='red')
# -- node < < try to get leoID from "leoID.txt" > >
# g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('leoID=',g_DOT_app_DOT_leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
g.es('unexpected exception in app.setLeoID',color='red')
# -- node < < try to get leoID from os.getenv('USER') > >
# g.es_print("using os.getenv('USER'):",repr(theId),color='red')
g.es_print("using os.getenv('USER'):",repr_LP_theId_RP_,color='red')
# -- node reportDirectories
g.es('',kind,'directory','',':',theDir,color='blue')
# -- node createFrame (leoBridge)
g.es('file not found', fileName,'creating new window')
# ---- @thin leoChapters.py
g.es_print('','-------------------- @thin leoChapters.py',color='red')
# -- node cc.createChapterByName
g.es('created chapter',name,color='blue')
# -- node cc.error
g.es_print(s,color='red')
# ---- @thin leoColor.py
g.es_print('','-------------------- @thin leoColor.py',color='red')
# ---- @thin leoCommands.py
g.es_print('','-------------------- @thin leoCommands.py',color='red')
# -- node doCommand
# g.es(c.disableCommandsMessage,color='blue')
g.es(c_DOT_disableCommandsMessage,color='blue')
g.es('ignoring command: already executing a command.',color='red')
g.es("exception executing command")
# -- node c.signOnWithVersion
g.es("Leo Log Window...",color=color)
g.es(signon)
# g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g_DOT_app_DOT_gui_DOT_getFullVersion_LP_c_RP_,version))
# -- node openWith and allies
g.es("unexpected exception in c.openWith")
# -- node < < create or recreate temp file as needed > >
# g.es("reopening:",g.shortFileName(path),color="blue")
g.es("reopening:",g_DOT_shortFileName_LP_path_RP_,color="blue")
# -- node < < execute a command to open path in external editor > >
g.es("exception executing:",command)
# -- node createOpenWithTempFile
# g.es("recreating:  ",g.shortFileName(path),color="red")
g.es("recreating:  ",g_DOT_shortFileName_LP_path_RP_,color="red")
# g.es("creating:  ",g.shortFileName(path),color="blue")
g.es("creating:  ",g_DOT_shortFileName_LP_path_RP_,color="blue")
# g.es("time: " + str(time))
g.es("time: " + str_LP_time_RP_)
g.es("exception creating temp file",color="red")
# -- node save (commands)
g.es("save commands disabled",color="purple")
# -- node saveAs
g.es("save commands disabled",color="purple")
# -- node saveTo
g.es("save commands disabled",color="purple")
# -- node readOutlineOnly
g.es("can not open:",fileName)
# -- node readFileIntoFile
g.es("can not open:",fileName)
# -- node writeFileFromNode
g.es_print('wrote:',fileName,color='blue')
g.es('can not write %s',fileName,color='red')
# -- node c.executeScript & helpers
g.es("end of script",color="purple",tabName=tabName)
g.es("no script selected",color="blue",tabName=tabName)
# -- node goToLineNumber & allies
# g.es("error handling:",root.headString())
g.es("error handling:",root_DOT_headString_PARENS_)
# -- node < < set root > >
g.es("no ancestor @file node: using script line numbers", color="blue")
# -- node < < read the file into lines > >
g.es("not found:",fileName)
# -- node < < 4.2: get node from gnx > >
g.es("not found:",vnodeName,color="red")
# -- node < < 4.x: scan for the node using tnodeList and n > >
# g.es_print("no child index for",root.headString(),color="red")
g.es_print("no child index for",root_DOT_headString_PARENS_,color="red")
# -- node < < set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false > >
g.es_print(s, color="red")
g.es_print(s, color="red")
g.es_print(s, color = "red")
# -- node < < set p to the first node whose headline matches vnodeName > >
g.es_print(s, color="red")
# -- node < < 3.x: scan for the node with the given childIndex > >
g.es("not found:",vnodeName, color="red")
# -- node < < put the cursor on line n2 of the body text > >
# g.es('only',len(lines),'lines',color="blue")
g.es('only',len_LP_lines_RP_,'lines',color="blue")
# -- node convertLineToVnodeNameIndexLine
g.es("bad @+leo sentinel")
# -- node < < handle delim while scanning backward > >
# g.es("line",str(n),"is a sentinel line")
g.es("line",str_LP_n_RP_,"is a sentinel line")
# -- node < < set vnodeName and (childIndex or gnx) from s > >
g.es("bad @+node sentinel")
# -- node convertAllBlanks
g.es("blanks converted to tabs in",count,"nodes")
# -- node convertAllTabs
g.es("tabs converted to blanks in",count,"nodes")
# -- node extract (test)
g.es("nothing follows section name",color="blue")
# -- node extractSection
g.es("nothing follows section name",color="blue")
# -- node < < Set headline for extractSection > >
g.es("selected text should start with a section name",color="blue")
# -- node extractSectionNames
g.es("selected text should contain one or more section names",color="blue")
# -- node < < trace head_lines, ins, tail_lines > >
g.es_print("head_lines: ",head_lines)
g.es_print("ins: ",ins)
g.es_print("tail_lines: ",tail_lines)
# -- node c.findMatchingBracket, helper and test
# g.es("unmatched",repr(ch))
g.es("unmatched",repr_LP_ch_RP_)
# -- node getTime
g.es("time.strftime not available on this platform",color="blue")
# -- node addComments (test)
g.es('no text selected',color='blue')
# -- node deleteComments (test)
g.es('no text selected',color='blue')
g.es('',"'%s'" % (d2),"not found",color='blue')
g.es('',"'%s'" % (d3),"not found",color='blue')
# -- node showFindPanel
# g.es('the',g.app.gui.guiName(),
#             'gui does not support a stand-alone find dialog',color='blue')
g.es('the',g_DOT_app_DOT_gui_DOT_guiName_PARENS_,
            'gui does not support a stand-alone find dialog',color='blue')
# -- node notValidInBatchMode
g.es('the',commandName,"command is not valid in batch mode")
# -- node c.checkOutline
g.es("all tests enabled: this may take awhile",color="blue")
# -- node < < remove unused tnodeList > >
g.es_print(s,color="blue")
# -- node < < do full tests > >
g.es('','.',newline=False)
# -- node < < give test failed message > >
g.es_print(s,color="red")
# -- node < <print summary message > >
g.es_print('',count,'nodes checked',errors,'errors',color=color)
# -- node checkAllPythonCode
g.es("check complete",color="blue")
# -- node < < print dots > >
g.es('','.',newline=False)
# -- node checkPythonCode
g.es("checking Python code   ")
g.es("surprise in checkPythonNode")
g.es("check complete",color="blue")
# -- node < < print dots > >
g.es('','.',newline=False)
# -- node checkPythonNode
g.es_print(s,color="blue")
# -- node tabNannyNode
g.es("ParserError in",headline,color="blue")
# g.es('',str(msg))
g.es('',str_LP_msg_RP_)
g.es("TokenError in",headline,color="blue")
# g.es('',str(msg))
g.es('',str_LP_msg_RP_)
g.es("indentation error in",headline,"line",badline,color="blue")
g.es(message)
g.es("offending line:\n",line2)
# -- node prettyPrintNode
g.es("error pretty-printing",h,"not changed.",color="blue")
# -- node markChangedHeadlines
g.es("done",color="blue")
# -- node markChangedRoots
g.es("done",color="blue")
# -- node markClones
g.es('the current node is not a clone',color='blue')
# -- node cantMoveMessage
g.es("can't move node out of",kind,color="blue")
# -- node c.toggleSparseMove
g.es(tag,'=',sparseMove,color='blue')
# -- node goToNextClone
# g.es('not a clone:',p.headString(),color='blue')
g.es('not a clone:',p_DOT_headString_PARENS_,color='blue')
g.es("done",color="blue")
# -- node findNextClone
g.es('no more clones',color='blue')
# -- node goToNextDirtyHeadline
g.es("done",color="blue")
# -- node goToNextMarkedHeadline
g.es("done",color="blue")
# -- node openCompareWindow
# g.es('the',g.app.gui.guiName(),
#             'gui does not support the compare window',color='blue')
g.es('the',g_DOT_app_DOT_gui_DOT_guiName_PARENS_,
            'gui does not support the compare window',color='blue')
# -- node openLeoSettings and openMyLeoSettings
g.es('',name,"not found in",configDir)
g.es('',name,"not found in",configDir,"or",homeDir)
# -- node openLeoScripts
g.es('not found:',fileName)
# -- node leoDocumentation
g.es("not found:",name)
# -- node leoHome
g.es("not found:",url)
# -- node leoPlugins
g.es("not found:",name)
# -- node leoTutorial (version number)
g.es("not found:",url)
# -- node leoUsersGuide
g.es("not found:",url)
# -- node initEncoding
g.es("bad", "%s: %s" % (encodingName,encoding))
# ---- @thin leoConfig.py
g.es_print('','-------------------- @thin leoConfig.py',color='red')
# -- node error
g.es(s,color="blue")
# -- node doIfGui
g.es_print(s,color='blue')
# -- node doMenus & helper
# g.es_print('creating menu from',c.shortFileName(),color='blue')
g.es_print('creating menu from',c_DOT_shortFileName_PARENS_,color='blue')
# -- node set (parseBaseClass)
g.es("over-riding setting:",name,"from",path)
# -- node traverse (parserBaseClass)
# g.es_print('skipping settings in',p.headString(),color='blue')
g.es_print('skipping settings in',p_DOT_headString_PARENS_,color='blue')
# -- node initEncoding
g.es("g.app.config: bad encoding:","%s: %s" % (ivar,encoding))
# -- node getValFromDict
# g.es_print('warning: ignoring',bunch.kind,'',setting,'is not',requestedType,color='red')
g.es_print('warning: ignoring',bunch_DOT_kind,'',setting,'is not',requestedType,color='red')
g.es_print('there may be conflicting settings!',color='red')
# -- node createRecentFiles
g.es_print('created',fileName,color='red')
g.es_print('can not create',fileName,color='red')
# -- node writeRecentFilesFileHelper
g.es('unexpected exception writing',fileName,color='red')
# -- node g.app.config.printSettings & helper
g.es('','%s %s = %s' % (letter,key,val))
# ---- @thin leoEditCommands.py
g.es_print('','-------------------- @thin leoEditCommands.py',color='red')
# -- node dynamicCompletion
g.es('command not ready yet',color='blue')
# -- node dynamicExpansion
g.es('command not ready yet',color='blue')
# -- node listAbbrevs
g.es('','%s=%s' % (z,s))
# -- node readAbbreviations
g.es('can not open',fileName)
# -- node writeAbbreviations
g.es('can not create',fileName)
# -- node listBuffers & listBuffersAlphabetically
g.es('buffers...')
g.es('',name)
g.es('buffers...')
g.es('',name)
# -- node debug & helper
g.es("info string")
# -- node findDebugger
g.es('debugger does not exist:',debugger,color='blue')
g.es('no debugger found.')
# -- node enable/disableGcTrace
g.es('enabled verbose gc stats',color='blue')
g.es('enabled brief gc stats',color='blue')
# -- node printFocus
# g.es_print('      hasFocusWidget:',c.widget_name(c.hasFocusWidget))
g.es_print('      hasFocusWidget:',c_DOT_widget_name_LP_c_DOT_hasFocusWidget_RP_)
# g.es_print('requestedFocusWidget:',c.widget_name(c.requestedFocusWidget))
g.es_print('requestedFocusWidget:',c_DOT_widget_name_LP_c_DOT_requestedFocusWidget_RP_)
# g.es_print('           get_focus:',c.widget_name(c.get_focus()))
g.es_print('           get_focus:',c_DOT_widget_name_LP_c_DOT_get_focus_PARENS__RP_)
# -- node appendImageDictToList
g.es('can not load image:',path)
# -- node getImage
g.es('can not import Image module from PIL',color='blue')
g.es('can not import ImageTk module',color='blue')
# -- node initBracketMatcher
g.es_print('bad open/close_flash_brackets setting: using defaults')
# -- node viewLossage
g.es('lossage...')
# g.es('',stroke or d.get(ch) or ch or 'None')
g.es('',stroke or d_DOT_get_LP_ch_RP_ or ch or 'None')
# -- node clear/set/ToggleExtendMode
# g.es('extend mode',g.choose(val,'on','off'),color='red')
g.es('extend mode',g_DOT_choose_LP_val_COMMA__SQ_on_SQ__COMMA__SQ_off_SQ__RP_,color='red')
# -- node swapWords
g.es('swap-words command not ready yet',color='blue')
# -- node getReadableTextFile
g.es('can not open',fileName)
# -- node saveFile
g.es('can not create',fileName)
# -- node helpForMinibuffer
g.es_print('',s)
# -- node helpForCommand
g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')
# -- node aproposAutocompletion
g.es_print('',s)
# -- node aproposBindings
g.es_print('',s)
# -- node aproposDebuggingCommands
g.es_print('',s)
# -- node aproposFindCommands
g.es_print('',s)
# -- node loadFile & helpers
g.es('can not open',fileName)
# -- node saveMacros & helper
g.es('can not create',fileName)
# -- node findNextMatch (query-replace)
g.es('command not ready yet',color='blue')
# -- node Find options wrappers
# g.es('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))
g.es('collapse_nodes_during_finds',c_DOT_config_DOT_getBool_LP__SQ_collapse_nodes_during_finds_SQ__RP_)
# -- node scolorizer LATER
g.es('command not ready yet',color='blue')
# -- node init_aspell
g.es_print('can not open dictionary file:',dictionaryFileName, color='red')
g.es_print('can not open Aspell',color='red')
# -- node readDictionary
g.es("can not open local dictionary",fileName,"using a blank one instead")
# -- node add
g.es("adding ", color= "blue", newline= False)
# g.es('','%s' % self.currentWord)
g.es('','%s' % self_DOT_currentWord)
# g.es("can not add",self.currentWord,"to dictionary",color="red")
g.es("can not add",self_DOT_currentWord,"to dictionary",color="red")
# -- node find & helpers
g.es("no more misspellings")
# -- node hide
g.es(message,color='blue')
# -- node ignore
g.es("ignoring ",color= "blue", newline= False)
# g.es('','%s' % self.currentWord)
g.es('','%s' % self_DOT_currentWord)
# -- node report
g.es_print(message,color='blue')
# ---- @thin leoFileCommands.py
g.es_print('','-------------------- @thin leoFileCommands.py',color='red')
# -- node processingInstruction (stylesheet)
g.es('','%s: %s' % (target,data),color='blue')
# -- node startVnodes
# g.es("reading:",self.fileName)
g.es("reading:",self_DOT_fileName)
# -- node checkLeoFile (fileCommands)
g.es_print('check-leo-file passed',color='blue')
# g.es_print('check-leo-file failed:',str(message),color='red')
g.es_print('check-leo-file failed:',str_LP_message_RP_,color='red')
# -- node getLeoOutlineFromClipboard & helpers
g.es("invalid Paste As Clone",color="blue")
g.es("the clipboard is not valid ",color="blue")
# -- node < < warn on read-only files > >
g.es("read only:",fileName,color="red")
# -- node newTnode
# g.es("bad tnode index:",str(index),"using empty text.")
g.es("bad tnode index:",str_LP_index_RP_,"using empty text.")
# g.es("newTnode: unexpected index type:",type(index),index,color="red")
g.es("newTnode: unexpected index type:",type_LP_index_RP_,index,color="red")
# -- node getAllLeoElements
g.es("reading:",fileName)
# -- node getPrefs
# g.es("default tangle directory not found:",c.tangle_directory)
g.es("default tangle directory not found:",c_DOT_tangle_directory)
# -- node getTnode
# g.es("no tnode with index:",str(index),"the text will be discarded")
g.es("no tnode with index:",str_LP_index_RP_,"the text will be discarded")
# -- node < < handle unknown attributes > >
g.es_print("unknown attributes for tnode",color = "blue")
# g.es_print('',"%s = %s" % (key,attrDict.get(key)))
g.es_print('',"%s = %s" % (key,attrDict_DOT_get_LP_key_RP_))
# -- node < < handle unknown vnode attributes > >
# g.es_print("unknown attributes for",v.headString(),color="blue")
g.es_print("unknown attributes for",v_DOT_headString_PARENS_,color="blue")
# g.es_print('',"%s = %s" % (key,attrDict.get(key)))
g.es_print('',"%s = %s" % (key,attrDict_DOT_get_LP_key_RP_))
# -- node getExistingVnode
g.es("missing vnode:",headline,color="red")
g.es("probably an outline topology error.")
# -- node getXmlVersionTag
g.es("invalid encoding in .leo file:",encoding,color="red")
# -- node getSaxUa
g.es_print('unexpected exception converting hexlified string to string')
# -- node parse_leo_file
g.es_print('error parsing',inputFileName,color='red')
g.es_print('unexpected exception parsing',inputFileName,color='red')
# -- node save (fileCommands)
g.es("clearing undo")
# -- node putSavedMessage
# g.es("saved:","%s%s" % (zipMark,g.shortFileName(fileName)))
g.es("saved:","%s%s" % (zipMark,g_DOT_shortFileName_LP_fileName_RP_))
# -- node deleteFileWithMessage
g.es("read only",color="red")
g.es("exception deleting backup file:",fileName)
# -- node putUnknownAttributes & helper
g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
# -- node putUaHelper
g.es("ignoring non-string attribute",key,"in",torv,color="blue")
g.es('putUaHelper: unexpected pickling exception',color='red')
g.es("ignoring non-pickleable attribute",key,"in",torv,color="blue")
# -- node < < Append tnodeList and unKnownAttributes to attrs> >
# g.es("deleting tnode list for",p.headString(),color="blue")
g.es("deleting tnode list for",p_DOT_headString_PARENS_,color="blue")
# -- node < < issue informational messages > >
# g.es("writing erroneous:",p.headString(),color="blue")
g.es("writing erroneous:",p_DOT_headString_PARENS_,color="blue")
# -- node putDescendentUnknownAttributes
g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
g.es("ignoring bad unknownAttributes key",key,"in",p,color="blue")
g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
g.es("putDescendentUnknownAttributes can't happen 2",color='red')
# -- node write_Leo_file
# g.es_print('len',len(s),'putCount',self.putCount)
g.es_print('len',len_LP_s_RP_,'putCount',self_DOT_putCount)
g.es("exception writing:",fileName)
# -- node < < return if the .leo file is read-only > >
g.es("can not create: read only:",fileName,color="red")
# -- node < < create backup file > >
g.es("read only",color="red")
# -- node < < rename backupName to fileName > >
g.es("restoring",fileName,"from",backupName)
# -- node writeAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeDirtyAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeMissingAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeOutlineOnly
g.es('done',color='blue')
# ---- @thin leoGlobals.py
g.es_print('','-------------------- @thin leoGlobals.py',color='red')
# -- node computeLoadDir
g.es("load dir:",loadDir,color="blue")
# -- node set_language
# g.es("ignoring:",g.get_line(s,i))
g.es("ignoring:",g_DOT_get_line_LP_s_COMMA_i_RP_)
# -- node < < set theDict for @ directives > >
g.es("warning: conflicting values for",word,color="blue")
# -- node < < set theDict["root"] for noweb * chunks > >
# g.es('',g.angleBrackets("*") + "= requires @root in the headline")
g.es('',g_DOT_angleBrackets_LP__DQ___DQ__RP_ + "= requires @root in the headline")
# -- node g.scanAtEncodingDirective
g.es("invalid @encoding:",encoding,color="red")
# -- node g.scanAtLineendingDirective
g.es("invalid @lineending directive:",e,color="red")
# -- node g.scanAtPagewidthDirective
g.es("ignoring",s,color="red")
# -- node < < scan another @root option > >
# g.es("modes conflict in:",g.get_line(s,i))
g.es("modes conflict in:",g_DOT_get_line_LP_s_COMMA_i_RP_)
# g.es("modes conflict in:",g.get_line(s,i))
g.es("modes conflict in:",g_DOT_get_line_LP_s_COMMA_i_RP_)
g.es("unknown option:",z_opt,"in",z_line)
# -- node g.scanAtTabwidthDirective
g.es("ignoring",s,color="red")
# -- node alert
g.es('',message)
# -- node es_dump
g.es_print('',title)
g.es_print('',aList)
# -- node es_error
g.es(s,color=color)
# -- node es_event_exception
g.es("exception handling ",eventName,"event")
g.es('',i)
# -- node es_exception_type
# g.es_print('','%s, %s' % (exctype.__name__, value),color=color)
g.es_print('','%s, %s' % (exctype_DOT___name__, value),color=color)
# -- node getLastTracebackFileAndLineNumber
# g.es_print('',repr(val))
g.es_print('',repr_LP_val_RP_)
# g.es_print('',repr(data))
g.es_print('',repr_LP_data_RP_)
# -- node Timing
# g.es('',"%s %6.3f" % (message,(time.clock()-start)))
###g.es('',"%s %6.3f" % (message,(time_DOT_clock_PARENS_-start)))
# -- node g.create_temp_file
###g.es('unexpected exception in g.create_temp_file',color='red')
# -- node g.is_sentinel
g.es("can't happen: is_sentinel",color="red")
# -- node g.makeAllNonExistentDirectories
g.es("created directory:",path)
g.es("exception creating directory:",path)
# -- node g.openLeoOrZipFile
g.es("can not open:",fileName,color="blue")
# -- node g.setGlobalOpenDir
# g.es('current directory:',g.app.globalOpenDir)
g.es('current directory:',g_DOT_app_DOT_globalOpenDir)
# -- node g.update_file_if_changed
g.es('','%12s: %s' % (kind,file_name))
g.es("rename failed: no file created!",color="red")
g.es('',file_name," may be read-only or in use")
# -- node g.utils_remove
g.es("exception removing:",fileName)
# -- node g.utils_rename
g.es('exception renaming',src,'to',dst,color='red')
# -- node g.utils_chmod
g.es("exception in os.chmod",fileName)
# -- node enable_gc_debug
g.es('can not import gc module',color='blue')
# -- node g.doHook
g.es_print(s,color="blue")
# -- node g.plugin_signon
# g.es('',"...%s.py v%s: %s" % (
#             m.__name__, m.__version__, g.plugin_date(m)))
g.es('',"...%s.py v%s: %s" % (
            m_DOT___name__, m_DOT___version__, g_DOT_plugin_date_LP_m_RP_))
# -- node mini test of es
g.es(s)
g.es_print(s)
# -- node es_print
# -- node @@test g.es_print
g.es_print('\ntest of es_print: ',color='red',newline=False)
g.es_print('after')
g.es_print('done')
# -- node es_trace
# -- node < < scan another @file option > >
g.es("using -asis option in:",h)
g.es("ignoring redundant -noref in:",h)
g.es("ignoring redundant -nosent in:",h)
g.es("using -thin option in:",h)
g.es("unknown option:",z_opt,"in",h)
# -- node scanError
g.es('',s)
# -- node skip_pp_if
g.es("#if and #else parts have different braces:",start_line)
g.es("no matching #endif:",start_line)
# -- node g.initScriptFind (set up dialog)
g.es("no Find script node",color="red")
# -- node g.handleScriptException
g.es("exception executing script",color='blue')
# -- node < < dump the lines near the error > >
g.es_print('',s)
g.es('',s,newline=False)
# -- node reportBadChars
g.es(s2,color='red')
g.es(s2,color='red')
# -- node g.executeScript
g.es("exception executing",name,color="red")
# -- node g.getScript
g.es_print("unexpected exception in g.getScript")
# -- node g.cantImport
g.es_print('',s,color="blue")
# -- node g.importFromPath
g.es_print("exception in g.importFromPath",color='blue')
g.es_print("unexpected exception in g.importFromPath(%s)" %
                    (name),color='blue')
# -- node g.init_zodb
g.es('g.init_zodb: can not import ZODB')
g.es('g.init_zodb: exception creating ZODB.DB instance')
# ---- @thin leoImport.py
g.es_print('','-------------------- @thin leoImport.py',color='red')
# -- node exportHeadlines
g.es("can not open",fileName,color="blue")
# -- node flattenOutline
g.es("can not open",fileName,color="blue")
# -- node outlineToWeb
g.es("can not open",fileName,color="blue")
# -- node < < Read file into s > >
g.es("can not open",fileName, color="blue")
# -- node < < set delims from the header line > >
g.es("invalid @+leo sentinel in",fileName)
# -- node < < Write s into newFileName > >
g.es("created:",newFileName)
g.es("exception creating:",newFileName)
# -- node < < open filename to f, or return > >
g.es("exception opening:",filename)
# -- node error
g.es('',s)
# -- node < < Read file into s > >
g.es("can not open", "%s%s" % (z,fileName),color='red')
# -- node readAtAutoNodes (importCommands) & helper
# g.es_print('ignoring',p.headString(),color='blue')
g.es_print('ignoring',p_DOT_headString_PARENS_,color='blue')
g.es(message,color='blue')
# -- node importFilesCommand
g.es("imported",fileName,color="blue")
# -- node importFlattenedOutline
g.es("not a valid MORE file",fileName)
# -- node < < Read the file into array > >
g.es("can not open",fileName, color="blue")
# -- node scanWebFile (handles limbo)
g.es("can not import",fileName, color="blue")
# -- node cstLookup
g.es('',"****** %s" % (target),"is also a prefix of",s)
g.es("replacing",target,"with",s)
# -- node scanPHPText
g.es_print('seems to be mixed HTML and PHP:',fileName)
# -- node compareHelper
# g.es_print('first mismatched line at line',str(i+1))
g.es_print('first mismatched line at line',str_LP_i_1_RP_)
g.es_print('original line: ',line1)
g.es_print('generated line:',line2)
g.es_print('missing lines')
# g.es_print('',repr(line))
g.es_print('',repr_LP_line_RP_)
# -- node checkLeadingWhitespace
# g.es_print('line:',repr(line),color='red')
g.es_print('line:',repr_LP_line_RP_,color='red')
# -- node reportMismatch
# -- node insertIgnoreDirective
g.es_print('inserting @ignore',color='blue')
# -- node error, oops, report and warning
g.es_print('',s,color='red')
g.es_print('error:',s,color='red')
g.es_print('warning:',s,color='red')
# ---- @thin leoKeys.py
g.es_print('','-------------------- @thin leoKeys.py',color='red')
# -- node showAutocompleter/CalltipsStatus
g.es(s,color='red')
g.es(s,color='red')
# -- node computeCompletionList
# g.es('',z,tabName=self.tabName)
g.es('',z,tabName=self_DOT_tabName)
# -- node info
g.es('no docstring for',word,color='blue')
g.es('',doc,tabName='Info')
g.es('no docstring for',word,color='blue')
# -- node scan
g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
# -- node scanOutline
g.es_print('scanning for auto-completer...')
g.es('','.',newline=False)
g.es_print('\nauto-completer scan complete',color='blue')
# -- node createClassObjectFromString
g.es_print('unexpected exception in',computeProxyObject)
# -- node forgivingParser
g.es_print('syntax error in class node: can not continue')
# g.es_print('syntax error: deleting',p.headString())
g.es_print('syntax error: deleting',p_DOT_headString_PARENS_)
# -- node bindKey
g.es_print('exception binding',shortcut,'to',commandName)
# -- node < < give warning and return if we try to bind to Enter or Leave > >
g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
# -- node < < remove previous conflicting definitions from bunchList > >
# g.es_print('redefining',z,'in',b2.pane,'to',commandName,'in',pane,color='red')
g.es_print('redefining',z,'in',b2_DOT_pane,'to',commandName,'in',pane,color='red')
# -- node k.initAbbrev
g.es_print('bad abbrev:',key,'unknown command name:',commandName,color='blue')
# -- node k.makeMasterGuiBinding
# g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')
g.es_print('exception binding',bindStroke,'to',c_DOT_widget_name_LP_w_RP_,color='blue')
# -- node callStateFunction
# g.es_print('no state function for',k.state.kind,color='red')
g.es_print('no state function for',k_DOT_state_DOT_kind,color='red')
# -- node k.show/hide/toggleMinibuffer
g.es('minibuffer hidden',color='red')
g.es('',commandName,'is bound to:',shortcut)
# -- node printBindings & helper
g.es('no bindings')
g.es('','%s %s' % (sep, prefix),tabName=tabName)
g.es('','%s %s' % (sep, 'Plain Keys',),tabName=tabName)
# -- node printBindingsHelper
# g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
# g.es('','%*s %*s %s' % (-n1,s1,-(min_LP_12_COMMA_n2_RP_),s2,s3),tabName='Bindings')
# -- node printCommands
# g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
# g.es('','%*s %*s %s' % (-n1,s1,-(min_LP_12_COMMA_n2_RP_),s2,s3),tabName=tabName)
# -- node repeatComplexCommand & helper
g.es('no previous command',color='blue')
# -- node k.registerCommand
g.es_print('redefining',commandName, color='red')
# g.es_print('','@command: %s = %s' % (
#                 commandName,k.prettyPrintKey(stroke)),color='blue')
g.es_print('','@command: %s = %s' % (
                commandName,k_DOT_prettyPrintKey_LP_stroke_RP_),color='blue')
g.es_print('','@command: %s' % (commandName),color='blue')
# -- node createModeBindings
g.es_print('no such command:',commandName,'Referenced from',modeName)
# -- node modeHelpHelper
g.es('','%s mode\n\n' % modeName,tabName=tabName)
###g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
# -- node k.computeCompletionList
# g.es('','%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3),tabName=tabName)
# g.es('','%*s %*s %s' % (-(min_LP_20_COMMA_n1_RP_),s1,n2,s2,s3),tabName=tabName)
# -- node k.showFileNameTabList
g.es('',s,tabName=tabName)
# ---- @thin leoNodes.py
g.es_print('','-------------------- @thin leoNodes.py',color='red')
# -- node v.bodyString
g.es_print('',s,color="red")
# -- node v.headString & v.cleanHeadString
g.es_print('',s,color="red")
# -- node scanGnx
# g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
g.es("scanGnx: unexpected index type:",type_LP_s_RP_,'',s,color="red")
# ---- @thin leoPlugins.py
g.es_print('','-------------------- @thin leoPlugins.py',color='red')
# -- node loadHandlers & helper
# -- node loadOnePlugin
g.es_print('plugin',moduleName,'already loaded',color="blue")
g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
g.es('exception loading plugin',color='red')
g.es_print('can not load enabled plugin:',moduleName,color="red")
g.es_print('loaded plugin:',moduleName,color="blue")
# -- node printHandlers
g.es_print('handlers for',moduleName,'...')
g.es_print('all plugin handlers...')
g.es_print('','%25s %s' % (tag,key))
# -- node printPlugins
g.es_print('enabled plugins...')
g.es_print('',key)
# -- node registerExclusiveHandler
g.es("*** Two exclusive handlers for","'%s'" % (tag))
# ---- @thin leoPymacs.py
g.es_print('','-------------------- @thin leoPymacs.py',color='red')
# -- node open
g.es_print('','leoPymacs.open:','no file name')
g.es_print('','leoPymacs.open:',c)
g.es_print('','leoPymacs.open:','can not open',fileName)
# ---- @thin leoTangle.py
g.es_print('','-------------------- @thin leoTangle.py',color='red')
# -- node < < call tangle_done.run() or untangle_done.run() > >
g.es("can not execute","tangle_done.run()")
g.es("can not execute","tangle_done.run()")
# -- node initTangleCommand
g.es("tangling...")
# -- node initUntangleCommand
g.es("untangling...")
# -- node tangle
g.es("looking for a parent to tangle...")
g.es("tangling parent")
g.es("tangle complete")
# -- node tangleAll
g.es("tangle complete")
# -- node tangleMarked
g.es("tangle complete")
# -- node untangle
g.es("untangle complete")
# -- node untangleAll
g.es("untangle complete")
# -- node untangleMarked
g.es("untangle complete")
# -- node untangleRoot (calls cleanup)
g.es('','@root ' + path)
# -- node < < return if @silent or unknown language > >
g.es("@comment disables untangle for",path, color="blue")
# g.es('','@%s' % (self.print_mode),"inhibits untangle for",path, color="blue")
g.es('','@%s' % (self_DOT_print_mode),"inhibits untangle for",path, color="blue")
# -- node < < Read the file into file_buf  > > in untangleRoot
g.es("error reading:",path)
# -- node tangle.put_all_roots
g.es("can not create temp file")
g.es("unchanged:",file_name)
# -- node st_check
# g.es('',' ' * 4,'warning:',lp,'',section.name,'',rp,'has been defined but not used.')
g.es('',' ' * 4,'warning:',lp,'',section_DOT_name,'',rp,'has been defined but not used.')
# -- node < <check for duplicate code definitions > >
g.es('warning: possible duplicate definition of:',s)
# -- node ust_warn_about_orphans
# g.es("warning:",'%s%s%s' % (lp,part.name,rp),"is not in the outline")
g.es("warning:",'%s%s%s' % (lp,part_DOT_name,rp),"is not in the outline")
# -- node update_def (pass 2)
# g.es("***Updating:",p.headString())
g.es("***Updating:",p_DOT_headString_PARENS_)
# -- node < < Test for @comment and @language > >
g.es("ignoring: @comment",z)
# -- node < < handle absolute @path > >
g.es("relative_path_base_directory:",base)
g.es("relative path in @path directive:",relative_path)
# -- node < < Test for @header and @noheader > >
g.es("conflicting @header and @noheader directives")
# -- node < < handle absolute path > >
g.es("relative_path_base_directory:",base)
g.es('',kind,"directory:",dir2)
# ---- @thin leoTest.py
g.es_print('','-------------------- @thin leoTest.py',color='red')
# -- node runTimerOnNode
# g.es_print("count:",count,"time/count:",ratio,'',p.headString())
g.es_print("count:",count,"time/count:",ratio,'',p_DOT_headString_PARENS_)
# -- node runTests
g.es('running',kind,'unit tests',color='blue')
g.es_print('no @test or @suite nodes in selected outline')
# -- node checkFileSyntax
g.es("syntax error in:",fileName,color="blue")
# -- node checkFileTabs
g.es_print("Token error in",fileName,color="blue")
g.es_print('',msg)
g.es_print("Indentation error in",fileName,"line",badline,color="blue")
g.es_print('',message)
g.es_print("offending line...")
g.es_print('',line)
# -- node importAllModulesInPath
g.es("path does not exist:",path)
# ---- @thin leoUndo.py
g.es_print('','-------------------- @thin leoUndo.py',color='red')
# -- node < < set newBead if we can't share the previous bead > >
g.es('exception in','setUndoRedoTypingParams',color='blue')
# -- node redoGroup
g.es("redo",count,"instances")
# -- node undoGroup
g.es("undo",count,"instances")
g.app.translateToUpperCase=False
#@nonl
#@-node:ekr.20080220082727:@scan_g.es_results
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = not g.app.unitTesting
    << return if we can set leoID from sys.leoID >>
    << return if we can set leoID from "leoID.txt" >>
    << return if we can set leoID from os.getenv('USER') >>
    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@+node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose and not g.app.unitTesting:
        g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
    # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
    g.app.leoID = g.app.leoID.replace('.','-')
    return
else:
    g.app.leoID = None
#@-node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose and not g.app.unitTesting:
            g.es("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId
        # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
        g.app.leoID = g.app.leoID.replace('.','-')
        return

except Exception:
    pass
#@-node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
g.app.leoID = g.app.leoID.replace('.','-')

# g.trace(g.app.leoID)
g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@+node:ekr.20070426092031:Consider another way to compute home directory
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4281562
By: ktenney

I don't know if this is a resolved issue, here's another approach,
looks like a good one.

email link
http://murl.se/24201

python.org os.path doc
http://murl.se/24202

>>> import os
>>> lin_key, win_key = "home", "Documents"
>>> homedir = os.path.expanduser('~')
>>> if os.name == 'nt': os_key = win_key
>>> if os.name == 'posix': os_key = lin_key
>>> print homedir.find(os_key) > -1
True

#@-node:ekr.20070426092031:Consider another way to compute home directory
#@+node:ekr.20070227094232:getLeoID
def getLeoID (self):

    import os
    import sys

    g = self.g ; tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = False and not g.app.unitTesting
    << try to get leoID from sys.leoID >>
    if not g.app.leoID:
        << try to get leoID from "leoID.txt" >>
    if not g.app.leoID:
        << try to get leoID from os.getenv('USER') >>
    return g.app.leoID
#@+node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es("leoID=",g.app.leoID,spaces=False,color='red')
#@nonl
#@-node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
#@+node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                if verbose:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                break
            elif verbose:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
#@+node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId

except Exception:
    pass
#@-node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
#@-node:ekr.20070227094232:getLeoID
#@+node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es('',name,"not found in",configDir)
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('',name,"not found in",configDir,"or",homeDir)
#@-node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():

    """Returns the user's home directory."""

    import leo.core.leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@-node:ekr.20041117151301:computeHomeDir
#@-node:ekr.20080407090400.4:Found: homeDir
#@-node:ekr.20080407090400.3:Added install nodes re Leo's home directory
#@+node:ekr.20080318081653.1:Added support for @bool fixedWindow option
@nocolor

We should avoid conflicts here in the first place. We really need that
'toggle-fixed' thing (that would prevent writing window positions and node
expansion statuses to .leo file) I suggested a while back, to make collaboration
with .leo files possible...

@color
#@nonl
#@+node:ekr.20080412053100.3:Documentation
@nocolor

Leo suppresses marks, expansion state, orphan bits and current
position bits when writing fixed .leo files.  As a result, all nodes
will be collapsed and the root node will always be selected when Leo
opens a fixed .leo file.

When writing fixed .leo files, Leo writes fixed, immutable, reasonable
defaults for window size, position and body-outline ratio.
Specifically, width,height,left,top = 700,500,50,50 and the ratio is
0.5. These values are written so older versions of Leo can read fixed
files.

You make a file fixed by putting '@bool fixedWindow = True' in the
@settings tree of a particular .leo file.  The file will be fixed
after you save the file, reload the file, and save the file again.
Yes, this is clumsy, but it only has to be done once.  A toggle-fixed
file command doesn't seem that useful: using an @bool node is simple
and clear.

You can optionally specify the size and position on the screen of
fixed .leo files by putting an '@data fixedWindowPosition' node in the
@settings tree of myLeoSettings.leo or leoSettings.leo.  You should
**not** put such a node in the fixed .leo file itself--everyone who
opens the file would get that fixed position.

The body of the '@data fixedWindowPosition' node should contain
something like this:

# Must be four entries: width,height,left,top.
# Put this in myLeoSettings.leo, **not** in individual .leo files.

1200
800
50
50

Leo uses reasonable defaults for fixed .leo files if this node does
not exist, or contains something other than 4 numbers, one per line. 
#@nonl
#@-node:ekr.20080412053100.3:Documentation
#@+node:ekr.20060919145406:<< define sax classes >>
@others
#@nonl
#@+node:ekr.20060919110638.19:class saxContentHandler (XMLGenerator)
class saxContentHandler (xml.sax.saxutils.XMLGenerator):

    '''A sax content handler class that reads Leo files.'''

    @others
#@nonl
#@+node:ekr.20060919110638.20: __init__ & helpers
def __init__ (self,c,fileName,silent,inClipboard):

    self.c = c
    self.fileName = fileName
    self.silent = silent
    self.inClipboard = inClipboard

    # Init the base class.
    xml.sax.saxutils.XMLGenerator.__init__(self)

    << define dispatch dict >>

    self.printElements = [] # 'all', 'v'

    # Global attributes of the .leo file...
    # self.body_outline_ratio = '0.5'
    self.global_window_position = {}
    self.encoding = 'utf-8' 

    # Semantics...
    self.content = None
    self.elementStack = []
    self.errors = 0
    self.tnxToListDict = {} # Keys are tnx's (strings), values are *lists* of saxNodeClass objects.
    self.level = 0
    self.node = None
    self.nodeList = [] # List of saxNodeClass objects with the present tnode.
    self.nodeStack = []
    self.rootNode = None # a sax node.
#@nonl
#@+node:ekr.20060919110638.21:<< define dispatch dict >>
# There is no need for an 'end' method if all info is carried in attributes.

self.dispatchDict = {
    'change_string':               (None,None),
    'find_panel_settings':         (None,None),
    'find_string':                 (None,None),
    'globals':                     (self.startGlobals,None),
    'global_log_window_position':  (None,None), # The position of the log window is no longer used.
    'global_window_position':      (self.startWinPos,None),
    'leo_file':                    (None,None),
    'leo_header':                  (self.startLeoHeader,None),
    'preferences':                 (None,None),
    't':                           (self.startTnode,self.endTnode),
    'tnodes':                      (None,None),
    'v':                           (self.startVnode,self.endVnode),
    'vh':                          (self.startVH,self.endVH),
    'vnodes':                      (self.startVnodes,None), # Causes window to appear.
}
#@nonl
#@-node:ekr.20060919110638.21:<< define dispatch dict >>
#@-node:ekr.20060919110638.20: __init__ & helpers
#@+node:ekr.20060919110638.29: Do nothing
def endElementNS(self,unused_name,unused_qname):
    g.trace(unused_name)

def endDocument(self):
    pass

def ignorableWhitespace(self,unused_whitespace):
    pass

def skippedEntity(self,name):
    g.trace(name)

def startElementNS(self,unused_name,unused_qname,unused_attrs):
    g.trace(unused_name)

def startDocument(self):
    pass
#@nonl
#@-node:ekr.20060919110638.29: Do nothing
#@+node:ekr.20060919134313: Utils
#@+node:ekr.20060919110638.23:attrsToList
def attrsToList (self,attrs):

    '''Convert the attributes to a list of g.Bunches.

    attrs: an Attributes item passed to startElement.'''

    if 0: # check for non-unicode attributes.
        for name in attrs.getNames():
            val = attrs.getValue(name)
            if type(val) != type(u''):
                g.trace('Non-unicode attribute',name,val)

    # g.trace(g.listToString([repr(z) for z in attrs.getNames()]))

    return [
        g.Bunch(name=name,val=attrs.getValue(name))
            for name in attrs.getNames()]
#@nonl
#@-node:ekr.20060919110638.23:attrsToList
#@+node:ekr.20060919110638.26:error
def error (self, message):

    g.pr('\n\nXML error: %s\n' % (message))

    self.errors += 1
#@nonl
#@-node:ekr.20060919110638.26:error
#@+node:ekr.20060919110638.27:inElement
def inElement (self,name):

    return self.elementStack and name in self.elementStack
#@nonl
#@-node:ekr.20060919110638.27:inElement
#@+node:ekr.20060919110638.28:printStartElement
def printStartElement(self,name,attrs):

    indent = '\t' * self.level or ''

    if attrs.getLength() > 0:
        g.pr('%s<%s %s>' % (
            indent,
            self.clean(name).strip(),
            self.attrsToString(attrs,sep=' ')),
            newline=False)
    else:
        g.pr('%s<%s>' % (
            indent,
            self.clean(name).strip()),
            newline=False)

    if name.lower() in ['v','t','vnodes','tnodes',]:
        g.pr('')
#@nonl
#@+node:ekr.20060919110638.24:attrsToString
def attrsToString (self,attrs,sep='\n'):

    '''Convert the attributes to a string.

    attrs: an Attributes item passed to startElement.

    sep: the separator charater between attributes.'''

    result = [
        '%s="%s"' % (bunch.name,bunch.val)
        for bunch in self.attrsToList(attrs)
    ]

    return sep.join(result)
#@nonl
#@-node:ekr.20060919110638.24:attrsToString
#@+node:ekr.20060919110638.25:clean
def clean(self,s):

    return g.toEncodedString(s,"ascii")
#@nonl
#@-node:ekr.20060919110638.25:clean
#@-node:ekr.20060919110638.28:printStartElement
#@-node:ekr.20060919134313: Utils
#@+node:ekr.20060919110638.30:characters
def characters(self,content):

    if content and type(content) != type(u''):
        g.trace('Non-unicode content',repr(content))

    content = content.replace('\r','')
    if not content: return

    elementName = self.elementStack and self.elementStack[-1].lower() or '<no element name>'

    if elementName in ('t','vh'):
        # if elementName == 'vh': g.trace(elementName,repr(content))
        self.content.append(content)

    elif content.strip():
        g.pr('unexpected content:',elementName,repr(content))
#@nonl
#@-node:ekr.20060919110638.30:characters
#@+node:ekr.20060919110638.31:endElement & helpers
def endElement(self,name):

    name = name.lower()

    if name in self.printElements or 'all' in self.printElements:
        indent = '\t' * (self.level-1) or ''
        g.pr('%s</%s>' % (indent,self.clean(name).strip()))

    data = self.dispatchDict.get(name)

    if data is None:
        if 1: g.trace('unknown end element',name)
    else:
        junk,func = data
        if func:
            func()

    name2 = self.elementStack.pop()
    assert name == name2
#@nonl
#@+node:ekr.20060919110638.32:endTnode
def endTnode (self):

    for sax_node in self.nodeList:
        sax_node.bodyString = ''.join(self.content)

    self.content = []
#@nonl
#@-node:ekr.20060919110638.32:endTnode
#@+node:ekr.20060919110638.33:endVnode
def endVnode (self):

    self.level -= 1
    self.node = self.nodeStack.pop()
#@nonl
#@-node:ekr.20060919110638.33:endVnode
#@+node:ekr.20060919110638.34:endVH
def endVH (self):

    if self.node:
        self.node.headString = ''.join(self.content)

    self.content = []
#@nonl
#@-node:ekr.20060919110638.34:endVH
#@-node:ekr.20060919110638.31:endElement & helpers
#@+node:ekr.20060919110638.45:getRootNode
def getRootNode (self):
    return self.rootNode
#@-node:ekr.20060919110638.45:getRootNode
#@+node:ekr.20061004054323:processingInstruction (stylesheet)
def processingInstruction (self,target,data):

    if target == 'xml-stylesheet':
        self.c.frame.stylesheet = data
        if False and not self.silent:
            g.es('','%s: %s' % (target,data),color='blue')
    else:
        g.trace(target,data)
#@nonl
#@-node:ekr.20061004054323:processingInstruction (stylesheet)
#@+node:ekr.20060919110638.35:startElement & helpers
def startElement(self,name,attrs):

    name = name.lower()

    if name in self.printElements or 'all' in self.printElements:
        self.printStartElement(name,attrs)

    self.elementStack.append(name)

    data = self.dispatchDict.get(name)

    if data is None:
        if 1: g.trace('unknown start element',name)
    else:
        func,junk = data
        if func:
            func(attrs)
#@nonl
#@+node:ekr.20060919110638.36:getPositionAttributes
def getPositionAttributes (self,attrs):

    c = self.c

    if c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}
    else:
        d = {}
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    return d
#@-node:ekr.20060919110638.36:getPositionAttributes
#@+node:ekr.20060919110638.37:startGlobals
def startGlobals (self,attrs):

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val

        if name == 'body_outline_ratio':
            # self.body_outline_ratio = val
            if not self.inClipboard:
                self.c.ratio = val
            # g.trace(name,val)
        elif 0:
            g.trace(name,len(val))
#@nonl
#@-node:ekr.20060919110638.37:startGlobals
#@+node:ekr.20060919110638.38:startWinPos
def startWinPos (self,attrs):

    self.global_window_position = self.getPositionAttributes(attrs)
#@nonl
#@-node:ekr.20060919110638.38:startWinPos
#@+node:ekr.20060919110638.39:startLeoHeader
def startLeoHeader (self,unused_attrs):

    self.tnxToListDict = {}
#@-node:ekr.20060919110638.39:startLeoHeader
#@+node:ekr.20060919110638.40:startVH
def startVH (self,unused_attrs):

    self.content = []
#@nonl
#@-node:ekr.20060919110638.40:startVH
#@+node:ekr.20060919112118:startVnodes
def startVnodes (self,unused_attrs):

    # __pychecker__ = '--no-argsused'

    if self.inClipboard:
        return # No need to do anything to the main window.

    c = self.c ; d = self.global_window_position

    w = d.get('width',700)
    h = d.get('height',500)
    x = d.get('left',50)
    y = d.get('top',50)
    # g.trace(d,w,h,x,y)

    # Redraw the window before writing into it.
    c.frame.setTopGeometry(w,h,x,y)
    c.frame.deiconify()
    c.frame.lift()
    c.frame.update()

    # Causes window to appear.
    # g.trace('ratio',c.frame.ratio,c.frame.secondary_ratio)
    c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
    if not self.silent and not g.unitTesting:
        g.es("reading:",self.fileName)
#@-node:ekr.20060919112118:startVnodes
#@+node:ekr.20060919110638.41:startTnode
def startTnode (self,attrs):

    if not self.inElement('tnodes'):
        self.error('<t> outside <tnodes>')

    self.content = []

    self.tnodeAttributes(attrs)
#@nonl
#@+node:ekr.20060919110638.42:tnodeAttributes
def tnodeAttributes (self,attrs):

    # The tnode must have a tx attribute to associate content with the proper node.

    node = self.node
    self.nodeList = []

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name == 'tx':
            self.nodeList = self.tnxToListDict.get(val,[])
            if not self.nodeList:
                self.error('Bad leo file: no node for <t tx=%s>' % (val))
        else:
            node.tnodeAttributes[name] = val

    if not self.nodeList:
        self.error('Bad leo file: no tx attribute for tnode')
#@nonl
#@-node:ekr.20060919110638.42:tnodeAttributes
#@-node:ekr.20060919110638.41:startTnode
#@+node:ekr.20060919110638.43:startVnode
def startVnode (self,attrs):

    if not self.inElement('vnodes'):
        self.error('<v> outside <vnodes>')

    if self.rootNode:
        parent = self.node
    else:
        self.rootNode = parent = saxNodeClass() # The dummy parent node.
        parent.headString = 'dummyNode'

    self.node = saxNodeClass()

    parent.children.append(self.node)
    self.vnodeAttributes(attrs)
    self.nodeStack.append(parent)

    return parent
#@nonl
#@+node:ekr.20060919110638.44:vnodeAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def vnodeAttributes (self,attrs):

    node = self.node

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name == 't':
            aList = self.tnxToListDict.get(val,[])
            aList.append(self.node)
            self.tnxToListDict[val] = aList
            node.tnx = str(val) # nodeIndices.toString returns a string.
        else:
            node.attributes[name] = val
#@nonl
#@-node:ekr.20060919110638.44:vnodeAttributes
#@-node:ekr.20060919110638.43:startVnode
#@-node:ekr.20060919110638.35:startElement & helpers
#@-node:ekr.20060919110638.19:class saxContentHandler (XMLGenerator)
#@+node:ekr.20060919110638.15:class saxNodeClass
class saxNodeClass:

    '''A class representing one <v> element.

    Use getters to access the attributes, properties and rules of this mode.'''

    @others
#@nonl
#@+node:ekr.20060919110638.16: node.__init__
def __init__ (self):

    self.attributes = {}
    self.bodyString = ''
    self.headString = ''
    self.children = []
    self.tnodeAttributes = {}
    self.tnodeList = []
    self.tnx = None
#@nonl
#@-node:ekr.20060919110638.16: node.__init__
#@+node:ekr.20060919110638.17: node.__str__ & __repr__
def __str__ (self):

    return '<v: %s>' % self.headString

__repr__ = __str__
#@nonl
#@-node:ekr.20060919110638.17: node.__str__ & __repr__
#@+node:ekr.20060919110638.18:node.dump
def dump (self):

    g.pr('\nnode: tnx: %s len(body): %d %s' % (
        self.tnx,len(self.bodyString),self.headString))
    g.pr('children:',g.listToString(self.children))
    g.pr('attrs:',self.attributes.values())
#@nonl
#@-node:ekr.20060919110638.18:node.dump
#@-node:ekr.20060919110638.15:class saxNodeClass
#@-node:ekr.20060919145406:<< define sax classes >>
#@+node:ekr.20070626132332:es & minitest
def es(s,*args,**keys):

    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    # g.pr('es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s))
    # g.pr('es',repr(s))
    log = app.log
    if app.killed:
        return

    # Important: defining keyword arguments in addition to *args **does not work**.
    # See Section 5.3.4 (Calls) of the Python reference manual.
    # In other words, the following is about the best that can be done.
    color = keys.get('color')
    commas = keys.get('commas')
    commas = g.choose( 
        commas in (True,'True','true'),True,False)# default is False
    newline = keys.get('newline')
    newline = g.choose(
        newline in (False,'False','false'),False,True)# default is True
    spaces= keys.get('spaces')
    spaces = g.choose(
        spaces in (False,'False','false'),False,True)# default is True
    tabName = keys.get('tabName','Log')

        # Default goes to log pane *not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""):
        s = repr(s)
    s = g.translateArgs(s,args,commas,spaces)

    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            g.pr(s,newline=newline)
    else:
        if log and log.isNull:
            pass
        elif log:
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
        else:
            app.logWaiting.append((s,color),)
#@+node:ekr.20071024101611:mini test of es
@nocolor
@first
@first
@

This doesn't work as an external unit test.
To test, select all following lines and do execute-script.

s1 = 'line1 , ,  ,  end'
s2 = g.toUnicode(s1,'utf-8')

for s in (s1,s2):
    g.es(s)
    g.es_print(s)
#@-node:ekr.20071024101611:mini test of es
#@-node:ekr.20070626132332:es & minitest
#@+node:ekr.20041123092357:config.findSettingsPosition
# This was not used prior to Leo 4.5.

def findSettingsPosition (self,c,setting):

    """Return the position for the setting in the @settings tree for c."""

    munge = self.munge

    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()

    setting = munge(setting)

    for p in root.subtree_iter():
        #BJ munge will return None if a headstring is empty
        h = munge(p.headString()) or ''
        if h.startswith(setting):
            return p.copy()

    return c.nullPosition()
#@-node:ekr.20041123092357:config.findSettingsPosition
#@+node:ekr.20080412053100.2:changed
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName,relativeFileName=None):

    c = self

    self.requestedFocusWidget = None
    self.requestRedrawFlag = False
    self.requestRedrawScrollFlag = False
    self.requestedIconify = '' # 'iconify','deiconify'
    self.requestRecolorFlag = False

    # g.trace('Commands')
    self.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.

    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.chapterController = None
    self.frame = frame

    self.hiddenRootNode = leoNodes.vnode(context=c)
    self.hiddenRootNode.setHeadString('<hidden root vnode>')
    self.hiddenRootNode.t.vnodeList = [self.hiddenRootNode]
    self.isZipped = False # May be set to True by g.openWithFileName.
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()
    self.nodeHistory = nodeHistory(c)

    self.contractVisitedNodes = c.config.getBool('contractVisitedNodes')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
    self.fixed = c.config.getBool('fixedWindow',False)
        # New in Leo 4.5: True: Don't write window position, expansion states, marks, etc.
    self.fixedWindowPosition = c.config.getData('fixedWindowPosition')
    if self.fixedWindowPosition:
        try:
            w,h,l,t = self.fixedWindowPosition
            self.fixedWindowPosition = int(w),int(h),int(l),int(t)
        except Exception:
            g.es_print('bad @data fixedWindowPosition',repr(self.fixedWindowPosition),color='red')
    else:
        self.windowPosition = 500,700,50,50 # width,height,left,top.

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.

    # Break circular import dependencies by importing here.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoEditCommands as leoEditCommands
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoUndo as leoUndo

    self.shadowController = leoShadow.shadowController(c)
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0:
        g.pr("\n*** using Null undoer ***\n")
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20031218072017.3037:putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    c = self.c
    self.put("<globals")
    << put the body/outline ratio >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20031218072017.3038:<< put the body/outline ratio >>
# Puts an innumerate number of digits

self.put(" body_outline_ratio=")

# New in Leo 4.5: support fixed .leo files.
self.put_in_dquotes(
    str(g.choose(c.fixed,0.5,c.frame.ratio)))
#@-node:ekr.20031218072017.3038:<< put the body/outline ratio >>
#@+node:ekr.20031218072017.3039:<< put the position of this frame >>
# New in Leo 4.5: support fixed .leo files.

if c.fixed:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3039:<< put the position of this frame >>
#@+node:ekr.20031218072017.3040:<< put the position of the log window >>
top = left = height = width = 0 # no longer used

self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3040:<< put the position of the log window >>
#@-node:ekr.20031218072017.3037:putGlobals
#@+node:ekr.20031218072017.1863:putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    # Not writing @auto nodes is way too dangerous.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    if isIgnore:   forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = False     # Never write non-ignored @auto trees.
    elif isShadow: forceWrite = False   # Never write non-ignored @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Only write orphan @thin trees.
    else:          forceWrite = True      # Write all other @file trees.

    << Set gnx = tnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append tnodeList and unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s><vh>%s</vh>' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        << issue informational messages >>
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('</v>\n')
    else:
        fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
# New in Leo 4.4.8.  Assign v.t.fileIndex here as needed.
if not v.t.fileIndex:
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)

if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
#@-node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
#@+node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren(): attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"

    # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    # if not self.use_sax:
        # if p.equal(self.topPosition):     attr += "T" # was a bottleneck
        # if p.equal(self.currentPosition): attr += "V" # was a bottleneck

    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    if not c.fixed:
        d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@-node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
#@+node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin or isShadow:
        if 1:
            if g.app.unitTesting:
                g.app.unitTestDict["warning"] = True
            g.es("deleting tnode list for",p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))
#@nonl
#@-node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
#@+node:ekr.20040702085529:<< issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.headString(),color="blue")
    p.clearOrphan()
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode
#@+node:ekr.20060919110638.36:getPositionAttributes
def getPositionAttributes (self,attrs):

    c = self.c

    if c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}
    else:
        d = {}
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    return d
#@-node:ekr.20060919110638.36:getPositionAttributes
#@+node:ekr.20040629121554.3:c.signOnWithVersion
def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: version = sys.platform

    if not g.unitTesting:
        g.es("Leo Log Window...",color=color)
        g.es(signon)
        g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
        g.enl()
        if c.fixed:
            g.es_print('This is a fixed window',color='red')
#@-node:ekr.20040629121554.3:c.signOnWithVersion
#@+node:ekr.20080412172151.2:updateFixedStatus
def updateFixedStatus (self):

    c = self.c
    p = g.app.config.findSettingsPosition(c,'@bool fixedWindow')
    if p:
        import leo.core.leoConfig as leoConfig
        parser = leoConfig.settingsTreeParser(c)
        kind,name,val = parser.parseHeadline(p.headString())
        if val and val.lower() in ('true','1'):
            val = True
        else:
            val = False
        c.fixed = val

    # g.trace('c.fixed',c.fixed)
#@-node:ekr.20080412172151.2:updateFixedStatus
#@-node:ekr.20080412053100.2:changed
#@-node:ekr.20080318081653.1:Added support for @bool fixedWindow option
#@+node:ekr.20080517075806.1:Added new key-handling
This allows substantially simpler key bindings. Indeed, most per-pane bindings
have been eliminate.
#@nonl
#@+node:ekr.20080517075806.2:Vim notes
@nocolor

Other possible vim features:

- search-and-replace within the current selection,
- and to some extent macro recording and running.
- Support vim-specific features like '.', etc.
#@+node:ekr.20080517075806.3:Posting: New key handling
@nocolor

The "Huge Focus Aha", namely that focus never needs to be in the
outline pane, continues to clarify and guide my thinking:

1. There is no need for per-pane key bindings.  I'll be discussing
this in more detail as we go along.  This is itself a major
simplification.

2. Ville has discovered the heart of the matter: most modes should
continue until an unknown character is seen.  An **unknown character
for a mode** is a character for which no explicit binding has been
made for that mode.  Leo will enter a **main** (or default) mode when
the user types an unknown (unbound) character in a mode.

The main mode would be normal text-input mode for the emacs-like
bindings, and a "command" mode for vim-like bindings.  Leo already
allows the user to specify emacs-like or vim-like defaults via various
settings.  I forget the details, but they don't much matter in this
discussion.

There are a few complications with "stay in the mode until an unknown
character is seen".

A. Some modes, like the minibuffer, and vim input mode, will allow the
user to enter any unicode character.  Thus, we can't just list the
"known" bindings of a mode--there can be too many.  To handle this, we
need to create the distinction between **input modes** and **command
modes**.  Input modes continue until another mode is explicitly
requested.  Command modes continue until an unknown (unbound) key
sequence is seen.

B. Several modes, including the minibuffer and search modes, contain
implicit bindings for keys like <tab>, <return> and <backspace>.
Indeed, the user probably need not specify any bindings explicitly for
such modes.  This creates some interesting complications however.  Let
us distinguish between *text-editing* commands and *non-text-editing*
commands.  'beginning-of-line' is a text editing command; 'save-
outline' is not.  Commands such as sort-lines could be called text-
editing commands, but they make no sense in a single-line environment
such as the minibuffer or search/replace commands, so let us
tentatively call them non-text-editing commands, or rather **multi-
line-editing** commands.

As I write this, I realize that the distinction between text-editing
and non-text-editing commands implicitly assumes emacs-like *bindings*
for commands.  In the vim-like world of plain-key bindings, we could
imagine *temporarily* entering vim-command mode in the minibuffer, and
then *returning* to the minibuffer-insert-mode after the temporary vim-
command mode finished.  This could cause complications.  In general,
I'd rather stay away from a stack of modes, but only experimentation
will show what is needed.

C. Regardless of other details, some **basic editing commands/
bindings** surely must be supported in the minibuffer and search
commands:  cut, copy, paste, arrow-keys move the cursor, shift-arrow
keys extend the selection.  In emacs-like operation we can throw in
all text-editing bindings at essentially no cost.  In vim-like
operation, we can use the basic bindings, but more complex commands
would seem to require nested modes.

But the main point is that special-purpose modes will probably use
some reasonable, standard defaults based on settings for *other*
modes, plus some standard keys.  In other words, it may be possible to
dispense with explicit bindings for the minibuffer, etc.

That being so, we are left with a simple scheme:

1. Bindings apply **everywhere** in several senses.  They apply to all
panes, and bindings for text-editing commands apply in all text
widgets: the minibuffer, body pane, log pane, headlines, etc.

2. Binding unknown in a mode terminate the mode and return to the main
or default mode.

3. Non-text-editing commands, including multi-line-editing commands,
should terminate **single-line modes** such as minibuffer commands
unless a special case explicitly exists for them.

4. Bindings for **Leo-provided modes** will be created automatically
using the user's bindings for text-editing commands, plus special
characters like <tab>, <return> and <backspace>.  Leo provided modes
are the initial minibuffer mode and secondary minibuffer modes such
entering search patterns.

5. The only complication is possibly allowing vim-like command sub-
modes of single-line modes.

The code in k.masterKeyHandler is in the back of my mind as I write
this.  With luck, the new scheme will be considerably simpler than the
old, while being more flexible and more general.  Note that the way
bindings are actually specified is an entirely separate issue, which
is good because that logic is horrible.  Eliminating per-pane bindings
will help some, but not a lot.

We may want to allow the user to specify per-pane bindings as before,
but the bindings will be ignored.  But as I write this it seems like
this could cause a great deal of confusion.  Perhaps it will be better
to outlaw the old syntax entirely, or at least issue warnings that per-
pane bindings no longer have any effect.

This is all very preliminary.  I've written no code.  Your comments
are welcome now.
#@-node:ekr.20080517075806.3:Posting: New key handling
#@+node:ekr.20080517075806.4:Posting: More design notes
@nocolor

On May 7, 7:05 pm, "Edward K. Ream" <edream...@gmail.com> wrote:

> This post will be a "thinking out loud" discussion of the new design.

I've just spent some time drawing state diagrams that indicate transitions between various states.  It turned out to be more simple than I had feared.

> As I write this, I realize that the distinction between text-editing
> and non-text-editing commands implicitly assumes emacs-like *bindings*
> for commands.  

No.  The distinction has nothing to do with bindings, as my post earlier today shows.  In fact, after seeing the final state diagrams, my intention is to be able to support *both* emacs-like and vim-like bindings simultaneously.  Actually, Leo can already do this, or it could if @mode bindings actually worked :-)

The more useful distinction is between commands that change modes and commands that stay in the same mode.  This became clearer as I played with the diagrams.

Ok, let's see if I can summarize what the diagrams are trying to tell me without tying myself up in knots :-)

1. *All* modes are minibuffer modes.  That is, the present mode will always be indicated at the start of the minibuffer.  It would not be good to use the status area because the UNL plugin overwrites the status when changing nodes.

However, not all modes need actually *use* (alter) the minibuffer.  For example, a user-defined outline mode might provide bindings for just the arrow and shift arrow keys.  Nothing the user types would appear in the minibuffer during that mode.

2. @mode nodes define user modes.  These nodes can specify the "prompt" that will appear in the minibuffer while the node is active. For example:

@mode <mode name> @prompt = <prompt>

When a mode is active the minibuffer will contain as a **minibuffer prefix**:

<mode name> mode: <prompt>

As always, the prefix is protected: the user can not erase it by backspacing.

3. Binding are actually a completely separate topic from how Leo handles modes.  However, modes can create "virtual key sequences" that represent a command.  It would be extremely complex to generate those virtual key sequences in menus with the present code base--and probably for *any* version of Leo's config code.  To handle this, @item nodes in @settings trees could specify a "hint" that would look like a real menu shortcut.  Leo would completely ignore such hints: they would be only for cosmetic purposes.  Like this;

@item move-outline-left @hint = A-S-Left or [cmd]o,S-Left

The hint can be any string that makes sense to you.  In this case it signifies that there are two possible ways move an outline left: Alt-Shift-Left in any mode or type o followed by Shift-Left in command mode.

The advantage of this scheme is its simplicity and generality.  The disadvantage is that you, the user, must ensure that the hints make sense and are up-to-date.  I think it will turn out to be very handy.

4. With these preliminaries in place, the actual scheme for switching between modes is relatively straightforward:

A: The default (main) mode will be insert-mode for emacs-like operation and command-mode for vim-like operation.

B: In insert mode, edit-commands executed via menus or by key bindings will cause Leo to remain in insert mode.  All other commands transfer to other modes, with the default mode as the default.  So for emacs-like operation, control (focus) typically stays in the body pane, while for vim-like operation control typically stays in the minibuffer.

BTW, now that all modes can be considered minibuffer modes, we need to distinguish between modes that insert unbound keys (either in the present text pane or in the minibuffer) and those that don't.  For those modes that don't, any unbound key will transfer to the default mode.

C: In general (there may be smallish exceptions), a key stroke that would invoke an unknown command causes control to go to the default mode.

D: In user modes, all commands transfer to the default mode except for explicitly declared "stay-in-this-mode" commands.  This mechanism is already in place.

In short, key **bindings** no longer matter to k.masterKeyHandler.  All that matters is the command that is about to be executed.  This is a very nice simplification: all the old pane-specific logic should just go away.  Actually, it seems like an important Aha.

I now have hopes of putting this all in place in just a few days.

BTW, none of this is a "requirements specification".  That's not how I work :-)  What will emerge will be the result of playing with the code and seeing what works and what doesn't.

Edward
#@nonl
#@-node:ekr.20080517075806.4:Posting: More design notes
#@+node:ekr.20080517075806.5:Used by vim
@nocolor

Used by vim:

a/A (append after cursor)
c
d,dd,D (delete before cursor)
f/F/t/T
g,gf,g0,gg,ge,gE
h,j,k,l (motion commands)
i/I (insert before cursor, insert at indentation)
m,m',m` (marks)
n,N
o/O (open line) Why not just use <insert?>
r/R
x/X (delete after cursor)
y
u
v,V
w/W
ZZ,ZQ
.
:
;
+-
/ (patterns)
#@nonl
#@-node:ekr.20080517075806.5:Used by vim
#@+node:ekr.20080517075806.6:vim bindings: what I did
@nocolor

- Changed cycle-focus and cycle-all-focus commands.
- Removed Alt-T binding for focus-to-outline
- Paste in minibuffer (find/change) does not work.
  Added cut-text, copy-text, paste-text to list of single-line commands.  
- Bug: don't enter edit-headline in command mode.
- Bug: can't enter period in find.  Period is bound to auto-complete(!)
- Indicate input mode in mini-buffer.
- Ignore plain-key bindings in insert-mode.
- Enter outline mode after clone/copy-outline/Collapse all.
- Bound escape to set-command-mode.
- end-edit-headline should switch to body pane.
  Just set @bool stayInTreeAfterEditHeadline = False
- Enter command mode when editing headlines.
- Fix autocompletion.
- Don't allow unbound plain keys in command mode.
- State prompt (and Find prompt) in minibuffer is not protected.
- Tab completion wipes out full-command.
- Modes no longer put focus in minibuffer.
- Strip '-mode' from mode message in minibuffer.
- Show "In outline" in showStateAndMode.
- focus-to-body now enters default input state.
- End editing of headline leaves *body* in insert mode.
    - The actual bug was in k.setDefaultInputAction. It must use k.defaultUnboundKeyAction.
- Fixed bug: body pane changes color when headline mode changes.
- Python indentation now works.
- Ignore all unbound plain keys valid in command mode, except for plain auto-complete key.
- Insert mode does now persists in headline.
- Handled outline navigation.
- Don't honor command-mode keys if in tree.
- Reorganized and simplified leoSettings.leo.
- find-char should extend past line.
- Extended a, e commands: go further if at beginning/end of line.
- **Sometimes** the focus is both in the body pane and outline pane.
  For example, after save outline.
- Made legacy (insert mode) operation the default.
- All unit tests pass in legacy mode.
- Moving outlines with alt-shift-arrow keys messed up state reports.
- Autocompletion doesn't restore 'insert' mode when 'command' mode is the default.
- Control-g doesn't restore default input state, or doesn't recolor the body.
- Body pane is yellow initially, and prompt is "In Tree", but focus is in body!
- Initial body pane color should be yellow if outline has focus initially.
- Make sure minibuffer keeps its blue color.
- add empty bindings for clean-recent-files and sort-recent-files.
- Dot in insert mode when there are no autocompletions to suggest goes to command mode.
- Typing . at the start of a line with auto-completer enabled hangs leo(!)
  This happens in the trunk too.
- Disabled failed unit tests when command-mode is the default.
#@nonl
#@-node:ekr.20080517075806.6:vim bindings: what I did
#@-node:ekr.20080517075806.2:Vim notes
#@-node:ekr.20080517075806.1:Added new key-handling
#@+node:ekr.20080517075806.7:New drawing/focus code
#@+node:ekr.20080517075806.9:Notes
@nocolor

c.redraw_now is a bit of a problem.  Sometimes it can be replaced by c.redraw, sometimes not. I have been super conservative: I've left all calls to c.redraw_now alone, and added calls to c.outerUpdate as needed.

Later, when preliminary testing is complete, c.redraw_now() can call c.outerUpdate automatically.

c.bind(w,a,b) can call g.app.gui.bind(w,a,b) to avoid a gui-related case statement.

@color
#@nonl
#@+node:ekr.20080517075806.8:What I did
What I did:

- Created new version of all c.Drawing methods when g.newDrawing is True.
- Call outerUpdate from event handlers.
- Call outerUpdate after calling k.masterKeyHandlerHelper.
- Created new versions of leoBody.color methods.
- Created and test c.bind.
- Reviewed all uses of c.redraw_now(): added calls to c.outerUpdate where needed.
- Removed new wrappers from k.masterX.
- There is a slight wiggle when opening files.  It happens with the old code.
- Add c.bind2 with 3 args.
- Added call to c.outerUpdate to g.app.closeLeoWindow.
- Fixed major bug: c.redraw and c.redraw_now must request a redraw.

Changed x.bind to c.bind or c.bind2 in the following plugins:

EditAttributes.py
UASearch.py
URLloader.py
UniversalScrolling.py
fastGotoNode.py
ironPythonGui.py
mod_scripting.py
nav_buttons.py
newButtons.py
nodebar.py
pie_menus.py
plugins_menu.py
scheduler.py
searchbox.py
toolbar.py
xcc_nodes.py
#@nonl
#@-node:ekr.20080517075806.8:What I did
#@+node:ekr.20080517075806.10:Design for simplified drawing & focus
@nocolor

- c.outerUpdate actually updates everything, using c.requestedRedraw,
  c.requestedWidget, c.requestedMinibufferPrompt. c.outerUpdate may be called
  anytime to force an immediate update. The master command handler calls
  outerUpdate, as do all event handlers that make any requests.

- g.newDrawing selects between old and new code. When g.newDrawing is False,
  c.outerUpdate does nothing. When g.newDrawing is True, many of Leo's drawing
  methods simply make requests:

    - c.beginUpdate does nothing.
    - c.endUpdate sets c.requestRedrawFlag to request a redraw.
    - c.xWantsFocus set c.requestedFocusWidget.
    - c.k.showStateAndFocus sets c.requestedMinibufferPrompt.
    - c.selectPosition sets c.requestedPosition.
    - c.recolor() sets c.frame.requestRecolorFlag.

This design might substantially simplify some very complex code. My intention is
to make *no* changes to the code base except for calls to c.outerUpdate. Thus,
it will be easy to see what has changed. The experiment can be done in the
key-handling branch.

This is a higly speculative project.  Previous attempts have failed...
#@-node:ekr.20080517075806.10:Design for simplified drawing & focus
#@-node:ekr.20080517075806.9:Notes
#@+node:ekr.20080517075806.12:Menus (tkBody) (May cause problems)
def bind (self,*args,**keys):

    c = self.c
    return self.bodyCtrl.bind(*args,**keys)
#@-node:ekr.20080517075806.12:Menus (tkBody) (May cause problems)
#@+node:ekr.20080517075806.13:Projects
#@+node:ekr.20080517075806.14:Classified commands
#@-node:ekr.20080517075806.14:Classified commands
#@+node:ekr.20080517075806.15:@strings  [ignore,insert, overwrite] top_level_unbound_key_action = insert
@nocolor

This setting determines the initial binding for otherwise-unbound keystrokes
when no mode is in effect.  Note: the keyboard-quit command exits all modes.

The valid values are::

ignore:  Leo ignores the key (like Vim).
insert:  Leo inserts the key at the cursor (like Emacs)
overwrite: Leo replaces the character at the cursor.
#@nonl
#@-node:ekr.20080517075806.15:@strings  [ignore,insert, overwrite] top_level_unbound_key_action = insert
#@+node:ekr.20080517075806.16:Modes no longer put focus in minibuffer
#@-node:ekr.20080517075806.16:Modes no longer put focus in minibuffer
#@+node:ekr.20080517075806.17:Reset input state in end-edit-headline
#@-node:ekr.20080517075806.17:Reset input state in end-edit-headline
#@+node:ekr.20080517075806.18:Don't honor command-mode keys if not in text widget
#@-node:ekr.20080517075806.18:Don't honor command-mode keys if not in text widget
#@+node:ekr.20080517075806.20:Make sure keyboard-quit enters default mode, except during auto-completion
#@-node:ekr.20080517075806.20:Make sure keyboard-quit enters default mode, except during auto-completion
#@+node:ekr.20080517075806.22:Munged mode names to create mode prompt
@nocolor

In @mode aString, everything before the first :: is the mode name, and everything after is the prompt that appears in the minibuffer.  If there is no ::, the prompt is the same as the mode name.
#@nonl
#@-node:ekr.20080517075806.22:Munged mode names to create mode prompt
#@+node:ekr.20080517075806.23:Fixed an unusual headline click problem
@

This happens when focus is in the minibuffer and the user clicks a headline.

The fix was to add a "don't color" arg to showStateAndMode.

I also changed treeWantsFocus to treeWantsFocusNow in OnActivateHeadline.
#@nonl
#@-node:ekr.20080517075806.23:Fixed an unusual headline click problem
#@-node:ekr.20080517075806.13:Projects
#@-node:ekr.20080517075806.7:New drawing/focus code
#@+node:ekr.20080517075806.24:Improved end of calltips
# Added ')' at end.
#@nonl
#@-node:ekr.20080517075806.24:Improved end of calltips
#@+node:ekr.20080517075806.19:Find character crosses lines
#@-node:ekr.20080517075806.19:Find character crosses lines
#@+node:ekr.20080520090822.1:Added os.curdir to sys.path if possible
# This is necessary to simulate operation as a package.
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
if jyLeo:
    print('*** starting jyLeo',sys.platform) # will be something like java1.6.0_02

# Add the current directory to sys.path *before* importing g.
# This will fail if the current directory contains unicode characters...
path = os.getcwd()
if path not in sys.path:
    # print('appending %s to sys.path' % path)
    sys.path.append(path)

# Import leoGlobals, but do NOT set g.
import leo.core.leoGlobals as leoGlobals

# Set leoGlobals.g here, rather than in leoGlobals.py.
leoGlobals.g = leoGlobals

import leo.core.leoApp as leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

if jyLeo:
    startJyleo(g)
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@-node:ekr.20080520090822.1:Added os.curdir to sys.path if possible
#@+node:ekr.20080521132317.1:Added support for single-config option
# This code appears to have been reverted in such a way that it never got pushed to launchpad.
#@nonl
#@+node:ekr.20031218072017.1934:run
def run(fileName=None,pymacs=None,jyLeo=False,*args,**keywords):

    """Initialize and run Leo"""

    # __pychecker__ = '--no-argsused' # keywords not used.

    import pdb ; pdb = pdb.set_trace

    << import leoGlobals and leoApp >>
    if not jyLeo and not isValidPython(): return
    g.computeStandardDirectories()
    adjustSysPath(g)
    script,windowFlag = scanOptions(g)
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    if not fileName:
        fileName = getFileName()

    << import other early files >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName,relativeFileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif jyLeo:
        import leo.core.leoSwingGui as leoSwingGui
        g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    if g.app.oneConfigFilename: g.es_print('--one-config option in effect',color='red')
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    # Respect c's focus wishes if posssible.
    w = g.app.gui.get_focus(c)
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)
    c.outerUpdate()
    g.app.gui.runMainLoop()
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
if jyLeo:
    print('*** starting jyLeo',sys.platform) # will be something like java1.6.0_02

# Add the current directory to sys.path *before* importing g.
# This will fail if the current directory contains unicode characters...
path = os.getcwd()
if path not in sys.path:
    # print('appending %s to sys.path' % path)
    sys.path.append(path)

# Import leoGlobals, but do NOT set g.
import leo.core.leoGlobals as leoGlobals

# Set leoGlobals.g here, rather than in leoGlobals.py.
leoGlobals.g = leoGlobals

import leo.core.leoApp as leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

if jyLeo:
    startJyleo(g)
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import other early files>>
import leo.core.leoNodes as leoNodes
import leo.core.leoConfig as leoConfig

# There is a circular dependency between leoCommands and leoEditCommands.
import leo.core.leoCommands as leoCommands
#@-node:ekr.20041219072416.1:<< import other early files>>
#@-node:ekr.20031218072017.1934:run
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions(g):

    '''Handle all options and remove them from sys.argv.'''

    import optparse

    parser = optparse.OptionParser()
    parser.add_option('--one-config',dest="one_config_path")
    parser.add_option('--silent',action="store_false",dest="silent")
    parser.add_option('--script',dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # --one-config
    path = options.one_config_path
    if path:
        path = g.os_path_abspath(g.os_path_join(os.getcwd(),path))
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid option: file not found:',path,color='red')

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent

    # Compute the return values.
    windowFlag = script and script_path_w
    return script, windowFlag
#@nonl
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    if g.app.oneConfigFilename:
        table = ((g.app.oneConfigFilename,False),)
    else:
        table = (
            (self.globalConfigFile,False),
            (self.homeFile,False),
            (localConfigFile,False),
            (self.myGlobalConfigFile,False),
            (self.myHomeConfigFile,False),
            (self.machineConfigFile,False),
            (myLocalConfigFile,False),
            (fileName,True),
        )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_abspath(g.os_path_normpath(path)))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@-node:ekr.20080521132317.1:Added support for single-config option
#@+node:ekr.20080531075119.8:Finished Tracer class
#@+node:ekr.20041005105605.26:readAll (atFile)
def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if not p.headString().startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for v in c.all_unique_vnodes_iter():
        v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")

    if use_tracer: tt.stop()
#@-node:ekr.20041005105605.26:readAll (atFile)
#@+node:ekr.20041005105605.21:read (atFile)
def read(self,root,importFileName=None,thinFile=False,fromString=None,atShadow=False):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString,atShadow=atShadow)
    if not at.inputFile: return False
    if not g.unitTesting:
        g.es("reading:",root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>
    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
resurrected = 0
for p in root.self_and_subtree_iter():

    if not p.v.t.isVisited():
        g.es('resurrected node:',p.headString(),color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for t in c.all_unique_tnodes_iter():

    if hasattr(t,"tempBodyString"):
        delattr(t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile)
#@+node:ekr.20080531075119.1:class Tracer & g.startTracer
class Tracer:

    '''A "debugger" that computes a call graph.

    To trace a function and its callers, put the following at the function's start:

    g.startTracer()
    '''

	@others

def startTracer():

    import sys
    t = g.Tracer()
    sys.settrace(t.tracer)
    return t
#@+node:ekr.20080531075119.2: __init__
def __init__(self):

    self.callDict = {}
        # Keys are function names.
        # Values are the number of times the function was called by the caller.
    self.calledDict = {}
        # Keys are function names.
        # Values are the total number of times the function was called.

    self.count = 0
    self.inited = False
    self.limit = 2 # 0: no limit, otherwise, limit trace to n entries deep.
    self.stack = []
    self.trace = False
    self.verbose = False # True: print returns as well as calls.
#@-node:ekr.20080531075119.2: __init__
#@+node:ekr.20080531075119.3:computeName
def computeName (self,frame):

    import inspect

    if not frame: return ''

    code = frame.f_code ; result = []

    module = inspect.getmodule(code)
    if module:
        module_name = module.__name__
        if module_name == 'leo.core.leoGlobals':
            result.append('g')
        else:
            tag = 'leo.core.'
            if module_name.startswith(tag):
                module_name = module_name[len(tag):]
            result.append(module_name)

    try:
        # This can fail during startup.
        self_obj = frame.f_locals.get('self')
        if self_obj: result.append(self_obj.__class__.__name__)
    except Exception:
        pass

    result.append(code.co_name)

    return '.'.join(result)
#@-node:ekr.20080531075119.3:computeName
#@+node:ekr.20080531075119.4:report
def report (self):

    if 0:
        g.pr('\nstack')
        for z in self.stack:
            g.pr(z)

    g.pr('\ncallDict...')

    # g.pr(g.dictToString(self.callDict))
    keys = self.callDict.keys()
    keys.sort()
    for key in keys:
        # Print the calling function.
        g.pr('%d' % (self.calledDict.get(key,0)),key)
        # Print the called functions.
        d = self.callDict.get(key)
        keys2 = d.keys()
        keys2.sort()
        for key2 in keys2:
            g.pr('%8d' % (d.get(key2)),key2)
#@-node:ekr.20080531075119.4:report
#@+node:ekr.20080531075119.5:stop
def stop (self):

    sys.settrace(None)
    self.report()
#@-node:ekr.20080531075119.5:stop
#@+node:ekr.20080531075119.6:tracer
def tracer (self, frame, event, arg):

    '''A function to be passed to sys.settrace.'''

    n = len(self.stack)
    if event == 'return': n = max(0,n-1)
    pad = '.' * n

    if event == 'call':
        if not self.inited:
            # Add an extra stack element for the routine containing the call to startTracer.
            self.inited = True
            name = self.computeName(frame.f_back)
            self.updateStats(name)
            self.stack.append(name)
        name = self.computeName(frame)
        if self.trace and (self.limit == 0 or len(self.stack) < self.limit):
            g.trace('%scall' % (pad),name)
        self.updateStats(name)
        self.stack.append(name)
        return self.tracer
    elif event == 'return':
        if self.stack:
            name = self.stack.pop()
            if self.trace and self.verbose and (self.limit == 0 or len(self.stack) < self.limit):
                g.trace('%sret ' % (pad),name)
        else:
            g.trace('return underflow')
            self.stop()
            return None
        if self.stack:
            return self.tracer
        else:
            self.stop()
            return None
    else:
        return self.tracer
#@-node:ekr.20080531075119.6:tracer
#@+node:ekr.20080531075119.7:updateStats
def updateStats (self,name):

    if not self.stack:
        return

    caller = self.stack[-1]
    d = self.callDict.get(caller,{})
        # d is a dict reprenting the called functions.
        # Keys are called functions, values are counts.
    d[name] = 1 + d.get(name,0)
    self.callDict[caller] = d

    # Update the total counts.
    self.calledDict[name] = 1 + self.calledDict.get(name,0)
#@-node:ekr.20080531075119.7:updateStats
#@-node:ekr.20080531075119.1:class Tracer & g.startTracer
#@-node:ekr.20080531075119.8:Finished Tracer class
#@+node:ekr.20080527084425.4:Rewrote option-parsing code using optparse
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions(g):

    '''Handle all options and remove them from sys.argv.'''

    import optparse

    parser = optparse.OptionParser()
    parser.add_option('--one-config',dest="one_config_path")
    parser.add_option('--silent',action="store_false",dest="silent")
    parser.add_option('--script',dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # --one-config
    path = options.one_config_path
    if path:
        path = g.os_path_abspath(g.os_path_join(os.getcwd(),path))
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid option: file not found:',path,color='red')

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent

    # Compute the return values.
    windowFlag = script and script_path_w
    return script, windowFlag
#@nonl
#@-node:ekr.20080521132317.2:scanOptions
#@-node:ekr.20080527084425.4:Rewrote option-parsing code using optparse
#@+node:ekr.20080602172531.3:Added @bool cleo_color_ignore = True
This determines whether cleo colors @ignore headlines. The default is True.
#@nonl
#@-node:ekr.20080602172531.3:Added @bool cleo_color_ignore = True
#@+node:ekr.20080606074139.1:Set cwd in read/write commands
@ This affect the following commands:

open, save, save-as, save-to, read-outline-only, read-file-into-node, write-file-from-node and all the import/export commands.
#@nonl
#@+node:ekr.20080606074139.2:g.chdir
def chdir (path):

    if not g.os_path_isdir(path):
        path = g.os_path_dirname(path)

    if g.os_path_isdir(path) and g.os_path_exists(path):
        os.chdir(path)
#@-node:ekr.20080606074139.2:g.chdir
#@+node:ekr.20031218072017.2819:File Menu
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    # g.trace(g.callers())

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    # c.beginUpdate()
    # try:
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    v = leoNodes.vnode(context=c)
    p = leoNodes.position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    c.setRootVnode(v) # New in Leo 4.4.2.
    c.editPosition(p)
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(fileName=None)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # finally:
    # c.endUpdate(False)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    # Force a call to c.outerUpdate.
    # This is needed when we execute this command from a menu.
    c.redraw_now()

    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.chdir(fileName)
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # g.pr(language,ext)
    if ext == None:
        ext = "txt"

if ext[0] != ".":
    ext = "."+ext

# g.pr("ext",ext)
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening:",g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.trace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing:",command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    c = self
    theFile = None # pylint complains if this is inited to ''.
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  ",g.shortFileName(path),color="red")
        else:
            g.es("creating:  ",g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # g.pr("removing previous entry in g.app.openWithFiles for",p.headString())
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    name = "LeoTemp_%s_%s%s" % (
        str(id(p.v.t)),
        g.sanitize_filename(p.headString()),
        ext)

    name = g.toUnicode(name,g.app.tkEncoding)

    td = g.os_path_abspath(tempfile.gettempdir())

    path = g.os_path_join(td,name)

    return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    # c.beginUpdate()
    # try:
    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)
    # finally:
    c.redraw() # was c.endUpdate()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # c.beginUpdate()
    # try:
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        g.trace(fileName)
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)
    # finally:
    c.redraw() # was c.endUpdate()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # c.beginUpdate()
    # try:
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
        g.chdir(fileName)
    # finally:
    c.redraw() # was c.endUpdate()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.2079:Recent Files submenu & allies
#@+node:ekr.20031218072017.2080:clearRecentFiles
def clearRecentFiles (self,event=None):

    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer

    bunch = u.beforeClearRecentFiles()

    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.deleteRecentFilesMenuItems(recentFilesMenu)

    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.relativeFileName())

    g.app.config.appendToRecentFiles(c.recentFiles)

    # g.trace(c.recentFiles)

    u.afterClearRecentFiles(bunch)

    # New in Leo 4.4.5: write the file immediately.
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:ekr.20031218072017.2080:clearRecentFiles
#@+node:ekr.20031218072017.2081:openRecentFile
def openRecentFile(self,name=None):

    if not name: return

    c = self ; v = c.currentVnode()
    << Set closeFlag if the only open window is empty >>

    fileName = name
    if not g.doHook("recentfiles1",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag and frame != c.frame:
            g.app.destroyWindow(c.frame) # 12/12/03
            c = frame.c # Switch to the new commander so the "recentfiles2" hook doesn't crash.
            c.setLog() # Sets the log stream for g.es

    g.doHook("recentfiles2",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
#@+node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2081:openRecentFile
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    if g.app.unitTesting: return

    def munge(name):
        return g.os_path_normpath(name or '').lower()
    def munge2(name):
        return g.os_path_abspath(g.os_path_join(g.app.loadDir,name or ''))

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if munge(fileName) == munge(name) or munge2(fileName) == munge2(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace('adding',fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@+node:tbrown.20080509212202.6:cleanRecentFiles
def cleanRecentFiles(self,event=None):

    c = self

    dat = c.config.getData('path-demangle')
    if not dat:
        g.es('No @data path-demangle setting')
        return

    changes = []
    replace = None
    for line in dat:
        text = line.strip()
        if text.startswith('REPLACE: '):
            replace = text.split(None, 1)[1].strip()
        if text.startswith('WITH:') and replace is not None:
            with_ = text[5:].strip()
            changes.append((replace, with_))
            g.es('%s -> %s' % changes[-1])

    orig = [i for i in c.recentFiles if i.startswith("/")]
    c.clearRecentFiles()

    for i in orig:
        t = i
        for change in changes:
            t = t.replace(*change)

        c.updateRecentFiles(t)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:tbrown.20080509212202.6:cleanRecentFiles
#@+node:tbrown.20080509212202.8:sortRecentFiles
def sortRecentFiles(self,event=None):

    c = self

    orig = c.recentFiles[:]
    c.clearRecentFiles()
    import os
    orig.sort(cmp=lambda a,b:cmp(os.path.basename(b).lower(),     
        os.path.basename(a).lower()))
    for i in orig:
        c.updateRecentFiles(i)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:tbrown.20080509212202.8:sortRecentFiles
#@-node:ekr.20031218072017.2079:Recent Files submenu & allies
#@+node:ekr.20031218072017.2838:Read/Write submenu
#@+node:ekr.20031218072017.2839:readOutlineOnly
def readOutlineOnly (self,event=None):

    '''Open a Leo outline from a .leo file, but do not read any derived files.'''

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        g.chdir(fileName)
        c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
        frame.deiconify()
        frame.lift()
        g.app.root.update() # Force a screen redraw immediately.
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:",fileName)
#@-node:ekr.20031218072017.2839:readOutlineOnly
#@+node:ekr.20070915134101:readFileIntoNode
def readFileIntoNode (self,event=None):

    '''Read a file into a single node.'''

    c = self ; undoType = 'Read File Into Node'
    filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Read File Into Node",filetypes=filetypes,defaultextension=None)

    if fileName:    
        try:
            theFile = open(fileName,'r')
            g.chdir(fileName)
            s = theFile.read()
            s = '@nocolor\n' + s
            # c.beginUpdate()
            # try:
            w = c.frame.body.bodyCtrl
            p = c.insertHeadline(op_name=undoType)
            p.setHeadString('@read-file-into-node ' + fileName)
            p.setBodyString(s)
            w.setAllText(s)
            # finally:
            c.redraw() # was c.endUpdate()
        except:
            g.es("can not open:",fileName)
#@-node:ekr.20070915134101:readFileIntoNode
#@+node:ekr.20070806105721.1:readAtAutoNodes (commands)
def readAtAutoNodes (self,event=None):

    '''Read all @auto nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    # c.beginUpdate()
    # try:
    undoData = u.beforeChangeTree(p)
    c.importCommands.readAtAutoNodes()
    u.afterChangeTree(p,'Read @auto Nodes',undoData)
    # finally:
    c.redraw() # was c.endUpdate()
#@-node:ekr.20070806105721.1:readAtAutoNodes (commands)
#@+node:ekr.20031218072017.1839:readAtFileNodes (commands)
def readAtFileNodes (self,event=None):

    '''Read all @file nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    c.fileCommands.readAtFileNodes()
    u.afterChangeTree(p,'Read @file Nodes',undoData)
    c.redraw()
#@-node:ekr.20031218072017.1839:readAtFileNodes (commands)
#@+node:ekr.20080801071227.4:readAtShadowNodes (commands)
def readAtShadowNodes (self,event=None):

    '''Read all @shadow nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    c.atFileCommands.readAtShadowNodes(p)
    u.afterChangeTree(p,'Read @shadow Nodes',undoData)
    c.redraw() 
#@-node:ekr.20080801071227.4:readAtShadowNodes (commands)
#@+node:ekr.20031218072017.1809:importDerivedFile
def importDerivedFile (self,event=None):

    """Create a new outline from a 4.0 derived file."""

    c = self ; p = c.currentPosition()

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        g.chdir(names[0])
        c.importCommands.importDerivedFiles(parent=p,paths=names)
#@-node:ekr.20031218072017.1809:importDerivedFile
#@+node:ekr.20070915142635:writeFileFromNode
def writeFileFromNode (self,event=None):

    # If node starts with @read-file-into-node, use the full path name in the headline.
    # Otherwise, prompt for a file name.

    c = self ; p = c.currentPosition()
    h = p.headString().rstrip()
    s = p.bodyString()
    tag = '@read-file-into-node'

    if h.startswith(tag):
        fileName = h[len(tag):].strip()
    else:
        fileName = None

    if not fileName:
        filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
        fileName = g.app.gui.runSaveFileDialog(
            initialfile=None,
            title='Write File From Node',
            filetypes=filetypes,
            defaultextension=None)
    if fileName:
        try:
            theFile = open(fileName,'w')
            g.chdir(fileName)
        except IOError:
            theFile = None
        if theFile:
            if s.startswith('@nocolor\n'):
                s = s[len('@nocolor\n'):]
            theFile.write(s)
            theFile.flush()
            g.es_print('wrote:',fileName,color='blue')
            theFile.close()
        else:
            g.es('can not write %s',fileName,color='red')
#@nonl
#@-node:ekr.20070915142635:writeFileFromNode
#@-node:ekr.20031218072017.2838:Read/Write submenu
#@+node:ekr.20031218072017.2841:Tangle submenu
#@+node:ekr.20031218072017.2842:tangleAll
def tangleAll (self,event=None):

    '''Tangle all @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.tangleAll()
#@-node:ekr.20031218072017.2842:tangleAll
#@+node:ekr.20031218072017.2843:tangleMarked
def tangleMarked (self,event=None):

    '''Tangle all marked @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.tangleMarked()
#@-node:ekr.20031218072017.2843:tangleMarked
#@+node:ekr.20031218072017.2844:tangle
def tangle (self,event=None):

    '''Tangle all @root nodes in the selected outline.'''

    c = self
    c.tangleCommands.tangle()
#@-node:ekr.20031218072017.2844:tangle
#@-node:ekr.20031218072017.2841:Tangle submenu
#@+node:ekr.20031218072017.2845:Untangle submenu
#@+node:ekr.20031218072017.2846:untangleAll
def untangleAll (self,event=None):

    '''Untangle all @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.untangleAll()
    c.undoer.clearUndoState()
#@-node:ekr.20031218072017.2846:untangleAll
#@+node:ekr.20031218072017.2847:untangleMarked
def untangleMarked (self,event=None):

    '''Untangle all marked @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.untangleMarked()
    c.undoer.clearUndoState()
#@-node:ekr.20031218072017.2847:untangleMarked
#@+node:ekr.20031218072017.2848:untangle
def untangle (self,event=None):

    '''Untangle all @root nodes in the selected outline.'''

    c = self
    c.tangleCommands.untangle()
    c.undoer.clearUndoState()
#@-node:ekr.20031218072017.2848:untangle
#@-node:ekr.20031218072017.2845:Untangle submenu
#@+node:ekr.20031218072017.2849:Import&Export submenu
#@+node:ekr.20031218072017.2850:exportHeadlines
def exportHeadlines (self,event=None):

    '''Export all headlines to an external file.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.exportHeadlines(fileName)
#@-node:ekr.20031218072017.2850:exportHeadlines
#@+node:ekr.20031218072017.2851:flattenOutline
def flattenOutline (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in MORE format.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.flattenOutline(fileName)
#@-node:ekr.20031218072017.2851:flattenOutline
#@+node:ekr.20031218072017.2852:importAtRoot
def importAtRoot (self,event=None):

    '''Import one or more external files, creating @root trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFilesCommand (names,"@root")
#@-node:ekr.20031218072017.2852:importAtRoot
#@+node:ekr.20031218072017.2853:importAtFile
def importAtFile (self,event=None):

    '''Import one or more external files, creating @file trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFilesCommand(names,"@file")
#@-node:ekr.20031218072017.2853:importAtFile
#@+node:ekr.20031218072017.2854:importCWEBFiles
def importCWEBFiles (self,event=None):

    '''Import one or more external CWEB files, creating @file trees.'''

    c = self

    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importWebCommand(names,"cweb")
#@-node:ekr.20031218072017.2854:importCWEBFiles
#@+node:ekr.20031218072017.2855:importFlattenedOutline
def importFlattenedOutline (self,event=None):

    '''Import an external created by the flatten-outline command.'''

    c = self

    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFlattenedOutline(names)
#@-node:ekr.20031218072017.2855:importFlattenedOutline
#@+node:ekr.20031218072017.2856:importNowebFiles
def importNowebFiles (self,event=None):

    '''Import one or more external noweb files, creating @file trees.'''

    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importWebCommand(names,"noweb")
#@-node:ekr.20031218072017.2856:importNowebFiles
#@+node:ekr.20031218072017.2857:outlineToCWEB
def outlineToCWEB (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in CWEB format.'''

    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.outlineToWeb(fileName,"cweb")
#@-node:ekr.20031218072017.2857:outlineToCWEB
#@+node:ekr.20031218072017.2858:outlineToNoweb
def outlineToNoweb (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in noweb format.'''

    c = self

    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName
#@-node:ekr.20031218072017.2858:outlineToNoweb
#@+node:ekr.20031218072017.2859:removeSentinels
def removeSentinels (self,event=None):

    '''Import one or more files, removing any sentinels.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.removeSentinelsCommand (names)
#@-node:ekr.20031218072017.2859:removeSentinels
#@+node:ekr.20031218072017.2860:weave
def weave (self,event=None):

    '''Simulate a literate-programming weave operation by writing the outline to a text file.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.weave(fileName)
#@-node:ekr.20031218072017.2860:weave
#@-node:ekr.20031218072017.2849:Import&Export submenu
#@-node:ekr.20031218072017.2819:File Menu
#@+node:ekr.20080606074139.3:Changed
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.chdir(fileName)
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    # c.beginUpdate()
    # try:
    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)
    # finally:
    c.redraw() # was c.endUpdate()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # c.beginUpdate()
    # try:
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        g.trace(fileName)
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)
    # finally:
    c.redraw() # was c.endUpdate()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # c.beginUpdate()
    # try:
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
        g.chdir(fileName)
    # finally:
    c.redraw() # was c.endUpdate()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2839:readOutlineOnly
def readOutlineOnly (self,event=None):

    '''Open a Leo outline from a .leo file, but do not read any derived files.'''

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        g.chdir(fileName)
        c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
        frame.deiconify()
        frame.lift()
        g.app.root.update() # Force a screen redraw immediately.
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:",fileName)
#@-node:ekr.20031218072017.2839:readOutlineOnly
#@+node:ekr.20070915134101:readFileIntoNode
def readFileIntoNode (self,event=None):

    '''Read a file into a single node.'''

    c = self ; undoType = 'Read File Into Node'
    filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Read File Into Node",filetypes=filetypes,defaultextension=None)

    if fileName:    
        try:
            theFile = open(fileName,'r')
            g.chdir(fileName)
            s = theFile.read()
            s = '@nocolor\n' + s
            # c.beginUpdate()
            # try:
            w = c.frame.body.bodyCtrl
            p = c.insertHeadline(op_name=undoType)
            p.setHeadString('@read-file-into-node ' + fileName)
            p.setBodyString(s)
            w.setAllText(s)
            # finally:
            c.redraw() # was c.endUpdate()
        except:
            g.es("can not open:",fileName)
#@-node:ekr.20070915134101:readFileIntoNode
#@+node:ekr.20070915142635:writeFileFromNode
def writeFileFromNode (self,event=None):

    # If node starts with @read-file-into-node, use the full path name in the headline.
    # Otherwise, prompt for a file name.

    c = self ; p = c.currentPosition()
    h = p.headString().rstrip()
    s = p.bodyString()
    tag = '@read-file-into-node'

    if h.startswith(tag):
        fileName = h[len(tag):].strip()
    else:
        fileName = None

    if not fileName:
        filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
        fileName = g.app.gui.runSaveFileDialog(
            initialfile=None,
            title='Write File From Node',
            filetypes=filetypes,
            defaultextension=None)
    if fileName:
        try:
            theFile = open(fileName,'w')
            g.chdir(fileName)
        except IOError:
            theFile = None
        if theFile:
            if s.startswith('@nocolor\n'):
                s = s[len('@nocolor\n'):]
            theFile.write(s)
            theFile.flush()
            g.es_print('wrote:',fileName,color='blue')
            theFile.close()
        else:
            g.es('can not write %s',fileName,color='red')
#@nonl
#@-node:ekr.20070915142635:writeFileFromNode
#@+node:ekr.20031218072017.1809:importDerivedFile
def importDerivedFile (self,event=None):

    """Create a new outline from a 4.0 derived file."""

    c = self ; p = c.currentPosition()

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        g.chdir(names[0])
        c.importCommands.importDerivedFiles(parent=p,paths=names)
#@-node:ekr.20031218072017.1809:importDerivedFile
#@+node:ekr.20031218072017.2849:Import&Export submenu
#@+node:ekr.20031218072017.2850:exportHeadlines
def exportHeadlines (self,event=None):

    '''Export all headlines to an external file.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.exportHeadlines(fileName)
#@-node:ekr.20031218072017.2850:exportHeadlines
#@+node:ekr.20031218072017.2851:flattenOutline
def flattenOutline (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in MORE format.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.flattenOutline(fileName)
#@-node:ekr.20031218072017.2851:flattenOutline
#@+node:ekr.20031218072017.2852:importAtRoot
def importAtRoot (self,event=None):

    '''Import one or more external files, creating @root trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFilesCommand (names,"@root")
#@-node:ekr.20031218072017.2852:importAtRoot
#@+node:ekr.20031218072017.2853:importAtFile
def importAtFile (self,event=None):

    '''Import one or more external files, creating @file trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFilesCommand(names,"@file")
#@-node:ekr.20031218072017.2853:importAtFile
#@+node:ekr.20031218072017.2854:importCWEBFiles
def importCWEBFiles (self,event=None):

    '''Import one or more external CWEB files, creating @file trees.'''

    c = self

    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importWebCommand(names,"cweb")
#@-node:ekr.20031218072017.2854:importCWEBFiles
#@+node:ekr.20031218072017.2855:importFlattenedOutline
def importFlattenedOutline (self,event=None):

    '''Import an external created by the flatten-outline command.'''

    c = self

    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFlattenedOutline(names)
#@-node:ekr.20031218072017.2855:importFlattenedOutline
#@+node:ekr.20031218072017.2856:importNowebFiles
def importNowebFiles (self,event=None):

    '''Import one or more external noweb files, creating @file trees.'''

    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importWebCommand(names,"noweb")
#@-node:ekr.20031218072017.2856:importNowebFiles
#@+node:ekr.20031218072017.2857:outlineToCWEB
def outlineToCWEB (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in CWEB format.'''

    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.outlineToWeb(fileName,"cweb")
#@-node:ekr.20031218072017.2857:outlineToCWEB
#@+node:ekr.20031218072017.2858:outlineToNoweb
def outlineToNoweb (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in noweb format.'''

    c = self

    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName
#@-node:ekr.20031218072017.2858:outlineToNoweb
#@+node:ekr.20031218072017.2859:removeSentinels
def removeSentinels (self,event=None):

    '''Import one or more files, removing any sentinels.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.removeSentinelsCommand (names)
#@-node:ekr.20031218072017.2859:removeSentinels
#@+node:ekr.20031218072017.2860:weave
def weave (self,event=None):

    '''Simulate a literate-programming weave operation by writing the outline to a text file.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.weave(fileName)
#@-node:ekr.20031218072017.2860:weave
#@-node:ekr.20031218072017.2849:Import&Export submenu
#@-node:ekr.20080606074139.3:Changed
#@-node:ekr.20080606074139.1:Set cwd in read/write commands
#@+node:ekr.20080611105410.145:Added  vim patches
@nocolor

Headline pane:

- (Done) Prevent "--> exit-named-modes" from switching focus to the Body pane.
    Removed 'c.frame.log.deleteTab('Mode') from endMode

Body pane:

- (Done) Enable search for 'space' character in text
    Removed 'if ch.isspace(): return' in zapToCharacter:

- (Done) Eliminate delete-word from removing trailing white space
    Removed 'self.killWs(event)' in killWord and backwardKillWord

- (Done) Put zapped text to clipboard
    Added 'g.app.gui.replaceClipboardWith(s[ins:i])' after 'sel.addToKillBuffer(s[ins:i])' in zapToCharacter

@color
#@nonl
#@+node:ekr.20061031131434.159:endMode
def endMode(self,event):

    k = self ; c = k.c

    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.

    if w:
        c.widgetWantsFocusNow(w)
#@-node:ekr.20061031131434.159:endMode
#@+node:ekr.20050920084036.128:zapToCharacter
def zapToCharacter (self,event):

    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        ch = event and event.char or ' '
        k.resetLabel()
        k.clearState()
        s = w.getAllText()
        ins = w.getInsertPoint()
        i = s.find(ch,ins)
        if i == -1: return
        self.beginCommand(undoType='zap-to-char')
        self.addToKillBuffer(s[ins:i])
        g.app.gui.replaceClipboardWith(s[ins:i]) # Support for proper yank.
        w.setAllText(s[:ins] + s[i:])
        w.setInsertPoint(ins)
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.128:zapToCharacter
#@+node:ekr.20050920084036.180:backwardKillWord & killWord
def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    # self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    # self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20050920084036.180:backwardKillWord & killWord
#@-node:ekr.20080611105410.145:Added  vim patches
#@+node:ekr.20061014050154.2:Added 'kill' bindings
Should assigning to None clear all key bindings?
#@nonl
#@+node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    if g.app.oneConfigFilename:
        table = ((g.app.oneConfigFilename,False),)
    else:
        table = (
            (self.globalConfigFile,False),
            (self.homeFile,False),
            (localConfigFile,False),
            (self.myGlobalConfigFile,False),
            (self.myHomeConfigFile,False),
            (self.machineConfigFile,False),
            (myLocalConfigFile,False),
            (fileName,True),
        )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_abspath(g.os_path_normpath(path)))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace('=' * 20, c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@-node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041120105609:doShortcuts (ParserBaseClass)
def doShortcuts(self,p,kind,name,val,s=None):

    # __pychecker__ = '--no-argsused' # kind,val.

    # g.trace(self.c.fileName(),name)

    c = self.c ; d = self.shortcutsDict ; k = c.k
    trace = False or c.config.getBool('trace_bindings_verbose')
    munge = k.shortcutFromSetting
    if s is None: s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            # if name in ('save-file','enter-tree-save-file-mode'): g.pdb()
            if bunch is not None:
                if bunch.val not in (None,'none','None'):
                    # A regular shortcut.
                    bunchList = d.get(name,[])
                    if bunch.pane in ('kill','Kill'):
                        if trace: g.trace('****** killing binding:',bunch.val,'to',name)
                        bunchList = [z for z in bunchList
                            if munge(z.val) != munge(bunch.val)]
                        # g.trace(bunchList)
                    else:
                        if trace: g.trace('%6s %20s %s' % (bunch.pane,bunch.val,name))
                        bunchList.append(bunch)
                    d [name] = bunchList
                    self.set(p,"shortcut",name,bunchList)
                    self.setShortcut(name,bunchList)
#@-node:ekr.20041120105609:doShortcuts (ParserBaseClass)
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    << trace bindings >>
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.91:<< trace bindings >>
if c.config.getBool('trace_bindings_verbose'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)
#@-node:ekr.20061031131434.91:<< trace bindings >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print('redefining','shortcut %20s' % (shortcut),
            'from',z,'(%s)' % (b2.pane),
            'to',commandName,'(%s)' % (pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@+node:ekr.20080617073917.1:Error messages
C:\leo.repo\trunk>python leo\core\runLeo.py leo\test\test.leo
reading settings in C:\leo.repo\trunk\leo\config\leoSettings.leo
readSettings: ==================== C:\leo.repo\trunk\leo\config\leoSettings.leo
doShortcuts:   tree               Return end-edit-headline
doShortcuts:   body               Return insert-newline
doShortcuts:   text              LtArrow back-char
doShortcuts:   text              RtArrow forward-char
doShortcuts:   text              DnArrow next-line
doShortcuts:   text              UpArrow previous-line
doShortcuts:   text        Shift-LtArrow back-char-extend-selection
doShortcuts:   text        Shift-RtArrow forward-char-extend-selection
doShortcuts:   text        Shift-DnArrow next-line-extend-selection
doShortcuts:   text        Shift-UpArrow previous-line-extend-selection
doShortcuts:   tree              LtArrow contract-or-go-left
doShortcuts:   tree              RtArrow expand-and-go-right
doShortcuts:   tree              DnArrow goto-next-visible
doShortcuts:   tree              UpArrow goto-prev-visible
doShortcuts:   tree        Shift-DnArrow move-outline-down
doShortcuts:   tree        Shift-LtArrow move-outline-left
doShortcuts:   tree        Shift-RtArrow move-outline-right
doShortcuts:   tree        Shift-UpArrow move-outline-up
doShortcuts:    all          Alt-LtArrow contract-or-go-left
doShortcuts:    all          Alt-RtArrow expand-and-go-right
doShortcuts:    all          Alt-DnArrow goto-next-visible
doShortcuts:    all          Alt-UpArrow goto-prev-visible
doShortcuts:    all    Alt-Shift-DnArrow move-outline-down
doShortcuts:    all    Alt-Shift-LtArrow move-outline-left
doShortcuts:    all    Alt-Shift-RtArrow move-outline-right
doShortcuts:    all    Alt-Shift-UpArrow move-outline-up
doShortcuts:    all             Alt-Home goto-first-visible-node
doShortcuts:    all              Alt-End goto-last-visible-node
doShortcuts:    all             Ctrl-tab cycle-focus
doShortcuts:    all       Ctrl-Shift-tab cycle-all-focus
doShortcuts:    all         Ctrl-LtArrow back-word
doShortcuts:    all   Ctrl-Shift-LtArrow back-word-extend-selection
doShortcuts:    all            Ctrl-Home beginning-of-buffer
doShortcuts:    all      Ctrl-Shift-Home beginning-of-buffer-extend-selection
doShortcuts:    all             Ctrl-End end-of-buffer
doShortcuts:    all       Ctrl-Shift-End end-of-buffer-extend-selection
doShortcuts:    all         Ctrl-RtArrow forward-word
doShortcuts:    all   Ctrl-Shift-RtArrow forward-word-extend-selection
doShortcuts:    all                 Home beginning-of-line
doShortcuts:    all           Shift-Home beginning-of-line-extend-selection
doShortcuts:    all                  End end-of-line
doShortcuts:    all            Shift-End end-of-line-extend-selection
doShortcuts:    all               PageDn scroll-down
doShortcuts:    all         Shift-PageDn scroll-down-extend-selection
doShortcuts:    all               PageUp scroll-up
doShortcuts:    all         Shift-PageUp scroll-up-extend-selection
doShortcuts:    all                Alt-b back-word
doShortcuts:    all          Alt-Shift-b back-word-extend-selection
doShortcuts:    all           Ctrl-space back-to-indentation
doShortcuts:    all               Ctrl-a beginning-of-line
doShortcuts:    all         Ctrl-Shift-a beginning-of-line-extend-selection
doShortcuts:    all               Ctrl-e end-of-line
doShortcuts:    all                Alt-M exchange-point-mark
doShortcuts:    all         Ctrl-Shift-e end-of-line-extend-selection
doShortcuts:    all                Alt-L extend-to-line
doShortcuts:    all               Ctrl-W extend-to-word
doShortcuts:    all       Alt-braceright forward-paragraph
doShortcuts:    all Alt-Shift-braceright forward-paragraph-extend-selection
doShortcuts:    all                Alt-g goto-global-line
doShortcuts:    all       Alt-parenright move-past-close
doShortcuts:    all          Alt-Shift-A select-all
doShortcuts:    all               Alt-F4 close-window
doShortcuts:    all               Ctrl-q exit-leo
doShortcuts:    all               Ctrl-n new
doShortcuts:    all               Ctrl-o open-outline
doShortcuts:    all               Ctrl-s save-file
doShortcuts:    all         Shift-Ctrl-W write-at-file-nodes
doShortcuts:    all         Shift+Ctrl+Q write-dirty-at-file-nodes
doShortcuts:    all                Alt-Q backward-find-character
doShortcuts:    all          Alt-Shift-Q backward-find-character-extend-selection
doShortcuts:    all               Ctrl-f search-with-present-options
doShortcuts:    all         Ctrl-Shift-r replace-string
doShortcuts:    all                Alt-R isearch-backward
doShortcuts:    all                Alt-S isearch-forward
doShortcuts:    all                   F3 find-next
doShortcuts:    all                   F2 find-prev
doShortcuts:    all               Ctrl-= change
doShortcuts:    all               Ctrl-- change-then-find
doShortcuts:    all           Alt-Ctrl-e set-find-everywhere
doShortcuts:    all           Alt-Ctrl-n set-find-node-only
doShortcuts:    all           Alt-Ctrl-s set-find-suboutline-only
doShortcuts:    all           Alt-Ctrl-i toggle-find-ignore-case-option
doShortcuts:    all           Alt-Ctrl-b toggle-find-in-body-option
doShortcuts:    all           Alt-Ctrl-h toggle-find-in-headline-option
doShortcuts:    all           Alt-Ctrl-c toggle-find-mark-changes-option
doShortcuts:    all           Alt-Ctrl-f toggle-find-mark-finds-option
doShortcuts:    all           Alt-Ctrl-x toggle-find-regex-option
doShortcuts:    all           Alt-Ctrl-r toggle-find-reverse-option
doShortcuts:    all           Alt-Ctrl-w toggle-find-word-option
doShortcuts:    all           Alt-Ctrl-a toggle-find-wrap-around-option
doShortcuts:    all           Alt+Ctrl+- contract-pane
doShortcuts:    all           Alt+Ctrl-= expand-pane
doShortcuts:    all                Alt-d focus-to-body
doShortcuts:    all                Alt-t focus-to-tree
doShortcuts:    all               Ctrl-t toggle-active-pane
doShortcuts:    all               Ctrl-g keyboard-quit
doShortcuts:    all          Alt-Shift-i start-ipython
doShortcuts:    all                Alt-i push-to-ipython
doShortcuts:    all                Alt-C propagate-key-event
doShortcuts:    all                Alt-E propagate-key-event
doShortcuts:    all                Alt-F propagate-key-event
doShortcuts:    all                Alt-H propagate-key-event
doShortcuts:    all                Alt-P propagate-key-event
doShortcuts:    all                Alt-O propagate-key-event
doShortcuts:    all                Alt-W propagate-key-event
doShortcuts:    all                Alt-x full-command
doShortcuts:    all               Ctrl-P repeat-complex-command
doShortcuts:    all                Alt-u universal-argument
doShortcuts:    all               period auto-complete
doShortcuts:    all               Ctrl+B execute-script
doShortcuts:    all                   F1 help-for-command
doShortcuts:    all                   F7 open-spell-tab
doShortcuts:    all         Shift-Ctrl-Z redo
doShortcuts:    all                Alt-4 run-unit-tests-locally
doShortcuts:    all            parenleft show-calltips
doShortcuts:    all                Alt-A sort-siblings
doShortcuts:    all                Alt-1 toggle-autocompleter
doShortcuts:    all                Alt-2 toggle-calltips
doShortcuts:    all                Alt-3 toggle-extend-mode
doShortcuts:    all               Ctrl-Z undo
doShortcuts:    all               Ctrl-` clone-node
doShortcuts:    all         Shift-Ctrl-c copy-node
doShortcuts:    all         Shift-Ctrl-x cut-node
doShortcuts:    all                Alt-- contract-all
doShortcuts:    all               Ctrl-h edit-headline
doShortcuts:    all               Ctrl-} demote
doShortcuts:    all     Alt-bracketright expand-node
doShortcuts:    all         Shift-Ctrl-D extract
doShortcuts:    all         Shift-Ctrl-N extract-names
doShortcuts:    all         Shift-Ctrl-S extract-section
doShortcuts:    all                Alt-N goto-next-clone
doShortcuts:    all               Ctrl-I insert-node
doShortcuts:    all               Ctrl-M mark
doShortcuts:    all               Ctrl-D move-outline-down
doShortcuts:    all               Ctrl-L move-outline-left
doShortcuts:    all               Ctrl-R move-outline-right
doShortcuts:    all               Ctrl-U move-outline-up
doShortcuts:    all         Shift-Ctrl-V paste-node
doShortcuts:    all               Ctrl-{ promote
doShortcuts:    all       Ctrl-parenleft add-comments
doShortcuts:    all            BackSpace backward-delete-char
doShortcuts:    all           Alt-Delete backward-kill-word
doShortcuts:    all               Ctrl-c copy-text
doShortcuts:    all               Ctrl-x cut-text
doShortcuts:    all               Delete delete-char
doShortcuts:    all      Ctrl-parenright delete-comments
doShortcuts:    all               Ctrl-] indent-region
doShortcuts:    all               Ctrl-k kill-line
doShortcuts:    all               Ctrl-j newline-and-indent
doShortcuts:    all               Ctrl-v paste-text
doShortcuts:    all         Shift-Ctrl-p reformat-paragraph
doShortcuts:    all               Ctrl-[ unindent-region
doShortcuts:    all               Ctrl-Y yank
doShortcuts:    all                Alt-Y yank-pop
doShortcuts:    all                Alt-z zap-to-character
doShortcuts: ****** killing binding: Alt+m to exchange-point-mark
doShortcuts:   tree                    : enter-tree-command-line-mode
doShortcuts:   tree               Ctrl-: full-command
doShortcuts:   tree               Ctrl-s enter-tree-save-file-mode
doShortcuts:   tree                    u enter-tree-undo-mode
doShortcuts:   tree               Ctrl-r enter-tree-redo-mode
doShortcuts:   body                  Tab enter-focus-to-tree-mode
doShortcuts:   tree                  Tab enter-focus-to-body-mode
doShortcuts:   tree                    = enter-tree-double-click-node-mode
doShortcuts:   tree                Alt-g goto-global-line
doShortcuts:   tree                    i set-insert-state
doShortcuts:   tree               Ctrl-i edit-headline
doShortcuts:   tree               Ctrl-[ set-command-state
doShortcuts:   tree                  Esc set-command-state
doShortcuts:   tree               return set-command-state
doShortcuts:   tree               Ctrl-] end-edit-headline
doShortcuts:   tree              Shift-y end-of-line-extend-selection
doShortcuts:   tree                Alt-y copy-text
doShortcuts:   tree                    v toggle-extend-mode
doShortcuts:   tree              Shift-c end-of-line-extend-selection
doShortcuts:   tree                    c enter-tree-select-object-mode
doShortcuts:   tree                    s forward-char-extend-selection
doShortcuts:   tree              Shift-s select-all
doShortcuts:   tree              Shift-d end-of-line-extend-selection
doShortcuts:   tree                    d enter-tree-delete-text-object-mode
doShortcuts:   tree                    x delete-char
doShortcuts:   tree               delete delete-char
doShortcuts:   tree               Ctrl-b scroll-outline-up-line
doShortcuts:   tree               Ctrl-f scroll-outline-down-line
doShortcuts:   tree               Ctrl-u scroll-outline-up-line
doShortcuts:   tree               Ctrl-d scroll-outline-down-line
doShortcuts:   tree               Ctrl-y scroll-outline-up-line
doShortcuts:   tree               Ctrl-e scroll-outline-down-line
doShortcuts:   tree              RtArrow forward-char
doShortcuts:   tree                    l forward-char
doShortcuts:   tree              LtArrow back-char
doShortcuts:   tree                    h back-char
doShortcuts:   tree                    w forward-word
doShortcuts:   tree              Shift-w forward-word-extend-selection
doShortcuts:   tree                    b back-word
doShortcuts:   tree              Shift-b back-word-extend-selection
doShortcuts:   tree                    e forward-end-word
doShortcuts:   tree              Shift-e forward-end-word-extend-selection
doShortcuts:   tree                    | beginning-of-line
doShortcuts:   tree                    $ end-of-line
doShortcuts:   tree                    % match-brackets
doShortcuts:   tree                    f find-character
doShortcuts:   tree              Shift-f backward-find-character
doShortcuts:   tree                    g enter-tree-goto-mode
doShortcuts:   tree              Shift-g enter-tree-goto-last-node-mode
doShortcuts:   tree               Ctrl-j enter-tree-goto-next-visible-mode
doShortcuts:   tree              DnArrow enter-tree-goto-next-visible-mode
doShortcuts:   tree         Ctrl-DnArrow enter-tree-goto-next-visible-mode
doShortcuts:   body               Ctrl-j enter-body-goto-next-visible-mode
doShortcuts:   body         Ctrl-DnArrow enter-body-goto-next-visible-mode
doShortcuts:   tree               Ctrl-k enter-tree-goto-prev-visible-mode
doShortcuts:   tree              UpArrow enter-tree-goto-prev-visible-mode
doShortcuts:   tree         Ctrl-UpArrow enter-tree-goto-prev-visible-mode
doShortcuts:   body               Ctrl-k enter-body-goto-prev-visible-mode
doShortcuts:   body         Ctrl-UpArrow enter-body-goto-prev-visible-mode
doShortcuts:   tree               Ctrl-h enter-tree-contract-or-go-left-mode
doShortcuts:   tree         Ctrl-LtArrow enter-tree-contract-or-go-left-mode
doShortcuts:   body               Ctrl-h enter-body-contract-or-go-left-mode
doShortcuts:   body         Ctrl-LtArrow enter-body-contract-or-go-left-mode
doShortcuts:   tree               Ctrl-l enter-tree-expand-and-go-right-mode
doShortcuts:   tree         Ctrl-RtArrow enter-tree-expand-and-go-right-mode
doShortcuts:   body               Ctrl-l enter-body-expand-and-go-right-mode
doShortcuts:   body         Ctrl-RtArrow enter-body-expand-and-go-right-mode
doShortcuts:   tree                    / search-forward
doShortcuts:   tree                    n find-next
doShortcuts:   tree              Shift-n find-prev
doShortcuts:   tree               Ctrl-o insert-node
doShortcuts:   tree               Ctrl-c enter-tree-copy-node-mode
doShortcuts:   tree               Ctrl-x enter-tree-delete-node-mode
doShortcuts:   tree               Ctrl-v enter-tree-paste-node-mode
doShortcuts:   tree         Ctrl-Shift-j enter-tree-move-outline-down-mode
doShortcuts:   tree         Ctrl-Shift-h enter-tree-move-outline-left-mode
doShortcuts:   tree         Ctrl-Shift-l enter-tree-move-outline-right-mode
doShortcuts:   tree         Ctrl-Shift-k enter-tree-move-outline-up-mode
doShortcuts:   tree   Ctrl-Shift-DnArrow enter-tree-move-outline-down-mode
doShortcuts:   tree   Ctrl-Shift-LtArrow enter-tree-move-outline-left-mode
doShortcuts:   tree   Ctrl-Shift-RtArrow enter-tree-move-outline-right-mode
doShortcuts:   tree   Ctrl-Shift-UpArrow enter-tree-move-outline-up-mode
doShortcuts:   tree                    t enter-tree-clone-node-mode
doShortcuts:   tree               Ctrl-t enter-tree-goto-next-clone-node-mode
doShortcuts:   tree                    m enter-tree-mark-node-mode
doShortcuts:   tree               Ctrl-m enter-tree-goto-next-marked-node-mode
doShortcuts:   tree                Alt-m enter-tree-unmark-all-nodes-mode
doShortcuts:   body                    : enter-vi-command-line-mode
doShortcuts:    all         Ctrl-Shift-: full-command
doShortcuts:   body               Ctrl-[ keyboard-quit
doShortcuts:   body                  esc keyboard-quit
doShortcuts:   body                    = double-click-icon-box
doShortcuts:    all                    u undo
doShortcuts:    all               Ctrl-r redo
doShortcuts:    all              Shift-z enter-vi-save-buffers-exit-mode
doShortcuts:   body              Shift-i enter-vi-insert-at-indent-mode
doShortcuts:   body                    i set-insert-state
doShortcuts:   body                    a set-insert-state
doShortcuts:   body              Shift-a enter-vi-append-mode
doShortcuts:   body              Shift-r set-overwrite-state
doShortcuts:   body                    o enter-vi-new-line-below-mode
doShortcuts:   body              Shift-o enter-vi-new-line-above-mode
doShortcuts:   body              Shift-c enter-vi-change-to-end-of-line-mode
doShortcuts:   body                    c enter-vi-change-mode
doShortcuts:   body                    s enter-vi-substitute-char-mode
doShortcuts:   body              Shift-s enter-vi-substitute-line-mode
doShortcuts:   body                    d enter-vi-delete-object-mode
doShortcuts:   body              Shift-d enter-vi-delete-to-end-of-line-mode
doShortcuts:   body                    x delete-char
doShortcuts:   body               delete delete-char
doShortcuts:   body              Shift-y enter-vi-yank-to-end-of-line-mode
doShortcuts:   body                    y enter-vi-yank-mode
doShortcuts:   body                Alt-y copy-text
doShortcuts:   body                    v toggle-extend-mode
doShortcuts:   body              Shift-p paste-text
doShortcuts:   body                    p paste-text
doShortcuts:   body              greater enter-vi-indent-mode
doShortcuts:   body                 less enter-vi-deindent-mode
doShortcuts:   body              Shift-j enter-vi-join-mode
doShortcuts:   body                    h back-char
doShortcuts:   body              LtArrow back-char
doShortcuts:   body                    l forward-char
doShortcuts:   body              RtArrow forward-char
doShortcuts:   body                    w forward-word
doShortcuts:   body              Shift-w forward-word
doShortcuts:   body                    b back-word
doShortcuts:   body              Shift-b back-word
doShortcuts:   body                    e forward-end-word
doShortcuts:   body              Shift-e forward-end-word
doShortcuts:   body                    | enter-vi-beginning-of-line-mode
doShortcuts:   body                    ^ back-to-indentation
doShortcuts:   body                    $ enter-vi-end-of-line-mode
doShortcuts:   body                minus enter-vi-goto-indent-of-previous-line-mode
doShortcuts:   body                    j next-line
doShortcuts:   body              DnArrow next-line
doShortcuts:   body                    k previous-line
doShortcuts:   body              UpArrow previous-line
doShortcuts:   body                    ) forward-sentence
doShortcuts:   body                    ( back-sentence
doShortcuts:   body                    } enter-vi-goto-after-paragraph-mode
doShortcuts:   body                    { enter-vi-goto-before-paragraph-mode
doShortcuts:   body                    g enter-vi-goto-mode
doShortcuts:   body              Shift-g enter-vi-goto-end-of-buffer-mode
doShortcuts:   body               Ctrl-g goto-line
doShortcuts:   body                    % enter-vi-match-mode
doShortcuts:   body               Ctrl-b scroll-up
doShortcuts:   body               Ctrl-f scroll-down
doShortcuts:   body               Ctrl-u scroll-up
doShortcuts:   body               Ctrl-d scroll-down
doShortcuts:   body               Ctrl-y scroll-up
doShortcuts:   body               Ctrl-e scroll-down
doShortcuts:   body               Ctrl-w enter-vim-window-commands-mode
doShortcuts:   body                    f find-character
doShortcuts:   body              Shift-f backward-find-character
doShortcuts:   body                    / search-forward
doShortcuts:   body             question search-backward
doShortcuts:   body                    n find-next
doShortcuts:   body              Shift-n find-prev
reading settings in C:\Documents and Settings\HP_Administrator\My Documents\Edward\myLeoSettings.leo
readSettings: ==================== C:\Documents and Settings\HP_Administrator\My Documents\Edward\myLeoSettings.leo
doShortcuts:    all                Alt-9 enter-headline-mode
reading settings in C:\leo.repo\trunk\leo\test\test.leo
readSettings: ==================== C:\leo.repo\trunk\leo\test\test.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leoRecentFiles.txt
@enabled-plugins found in test.leo
wiki markup enabled
rst3 plugin: SilverCity not loaded
redefining shortcut                 Left from back-char (body) to contract-or-go-left (tree)
warning: ignoring bool enablecalltips is not shortcut
there may be conflicting settings!
redefining shortcut                Alt+m from enter-tree-unmark-all-nodes-mode (tree) to exchange-point-mark (all)
redefining shortcut               Ctrl+w from enter-vim-window-commands-mode (body) to extend-to-word (all)
redefining shortcut                Right from expand-and-go-right (text) to forward-char (tree)
redefining shortcut           Ctrl+Right from enter-body-expand-and-go-right-mode (tree) to forward-word (all)
redefining shortcut           Ctrl+Right from enter-tree-expand-and-go-right-mode (tree) to forward-word (all)
redefining shortcut     Ctrl+Shift+Right from enter-tree-move-outline-right-mode (tree) to forward-word-extend-selection (all)
redefining shortcut                 Down from enter-tree-goto-next-visible-mode (tree) to goto-next-visible (tree)
redefining shortcut                   Up from enter-tree-goto-prev-visible-mode (tree) to goto-prev-visible (tree)
redefining shortcut    Ctrl+bracketright from end-edit-headline (tree) to indent-region (all)
redefining shortcut               Ctrl+i from edit-headline (tree) to insert-node (all)
redefining shortcut               Ctrl+g from goto-line (body) to keyboard-quit (all)
redefining shortcut               Ctrl+m from enter-tree-goto-next-marked-node-mode (tree) to mark (all)
redefining shortcut               Ctrl+l from enter-body-expand-and-go-right-mode (tree) to move-outline-left (all)
redefining shortcut               Ctrl+l from enter-tree-expand-and-go-right-mode (tree) to move-outline-left (all)
redefining shortcut               Ctrl+r from enter-tree-redo-mode (tree) to move-outline-right (all)
redefining shortcut               Ctrl+j from enter-body-goto-next-visible-mode (tree) to newline-and-indent (all)
redefining shortcut               Ctrl+j from enter-tree-goto-next-visible-mode (tree) to newline-and-indent (all)
redefining shortcut               Ctrl+o from insert-node (tree) to open-outline (all)
redefining shortcut               Ctrl+v from enter-tree-paste-node-mode (tree) to paste-text (all)
redefining shortcut               Ctrl+r from move-outline-right (all) to redo (all)
redefining shortcut               Ctrl+f from scroll-down (tree) to search-with-present-options (all)
redefining shortcut               Ctrl+f from scroll-outline-down-line (tree) to search-with-present-options (all)
redefining shortcut               Return from end-edit-headline (body) to set-command-state (tree)
redefining shortcut            parenleft from back-sentence (body) to show-calltips (all)
redefining shortcut                    u from enter-tree-undo-mode (tree) to undo (all)
redefining shortcut     Ctrl+bracketleft from keyboard-quit (tree) to unindent-region (all)
redefining shortcut     Ctrl+bracketleft from set-command-state (tree) to unindent-region (all)
redefining shortcut               Ctrl+y from scroll-outline-up-line (body) to yank (all)
redefining shortcut               Ctrl+y from scroll-up (body) to yank (all)
redefining shortcut                Alt+y from copy-text (body) to yank-pop (all)
redefining shortcut                Alt+y from copy-text (body) to yank-pop (all)
#@-node:ekr.20080617073917.1:Error messages
#@-node:ekr.20061014050154.2:Added 'kill' bindings
#@+node:ekr.20080620095343.2:Added check for empty @nosent nodes
# These are now treated much like empty @auto nodes
#@nonl
#@+node:ekr.20041005105605.144:write & helper
# This is the entry point to the write code.  root should be an @file vnode.

def write (self,root,
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
    write_strips_blank_lines = None,
):

    """Write a 4.x derived file."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString,
        write_strips_blank_lines = write_strips_blank_lines)

    if nosentinels and not scriptWrite and not toString:
        fileName = g.os_path_normpath(g.os_path_join(at.default_directory,at.targetFileName))
        exists = g.os_path_exists(fileName)
        if not self.shouldWriteAtNosentNode(root,exists):
            return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except Exception:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    ### os.remove(at.outputFileName) # Delete the temp file.
    self.remove(at.outputFileName) # Delete the temp file.
    g.es("not written:",at.outputFileName)
else:
    at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@+node:ekr.20080620095343.1:shouldWriteAtNosentNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.That ' s too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the.leo file is opened.
- We don ' t want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtNosentNode (self,p,exists):

    '''Return True if we should write the @auto node at p.'''

    if not exists: # We can write a non-existent file without danger.
        return True
    elif self.isSignificantTree(p):
        return True # Assume the tree contains what should be written.
    else:
        g.es_print(p.headString(),'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='blue')
        return False
#@-node:ekr.20080620095343.1:shouldWriteAtNosentNode
#@-node:ekr.20041005105605.144:write & helper
#@-node:ekr.20080620095343.2:Added check for empty @nosent nodes
#@-node:ekr.20080408060320.783:Features
#@+node:ekr.20080529054218.2:Benchmarked the read code
To do:

- Use cProfile.
- Sort first by module, then by time (**not** cumulative)
#@nonl
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    # name = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','leoProfile.txt'))

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20051104075904.2:Support @profile, @suite, @test, @timer
#@+node:ekr.20051104075904.3:isSuiteNode and isTestNode
def isSuiteNode (p):
    h = p.headString().lower()
    return g.match_word(h,0,"@suite")

def isTestNode (p):
    h = p.headString().lower()
    return g.match_word(h,0,"@test")

# def isTestCaseNode (p):
    # h = p.headString().lower()
    # return g.match_word(h,0,"@testcase") or g.match_word(h,0,"@test-case")
#@-node:ekr.20051104075904.3:isSuiteNode and isTestNode
#@+node:ekr.20051104075904.4:doTests...
def doTests(c,all,verbosity=1):

    if all:
        p = c.rootPosition()
    else:
        p = c.currentPosition()
    p1 = p.copy()

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        if all: last = None
        else:   last = p.nodeAfterTree()
        while p and p != last:
            h = p.headString()
            if g.match_word(h,0,'@ignore'):
                p.moveToNodeAfterTree()
            elif isTestNode(p): # @test
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
                p.moveToThreadNext()
            elif isSuiteNode(p): # @suite
                # g.trace(p.headString())
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
                p.moveToThreadNext()
            else:
                p.moveToThreadNext()

        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
    finally:
        c.setChanged(changed) # Restore changed state.
        c.selectPosition(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20051104075904.5:class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20051104075904.6:__init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@-node:ekr.20051104075904.6:__init__
#@+node:ekr.20051104075904.7: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    # __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.7: fail
#@+node:ekr.20051104075904.8:setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
#@-node:ekr.20051104075904.8:setUp
#@+node:ekr.20051104075904.9:tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@nonl
#@-node:ekr.20051104075904.9:tearDown
#@+node:ekr.20051104075904.10:runTest
def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # import leo.core.leoGlobals as g

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p}
    else:
        d = {}

    # Execute the script. Let unit test handle any errors!

    if 0: # debug
        import pdb
        pdb.run(script+'\n',d)
    else:
        exec script + '\n' in d
#@-node:ekr.20051104075904.10:runTest
#@+node:ekr.20051104075904.11:shortDescription
def shortDescription (self):

    return self.p.headString() + '\n'
#@-node:ekr.20051104075904.11:shortDescription
#@-node:ekr.20051104075904.5:class generalTestCase
#@+node:ekr.20051104075904.12:makeTestSuite
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    # import leo.core.leoGlobals as g
    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        g.pr("no script in %s" % h)
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            g.pr("%s script did not set g.app.scriptDict" % h)
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None
#@-node:ekr.20051104075904.12:makeTestSuite
#@+node:ekr.20051104075904.13:makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None
#@-node:ekr.20051104075904.13:makeTestCase
#@-node:ekr.20051104075904.4:doTests...
#@+node:ekr.20051104075904.14:runProfileOnNode
# A utility for use by script buttons.

def runProfileOnNode (p,outputPath=None):

    s = p.bodyString().rstrip() + '\n'

    if outputPath is None:
        # outputPath = g.os_path_abspath(
            # g.os_path_join(
                # g.app.loadDir,'..','test','profileStats'))
        outputPath = name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"

    profile.run(s,outputPath)

    if 1:
        stats = pstats.Stats(outputPath)
        stats.strip_dirs()
        stats.sort_stats('cum','file','name')
        stats.print_stats()
#@-node:ekr.20051104075904.14:runProfileOnNode
#@+node:ekr.20051104075904.15:runTimerOnNode
# A utility for use by script buttons.

def runTimerOnNode (c,p,count):

    s = p.bodyString().rstrip() + '\n'

    # A kludge so we the statement below can get c and p.
    g.app.unitTestDict = {'c':c,'p':p and p.copy()}

    # This looks like the best we can do.
    setup = 'import leo.core.leoGlobals as g; c = g.app.unitTestDict.get("c"); p = g.app.unitTestDict.get("p")'

    t = timeit.Timer(s,setup)

    try:
        if count is None:
            count = 1000000
        result = t.timeit(count)
        ratio = "%f" % (float(result)/float(count))
        g.es_print("count:",count,"time/count:",ratio,'',p.headString())
    except:
        t.print_exc()
#@-node:ekr.20051104075904.15:runTimerOnNode
#@-node:ekr.20051104075904.2:Support @profile, @suite, @test, @timer
#@+node:ekr.20080529114024.1:Stats
@killcolor

C:\leo.repo\trunk>python
Python 2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)] on win32

         881734 function calls (875681 primitive calls) in 17.168 CPU seconds

   Ordered by: file name, call count, internal time, function name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)

      412    0.001    0.000    0.001    0.000 cp1252.py:14(decode)
       14    0.000    0.000    0.000    0.000 cp1252.py:11(encode)
        3    0.000    0.000    0.000    0.000 cp437.py:11(encode)
        1    0.004    0.004    0.004    0.004 dis.py:1(<module>)


        1    0.004    0.004    0.004    0.004 expat.py:1(<module>)
     4254    0.014    0.000    0.122    0.000 expatreader.py:300(start_element)
     4254    0.006    0.000    0.051    0.000 expatreader.py:303(end_element)
        8    0.000    0.000    0.310    0.039 expatreader.py:196(feed)
        4    0.000    0.000    0.000    0.000 expatreader.py:244(reset)
        4    0.000    0.000    0.000    0.000 expatreader.py:223(_reset_cont_handler)
        2    0.000    0.000    0.000    0.000 expatreader.py:213(close)
        2    0.000    0.000    0.310    0.155 expatreader.py:100(parse)
        2    0.000    0.000    0.000    0.000 expatreader.py:87(__init__)
        2    0.000    0.000    0.000    0.000 expatreader.py:404(create_parser)
        2    0.000    0.000    0.000    0.000 expatreader.py:115(setContentHandler)
        2    0.000    0.000    0.000    0.000 expatreader.py:109(prepareParser)
        2    0.000    0.000    0.000    0.000 expatreader.py:54(__init__)
        2    0.000    0.000    0.000    0.000 expatreader.py:132(setFeature)
        1    0.008    0.008    0.013    0.013 expatreader.py:4(<module>)
        1    0.000    0.000    0.000    0.000 expatreader.py:84(ExpatParser)
        1    0.000    0.000    0.000    0.000 expatreader.py:48(ExpatLocator)

    14209    0.015    0.000    0.094    0.000 pyexpat.c:479(CharacterData)
     4254    0.005    0.000    0.127    0.000 pyexpat.c:604(StartElement)
     4254    0.005    0.000    0.056    0.000 pyexpat.c:656(EndElement)
        2    0.000    0.000    0.000    0.000 pyexpat.c:662(ProcessingInstruction)
        1    0.000    0.000    0.000    0.000 python.py:5(<module>)
      204    0.002    0.000    0.145    0.001 re.py:219(_compile)
      117    0.000    0.000    0.001    0.000 re.py:126(match)
       84    0.000    0.000    0.143    0.002 re.py:178(compile)
       11    0.000    0.000    0.000    0.000 re.py:196(escape)
        3    0.000    0.000    0.001    0.000 re.py:131(search)

     1686    0.001    0.000    0.001    0.000 sre_compile.py:24(_identityfunction)
   892/81    0.014    0.000    0.040    0.000 sre_compile.py:38(_compile)
      310    0.001    0.000    0.001    0.000 sre_compile.py:360(_simple)
      301    0.013    0.000    0.022    0.000 sre_compile.py:213(_optimize_charset)
      301    0.002    0.000    0.025    0.000 sre_compile.py:184(_compile_charset)
      162    0.000    0.000    0.000    0.000 sre_compile.py:480(isstring)
       88    0.005    0.000    0.005    0.000 sre_compile.py:264(_mk_bitmap)
       81    0.001    0.000    0.013    0.000 sre_compile.py:367(_compile_info)
       81    0.001    0.000    0.143    0.002 sre_compile.py:501(compile)
       81    0.000    0.000    0.053    0.001 sre_compile.py:486(_code)
       16    0.000    0.000    0.000    0.000 sre_compile.py:57(fixup)
        1    0.002    0.002    0.003    0.003 sre_compile.py:307(_optimize_unicode)
    11989    0.025    0.000    0.033    0.000 sre_parse.py:188(__next)
    10954    0.012    0.000    0.042    0.000 sre_parse.py:207(get)
     3665    0.003    0.000    0.006    0.000 sre_parse.py:201(match)
     3176    0.002    0.000    0.002    0.000 sre_parse.py:136(__getitem__)
     1553    0.001    0.000    0.002    0.000 sre_parse.py:132(__len__)
     1212    0.001    0.000    0.002    0.000 sre_parse.py:144(append)
 1129/415    0.006    0.000    0.008    0.000 sre_parse.py:146(getwidth)
      892    0.001    0.000    0.001    0.000 sre_parse.py:96(__init__)
   499/84    0.025    0.000    0.087    0.001 sre_parse.py:385(_parse)
   375/81    0.004    0.000    0.087    0.001 sre_parse.py:307(_parse_sub)
      310    0.001    0.000    0.001    0.000 sre_parse.py:140(__getslice__)
      310    0.000    0.000    0.000    0.000 sre_parse.py:138(__setitem__)
      231    0.000    0.000    0.000    0.000 sre_parse.py:216(isident)
      225    0.001    0.000    0.001    0.000 sre_parse.py:231(_class_escape)
      198    0.001    0.000    0.001    0.000 sre_parse.py:263(_escape)
      143    0.000    0.000    0.000    0.000 sre_parse.py:78(opengroup)
      143    0.000    0.000    0.000    0.000 sre_parse.py:89(closegroup)
       81    0.001    0.000    0.089    0.001 sre_parse.py:669(parse)
       81    0.000    0.000    0.000    0.000 sre_parse.py:184(__init__)
       81    0.000    0.000    0.000    0.000 sre_parse.py:73(__init__)
       38    0.000    0.000    0.000    0.000 sre_parse.py:222(isname)
        6    0.000    0.000    0.000    0.000 sre_parse.py:211(tell)
        2    0.000    0.000    0.000    0.000 sre_parse.py:219(isdigit)

        5    0.000    0.000    0.000    0.000 stat.py:29(S_IFMT)
        3    0.000    0.000    0.000    0.000 stat.py:45(S_ISDIR)
        2    0.000    0.000    0.000    0.000 stat.py:54(S_ISREG)

        1    0.006    0.006    0.007    0.007 statemachine.py:105(<module>)
        1    0.000    0.000    0.000    0.000 statemachine.py:115(StateMachine)
        1    0.000    0.000    0.000    0.000 statemachine.py:1041(ViewList)
        1    0.000    0.000    0.000    0.000 statemachine.py:867(StateWS)
        1    0.000    0.000    0.000    0.000 statemachine.py:489(State)
        1    0.000    0.000    0.000    0.000 statemachine.py:1297(StringList)
        1    0.000    0.000    0.000    0.000 statemachine.py:761(StateMachineWS)
        1    0.000    0.000    0.000    0.000 statemachine.py:1008(_SearchOverride)
        1    0.000    0.000    0.000    0.000 statemachine.py:1427(StateMachineError)
        1    0.000    0.000    0.000    0.000 statemachine.py:1437(TransitionCorrection)
        1    0.000    0.000    0.000    0.000 statemachine.py:1036(SearchStateMachineWS)
        1    0.000    0.000    0.000    0.000 statemachine.py:1433(TransitionMethodNotFound)
        1    0.000    0.000    0.000    0.000 statemachine.py:1428(UnknownStateError)
        1    0.000    0.000    0.000    0.000 statemachine.py:1031(SearchStateMachine)
        1    0.000    0.000    0.000    0.000 statemachine.py:1429(DuplicateStateError)
        1    0.000    0.000    0.000    0.000 statemachine.py:1434(UnexpectedIndentationError)
        1    0.000    0.000    0.000    0.000 statemachine.py:1431(DuplicateTransitionError)
        1    0.000    0.000    0.000    0.000 statemachine.py:1446(StateCorrection)
        1    0.000    0.000    0.000    0.000 statemachine.py:1432(TransitionPatternNotFound)
        1    0.000    0.000    0.000    0.000 statemachine.py:1430(UnknownTransitionError)

        7    0.000    0.000    0.000    0.000 states.py:132(__init__)
      5/1    0.000    0.000    0.007    0.007 states.py:416(build_regexp)
        1    0.017    0.017    0.122    0.122 states.py:101(<module>)
        1    0.000    0.000    0.033    0.033 states.py:985(Body)
        1    0.000    0.000    0.044    0.044 states.py:439(Inliner)
        1    0.000    0.000    0.000    0.000 states.py:2794(Line)
        1    0.000    0.000    0.000    0.000 states.py:2318(RFC2822Body)
        1    0.000    0.000    0.000    0.000 states.py:2583(Text)
        1    0.000    0.000    0.000    0.000 states.py:201(RSTState)
        1    0.000    0.000    0.001    0.001 states.py:2557(SubstitutionDef)
        1    0.000    0.000    0.000    0.000 states.py:2914(QuotedLiteralBlock)
        1    0.000    0.000    0.000    0.000 states.py:2364(SpecializedBody)
        1    0.000    0.000    0.000    0.000 states.py:2754(SpecializedText)
        1    0.000    0.000    0.000    0.000 states.py:2483(RFC2822List)
        1    0.000    0.000    0.000    0.000 states.py:2777(Definition)
        1    0.000    0.000    0.000    0.000 states.py:136(RSTStateMachine)
        1    0.000    0.000    0.000    0.000 states.py:128(Struct)
        1    0.000    0.000    0.000    0.000 states.py:2536(Explicit)
        1    0.000    0.000    0.000    0.000 states.py:2520(LineBlock)
        1    0.000    0.000    0.000    0.000 states.py:2456(FieldList)
        1    0.000    0.000    0.000    0.000 states.py:175(NestedStateMachine)
        1    0.000    0.000    0.000    0.000 states.py:2408(BulletList)
        1    0.000    0.000    0.000    0.000 states.py:2432(EnumeratedList)
        1    0.000    0.000    0.000    0.000 states.py:124(ParserError)
        1    0.000    0.000    0.000    0.000 states.py:2468(OptionList)
        1    0.000    0.000    0.000    0.000 states.py:122(UnknownInterpretedRoleError)
        1    0.000    0.000    0.000    0.000 states.py:2500(ExtensionOptions)
        1    0.000    0.000    0.000    0.000 states.py:2423(DefinitionList)
        1    0.000    0.000    0.000    0.000 states.py:121(MarkupError)
        1    0.000    0.000    0.000    0.000 states.py:123(InterpretedRoleNotImplementedError)
        1    0.000    0.000    0.000    0.000 states.py:125(MarkupMismatch)
    18311    0.024    0.000    0.024    0.000 string.py:349(find)
       16    0.000    0.000    0.000    0.000 string.py:509(replace)
        6    0.000    0.000    0.000    0.000 string.py:390(atoi)
        1    0.000    0.000    0.000    0.000 string.py:279(split)
        1    0.000    0.000    0.000    0.000 string.py:218(lower)

     4254    0.002    0.000    0.002    0.000 xmlreader.py:278(__init__)
     2845    0.002    0.000    0.002    0.000 xmlreader.py:290(getValue)
     2803    0.003    0.000    0.005    0.000 xmlreader.py:306(getNames)
        6    0.000    0.000    0.000    0.000 xmlreader.py:253(getByteStream)
        4    0.000    0.000    0.000    0.000 xmlreader.py:203(__init__)
        4    0.000    0.000    0.000    0.000 xmlreader.py:236(getEncoding)
        2    0.000    0.000    0.310    0.155 xmlreader.py:115(parse)
        2    0.000    0.000    0.000    0.000 xmlreader.py:24(__init__)
        2    0.000    0.000    0.000    0.000 xmlreader.py:111(__init__)
        2    0.000    0.000    0.000    0.000 xmlreader.py:38(setContentHandler)
        2    0.000    0.000    0.000    0.000 xmlreader.py:240(setByteStream)
        2    0.000    0.000    0.000    0.000 xmlreader.py:222(getSystemId)
        1    0.002    0.002    0.003    0.003 xmlreader.py:2(<module>)
        1    0.000    0.000    0.000    0.000 xmlreader.py:11(XMLReader)
        1    0.000    0.000    0.000    0.000 xmlreader.py:276(AttributesImpl)
        1    0.000    0.000    0.000    0.000 xmlreader.py:341(AttributesNSImpl)
        1    0.000    0.000    0.000    0.000 xmlreader.py:187(InputSource)
        1    0.000    0.000    0.000    0.000 xmlreader.py:91(IncrementalParser)
        1    0.000    0.000    0.000    0.000 xmlreader.py:163(Locator)
        2    0.000    0.000    0.000    0.000 zipfile.py:128(_EndRecData)
        2    0.000    0.000    0.001    0.001 zipfile.py:82(is_zipfile)

83742/83321    0.029    0.000    0.030    0.000 {len}
    55075    0.058    0.000    0.058    0.000 {method 'replace' of 'unicode' objects}
    52474    0.023    0.000    0.023    0.000 {method 'append' of 'list' objects}
    50753    0.029    0.000    0.029    0.000 {method 'get' of 'dict' objects}
    31516    0.011    0.000    0.011    0.000 {method 'isalnum' of 'unicode' objects}
    29332    0.016    0.000    0.016    0.000 {method 'lower' of 'unicode' objects}
    19837    0.013    0.000    0.013    0.000 {method 'replace' of 'str' objects}
    15341    0.005    0.000    0.005    0.000 {method 'isalnum' of 'str' objects}
     9902    0.007    0.000    0.007    0.000 {method 'lower' of 'str' objects}
     8813    0.013    0.000    0.013    0.000 {method 'join' of 'str' objects}
     7762    0.004    0.000    0.004    0.000 {method 'strip' of 'unicode' objects}
     6700    0.007    0.000    0.008    0.000 {method 'update' of 'dict' objects}
     6630    0.003    0.000    0.003    0.000 {method 'pop' of 'list' objects}
     6371    0.007    0.000    0.007    0.000 {method 'startswith' of 'unicode' objects}
     6315    0.003    0.000    0.003    0.000 {method 'strip' of 'str' objects}
     5914    0.004    0.000    0.004    0.000 {method 'keys' of 'dict' objects}
     5592    0.005    0.000    0.005    0.000 {method 'find' of 'unicode' objects}
3888/3778    0.185    0.000    0.189    0.000 {built-in method call}
     3855    0.003    0.000    0.003    0.000 {method 'endswith' of 'unicode' objects}
     3282    0.008    0.000    0.008    0.000 {method 'split' of 'unicode' objects}
     2787    0.003    0.000    0.003    0.000 {method 'lstrip' of 'unicode' objects}
     2769    0.001    0.000    0.001    0.000 {callable}
     2756    0.004    0.000    0.004    0.000 {repr}
     2743    0.001    0.000    0.001    0.000 {id}
     2541    0.007    0.000    0.007    0.000 {built-in method createcommand}
     2515    0.008    0.000    0.008    0.000 {built-in method deletecommand}
     2346    0.005    0.000    0.005    0.000 {nt._getfullpathname}
     2012    0.003    0.000    0.003    0.000 {hasattr}
     1865    0.001    0.000    0.001    0.000 {min}
     1729    0.001    0.000    0.001    0.000 {ord}
     1704    0.002    0.000    0.002    0.000 {method 'has_key' of 'dict' objects}
     1693    0.001    0.000    0.001    0.000 {method 'startswith' of 'str' objects}
     1243    0.001    0.000    0.001    0.000 {method 'items' of 'dict' objects}
     1110    0.001    0.000    0.001    0.000 {method 'capitalize' of 'str' objects}
      765    0.001    0.000    0.001    0.000 {method 'rfind' of 'unicode' objects}
      761    0.001    0.000    0.001    0.000 {_tkinter._flatten}
      727    0.001    0.000    0.001    0.000 {method 'find' of 'str' objects}
      597    0.000    0.000    0.000    0.000 {setattr}
      528    0.000    0.000    0.000    0.000 {method 'endswith' of 'str' objects}
      512    0.000    0.000    0.000    0.000 {chr}
      487    0.000    0.000    0.000    0.000 {max}
      447    0.001    0.000    0.001    0.000 {built-in method match}
      431    0.021    0.000    0.021    0.000 {nt.stat}
      412    0.001    0.000    0.001    0.000 {_codecs.charmap_decode}
      394    0.001    0.000    0.001    0.000 {method 'setdefault' of 'dict' objects}
      365    0.000    0.000    0.000    0.000 {isinstance}
  272/169    0.001    0.000    0.109    0.001 {apply}
      198    0.000    0.000    0.000    0.000 {getattr}
      197    0.000    0.000    0.000    0.000 {method 'extend' of 'list' objects}
      194    0.000    0.000    0.000    0.000 {range}
      186    0.000    0.000    0.000    0.000 {method 'isdigit' of 'unicode' objects}
      181    0.000    0.000    0.000    0.000 {method 'values' of 'dict' objects}
      173    0.000    0.000    0.000    0.000 {method 'rstrip' of 'unicode' objects}
      172    0.000    0.000    0.000    0.000 {method 'remove' of 'list' objects}
      127    0.018    0.000    0.085    0.001 {__import__}
      124    0.000    0.000    0.000    0.000 {method 'read' of 'cStringIO.StringI' objects}
      109    0.000    0.000    0.000    0.000 {method 'upper' of 'str' objects}
       87    0.000    0.000    0.000    0.000 {method 'upper' of 'unicode' objects}
       81    0.000    0.000    0.000    0.000 {_sre.compile}
       72    0.000    0.000    0.000    0.000 {built-in method getboolean}
       70    0.000    0.000    0.000    0.000 {method 'isdigit' of 'str' objects}
       69    0.000    0.000    0.000    0.000 {method 'isalpha' of 'unicode' objects}
       66    0.000    0.000    0.000    0.000 {built-in method splitlist}
       66    0.000    0.000    0.000    0.000 {method 'isupper' of 'unicode' objects}
       65    0.000    0.000    0.000    0.000 {_codecs.utf_8_decode}
       60    0.000    0.000    0.000    0.000 {method 'lstrip' of 'str' objects}
       60    0.000    0.000    0.000    0.000 {method 'rstrip' of 'str' objects}
       57    0.000    0.000    0.001    0.000 {method 'encode' of 'unicode' objects}
       49    0.000    0.000    0.000    0.000 {method 'reverse' of 'list' objects}
       48    0.000    0.000    0.000    0.000 {method 'islower' of 'unicode' objects}
       41    0.001    0.000    0.001    0.000 {method 'splitlines' of 'unicode' objects}
       37    0.000    0.000    0.000    0.000 {method 'split' of 'str' objects}
       32    0.000    0.000    0.000    0.000 {method 'index' of 'list' objects}
       31    0.000    0.000    0.000    0.000 {cStringIO.StringIO}
       29    0.000    0.000    0.000    0.000 {binascii.unhexlify}
       29    0.000    0.000    0.000    0.000 {_sre.getlower}
       24    0.000    0.000    0.026    0.001 {map}
       19    0.002    0.000    0.002    0.000 {method 'close' of 'file' objects}
       19    0.000    0.000    0.000    0.000 {built-in method globalsetvar}
       18    0.000    0.000    0.000    0.000 {built-in method globalunsetvar}
       18    0.000    0.000    0.000    0.000 {method 'insert' of 'list' objects}
       17    0.000    0.000    0.000    0.000 {_codecs.charmap_encode}
       16    0.001    0.000    0.001    0.000 {method 'clear' of 'dict' objects}
       15    0.017    0.001    0.017    0.001 {imp.find_module}
       15    0.009    0.001    0.359    0.024 {imp.load_module}
       14    0.000    0.000    0.000    0.000 {locals}
       13    0.000    0.000    0.000    0.000 {method 'sort' of 'list' objects}
       13    0.000    0.000    0.000    0.000 {_codecs.lookup}
       10    0.001    0.000    0.001    0.000 {method 'read' of 'file' objects}
        9    0.000    0.000    0.000    0.000 {built-in method search}
        8    0.032    0.004    0.309    0.039 {built-in method Parse}
        7    0.000    0.000    0.000    0.000 {abs}
        6    0.000    0.000    0.000    0.000 {method 'count' of 'str' objects}
        5    0.001    0.000    0.001    0.000 {open}
        5    0.000    0.000    0.000    0.000 {method 'rfind' of 'str' objects}
        5    0.000    0.000    0.000    0.000 {method 'splitlines' of 'str' objects}
        4    0.000    0.000    0.000    0.000 {method 'seek' of 'file' objects}
        4    0.000    0.000    0.000    0.000 {thread.allocate_lock}
        4    0.000    0.000    0.000    0.000 {built-in method getvar}
        4    0.000    0.000    0.000    0.000 {method 'copy' of 'dict' objects}
        4    0.000    0.000    0.000    0.000 {built-in method globalgetvar}
        4    0.000    0.000    0.000    0.000 {built-in method SetParamEntityParsing}
        4    0.000    0.000    0.000    0.000 {globals}
        3    0.001    0.000    0.001    0.000 {nt.listdir}
        3    0.001    0.000    0.001    0.000 {method 'readlines' of 'file' objects}
        3    0.000    0.000    0.001    0.000 {filter}
        3    0.000    0.000    0.000    0.000 {eval}
        3    0.000    0.000    0.000    0.000 {vars}
        3    0.000    0.000    0.000    0.000 {method 'join' of 'unicode' objects}
        2    0.000    0.000    0.000    0.000 {dir}
        2    0.000    0.000    0.000    0.000 {nt.access}
        2    0.000    0.000    0.000    0.000 {_weakref.proxy}
        2    0.000    0.000    0.000    0.000 {method 'tell' of 'file' objects}
        2    0.000    0.000    0.000    0.000 {method 'capitalize' of 'unicode' objects}
        2    0.000    0.000    0.000    0.000 {built-in method acquire}
        2    0.000    0.000    0.000    0.000 {thread.get_ident}
        2    0.000    0.000    0.000    0.000 {sys.getdefaultencoding}
        2    0.000    0.000    0.000    0.000 {built-in method release}

        1   14.431   14.431   14.504   14.504 {built-in method mainloop}
        1    0.042    0.042    0.042    0.042 {_tkinter.create}
        1    0.002    0.002    0.002    0.002 {_ctypes.LoadLibrary}
        1    0.001    0.001    0.001    0.001 {execfile}
        1    0.000    0.000    0.000    0.000 {thread.start_new_thread}
        1    0.000    0.000    0.000    0.000 {method 'readline' of 'file' objects}
        1    0.000    0.000    0.000    0.000 {method 'write' of 'file' objects}
        1    0.000    0.000    0.000    0.000 {time.sleep}
        1    0.000    0.000    0.000    0.000 {strop.maketrans}
        1    0.000    0.000    0.000    0.000 {_locale._getdefaultlocale}
        1    0.000    0.000    0.000    0.000 {time.strftime}
        1    0.000    0.000    0.000    0.000 {time.localtime}
        1    0.000    0.000    0.000    0.000 {sys.getwindowsversion}
        1    0.000    0.000    0.000    0.000 {method 'tolist' of 'array.array' objects}
        1    0.000    0.000    0.000    0.000 {nt.getcwd}
        1    0.000    0.000    0.000    0.000 {built-in method __new__ of type object at 0x1E1E6DD0}
        1    0.000    0.000    0.000    0.000 {built-in method quit}
        1    0.000    0.000    0.000    0.000 {method 'tostring' of 'array.array' objects}
        1    0.000    0.000    0.000    0.000 {method 'translate' of 'str' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.000    0.000    0.000    0.000 {imp.get_magic}
#@-node:ekr.20080529114024.1:Stats
#@+node:ekr.20080529114024.3:Stats (.py files)
@killcolor

         10085874 function calls (10077839 primitive calls) in 31.652 CPU seconds

   Ordered by: file name, call count, internal time, function name
   List reduced from 2528 to 363 due to restriction <'leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   111237    0.279    0.000    0.963    0.000 leoAtFile.py:1808(readLine)
   111118    0.545    0.000    3.134    0.000 leoAtFile.py:1511(sentinelKind4)
    96055    0.261    0.000    0.589    0.000 leoAtFile.py:806(readNormalLine)
    15063    0.085    0.000    0.347    0.000 leoAtFile.py:1557(skipSentinelStart4)
     6272    0.010    0.000    0.013    0.000 leoAtFile.py:1499(popSentinelStack)
     5859    0.134    0.000    0.588    0.000 leoAtFile.py:634(createThinChild4)
     5859    0.087    0.000    0.743    0.000 leoAtFile.py:915(readStartNode)
     5859    0.084    0.000    0.165    0.000 leoAtFile.py:1079(readEndNode)
       43    0.531    0.012    6.564    0.153 leoAtFile.py:744(scanText4)
       43    0.292    0.007   13.668    0.318 leoAtFile.py:439(read)

negligible
      845    0.006    0.000    0.013    0.000 leoAtFile.py:1413(readNonl)
      665    0.004    0.000    0.017    0.000 leoAtFile.py:1452(readRef)
      664    0.002    0.000    0.005    0.000 leoAtFile.py:1400(readNl)
      287    0.002    0.000    0.006    0.000 leoAtFile.py:1322(readDirective)
      221    0.001    0.000    0.004    0.000 leoAtFile.py:999(readStartOthers)
      221    0.000    0.000    0.001    0.000 leoAtFile.py:1172(readEndOthers)
      188    0.002    0.000    0.004    0.000 leoAtFile.py:1182(readLastDocLine)
      188    0.001    0.000    0.003    0.000 leoAtFile.py:860(readStartAt)
      188    0.001    0.000    0.005    0.000 leoAtFile.py:1029(readEndAt)
       62    0.000    0.000    0.001    0.000 leoAtFile.py:3454(os)
       45    0.003    0.000    0.029    0.001 leoAtFile.py:3880(scanAllDirectives)
       45    0.000    0.000    0.001    0.000 leoAtFile.py:180(initCommonIvars)
       43    0.038    0.001    0.251    0.006 leoAtFile.py:1632(copyAllTempBodyStringsToTnodes)
       43    0.013    0.000    0.013    0.000 leoAtFile.py:422(openForRead)
       43    0.002    0.000    0.023    0.001 leoAtFile.py:4084(scanDefaultDirectory)
       43    0.001    0.000    0.003    0.000 leoAtFile.py:1677(parseLeoSentinel)
       43    0.001    0.000    6.572    0.153 leoAtFile.py:580(readOpenFile)
       43    0.001    0.000    0.024    0.001 leoAtFile.py:242(initReadIvars)
       43    0.000    0.000    0.006    0.000 leoAtFile.py:1817(scanHeader)
       43    0.000    0.000    0.018    0.000 leoAtFile.py:393(openFileForReading)
       43    0.000    0.000    0.001    0.000 leoAtFile.py:1582(completeFirstDirectives)
       43    0.000    0.000    0.001    0.000 leoAtFile.py:1610(completeLastDirectives)
       43    0.000    0.000    0.001    0.000 leoAtFile.py:1052(readEndLeo)
       27    0.000    0.000    0.000    0.000 leoAtFile.py:3440(onl)
       25    0.000    0.000    0.000    0.000 leoAtFile.py:3661(putIndent)
       17    0.000    0.000    0.001    0.000 leoAtFile.py:2831(putCodeLine)
       17    0.000    0.000    0.000    0.000 leoAtFile.py:3347(directiveKind4)
       17    0.000    0.000    0.000    0.000 leoAtFile.py:3392(findSectionName)
       14    0.000    0.000    0.000    0.000 leoAtFile.py:1474(readVerbatim)
       14    0.000    0.000    0.000    0.000 leoAtFile.py:1872(skipIndent)
       12    0.000    0.000    0.001    0.000 leoAtFile.py:906(readStartMiddle)
       12    0.000    0.000    0.000    0.000 leoAtFile.py:1070(readEndMiddle)
       10    0.000    0.000    0.000    0.000 leoAtFile.py:3292(putSentinel)
        5    0.000    0.000    0.000    0.000 leoAtFile.py:127(__init__)
        4    0.000    0.000    0.000    0.000 leoAtFile.py:842(readStartAll)
        4    0.000    0.000    0.000    0.000 leoAtFile.py:3163(nodeSentinelText)
        4    0.000    0.000    0.000    0.000 leoAtFile.py:1019(readEndAll)
        2    0.000    0.000    0.002    0.001 leoAtFile.py:2561(putBody)
        2    0.000    0.000    0.002    0.001 leoAtFile.py:289(initWriteIvars)
        2    0.000    0.000    0.003    0.001 leoAtFile.py:2533(writeOpenFile)
        2    0.000    0.000    0.006    0.003 leoAtFile.py:2394(writeFromString)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:2014(openFileForWriting)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:4173(cleanLines)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:1891(closeWriteFile)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3259(putOpenNodeSentinel)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3499(putAtLastLines)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3239(putOpenLeoSentinel)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3227(putCloseNodeSentinel)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3479(putAtFirstLines)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3675(putInitialComment)
        1    0.012    0.012   13.944   13.944 leoAtFile.py:502(readAll)
        1    0.000    0.000    0.000    0.000 leoAtFile.py:33(atFile)
        1    0.000    0.000    0.000    0.000 leoAtFile.py:7(<module>)
        1    0.000    0.000    0.000    0.000 leoAtFile.py:1240(readAfterRef)

All negligible

    22805    0.090    0.000    0.134    0.000 leoFileCommands.py:222(characters)
     5122    0.021    0.000    0.167    0.000 leoFileCommands.py:303(startElement)
     5122    0.021    0.000    0.056    0.000 leoFileCommands.py:241(endElement)
     3344    0.028    0.000    0.045    0.000 leoFileCommands.py:142(attrsToList)
     3337    0.006    0.000    0.006    0.000 leoFileCommands.py:173(inElement)
     1753    0.006    0.000    0.006    0.000 leoFileCommands.py:488(__init__)
     1749    0.017    0.000    0.069    0.000 leoFileCommands.py:436(startVnode)
     1749    0.012    0.000    0.041    0.000 leoFileCommands.py:459(vnodeAttributes)
     1749    0.010    0.000    0.012    0.000 leoFileCommands.py:278(endVH)
     1749    0.003    0.000    0.004    0.000 leoFileCommands.py:271(endVnode)
     1749    0.001    0.000    0.001    0.000 leoFileCommands.py:370(startVH)
     1710    0.004    0.000    0.048    0.000 leoFileCommands.py:892(canonicalTnodeIndex)
     1703    0.028    0.000    0.166    0.000 leoFileCommands.py:1037(createSaxVnode)
     1703    0.012    0.000    0.019    0.000 leoFileCommands.py:1092(handleVnodeSaxAttributes)
     1703    0.002    0.000    0.003    0.000 leoFileCommands.py:1073(handleTnodeSaxAttributes)
   1678/4    0.010    0.000    0.199    0.050 leoFileCommands.py:1003(createSaxChildren)
     1678    0.004    0.000    0.011    0.000 leoFileCommands.py:1149(_linkParentAndChildren)
  1674/29    0.004    0.000    0.198    0.007 leoFileCommands.py:1027(createSaxVnodeTree)
     1588    0.007    0.000    0.026    0.000 leoFileCommands.py:414(tnodeAttributes)
     1588    0.005    0.000    0.010    0.000 leoFileCommands.py:262(endTnode)
     1588    0.004    0.000    0.033    0.000 leoFileCommands.py:404(startTnode)
       35    0.000    0.000    0.002    0.000 leoFileCommands.py:1178(getSaxUa)
       12    0.000    0.000    0.000    0.000 leoFileCommands.py:909(getDescendentAttributes)
        8    0.002    0.000    0.002    0.000 leoFileCommands.py:940(initReadIvars)
        5    0.000    0.000    0.000    0.000 leoFileCommands.py:543(initIvars)
        5    0.000    0.000    0.000    0.000 leoFileCommands.py:529(__init__)
        4    0.015    0.004    0.323    0.081 leoFileCommands.py:761(initAllParents)
        4    0.004    0.001    0.072    0.018 leoFileCommands.py:1274(resolveTnodeLists)
        4    0.000    0.000   15.661    3.915 leoFileCommands.py:686(getLeoFile)
        4    0.000    0.000    0.688    0.172 leoFileCommands.py:1255(readSaxFile)
        4    0.000    0.000    0.490    0.122 leoFileCommands.py:1219(parse_leo_file)
        4    0.000    0.000    0.033    0.008 leoFileCommands.py:376(startVnodes)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:67(__init__)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:322(getPositionAttributes)
        4    0.000    0.000   15.661    3.915 leoFileCommands.py:824(open)
        4    0.000    0.000    0.001    0.000 leoFileCommands.py:1295(setPositionsFromVnodes)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:344(startGlobals)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:292(processingInstruction)
        4    0.000    0.000    0.199    0.050 leoFileCommands.py:990(createSaxVnodes)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:359(startWinPos)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:365(startLeoHeader)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:288(getRootNode)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:124(endDocument)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:136(startDocument)
        2    0.000    0.000    0.000    0.000 leoFileCommands.py:1309(archivedPositionToPosition)
        1    0.020    0.020    0.245    0.245 leoFileCommands.py:949(restoreDescendentAttributes)
        1    0.012    0.012    0.066    0.066 leoFileCommands.py:9(<module>)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:525(baseFileCommands)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:61(saxContentHandler)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:480(saxNodeClass)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:43(BadLeoFile)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:50(invalidPaste)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:2303(fileCommands)

   979398    0.728    0.000    0.728    0.000 leoGlobals.py:3520(is_ws)
   283766    0.585    0.000    1.047    0.000 leoGlobals.py:3531(match)
   185704    0.386    0.000    0.409    0.000 leoGlobals.py:4074(toUnicode)
   162977    0.996    0.000    1.779    0.000 leoGlobals.py:3734(skip_ws)
   111237    0.217    0.000    0.402    0.000 leoGlobals.py:2009(readlineForceUnixNewline)
    94250    0.251    0.000    0.251    0.000 leoGlobals.py:5569(removeLeadingWhitespace)
    89406    0.088    0.000    0.124    0.000 leoGlobals.py:3921(isWordChar)
    26522    0.026    0.000    0.026    0.000 leoGlobals.py:3996(isUnicode)

Negligible

    25877    0.055    0.000    0.088    0.000 leoGlobals.py:3725(skip_to_char)
    19384    0.053    0.000    0.103    0.000 leoGlobals.py:2992(toUnicodeFileEncoding)
    15700    0.037    0.000    0.063    0.000 leoGlobals.py:3550(match_word)
    15333    0.007    0.000    0.007    0.000 leoGlobals.py:2594(choose)
    14256    0.075    0.000    0.179    0.000 leoGlobals.py:3577(skip_c_id)
    11417    0.012    0.000    0.045    0.000 leoGlobals.py:2195(clearAllIvars)
     6721    0.011    0.000    0.018    0.000 leoGlobals.py:4384(__init__)
     6028    0.012    0.000    0.024    0.000 leoGlobals.py:5159(stripBrackets)
     5859    0.022    0.000    0.024    0.000 leoGlobals.py:5642(skip_leading_ws_with_indent)
     4844    0.019    0.000    0.222    0.000 leoGlobals.py:2807(os_path_abspath)
     3813    0.008    0.000    0.014    0.000 leoGlobals.py:3603(skip_line)
     2570    0.010    0.000    0.089    0.000 leoGlobals.py:2955(os_path_normpath)
     1946    0.021    0.000    0.050    0.000 leoGlobals.py:3585(skip_id)
      506    0.002    0.000    0.014    0.000 leoGlobals.py:2820(os_path_basename)
      473    0.002    0.000    0.011    0.000 leoGlobals.py:2980(os_path_splitext)
      448    0.004    0.000    0.015    0.000 leoGlobals.py:2891(os_path_join)
      275    0.008    0.000    0.020    0.000 leoGlobals.py:462(get_directives_dict)
      184    0.001    0.000    0.002    0.000 leoGlobals.py:2864(os_path_isabs)
      181    0.002    0.000    1.364    0.008 leoGlobals.py:2540(doHook)
      156    0.005    0.000    0.020    0.000 leoGlobals.py:3501(is_special)
      139    0.000    0.000    0.000    0.000 leoGlobals.py:3494(is_nl)
      123    0.000    0.000    0.002    0.000 leoGlobals.py:4048(toEncodedString)
      113    0.000    0.000    0.006    0.000 leoGlobals.py:2846(os_path_exists)
      106    0.001    0.000    0.001    0.000 leoGlobals.py:838(getOutputNewline)
      100    0.001    0.000    0.003    0.000 leoGlobals.py:2833(os_path_dirname)
       94    0.001    0.000    0.002    0.000 leoGlobals.py:1773(getBaseDirectory)
       83    0.000    0.000    0.000    0.000 leoGlobals.py:4118(convertPythonIndexToRowCol)
       76    0.001    0.000    0.001    0.000 leoGlobals.py:3628(skip_long)
       73    0.000    0.000    0.002    0.000 leoGlobals.py:2968(os_path_split)
       71    0.000    0.000    0.003    0.000 leoGlobals.py:4931(computeWindowTitle)
       69    0.001    0.000    0.006    0.000 leoGlobals.py:2742(translateArgs)
       67    0.000    0.000    0.006    0.000 leoGlobals.py:2768(translateString)
       66    0.003    0.000    0.130    0.002 leoGlobals.py:2616(es)
       64    0.000    0.000    0.001    0.000 leoGlobals.py:3750(splitLines)
       62    0.000    0.000    0.000    0.000 leoGlobals.py:5023(write)
       57    0.000    0.000    0.031    0.001 leoGlobals.py:2609(enl)
       55    0.000    0.000    0.031    0.001 leoGlobals.py:2603(ecnls)
       55    0.000    0.000    0.031    0.001 leoGlobals.py:2600(ecnl)
       53    0.001    0.000    0.002    0.000 leoGlobals.py:326(set_delims_from_string)
       53    0.000    0.000    0.002    0.000 leoGlobals.py:311(set_delims_from_language)
       46    0.000    0.000    0.001    0.000 leoGlobals.py:2050(shortFileName)
       38    0.000    0.000    0.001    0.000 leoGlobals.py:563(scanAtPagewidthDirective)
       38    0.000    0.000    0.001    0.000 leoGlobals.py:622(scanAtTabwidthDirective)
       20    0.001    0.000    0.001    0.000 leoGlobals.py:4001(isValidEncoding)
       19    0.000    0.000    0.000    0.000 leoGlobals.py:4137(convertRowColToPythonIndex)
       17    0.001    0.000    0.031    0.002 leoGlobals.py:5233(importModule)
       17    0.000    0.000    0.073    0.004 leoGlobals.py:5255(importExtension)
       14    0.000    0.000    0.002    0.000 leoGlobals.py:2489(idleTimeHookHandler)
       13    0.000    0.000    0.337    0.026 leoGlobals.py:5406(importFromPath)
       12    0.000    0.000    0.000    0.000 leoGlobals.py:4229(CheckVersionToInt)
       11    0.001    0.000    0.009    0.001 leoGlobals.py:2573(plugin_signon)
        6    0.000    0.000    0.002    0.000 leoGlobals.py:669(scanDirectives)
        4    0.001    0.000    0.006    0.001 leoGlobals.py:1981(openLeoOrZipFile)
        4    0.000    0.000    0.000    0.000 leoGlobals.py:4974(__init__)
        3    0.002    0.001    0.003    0.001 leoGlobals.py:2692(es_print)
        3    0.000    0.000    0.000    0.000 leoGlobals.py:291(startupEncoding)
        3    0.000    0.000    0.000    0.000 leoGlobals.py:2873(os_path_isdir)
        3    0.000    0.000    0.000    0.000 leoGlobals.py:5048(funcToMethod)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:4204(CheckVersion)
        2    0.000    0.000    0.006    0.003 leoGlobals.py:5054(getScript)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:5585(removeExtraLws)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:247(computeMachineName)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:1902(munge)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:5529(get_leading_ws)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:5518(computeWidth)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:5004(get)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:3763(joinLines)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:4999(flush)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:4992(close)
        1    0.000    0.000   16.606   16.606 leoGlobals.py:1894(openWithFileName)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:208(computeLoadDir)
        1    0.000    0.000    0.001    0.001 leoGlobals.py:265(computeStandardDirectories)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:140(computeGlobalConfigDir)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:164(computeHomeDir)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:192(computeLeoDir)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:1574(init_trace)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:1556(get_Sherlock_args)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:2467(enableIdleTimeHook)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:1542(init_sherlock)


  1117866    0.908    0.000    0.908    0.000 leoNodes.py:1069(__nonzero__)
   768290    0.663    0.000    0.663    0.000 leoNodes.py:1692(<lambda>)
   396157    0.682    0.000    0.682    0.000 leoNodes.py:2721(_parentVnode)
   223158    0.737    0.000    1.212    0.000 leoNodes.py:1276(hasNext)
   194215    0.768    0.000    7.557    0.000 leoNodes.py:1707(next)
   194143    2.396    0.000    6.314    0.000 leoNodes.py:1722(moveToThreadNextUnique)
   172954    0.739    0.000    1.085    0.000 leoNodes.py:2425(moveToNext)
   155157    0.136    0.000    0.136    0.000 leoNodes.py:1773(<lambda>)
    50509    0.137    0.000    0.160    0.000 leoNodes.py:2473(moveToParent)
    50075    0.240    0.000    0.259    0.000 leoNodes.py:2376(moveToFirstChild)
    26496    0.019    0.000    0.019    0.000 leoNodes.py:852(areEqual)
    25341    0.109    0.000    0.421    0.000 leoNodes.py:2502(moveToThreadNext)
    11920    0.053    0.000    0.279    0.000 leoNodes.py:1662(next)
    11871    0.061    0.000    0.294    0.000 leoNodes.py:1806(next)
     9243    0.109    0.000    0.274    0.000 leoNodes.py:892(scanGnx)

    20184    0.068    0.000    0.106    0.000 leoNodes.py:564(headString)
    17200    0.020    0.000    0.020    0.000 leoNodes.py:588(isDirty)
    16140    0.105    0.000    0.124    0.000 leoNodes.py:812(_computeParentsOfChildren)
    13814    0.022    0.000    0.093    0.000 leoNodes.py:1183(headString)
    12820    0.009    0.000    0.009    0.000 leoNodes.py:1777(<lambda>)
    12132    0.022    0.000    0.022    0.000 leoNodes.py:1030(isEqual)
    11763    0.015    0.000    0.015    0.000 leoNodes.py:213(setVisited)
     7293    0.024    0.000    0.024    0.000 leoNodes.py:260(__init__)
     7177    0.056    0.000    0.114    0.000 leoNodes.py:58(__init__)
     7174    0.011    0.000    0.020    0.000 leoNodes.py:1192(isDirty)
     6338    0.020    0.000    0.032    0.000 leoNodes.py:491(bodyString)
     6338    0.010    0.000    0.041    0.000 leoNodes.py:1179(bodyString)
     5985    0.006    0.000    0.006    0.000 leoNodes.py:598(isMarked)
     5961    0.009    0.000    0.014    0.000 leoNodes.py:1194(isMarked)
     5871    0.005    0.000    0.005    0.000 leoNodes.py:115(hasBody)
     5843    0.005    0.000    0.005    0.000 leoNodes.py:135(isVisited)
     5653    0.006    0.000    0.006    0.000 leoNodes.py:662(clearOrphan)
     5582    0.020    0.000    0.109    0.000 leoNodes.py:792(_linkAsNthChild)
     5582    0.008    0.000    0.011    0.000 leoNodes.py:538(numberOfChildren)
     5001    0.010    0.000    0.014    0.000 leoNodes.py:748(setBodyString)
     1702    0.003    0.000    0.003    0.000 leoNodes.py:1012(__cmp__)
     1094    0.003    0.000    0.003    0.000 leoNodes.py:989(__init__)
     1059    0.005    0.000    0.007    0.000 leoNodes.py:1104(copy)
      672    0.003    0.000    0.017    0.000 leoNodes.py:342(findAtFileName)
      397    0.002    0.000    0.003    0.000 leoNodes.py:2024(next)
      301    0.001    0.000    0.006    0.000 leoNodes.py:2444(moveToNodeAfterTree)
      257    0.000    0.000    0.000    0.000 leoNodes.py:100(bodyString)
      202    0.001    0.000    0.006    0.000 leoNodes.py:1240(getNodeAfterTree)
      175    0.000    0.000    0.008    0.000 leoNodes.py:362(anyAtFileNodeName)
      156    0.000    0.000    0.005    0.000 leoNodes.py:447(isAtThinFileNode)
      156    0.000    0.000    0.021    0.000 leoNodes.py:456(isAtIgnoreNode)
      156    0.000    0.000    0.021    0.000 leoNodes.py:1163(isAtIgnoreNode)
      156    0.000    0.000    0.006    0.000 leoNodes.py:1168(isAtThinFileNode)
      156    0.000    0.000    0.005    0.000 leoNodes.py:403(atThinFileNodeName)
      136    0.001    0.000    0.006    0.000 leoNodes.py:1786(__init__)
      136    0.000    0.000    0.000    0.000 leoNodes.py:1801(__iter__)
      133    0.001    0.000    0.006    0.000 leoNodes.py:1827(self_and_subtree_iter)
      131    0.000    0.000    0.007    0.000 leoNodes.py:1146(anyAtFileNodeName)
      116    0.000    0.000    0.001    0.000 leoNodes.py:2007(__init__)
      116    0.000    0.000    0.000    0.000 leoNodes.py:2019(__iter__)
      115    0.000    0.000    0.002    0.000 leoNodes.py:435(isAtFileNode)
      115    0.000    0.000    0.002    0.000 leoNodes.py:1162(isAtFileNode)
      115    0.000    0.000    0.002    0.000 leoNodes.py:387(atFileNodeName)
      113    0.001    0.000    0.002    0.000 leoNodes.py:2045(self_and_parents_iter)
      113    0.000    0.000    0.002    0.000 leoNodes.py:432(isAtAutoNode)
      113    0.000    0.000    0.002    0.000 leoNodes.py:441(isAtRawFileNode)
      113    0.000    0.000    0.002    0.000 leoNodes.py:1161(isAtAutoNode)
      113    0.000    0.000    0.002    0.000 leoNodes.py:1166(isAtRawFileNode)
      113    0.000    0.000    0.002    0.000 leoNodes.py:380(atAutoNodeName)
      113    0.000    0.000    0.002    0.000 leoNodes.py:395(atRawFileNodeName)
       95    0.001    0.000    0.001    0.000 leoNodes.py:1130(key)
       72    0.001    0.000    0.001    0.000 leoNodes.py:1692(__init__)
       72    0.000    0.000    0.000    0.000 leoNodes.py:1702(__iter__)
       58    0.000    0.000    0.000    0.000 leoNodes.py:1217(hasChildren)
       57    0.000    0.000    0.000    0.000 leoNodes.py:1287(hasParent)
       52    0.000    0.000    0.000    0.000 leoNodes.py:1272(hasBack)
       47    0.000    0.000    0.000    0.000 leoNodes.py:667(clearVisited)
       45    0.001    0.000    0.005    0.000 leoNodes.py:1455(clearVisitedInTree)
       45    0.000    0.000    0.002    0.000 leoNodes.py:421(isAnyAtFileNode)
       45    0.000    0.000    0.000    0.000 leoNodes.py:1401(clearVisited)
       45    0.000    0.000    0.000    0.000 leoNodes.py:1193(isExpanded)
       45    0.000    0.000    0.000    0.000 leoNodes.py:593(isExpanded)
       44    0.000    0.000    0.000    0.000 leoNodes.py:2357(moveToBack)
       43    0.000    0.000    0.000    0.000 leoNodes.py:1771(unique_tnodes_iter)
       43    0.000    0.000    0.000    0.000 leoNodes.py:1471(clearDirty)
       43    0.000    0.000    0.000    0.000 leoNodes.py:645(clearDirty)
       43    0.000    0.000    0.002    0.000 leoNodes.py:1159(isAnyAtFileNode)
       25    0.000    0.000    0.000    0.000 leoNodes.py:1943(<lambda>)
       24    0.000    0.000    0.000    0.000 leoNodes.py:767(computeIcon)
       24    0.000    0.000    0.000    0.000 leoNodes.py:1239(getNext)
       24    0.000    0.000    0.000    0.000 leoNodes.py:583(isCloned)
       11    0.000    0.000    0.000    0.000 leoNodes.py:752(setHeadString)
       10    0.000    0.000    0.000    0.000 leoNodes.py:678(expand)
        9    0.000    0.000    0.000    0.000 leoNodes.py:2076(next)
        8    0.000    0.000    0.000    0.000 leoNodes.py:1861(next)
        6    0.000    0.000    0.000    0.000 leoNodes.py:1873(moveToThreadNextUnique)
        6    0.000    0.000    0.000    0.000 leoNodes.py:2056(__init__)
        6    0.000    0.000    0.000    0.000 leoNodes.py:2092(siblings_iter)
        6    0.000    0.000    0.000    0.000 leoNodes.py:2071(__iter__)
        6    0.000    0.000    0.000    0.000 leoNodes.py:1939(<lambda>)
        5    0.000    0.000    0.000    0.000 leoNodes.py:1775(unique_vnodes_iter)
        5    0.000    0.000    0.000    0.000 leoNodes.py:1404(expand)
        4    0.000    0.000    0.000    0.000 leoNodes.py:1440(initHeadString)
        4    0.000    0.000    0.000    0.000 leoNodes.py:1649(__init__)
        4    0.000    0.000    0.000    0.000 leoNodes.py:736(setVisited)
        4    0.000    0.000    0.000    0.000 leoNodes.py:125(isDirty)
        4    0.000    0.000    0.000    0.000 leoNodes.py:1657(__iter__)
        3    0.000    0.000    0.000    0.000 leoNodes.py:2525(moveToVisBack)
        3    0.000    0.000    0.000    0.000 leoNodes.py:2689(_linkAsRoot)
        3    0.000    0.000    0.000    0.000 leoNodes.py:1247(getVisBack)
        3    0.000    0.000    0.000    0.000 leoNodes.py:1823(subtree_iter)
        3    0.000    0.000    0.000    0.000 leoNodes.py:2041(parents_iter)
        3    0.000    0.000    0.000    0.000 leoNodes.py:1234(getBack)
        3    0.000    0.000    0.000    0.000 leoNodes.py:1291(hasThreadBack)
        3    0.000    0.000    0.000    0.000 leoNodes.py:717(initMarkedBit)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1461(clearAllVisitedInTree)
        2    0.000    0.000    0.000    0.000 leoNodes.py:2564(moveToVisNext)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1354(isVisible)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1838(__init__)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1248(getVisNext)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1934(subtree_with_unique_tnodes_iter)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1403(contract)
        2    0.000    0.000    0.000    0.000 leoNodes.py:672(contract)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1400(clearOrphan)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1413(setVisited)
        2    0.000    0.000    0.000    0.000 leoNodes.py:193(clearVisited)
        2    0.000    0.000    0.000    0.000 leoNodes.py:198(clearWriteBit)
        2    0.000    0.000    0.000    0.000 leoNodes.py:218(setWriteBit)
        2    0.000    0.000    0.000    0.000 leoNodes.py:2531(checkLimit)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1855(__iter__)
        1    0.000    0.000    0.001    0.001 leoNodes.py:9(<module>)
        1    0.000    0.000    0.000    0.000 leoNodes.py:46(tnode)
        1    0.000    0.000    0.000    0.000 leoNodes.py:985(basePosition)
        1    0.000    0.000    0.000    0.000 leoNodes.py:234(vnode)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1477(findAllPotentiallyDirtyNodes)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1520(setAllAncestorAtFileNodesDirty)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2753(_unlink)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2665(_linkAsNthChild)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1547(setDirty)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2208(insertAsNthChild)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2284(moveToRoot)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1295(hasThreadNext)
        1    0.000    0.000    0.000    0.000 leoNodes.py:919(setTimestamp)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2196(insertAsLastChild)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1242(getParent)
        1    0.000    0.000    0.000    0.000 leoNodes.py:840(__init__)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2487(moveToThreadBack)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2607(_adjustPositionBeforeUnlink)
        1    0.000    0.000    0.000    0.000 leoNodes.py:834(nodeIndices)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1341(isCloned)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1780(subtree_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1686(unique_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1224(numberOfChildren)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1832(subtree_unique_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:874(getNewIndex)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1643(iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1959(children_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2001(parents_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2050(siblings_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:203(setDirty)
        1    0.000    0.000    0.000    0.000 leoNodes.py:43(baseTnode)
        1    0.000    0.000    0.000    0.000 leoNodes.py:231(baseVnode)
        1    0.000    0.000    0.000    0.000 leoNodes.py:171(setFileIndex)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2798(position)
#@-node:ekr.20080529114024.3:Stats (.py files)
#@-node:ekr.20080529054218.2:Benchmarked the read code
#@-node:ekr.20080408060320.4:4.5 b1
#@+node:ekr.20080702123133.2:4.5 b2
@
The 4.5 b2 release boasts these features:

- Full support for @shadow in Leo's core.
- Converted print to g.pr. This makes Leo's code base ready for Python 3.0.
#@nonl
#@+node:ekr.20080730212711.2:Bugs
#@+node:ekr.20080730161153.9:Fixed leoBridge and run-unit-tests
@
- leoBridgeTest.py and leoDynamicTest.py are now in the core directory.
  This required some changes to imports.
- runLeoDynamicTest now uses new paths.
#@nonl
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    # New in Leo 4.5: leoDynamicTest.py is in the leo/core folder.
    path = g.os_path_abspath(g.os_path_join(
        # g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))
        g.app.loadDir,'leoDynamicTest.py'))

    if ' ' in path and sys.platform.startswith('win'): 
        path = '"' + path + '"'

    args = [sys.executable, path, '--silent']  

    # srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    # srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..')
    # os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@-node:ekr.20080730161153.9:Fixed leoBridge and run-unit-tests
#@-node:ekr.20080730212711.2:Bugs
#@+node:ekr.20080730212711.3:Code cleanups
#@+node:ekr.20080629085849.3:Eliminated @bool useTextMinibuffer
Should always use a Tk.Text widget.
#@nonl
#@+node:ekr.20050920094212:f.createMiniBufferWidget
def createMiniBufferWidget (self):

    '''Create the minbuffer below the status line.'''

    frame = self ; c = frame.c

    frame.minibufferFrame = f = Tk.Frame(frame.outerFrame,relief='flat',borderwidth=0)
    if c.showMinibuffer:
        f.pack(side='bottom',fill='x')

    lab = Tk.Label(f,text='mini-buffer',justify='left',anchor='nw',foreground='blue')
    lab.pack(side='left')

    label = g.app.gui.plainTextWidget(
        f,height=1,relief='groove',background='lightgrey',name='minibuffer')
    label.pack(side='left',fill='x',expand=1,padx=2,pady=1)

    frame.minibufferVisible = c.showMinibuffer

    return label
#@-node:ekr.20050920094212:f.createMiniBufferWidget
#@-node:ekr.20080629085849.3:Eliminated @bool useTextMinibuffer
#@+node:ekr.20080730072844.1:Converted most calls to 'print' to calls to g.pr
#@+node:ekr.20080729194150.2:print to g.pr regex
@nocolor

print[ ]+(.*)$
g.pr(\1)

print[ ]+;[ ]+print[]+\'(.*)$
g.pr('\\n\1)

# Double escapes in print statements.
print(.*)\\n(.*)$
print\1\\\\n\2
#@nonl
#@-node:ekr.20080729194150.2:print to g.pr regex
#@-node:ekr.20080730072844.1:Converted most calls to 'print' to calls to g.pr
#@+node:ekr.20080707093924.1:regexp for redraw branch
@nocolor

# Used to change c.begin/endUpdate/try/finally

( *)c.beginUpdate\(\)(.*)\n( *)try:(.*)$
\1# c.beginUpdate()\n\3# try:

# Comment out .endupdate(False)
^( *)(.*)\.endUpdate\(False\)
\1# \2.endUpdate(False)

# Remove all commented out try & finally

(^ *# *try:.*\n)|(^ *# *finally:.*\n)

# Tests
    # try:
    # finally:

# Remove all commented out .endUpdate.
^ *#.*\.endUpdate\(False\)
^ *#.*\.endUpdate

# Remove all commented out .beginUpdate
^ *#.*\.beginUpdate.*\n
^ *#.*\.beginUpdate

# Tests
# c.beginUpdate()
    #c2.beginUpdate()#blah
# c.endUpdate()
    #c2.endUpdate(False)

^# import leo\.core\.leoTest as leoTest.*\n# u = leoTest\.testUtils(c)\n

#@-node:ekr.20080707093924.1:regexp for redraw branch
#@-node:ekr.20080730212711.3:Code cleanups
#@+node:ekr.20080730212711.5:Added support for @shadow
#@+node:ekr.20080730212711.53: Notes for @shadow
#@+node:ekr.20080730212711.54:Thead: Eureka?? Can we just not use sentinels?
@nocolor

On sleeping on this queston, I think the "Aha" really means that I
should start using the shadow plugin. I *really* do not want to give
up the advantages of sentinels: they are an important part of Leo's
internal reliability.  Furthermore, @thin is just exactly what is
needed to make .leo files compatible with cvs/bzr.

Bernhard's plugin does, in fact, do everything that we want, and the
possible solutions to edge conditions are exactly the same for the "do
without sentinels" approach and the shadow plugin. So I'll start using
this plugin soon and report my conclusions. 
#@nonl
#@-node:ekr.20080730212711.54:Thead: Eureka?? Can we just not use sentinels?
#@+node:ekr.20080730212711.55:Theory of operation: from leoShadow.py: first light
@nocolor

The distinction between public (no sentinels) and private (with sentinels) files
clarifies the code considerably by making names much shorter. In this case, the
improvement is actually quite useful.

Last night I spent about four hours studying the heart of the shadow code, the
method called propagate_changed_lines. I believe I now understand this code in
considerable detail, something that has *never* been true for me in the past.

In this post I'll report that Aha's that made the code comprehensible.

propagate_changed_lines computes new_private_lines (the changed lines
*with* sentinels) given two arguments:

- old_private_lines (containing sentinels) and
- new_public_lines (the changed lines without sentinels)

As an overview, propagate_changed_lines works as follows:

1. It reconstitutes old_public_lines (the original lines without sentinels) by
removing sentinels from old_private_lines.

2. It calls difflib.SequenceMatcher(None,old_public_lines,new_public_lines) to
create a list of diffs of the old and new versions of the lines **without**
sentinels.

3. It (very cleverly) uses the list of diffs to drive what is, in effect, a
two-way merge of old_private_lines (with sentinels) and new_public_lines
(without sentinels). All sentinels and unchanged regular lines come from
old_private_lines. All inserted or replacement lines come from new_public_lines.

There are a *lot* of details in the algorithm. Probably the turning point, the
point at which I truly started to understand the algorithm, was the realization
that the main loop involves only input from old_private_lines and
new_public_lines. Once I saw that, I could begin to the following:

Most of the indices returned by SequenceMatcher.get_opcodes are *not* used in
the main loop. In the present code, these indices are called old_i, old_j, new_i
and new_j.

Indeed, the main loop mostly ignores these indices (I'm exaggerating a bit) and
instead mostly relies on implied pointers into the old_private_lines and
new_public_lines arrays. These "implied pointers" are the position of the
corresponding reader classes used to access old_private_lines and
new_public_lines.

This lead me, finally, to the realization that the main loop is, in effect, a
two-way merge of old_private_lines and new_public_lines arrays. It's a clever,
tricky, merge, but (in essence) a merge is exactly what it is.

There is one crucial detail that you must understand to begin to make sense of
this merge: the mapping array.

propagate_changed_lines reconstitutes old_public_lines (the original lines
without sentinels) by removing sentinels from old_private_lines as follows::

  old_public_lines, mapping = self.strip_sentinels_with_map(old_private_lines,marker)

As the name implies, this method not only strips sentinel lines, but it returns
a mapping. This mapping is an array of n+1 entries, where n is
len(old_public_lines). This mapping array is an essential part of the algorithm.
mapping[i] is the index into old_private_lines of line i in old_public_lines.
That is, for each i < len(old_public_lines), line i in old_public_lines ==
old_private_lines[i]. In other words, mapping[i] tells where line i of
old_public_lines "came from".

We are now in a position to begin to understand the main loop in detail. The
main loop processes one SequenceMatcher opcode, of the form
tag,old_i,old_j,new_i,new_j. tag is the opcode kind. It is in
('insert','delete','equal','replace').

The following code starts the opcode loop::

    # Ignore (delete) all unwritten lines of old_private_lines_rdr up to index mapping[old_i].
    # Because of this, nothing has to be explicitly deleted below.
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=mapping[old_i])

Understanding this single line is essential to understanding the rest of the tag
(opcode) handlers.

This line copies only sentinel lines from the current position of the
old_private_lines_rdr up to mapping[old_i]. As a side effect, the current
position of the old_private_lines_rdr is advanced to mapping[old_i], so in
effect all non-sentinel lines from the last written line to limit are deleted
from old_private_lines. That is, those lines will never be copied to the output.

Now let's take a look at the rest of the main loop::

    if tag == 'equal':
        # Copy all lines (including sentinels) from the old private file to the new private file.
        while old_private_lines_rdr.index() <= mapping[old_j-1]:
           line = old_private_lines_rdr.get()
           new_private_lines_wtr.put(line)

        # Ignore all new lines up to new_j: the same lines (with sentinels) have just been written.
        new_public_lines_rdr.sync(new_j)

Diff is telling us that old_public_lines[old_i:old_j] are the same as
new_public_lines[new_i:new_j]. However, we can't use either of these arrays
directly because we would lose sentinels lines. Instead we copy all lines,
including sentinels, from the current position in old_private_lines_rdr to
mapping[old_j-1] (I'm dubious about the -1: unit testing is required). Once we
have done that, we skip all lines in new_public_lines up until line new_j.

Note that *only* index old_j is used in this code. The old_i, new_i and new_j
indices are not used at all. Similar remarks can be made about the other cases
to be discussed below. The realization that most indices aren't used was an
important Aha.
::

    elif tag in ('insert','replace'):
        # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
        # Copy lines from new_public_lines_rdr up to new_j.
        while new_public_lines_rdr.index() < new_j:
            line = new_public_lines_rdr.get()
            new_private_lines_wtr.put(line)

Diff is telling us that new_public_lines[new_i:new_j] should replace
old_public_lines[old_i:old_j]. However, the call to copy_sentinels has *already*
skipped lines up to old_private_lines[mapping[old_i]], and these correspond (via
the mapping) to the lines up to old_public_lines[old_i]. Thus, for both the
'insert' and 'replace' opcodes, all we have to do is copy unwritten lines from
new_public_llines_rdr up to index new_j.

Note: we could assert that new_public_lines.index() == new_i at the start of
this case. This assertion, and similar assertions, are true because
SequenceMatcher returns opcodes in increasing order without gaps.
::

    elif tag=='delete':
        # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
        # Leave new_public_lines_rdr unchanged.
        pass

Diff is telling us delete old_public_lines[old_i:old_j]. The call to
copy_sentinels has deleted old_private_lines up to index mapping [old_i],
**not** up to mapping [old_j]. We could call::

    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=mapping[old_j])

here, but there is no need to do so. The next time through the loop will do the
equivalent. Finally, after the loop completes, the following code ensures that
all trailing sentinels are written by calling::

    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=old_private_lines_rdr.size())

So that's it. The big picture is that the main loop is a two-way merge of
old_private_lines (with sentinels) with new_public_lines (without sentinels).
Unchanged lines come from old_private_lines; changed lines come from
new_public_lines. The result of the merge forms new_private_lines.

Clearly, every line of new_public_line gets written to the output. In the
'equal' case, however, those lines actually come from old_private_lines.
#@nonl
#@-node:ekr.20080730212711.55:Theory of operation: from leoShadow.py: first light
#@+node:ekr.20080730212711.56:Unit tests: from leoShadow.py: first light
@nocolor

The shadow branch now contains the first-ever usable unit-testing
framework for @shadow.

unitTest.leo contains complete unit tests for @shadow.  See the node::

    @suite run @shadow-test nodes

This @suite node creates and runs leoShadow.atShadowTestCase
tests or each @shadow-test node in the @shadow-tests tree.
Creating a new unit test is as easy as creating the following
tree::

    @shadow-test
      old
      new

Two multi-node unit tests which demonstrate that it is impossible, in general,
to properly place a line on the boundary between nodes. They are called::

    @shadow-test-lax insert between nodes: at end of prev node
    @shadow-test insert between nodes: at start of next node

The reason one of these tests *must* fail is that both will generate
exactly the same new_public_lines: the only difference between these
tests is, in essence, the *expected* result.  This expected result is
computed by the unit test from the 'new' outline, but this expected
result is not available to the shadow code!

Heuristics can not possibly help. The data available to the shadow
code is exactly the same for both unit tests, yet the two unit tests
ask for different results!  Thus, one test must fail.

I had foreseen this situation years ago, but alas, I let this
difficulty stop me.  In fact, this is not fatal flaw: it simply means
that @auto must show nodes that have changed externally.

Furthermore, the proximate cause of the failed unit test is an overly-
strict test in test_propagate_changes.  A lesser test at the end of
propagate_changed_lines succeeds for both unit tests.  This test
ensures that the sentinel lines and non-sentinel lines *separately*
match the expected sentinel and non-sentinel lines.  This test is
clearly too lax because it *completely* ignores the interleaving
between sentinel and non-sentinel lines.
#@-node:ekr.20080730212711.56:Unit tests: from leoShadow.py: first light
#@+node:ekr.20080730212711.57:Thread: Giant Aha: @shadow *is* safe
@nocolor

The following post is long, but imo it is one of the most important in
Leo's long history of long posts :-)

This post finally, indisputably, proves that @shadow is safe, and
proposes a consolation prize for the long delay in implementing
@shadow, namely @auto-shadow.

This is a continuation of the thread, leoShadow.py: first light.  In
the last post to that thread I said:

QQQ
The proximate cause of the failed unit test is an overly-strict test
in test_propagate_changes. A lesser test at the end of
propagate_changed_lines succeeds for both unit tests. This test
ensures that the sentinel lines and non-sentinel lines *separately*
match the expected sentinel and non-sentinel lines. This test is
clearly too lax because it *completely* ignores the interleaving
between sentinel and non-sentinel lines.
QQQ

Last night in bed, thinking about what I had just written, I realized
that the failed unit test simply is not a problem.  There are two
reasons for this statement:

1. The public file produced by the "failed" unit test will be
identical with the original (that is, changed) public file.  Thus,
regardless of where @shadow puts the inserted lines, there will be no
difference that can be seen outside of Leo.  But this 'round trip of
public files' is the essential requirement!

2. Furthermore, once the Leo user saves the @shadow file, the location
of all newly inserted lines will be "fixed" (determined).  That is,
the next time Leo opens the @shadow file, the @shadow code will "know
for sure" where the line should go. The reason is simple: the line
will be placed by the "equal" SequenceMatcher opcode, rather than the
"insert" opcode.  Thus, once the Leo user chooses the location of
newly inserted lines, the @shadow code will know (or remember) the
location of those lines, because they will be part of the original,
unchanged, *private* file.  The sentinels in the private file will
tell where to put the line unambiguously.

In short:

1. **Boundary conditions do not affect public files**, the files seen
by people who do not use Leo.

2. Once an inserted line has been saved (thereby generating a new
public file), Leo will forever afterward remember the location of the
file.

Thus, the *only* remaining detail, a minor one, is to alert the user
when changes to a public file results in change to the Leo outline.
But Leo already warns when such external changes are made.  If the
user does nothing, the corresponding public file will remain as it
was.

Imo, this discussion clearly demonstrates that @shadow is safe.  This
is a huge step forward.

This Aha came, in no small part, from the change in terminology from
"files with/without sentinels" to "private/public files". When we
focus on what the public sees, we see that @shadow is safe.  Is just
about that simple.

So the executive summary is:

Boundary problems while scanning changed public files can affect only
*private* view of the Leo outline.  The public file will remain
unchanged regardless of how boundary conditions are resolved. The user
can change her private view as she likes, and once she has done so and
saved the @shadow file, the change will become permanent: it is
embodied in her private files.

Hurray!  Clarity!  Safety!

So what to do about the failed unit test?   Let's reconsider the
opening quote:

QQQ
The proximate cause of the failed unit test is an overly- strict test
in test_propagate_changes. A lesser test at the end of
propagate_changed_lines succeeds for both unit tests. This test
ensures that the sentinel lines and non-sentinel lines *separately*
match the expected sentinel and non-sentinel lines. This test is
clearly too lax because it *completely* ignores the interleaving
between sentinel and non-sentinel lines.
QQQ

Now it should be clear that the essential test is the test that non-
sentinel (public!) lines are preserved.  Thus, the test at the end of
propagate_changed_lines is *not* too lax: the test that sentinel
(private!) lines are preserved is nice to have, but preserving public
lines is the acid test.

So the solution to unit tests that fail at the boundary of nodes is
simply to relax the test.  I'll do this by marking such tests with
@shadow-test-lax, which will cause the actual UnitTest test case not
to perform the stricter test that fails.  How easy is that?
Naturally, I'll put comments in each @shadow-test-lax node explaining
why a looser test is required.

The Aha just discussed will make Leo famous.

I have been lamenting to myself recently that I didn't see all of this
when Bernhard Mulder first proposed shadow files.  I'm not sure how
clearly he understood all the issues I have just discussed, but in any
case, the responsibility for dismissing shadow files is mine and mine
alone.

However, in the spirit of 'make lemonade from lemons', it may be that
the long delay in recognizing @shadow's true importance has had some
benefits.  In particular, @auto might not have happened had @shadow
been adopted earlier.

What good is @auto now that we have @shadow, you ask?  I reply in two
ways:

1. @auto is useful in its own right, for study, etc, quite
independently of whether people use @shadow.

2. We can eliminate some potential problem with both @auto and @shadow
by using @auto-shadow. Yes, I'll provide abbreviations for this.

@auto-shadow does what the name implies: It uses @auto logic to import
the file if no private (shadow) files exist for the file; otherwise it
uses the @shadow logic. This will smooth the process of creating and
using other people's outlines.  @auto-shadow will ensure that
everything "just works"

A great day for Leo.

==================

Doh!  The abbreviation should be @shadow :-)  That is, @shadow should
work as I proposed @auto-shadow to work.

===================

Another important simplification was Bernhard's use of
reader and writer classes. In an algorithm as visually complex as the
main opcode loop, any visual simplification can be significant.
Furthermore, these classes were perfect for adding debugging and
tracing info.  I wouldn't willing do without them.
#@nonl
#@-node:ekr.20080730212711.57:Thread: Giant Aha: @shadow *is* safe
#@+node:ekr.20080730212711.58:Thread: @shadow plugin *will* make Leo famous
@nocolor
#@nonl
#@+node:ekr.20080730212711.59:Post
Not paying more attention to Bernhard's mod_shadow plugin is probably
the biggest mistake I have ever made with Leo.  I rejected the idea
far too quickly: any minor problems with it can easily be solved.

First, let me summarize what the mod_shadow (shadow) plugin does:

1. The shadow plugin writes "shadowed" derived files in two forms: a
"public" form without sentinels, and a "private", form with
sentinels.  The shadow plugin writes private files to a leo-shadow
folder.

At present, a script button converts a non-shadowed file to a shadowed
file.  We could make the process of shadowing files more automatic.
For example, @shadow-thin and @shadow-file might create shadowed
private files in @thin or @file formats respectively.

2. Typically, only the *public* files get committed to a repository.
This makes Leo available even in shops where Leo sentinels are
considered odious.  I am astounded that I haven't paid more attention
to this plugin.

3. Suppose that a public file (without sentinels) changes as the
result of a bzr merge. When Leo reads the changed *public* file, the
shadow plugin can *deduce* what changes were made by comparing the
changed public file and the (still unchanged) private file.

This idea is a stroke of genius.  Furthermore, the implementation is
relatively straightforward.  The shadow plugin does the following:

A. Removes sentinels from the private file, thereby recreating the
original *public* file.
B. Uses Python's difflib.Differ class to compute line-by-line diffs
between the original and changed public files.
C. Uses the line-oriented diffs to update the *private* file.
D. Uses the updated private file (containing sentinels) to load the
derived file.

My concerns were with step C.  There is a boundary problem.  Suppose a
changed line appears on the boundary of adjacent nodes A and B.
Should the line be inserted at the end of node A, or at the start of
node B?

At the time, I suppose I wanted absolute answers the this question.
But that is extremely foolish, for several reasons:

1. The shadow plugin could warn that there is an ambiguity, and let
the user decide.  The easy way to do this is to guess the answer, then
clone the ambiguous nodes so they can be presented to the user to
change if need be.

2. Furthermore, indentation often (usually?) makes clear in which node
to insert the new line.  If A and B have the same starting indentation
and the inserted line has a larger indentation, we should prefer to
put the node at the end of A rather than the start of B.  Other
heuristics could be used too.

But the main point is, **the ambiguity isn't serious** as long as the
user is informed and can easily override incorrect guesses in step C.
#@-node:ekr.20080730212711.59:Post
#@+node:ekr.20080730212711.60:Post
> My impression has been that they are private to Leo.

The audience is anyone who wants to share files without sentinels.

True, shadow files are private.  That is, they exist only in the Leo-shadow
folder and they would typically not be part of the repository.  But the
*public* files, the files without sentinels, could be shared in a
repository.  The point is that Leo can update the private files from changes
made to public files, so that changes to the repository will "magically"
cause changes to the Leo outline.

Perhaps an example will make this clearer.  Suppose, as is indeed the case,
that I would like to study the pypy project.
http://codespeak.net/pypy/dist/pypy/doc/home.html

This is a major project, with lots of files.  Clearly, I don't want to try
to convince the pypy folk to change all their files.  Here is what I am
likely to do:

1.  First, I'll create @auto for all the files of the pypy project in which
I have an interest.  An already-existing script will help me do this.  See
test.leo:

Startup-->Scripts-->create-at-auto-nodes

2.  Next, I'll convert @auto nodes to @shadow nodes (details a bit fuzzy,
but let's ignore them for now).  When I save the outline, the original files
get written as before.  In addition, the private files containing Leo
sentinels will be saved to the private Leo-shadow directory.

3.  When I reopen the Leo file, the outline structure will come from the
private files.  However, if any of the *public* files have changed (by the
pypy folk), those changes will be incorporated into the Leo outline, and
when I save the Leo outline again the changes will be written back to the
private files.

Thus, I can use Leo to read and write pypy files, but the pypy folk will
never see Leo sentinels in "their" files.  I can use the pypy repository and
the pypy people will not know that I am using Leo.

Edward

P.S.  In the usage case just described we would *not* want to add headline
comments to the public files because that would be change the pypy sources
too much. 
#@nonl
#@-node:ekr.20080730212711.60:Post
#@+node:ekr.20080730212711.61:Post 3
> 1.  First, I'll create @auto for all the files of the pypy project in which
> I have an interest.  An already-existing script will help me do this.

There are often minor problems that must be corrected before @auto will
import a python file "perfectly", typically tabnanny problems or
underindented comments.  It would be necessary to convince the pypy
community to allow me to fix these minor problems so that I can use Leo.
Presumably, that would be easy to do: there should be no reason why a
project should be committed to either inconsistent whitespace or
underindented comments. 
#@nonl
#@-node:ekr.20080730212711.61:Post 3
#@+node:ekr.20080730212711.62:Post 4
> I consider @auto to be a most happy development. In particular, @auto
> provides an excellent *starting* point for @shadow.

@auto does one (important!) thing more: it guarantees that the result of
writing an @auto file will be identical (up to some specified 'strictness'
level) to the original files.  For 'strict' languages such as python, the
comparison requires substantially identical leading whitespace.

In other words, @auto isn't a lax import: when it succeeds it guarantees
that we won't be changing the original (public) files.  When it fails, it
tells us why it failed so we could, for example, request that pypy clean up
the offending files.  I think this is *exactly* the right balance to have
when dealing with external projects, especially Python projects. 
#@nonl
#@-node:ekr.20080730212711.62:Post 4
#@-node:ekr.20080730212711.58:Thread: @shadow plugin *will* make Leo famous
#@-node:ekr.20080730212711.53: Notes for @shadow
#@+node:ekr.20080708094444.60: Leo overwrites
#@+node:ekr.20080708094444.79: x.ctor
def __init__ (self,c,trace=False,trace_writers=False):

    self.c = c

    # Configuration...
    self.shadow_subdir = c.config.getString('shadow_subdir') or 'LeoFolder'
    self.shadow_prefix = c.config.getString('shadow_prefix') or ''

    # Debugging...
    self.trace = trace
    self.trace_writers = trace_writers  # True: enable traces in all sourcewriters.

    # Error handling...
    self.errors = 0
    self.last_error  = '' # The last error message, regardless of whether it was actually shown.

    # Support for goto-line-number.
    self.line_mapping = []

#@-node:ekr.20080708094444.79: x.ctor
#@+node:ekr.20041005105605.19:openFileForReading (atFile)
def openFileForReading(self,fn,fromString=False,atShadow=False):

    at = self ; trace = True and not g.app.unitTesting ; verbose = False

    if fromString:
        if atShadow:
            return at.error('can not call read(atShadow=True,fromString=aString)')
        at.inputFile = g.fileLikeObject(fromString=fromString)
    else:
        fn = g.os_path_abspath(g.os_path_normpath(g.os_path_join(at.default_directory,fn)))

        if atShadow:
            x = at.c.shadowController
            # readOneAtShadowNode should already have checked these.
            shadow_fn       = x.shadowPathName(fn)
            shadow_exists   = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
            # x.updatePublicAndPrivate will create the public file from the private file
            # if the public file exists. This *is* reasonable: there is nothing to import!
            # if not g.os_path_exists(fn):
                # g.trace('oops public',fn,g.callers())
                # return at.error('can not happen: public file does not exist: %s' % (fn))
            if not shadow_exists:
                g.trace('oops private',shadow_fn,g.callers())
                return at.error('can not happen: private file does not exist: %s' % (shadow_fn))
            # This method is the gateway to the essence of the shadow algorithm.
            x.updatePublicAndPrivateFiles(fn,shadow_fn)
            fn = shadow_fn

        try:
            # Open the file in binary mode to allow 0x1a in bodies & headlines.
            if trace and verbose and atShadow: g.trace('opening %s file: %s' % (
                g.choose(atShadow,'private','public'),fn))
            at.inputFile = open(fn,'rb')
            at.warnOnReadOnlyFile(fn)
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None

    return at.inputFile # for unit tests.
#@-node:ekr.20041005105605.19:openFileForReading (atFile)
#@+node:ekr.20041005105605.21:read (atFile)
def read(self,root,importFileName=None,thinFile=False,fromString=None,atShadow=False):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString,atShadow=atShadow)
    if not at.inputFile: return False
    if not g.unitTesting:
        g.es("reading:",root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>
    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
resurrected = 0
for p in root.self_and_subtree_iter():

    if not p.v.t.isVisited():
        g.es('resurrected node:',p.headString(),color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for t in c.all_unique_tnodes_iter():

    if hasattr(t,"tempBodyString"):
        delattr(t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile)
#@+node:ekr.20041005105605.26:readAll (atFile)
def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if not p.headString().startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for v in c.all_unique_vnodes_iter():
        v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")

    if use_tracer: tt.stop()
#@-node:ekr.20041005105605.26:readAll (atFile)
#@+node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

    fn = g.os_path_abspath(g.os_path_normpath(g.os_path_join(at.default_directory,fn)))
    shadow_fn       = x.shadowPathName(fn)
    shadow_exists   = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
    # significant     = x.isSignificantPublicFile(fn)

    if shadow_exists:
        # x.updatePublicAndPrivateFiles creates the public file if it does not exist.
        at.read(p,
            thinFile=True, # The shadow file contains sentinels: new in Leo 4.5 b2.
            atShadow=True)
            # Calls x.updatePublicAndPrivateFiles
    else:
        if not g.unitTesting: g.es("reading:",p.headString())
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # x.makeShadowFile(fn,p)
            at.writeOneAtShadowNode(p,toString=False,force=True)
#@+node:ekr.20080712080505.1:importAtShadowNode
def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
#@-node:ekr.20080712080505.1:importAtShadowNode
#@-node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
#@+node:ekr.20041005105605.27:readOpenFile
def readOpenFile(self,root,theFile,fileName):

    '''Read an open derived file.

    Leo 4.5 and later can only read 4.x derived files.'''

    at = self

    firstLines,read_new,junk = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        # lastLines = at.scanText3(theFile,root,[],at.endLeo)
        lastLines = []
        g.es('can not read 3.x derived file',fileName,color='red')
        g.es('you may upgrade these file using Leo 4.0 through 4.4.x')
        g.trace('root',root and root.headString(),fileName)

    if root:
        root.v.t.setVisited() # Disable warning about set nodes.

    << handle first and last lines >>
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.t.tempBodyString
except Exception:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@-node:ekr.20041005105605.27:readOpenFile
#@+node:ekr.20080711063656.1:x.File utils
#@+node:ekr.20080711063656.7:x.baseDirName
def baseDirName (self):

    x = self ; filename = x.c.fileName()

    if filename:
        return g.os_path_dirname(g.os_path_abspath(filename))
    else:
        self.error('Can not compute shadow path: .leo file has not been saved')
        return None
#@nonl
#@-node:ekr.20080711063656.7:x.baseDirName
#@+node:ekr.20080711063656.4:x.dirName and pathName
def dirName (self,filename):

    '''Return the directory for filename.'''

    x = self

    return g.os_path_dirname(x.pathName(filename))

def pathName (self,filename):

    '''Return the full path name of filename.'''

    x = self ; theDir = x.baseDirName()

    return theDir and g.os_path_abspath(g.os_path_join(theDir,filename))
#@nonl
#@-node:ekr.20080711063656.4:x.dirName and pathName
#@+node:ekr.20080712080505.3:x.isSignificantPublicFile
def isSignificantPublicFile (self,fn):

    '''This tells the atFile.read logic whether to import a public file or use an existing public file.'''

    return g.os_path_exists(fn) and g.os_path_isfile(fn) and g.os_path_getsize(fn) > 10
#@-node:ekr.20080712080505.3:x.isSignificantPublicFile
#@+node:ekr.20080710082231.19:x.makeShadowDirectory
def makeShadowDirectory (self,fn):

    '''Make a shadow directory for the **public** fn.'''

    x = self ; path = x.shadowDirName(fn)

    if not g.os_path_exists(path):

        try:
            # g.trace('making',path)
            os.mkdir(path)
        except Exception:
            x.error('unexpected exception creating %s' % path)
            g.es_exception()
            return False

    return g.os_path_exists(path) and g.os_path_isdir(path)
#@-node:ekr.20080710082231.19:x.makeShadowDirectory
#@+node:ekr.20080711063656.2:x.rename
def rename (self,src,dst,mode=None,silent=False):

    x = self ; c = x.c

    ok = g.utils_rename (c,src,dst,mode=mode,verbose=not silent)
    if not ok:
        x.error('can not rename %s to %s' % (src,dst),silent=silent)

    return ok
#@-node:ekr.20080711063656.2:x.rename
#@+node:ekr.20080713091247.1:x.replaceFileWithString
def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    x = self ; testing = g.app.unitTesting

    exists = g.os_path_exists(fn)

    if exists: # Read the file.  Return if it is the same.
        try:
            f = file(fn,'rb')
            s2 = f.read()
            f.close()
        except IOError:
            x.error('unexpected exception creating %s' % fn)
            g.es_exception()
            return False
        if s == s2:
            if not testing: g.es('unchanged:',fn)
            return False

    # Replace the file.
    try:
        f = file(fn,'wb')
        f.write(s)
        f.close()
        if not testing:
            if exists:  g.es('wrote:    ',fn)
            else:       g.es('created:  ',fn)
        return True
    except IOError:
        x.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
#@-node:ekr.20080713091247.1:x.replaceFileWithString
#@+node:ekr.20080711063656.6:x.shadowDirName and shadowPathName
def shadowDirName (self,filename):

    '''Return the directory for the shadow file corresponding to filename.'''

    x = self

    return g.os_path_dirname(x.shadowPathName(filename))

def shadowPathName (self,filename):

    '''Return the full path name of filename, resolved using c.fileName()'''

    x = self ; baseDir = x.baseDirName()
    fileDir = g.os_path_dirname(filename)
    # g.trace(baseDir)
    # g.trace(x.shadow_subdir)
    # g.trace(fileDir)

    return baseDir and g.os_path_abspath(g.os_path_normpath(g.os_path_join(
            baseDir,
            fileDir, # Bug fix: honor any directories specified in filename.
            x.shadow_subdir,
            x.shadow_prefix + g.shortFileName(filename))))
#@nonl
#@-node:ekr.20080711063656.6:x.shadowDirName and shadowPathName
#@+node:ekr.20080711063656.3:x.unlink
def unlink (self, filename,silent=False):

    '''Unlink filename from the file system.
    Give an error on failure.'''

    x = self

    ok = g.utils_remove(filename, verbose=not silent)
    if not ok:
        x.error('can not delete %s' % (filename),silent=silent)

    return ok
#@-node:ekr.20080711063656.3:x.unlink
#@-node:ekr.20080711063656.1:x.File utils
#@+node:ekr.20080712080505.3:x.isSignificantPublicFile
def isSignificantPublicFile (self,fn):

    '''This tells the atFile.read logic whether to import a public file or use an existing public file.'''

    return g.os_path_exists(fn) and g.os_path_isfile(fn) and g.os_path_getsize(fn) > 10
#@-node:ekr.20080712080505.3:x.isSignificantPublicFile
#@+node:ekr.20080710082231.19:x.makeShadowDirectory
def makeShadowDirectory (self,fn):

    '''Make a shadow directory for the **public** fn.'''

    x = self ; path = x.shadowDirName(fn)

    if not g.os_path_exists(path):

        try:
            # g.trace('making',path)
            os.mkdir(path)
        except Exception:
            x.error('unexpected exception creating %s' % path)
            g.es_exception()
            return False

    return g.os_path_exists(path) and g.os_path_isdir(path)
#@-node:ekr.20080710082231.19:x.makeShadowDirectory
#@+node:ekr.20080708094444.36:x.propagate_changes
def propagate_changes(self, old_public_file, old_private_file):

    '''Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)'''

    x = self

    g.trace('old_public_file',old_public_file)

    old_public_lines  = file(old_public_file).readlines()
    old_private_lines = file(old_private_file).readlines()
    marker = x.marker_from_extension(old_public_file)

    new_private_lines = x.propagate_changed_lines(
        old_public_lines,
        old_private_lines,
        marker)

    fn = old_private_file
    copy = not os.path.exists(fn) or new_private_lines != old_private_lines

    if copy and x.errors == 0:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(fn,s)

    return copy
#@-node:ekr.20080708094444.36:x.propagate_changes
#@+node:bwmulder.20041231170726:x.updatePublicAndPrivateFiles
def updatePublicAndPrivateFiles (self,fn,shadow_fn):

    '''handle crucial @shadow read logic.

    This will be called only if the public and private files both exist.'''

    x = self ; trace = False

    if trace and not g.app.unitTesting:
        g.trace('significant',x.isSignificantPublicFile(fn),fn)

    if x.isSignificantPublicFile(fn):
        # Update the private shadow file from the public file.
        written = x.propagate_changes(fn,shadow_fn)
        if written: x.message("updated private %s from public %s" % (shadow_fn, fn))
    else:
        # Create the public file from the private shadow file.
        x.copy_file_removing_sentinels(shadow_fn,fn)
        x.message("created public %s from private %s " % (fn, shadow_fn))
#@+node:ekr.20080708094444.27:x.copy_file_removing_sentinels
def copy_file_removing_sentinels (self,source_fn,target_fn):

    '''Copies sourcefilename to targetfilename, removing sentinel lines.'''

    x = self ; marker = x.marker_from_extension(source_fn)

    old_lines = file(source_fn).readlines()
    new_lines, junk = x.separate_sentinels(old_lines,marker)

    copy = not os.path.exists(target_fn) or old_lines != new_lines
    if copy:
        s = ''.join(new_lines)
        x.replaceFileWithString(target_fn,s)
#@-node:ekr.20080708094444.27:x.copy_file_removing_sentinels
#@-node:bwmulder.20041231170726:x.updatePublicAndPrivateFiles
#@-node:ekr.20080708094444.60: Leo overwrites
#@+node:ekr.20080710082231.3:(Added support for lax tests)
#@+node:ekr.20080709062932.10:runTest (atShadowTestCase)
def runTest (self,define_g = True):

    x = self.shadowController

    results = x.propagate_changed_lines(
        self.new_public_lines,
        self.old_private_lines,
        marker="#@",
        p = self.p.copy())

    if not self.lax and results != self.expected_private_lines:

        g.pr('%s atShadowTestCase.runTest:failure' % ('*' * 40))
        for aList,tag in ((results,'results'),(self.expected_private_lines,'expected_private_lines')):
            g.pr('%s...' % tag)
            for i, line in enumerate(aList):
                g.pr('%3s %s' % (i,repr(line)))
            g.pr('-' * 40)

        assert results == self.expected_private_lines

    assert self.ok
    return self.ok
#@nonl
#@-node:ekr.20080709062932.10:runTest (atShadowTestCase)
#@+node:ekr.20080708094444.38:x.propagate_changed_lines
def propagate_changed_lines(self,new_public_lines,old_private_lines,marker,p=None):

    '''Propagate changes from 'new_public_lines' to 'old_private_lines.

    We compare the old and new public lines, create diffs and
    propagate the diffs to the new private lines, copying sentinels as well.

    We have two invariants:
    1. We *never* delete any sentinels.
    2. Insertions that happen at the boundary between nodes will be put at
       the end of a node.  However, insertions must always be done within sentinels.
    '''

    x = self ; trace = False ; verbose = True
    # mapping tells which line of old_private_lines each line of old_public_lines comes from.
    old_public_lines, mapping = self.strip_sentinels_with_map(old_private_lines,marker)

    << init vars >>
    << define print_tags >>

    sm = difflib.SequenceMatcher(None,old_public_lines,new_public_lines)
    prev_old_j = 0 ; prev_new_j = 0

    for tag,old_i,old_j,new_i,new_j in sm.get_opcodes():

        << About this loop >>

        # Verify that SequenceMatcher never leaves gaps.
        if old_i != prev_old_j: # assert old_i == prev_old_j
            x.error('can not happen: gap in old:',old_i,prev_old_j)
        if new_i != prev_new_j: # assert new_i == prev_new_j
            x.error('can not happen: gap in new:',new_i,prev_new_j)

        << Handle the opcode >>

        # Remember the ends of the previous tag ranges.
        prev_old_j = old_j
        prev_new_j = new_j

    # Copy all unwritten sentinels.
    self.copy_sentinels(
        old_private_lines_rdr,new_private_lines_wtr,
        marker, limit = old_private_lines_rdr.size())

    # Get the result.
    result = new_private_lines_wtr.getlines()
    if 1:
        << do final correctness check>>
    return result
#@+node:ekr.20080708094444.40:<< init vars >>
new_private_lines_wtr = sourcewriter(self)
# collects the contents of the new file.

new_public_lines_rdr = sourcereader(self,new_public_lines)
    # Contains the changed source code.

old_public_lines_rdr = sourcereader(self,old_public_lines)
    # this is compared to new_public_lines_rdr to find out the changes.

old_private_lines_rdr = sourcereader(self,old_private_lines) # lines_with_sentinels)
    # This is the file which is currently produced by Leo, with sentinels.

# Check that all ranges returned by get_opcodes() are contiguous
old_old_j, old_i2_modified_lines = -1,-1

tag = old_i = old_j = new_i = new_j = None
#@nonl
#@-node:ekr.20080708094444.40:<< init vars >>
#@+node:ekr.20080708094444.39:<< define print_tags >>
def print_tags(tag, old_i, old_j, new_i, new_j, message):

    sep1 = '=' * 10 ; sep2 = '-' * 20

    g.pr('\n',sep1,message,sep1,p and p.headString())

    g.pr('\n%s: old[%s:%s] new[%s:%s]' % (tag,old_i,old_j,new_i,new_j))

    g.pr('\n',sep2)

    table = (
        (old_private_lines_rdr,'old private lines'),
        (old_public_lines_rdr,'old public lines'),
        (new_public_lines_rdr,'new public lines'),
        (new_private_lines_wtr,'new private lines'),
    )

    for f,tag in table:
        f.dump(tag)
        g.pr(sep2)


#@-node:ekr.20080708094444.39:<< define print_tags >>
#@+node:ekr.20080708192807.2:<< about this loop >>
@

This loop writes all output lines using a single writer: new_private_lines_wtr.

The output lines come from two, and *only* two readers:

1. old_private_lines_rdr delivers the complete original sources. All
   sentinels and unchanged regular lines come from this reader.

2. new_public_lines_rdr delivers the new, changed sources. All inserted or
   replacement text comes from this reader.

Each time through the loop, the following are true:

- old_i is the index into old_public_lines of the start of the present SequenceMatcher opcode.

- mapping[old_i] is the index into old_private_lines of the start of the same opcode.

At the start of the loop, the call to copy_sentinels effectively skips (deletes)
all previously unwritten non-sentinel lines in old_private_lines_rdr whose index
less than mapping[old_i].

As a result, the opcode handlers do not need to delete elements from the
old_private_lines_rdr explicitly. This explains why opcode handlers for the
'insert' and 'delete' opcodes are identical.
#@-node:ekr.20080708192807.2:<< about this loop >>
#@+node:ekr.20080708192807.5:<< Handle the opcode >>
# Do not copy sentinels if a) we are inserting and b) limit is at the end of the old_private_lines.
# In this special case, we must do the insert before the sentinels.
limit=mapping[old_i]

if trace: g.trace(tag,'old_i',old_i,'limit',limit)

if tag == 'insert' and limit >= old_private_lines_rdr.size():
    pass
else:
    # Ignore (delete) all unwritten lines of old_private_lines_rdr up to limit.
    # Because of this, nothing has to be explicitly deleted below.
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)

if tag == 'equal':
    # Copy all lines (including sentinels) from the old private file to the new private file.
    start = old_private_lines_rdr.index()
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        line = old_private_lines_rdr.get()
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,mapping[old_j-1]))

    # Ignore all new lines up to new_j: the same lines (with sentinels) have just been written.
    new_public_lines_rdr.sync(new_j)

elif tag in ('insert','replace'):
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Copy lines from new_public_lines_rdr up to new_j.
    start = new_public_lines_rdr.index()
    while new_public_lines_rdr.index() < new_j:
        line = new_public_lines_rdr.get()
        if x.is_sentinel(line,marker):
            new_private_lines_wtr.put('%sverbatim\n' % (marker),tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag=='delete':
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Leave new_public_lines_rdr unchanged.
    pass

else: g.trace('can not happen: unknown difflib.SequenceMather tag: %s' % repr(tag))

if trace and verbose:
    print_tags(tag, old_i, old_j, new_i, new_j, "After tag")
#@nonl
#@-node:ekr.20080708192807.5:<< Handle the opcode >>
#@+node:ekr.20080708094444.45:<< do final correctness check >>
t_sourcelines, t_sentinel_lines = self.separate_sentinels(
    new_private_lines_wtr.lines, marker)

self.check_the_final_output(
    new_private_lines   = result,
    new_public_lines    = new_public_lines,
    sentinel_lines      = t_sentinel_lines,
    marker              = marker)
#@-node:ekr.20080708094444.45:<< do final correctness check >>
#@-node:ekr.20080708094444.38:x.propagate_changed_lines
#@+node:ekr.20080708094444.35:x.check_the_final_output
def check_the_final_output(self, new_private_lines, new_public_lines, sentinel_lines, marker):
    """
    Check that we produced a valid output.

    Input:
        new_targetlines:   the lines with sentinels which produce changed_lines_without_sentinels.
        sentinels:         new_targetlines should include all the lines from sentinels.

    checks:
        1. new_targetlines without sentinels must equal changed_lines_without_sentinels.
        2. the sentinel lines of new_targetlines must match 'sentinels'
    """
    new_public_lines2, new_sentinel_lines2 = self.separate_sentinels (new_private_lines, marker)

    ok = True
    if new_public_lines2 != new_public_lines:
        ok = False
        self.show_error(
            lines1 = new_public_lines2,
            lines2 = new_public_lines,
            message = "Error in updating public file!",
            lines1_message = "new public lines (derived from new private lines)",
            lines2_message = "new public lines")
        # g.trace(g.callers())

    if new_sentinel_lines2 != sentinel_lines:
        ok = False
        self.show_error(
            lines1 = sentinel_lines,
            lines2 = new_sentinel_lines2,
            message = "Sentinals not preserved!",
            lines1_message = "old sentinels",
            lines2_message = "new sentinels")

    # if ok: g.trace("success!")
#@-node:ekr.20080708094444.35:x.check_the_final_output
#@-node:ekr.20080710082231.3:(Added support for lax tests)
#@+node:ekr.20080710082231.15:(Created c.shadowController)
#@-node:ekr.20080710082231.15:(Created c.shadowController)
#@+node:ekr.20080710082231.14:(Improved marker from extension)
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "autohotkey" : "; /* */", #TL - AutoHotkey language
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "cpp" : "// /* */",# C++.
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "// /* */", # 6/23/07: was "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#", # Set when @comment is seen.
    "xml" : "<!-- -->",
}

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "autohotkey" : "ahk", #TL - AutoHotkey language
    "c" : "c",
    "cpp" : "cpp",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt", # Set when @comment is seen.
    "xml": "xml",
}

self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey", #TL - AutoHotkey language
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb",
    "xml"   : "xml",
}
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@+node:ekr.20080708094444.9:x.marker_from_extension
def marker_from_extension (self,filename):

    '''Return the sentinel delimiter comment to be used for filename.'''

    delims = g.comment_delims_from_extension(filename)
    for i in (0,1):
        if delims[i] is not None:
            return delims[i]+'@'

    # Try some other choices.
    root, ext = os.path.splitext(filename)

    if ext=='.tmp':
        root, ext = os.path.splitext(root)

    if ext in('.h', '.c'):
        marker = "//@"
    elif ext in(".py", ".cfg", ".ksh", ".txt"):
        marker = '#@'
    elif ext in (".bat",):
        marker = "REM@"
    else:
        self.error("extension '%s' not known" % ext)
        marker = '#@' # Bug fix: 2008/8/4

    return marker
#@-node:ekr.20080708094444.9:x.marker_from_extension
#@-node:ekr.20080710082231.14:(Improved marker from extension)
#@+node:ekr.20080711093251.2:(Made @shadow a kind of file node)
#@+node:ekr.20040306211032:p.Comparisons
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atAutoNodeName            (self): return self.v.atAutoNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atShadowFileNodeName      (self): return self.v.atShadowFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtAutoNode            (self): return self.v.isAtAutoNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtShadowFileNode      (self): return self.v.isAtShadowFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
#@-node:ekr.20040306211032:p.Comparisons
#@+node:ekr.20031218072017.3348:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName (self):
    # h = self.headString() ; tag = '@auto'
    # # Prevent conflicts with autotrees plugin: don't allow @auto-whatever to match.
    # return g.match_word(h,0,tag) and not g.match(h,0,tag+'-') and h[len(tag):].strip()
    names = ("@auto",)
    return self.findAtFileName(names)

def atFileNodeName (self):
    names = ("@file",)
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atShadowFileNodeName (self):
    names = ("@shadow",)
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName
#@-node:ekr.20031218072017.3348:at...FileNodeName
#@+node:ekr.20040325073709:isAt...FileNode (vnode)
def isAtAutoNode (self):
    return g.choose(self.atAutoNodeName(),True,False)

def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)

def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtShadowFileNode (self):
    return g.choose(self.atShadowFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@-node:ekr.20040325073709:isAt...FileNode (vnode)
#@-node:ekr.20080711093251.2:(Made @shadow a kind of file node)
#@+node:ekr.20080710082231.8:(Patched goto-line-number)
#@+node:ekr.20080710082231.10:gotoLineNumber and helpers
#@+node:ekr.20031218072017.2864: goToLineNumber
def goToLineNumber (self,event=None,root=None,lines=None,n=None,scriptFind=False):

    '''Place the cursor on the n'th line of a derived file or script.'''

    # __pychecker__ = 'maxlines=400'

    c = self ; p = c.currentPosition() ; w = c.frame.body.bodyCtrl
    root1 = root
    if root is None:
        << set root >>
    if lines is None:
        << read the file into lines >>
    if n is None:
        << get n, the line number, from a dialog >>
    n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        << count outline lines, setting p,n2,found >>
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling:",root.headString())
            return
        << set p to the node given by vnodeName, etc. >>
    << select p and make it visible >>
    << put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2865:<< set root >>
# First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_with_unique_tnodes_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("no ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            g.pr(line,newline=False)
#@-node:ekr.20031218072017.2865:<< set root >>
#@+node:ekr.20031218072017.2866:<< read the file into lines >>
# 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found:",fileName)
    return
#@-node:ekr.20031218072017.2866:<< read the file into lines >>
#@+node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
n = g.app.gui.runAskOkCancelNumberDialog(c,"Enter Line Number","Line number:")
if n == -1:
    return
#@-node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
#@+node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) > 0 and s[-1] != '\n':
        lines += 1
    # g.pr(lines,prev,p)
    if prev + lines >= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)
#@-node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
#@+node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
if scriptFind:
    << just scan for the node name >>
elif gnx:
    << 4.2: get node from gnx >>
elif childIndex == -1:
    << 4.x: scan for the node using tnodeList and n >>
else:
    << 3.x: scan for the node with the given childIndex >>
#@+node:ekr.20041111093404:<< just scan for the node name >>
# This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@-node:ekr.20041111093404:<< just scan for the node name >>
#@+node:EKR.20040609110138:<< 4.2: get node from gnx >>
found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found:",vnodeName,color="red")
    return
#@-node:EKR.20040609110138:<< 4.2: get node from gnx >>
#@+node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
# This is about the best that can be done without replicating the entire atFile write logic.

ok = hasattr(root.v.t,"tnodeList")

if ok:
    # Use getattr to keep pylint happy.
    tnodeList = getattr(root.v.t,'tnodeList')
    << set tnodeIndex to the number of +node sentinels before line n >>
    tnodeIndex = max(0,tnodeIndex)
    << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
else:
    g.es_print("no child index for",root.headString(),color="red")

if not ok:
    # Fall back to the old logic.
    << set p to the first node whose headline matches vnodeName >>
#@+node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>

tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@-node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>

@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False
#@-node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    g.es_print(s, color="red")
    return
#@-node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
#@+node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex <= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found:",vnodeName, color="red")
    return
#@-node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
#@-node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
#@+node:ekr.20031218072017.2875:<< select p and make it visible >>
# c.beginUpdate()
# try:
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
# finally:
c.redraw() # was c.endUpdate()
#@-node:ekr.20031218072017.2875:<< select p and make it visible >>
#@+node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
s = w.getAllText()
if found:
    ins = g.convertRowColToPythonIndex(s,n2-1,0)    
    # c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    #c.frame.body.setInsertionPointToEnd()
    ins = len(s)
    g.es('only',len(lines),'lines',color="blue")

w.setInsertPoint(ins)
c.bodyWantsFocusNow()
w.seeInsertPoint()
#@-node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
#@-node:ekr.20031218072017.2864: goToLineNumber
#@+node:ekr.20080708094444.65:applyLineNumberMappingIfAny
def applyLineNumberMappingIfAny(self, n):

    c = self ; x = c.shadowController

    if len(x.line_mapping) > n:
        return x.line_mapping[n]
    else:
        return n

    # if hasattr(self,'line_mapping') and self.line_mapping:
        # return self.line_mapping[n]
    # else:
        # return n
#@nonl
#@-node:ekr.20080708094444.65:applyLineNumberMappingIfAny
#@+node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):

    """Convert a line number n to a vnode name, (child index or gnx) and line number."""

    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    << set vnodeName and (childIndex or gnx) from s >>
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line >= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line",str(n),"is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i > -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i < len(s) and colons < 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 < len(s) and s[i+1].isdigit():
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()

# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
#@-node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
#@-node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
#@+node:ekr.20080708094444.63:gotoLineNumberOpen
def gotoLineNumberOpen (self,filename):
    """
    Open a file for "goto linenumber" command and check if a shadow file exists.
    Construct a line mapping. This ivar is empty i no shadow file exists.
    Otherwise it contains a mapping shadow file number -> real file number.
    """
    try:
        c = self ; x = c.shadowController
        theDir, simplename = os.path.split(filename)
        shadow_filename = os.path.join(theDir,x.shadow_subdir,x.shadow_prefix + simplename)
        if os.path.exists(shadow_filename):
            lines = file(shadow_filename).readlines()
            c.line_mapping = x.push_filter_mapping(
                lines, x.marker_from_extension(shadow_filename))
        else:
            c.line_mapping = []
            lines = file(filename).readlines()
        return lines 
    except:
        # Make sure failures to open a file generate clear messages.
        g.es_exception()
        raise
#@nonl
#@-node:ekr.20080708094444.63:gotoLineNumberOpen
#@+node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
#@-node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
#@-node:ekr.20080710082231.10:gotoLineNumber and helpers
#@-node:ekr.20080710082231.8:(Patched goto-line-number)
#@+node:ekr.20080712080505.2:(Patched write code)
#@+node:ekr.20080712150045.1:at.replaceFileWithString
def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    at = self ; testing = g.app.unitTesting

    exists = g.os_path_exists(fn)

    if exists: # Read the file.  Return if it is the same.
        try:
            f = file(fn,'rb')
            s2 = f.read()
            f.close()
        except IOError:
            at.error('unexpected exception creating %s' % fn)
            g.es_exception()
            return False
        if s == s2:
            if not testing: g.es('unchanged:',fn)
            return False

    # Replace
    try:
        f = file(fn,'wb')
        f.write(s)
        f.close()
        if not testing:
            if exists:
                g.es('wrote:    ',fn)
            else:
                g.es('created:  ',fn)
        return True
    except IOError:
        at.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
#@-node:ekr.20080712150045.1:at.replaceFileWithString
#@+node:ekr.20080712150045.3:closeStringFile
def closeStringFile (self,theFile):

    at = self

    if theFile:
        theFile.flush()
        s = at.stringOutput = theFile.get()
        theFile.close()
        at.outputFile = None
        at.outputFileName = u''
        at.shortFileName = ''
        at.targetFileName = None
        return s
    else:
        return None
#@-node:ekr.20080712150045.3:closeStringFile
#@+node:ekr.20041005105605.135:closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):

    at = self

    if at.outputFile:
        at.outputFile.flush()
        if at.toString:
            at.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
        return at.stringOutput
    else:
        return None
#@-node:ekr.20041005105605.135:closeWriteFile
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.

    The caller is responsible for handling newlines correctly."""

    @others
#@+node:ekr.20050404151753: ctor
def __init__(self,fromString=None):

    # New in 4.2.1: allow the file to be inited from string s.
    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0

# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.
#@-node:ekr.20050404151753: ctor
#@+node:ekr.20050404151753.1:clear
def clear (self):

    self.list = []
#@-node:ekr.20050404151753.1:clear
#@+node:ekr.20050404151753.2:close
def close (self):

    pass

    # The StringIo version free's the memory buffer.
#@-node:ekr.20050404151753.2:close
#@+node:ekr.20050404151753.3:flush
def flush (self):

    pass
#@-node:ekr.20050404151753.3:flush
#@+node:ekr.20050404151753.4:get & getvalue & read
def get (self):

    return ''.join(self.list)

getvalue = get # for compatibility with StringIo
read = get # for use by sax.
#@-node:ekr.20050404151753.4:get & getvalue & read
#@+node:ekr.20050404151753.5:readline
def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr < len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''
#@-node:ekr.20050404151753.5:readline
#@+node:ekr.20050404151753.6:write
def write (self,s):

    if s:
        self.list.append(s)
#@-node:ekr.20050404151753.6:write
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@+node:ekr.20080712150045.4:g.getIvarsDict and checkUnchangedIvars
def getIvarsDict(obj):

    '''Return a dictionary of ivars:values for non-methods of obj.'''

    import types

    d = dict(
        [[key,getattr(obj,key)] for key in dir(obj)
            if type (getattr(obj,key)) != types.MethodType])

    # keys = d.keys() ; keys.sort() ;g.pr(g.listToString(keys))
    return d

def checkUnchangedIvars(obj,d,exceptions=None):

    if not exceptions: exceptions = []
    ok = True

    for key in d.keys():
        if key not in exceptions:
            if getattr(obj,key) != d.get(key):
                g.trace('changed ivar: %s old: %s new: %s' % (
                    key,repr(d.get(key)),repr(getattr(obj,key))))
                ok = False
    return ok
#@-node:ekr.20080712150045.4:g.getIvarsDict and checkUnchangedIvars
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None,
    write_strips_blank_lines=None,
):

    self.initCommonIvars()
    << init ivars for writing >>

    if write_strips_blank_lines is None:
        self.write_strips_blank_lines = self.c.config.getBool('write_strips_blank_lines')
    else:
        self.write_strips_blank_lines = write_strips_blank_lines

    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels)

    # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)

    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root

    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'

    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        self.root.v.t.tnodeList = []
        self.root.v.t._p_changed = True
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False
self.force_newlines_in_at_nosent_bodies = self.c.config.getBool('force_newlines_in_at_nosent_bodies')

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@+node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
def openFileForWriting (self,root,fileName,toString):

    at = self
    at.outputFile = None

    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "<string: %s>" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        ok = at.openFileForWritingHelper(fileName)

        # New in Leo 4.4.8: set dirty bit if there are errors.
        if not ok: at.outputFile = None

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()

    return at.outputFile is not None
#@+node:ekr.20041005105605.143:openFileForWritingHelper & helper
def openFileForWritingHelper (self,fileName):

    '''Open the file and return True if all went well.'''

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return False
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return False

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not open: read only: " + at.targetFileName)
                return False
        except AttributeError:
            pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
            return False
    except Exception:
        at.exception("exception creating:" + at.outputFileName)
        return False

    return True
#@+node:bwmulder.20050101094804:openForWrite (atFile)
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    c = self.c ; x = c.shadowController ; trace = True or x.trace

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace and not g.app.unitTesting: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)

        return open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return None
#@-node:bwmulder.20050101094804:openForWrite (atFile)
#@-node:ekr.20041005105605.143:openFileForWritingHelper & helper
#@-node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
#@+node:bwmulder.20050101094804:openForWrite (atFile)
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    c = self.c ; x = c.shadowController ; trace = True or x.trace

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace and not g.app.unitTesting: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)

        return open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return None
#@-node:bwmulder.20050101094804:openForWrite (atFile)
#@+node:ekr.20080712150045.2:openStringFile
def openStringFile (self,fn):

    at = self

    at.shortFileName = g.shortFileName(fn)
    at.outputFileName = "<string: %s>" % at.shortFileName
    at.outputFile = g.fileLikeObject()
    at.targetFileName = "<string-file>"

    return at.outputFile
#@-node:ekr.20080712150045.2:openStringFile
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    at = self

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.bodyString())

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    if self.write_strips_blank_lines:
        s = self.cleanLines(p,s)
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
@

If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if (at.sentinels or at.force_newlines_in_at_nosent_bodies) and not trailingNewlineFlag:
        # g.trace('Added newline',repr(s))
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
# g.trace(kind,repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@+node:ekr.20031218072017.1863:putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    # Not writing @auto nodes is way too dangerous.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    if isIgnore:   forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = False     # Never write non-ignored @auto trees.
    elif isShadow: forceWrite = False   # Never write non-ignored @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Only write orphan @thin trees.
    else:          forceWrite = True      # Write all other @file trees.

    << Set gnx = tnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append tnodeList and unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s><vh>%s</vh>' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        << issue informational messages >>
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('</v>\n')
    else:
        fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
# New in Leo 4.4.8.  Assign v.t.fileIndex here as needed.
if not v.t.fileIndex:
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)

if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
#@-node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
#@+node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren(): attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"

    # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    # if not self.use_sax:
        # if p.equal(self.topPosition):     attr += "T" # was a bottleneck
        # if p.equal(self.currentPosition): attr += "V" # was a bottleneck

    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    if not c.fixed:
        d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@-node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
#@+node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin or isShadow:
        if 1:
            if g.app.unitTesting:
                g.app.unitTestDict["warning"] = True
            g.es("deleting tnode list for",p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))
#@nonl
#@-node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
#@+node:ekr.20040702085529:<< issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.headString(),color="blue")
    p.clearOrphan()
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent & helper
def replaceTargetFileIfDifferent (self,root):

    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.

    Return True if the original file was changed.
    '''

    assert(self.outputFile is None)

    if self.toString:
        # Do *not* change the actual file or set any dirty flag.
        self.fileChangedFlag = False
        return False

    if root:
        # The default: may be changed later.
        root.clearOrphan()
        root.clearDirty()

    if g.os_path_exists(self.targetFileName):
        if self.compareFiles(self.outputFileName,self.targetFileName,not self.explicitLineEnding):
            # Files are identical.
            ok = self.remove(self.outputFileName)
            if not ok:
                # self.remove gives the error.
                # g.es('error removing temp file',color='red')
                g.es('unchanged:',self.shortFileName)
                if root: root.setDirty() # New in 4.4.8.
            g.es('unchanged:',self.shortFileName)

            self.fileChangedFlag = False
            return False
        else:
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('wrote:    ',self.shortFileName)
            else:
                # self.rename gives the error.
                # g.es('error removing temp file',color='red')
                g.es('unchanged:',self.shortFileName)
                if root: root.setDirty() # New in 4.4.8.

            self.fileChangedFlag = ok
            return ok
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('created:  ',self.targetFileName)
        else:
            # self.rename gives the error.
            # g.es('error renaming temp file',color='red')
            # g.es('unchanged:',self.targetFileName)
            if root: root.setDirty() # New in 4.4.8.

        # No original file to change. Return value tested by a unit test.
        self.fileChangedFlag = False 
        return False
#@nonl
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in:",self.targetFileName,color="blue")
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent & helper
#@+node:ekr.20041005105605.147:writeAll (atFile)
def writeAll(self,
    writeAtFileNodesFlag=False,
    writeDirtyAtFileNodesFlag=False,
    toString=False,
):

    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False ; atOk = True

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    atOk = True
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave,atOk
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p,toString=toString,force=False)
        writtenFiles.append(p.v.t)
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtShadowFileNode():
        at.writeOneAtShadowNode(p,toString=toString,force=False)
        writtenFiles.append(p.v.t) ; autoSave = True # 2008/7/29
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.errors: atOk = False

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll (atFile)
#@+node:ekr.20080711093251.3:writeAtShadowdNodes & writeDirtyAtShadowNodes (atFile) & helpers
def writeAtShadowNodes (self,event=None):

    '''Write all @shadow nodes in the selected outline.'''

    at = self
    return at.writeAtShadowNodesHelper(writeDirtyOnly=False)

def writeDirtyAtShadowNodes (self,event=None):

    '''Write all dirty @shadow nodes in the selected outline.'''

    at = self
    return at.writeAtShadowNodesHelper(writeDirtyOnly=True)
#@nonl
#@+node:ekr.20080711093251.4:writeAtShadowNodesHelper
def writeAtShadowNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @shadow nodes in the selected outline"""

    at = self ; c = at.c
    p = c.currentPosition() ; after = p.nodeAfterTree()
    found = False

    while p and p != after:
        if p.atShadowFileNodeName() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = at.writeOneAtShadowNode(p,toString=toString,force=True)
            if ok:
                found = True
                g.es('wrote %s' % p.atShadowFileNodeName(),color='blue')
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @shadow nodes in the selected tree")
    else:
        g.es("no @shadow nodes in the selected tree")

    return found
#@-node:ekr.20080711093251.4:writeAtShadowNodesHelper
#@+node:ekr.20080711093251.5:writeOneAtShadowNode & helper
def writeOneAtShadowNode(self,p,toString,force):

    '''Write p, an @shadow node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy() ; x = c.shadowController

    fn = p.atShadowFileNodeName()
    if not fn:
        g.trace('can not happen: not an @shadow node',p.headString())
        return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fn = g.os_path_join(at.default_directory,fn)
    exists = g.os_path_exists(fn)

    if not toString and not self.shouldWriteAtShadowNode(p,exists,force):
        return False

    c.endEditing() # Capture the current headline.
    at.initWriteIvars(root,targetFileName=None,
        nosentinels=None, # set below.  Affects only error messages (sometimes).
        thinFile=True, # New in Leo 4.5 b2: private files are thin files.
        scriptWrite=False,
        toString=False, # True: create a fileLikeObject.  This is done below.
        write_strips_blank_lines=False)
            # at.targetFileName not used.

    if g.app.unitTesting: ivars_dict = g.getIvarsDict(at)

    # Write the public and private files to public_s and private_s strings.
    data = []
    for sentinels in (False,True):
        theFile = at.openStringFile(fn)
        at.sentinels = sentinels
        at.writeOpenFile(root,nosentinels=not sentinels,toString=False,atAuto=False)
            # nosentinels only affects error messages, and then only if atAuto is True.
        s = at.closeStringFile(theFile)
        data.append(s)

    # Set these new ivars for unit tests.
    at.public_s, at.private_s = data

    if g.app.unitTesting:
        exceptions = ('public_s','private_s','sentinels','stringOutput')
        assert g.checkUnchangedIvars(at,ivars_dict,exceptions)

    if at.errors == 0 and not toString:
        ### It may be better to compute the public file by removing sentinels from at.private_s
        ### by calling x.copy_file_removing_sentinels. This would ensure that the (dubious!!)
        ### x.isSentinel logic is used consistently by the @shadow read/write logic.
        ### OTOH, Leo's write logic should actually dominate x.isSentinel.

        # Write the public and private files.
        private_fn = x.shadowPathName(fn)
        x.makeShadowDirectory(fn) # makeShadowDirectory takes a *public* file name.
        at.replaceFileWithString(private_fn,at.private_s)
        at.replaceFileWithString(fn,at.public_s)

    if at.errors == 0:
        root.clearOrphan()
        root.clearDirty()
    else:
        g.es("not written:",at.outputFileName)
        root.setDirty() # New in Leo 4.4.8.

    return at.errors == 0
#@+node:ekr.20080711093251.6:shouldWriteAtShadowNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @shadow x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @shadow node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @shadow file.
- The explicit commands that read and write @shadow trees must always be honored.
@c

def shouldWriteAtShadowNode (self,p,exists,force):

    '''Return True if we should write the @shadow node at p.'''

    if force: # We are executing write-at-shadow-node or write-dirty-at-shadow-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.headString(),'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @shadow tree is dirty and contains significant info.
        return True
#@-node:ekr.20080711093251.6:shouldWriteAtShadowNode
#@-node:ekr.20080711093251.5:writeOneAtShadowNode & helper
#@-node:ekr.20080711093251.3:writeAtShadowdNodes & writeDirtyAtShadowNodes (atFile) & helpers
#@+node:ekr.20080711093251.5:writeOneAtShadowNode & helper
def writeOneAtShadowNode(self,p,toString,force):

    '''Write p, an @shadow node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy() ; x = c.shadowController

    fn = p.atShadowFileNodeName()
    if not fn:
        g.trace('can not happen: not an @shadow node',p.headString())
        return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fn = g.os_path_join(at.default_directory,fn)
    exists = g.os_path_exists(fn)

    if not toString and not self.shouldWriteAtShadowNode(p,exists,force):
        return False

    c.endEditing() # Capture the current headline.
    at.initWriteIvars(root,targetFileName=None,
        nosentinels=None, # set below.  Affects only error messages (sometimes).
        thinFile=True, # New in Leo 4.5 b2: private files are thin files.
        scriptWrite=False,
        toString=False, # True: create a fileLikeObject.  This is done below.
        write_strips_blank_lines=False)
            # at.targetFileName not used.

    if g.app.unitTesting: ivars_dict = g.getIvarsDict(at)

    # Write the public and private files to public_s and private_s strings.
    data = []
    for sentinels in (False,True):
        theFile = at.openStringFile(fn)
        at.sentinels = sentinels
        at.writeOpenFile(root,nosentinels=not sentinels,toString=False,atAuto=False)
            # nosentinels only affects error messages, and then only if atAuto is True.
        s = at.closeStringFile(theFile)
        data.append(s)

    # Set these new ivars for unit tests.
    at.public_s, at.private_s = data

    if g.app.unitTesting:
        exceptions = ('public_s','private_s','sentinels','stringOutput')
        assert g.checkUnchangedIvars(at,ivars_dict,exceptions)

    if at.errors == 0 and not toString:
        ### It may be better to compute the public file by removing sentinels from at.private_s
        ### by calling x.copy_file_removing_sentinels. This would ensure that the (dubious!!)
        ### x.isSentinel logic is used consistently by the @shadow read/write logic.
        ### OTOH, Leo's write logic should actually dominate x.isSentinel.

        # Write the public and private files.
        private_fn = x.shadowPathName(fn)
        x.makeShadowDirectory(fn) # makeShadowDirectory takes a *public* file name.
        at.replaceFileWithString(private_fn,at.private_s)
        at.replaceFileWithString(fn,at.public_s)

    if at.errors == 0:
        root.clearOrphan()
        root.clearDirty()
    else:
        g.es("not written:",at.outputFileName)
        root.setDirty() # New in Leo 4.4.8.

    return at.errors == 0
#@+node:ekr.20080711093251.6:shouldWriteAtShadowNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @shadow x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @shadow node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @shadow file.
- The explicit commands that read and write @shadow trees must always be honored.
@c

def shouldWriteAtShadowNode (self,p,exists,force):

    '''Return True if we should write the @shadow node at p.'''

    if force: # We are executing write-at-shadow-node or write-dirty-at-shadow-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.headString(),'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @shadow tree is dirty and contains significant info.
        return True
#@-node:ekr.20080711093251.6:shouldWriteAtShadowNode
#@-node:ekr.20080711093251.5:writeOneAtShadowNode & helper
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString='',atAuto=False):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v.t._bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if atAuto or (not toString and not nosentinels):
        at.warnAboutOrphandAndIgnoredNodes()
#@-node:ekr.20041005105605.157:writeOpenFile
#@+node:ekr.20080711063656.1:x.File utils
#@+node:ekr.20080711063656.7:x.baseDirName
def baseDirName (self):

    x = self ; filename = x.c.fileName()

    if filename:
        return g.os_path_dirname(g.os_path_abspath(filename))
    else:
        self.error('Can not compute shadow path: .leo file has not been saved')
        return None
#@nonl
#@-node:ekr.20080711063656.7:x.baseDirName
#@+node:ekr.20080711063656.4:x.dirName and pathName
def dirName (self,filename):

    '''Return the directory for filename.'''

    x = self

    return g.os_path_dirname(x.pathName(filename))

def pathName (self,filename):

    '''Return the full path name of filename.'''

    x = self ; theDir = x.baseDirName()

    return theDir and g.os_path_abspath(g.os_path_join(theDir,filename))
#@nonl
#@-node:ekr.20080711063656.4:x.dirName and pathName
#@+node:ekr.20080712080505.3:x.isSignificantPublicFile
def isSignificantPublicFile (self,fn):

    '''This tells the atFile.read logic whether to import a public file or use an existing public file.'''

    return g.os_path_exists(fn) and g.os_path_isfile(fn) and g.os_path_getsize(fn) > 10
#@-node:ekr.20080712080505.3:x.isSignificantPublicFile
#@+node:ekr.20080710082231.19:x.makeShadowDirectory
def makeShadowDirectory (self,fn):

    '''Make a shadow directory for the **public** fn.'''

    x = self ; path = x.shadowDirName(fn)

    if not g.os_path_exists(path):

        try:
            # g.trace('making',path)
            os.mkdir(path)
        except Exception:
            x.error('unexpected exception creating %s' % path)
            g.es_exception()
            return False

    return g.os_path_exists(path) and g.os_path_isdir(path)
#@-node:ekr.20080710082231.19:x.makeShadowDirectory
#@+node:ekr.20080711063656.2:x.rename
def rename (self,src,dst,mode=None,silent=False):

    x = self ; c = x.c

    ok = g.utils_rename (c,src,dst,mode=mode,verbose=not silent)
    if not ok:
        x.error('can not rename %s to %s' % (src,dst),silent=silent)

    return ok
#@-node:ekr.20080711063656.2:x.rename
#@+node:ekr.20080713091247.1:x.replaceFileWithString
def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    x = self ; testing = g.app.unitTesting

    exists = g.os_path_exists(fn)

    if exists: # Read the file.  Return if it is the same.
        try:
            f = file(fn,'rb')
            s2 = f.read()
            f.close()
        except IOError:
            x.error('unexpected exception creating %s' % fn)
            g.es_exception()
            return False
        if s == s2:
            if not testing: g.es('unchanged:',fn)
            return False

    # Replace the file.
    try:
        f = file(fn,'wb')
        f.write(s)
        f.close()
        if not testing:
            if exists:  g.es('wrote:    ',fn)
            else:       g.es('created:  ',fn)
        return True
    except IOError:
        x.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
#@-node:ekr.20080713091247.1:x.replaceFileWithString
#@+node:ekr.20080711063656.6:x.shadowDirName and shadowPathName
def shadowDirName (self,filename):

    '''Return the directory for the shadow file corresponding to filename.'''

    x = self

    return g.os_path_dirname(x.shadowPathName(filename))

def shadowPathName (self,filename):

    '''Return the full path name of filename, resolved using c.fileName()'''

    x = self ; baseDir = x.baseDirName()
    fileDir = g.os_path_dirname(filename)
    # g.trace(baseDir)
    # g.trace(x.shadow_subdir)
    # g.trace(fileDir)

    return baseDir and g.os_path_abspath(g.os_path_normpath(g.os_path_join(
            baseDir,
            fileDir, # Bug fix: honor any directories specified in filename.
            x.shadow_subdir,
            x.shadow_prefix + g.shortFileName(filename))))
#@nonl
#@-node:ekr.20080711063656.6:x.shadowDirName and shadowPathName
#@+node:ekr.20080711063656.3:x.unlink
def unlink (self, filename,silent=False):

    '''Unlink filename from the file system.
    Give an error on failure.'''

    x = self

    ok = g.utils_remove(filename, verbose=not silent)
    if not ok:
        x.error('can not delete %s' % (filename),silent=silent)

    return ok
#@-node:ekr.20080711063656.3:x.unlink
#@-node:ekr.20080711063656.1:x.File utils
#@+node:ekr.20080710082231.19:x.makeShadowDirectory
def makeShadowDirectory (self,fn):

    '''Make a shadow directory for the **public** fn.'''

    x = self ; path = x.shadowDirName(fn)

    if not g.os_path_exists(path):

        try:
            # g.trace('making',path)
            os.mkdir(path)
        except Exception:
            x.error('unexpected exception creating %s' % path)
            g.es_exception()
            return False

    return g.os_path_exists(path) and g.os_path_isdir(path)
#@-node:ekr.20080710082231.19:x.makeShadowDirectory
#@-node:ekr.20080712080505.2:(Patched write code)
#@+node:ekr.20080713091247.4:(Fixed problem with 'can not read 3.x derived file' message)
@nocolor

Callers of at.read:
    .checkDerivedFile
    .readOneAtShadowNode (if isSignificantPublicFile)
    .importDerivedFiles

readOneAtShadowNode
    at.read(atShadow=True)
        at.openFileForReading(atShadow=True)

What I did:

- readOneAtShadowNode now checks that both public and private files exist, and
  that that the public file is significant. Only in that case does
  readOneAtShadowNode call at.read. Otherwise, we import the file.

- When atShadow is True, openFileForReading now fails if either the public or
  private files exist. This is, in effect, an assertion.    

@color
#@nonl
#@+node:ekr.20041005105605.19:openFileForReading (atFile)
def openFileForReading(self,fn,fromString=False,atShadow=False):

    at = self ; trace = True and not g.app.unitTesting ; verbose = False

    if fromString:
        if atShadow:
            return at.error('can not call read(atShadow=True,fromString=aString)')
        at.inputFile = g.fileLikeObject(fromString=fromString)
    else:
        fn = g.os_path_abspath(g.os_path_normpath(g.os_path_join(at.default_directory,fn)))

        if atShadow:
            x = at.c.shadowController
            # readOneAtShadowNode should already have checked these.
            shadow_fn       = x.shadowPathName(fn)
            shadow_exists   = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
            # x.updatePublicAndPrivate will create the public file from the private file
            # if the public file exists. This *is* reasonable: there is nothing to import!
            # if not g.os_path_exists(fn):
                # g.trace('oops public',fn,g.callers())
                # return at.error('can not happen: public file does not exist: %s' % (fn))
            if not shadow_exists:
                g.trace('oops private',shadow_fn,g.callers())
                return at.error('can not happen: private file does not exist: %s' % (shadow_fn))
            # This method is the gateway to the essence of the shadow algorithm.
            x.updatePublicAndPrivateFiles(fn,shadow_fn)
            fn = shadow_fn

        try:
            # Open the file in binary mode to allow 0x1a in bodies & headlines.
            if trace and verbose and atShadow: g.trace('opening %s file: %s' % (
                g.choose(atShadow,'private','public'),fn))
            at.inputFile = open(fn,'rb')
            at.warnOnReadOnlyFile(fn)
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None

    return at.inputFile # for unit tests.
#@-node:ekr.20041005105605.19:openFileForReading (atFile)
#@+node:ekr.20041005105605.120:parseLeoSentinel
def parseLeoSentinel (self,s):

    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    start = '' ; end = '' ; isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    << set the opening comment delim >>
    << make sure we have @+leo >>
    << read optional version param >>
    << read optional thin param >>
    << read optional encoding param >>
    << set the closing comment delim >>
    if not new_df:
        g.trace('not new_df(!)',repr(s))
    return valid,new_df,start,end,isThinDerivedFile
#@+node:ekr.20041005105605.121:<< set the opening comment delim >>
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j < i:
    start = s[j:i]
else:
    valid = False

#@-node:ekr.20041005105605.121:<< set the opening comment delim >>
#@+node:ekr.20041005105605.122:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False
#@-node:ekr.20041005105605.122:<< make sure we have @+leo >>
#@+node:ekr.20041005105605.123:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
    # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
    # Leo 4.4.1 +:   Skip to next minus sign, end-of-line, or non numeric character.
    # This is required to handle trailing comment delims properly.
    i += len(version_tag)
    j = i
    while i < len(s) and (s[i] == '.' or s[i].isdigit()):
        i += 1

    if j < i:
        pass
    else:
        valid = False
#@-node:ekr.20041005105605.123:<< read optional version param >>
#@+node:ekr.20041005105605.124:<< read optional thin param >>
if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
#@-node:ekr.20041005105605.124:<< read optional thin param >>
#@+node:ekr.20041005105605.125:<< read optional encoding param >>
# Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j > -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j > -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            g.es_print("bad encoding in derived file:",encoding)
    else:
        valid = False
#@-node:ekr.20041005105605.125:<< read optional encoding param >>
#@+node:ekr.20041005105605.126:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
#@-node:ekr.20041005105605.126:<< set the closing comment delim >>
#@-node:ekr.20041005105605.120:parseLeoSentinel
#@+node:ekr.20041005105605.21:read (atFile)
def read(self,root,importFileName=None,thinFile=False,fromString=None,atShadow=False):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString,atShadow=atShadow)
    if not at.inputFile: return False
    if not g.unitTesting:
        g.es("reading:",root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>
    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
resurrected = 0
for p in root.self_and_subtree_iter():

    if not p.v.t.isVisited():
        g.es('resurrected node:',p.headString(),color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for t in c.all_unique_tnodes_iter():

    if hasattr(t,"tempBodyString"):
        delattr(t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile)
#@+node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

    fn = g.os_path_abspath(g.os_path_normpath(g.os_path_join(at.default_directory,fn)))
    shadow_fn       = x.shadowPathName(fn)
    shadow_exists   = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
    # significant     = x.isSignificantPublicFile(fn)

    if shadow_exists:
        # x.updatePublicAndPrivateFiles creates the public file if it does not exist.
        at.read(p,
            thinFile=True, # The shadow file contains sentinels: new in Leo 4.5 b2.
            atShadow=True)
            # Calls x.updatePublicAndPrivateFiles
    else:
        if not g.unitTesting: g.es("reading:",p.headString())
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # x.makeShadowFile(fn,p)
            at.writeOneAtShadowNode(p,toString=False,force=True)
#@+node:ekr.20080712080505.1:importAtShadowNode
def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
#@-node:ekr.20080712080505.1:importAtShadowNode
#@-node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
#@+node:ekr.20041005105605.27:readOpenFile
def readOpenFile(self,root,theFile,fileName):

    '''Read an open derived file.

    Leo 4.5 and later can only read 4.x derived files.'''

    at = self

    firstLines,read_new,junk = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        # lastLines = at.scanText3(theFile,root,[],at.endLeo)
        lastLines = []
        g.es('can not read 3.x derived file',fileName,color='red')
        g.es('you may upgrade these file using Leo 4.0 through 4.4.x')
        g.trace('root',root and root.headString(),fileName)

    if root:
        root.v.t.setVisited() # Disable warning about set nodes.

    << handle first and last lines >>
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.t.tempBodyString
except Exception:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@-node:ekr.20041005105605.27:readOpenFile
#@+node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
def scanHeader(self,theFile,fileName):

    """Scan the @+leo sentinel.

    Sets self.encoding, and self.start/endSentinelComment.

    Returns (firstLines,new_df,isThinDerivedFile) where:
    firstLines        contains all @first lines,
    new_df            is True if we are reading a new-format derived file.
    isThinDerivedFile is True if the file is an @thin file."""

    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    << skip any non @+leo lines >>
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
        # g.trace('start',repr(start),'end',repr(end))
    else:
        at.error("Bad @+leo sentinel in: %s" % fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile
#@+node:ekr.20041005105605.130:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
while len(s) > 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)

n = len(s)
valid = n > 0
#@-node:ekr.20041005105605.130:<< skip any non @+leo lines >>
#@-node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
#@+node:ekr.20080712080505.3:x.isSignificantPublicFile
def isSignificantPublicFile (self,fn):

    '''This tells the atFile.read logic whether to import a public file or use an existing public file.'''

    return g.os_path_exists(fn) and g.os_path_isfile(fn) and g.os_path_getsize(fn) > 10
#@-node:ekr.20080712080505.3:x.isSignificantPublicFile
#@+node:bwmulder.20041231170726:x.updatePublicAndPrivateFiles
def updatePublicAndPrivateFiles (self,fn,shadow_fn):

    '''handle crucial @shadow read logic.

    This will be called only if the public and private files both exist.'''

    x = self ; trace = False

    if trace and not g.app.unitTesting:
        g.trace('significant',x.isSignificantPublicFile(fn),fn)

    if x.isSignificantPublicFile(fn):
        # Update the private shadow file from the public file.
        written = x.propagate_changes(fn,shadow_fn)
        if written: x.message("updated private %s from public %s" % (shadow_fn, fn))
    else:
        # Create the public file from the private shadow file.
        x.copy_file_removing_sentinels(shadow_fn,fn)
        x.message("created public %s from private %s " % (fn, shadow_fn))
#@+node:ekr.20080708094444.27:x.copy_file_removing_sentinels
def copy_file_removing_sentinels (self,source_fn,target_fn):

    '''Copies sourcefilename to targetfilename, removing sentinel lines.'''

    x = self ; marker = x.marker_from_extension(source_fn)

    old_lines = file(source_fn).readlines()
    new_lines, junk = x.separate_sentinels(old_lines,marker)

    copy = not os.path.exists(target_fn) or old_lines != new_lines
    if copy:
        s = ''.join(new_lines)
        x.replaceFileWithString(target_fn,s)
#@-node:ekr.20080708094444.27:x.copy_file_removing_sentinels
#@-node:bwmulder.20041231170726:x.updatePublicAndPrivateFiles
#@-node:ekr.20080713091247.4:(Fixed problem with 'can not read 3.x derived file' message)
#@+node:ekr.20080713091247.5:Finished @shadow commands
@ Add new read/write @shadow nodes commands.
#@nonl
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'beautify-all':                 c.beautifyAllPythonCode,
    'beautify-tree':                c.beautifyPythonTree,
    'beautify':                     c.beautifyPythonCode,
    'cascade-windows':              f.cascade,
    'check-derived-file':           c.atFileCommands.checkDerivedFile,
    'check-leo-file':               c.fileCommands.checkLeoFile,
    'clear-recent-files':           c.clearRecentFiles,
    'clean-recent-files':           c.cleanRecentFiles,
    'sort-recent-files':            c.sortRecentFiles,
    'close-window':                 c.close,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'check-python-code':            c.checkPythonCode,
    'check-all-python-code':        c.checkAllPythonCode,
    'check-outline':                c.checkOutline,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'contract-node':                c.contractNode,
    'contract-all':                 c.contractAllHeadlines,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-section':              c.extractSection,
    'find-next-clone':              c.findNextClone,
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-visible-node':      c.goToFirstVisibleNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible-node':       c.goToLastVisibleNode,
    'goto-line-number':             c.goToLineNumber,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hide-invisibles':              c.hideInvisibles,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-child':                 c.insertChild,
    'insert-node':                  c.insertHeadline,
    'insert-body-time':             c.insertBodyTime,
    'insert-headline-time':         f.insertHeadlineTime,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    'mark-changed-roots':           c.markChangedRoots,
    'mark-clones':                  c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-brackets':               c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-scripts-leo':             c.openLeoScripts,
    'open-myLeoSettings-leo':       c.openMyLeoSettings,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-offline-tutorial':        f.leoHelp,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    # 'open-test-leo':              c.openTest, # Doesn't work.
    'open-users-guide':             c.leoUsersGuide,
    'open-with':                    c.openWith,
    'outline-to-cweb':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-auto-nodes':           c.readAtAutoNodes,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-at-shadow-nodes':         c.readAtShadowNodes,
    'read-outline-only':            c.readOutlineOnly,
    'read-file-into-node':          c.readFileIntoNode,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-as-unzipped':        c.saveAsUnzipped,
    'save-file-as-zipped':          c.saveAsZipped,
    'save-file-to':                 c.saveTo,
    'settings':                     c.preferences,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'show-invisibles':              c.showInvisibles,
    'sort-children':                c.sortChildren,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-invisibles':            c.toggleShowInvisibles,
    'toggle-sparce-move':           c.toggleSparseMove,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-auto-nodes':          c.atFileCommands.writeAtAutoNodes,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-at-shadow-nodes':        c.fileCommands.writeAtShadowNodes,
    'write-dirty-at-auto-nodes':    c.atFileCommands.writeDirtyAtAutoNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-dirty-at-shadow-nodes':  c.fileCommands.writeDirtyAtShadowNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
    'write-file-from-node':         c.writeFileFromNode,
}
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@+node:ekr.20080801071227.4:readAtShadowNodes (commands)
def readAtShadowNodes (self,event=None):

    '''Read all @shadow nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    c.atFileCommands.readAtShadowNodes(p)
    u.afterChangeTree(p,'Read @shadow Nodes',undoData)
    c.redraw() 
#@-node:ekr.20080801071227.4:readAtShadowNodes (commands)
#@+node:ekr.20080801071227.7:readAtShadowNodes (atFile)
def readAtShadowNodes (self,p):

    '''Read all @shadow nodes in the p's tree.'''

    at = self ; after = p.nodeAfterTree()
    p = p.copy() # Don't change p in the caller.

    while p and not p.equal(after): # Don't use iterator.
        if p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
#@-node:ekr.20080801071227.7:readAtShadowNodes (atFile)
#@+node:ekr.20080801071227.5:writeAtShadowNodes (fileCommands)
def writeAtShadowNodes (self,event=None):

    '''Write all @file nodes in the selected outline.'''

    c = self.c

    changedFiles,atOk = c.atFileCommands.writeAll(writeAtFileNodesFlag=True)

    if changedFiles:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to set or clear tnodeList.
#@-node:ekr.20080801071227.5:writeAtShadowNodes (fileCommands)
#@+node:ekr.20080801071227.6:writeDirtyAtShadowNodes (fileCommands)
def writeDirtyAtShadowNodes (self,event=None):

    '''Write all changed @shadow Nodes.'''

    c = self.c ; at = c.atFileCommands

    changed = at.writeDirtyAtShadowNodes()

    if changed:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to set or clear tnodeList.
#@-node:ekr.20080801071227.6:writeDirtyAtShadowNodes (fileCommands)
#@+node:ekr.20080711093251.3:writeAtShadowdNodes & writeDirtyAtShadowNodes (atFile) & helpers
def writeAtShadowNodes (self,event=None):

    '''Write all @shadow nodes in the selected outline.'''

    at = self
    return at.writeAtShadowNodesHelper(writeDirtyOnly=False)

def writeDirtyAtShadowNodes (self,event=None):

    '''Write all dirty @shadow nodes in the selected outline.'''

    at = self
    return at.writeAtShadowNodesHelper(writeDirtyOnly=True)
#@nonl
#@+node:ekr.20080711093251.4:writeAtShadowNodesHelper
def writeAtShadowNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @shadow nodes in the selected outline"""

    at = self ; c = at.c
    p = c.currentPosition() ; after = p.nodeAfterTree()
    found = False

    while p and p != after:
        if p.atShadowFileNodeName() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = at.writeOneAtShadowNode(p,toString=toString,force=True)
            if ok:
                found = True
                g.es('wrote %s' % p.atShadowFileNodeName(),color='blue')
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @shadow nodes in the selected tree")
    else:
        g.es("no @shadow nodes in the selected tree")

    return found
#@-node:ekr.20080711093251.4:writeAtShadowNodesHelper
#@+node:ekr.20080711093251.5:writeOneAtShadowNode & helper
def writeOneAtShadowNode(self,p,toString,force):

    '''Write p, an @shadow node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy() ; x = c.shadowController

    fn = p.atShadowFileNodeName()
    if not fn:
        g.trace('can not happen: not an @shadow node',p.headString())
        return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fn = g.os_path_join(at.default_directory,fn)
    exists = g.os_path_exists(fn)

    if not toString and not self.shouldWriteAtShadowNode(p,exists,force):
        return False

    c.endEditing() # Capture the current headline.
    at.initWriteIvars(root,targetFileName=None,
        nosentinels=None, # set below.  Affects only error messages (sometimes).
        thinFile=True, # New in Leo 4.5 b2: private files are thin files.
        scriptWrite=False,
        toString=False, # True: create a fileLikeObject.  This is done below.
        write_strips_blank_lines=False)
            # at.targetFileName not used.

    if g.app.unitTesting: ivars_dict = g.getIvarsDict(at)

    # Write the public and private files to public_s and private_s strings.
    data = []
    for sentinels in (False,True):
        theFile = at.openStringFile(fn)
        at.sentinels = sentinels
        at.writeOpenFile(root,nosentinels=not sentinels,toString=False,atAuto=False)
            # nosentinels only affects error messages, and then only if atAuto is True.
        s = at.closeStringFile(theFile)
        data.append(s)

    # Set these new ivars for unit tests.
    at.public_s, at.private_s = data

    if g.app.unitTesting:
        exceptions = ('public_s','private_s','sentinels','stringOutput')
        assert g.checkUnchangedIvars(at,ivars_dict,exceptions)

    if at.errors == 0 and not toString:
        ### It may be better to compute the public file by removing sentinels from at.private_s
        ### by calling x.copy_file_removing_sentinels. This would ensure that the (dubious!!)
        ### x.isSentinel logic is used consistently by the @shadow read/write logic.
        ### OTOH, Leo's write logic should actually dominate x.isSentinel.

        # Write the public and private files.
        private_fn = x.shadowPathName(fn)
        x.makeShadowDirectory(fn) # makeShadowDirectory takes a *public* file name.
        at.replaceFileWithString(private_fn,at.private_s)
        at.replaceFileWithString(fn,at.public_s)

    if at.errors == 0:
        root.clearOrphan()
        root.clearDirty()
    else:
        g.es("not written:",at.outputFileName)
        root.setDirty() # New in Leo 4.4.8.

    return at.errors == 0
#@+node:ekr.20080711093251.6:shouldWriteAtShadowNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @shadow x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @shadow node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @shadow file.
- The explicit commands that read and write @shadow trees must always be honored.
@c

def shouldWriteAtShadowNode (self,p,exists,force):

    '''Return True if we should write the @shadow node at p.'''

    if force: # We are executing write-at-shadow-node or write-dirty-at-shadow-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.headString(),'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @shadow tree is dirty and contains significant info.
        return True
#@-node:ekr.20080711093251.6:shouldWriteAtShadowNode
#@-node:ekr.20080711093251.5:writeOneAtShadowNode & helper
#@-node:ekr.20080711093251.3:writeAtShadowdNodes & writeDirtyAtShadowNodes (atFile) & helpers
#@-node:ekr.20080713091247.5:Finished @shadow commands
#@+node:ekr.20080802070659.5:Use thin-like shadow nodes
@ One unit tests generates a "bad tnode list" error.
writeOneAtShadowNode wust update the tnode list in the root!
#@nonl
#@+node:ekr.20080803063553.3:Changed to make private files use thin-like sentinels
#@+node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

    fn = g.os_path_abspath(g.os_path_normpath(g.os_path_join(at.default_directory,fn)))
    shadow_fn       = x.shadowPathName(fn)
    shadow_exists   = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
    # significant     = x.isSignificantPublicFile(fn)

    if shadow_exists:
        # x.updatePublicAndPrivateFiles creates the public file if it does not exist.
        at.read(p,
            thinFile=True, # The shadow file contains sentinels: new in Leo 4.5 b2.
            atShadow=True)
            # Calls x.updatePublicAndPrivateFiles
    else:
        if not g.unitTesting: g.es("reading:",p.headString())
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # x.makeShadowFile(fn,p)
            at.writeOneAtShadowNode(p,toString=False,force=True)
#@+node:ekr.20080712080505.1:importAtShadowNode
def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
#@-node:ekr.20080712080505.1:importAtShadowNode
#@-node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
#@+node:ekr.20031218072017.1863:putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    # Not writing @auto nodes is way too dangerous.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    if isIgnore:   forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = False     # Never write non-ignored @auto trees.
    elif isShadow: forceWrite = False   # Never write non-ignored @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Only write orphan @thin trees.
    else:          forceWrite = True      # Write all other @file trees.

    << Set gnx = tnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append tnodeList and unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s><vh>%s</vh>' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        << issue informational messages >>
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('</v>\n')
    else:
        fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
# New in Leo 4.4.8.  Assign v.t.fileIndex here as needed.
if not v.t.fileIndex:
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)

if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
#@-node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
#@+node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren(): attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"

    # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    # if not self.use_sax:
        # if p.equal(self.topPosition):     attr += "T" # was a bottleneck
        # if p.equal(self.currentPosition): attr += "V" # was a bottleneck

    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    if not c.fixed:
        d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@-node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
#@+node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin or isShadow:
        if 1:
            if g.app.unitTesting:
                g.app.unitTestDict["warning"] = True
            g.es("deleting tnode list for",p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))
#@nonl
#@-node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
#@+node:ekr.20040702085529:<< issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.headString(),color="blue")
    p.clearOrphan()
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode
#@+node:ekr.20080711093251.5:writeOneAtShadowNode & helper
def writeOneAtShadowNode(self,p,toString,force):

    '''Write p, an @shadow node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy() ; x = c.shadowController

    fn = p.atShadowFileNodeName()
    if not fn:
        g.trace('can not happen: not an @shadow node',p.headString())
        return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fn = g.os_path_join(at.default_directory,fn)
    exists = g.os_path_exists(fn)

    if not toString and not self.shouldWriteAtShadowNode(p,exists,force):
        return False

    c.endEditing() # Capture the current headline.
    at.initWriteIvars(root,targetFileName=None,
        nosentinels=None, # set below.  Affects only error messages (sometimes).
        thinFile=True, # New in Leo 4.5 b2: private files are thin files.
        scriptWrite=False,
        toString=False, # True: create a fileLikeObject.  This is done below.
        write_strips_blank_lines=False)
            # at.targetFileName not used.

    if g.app.unitTesting: ivars_dict = g.getIvarsDict(at)

    # Write the public and private files to public_s and private_s strings.
    data = []
    for sentinels in (False,True):
        theFile = at.openStringFile(fn)
        at.sentinels = sentinels
        at.writeOpenFile(root,nosentinels=not sentinels,toString=False,atAuto=False)
            # nosentinels only affects error messages, and then only if atAuto is True.
        s = at.closeStringFile(theFile)
        data.append(s)

    # Set these new ivars for unit tests.
    at.public_s, at.private_s = data

    if g.app.unitTesting:
        exceptions = ('public_s','private_s','sentinels','stringOutput')
        assert g.checkUnchangedIvars(at,ivars_dict,exceptions)

    if at.errors == 0 and not toString:
        ### It may be better to compute the public file by removing sentinels from at.private_s
        ### by calling x.copy_file_removing_sentinels. This would ensure that the (dubious!!)
        ### x.isSentinel logic is used consistently by the @shadow read/write logic.
        ### OTOH, Leo's write logic should actually dominate x.isSentinel.

        # Write the public and private files.
        private_fn = x.shadowPathName(fn)
        x.makeShadowDirectory(fn) # makeShadowDirectory takes a *public* file name.
        at.replaceFileWithString(private_fn,at.private_s)
        at.replaceFileWithString(fn,at.public_s)

    if at.errors == 0:
        root.clearOrphan()
        root.clearDirty()
    else:
        g.es("not written:",at.outputFileName)
        root.setDirty() # New in Leo 4.4.8.

    return at.errors == 0
#@+node:ekr.20080711093251.6:shouldWriteAtShadowNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @shadow x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @shadow node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @shadow file.
- The explicit commands that read and write @shadow trees must always be honored.
@c

def shouldWriteAtShadowNode (self,p,exists,force):

    '''Return True if we should write the @shadow node at p.'''

    if force: # We are executing write-at-shadow-node or write-dirty-at-shadow-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.headString(),'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @shadow tree is dirty and contains significant info.
        return True
#@-node:ekr.20080711093251.6:shouldWriteAtShadowNode
#@-node:ekr.20080711093251.5:writeOneAtShadowNode & helper
#@-node:ekr.20080803063553.3:Changed to make private files use thin-like sentinels
#@-node:ekr.20080802070659.5:Use thin-like shadow nodes
#@+node:ekr.20080803063553.6:(Found out why lines are being duplicated)
@nocolor

python launchLeo.py

NewHeadline -> @shadowImport
bodyString ->
---cut here---
#!/bin/sh

DB="$1"
---cut here---

save as del.leo
quit

python launchLeo.py del.leo

"#!/bin/sh"

is duplicated

==========================

The fix:

- Don't write new private file if there is an update error.
- Report extensions surrounded by single quotes: makes empty extension visible.
- (The real bug): use '#@', not '#' as the marker for empty/unknown file extensions.


@color
#@+node:ekr.20080708094444.9:x.marker_from_extension
def marker_from_extension (self,filename):

    '''Return the sentinel delimiter comment to be used for filename.'''

    delims = g.comment_delims_from_extension(filename)
    for i in (0,1):
        if delims[i] is not None:
            return delims[i]+'@'

    # Try some other choices.
    root, ext = os.path.splitext(filename)

    if ext=='.tmp':
        root, ext = os.path.splitext(root)

    if ext in('.h', '.c'):
        marker = "//@"
    elif ext in(".py", ".cfg", ".ksh", ".txt"):
        marker = '#@'
    elif ext in (".bat",):
        marker = "REM@"
    else:
        self.error("extension '%s' not known" % ext)
        marker = '#@' # Bug fix: 2008/8/4

    return marker
#@-node:ekr.20080708094444.9:x.marker_from_extension
#@+node:ekr.20080708094444.80:class shadowController
class shadowController:

    '''A class to manage @shadow files'''

    @others
#@+node:ekr.20080708094444.79: x.ctor
def __init__ (self,c,trace=False,trace_writers=False):

    self.c = c

    # Configuration...
    self.shadow_subdir = c.config.getString('shadow_subdir') or 'LeoFolder'
    self.shadow_prefix = c.config.getString('shadow_prefix') or ''

    # Debugging...
    self.trace = trace
    self.trace_writers = trace_writers  # True: enable traces in all sourcewriters.

    # Error handling...
    self.errors = 0
    self.last_error  = '' # The last error message, regardless of whether it was actually shown.

    # Support for goto-line-number.
    self.line_mapping = []

#@-node:ekr.20080708094444.79: x.ctor
#@+node:ekr.20080711063656.1:x.File utils
#@+node:ekr.20080711063656.7:x.baseDirName
def baseDirName (self):

    x = self ; filename = x.c.fileName()

    if filename:
        return g.os_path_dirname(g.os_path_abspath(filename))
    else:
        self.error('Can not compute shadow path: .leo file has not been saved')
        return None
#@nonl
#@-node:ekr.20080711063656.7:x.baseDirName
#@+node:ekr.20080711063656.4:x.dirName and pathName
def dirName (self,filename):

    '''Return the directory for filename.'''

    x = self

    return g.os_path_dirname(x.pathName(filename))

def pathName (self,filename):

    '''Return the full path name of filename.'''

    x = self ; theDir = x.baseDirName()

    return theDir and g.os_path_abspath(g.os_path_join(theDir,filename))
#@nonl
#@-node:ekr.20080711063656.4:x.dirName and pathName
#@+node:ekr.20080712080505.3:x.isSignificantPublicFile
def isSignificantPublicFile (self,fn):

    '''This tells the atFile.read logic whether to import a public file or use an existing public file.'''

    return g.os_path_exists(fn) and g.os_path_isfile(fn) and g.os_path_getsize(fn) > 10
#@-node:ekr.20080712080505.3:x.isSignificantPublicFile
#@+node:ekr.20080710082231.19:x.makeShadowDirectory
def makeShadowDirectory (self,fn):

    '''Make a shadow directory for the **public** fn.'''

    x = self ; path = x.shadowDirName(fn)

    if not g.os_path_exists(path):

        try:
            # g.trace('making',path)
            os.mkdir(path)
        except Exception:
            x.error('unexpected exception creating %s' % path)
            g.es_exception()
            return False

    return g.os_path_exists(path) and g.os_path_isdir(path)
#@-node:ekr.20080710082231.19:x.makeShadowDirectory
#@+node:ekr.20080711063656.2:x.rename
def rename (self,src,dst,mode=None,silent=False):

    x = self ; c = x.c

    ok = g.utils_rename (c,src,dst,mode=mode,verbose=not silent)
    if not ok:
        x.error('can not rename %s to %s' % (src,dst),silent=silent)

    return ok
#@-node:ekr.20080711063656.2:x.rename
#@+node:ekr.20080713091247.1:x.replaceFileWithString
def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    x = self ; testing = g.app.unitTesting

    exists = g.os_path_exists(fn)

    if exists: # Read the file.  Return if it is the same.
        try:
            f = file(fn,'rb')
            s2 = f.read()
            f.close()
        except IOError:
            x.error('unexpected exception creating %s' % fn)
            g.es_exception()
            return False
        if s == s2:
            if not testing: g.es('unchanged:',fn)
            return False

    # Replace the file.
    try:
        f = file(fn,'wb')
        f.write(s)
        f.close()
        if not testing:
            if exists:  g.es('wrote:    ',fn)
            else:       g.es('created:  ',fn)
        return True
    except IOError:
        x.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
#@-node:ekr.20080713091247.1:x.replaceFileWithString
#@+node:ekr.20080711063656.6:x.shadowDirName and shadowPathName
def shadowDirName (self,filename):

    '''Return the directory for the shadow file corresponding to filename.'''

    x = self

    return g.os_path_dirname(x.shadowPathName(filename))

def shadowPathName (self,filename):

    '''Return the full path name of filename, resolved using c.fileName()'''

    x = self ; baseDir = x.baseDirName()
    fileDir = g.os_path_dirname(filename)
    # g.trace(baseDir)
    # g.trace(x.shadow_subdir)
    # g.trace(fileDir)

    return baseDir and g.os_path_abspath(g.os_path_normpath(g.os_path_join(
            baseDir,
            fileDir, # Bug fix: honor any directories specified in filename.
            x.shadow_subdir,
            x.shadow_prefix + g.shortFileName(filename))))
#@nonl
#@-node:ekr.20080711063656.6:x.shadowDirName and shadowPathName
#@+node:ekr.20080711063656.3:x.unlink
def unlink (self, filename,silent=False):

    '''Unlink filename from the file system.
    Give an error on failure.'''

    x = self

    ok = g.utils_remove(filename, verbose=not silent)
    if not ok:
        x.error('can not delete %s' % (filename),silent=silent)

    return ok
#@-node:ekr.20080711063656.3:x.unlink
#@-node:ekr.20080711063656.1:x.File utils
#@+node:ekr.20080708192807.1:x.Propagation
#@+node:ekr.20080708094444.35:x.check_the_final_output
def check_the_final_output(self, new_private_lines, new_public_lines, sentinel_lines, marker):
    """
    Check that we produced a valid output.

    Input:
        new_targetlines:   the lines with sentinels which produce changed_lines_without_sentinels.
        sentinels:         new_targetlines should include all the lines from sentinels.

    checks:
        1. new_targetlines without sentinels must equal changed_lines_without_sentinels.
        2. the sentinel lines of new_targetlines must match 'sentinels'
    """
    new_public_lines2, new_sentinel_lines2 = self.separate_sentinels (new_private_lines, marker)

    ok = True
    if new_public_lines2 != new_public_lines:
        ok = False
        self.show_error(
            lines1 = new_public_lines2,
            lines2 = new_public_lines,
            message = "Error in updating public file!",
            lines1_message = "new public lines (derived from new private lines)",
            lines2_message = "new public lines")
        # g.trace(g.callers())

    if new_sentinel_lines2 != sentinel_lines:
        ok = False
        self.show_error(
            lines1 = sentinel_lines,
            lines2 = new_sentinel_lines2,
            message = "Sentinals not preserved!",
            lines1_message = "old sentinels",
            lines2_message = "new sentinels")

    # if ok: g.trace("success!")
#@-node:ekr.20080708094444.35:x.check_the_final_output
#@+node:ekr.20080708094444.37:x.copy_sentinels
def copy_sentinels(self,reader,writer,marker,limit):

    '''Copy sentinels from reader to writer while reader.index() < limit.'''

    x = self
    start = reader.index()
    while reader.index() < limit:
        line = reader.get()
        if x.is_sentinel(line, marker):
            if x.is_verbatim(line,marker):
                # # if reader.index() < limit:
                    # # # We are *copying* the @verbatim sentinel.
                    # # line = reader.get()
                    # # writer.put(line,tag='copy sent %s:%s' % (start,limit))
                # We are *deleting* non-sentinel lines, so we must delete @verbatim sentinels!
                # We must **extend** the limit to get the next line.
                if reader.index() < limit + 1:
                    # Skip the next line, whatever it is.
                    # Important: this **deletes** the @verbatim sentinel,
                    # so this is a exception to the rule that sentinels are preserved.
                    line = reader.get()
                else:
                    x.verbatim_error()
            else:
                # g.trace('put line',repr(line))
                writer.put(line,tag='copy sent %s:%s' % (start,limit))
#@-node:ekr.20080708094444.37:x.copy_sentinels
#@+node:ekr.20080708094444.38:x.propagate_changed_lines
def propagate_changed_lines(self,new_public_lines,old_private_lines,marker,p=None):

    '''Propagate changes from 'new_public_lines' to 'old_private_lines.

    We compare the old and new public lines, create diffs and
    propagate the diffs to the new private lines, copying sentinels as well.

    We have two invariants:
    1. We *never* delete any sentinels.
    2. Insertions that happen at the boundary between nodes will be put at
       the end of a node.  However, insertions must always be done within sentinels.
    '''

    x = self ; trace = False ; verbose = True
    # mapping tells which line of old_private_lines each line of old_public_lines comes from.
    old_public_lines, mapping = self.strip_sentinels_with_map(old_private_lines,marker)

    << init vars >>
    << define print_tags >>

    sm = difflib.SequenceMatcher(None,old_public_lines,new_public_lines)
    prev_old_j = 0 ; prev_new_j = 0

    for tag,old_i,old_j,new_i,new_j in sm.get_opcodes():

        << About this loop >>

        # Verify that SequenceMatcher never leaves gaps.
        if old_i != prev_old_j: # assert old_i == prev_old_j
            x.error('can not happen: gap in old:',old_i,prev_old_j)
        if new_i != prev_new_j: # assert new_i == prev_new_j
            x.error('can not happen: gap in new:',new_i,prev_new_j)

        << Handle the opcode >>

        # Remember the ends of the previous tag ranges.
        prev_old_j = old_j
        prev_new_j = new_j

    # Copy all unwritten sentinels.
    self.copy_sentinels(
        old_private_lines_rdr,new_private_lines_wtr,
        marker, limit = old_private_lines_rdr.size())

    # Get the result.
    result = new_private_lines_wtr.getlines()
    if 1:
        << do final correctness check>>
    return result
#@+node:ekr.20080708094444.40:<< init vars >>
new_private_lines_wtr = sourcewriter(self)
# collects the contents of the new file.

new_public_lines_rdr = sourcereader(self,new_public_lines)
    # Contains the changed source code.

old_public_lines_rdr = sourcereader(self,old_public_lines)
    # this is compared to new_public_lines_rdr to find out the changes.

old_private_lines_rdr = sourcereader(self,old_private_lines) # lines_with_sentinels)
    # This is the file which is currently produced by Leo, with sentinels.

# Check that all ranges returned by get_opcodes() are contiguous
old_old_j, old_i2_modified_lines = -1,-1

tag = old_i = old_j = new_i = new_j = None
#@nonl
#@-node:ekr.20080708094444.40:<< init vars >>
#@+node:ekr.20080708094444.39:<< define print_tags >>
def print_tags(tag, old_i, old_j, new_i, new_j, message):

    sep1 = '=' * 10 ; sep2 = '-' * 20

    g.pr('\n',sep1,message,sep1,p and p.headString())

    g.pr('\n%s: old[%s:%s] new[%s:%s]' % (tag,old_i,old_j,new_i,new_j))

    g.pr('\n',sep2)

    table = (
        (old_private_lines_rdr,'old private lines'),
        (old_public_lines_rdr,'old public lines'),
        (new_public_lines_rdr,'new public lines'),
        (new_private_lines_wtr,'new private lines'),
    )

    for f,tag in table:
        f.dump(tag)
        g.pr(sep2)


#@-node:ekr.20080708094444.39:<< define print_tags >>
#@+node:ekr.20080708192807.2:<< about this loop >>
@

This loop writes all output lines using a single writer: new_private_lines_wtr.

The output lines come from two, and *only* two readers:

1. old_private_lines_rdr delivers the complete original sources. All
   sentinels and unchanged regular lines come from this reader.

2. new_public_lines_rdr delivers the new, changed sources. All inserted or
   replacement text comes from this reader.

Each time through the loop, the following are true:

- old_i is the index into old_public_lines of the start of the present SequenceMatcher opcode.

- mapping[old_i] is the index into old_private_lines of the start of the same opcode.

At the start of the loop, the call to copy_sentinels effectively skips (deletes)
all previously unwritten non-sentinel lines in old_private_lines_rdr whose index
less than mapping[old_i].

As a result, the opcode handlers do not need to delete elements from the
old_private_lines_rdr explicitly. This explains why opcode handlers for the
'insert' and 'delete' opcodes are identical.
#@-node:ekr.20080708192807.2:<< about this loop >>
#@+node:ekr.20080708192807.5:<< Handle the opcode >>
# Do not copy sentinels if a) we are inserting and b) limit is at the end of the old_private_lines.
# In this special case, we must do the insert before the sentinels.
limit=mapping[old_i]

if trace: g.trace(tag,'old_i',old_i,'limit',limit)

if tag == 'insert' and limit >= old_private_lines_rdr.size():
    pass
else:
    # Ignore (delete) all unwritten lines of old_private_lines_rdr up to limit.
    # Because of this, nothing has to be explicitly deleted below.
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)

if tag == 'equal':
    # Copy all lines (including sentinels) from the old private file to the new private file.
    start = old_private_lines_rdr.index()
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        line = old_private_lines_rdr.get()
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,mapping[old_j-1]))

    # Ignore all new lines up to new_j: the same lines (with sentinels) have just been written.
    new_public_lines_rdr.sync(new_j)

elif tag in ('insert','replace'):
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Copy lines from new_public_lines_rdr up to new_j.
    start = new_public_lines_rdr.index()
    while new_public_lines_rdr.index() < new_j:
        line = new_public_lines_rdr.get()
        if x.is_sentinel(line,marker):
            new_private_lines_wtr.put('%sverbatim\n' % (marker),tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag=='delete':
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Leave new_public_lines_rdr unchanged.
    pass

else: g.trace('can not happen: unknown difflib.SequenceMather tag: %s' % repr(tag))

if trace and verbose:
    print_tags(tag, old_i, old_j, new_i, new_j, "After tag")
#@nonl
#@-node:ekr.20080708192807.5:<< Handle the opcode >>
#@+node:ekr.20080708094444.45:<< do final correctness check >>
t_sourcelines, t_sentinel_lines = self.separate_sentinels(
    new_private_lines_wtr.lines, marker)

self.check_the_final_output(
    new_private_lines   = result,
    new_public_lines    = new_public_lines,
    sentinel_lines      = t_sentinel_lines,
    marker              = marker)
#@-node:ekr.20080708094444.45:<< do final correctness check >>
#@-node:ekr.20080708094444.38:x.propagate_changed_lines
#@+node:ekr.20080708094444.36:x.propagate_changes
def propagate_changes(self, old_public_file, old_private_file):

    '''Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)'''

    x = self

    g.trace('old_public_file',old_public_file)

    old_public_lines  = file(old_public_file).readlines()
    old_private_lines = file(old_private_file).readlines()
    marker = x.marker_from_extension(old_public_file)

    new_private_lines = x.propagate_changed_lines(
        old_public_lines,
        old_private_lines,
        marker)

    fn = old_private_file
    copy = not os.path.exists(fn) or new_private_lines != old_private_lines

    if copy and x.errors == 0:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(fn,s)

    return copy
#@-node:ekr.20080708094444.36:x.propagate_changes
#@+node:ekr.20080708094444.34:x.strip_sentinels_with_map
def strip_sentinels_with_map (self, lines, marker):

    '''Strip sentinels from lines, a list of lines with sentinels.

    Return (results,mapping)

    'lines':     A list of lines containing sentinels.
    'results':   The list of non-sentinel lines.
    'mapping':   A list mapping each line in results to the original list.
                results[i] comes from line mapping[i] of the original lines.'''

    x = self
    mapping = [] ; results = [] ; i = 0 ; n = len(lines)
    while i < n:
        line = lines[i]
        if x.is_sentinel(line,marker):
            if x.is_verbatim(line,marker):
                i += 1
                if i < n:
                    # Not a sentinel, whatever it looks like.
                    line = lines[i]
                    # g.trace('not a sentinel',repr(line))
                    results.append(line)
                    mapping.append(i)
                else:
                    x.verbatim_error()
        else:
            results.append(line)
            mapping.append(i)
        i += 1

    mapping.append(len(lines)) # To terminate loops.
    return results, mapping 
#@-node:ekr.20080708094444.34:x.strip_sentinels_with_map
#@+node:bwmulder.20041231170726:x.updatePublicAndPrivateFiles
def updatePublicAndPrivateFiles (self,fn,shadow_fn):

    '''handle crucial @shadow read logic.

    This will be called only if the public and private files both exist.'''

    x = self ; trace = False

    if trace and not g.app.unitTesting:
        g.trace('significant',x.isSignificantPublicFile(fn),fn)

    if x.isSignificantPublicFile(fn):
        # Update the private shadow file from the public file.
        written = x.propagate_changes(fn,shadow_fn)
        if written: x.message("updated private %s from public %s" % (shadow_fn, fn))
    else:
        # Create the public file from the private shadow file.
        x.copy_file_removing_sentinels(shadow_fn,fn)
        x.message("created public %s from private %s " % (fn, shadow_fn))
#@+node:ekr.20080708094444.27:x.copy_file_removing_sentinels
def copy_file_removing_sentinels (self,source_fn,target_fn):

    '''Copies sourcefilename to targetfilename, removing sentinel lines.'''

    x = self ; marker = x.marker_from_extension(source_fn)

    old_lines = file(source_fn).readlines()
    new_lines, junk = x.separate_sentinels(old_lines,marker)

    copy = not os.path.exists(target_fn) or old_lines != new_lines
    if copy:
        s = ''.join(new_lines)
        x.replaceFileWithString(target_fn,s)
#@-node:ekr.20080708094444.27:x.copy_file_removing_sentinels
#@-node:bwmulder.20041231170726:x.updatePublicAndPrivateFiles
#@-node:ekr.20080708192807.1:x.Propagation
#@+node:ekr.20080708094444.89:x.Utils...
#@+node:ekr.20080708094444.85:x.error & message & verbatim_error
def error (self,s,silent=False):

    x = self

    if not silent:
        g.es_print(s,color='red')

    # For unit testing.
    x.last_error = s
    x.errors += 1

def message (self,s):

    g.es_print(s,color='orange')

def verbatim_error(self):

    x = self

    x.error('file syntax error: nothing follows verbatim sentinel')
    g.trace(g.callers())
#@-node:ekr.20080708094444.85:x.error & message & verbatim_error
#@+node:ekr.20080708094444.11:x.is_sentinel & is_verbatim
def is_sentinel (self, line, marker):

    '''Return true if the line is a sentinel.'''

    return line.lstrip().startswith(marker)

def is_verbatim (self,line,marker):

    return line.lstrip().startswith(marker+'verbatim')
#@-node:ekr.20080708094444.11:x.is_sentinel & is_verbatim
#@+node:ekr.20080708094444.9:x.marker_from_extension
def marker_from_extension (self,filename):

    '''Return the sentinel delimiter comment to be used for filename.'''

    delims = g.comment_delims_from_extension(filename)
    for i in (0,1):
        if delims[i] is not None:
            return delims[i]+'@'

    # Try some other choices.
    root, ext = os.path.splitext(filename)

    if ext=='.tmp':
        root, ext = os.path.splitext(root)

    if ext in('.h', '.c'):
        marker = "//@"
    elif ext in(".py", ".cfg", ".ksh", ".txt"):
        marker = '#@'
    elif ext in (".bat",):
        marker = "REM@"
    else:
        self.error("extension '%s' not known" % ext)
        marker = '#@' # Bug fix: 2008/8/4

    return marker
#@-node:ekr.20080708094444.9:x.marker_from_extension
#@+node:ekr.20080708094444.30:x.push_filter_mapping
def push_filter_mapping (self,lines, marker):
    """
    Given the lines of a file, filter out all
    Leo sentinels, and return a mapping:

      stripped file -> original file

    Filtering should be the same as
    separate_sentinels
    """

    x = self ; mapping =[None]

    i = 0 ; n = len(lines)
    while i < n:
        line = lines[i]
        if x.is_sentinel(line,marker):
            if x.is_verbatim(line,marker):
                i += 1
                if i < n:
                    mapping(append(i+1))
                else:
                    x.verbatim_error()
        else:
            mapping.append(i+1)
        i += 1

    # for i, line in enumerate(filelines):
        # if not self.is_sentinel(line,marker):
            # mapping.append(i+1)

    return mapping 
#@-node:ekr.20080708094444.30:x.push_filter_mapping
#@+node:ekr.20080708094444.29:x.separate_sentinels
def separate_sentinels (self, lines, marker):

    '''
    Separates regular lines from sentinel lines.

    Returns (regular_lines, sentinel_lines)
    '''

    x = self ; regular_lines = [] ; sentinel_lines = []

    i = 0 ; n = len(lines)
    while i < len(lines):
        line = lines[i]
        if x.is_sentinel(line,marker):
            sentinel_lines.append(line)
            if x.is_verbatim(line,marker):
                i += 1
                if i < len(lines):
                    line = lines[i]
                    regular_lines.append(line)
                else:
                    x.verbatim_error()
        else:
            regular_lines.append(line)
        i += 1

    return regular_lines, sentinel_lines 
#@-node:ekr.20080708094444.29:x.separate_sentinels
#@+node:ekr.20080708094444.33:x.show_error
def show_error (self, lines1, lines2, message, lines1_message, lines2_message):

    def p(s):
        sys.stdout.write(s)
        f1.write(s)
    g.pr("=================================")
    g.pr(message)
    g.pr("=================================")
    g.pr(lines1_message )
    g.pr("---------------------------------")
    f1 = file("mod_shadow.tmp1", "w")
    for line in lines1:
        p(line)
    f1.close()
    g.pr("\n==================================")
    g.pr(lines2_message )
    g.pr("---------------------------------")
    f1 = file("mod_shadow.tmp2", "w")
    for line in lines2:
        p(line)
    f1.close()
    g.pr('')
    g.es("@shadow did not pick up the external changes correctly; please check shadow.tmp1 and shadow.tmp2 for differences")
    # assert 0, "Malfunction of @shadow"
#@-node:ekr.20080708094444.33:x.show_error
#@-node:ekr.20080708094444.89:x.Utils...
#@+node:ekr.20080709062932.2:atShadowTestCase
class atShadowTestCase (unittest.TestCase):

    '''Support @shadow-test nodes.

    These nodes should have two descendant nodes: 'before' and 'after'.

    '''

    @others

#@+node:ekr.20080709062932.6:__init__
def __init__ (self,c,p,shadowController,lax,trace=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.lax = lax
    self.p = p.copy()
    self.shadowController=shadowController

    # Hard value for now.
    self.marker = '#@'

    # For teardown...
    self.ok = True

    # Debugging
    self.trace = trace
#@-node:ekr.20080709062932.6:__init__
#@+node:ekr.20080709062932.7: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20080709062932.7: fail
#@+node:ekr.20080709062932.8:setUp & helpers
def setUp (self):

    c = self.c ; p = self.p ; x = self.shadowController

    old = self.findNode (c,p,'old')
    new = self.findNode (c,p,'new')

    self.old_private_lines = self.makePrivateLines(old)
    self.new_private_lines = self.makePrivateLines(new)

    self.old_public_lines = self.makePublicLines(self.old_private_lines)
    self.new_public_lines = self.makePublicLines(self.new_private_lines)

    # We must change node:new to node:old
    self.expected_private_lines = self.mungePrivateLines(self.new_private_lines,'node:new','node:old')

#@+node:ekr.20080709062932.19:findNode
def findNode(self,c,p,headline):
    p = g.findNodeInTree(c,p,headline)
    if not p:
        g.es_print('can not find',headline)
        assert False
    return p
#@nonl
#@-node:ekr.20080709062932.19:findNode
#@+node:ekr.20080709062932.20:createSentinelNode
def createSentinelNode (self,root,p):

    '''Write p's tree to a string, as if to a file.'''

    h = p.headString()
    p2 = root.insertAsLastChild()
    p2.setHeadString(h + '-sentinels')
    return p2

#@-node:ekr.20080709062932.20:createSentinelNode
#@+node:ekr.20080709062932.21:makePrivateLines
def makePrivateLines (self,p):

    c = self.c ; at = c.atFileCommands

    at.write (p,
        nosentinels = False,
        thinFile = False,  # Debatable.
        scriptWrite = True,
        toString = True,
        write_strips_blank_lines = None,)

    s = at.stringOutput

    # g.trace(p.headString(),'\n',s)

    return g.splitLines(s)
#@-node:ekr.20080709062932.21:makePrivateLines
#@+node:ekr.20080709062932.22:makePublicLines
def makePublicLines (self,lines):

    x = self.shadowController

    lines,mapping = x.strip_sentinels_with_map(lines,self.marker)

    # g.trace(lines)

    return lines
#@-node:ekr.20080709062932.22:makePublicLines
#@+node:ekr.20080709062932.23:mungePrivateLines
def mungePrivateLines (self,lines,find,replace):

    x = self.shadowController ; marker = self.marker

    i = 0 ; n = len(lines) ; results = []
    while i < n:
    # for line in lines:
        line = lines[i]
        if x.is_sentinel(line,self.marker):
            new_line = line.replace(find,replace)
            results.append(new_line)
            if x.is_verbatim(line,marker):
                i += 1
                if i < len(lines):
                    line = lines[i]
                    results.append(line)
                else:
                    x.verbatim_error()

            # if line != new_line: g.trace(new_line)
        else:
            results.append(line)
        i += 1

    return results
#@-node:ekr.20080709062932.23:mungePrivateLines
#@-node:ekr.20080709062932.8:setUp & helpers
#@+node:ekr.20080709062932.9:tearDown
def tearDown (self):

    pass

    # No change is made to the outline.
    # self.c.redraw()
#@-node:ekr.20080709062932.9:tearDown
#@+node:ekr.20080709062932.10:runTest (atShadowTestCase)
def runTest (self,define_g = True):

    x = self.shadowController

    results = x.propagate_changed_lines(
        self.new_public_lines,
        self.old_private_lines,
        marker="#@",
        p = self.p.copy())

    if not self.lax and results != self.expected_private_lines:

        g.pr('%s atShadowTestCase.runTest:failure' % ('*' * 40))
        for aList,tag in ((results,'results'),(self.expected_private_lines,'expected_private_lines')):
            g.pr('%s...' % tag)
            for i, line in enumerate(aList):
                g.pr('%3s %s' % (i,repr(line)))
            g.pr('-' * 40)

        assert results == self.expected_private_lines

    assert self.ok
    return self.ok
#@nonl
#@-node:ekr.20080709062932.10:runTest (atShadowTestCase)
#@+node:ekr.20080709062932.11:shortDescription
def shortDescription (self):

    return self.p and self.p.headString() or '@test-shadow: no self.p'
#@-node:ekr.20080709062932.11:shortDescription
#@-node:ekr.20080709062932.2:atShadowTestCase
#@-node:ekr.20080708094444.80:class shadowController
#@-node:ekr.20080803063553.6:(Found out why lines are being duplicated)
#@+node:ekr.20080804063523.2:Investigated java import problems
@nocolor

http://mail.google.com/mail/#label/Leo/11b7287f4a4fe771
http://groups.google.com/group/leo-editor/browse_thread/thread/bbadb4bee49f397b

> I would appreciate your help in reporting java import problems: please send
> a description of the apparent import problem, and a url where I can get the
> original source.  Thanks.

First 'real' modification:

reading: @shadow C:\OSGi\atshadow-test2\OSGI-OPT\src\org\osgi\framework
\FrameworkUtil.java
warning: intermixed blanks and tabs
warning: mismatch in leading whitespace
first mismatched line at line 50
original line:          private static class ImplHolder implements
PrivilegedAction {
generated line:     private static class ImplHolder implements
PrivilegedAction {
created:   C:\OSGi\atshadow-test2\OSGI-OPT\src\org\osgi\framework
\.leo_shadow\xFrameworkUtil.java
wrote:     C:\OSGi\atshadow-test2\OSGI-OPT\src\org\osgi\framework
\FrameworkUtil.java

Second 'real' modification:

reading: @shadow C:\OSGi\atshadow-test2\OSGI-OPT\src\org\osgi\framework\AdminPermission.java
warning: intermixed blanks and tabs
warning: mismatch in leading whitespace
first mismatched line at line 148
original line:          private static class ImplHolder implements
PrivilegedAction {
generated line:     private static class ImplHolder implements
PrivilegedAction {
created:   C:\OSGi\atshadow-test2\OSGI-OPT\src\org\osgi\framework\.leo_shadow\xAdminPermission.java
wrote:     C:\OSGi\atshadow-test2\OSGI-OPT\src\org\osgi\framework\AdminPermission.java

The other reported modifications are related only to "comment
sections"
within the java sources.

Download location for OSGi Framework JAR:

http://www.osgi.org/Download/Release4V41

@color
#@nonl
#@-node:ekr.20080804063523.2:Investigated java import problems
#@+node:ekr.20080802070659.6:(Added code to handle @verbatim sentinels correctly)
#@+node:ekr.20080708094444.38:x.propagate_changed_lines
def propagate_changed_lines(self,new_public_lines,old_private_lines,marker,p=None):

    '''Propagate changes from 'new_public_lines' to 'old_private_lines.

    We compare the old and new public lines, create diffs and
    propagate the diffs to the new private lines, copying sentinels as well.

    We have two invariants:
    1. We *never* delete any sentinels.
    2. Insertions that happen at the boundary between nodes will be put at
       the end of a node.  However, insertions must always be done within sentinels.
    '''

    x = self ; trace = False ; verbose = True
    # mapping tells which line of old_private_lines each line of old_public_lines comes from.
    old_public_lines, mapping = self.strip_sentinels_with_map(old_private_lines,marker)

    << init vars >>
    << define print_tags >>

    sm = difflib.SequenceMatcher(None,old_public_lines,new_public_lines)
    prev_old_j = 0 ; prev_new_j = 0

    for tag,old_i,old_j,new_i,new_j in sm.get_opcodes():

        << About this loop >>

        # Verify that SequenceMatcher never leaves gaps.
        if old_i != prev_old_j: # assert old_i == prev_old_j
            x.error('can not happen: gap in old:',old_i,prev_old_j)
        if new_i != prev_new_j: # assert new_i == prev_new_j
            x.error('can not happen: gap in new:',new_i,prev_new_j)

        << Handle the opcode >>

        # Remember the ends of the previous tag ranges.
        prev_old_j = old_j
        prev_new_j = new_j

    # Copy all unwritten sentinels.
    self.copy_sentinels(
        old_private_lines_rdr,new_private_lines_wtr,
        marker, limit = old_private_lines_rdr.size())

    # Get the result.
    result = new_private_lines_wtr.getlines()
    if 1:
        << do final correctness check>>
    return result
#@+node:ekr.20080708094444.40:<< init vars >>
new_private_lines_wtr = sourcewriter(self)
# collects the contents of the new file.

new_public_lines_rdr = sourcereader(self,new_public_lines)
    # Contains the changed source code.

old_public_lines_rdr = sourcereader(self,old_public_lines)
    # this is compared to new_public_lines_rdr to find out the changes.

old_private_lines_rdr = sourcereader(self,old_private_lines) # lines_with_sentinels)
    # This is the file which is currently produced by Leo, with sentinels.

# Check that all ranges returned by get_opcodes() are contiguous
old_old_j, old_i2_modified_lines = -1,-1

tag = old_i = old_j = new_i = new_j = None
#@nonl
#@-node:ekr.20080708094444.40:<< init vars >>
#@+node:ekr.20080708094444.39:<< define print_tags >>
def print_tags(tag, old_i, old_j, new_i, new_j, message):

    sep1 = '=' * 10 ; sep2 = '-' * 20

    g.pr('\n',sep1,message,sep1,p and p.headString())

    g.pr('\n%s: old[%s:%s] new[%s:%s]' % (tag,old_i,old_j,new_i,new_j))

    g.pr('\n',sep2)

    table = (
        (old_private_lines_rdr,'old private lines'),
        (old_public_lines_rdr,'old public lines'),
        (new_public_lines_rdr,'new public lines'),
        (new_private_lines_wtr,'new private lines'),
    )

    for f,tag in table:
        f.dump(tag)
        g.pr(sep2)


#@-node:ekr.20080708094444.39:<< define print_tags >>
#@+node:ekr.20080708192807.2:<< about this loop >>
@

This loop writes all output lines using a single writer: new_private_lines_wtr.

The output lines come from two, and *only* two readers:

1. old_private_lines_rdr delivers the complete original sources. All
   sentinels and unchanged regular lines come from this reader.

2. new_public_lines_rdr delivers the new, changed sources. All inserted or
   replacement text comes from this reader.

Each time through the loop, the following are true:

- old_i is the index into old_public_lines of the start of the present SequenceMatcher opcode.

- mapping[old_i] is the index into old_private_lines of the start of the same opcode.

At the start of the loop, the call to copy_sentinels effectively skips (deletes)
all previously unwritten non-sentinel lines in old_private_lines_rdr whose index
less than mapping[old_i].

As a result, the opcode handlers do not need to delete elements from the
old_private_lines_rdr explicitly. This explains why opcode handlers for the
'insert' and 'delete' opcodes are identical.
#@-node:ekr.20080708192807.2:<< about this loop >>
#@+node:ekr.20080708192807.5:<< Handle the opcode >>
# Do not copy sentinels if a) we are inserting and b) limit is at the end of the old_private_lines.
# In this special case, we must do the insert before the sentinels.
limit=mapping[old_i]

if trace: g.trace(tag,'old_i',old_i,'limit',limit)

if tag == 'insert' and limit >= old_private_lines_rdr.size():
    pass
else:
    # Ignore (delete) all unwritten lines of old_private_lines_rdr up to limit.
    # Because of this, nothing has to be explicitly deleted below.
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)

if tag == 'equal':
    # Copy all lines (including sentinels) from the old private file to the new private file.
    start = old_private_lines_rdr.index()
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        line = old_private_lines_rdr.get()
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,mapping[old_j-1]))

    # Ignore all new lines up to new_j: the same lines (with sentinels) have just been written.
    new_public_lines_rdr.sync(new_j)

elif tag in ('insert','replace'):
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Copy lines from new_public_lines_rdr up to new_j.
    start = new_public_lines_rdr.index()
    while new_public_lines_rdr.index() < new_j:
        line = new_public_lines_rdr.get()
        if x.is_sentinel(line,marker):
            new_private_lines_wtr.put('%sverbatim\n' % (marker),tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag=='delete':
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Leave new_public_lines_rdr unchanged.
    pass

else: g.trace('can not happen: unknown difflib.SequenceMather tag: %s' % repr(tag))

if trace and verbose:
    print_tags(tag, old_i, old_j, new_i, new_j, "After tag")
#@nonl
#@-node:ekr.20080708192807.5:<< Handle the opcode >>
#@+node:ekr.20080708094444.45:<< do final correctness check >>
t_sourcelines, t_sentinel_lines = self.separate_sentinels(
    new_private_lines_wtr.lines, marker)

self.check_the_final_output(
    new_private_lines   = result,
    new_public_lines    = new_public_lines,
    sentinel_lines      = t_sentinel_lines,
    marker              = marker)
#@-node:ekr.20080708094444.45:<< do final correctness check >>
#@-node:ekr.20080708094444.38:x.propagate_changed_lines
#@+node:ekr.20080709062932.2:atShadowTestCase
class atShadowTestCase (unittest.TestCase):

    '''Support @shadow-test nodes.

    These nodes should have two descendant nodes: 'before' and 'after'.

    '''

    @others

#@+node:ekr.20080709062932.6:__init__
def __init__ (self,c,p,shadowController,lax,trace=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.lax = lax
    self.p = p.copy()
    self.shadowController=shadowController

    # Hard value for now.
    self.marker = '#@'

    # For teardown...
    self.ok = True

    # Debugging
    self.trace = trace
#@-node:ekr.20080709062932.6:__init__
#@+node:ekr.20080709062932.7: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20080709062932.7: fail
#@+node:ekr.20080709062932.8:setUp & helpers
def setUp (self):

    c = self.c ; p = self.p ; x = self.shadowController

    old = self.findNode (c,p,'old')
    new = self.findNode (c,p,'new')

    self.old_private_lines = self.makePrivateLines(old)
    self.new_private_lines = self.makePrivateLines(new)

    self.old_public_lines = self.makePublicLines(self.old_private_lines)
    self.new_public_lines = self.makePublicLines(self.new_private_lines)

    # We must change node:new to node:old
    self.expected_private_lines = self.mungePrivateLines(self.new_private_lines,'node:new','node:old')

#@+node:ekr.20080709062932.19:findNode
def findNode(self,c,p,headline):
    p = g.findNodeInTree(c,p,headline)
    if not p:
        g.es_print('can not find',headline)
        assert False
    return p
#@nonl
#@-node:ekr.20080709062932.19:findNode
#@+node:ekr.20080709062932.20:createSentinelNode
def createSentinelNode (self,root,p):

    '''Write p's tree to a string, as if to a file.'''

    h = p.headString()
    p2 = root.insertAsLastChild()
    p2.setHeadString(h + '-sentinels')
    return p2

#@-node:ekr.20080709062932.20:createSentinelNode
#@+node:ekr.20080709062932.21:makePrivateLines
def makePrivateLines (self,p):

    c = self.c ; at = c.atFileCommands

    at.write (p,
        nosentinels = False,
        thinFile = False,  # Debatable.
        scriptWrite = True,
        toString = True,
        write_strips_blank_lines = None,)

    s = at.stringOutput

    # g.trace(p.headString(),'\n',s)

    return g.splitLines(s)
#@-node:ekr.20080709062932.21:makePrivateLines
#@+node:ekr.20080709062932.22:makePublicLines
def makePublicLines (self,lines):

    x = self.shadowController

    lines,mapping = x.strip_sentinels_with_map(lines,self.marker)

    # g.trace(lines)

    return lines
#@-node:ekr.20080709062932.22:makePublicLines
#@+node:ekr.20080709062932.23:mungePrivateLines
def mungePrivateLines (self,lines,find,replace):

    x = self.shadowController ; marker = self.marker

    i = 0 ; n = len(lines) ; results = []
    while i < n:
    # for line in lines:
        line = lines[i]
        if x.is_sentinel(line,self.marker):
            new_line = line.replace(find,replace)
            results.append(new_line)
            if x.is_verbatim(line,marker):
                i += 1
                if i < len(lines):
                    line = lines[i]
                    results.append(line)
                else:
                    x.verbatim_error()

            # if line != new_line: g.trace(new_line)
        else:
            results.append(line)
        i += 1

    return results
#@-node:ekr.20080709062932.23:mungePrivateLines
#@-node:ekr.20080709062932.8:setUp & helpers
#@+node:ekr.20080709062932.9:tearDown
def tearDown (self):

    pass

    # No change is made to the outline.
    # self.c.redraw()
#@-node:ekr.20080709062932.9:tearDown
#@+node:ekr.20080709062932.10:runTest (atShadowTestCase)
def runTest (self,define_g = True):

    x = self.shadowController

    results = x.propagate_changed_lines(
        self.new_public_lines,
        self.old_private_lines,
        marker="#@",
        p = self.p.copy())

    if not self.lax and results != self.expected_private_lines:

        g.pr('%s atShadowTestCase.runTest:failure' % ('*' * 40))
        for aList,tag in ((results,'results'),(self.expected_private_lines,'expected_private_lines')):
            g.pr('%s...' % tag)
            for i, line in enumerate(aList):
                g.pr('%3s %s' % (i,repr(line)))
            g.pr('-' * 40)

        assert results == self.expected_private_lines

    assert self.ok
    return self.ok
#@nonl
#@-node:ekr.20080709062932.10:runTest (atShadowTestCase)
#@+node:ekr.20080709062932.11:shortDescription
def shortDescription (self):

    return self.p and self.p.headString() or '@test-shadow: no self.p'
#@-node:ekr.20080709062932.11:shortDescription
#@-node:ekr.20080709062932.2:atShadowTestCase
#@+node:ekr.20080802070659.7:Found: is_sentinel
#@+node:ekr.20080708094444.37:x.copy_sentinels
def copy_sentinels(self,reader,writer,marker,limit):

    '''Copy sentinels from reader to writer while reader.index() < limit.'''

    x = self
    start = reader.index()
    while reader.index() < limit:
        line = reader.get()
        if x.is_sentinel(line, marker):
            if x.is_verbatim(line,marker):
                # # if reader.index() < limit:
                    # # # We are *copying* the @verbatim sentinel.
                    # # line = reader.get()
                    # # writer.put(line,tag='copy sent %s:%s' % (start,limit))
                # We are *deleting* non-sentinel lines, so we must delete @verbatim sentinels!
                # We must **extend** the limit to get the next line.
                if reader.index() < limit + 1:
                    # Skip the next line, whatever it is.
                    # Important: this **deletes** the @verbatim sentinel,
                    # so this is a exception to the rule that sentinels are preserved.
                    line = reader.get()
                else:
                    x.verbatim_error()
            else:
                # g.trace('put line',repr(line))
                writer.put(line,tag='copy sent %s:%s' % (start,limit))
#@-node:ekr.20080708094444.37:x.copy_sentinels
#@+node:ekr.20080708094444.34:x.strip_sentinels_with_map
def strip_sentinels_with_map (self, lines, marker):

    '''Strip sentinels from lines, a list of lines with sentinels.

    Return (results,mapping)

    'lines':     A list of lines containing sentinels.
    'results':   The list of non-sentinel lines.
    'mapping':   A list mapping each line in results to the original list.
                results[i] comes from line mapping[i] of the original lines.'''

    x = self
    mapping = [] ; results = [] ; i = 0 ; n = len(lines)
    while i < n:
        line = lines[i]
        if x.is_sentinel(line,marker):
            if x.is_verbatim(line,marker):
                i += 1
                if i < n:
                    # Not a sentinel, whatever it looks like.
                    line = lines[i]
                    # g.trace('not a sentinel',repr(line))
                    results.append(line)
                    mapping.append(i)
                else:
                    x.verbatim_error()
        else:
            results.append(line)
            mapping.append(i)
        i += 1

    mapping.append(len(lines)) # To terminate loops.
    return results, mapping 
#@-node:ekr.20080708094444.34:x.strip_sentinels_with_map
#@+node:ekr.20080708094444.11:x.is_sentinel & is_verbatim
def is_sentinel (self, line, marker):

    '''Return true if the line is a sentinel.'''

    return line.lstrip().startswith(marker)

def is_verbatim (self,line,marker):

    return line.lstrip().startswith(marker+'verbatim')
#@-node:ekr.20080708094444.11:x.is_sentinel & is_verbatim
#@+node:ekr.20080708094444.30:x.push_filter_mapping
def push_filter_mapping (self,lines, marker):
    """
    Given the lines of a file, filter out all
    Leo sentinels, and return a mapping:

      stripped file -> original file

    Filtering should be the same as
    separate_sentinels
    """

    x = self ; mapping =[None]

    i = 0 ; n = len(lines)
    while i < n:
        line = lines[i]
        if x.is_sentinel(line,marker):
            if x.is_verbatim(line,marker):
                i += 1
                if i < n:
                    mapping(append(i+1))
                else:
                    x.verbatim_error()
        else:
            mapping.append(i+1)
        i += 1

    # for i, line in enumerate(filelines):
        # if not self.is_sentinel(line,marker):
            # mapping.append(i+1)

    return mapping 
#@-node:ekr.20080708094444.30:x.push_filter_mapping
#@+node:ekr.20080708094444.29:x.separate_sentinels
def separate_sentinels (self, lines, marker):

    '''
    Separates regular lines from sentinel lines.

    Returns (regular_lines, sentinel_lines)
    '''

    x = self ; regular_lines = [] ; sentinel_lines = []

    i = 0 ; n = len(lines)
    while i < len(lines):
        line = lines[i]
        if x.is_sentinel(line,marker):
            sentinel_lines.append(line)
            if x.is_verbatim(line,marker):
                i += 1
                if i < len(lines):
                    line = lines[i]
                    regular_lines.append(line)
                else:
                    x.verbatim_error()
        else:
            regular_lines.append(line)
        i += 1

    return regular_lines, sentinel_lines 
#@-node:ekr.20080708094444.29:x.separate_sentinels
#@+node:ekr.20080709062932.23:mungePrivateLines
def mungePrivateLines (self,lines,find,replace):

    x = self.shadowController ; marker = self.marker

    i = 0 ; n = len(lines) ; results = []
    while i < n:
    # for line in lines:
        line = lines[i]
        if x.is_sentinel(line,self.marker):
            new_line = line.replace(find,replace)
            results.append(new_line)
            if x.is_verbatim(line,marker):
                i += 1
                if i < len(lines):
                    line = lines[i]
                    results.append(line)
                else:
                    x.verbatim_error()

            # if line != new_line: g.trace(new_line)
        else:
            results.append(line)
        i += 1

    return results
#@-node:ekr.20080709062932.23:mungePrivateLines
#@-node:ekr.20080802070659.7:Found: is_sentinel
#@-node:ekr.20080802070659.6:(Added code to handle @verbatim sentinels correctly)
#@-node:ekr.20080730212711.5:Added support for @shadow
#@-node:ekr.20080702123133.2:4.5 b2
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
