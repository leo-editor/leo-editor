#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20080917153158.11:4.6
#@+node:ekr.20080918201437.1:Leo3k work
#@+node:ekr.20080918164844.16:use sorted(dict) everywhere
This removed about half of the instances of g.isPython3.
#@nonl
#@-node:ekr.20080918164844.16:use sorted(dict) everywhere
#@+node:ekr.20080918164844.17:Fixed pylint warnings
************* Module leo.core.leoAtFile
#fixed E0602:873:atFile.scanText4: Undefined variable 'message'
#fixed E0602:874:atFile.scanText4: Undefined variable 'message'
# fixed E0602:874:atFile.scanText4: Undefined variable 'sys'

************* Module leo.core.leoCommands
#fixed E0602:3930:baseCommands.tabNannyNode: Undefined variable 'msg'
#fixed E0602:3933:baseCommands.tabNannyNode: Undefined variable 'msg'
#fixed E0602:3935:baseCommands.tabNannyNode: Undefined variable 'msg'
#fixed E0602:3938:baseCommands.tabNannyNode: Undefined variable 'msg'
#fixed E0602:3940:baseCommands.tabNannyNode: Undefined variable 'nag'
#fixed E0602:3942:baseCommands.tabNannyNode: Undefined variable 'nag'
#fixed E0602:3943:baseCommands.tabNannyNode: Undefined variable 'nag'
#fixed E0602:3944:baseCommands.tabNannyNode: Undefined variable 'nag'
#fixed E1101:5849:baseCommands.scanAtRootDirectives:
    Instance of 'configSettings' has no 'at_root_bodies_start_in_doc_mode' member

************* Module leo.core.leoEditCommands
# fixed E0602:1064:controlCommandsClass.executeSubprocess: Undefined variable 'x'
# fixed E0602:1065:controlCommandsClass.executeSubprocess: Undefined variable 'x'
# fixed E0601:3379:editCommandsClass.linesHelper: Using variable 'x' before assignment
# fixed E0602:8792:AspellClass.updateDictionary: Undefined variable 'err'
# fixed E0602:8793:AspellClass.updateDictionary: Undefined variable 'err'
# fixed E0601:3372:editCommandsClass.linesHelper: Using variable 'x' before assignment

************* Module leo.core.leoFileCommands
# fixed E0602:618:baseFileCommands.checkLeoFile: Undefined variable 'message'
# fixed E0602:620:baseFileCommands.checkLeoFile: Undefined variable 'message'
# fixed E0602:744:baseFileCommands.getLeoFile: Undefined variable 'message'

************* Module leo.core.leoGlobals
# fixed W0311:3086: Bad indentation. Found 9 spaces, expected 8
# fixed W0311:3088: Bad indentation. Found 9 spaces, expected 8
# fixed E0602:1522:print_dict: Undefined variable 'keys'
# fixed E0602:1538:dictToString: Undefined variable 'keys'

************* Module leo.core.leoTangle
# E1101:1992:baseTangleCommands.st_dump: Instance of 'baseTangleCommands' has no 'txt' member
# changed to tst.
#@-node:ekr.20080918164844.17:Fixed pylint warnings
#@+node:ekr.20080919084526.1:Removed many calls to d.keys
Many, but not all, of these calls are unnecessary.
#@nonl
#@-node:ekr.20080919084526.1:Removed many calls to d.keys
#@+node:ekr.20080919085541.4:Fixed hangs in Leo3k
# They were due to __cmp__ not being called.
# Replaced p.__cmp__ with p.__eq__ and p.__ne__.
#@nonl
#@+node:ekr.20080919121250.1:leoConfig
#@+node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    c = self.c ; aList = [] ; tag = '@menu' ; trace = False and g.isPython3
    p = p.copy() ; after = p.nodeAfterTree()
    if trace: g.trace('******',p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace('***',self.debug_count,p.headString())
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if not g.app.unitTesting and not g.app.silentMode:
            g.es_print('Using menus from',c.shortFileName(),color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.headString())
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.headString())
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20041119204700.1:traverse (parserBaseClass)
def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # if g.isPython3:
            # g.trace(result,p.headString())
            # if p.headString() == 'Menus': g.pdb()
        if result == "skip":
            # g.es_print('skipping settings in',p.headString(),color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
#@-node:ekr.20041119204700.1:traverse (parserBaseClass)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace('=' * 20, c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@-node:ekr.20080919121250.1:leoConfig
#@+node:ekr.20080919121250.2:leoFileCommands
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    # g.trace('hiddenRootNode',c.hiddenRootNode)

    try:
        if g.isPython3:
            if theFile:
                pass # Just use the open binary file, opened by g.openLeoOrZipFile.
            else:
                theFile = StringIO(s)
        else:
            if theFile:
                s = theFile.read()
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20080919121250.2:leoFileCommands
#@+node:ekr.20080919121250.3:leoPlugins
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):

    if g.app.killed:
        return

    if g.isPython3:
        g.trace('ignoring all plugins')
        return

    # g.trace(tag)
    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
#@-node:ekr.20041001161108:doPlugins
#@-node:ekr.20080919121250.3:leoPlugins
#@+node:ekr.20080919121250.4:runLeo
#@+node:ekr.20031218072017.1934:run & helpers
def run(fileName=None,pymacs=None,jyLeo=False,*args,**keywords):

    """Initialize and run Leo"""

    if not isValidPython(): return
    if jyLeo: startJyleo()
    g.computeStandardDirectories()
    adjustSysPath()
    script,windowFlag = scanOptions()
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    createSpecialGui(jyLeo,pymacs,script,windowFlag)
    g.doHook("start1") # Load plugins. Plugins may create g.app.gui.
    if g.app.killed: return # Support for g.app.forceShutdown.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return
    finishInitApp(c)
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'): g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    g.app.gui.runMainLoop()
#@+node:ekr.20070306085724:adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.'''

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test')

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070306085724:adjustSysPath
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(jyLeo,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    elif jyLeo:
        import leo.core.leoSwingGui as leoSwingGui
        g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    fileName = g.g.os_path_finalize_join(os.getcwd(),fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921091311.2:initApp
def initApp (verbose):

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921091311.2:initApp
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(title='Python Version Error',message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8:<< define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9:__init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@-node:ekr.20080822065427.9:__init__ (emergencyDialog)
#@+node:ekr.20080822065427.12:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20080822065427.12:createButtons
#@+node:ekr.20080822065427.14:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@-node:ekr.20080822065427.14:createTopFrame
#@+node:ekr.20080822065427.10:okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@-node:ekr.20080822065427.10:okButton
#@+node:ekr.20080822065427.21:onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@-node:ekr.20080822065427.21:onKey
#@+node:ekr.20080822065427.16:run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@-node:ekr.20080822065427.16:run
#@-node:ekr.20080822065427.8:<< define emergency dialog class >>
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    # name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    name = g.os_path_finalize_join(g.app.loadDir,'..','test','leoProfile.txt')

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return script, windowFlag
#@nonl
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20070930194949:startJyleo
def startJyleo ():

    import leo.core.leoSwingFrame as leoSwingFrame
    import leo.core.leoSwingUtils as leoSwingUtils
    import java.awt as awt

    print('*** run:jyLeo',sys.platform) # e.g., java1.6.0_02

    if 1:
        g.app.splash = None
    else:
        g.app.splash = splash = leoSwingFrame.leoSplash()
        awt.EventQueue.invokeAndWait(splash)

    gct = leoSwingUtils.GCEveryOneMinute()
    gct.run()

    tk = awt.Toolkit.getDefaultToolkit()
    tk.setDynamicLayout(True)
#@-node:ekr.20070930194949:startJyleo
#@+node:ekr.20040411081633:startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:startPsyco
#@-node:ekr.20031218072017.1934:run & helpers
#@-node:ekr.20080919121250.4:runLeo
#@+node:ekr.20080919121250.5:Major short circuits
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace('=' * 20, c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):

    if g.app.killed:
        return

    if g.isPython3:
        g.trace('ignoring all plugins')
        return

    # g.trace(tag)
    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
#@-node:ekr.20041001161108:doPlugins
#@+node:ekr.20031218072017.1934:run & helpers
def run(fileName=None,pymacs=None,jyLeo=False,*args,**keywords):

    """Initialize and run Leo"""

    if not isValidPython(): return
    if jyLeo: startJyleo()
    g.computeStandardDirectories()
    adjustSysPath()
    script,windowFlag = scanOptions()
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    createSpecialGui(jyLeo,pymacs,script,windowFlag)
    g.doHook("start1") # Load plugins. Plugins may create g.app.gui.
    if g.app.killed: return # Support for g.app.forceShutdown.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return
    finishInitApp(c)
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'): g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    g.app.gui.runMainLoop()
#@+node:ekr.20070306085724:adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.'''

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test')

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070306085724:adjustSysPath
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(jyLeo,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    elif jyLeo:
        import leo.core.leoSwingGui as leoSwingGui
        g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    fileName = g.g.os_path_finalize_join(os.getcwd(),fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921091311.2:initApp
def initApp (verbose):

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921091311.2:initApp
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(title='Python Version Error',message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8:<< define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9:__init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@-node:ekr.20080822065427.9:__init__ (emergencyDialog)
#@+node:ekr.20080822065427.12:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20080822065427.12:createButtons
#@+node:ekr.20080822065427.14:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@-node:ekr.20080822065427.14:createTopFrame
#@+node:ekr.20080822065427.10:okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@-node:ekr.20080822065427.10:okButton
#@+node:ekr.20080822065427.21:onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@-node:ekr.20080822065427.21:onKey
#@+node:ekr.20080822065427.16:run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@-node:ekr.20080822065427.16:run
#@-node:ekr.20080822065427.8:<< define emergency dialog class >>
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    # name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    name = g.os_path_finalize_join(g.app.loadDir,'..','test','leoProfile.txt')

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return script, windowFlag
#@nonl
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20070930194949:startJyleo
def startJyleo ():

    import leo.core.leoSwingFrame as leoSwingFrame
    import leo.core.leoSwingUtils as leoSwingUtils
    import java.awt as awt

    print('*** run:jyLeo',sys.platform) # e.g., java1.6.0_02

    if 1:
        g.app.splash = None
    else:
        g.app.splash = splash = leoSwingFrame.leoSplash()
        awt.EventQueue.invokeAndWait(splash)

    gct = leoSwingUtils.GCEveryOneMinute()
    gct.run()

    tk = awt.Toolkit.getDefaultToolkit()
    tk.setDynamicLayout(True)
#@-node:ekr.20070930194949:startJyleo
#@+node:ekr.20040411081633:startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:startPsyco
#@-node:ekr.20031218072017.1934:run & helpers
#@-node:ekr.20080919121250.5:Major short circuits
#@+node:ekr.20080919121250.6:Problems opening .leo files
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    # g.trace('hiddenRootNode',c.hiddenRootNode)

    try:
        if g.isPython3:
            if theFile:
                pass # Just use the open binary file, opened by g.openLeoOrZipFile.
            else:
                theFile = StringIO(s)
        else:
            if theFile:
                s = theFile.read()
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@+node:ekr.20070412082527:g.openLeoOrZipFile
def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@-node:ekr.20080919121250.6:Problems opening .leo files
#@+node:ekr.20080919153256.1:Problems reading derived files
#@+node:ekr.20041005105605.135:closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):

    at = self

    if at.outputFile:
        at.outputFile.flush()
        if at.toString:
            at.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
        return at.stringOutput
    else:
        return None
#@-node:ekr.20041005105605.135:closeWriteFile
#@+node:ekr.20041005105605.204:os
def os (self,s):

    """Write a string to the output stream.

    All output produced by leoAtFile module goes here."""

    at = self

    if s and at.outputFile:
        try:
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            at.outputFile.write(s)
        except Exception:
            at.exception("exception writing:" + s)
#@-node:ekr.20041005105605.204:os
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.

    The caller is responsible for handling newlines correctly."""

    @others
#@+node:ekr.20050404151753: ctor
def __init__(self,encoding='utf-8',fromString=None):

    # g.trace('g.fileLikeObject:__init__','fromString',fromString)

    # New in 4.2.1: allow the file to be inited from string s.

    self.encoding = encoding

    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0

# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.
#@-node:ekr.20050404151753: ctor
#@+node:ekr.20050404151753.1:clear
def clear (self):

    self.list = []
#@-node:ekr.20050404151753.1:clear
#@+node:ekr.20050404151753.2:close
def close (self):

    pass

    # The StringIo version free's the memory buffer.
#@-node:ekr.20050404151753.2:close
#@+node:ekr.20050404151753.3:flush
def flush (self):

    pass
#@-node:ekr.20050404151753.3:flush
#@+node:ekr.20050404151753.4:get & getvalue & read
def get (self):

    return ''.join(self.list)

getvalue = get # for compatibility with StringIo
read = get # for use by sax.
#@-node:ekr.20050404151753.4:get & getvalue & read
#@+node:ekr.20050404151753.5:readline
def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr < len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''
#@-node:ekr.20050404151753.5:readline
#@+node:ekr.20050404151753.6:write
def write (self,s):

    if s:
        if g.isBytes(s):
            s = g.toUnicode(s,self.encoding)

        self.list.append(s)
#@-node:ekr.20050404151753.6:write
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@-node:ekr.20080919153256.1:Problems reading derived files
#@+node:ekr.20080919153256.2:Unicode problems
#@+node:ekr.20080816125725.2:g.isBytes & g.isString
def isBytes (s):

    '''Return True if s is Python3k bytes type.

    Python 3.x: s must be a unicode string, not bytes.
    Python 2.x: always returns False.'''

    if g.isPython3:
        # Generates a pylint warning, but that can't be helped.
        return type(s) == type(bytes('a','utf-8'))
    else:
        return False

def isString (s):

    '''Return True if s is a string.

    Python 3.x: s must be a unicode string, not bytes.
    Python 2.x: s may be either a unicode string or a regular string.'''

    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) in types.StringTypes
#@-node:ekr.20080816125725.2:g.isBytes & g.isString
#@+node:ekr.20050208093800:g.toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if isPython3:
        if g.isString(s):
            try:
                s = s.encode(encoding,"strict")
            except UnicodeError:
                if reportErrors:
                    g.reportBadChars(s,encoding)
                s = s.encode(encoding,"replace")

    else:
        if type(s) == types.UnicodeType:
            try:
                s = s.encode(encoding,"strict")
            except UnicodeError:
                if reportErrors:
                    g.reportBadChars(s,encoding)
                s = s.encode(encoding,"replace")
    return s
#@-node:ekr.20050208093800:g.toEncodedString
#@+node:ekr.20050208093800.1:g.toUnicode
def toUnicode (s,encoding,reportErrors=False):

    if isPython3:
        if s is None:
            return ''
        elif not g.isBytes(s):
            return s
        else:
            try:
                s = s.decode(encoding)
            except UnicodeError:
                if reportErrors:
                    g.reportBadChars(s,encoding)
                s = unicode(s,encoding,"replace")
            return s
    else:
        if s is None:
            return unicode('')
        elif type(s) == types.UnicodeType:
            return s
        else:
            try:
                s = unicode(s,encoding,"strict")
            except UnicodeError:
                if reportErrors:
                    g.reportBadChars(s,encoding)
                s = unicode(s,encoding,"replace")
            return s
#@-node:ekr.20050208093800.1:g.toUnicode
#@+node:ekr.20031218072017.2317:g.trace
# Convert all args to strings.

def trace (*args,**keys):

    # Compute the effective args.
    d = {'align':0,'newline':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    align = d.get('align')
    if align is None: align = 0

    # Compute the caller name.
    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except Exception: name = ''
    if name == "?":
        name = "<unknown>"

    # Pad the caller name.
    if align != 0 and len(name) < abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align > 0: name = name + pad
        else:         name = pad + name

    # Munge *args into s.
    # print ('g.trace:args...')
    # for z in args: print (g.isString(z),repr(z))
    result = []
    for arg in args:
        if g.isString(arg):
            pass
        elif g.isBytes(arg):
            arg = g.toUnicode(arg,'utf-8')
        else:
            arg = repr(arg)
        if result:
            result.append(" " + arg)
        else:
            result.append(arg)
    s = ''.join(result)
    try:
        g.pr('%s: %s' % (name,s),newline=newline)
    except Exception:
        s = g.toEncodedString(s,'ascii')
        g.pr('%s: %s' % (name,s),newline=newline)

#@-node:ekr.20031218072017.2317:g.trace
#@+node:ekr.20080710101653.1:g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.

    try: # We can't use any print keyword args in Python 2.x!
        # print(s) # Not quite right.
        if d.get('newline'):
            sys.stdout.write(s+'\n')
        else:
            sys.stdout.write(s)
    except Exception:
        print('unexpected Exception in g.pr')
        g.es_exception()
        g.trace(g.callers())
#@-node:ekr.20080710101653.1:g.pr
#@-node:ekr.20080919153256.2:Unicode problems
#@+node:ekr.20080920052058.1:Unbounded loops
@
The problem was that __cmp__ was not being called.
It has now been replaced by the __eq__ and __ne__ operators.
#@nonl
#@+node:ekr.20040228094013: p.ctor & other special methods...
#@+node:ekr.20080416161551.190: p.__init__
def __init__ (self,v,childIndex=0,stack=None,trace=False):

    '''Create a new position with the given childIndex and parent stack.'''

    # To support ZODB the code must set v._p_changed = 1
    # whenever any mutable vnode object changes.

    self._childIndex = childIndex
    self.v = v

    # New in Leo 4.5: stack entries are tuples (v,childIndex).
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())

    self.txtOffset = None # see self.textOffset()
#@-node:ekr.20080416161551.190: p.__init__
#@+node:ekr.20080920052058.3:p.__eq__ & __ne__
def __eq__(self,p2):

    """Return True if two postions are equivalent."""

    p1 = self

    # Don't use g.trace: it might call p.__eq__ or p.__ne__.
    # print ('p.__eq__: %s %s' % (
        # p1 and p1.v and p1.headString(),p2 and p2.v and p2.headString()))

    if p2 is None or p2.v is None:
        return p1.v is None
    else:
        return ( p1.v == p2.v and
            p1._childIndex == p2._childIndex and
            p1.stack == p2.stack )

def __ne__(self,p2):

    """Return True if two postions are not equivalent."""

    return not self.__eq__(p2) # For possible use in Python 2.x.
#@-node:ekr.20080920052058.3:p.__eq__ & __ne__
#@+node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):

        """Convert references to p.t into references to p.v.t.

        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                g.pr("unknown position attribute:",attr)
                import traceback ; traceback.print_stack()
            raise AttributeError(attr)
#@nonl
#@-node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20040117173448:p.__nonzero__ & __bool__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

if g.isPython3:

    def __bool__ ( self):

        """Return True if a position is valid."""

        # Tracing this appears to cause unbounded prints.
        # print("__bool__",self.v and self.v.cleanHeadString())

        return self.v is not None

else:

    def __nonzero__ ( self):

        """Return True if a position is valid."""

        # if g.app.trace: "__nonzero__",self.v

        # g.trace(repr(self))

        return self.v is not None
#@-node:ekr.20040117173448:p.__nonzero__ & __bool__
#@+node:ekr.20040301205720:p.__str__ and p.__repr__
def __str__ (self):

    p = self

    if p.v:
        return "<pos %d childIndex: %d lvl: %d [%d] %s>" % (
            id(p),p._childIndex,p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d [%d] None>" % (id(p),len(p.stack))

__repr__ = __str__
#@-node:ekr.20040301205720:p.__str__ and p.__repr__
#@+node:ekr.20061006092649:p.archivedPosition
def archivedPosition (self,root_p=None):

    '''Return a representation of a position suitable for use in .leo files.'''

    p = self

    if root_p is None:
        aList = [z._childIndex for z in p.self_and_parents_iter()]
    else:
        aList = []
        for z in p.self_and_parents_iter():
            if z == root_p:
                aList.append(0)
                break
            else:
                aList.append(z._childIndex)
        # g.trace(aList)

    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061006092649:p.archivedPosition
#@+node:ekr.20040117171654:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):

    """"Return an independent copy of a position."""

    # if g.app.tracePositions: g.trace(g.callers())

    return position(self.v,self._childIndex,self.stack,trace=False)
#@-node:ekr.20040117171654:p.copy
#@+node:ekr.20040310153624:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):

    p = self
    g.pr('-'*10,label,p)
    if p.v:
        p.v.dump() # Don't print a label

def vnodeListIds (self):

    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20040310153624:p.dump & p.vnodeListIds
#@+node:ekr.20080416161551.191:p.key
def key (self):

    p = self

    vList = [z[0] for z in p.stack]

    return '%s:%s.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(z)) for z in vList])
    )
#@-node:ekr.20080416161551.191:p.key
#@-node:ekr.20040228094013: p.ctor & other special methods...
#@+node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    c = self.c ; aList = [] ; tag = '@menu' ; trace = False and g.isPython3
    p = p.copy() ; after = p.nodeAfterTree()
    if trace: g.trace('******',p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace('***',self.debug_count,p.headString())
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if not g.app.unitTesting and not g.app.silentMode:
            g.es_print('Using menus from',c.shortFileName(),color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.headString())
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
#@-node:ekr.20080920052058.1:Unbounded loops
#@-node:ekr.20080919085541.4:Fixed hangs in Leo3k
#@+node:ekr.20080918164844.1:Leo now requires Python 2.4 or higher
#@-node:ekr.20080918164844.1:Leo now requires Python 2.4 or higher
#@-node:ekr.20080918201437.1:Leo3k work
#@+node:ekr.20080917153158.12:Fixed bugs
#@+node:ekr.20080917153158.13:Ensure that Python\Scripts exists in installer script
#@-node:ekr.20080917153158.13:Ensure that Python\Scripts exists in installer script
#@+node:ekr.20080917153158.14:Fix config crasher
@nocolor

Latest revision from trunk.

To reproduce:

- open a new outline.
- create a @settings node.
- create two children of the @settings node with the following
headlines "@string xxx = aaa" and "@button xxx".
- save the outline and close it.
- reopen the outline.

I'm getting the following traceback:

Traceback (most recent call last):
 File "/home/shadow/leo/leo-current/leo/core/leoGlobals.py", line
2818, in doHook
   return f(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 97,
in doPlugins
   return doHandlersForTag(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 76,
in doHandlersForTag
   val = callTagHandler(bunch,tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 55,
in callTagHandler
   result = handler(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 197, in onCreate
   sc.createAllButtons()
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 261, in createAllButtons
   self.handleAtButtonNode(p)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 533, in handleAtButtonNode
   b =
self.createAtButtonHelper(p,h,statusLine,shortcut,verbose=False)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 681, in createAtButtonHelper
   pane='button',verbose=verbose)
 File "/home/shadow/leo/leo-current/leo/core/leoKeys.py", line 3161,
in registerCommand
   junk,bunchList = c.config.getShortcut(commandName)
 File "/home/shadow/leo/leo-current/leo/core/leoCommands.py", line
7271, in getShortcut
   return g.app.config.getShortcut(self.c,shortcutName)
 File "/home/shadow/leo/leo-current/leo/core/leoConfig.py", line
1682, in getShortcut
   if bunch.val and bunch.val.lower() != 'none']
AttributeError: 'unicode' object has no attribute 'val'

@color
#@nonl
#@+node:ekr.20051015093141:typesMatch
def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything *except* shortcuts.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts',)

    return (
        type1 == None or type2 == None or
        type1.startswith('string') and type2 not in shortcuts or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
#@-node:ekr.20051015093141:typesMatch
#@-node:ekr.20080917153158.14:Fix config crasher
#@+node:ekr.20080915083836.2:Fixed encoding problems with rst3 plugin
http://groups.google.com/group/leo-editor/browse_thread/thread/5f5219fedd977ec2

@nocolor

I recently discovered leo and decided to give it a try. I'm using the
rst3 plugin for generating latex docs. In general it works like a
charm, but I'm having some problems with the text encoding. The most
annoying one follows. If in my rst tree I've nodes with the character

 (U+0140)

(or other character from the catalan alphabet) in the body text, I get
conversion errors in the log pane when the Write-Restructured-Text
command is executed. For instance, a node with the following body text

Nula

causes the following error in the log pane:

1 errors converting Nu?la.

 to iso-8859-1

If I process the generated .tex file via pdflatex the character is
displayed as a ? symbol in the pdf.

The rst-options are:

@ @rst-options
default_path=latex
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
write_intermediate_file = False
verbose=True
publish_argv_for_missing_stylesheets=--language=ca,--output-
encoding=utf-8,--stylesheet=/home/vmas/.leo/custom_style.sty
@c

If, instead of using leo, I put the problematic text content in a
plain rst file and process it via rst2latex I get no conversion
errors. The command line is:

rst2latex --language=ca --output-encoding=utf-8 --stylesheet=/home/
vmas/.leo/custom_style.sty prova.txt prova.tex 
#@nonl
#@-node:ekr.20080915083836.2:Fixed encoding problems with rst3 plugin
#@+node:ekr.20080918122745.1:Simplified c.scanAtPathDirectives
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@-node:ekr.20080918122745.1:Simplified c.scanAtPathDirectives
#@+node:ekr.20080918084804.1:Fixed goto-global-line crasher
#@+node:ekr.20080827175609.39:c.scanAllDirectives
def scanAllDirectives(self,p=None):

    '''Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.'''

    c = self ; p = p or c.currentPosition()

    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body_pane_wraps")

    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process: do *not* set commander ivars.
    lang_dict       = d.get('lang-dict')

    return {
        "delims"        : lang_dict.get('delims'),
        "encoding"      : d.get('encoding'),
        "language"      : lang_dict.get('language'),
        "lineending"    : d.get('lineending'),
        "pagewidth"     : d.get('pagewidth'),
        "path"          : d.get('path') or g.getBaseDirectory(c),
        "tabwidth"      : d.get('tabwidth'),
        "pluginsList"   : [],  ### To do: what about scan-directives hook?
        "wrap"          : d.get('wrap'),
    }
#@nonl
#@-node:ekr.20080827175609.39:c.scanAllDirectives
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if not force:
        if c:
            if not c.config.create_nonexistent_directories:
                return None
        elif not app.config.create_nonexistent_directories:
            return None

    if c:
        theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                g.es_print("created directory:",path,color='red')
            except Exception:
                g.trace(g.callers())
                g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@+node:ekr.20080710082231.10:c.gotoLineNumber and helpers
def goToLineNumber (self,n,p=None,scriptData=None):

    '''Place the cursor on the n'th line of a derived file or script.
    When present scriptData is a dict with 'root' and 'lines' keys.'''

    c = self
    delim = None ; gnx = None ; vnodeName = None
    if n < 0: return

    fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n,p,scriptData)

    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; n2 = root.bodyString().count('\n') ; found = False
    elif isRaw:
        p,n2,found = c.goto_countLines(root,n)
    else:
        vnodeName,gnx,n2,delim = c.goto_findVnode(root,lines,n,ignoreSentinels)
        if delim:
            p,found = c.goto_findPosition(
                root,lines,vnodeName,gnx,n,delim)
        else:
            p,found = root,False
    if 0:
        << trace gotoLineNumber results >>
    c.goto_showResults(found,p or root,n,n2,lines)
#@+node:ekr.20080905130513.40:<< trace gotoLineNumber results >>
g.trace(
    '\n  found',found,'n2',n2,'gnx',gnx,'delim',repr(delim),
    '\n  vnodeName',vnodeName,
    '\n  p        ',p and p.headString(),
    '\n  root     ',root and root.headString())
#@-node:ekr.20080905130513.40:<< trace gotoLineNumber results >>
#@+node:ekr.20080708094444.65:goto_applyLineNumberMapping
def goto_applyLineNumberMapping(self, n):

    c = self ; x = c.shadowController

    if len(x.line_mapping) > n:
        return x.line_mapping[n]
    else:
        return n
#@-node:ekr.20080708094444.65:goto_applyLineNumberMapping
#@+node:ekr.20080904071003.12:goto_countLines
def goto_countLines (self,root,n):

    '''Scan through root's outline, looking for line n.
    Return (p,n2,found) where p is the found node,
    n2 is the actural line found, and found is True if the line was found.'''

    p = lastv = root
    prev = 0 ; found = False
    isNosent = root.isAtNoSentFileNode()
    isAuto = root.isAtAutoNode()

    for p in p.self_and_subtree_iter():
        lastv = p.copy()
        s = p.bodyString()
        if isNosent or isAuto:
            s = ''.join([z for z in g.splitLines(s) if not z.startswith('@')])
        n_lines = s.count('\n')
        if len(s) > 0 and s[-1] != '\n': n_lines += 1
        # g.trace(n,prev,n_lines,p.headString())
        if prev + n_lines >= n:
            found = True ; break
        prev += n_lines

    p = lastv
    n2 = max(1,n-prev)

    return p,n2,found
#@-node:ekr.20080904071003.12:goto_countLines
#@+node:ekr.20080904071003.4:goto_findPosition & helpers
def goto_findPosition(self,root,lines,vnodeName,gnx,n,delim):

    c = self

    # if scriptFind:
        # p,found = c.scanForVnodeName(root,vnodeName

    if gnx:
        p,found = c.goto_findGnx(root,gnx,vnodeName)
    else:
        p,found = c.goto_scanTnodeList(root,delim,lines,n,vnodeName)

    # if not found:
        # g.es("not found:",vnodeName,color="red")

    return p,found
#@+node:ekr.20080904071003.18:goto_findGnx
def goto_findGnx (self,root,gnx,vnodeName):

    '''Scan root's tree for a node with the given gnx and vnodeName.

    return (p,found)'''

    gnx = g.app.nodeIndices.scanGnx(gnx,0)

    for p in root.self_and_subtree_iter():
        if p.matchHeadline(vnodeName):
            if p.v.t.fileIndex == gnx:
                return p.copy(),True

    return None,False
#@-node:ekr.20080904071003.18:goto_findGnx
#@+node:ekr.20080904071003.19:goto_scanTnodeList
def goto_scanTnodeList (self,root,delim,lines,n,vnodeName):

    # This is about the best that can be done without replicating the entire atFile write logic.
    found = False
    ok = hasattr(root.v.t,"tnodeList")

    if ok:
        # Use getattr to keep pylint happy.
        tnodeList = getattr(root.v.t,'tnodeList')
        << set tnodeIndex to the number of +node sentinels before line n >>
        tnodeIndex = max(0,tnodeIndex)
        << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
    else:
        g.es_print("no child index for",root.headString(),color="red")

    if not ok:
        # Fall back to the old logic.
        << set p to the first node whose headline matches vnodeName >>

    return p,found
#@+node:ekr.20080904071003.8:<< set tnodeIndex to the number of +node sentinels before line n >>

tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@-node:ekr.20080904071003.8:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20080904071003.9:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False
#@-node:ekr.20080904071003.9:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20080904071003.10:<< set p to the first node whose headline matches vnodeName >>
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@-node:ekr.20080904071003.10:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20080904071003.19:goto_scanTnodeList
#@-node:ekr.20080904071003.4:goto_findPosition & helpers
#@+node:ekr.20031218072017.2877:goto_findVnode
def goto_findVnode (self,root,lines,n,ignoreSentinels):

    '''Search the lines of a derived file containing sentinels for a vnode.
    return (vnodeName,gnx,offset,delim):

    vnodeName:  the name found in the previous @+body sentinel.
    gnx:        the gnx of the found node.
    offset:     the offset within the node of the desired line.
    delim:      the comment delim from the @+leo sentinel.
    '''

    c = self ; at = c.atFileCommands
    # g.trace('lines...\n',g.listToString(lines))
    gnx = None
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es('no sentinels in:',root.headString())
        return None,None,None,None

    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        g.trace('no @+node!!')
        return root.headString(),gnx,1,delim

    s = lines[nodeSentinelLine]

    << set gnx and vnodeName from s >>
    if delim and vnodeName:
        # g.trace('offset',offset)
        return vnodeName,gnx,offset,delim
    else:
        g.es("bad @+node sentinel")
        return None,None,None,None
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

# Set delim from the @+leo line.
delim = None
if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,thinFile = at.parseLeoSentinel(s)
    # New in Leo 4.5.1: only support 4.x files.
    if valid and newDerivedFile:
        delim = start + '@'
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
@
Scan backwards from the requested line, looking for an @-body line. When found,
we get the vnode's name from that line and set p to the indicated vnode. This
will fail if vnode names have been changed, and that can't be helped.

We compute the offset of the requested line **within the found node**.
@c

offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1 # Start with the requested line.
while line >= 0:
    progress = line
    s = lines[line]
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        ### offset += 1 # Assume the line is real.  A dubious assumption.
        line -= 1
    assert line < progress
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line",str(n),"is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    old_line = line
    line = c.goto_skipToMatchingNodeSentinel(lines,line,delim)
    assert line < old_line
    # g.trace('found',repr(lines[line]))
    nodeSentinelLine = line
    offset = n-line
    break
elif g.match(s,i,"+node"):
    # g.trace('found',repr(lines[line]))
    nodeSentinelLine = line
    offset = n-line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    # if not ignoreSentinels:
        # offset += 1 # Count these as a "real" lines.
    line -= 1
else:
    line -= 1
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set gnx and vnodeName from s >>
i = 0 ; gnx = None ; vnodeName = None

if thinFile:
    # gnx is lies between the first and second ':':
    i = s.find(':',i)
    if i > 0:
        i += 1
        j = s.find(':',i)
        if j > 0:   gnx = s[i:j]
        else:       i = len(s) # Force an error.
    else:
        i = len(s) # Force an error.

# vnode name is everything following the first or second':'
i = s.find(':',i)
if i > -1:
    vnodeName = s[i+1:].strip()
else:
    vnodeName = None
    g.es_print("bad @+node sentinel",color='red')
#@-node:ekr.20031218072017.2881:<< set gnx and vnodeName from s >>
#@-node:ekr.20031218072017.2877:goto_findVnode
#@+node:ekr.20080904071003.28:goto_setup & helpers
def goto_setup (self,n,p=None,scriptData=None):

    '''Return (fileName,isRaw,lines,n,p,root) where:

    fileName is the name of the nearest @file node, or None.
    isRaw is True if there are no sentinels in the file.
    lines are the lines to be scanned.
    n is the effective line number (munged for @shadow nodes).
    root is the nearest @file node, or c.currentPosition.'''

    c = self

    if scriptData:
        assert p is None
        lines = scriptData.get('lines')
        p = scriptData.get('p')
        root,fileName = c.goto_findRoot(p)
    else:
        # p is for unit testing only!
        if not p: p = c.currentPosition()
        root,fileName = c.goto_findRoot(p)
        if root and fileName:
            c.shadowController.line_mapping = [] # Set by goto_open.
            lines = c.goto_getFileLines(root,fileName)
            n = c.goto_applyLineNumberMapping(n)
        else:
            lines = c.goto_getScriptLines(p)

    isRaw = not root or (
        root.isAtAsisFileNode() or root.isAtNoSentFileNode() or root.isAtAutoNode())

    ignoreSentinels = root and root.isAtNoSentFileNode()

    if scriptData:
        if not root: root = p.copy()
    else:
        if not root: root = c.currentPosition()

    return fileName,ignoreSentinels,isRaw,lines,n,root
#@+node:ekr.20080904071003.25:goto_findRoot
def goto_findRoot (self,p):

    '''Find the closest ancestor @file node, of any type, except @all nodes.

    return root, fileName.'''

    c = self ; p1 = p.copy()

    # First look for ancestor @file node.
    for p in p.self_and_parents_iter():
        fileName = not p.isAtAllNode() and p.anyAtFileNodeName()
        if fileName:
            return p.copy(),fileName

    # Search the entire tree for joined nodes.
    # Bug fix: Leo 4.5.1: *must* search *all* positions.
    for p in c.all_positions_iter():
        # if p.v.t == p1.v.t: g.trace('p1',p1,'p',p)
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p2 in p.self_and_parents_iter():
                fileName = not p2.isAtAllNode() and p2.anyAtFileNodeName()
                if fileName:
                    return p2.copy(),fileName

    return None,None
#@-node:ekr.20080904071003.25:goto_findRoot
#@+node:ekr.20080904071003.26:goto_getFileLines
def goto_getFileLines (self,root,fileName):

    '''Read the file into lines.'''

    c = self

    if root.isAtNoSentFileNode():
        # Write a virtual file containing sentinels.
        at = c.atFileCommands
        at.write(root,nosentinels=False,toString=True)
        lines = g.splitLines(at.stringOutput)
    else:
        # Calculate the full path.
        d = g.scanDirectives(c,p=root)
        path = d.get("path")
        # g.trace('path',path,'fileName',fileName)
        fileName = c.os_path_finalize_join(path,fileName)
        lines    = c.goto_open(fileName)

    return lines
#@-node:ekr.20080904071003.26:goto_getFileLines
#@+node:ekr.20080904071003.27:goto_getScriptLines
def goto_getScriptLines (self,p):

    c = self

    if not g.unitTesting:
        g.es("no ancestor @file node: using script line numbers", color="blue")

    lines = g.getScript (c,p,useSelectedText=False)
    lines = g.splitLines(lines)

    return lines
#@-node:ekr.20080904071003.27:goto_getScriptLines
#@+node:ekr.20080708094444.63:goto_open
def goto_open (self,filename):
    """
    Open a file for "goto linenumber" command and check if a shadow file exists.
    Construct a line mapping. This ivar is empty i no shadow file exists.
    Otherwise it contains a mapping shadow file number -> real file number.
    """

    c = self ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        if os.path.exists(shadow_filename):
            fn = shadow_filename
            lines = open(shadow_filename).readlines()
            x.line_mapping = x.push_filter_mapping(
                lines, x.marker_from_extension(shadow_filename))
        else:
            # Just open the original file.  This is not an error!
            fn = filename
            c.line_mapping = []
            lines = open(filename).readlines()
    except Exception:
        # Make sure failures to open a file generate clear messages.
        g.es_print('can not open',fn,color='blue')
        # g.es_exception()
        lines = []

    return lines
#@-node:ekr.20080708094444.63:goto_open
#@-node:ekr.20080904071003.28:goto_setup & helpers
#@+node:ekr.20080904071003.14:goto_showResults
def goto_showResults(self,found,p,n,n2,lines):

    c = self ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    c.redraw()

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)    
    else:
        ins = len(s)
        if len(lines) < n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    # g.trace('n',n,'ins',ins,'p',p.headString())

    w.setInsertPoint(ins)
    c.bodyWantsFocusNow()
    w.seeInsertPoint()
#@-node:ekr.20080904071003.14:goto_showResults
#@+node:ekr.20031218072017.2882:goto_skipToMatchingNodeSentinel
def goto_skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
#@-node:ekr.20031218072017.2882:goto_skipToMatchingNodeSentinel
#@-node:ekr.20080710082231.10:c.gotoLineNumber and helpers
#@-node:ekr.20080918084804.1:Fixed goto-global-line crasher
#@+node:ekr.20080923143214.1:Removed pychecker stuff
# It's time.
#@nonl
#@-node:ekr.20080923143214.1:Removed pychecker stuff
#@-node:ekr.20080917153158.12:Fixed bugs
#@+node:ekr.20080917153158.15:New features
#@+node:ekr.20080917153158.16:Added c.config.getSettingSource
@nocolor

c.config.getSettingSource('show_full_tracebacks_in_scripts')
returns the name of the file which Leo used to determine the setting

- D indicates default settings.
- F indicates the file being loaded
- L indicates leoSettings.leo
- M indicates myLeoSettings.leo

theHash = d.get('_hash').lower()

if letter:
    pass
elif theHash.endswith('myleosettings.leo'):
    letter = '[M]'
elif theHash.endswith('leosettings.leo'):
    letter = ' ' * 3
else:
    letter = '[D]'

@color
#@nonl
#@-node:ekr.20080917153158.16:Added c.config.getSettingSource
#@+node:ekr.20080124083629.1:Improved @path handling
@nocolor





@color
#@nonl
#@+node:ekr.20080917154206.1:Done
What I did:

- Changed g.scanDirectives(c,p) to c.scanAllDirectives(p) in core.

- A deprecated g.scanDirectives just calls c.scanAllDirectives.
#@nonl
#@+node:ekr.20050121081635:Cumulative @path directives
@killcolor
https://sourceforge.net/forum/message.php?msg_id=2936513
By: ktenney

In the @view plugin is a method, currentPath() which examines the current headline
and body, and the headlines and bodies of it's parents, looking for @path and
@view directives. It builds a path from them and checks for validity.

if a top level node contains;
@path /home/ktenney

and a descendant of that node contains;
@path projects/myproject

Then a node further down the tree which contains;
@view readme.txt

will display /home/ktenney/projects/myproject/readme.txt

I like this principle of cumulative paths, and would like other plugins to work
the same way ... @image, @url etc.

This brings me to my question, would it make sense for Leo to offer a 'Plugin'
class to inherit from? It seems that there are some operations that are being
re-written in many plugins.


============

QQQQQQ
nested @paths don't do what I expected: 

For a leo file in directory foo: 

@path src 
....@path tmpl

should refer to foo/src and foo/src/tmpl

using @path src/tmpl works fine though.
QQQQQQQ
#@nonl
#@-node:ekr.20050121081635:Cumulative @path directives
#@-node:ekr.20080917154206.1:Done
#@-node:ekr.20080124083629.1:Improved @path handling
#@+node:ekr.20080917154206.4:Merge leo-30 branch
@nocolor 

This make's Leo's syntax compatible with Python 3.0.
#@nonl
#@-node:ekr.20080917154206.4:Merge leo-30 branch
#@+node:ekr.20080919085541.2:Open a default .leo file if no other is specified
# Added support for @string default_leo_file = ~/.leo/workbook.leo
#@nonl
#@+node:ekr.20080921060401.7: Request
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/d6449236bc140713#

Now it's easier than ever to add *quick* notes with leo. ILeo knows of
"special" leo file ~/.ipython/ipython_notebook.leo, which is opened
automatically when you do:

lleo

("launch leo" without specifying a .leo file to open. The old
behaviour was to open untitled file, saving of which iIs pain).

lno This is my note

("leo note")

This opens ipython_notebook.leo if leo is not running already, and
adds a headline with "This is my note" under headline "Scratch". Of
course the focus still remains in the ipython window, so you can
proceed adding more notes with %lno without losing your concentration
or touching your mouse. If you run  %lno with a note string that
already exists, the existing note is focused instead.

To enable all this goodness, you just need to add

_ip.load('ipy_leo')

to your ipy_user_conf.py.

You also need to install leo with "setup.py develop".

I guess this is leo's equivalent of Chandler's "Quick entry bar",
described here:

http://www.youtube.com/watch?v=JJBxajDwmLI 

@color
#@nonl
#@-node:ekr.20080921060401.7: Request
#@+node:ekr.20080921060401.11:Refactoring runLeo.run
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(jyLeo,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    elif jyLeo:
        import leo.core.leoSwingGui as leoSwingGui
        g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.9:doEarlyInits
def doEarlyInits(verbose):

    import leo.core.leoGlobals as g
    import leo.core.leoNodes as leoNodes
    import leo.core.leoConfig as leoConfig

    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.

    # There is a circular dependency between leoCommands and leoEditCommands.
    import leo.core.leoCommands as leoCommands

    # New in Leo 4.5 b3: make sure we call the new leoPlugins.init top-level function.
    # This prevents a crash when run is called repeatedly from IPython's lleo extension.
    import leo.core.leoPlugins as leoPlugins
    leoPlugins.init()

    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921060401.9:doEarlyInits
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    fileName = g.g.os_path_finalize_join(os.getcwd(),fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1934:run & helpers
def run(fileName=None,pymacs=None,jyLeo=False,*args,**keywords):

    """Initialize and run Leo"""

    if not isValidPython(): return
    if jyLeo: startJyleo()
    g.computeStandardDirectories()
    adjustSysPath()
    script,windowFlag = scanOptions()
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    createSpecialGui(jyLeo,pymacs,script,windowFlag)
    g.doHook("start1") # Load plugins. Plugins may create g.app.gui.
    if g.app.killed: return # Support for g.app.forceShutdown.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return
    finishInitApp(c)
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'): g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    g.app.gui.runMainLoop()
#@+node:ekr.20070306085724:adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.'''

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test')

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070306085724:adjustSysPath
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(jyLeo,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    elif jyLeo:
        import leo.core.leoSwingGui as leoSwingGui
        g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    fileName = g.g.os_path_finalize_join(os.getcwd(),fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921091311.2:initApp
def initApp (verbose):

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921091311.2:initApp
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(title='Python Version Error',message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8:<< define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9:__init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@-node:ekr.20080822065427.9:__init__ (emergencyDialog)
#@+node:ekr.20080822065427.12:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20080822065427.12:createButtons
#@+node:ekr.20080822065427.14:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@-node:ekr.20080822065427.14:createTopFrame
#@+node:ekr.20080822065427.10:okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@-node:ekr.20080822065427.10:okButton
#@+node:ekr.20080822065427.21:onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@-node:ekr.20080822065427.21:onKey
#@+node:ekr.20080822065427.16:run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@-node:ekr.20080822065427.16:run
#@-node:ekr.20080822065427.8:<< define emergency dialog class >>
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    # name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    name = g.os_path_finalize_join(g.app.loadDir,'..','test','leoProfile.txt')

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return script, windowFlag
#@nonl
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20070930194949:startJyleo
def startJyleo ():

    import leo.core.leoSwingFrame as leoSwingFrame
    import leo.core.leoSwingUtils as leoSwingUtils
    import java.awt as awt

    print('*** run:jyLeo',sys.platform) # e.g., java1.6.0_02

    if 1:
        g.app.splash = None
    else:
        g.app.splash = splash = leoSwingFrame.leoSplash()
        awt.EventQueue.invokeAndWait(splash)

    gct = leoSwingUtils.GCEveryOneMinute()
    gct.run()

    tk = awt.Toolkit.getDefaultToolkit()
    tk.setDynamicLayout(True)
#@-node:ekr.20070930194949:startJyleo
#@+node:ekr.20040411081633:startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:startPsyco
#@-node:ekr.20031218072017.1934:run & helpers
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return script, windowFlag
#@nonl
#@-node:ekr.20080521132317.2:scanOptions
#@-node:ekr.20080921060401.11:Refactoring runLeo.run
#@+node:ekr.20080921060401.12:Support for @string default_leo_file = ~/.leo/workbook.leo
#@+node:ekr.20080921060401.13:os_path_expanduser
def os_path_expanduser(path,encoding=None):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path,encoding)

    result = os.path.normpath(os.path.expanduser(path))

    # g.trace('path',path,'expanduser', result)

    return result
#@-node:ekr.20080921060401.13:os_path_expanduser
#@+node:ekr.20070412082527:g.openLeoOrZipFile
def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_finalize(fileName)
    isZipped = fileName and zipfile.is_zipfile(fileName)
    isLeo = isZipped or fileName.endswith('.leo')
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    if isLeo:
        theList = app.windowList
        for frame in theList:
            if munge(fileName) == munge(frame.c.mFileName):
                frame.bringToFront()
                frame.c.setLog()
                frame.c.outerUpdate()
                return True, frame
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
            g.doHook('open0')

        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile,isZipped = g.openLeoOrZipFile(fileName)
        if not theFile: return False, None
        c,frame = app.newLeoCommanderAndFrame(
            fileName=fileName,
            relativeFileName=relativeFileName,
            gui=gui)
    else:
        c,frame = g.openWrapperLeoFile(old_c,fileName,gui)
        if not c: return False,None

    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if isLeo:
            app.lockLog()
            ok = frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(frame)
                return False,frame
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.currentPosition()
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    c.redraw()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    return True, frame
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@-node:ekr.20080921060401.12:Support for @string default_leo_file = ~/.leo/workbook.leo
#@-node:ekr.20080919085541.2:Open a default .leo file if no other is specified
#@+node:ekr.20080910054558.2:Added -c option to specify config files
@nocolor

The setting is called -c or --config.  The one-config-file arg no longer exists.

http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

Personally, I'd like to see another config file available via -c on
the command line:
(a common idiom)

leo myproject.leo -c /usr/lib/myproject/myLeoSettings.leo

or better yet:

leo myproject.leo -c /etc/leo/style01.leo
leo myotherproject.leo -c /etc/leo/style02.leo
leo anotherproject.leo -c /etc/leo/style23.leo

Each file opens in an editor with the shortcuts, buttons, commands,
plugins, appearance etc.  that has been tuned for that data management task.

or best yet:

leo myproject.leo -c /usr/lib/python2.5/site-packages/leo/config/style94.leo

==================

http://groups.google.com/group/leo-editor/browse_thread/thread/b5a736089079acaf#

Please, I think each file has a distinct and required role.

- config/leoSettings.leo = Edward's base, required for a sane starting point

- home/.leo/myLeoSettings.leo = adjust Edwards suggestions to taste

- cwd/myLeoSettings.leo = provide a customized working environment in
this folder

- leo -c /usr/lib/leo-editor/src/config/zope3_ide.leo =
  - open this file in a specialized environments, mine or community contributed
  - ...

- currentfile/@settings =
  - I'm working on some customization ideas
  - Here, try out this Leo file I sent you, check out all the spiffy
modifications 

@color
#@nonl
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return script, windowFlag
#@nonl
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@-node:ekr.20080910054558.2:Added -c option to specify config files
#@+node:ekr.20080921060401.15:Replaced g.os_path.abspath with g.os_path_finalize/_join
# This is the elegant, clear way to support os.path.expanduser.
#@nonl
#@+node:ekr.20080921060401.13:os_path_expanduser
def os_path_expanduser(path,encoding=None):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path,encoding)

    result = os.path.normpath(os.path.expanduser(path))

    # g.trace('path',path,'expanduser', result)

    return result
#@-node:ekr.20080921060401.13:os_path_expanduser
#@+node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path,encoding=encoding)
    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: args = [g.os_path_expandExpression(path,**keys)
        for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@-node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):

    c = keys.get('c')
    encoding = keys.get('encoding')

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z,encoding=encoding) for z in uargs if z]

    path = os.path.join(*uargs)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
#@-node:ekr.20031218072017.2154:os_path_join
#@-node:ekr.20080921060401.15:Replaced g.os_path.abspath with g.os_path_finalize/_join
#@+node:ekr.20080921091311.5:Make sure '~' is handled properly in all contexts: add unit tests
#@-node:ekr.20080921091311.5:Make sure '~' is handled properly in all contexts: add unit tests
#@+node:ekr.20080918164844.15:Allow Leo to open .py files directly (or any other kind of file)
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626

I'm wondering, would it make sense for leo to do "something" when launched
directly against a .py file, i.e.

"leo test.py".

Of course that's a perfectly sensible thing to do, considering that leo is,
among other things, a python editor ;-)

Perhaps it might create create a (unsaved) leo document  where the .py file
is present as @shadow node, or something.

@color
#@nonl
#@+node:ekr.20080919085541.1:@url http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626
#@-node:ekr.20080919085541.1:@url http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626
#@+node:ekr.20080921154026.4:Not changed
#@+node:ekr.20070412082527:g.openLeoOrZipFile
def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leo.core.leoCommands as leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    << compute the window title >>

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName,relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    # if not g.app.initing:
        # g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame

    # Set c.openDirectory
    theDir = g.os_path_dirname(fileName)
    if theDir: c.openDirectory = theDir

    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)

    if ok:
        frame.resizePanesToRatio(ratio,frame.secondary_ratio)

    return ok
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should follow this with a call to c.redraw().

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    << warn on read-only files >>
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    c.loading = True # disable c.changed

    try:
        ok = True
        # t1 = time.clock()
        v = self.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            self.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            self.rootVnode = v
            c.setRootPosition(p)
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    # Do this before reading derived files.
    self.resolveTnodeLists()

    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw_now()
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    # Do this after reading derived files.
    if readAtFileNodesFlag:
        # The descendent nodes won't exist unless we have read the @thin nodes!
        self.restoreDescendentAttributes()

    self.setPositionsFromVnodes()
    c.selectVnode(c.currentPosition()) # load body pane

    self.initAllParents()

    if c.config.getBool('check_outline_after_read'):
        g.trace('@bool check_outline_after_read = True',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, self.ratio
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False

if self.read_only:
    g.es("read only:",fileName,color="red")
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20080921154026.4:Not changed
#@+node:ekr.20080921154026.5:Changed
#@+node:ekr.20080211085914:scanDefaultDirectory (leoImport)
def scanDefaultDirectory(self,p):

    """Set .default_directory by looking for @path directives."""

    c = self.c ; p1 = p.copy()
    self.default_directory = None
    if not p: return
    << Set path from @file node >>
    if self.default_directory:
        return

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        if 'path' in theDict:
            << handle @path >>
            return

    << Set current directory >>
    if not self.default_directory and p1.anyAtFileNodeName():
        # Don't issue a warning if p is not, in fact, an @file node.
        # This should never happen: c.openDirectory should be a good last resort.
        self.error("No absolute directory specified anywhere.")
        g.trace(g.callers())
        self.default_directory = ""
#@+node:ekr.20080211085914.1:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else:
        self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20080211085914.1:<< Set path from @file node >>
#@+node:ekr.20080211085914.2:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

path = theDict["path"]
path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = c.os_path_finalize_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        self.error("ignoring bad @path: %s" % path)
else:
    self.error("ignoring empty @path")
#@+node:ekr.20080211085914.3:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else:
    self.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20080211085914.3:<< handle absolute path >>
#@-node:ekr.20080211085914.2:<< handle @path >>
#@+node:ekr.20080211085914.4:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not self.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else:
                    self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20080211085914.4:<< Set current directory >>
#@-node:ekr.20080211085914:scanDefaultDirectory (leoImport)
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    func = self.importDispatchDict.get(ext)
    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    z = g.choose(atAuto,'@auto ','')
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (z,fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_finalize(fileName)
    isZipped = fileName and zipfile.is_zipfile(fileName)
    isLeo = isZipped or fileName.endswith('.leo')
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    if isLeo:
        theList = app.windowList
        for frame in theList:
            if munge(fileName) == munge(frame.c.mFileName):
                frame.bringToFront()
                frame.c.setLog()
                frame.c.outerUpdate()
                return True, frame
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
            g.doHook('open0')

        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile,isZipped = g.openLeoOrZipFile(fileName)
        if not theFile: return False, None
        c,frame = app.newLeoCommanderAndFrame(
            fileName=fileName,
            relativeFileName=relativeFileName,
            gui=gui)
    else:
        c,frame = g.openWrapperLeoFile(old_c,fileName,gui)
        if not c: return False,None

    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if isLeo:
            app.lockLog()
            ok = frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(frame)
                return False,frame
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.currentPosition()
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    c.redraw()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    return True, frame
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20080921154026.1:g.openWrapperLeoFile
def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''

    # This code is similar to c.new, but different enough to be separate.
    if not g.os_path_exists(fileName):
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,None

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    if 1: # Just read the file into the node.
        try:
            fileName = g.os_path_finalize(fileName)
            f = open(fileName)
            s = f.read()
            f.close()
        except IOError:
            g.es_print("can not open: ",fileName,color='red')
            return None,None
        p = c.currentPosition()
        p.setHeadString(fileName)
        p.setBodyString(s)
    else:  # Import the file into the new outline.
        junk,ext = g.os_path_splitext(fileName)
        p = c.currentPosition()
        p = c.importCommands.createOutline(fileName,parent=p,atAuto=False,ext=ext)
        c.setCurrentPosition(p)
        c.moveOutlineLeft()
        p = c.currentPosition()
        c.setCurrentPosition(p.back())
        c.deleteOutline(op_name=None)
        p = c.currentPosition()
        p.expand()

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(True) # Unlike new, we the outline should be marked changed.

    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()

    # c.redraw_now() # Only needed by menu commands.
    return c,frame
#@-node:ekr.20080921154026.1:g.openWrapperLeoFile
#@-node:ekr.20080921154026.5:Changed
#@+node:ekr.20080921154026.6:tests
leo c:\leo.repo\trunk\leo\modes\python.py

# --silent optional below
leo --script c:\leo.repo\trunk\leo\test\unittest\batchTest.py
#@nonl
#@-node:ekr.20080921154026.6:tests
#@-node:ekr.20080918164844.15:Allow Leo to open .py files directly (or any other kind of file)
#@+node:ekr.20080921154026.10:Added better default fonts for Leo on Linux
http://groups.google.com/group/leo-editor/browse_thread/thread/f1c7c5134b95c77e

The suggestion: paste fonts into myLeoSettings.leo.

Can they be a better default?
#@nonl
#@+node:ekr.20080921154026.11:Fonts
@nocolor
@

Valid values:

weight: bold, normal, None
slant: roman, italic, None

Use the show-fonts command to pick fonts, then copy the values shown
by the show-fonts command to the values here.

@c

import sys ; print sys.platform
#@+node:ekr.20080921154026.12:@font body text font
body_text_font_family = fixed
body_text_font_size = 11
body_text_font_slant = None
body_text_font_weight = None
#@-node:ekr.20080921154026.12:@font body text font
#@+node:ekr.20080921154026.13:@font button font
button_text_font_family = fixed
button_text_font_size = 8
button_text_font_slant = roman
button_text_font_weight = normal
#@-node:ekr.20080921154026.13:@font button font
#@+node:ekr.20080921154026.14:@font log font
# The font for the log pane. Default is
default font for Tk.Text widgets.
# Tk translates invalid font names to another font in a system-dependent way.
#
# Default size is 12 for Linux, 9 otherwise.

log_text_font_family = Courier
log_text_font_size = 9
log_text_font_slant = roman
log_text_font_weight = normal
#@-node:ekr.20080921154026.14:@font log font
#@+node:ekr.20080921154026.15:@font menu text font
menu_text_font_family = None
menu_text_font_size = None
menu_text_font_slant = None
menu_text_font_weight = None
#@nonl
#@-node:ekr.20080921154026.15:@font menu text font
#@+node:ekr.20080921154026.16:@font outline font
headline_text_font_family = fixed
headline_text_font_size = 11
headline_text_font_slant = roman
headline_text_font_weight = normal
#@-node:ekr.20080921154026.16:@font outline font
#@-node:ekr.20080921154026.11:Fonts
#@-node:ekr.20080921154026.10:Added better default fonts for Leo on Linux
#@+node:ekr.20080922124033.3:Enter tree pane after clone-find-all
# It's surprisingly annoying not to be able to move the tree just created.
#@nonl
#@-node:ekr.20080922124033.3:Enter tree pane after clone-find-all
#@+node:ekr.20080921154026.7:Added support for {{exp}}
#@+node:ekr.20080922170408.1:Made {{exp}} work in @path
#@+node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
#@+node:ekr.20031218072017.2146:os_path_abspath
def os_path_abspath(path,encoding=None):

    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.abspath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2146:os_path_abspath
#@+node:ekr.20031218072017.2147:os_path_basename
def os_path_basename(path,encoding=None):

    """Return the second half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.basename(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2147:os_path_basename
#@+node:ekr.20031218072017.2148:os_path_dirname
def os_path_dirname(path,encoding=None):

    """Return the first half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.dirname(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2148:os_path_dirname
#@+node:ekr.20031218072017.2149:os_path_exists
def os_path_exists(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.exists(path)
#@-node:ekr.20031218072017.2149:os_path_exists
#@+node:ekr.20080922124033.6:os_path_expandExpression
def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    i = s.find('{{')
    j = s.find('}}')
    if -1 < i < j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.currentPosition()
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

    return s
#@-node:ekr.20080922124033.6:os_path_expandExpression
#@+node:ekr.20080921060401.13:os_path_expanduser
def os_path_expanduser(path,encoding=None):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path,encoding)

    result = os.path.normpath(os.path.expanduser(path))

    # g.trace('path',path,'expanduser', result)

    return result
#@-node:ekr.20080921060401.13:os_path_expanduser
#@+node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path,encoding=encoding)
    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: args = [g.os_path_expandExpression(path,**keys)
        for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@-node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
#@+node:ekr.20031218072017.2150:os_path_getmtime
def os_path_getmtime(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getmtime(path)
#@-node:ekr.20031218072017.2150:os_path_getmtime
#@+node:ekr.20080729142651.2:os_path_getsize
def os_path_getsize (path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getsize(path)
#@-node:ekr.20080729142651.2:os_path_getsize
#@+node:ekr.20031218072017.2151:os_path_isabs
def os_path_isabs(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isabs(path)
#@-node:ekr.20031218072017.2151:os_path_isabs
#@+node:ekr.20031218072017.2152:os_path_isdir
def os_path_isdir(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isdir(path)
#@-node:ekr.20031218072017.2152:os_path_isdir
#@+node:ekr.20031218072017.2153:os_path_isfile
def os_path_isfile(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isfile(path)
#@-node:ekr.20031218072017.2153:os_path_isfile
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):

    c = keys.get('c')
    encoding = keys.get('encoding')

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z,encoding=encoding) for z in uargs if z]

    path = os.path.join(*uargs)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20031218072017.2156:os_path_normcase
def os_path_normcase(path,encoding=None):

    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normcase(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2156:os_path_normcase
#@+node:ekr.20031218072017.2157:os_path_normpath
def os_path_normpath(path,encoding=None):

    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normpath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2157:os_path_normpath
#@+node:ekr.20080605064555.2:os_path_realpath
def os_path_realpath(path,encoding=None):


    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.realpath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20080605064555.2:os_path_realpath
#@+node:ekr.20031218072017.2158:os_path_split
def os_path_split(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@-node:ekr.20031218072017.2158:os_path_split
#@+node:ekr.20031218072017.2159:os_path_splitext
def os_path_splitext(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@-node:ekr.20031218072017.2159:os_path_splitext
#@+node:ekr.20031218072017.2160:toUnicodeFileEncoding
def toUnicodeFileEncoding(path,encoding):

    if path: path = path.replace('\\', os.sep)

    if not encoding:
        if sys.platform == "win32" or sys.platform.lower().startswith('java'):
            # encoding = "mbcs" # Leo 4.2 and previous.
            encoding = 'utf-8' # New in Leo 4.3
        else:
            encoding = app.tkEncoding

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path,encoding)
#@-node:ekr.20031218072017.2160:toUnicodeFileEncoding
#@-node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c ; trace = False
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        if trace: g.trace('returns',at.default_directory)
        return

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        if 'path' in theDict:
            << handle @path >>
            if trace: g.trace('returns',at.default_directory)
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        g.trace(g.callers())
        at.default_directory = ""

    if trace: g.trace('returns',at.default_directory)
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

path = theDict["path"]
path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = c.os_path_finalize_join(base,path) # Bug fix: 2008/9/23

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = c.os_path_finalize_join(base,theDir) # Bug fix: 2008/9/23
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20080922124033.5:c.os_path_finalize and c.os_path_finalize_join
def os_path_finalize (self,path,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize(path,**keys)

def os_path_finalize_join (self,*args,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize_join(*args,**keys)
#@-node:ekr.20080922124033.5:c.os_path_finalize and c.os_path_finalize_join
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    func = self.importDispatchDict.get(ext)
    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    z = g.choose(atAuto,'@auto ','')
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (z,fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20071109165315:g.computeRelativePath
def computeRelativePath (path):

    if len(path) > 2 and (
        (path[0]=='<' and path[-1] == '>') or
        (path[0]=='"' and path[-1] == '"') or
        (path[0]=="'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()

    # We want a *relative* path, not an absolute path.
    return path
#@-node:ekr.20071109165315:g.computeRelativePath
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if not force:
        if c:
            if not c.config.create_nonexistent_directories:
                return None
        elif not app.config.create_nonexistent_directories:
            return None

    if c:
        theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                g.es_print("created directory:",path,color='red')
            except Exception:
                g.trace(g.callers())
                g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@+node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path,encoding=encoding)
    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: args = [g.os_path_expandExpression(path,**keys)
        for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@-node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):

    c = keys.get('c')
    encoding = keys.get('encoding')

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z,encoding=encoding) for z in uargs if z]

    path = os.path.join(*uargs)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

    fn = c.os_path_finalize_join(at.default_directory,fn)
    shadow_fn     = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)

    if shadow_exists:
        # at.read (via at.openFileForReading) calls x.updatePublicAndPrivateFiles.
        at.read(p,thinFile=True,atShadow=True)
    else:
        if not g.unitTesting: g.es("reading:",p.headString())
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p,toString=False,force=True)
#@+node:ekr.20080712080505.1:importAtShadowNode
def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
#@-node:ekr.20080712080505.1:importAtShadowNode
#@-node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
#@-node:ekr.20080922170408.1:Made {{exp}} work in @path
#@-node:ekr.20080921154026.7:Added support for {{exp}}
#@-node:ekr.20080917153158.15:New features
#@+node:ekr.20080922124033.2:Documentation
#@+node:ekr.20080921154026.9:Added getInput example to Leo's docs
http://webpages.charter.net/edreamleo/scripting.html#getting-interactive-input-from-scripts
#@nonl
#@-node:ekr.20080921154026.9:Added getInput example to Leo's docs
#@-node:ekr.20080922124033.2:Documentation
#@-node:ekr.20080917153158.11:4.6
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
