#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20090831095817.6067:Leo 4.6.3
- Put caching bug fixes into 46-maint branch
- Fixed bug in g.adjustTripleString.
- Created .nsi script.
#@nonl
#@-node:ekr.20090831095817.6067:Leo 4.6.3
#@+node:ekr.20090907080624.6082:Leo 4.6.4
#@+node:ekr.20090907080624.6083:Added new plugins
@nocolor-node

New command-line option
    --gui=qttabs

new plugins:
    spydershell,
    qtframecommands
    mod_framesize.

Improved plugin:  "show folder" in rclick menu.

Improved plugin: contextmenu.py

    If you rclick on @thin / whatever item, you should see "open
    /home/ville/foo" (or equivalent) menu entry. It open up the file manager on
    that folder (using xdg-open on linux, os.startfile on windows). I have no
    idea what to do with mac, now it runs xdg-open and probably fails.
#@nonl
#@-node:ekr.20090907080624.6083:Added new plugins
#@-node:ekr.20090907080624.6082:Leo 4.6.4
#@+node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:bwmulder.20050101094804:openForWrite (atFile)
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
#@-node:bwmulder.20050101094804:openForWrite (atFile)
#@+node:ekr.20090103070824.11:c.checkFileTimeStamp
def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    trace = False and not g.unitTesting
    c = self

    # Don't assume the file still exists.
    if not g.os_path_exists(fn):
        if trace: g.trace('file no longer exists',fn)
        return True

    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        if trace: g.trace('no time stamp',fn)
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        if trace: g.trace('time stamps match',fn,timeStamp)
        return True

    if g.app.unitTesting:
        return False

    if trace:
        g.trace('mismatch',timeStamp,timeStamp2)

    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090103070824.11:c.checkFileTimeStamp
#@-node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:ekr.20090812165611.5973:Fixed registerHandler bug
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/8616f4e171e1a24b

On Aug 10, 12:25 pm, tfer <tfethers...@aol.com> wrote:
> Well from vim.py:
> When properly installed, this plugin does the following:
>
> 1. - Double clicking on a node's icon opens that node in VIM. You can
> open nodes in VIM with
>         a single-click if you set useDoubleClick = False.

I tried setting "useDoubleClick = False" under the vim plugin node in
leoPluginsRef.leo work. It doesn't seem to work. I get the message:

exception loading plugin
Traceback (most recent call last):

 File "C:\Program Files\Leo-4-6-2-final\leo\core\leoPlugins.py", line
437, in loadOnePlugin
   init_result = result.init()

 File "C:\Program Files\Leo-4-6-2-final\leo\plugins\vim.py", line
232, in init
   leoPlugins.registerHandler(event,open_in_vim,val=True)

TypeError: registerHandler() got an unexpected keyword argument 'val'

The variable val doesn't get modified in the "open_in_vim
(tag,keywords,val=None)" function.
- Show quoted text -
#@nonl
#@-node:ekr.20090812165611.5973:Fixed registerHandler bug
#@+node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
# at_read attribute in the tnode, not the vnode.
#@nonl
#@+node:ekr.20090712050729.6017:promptForDangerousWrite
def promptForDangerousWrite (self,fileName,kind):

    c = self.c

    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForDangerousWrite')
        return val in (None,True)

    # g.trace(timeStamp, timeStamp2)
    message = '%s %s\n%s\n%s' % (
        kind, fileName,
        g.tr('already exists.'),
        g.tr('Overwrite this file?'))

    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite existing file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090712050729.6017:promptForDangerousWrite
#@-node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
#@+node:ekr.20090804091109.5985:Fixed double prompt in c.close()
#@+node:ekr.20091109103928.6372:Notes
@nocolor

This bug happens only on Linux.
#@nonl
#@-node:ekr.20091109103928.6372:Notes
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    # g.trace('frame',frame,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c) # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocus()
        frame.c.outerUpdate()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@-node:ekr.20090804091109.5985:Fixed double prompt in c.close()
#@+node:ekr.20090817080059.5995:Select main chapter initially
It can be alarming to select a small chapter in a large outline.
#@nonl
#@-node:ekr.20090817080059.5995:Select main chapter initially
#@+node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/33e87adbff5d69d9

Latest trunk.  qt gui

I used multiple body editors (2) for the first time in a long time and the
scroll position was moving at times that it shouldn't.

For example if I scrolled partially down the page and copied some text and then
pasted the text somewhere else that was visible without scrolling, the scroll
position would change significantly although the new text would remain visible.

It may not sound particularly serious but I found it very difficult to use.

The fix was to leoQtGui.updateEditors.
#@nonl
#@-node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
#@+node:ekr.20090822060128.6035:Improved the install docs
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/add6242d6f4fc476

From Matt Wilkie

I've installed Leo several times on windows, yet this morning still
took me a few minutes to find the section you reference above because
there are at least two other document sections with phrases similar to
"installing leo". Anyway, this is my simplified recipe for a virgin
install:

-------------------------
Installing Leo On Windows
-------------------------
//skip any step not needed//

1. Install Python - There are many sources, but from
http://www.python.org/download/releases/ is good

2. Install PyQt - acquire and run Binary Package from
http://www.riverbankcomputing.co.uk/software/pyqt/download which
matches installed Python version (so for python 2.5 scan for the
"Py2.5" in filename)

3. Install Leo
   - Head to http://sourceforge.net/projects/leo/ and slap [Download Now]
   - Unpack python *site-packages* folder, e.g.
C:\Python25\Lib\site-packages\leo-4-6-2-final

   - [optional] Generate/update a junction link from unpacked
leo-4-6-2-final to ...\site-packages\leo

      cd C:\Python25\Lib\site-packages\
      junction leo leo-4-6-2-final

   - Create windows shortcut (edit paths as necessary):

      Target   =  C:\Python25\pythonw.exe
"C:\Python25\Lib\site-packages\leo\launchLeo.py" --gui=qt
      Start in =  D:\code

   - Associate .leo filetype batch file:

      ftype LeoFile=C:\Python25\pythonw.exe
"C:\Python25\Lib\site-packages\leo\launchLeo.py" "--gui=qt" "%1"
      assoc .leo=LeoFile

   - [optional] Put this leo.bat in %PATH%:

      @C:\Python25\python.exe -i
"C:\Python25\Lib\site-packages\leo\launchLeo.py" --gui=qt %*

-------------------------

Further reading / Sources used:

   Junction links -
http://technet.microsoft.com/en-gb/sysinternals/bb896768.aspx,
http://groups.google.com/group/leo-editor/msg/30116f9193241dc4
   FTYPE - http://ss64.com/nt/ftype.html
   ASSOC - http://ss64.com/nt/assoc.html


=====================
Ville's comments

On Thu, Aug 20, 2009 at 10:49 PM, Matt Wilkie<map...@gmail.com> wrote:
> 3. Install Leo
>   - Head to http://sourceforge.net/projects/leo/ and slap [Download Now]
>   - Unpack python *site-packages* folder, e.g.
> C:\Python25\Lib\site-packages\leo-4-6-2-final

I don't think you need to use site-packages. Just extract it anywhere
you want (e.g. c:/opt/leo). But I could be wrong.

>   - Associate .leo filetype batch file:
>n
>      ftype LeoFile=C:\Python25\pythonw.exe
> "C:\Python25\Lib\site-packages\leo\launchLeo.py" "--gui=qt" "%1"
>      assoc .leo=LeoFile

--gui=qt us not needed anymore. 
#@nonl
#@-node:ekr.20090822060128.6035:Improved the install docs
#@+node:ekr.20090829175108.6133:Marked @<file> nodes dirty if nodes change during read.
#@+node:ekr.20041005105605.21:read (atFile) & helper
def read(self,root,
    importFileName=None,thinFile=False,
    fromString=None,atShadow=False,
    force=False
):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName and isAtFile >>
    if isAtFile:
        # The @file node has file-like sentinels iff a tnodeList exists.
        thinFile = not (hasattr(root.v,'tnodeList') and root.v.tnodeList)
    doCache = g.enableDB and (thinFile or atShadow) and not force
    at.initReadIvars(root,fileName,
        importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fileName,fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root, fileContent)

    # Remember that we have read this file.
    root.v.at_read = True # Create the attribute for all clones.

    if doCache and cachefile in c.db:
        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        aList = c.db[cachefile]
        root.v.createOutlineFromCacheList(c,aList)
        at.inputFile.close()
        root.clearDirty()
        return

    # Delete all children, but **not** for @file and @nosent nodes!
    # (We do delete all children for @file nodes with thin-like sentinels.)
    if thinFile or atShadow:
        root.v.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if not g.unitTesting:
        g.es("reading:",root.h)

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName and isAtFile >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False

isAtFile = (
    not thinFile and
    not importFileName and
    not atShadow and
    not fromString and
    root.h.startswith('@file'))
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName and isAtFile >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
resurrected = 0
for p in root.self_and_subtree():
    if p.v.isVisited():
        pass
        # g.trace('visited',p.v,p.h)
    else:
        g.trace('**** not visited',p.v,p.h)
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for v in c.all_unique_nodes():

    if hasattr(v,"tempBodyString"):
        delattr(v,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile) & helper
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    try:
        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(p, fileContent)
    except IOError:
        cachefile = None

    # Remember that we have read this file.
    p.v.at_auto_read = True # Create the attribute

    if cachefile is not None and cachefile in c.db:        
        # g.es('uncache:',p.h)
        aList = c.db[cachefile]
        p.v.createOutlineFromCacheList(c,aList)
        return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        # c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        self.writeCachedTree(p, cachefile)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20040311113514:p.clearDirty
def clearDirty (self):

    p = self
    p.v.clearDirty()
#@-node:ekr.20040311113514:p.clearDirty
#@+node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):

    p = self
    return p.v.findAllPotentiallyDirtyNodes()
#@-node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
#@+node:ekr.20040702104823:p.inAtIgnoreRange
def inAtIgnoreRange (self):

    """Returns True if position p or one of p's parents is an @ignore node."""

    p = self

    for p in p.self_and_parents():
        if p.isAtIgnoreNode():
            return True

    return False
#@-node:ekr.20040702104823:p.inAtIgnoreRange
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    trace = False and not g.unitTesting
    verbose = False
    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()

    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.setDirty()

    if trace: g.trace("position",dirtyVnodeList,g.callers(5))

    return dirtyVnodeList
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):

    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []

    # g.trace(p.h,g.callers(4))

    if not p.v.isDirty():
        p.v.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)

    return dirtyVnodeList
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20090830051712.6151: v.Dirty bits
#@+node:ekr.20031218072017.3390:v.clearDirty
def clearDirty (self):
    v = self
    v.statusBits &= ~ v.dirtyBit

#@-node:ekr.20031218072017.3390:v.clearDirty
#@+node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):

    trace = False and not g.unitTesting
    v = self ; c = v.context

    # Set the starting nodes.
    nodes = []
    newNodes = [v]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]

    # Remove the hidden vnode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root',c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)

    if trace: g.trace(nodes)
    return nodes
#@nonl
#@-node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes
#@+node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty
# Unlike p.setAllAncestorAtFileNodesDirty,
# there is no setDescendentsDirty arg.

def setAllAncestorAtFileNodesDirty (self):

    trace = False and not g.unitTesting
    verbose = False
    v = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = v.findAllPotentiallyDirtyNodes()

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]

    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.setDirty() # Do not call v.setDirty here!

    if trace: g.trace("vnode",dirtyVnodeList)

    return dirtyVnodeList
#@-node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty
#@+node:ekr.20080429053831.12:v.setDirty
def setDirty (self):

    self.statusBits |= self.dirtyBit
#@-node:ekr.20080429053831.12:v.setDirty
#@-node:ekr.20090830051712.6151: v.Dirty bits
#@+node:ekr.20090829064400.6040:v.createOutlineFromCacheList & helpers
def createOutlineFromCacheList(self,c,aList):
    """ Create outline structure from recursive aList
    built by p.makeCacheList.

    Clones will be automatically created by gnx,
    but *not* for the top-level node.
    """

    parent_v = self

    #import pprint ; pprint.pprint(tree)
    parent_v = self
    h,b,gnx,children = aList
    if h is not None:
        v = parent_v
        v._headString = h    
        v._bodyString = b

    for z in children:
        h,b,gnx,grandChildren = z
        isClone,child_v = parent_v.fastAddLastChild(c,gnx)
        if isClone:
            if child_v.b != b: # or child_v.h
                # Bug fix: the last seen clone rules.
                child_v.h = h
                child_v.b = b
                # Bug fix: mark @<file> nodes dirty.
                child_v.setAllAncestorAtFileNodesDirty()
                child_v.setMarked()
                g.es("changed:",child_v.h,color="blue")
        else:
            child_v.createOutlineFromCacheList(c,z)
#@+node:ekr.20090829064400.6042:v.fastAddLastChild
# Similar to createThinChild4
def fastAddLastChild(self,c,gnxString):
    '''Create new vnode as last child of the receiver.

    If the gnx exists already, create a clone instead of new vnode.
    '''

    trace = False and not g.unitTesting
    parent_v = self
    indices = g.app.nodeIndices
    gnxDict = c.fileCommands.gnxDict

    if gnxString is None: v = None
    else:                 v = gnxDict.get(gnxString)
    is_clone = v is not None

    if trace: g.trace(
        'clone','%-5s' % (is_clone),
        'parent_v',parent_v,'gnx',gnxString,'v',repr(v))

    if not is_clone:
        v = vnode(context=c)
        if gnxString:
            gnx = indices.scanGnx(gnxString,0)
            v.fileIndex = gnx
        gnxDict[gnxString] = v

    child_v = v
    child_v._linkAsNthChild(parent_v,parent_v.numberOfChildren())
    child_v.setVisited() # Supress warning/deletion of unvisited nodes.

    return is_clone,child_v
#@-node:ekr.20090829064400.6042:v.fastAddLastChild
#@-node:ekr.20090829064400.6040:v.createOutlineFromCacheList & helpers
#@-node:ekr.20090829175108.6133:Marked @<file> nodes dirty if nodes change during read.
#@+node:ekr.20090901175503.6096:Fixed bug in g.adjustTripleString
#@+node:ekr.20050211120242.2:g.removeExtraLws & test
def removeExtraLws (s,tab_width):

    '''Remove extra indentation from one or more lines.

    Warning: used by getScript.  This is *not* the same as g.adjustTripleString.'''

    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w = g.computeWidth(lws,tab_width)
            break
    else: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            g.pr(repr(line))

    return result
#@+node:ekr.20090517020744.5881:@test g.removeExtraLws
if g.unitTesting:

    c,p = g.getTestVars()

    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@-node:ekr.20090517020744.5881:@test g.removeExtraLws
#@-node:ekr.20050211120242.2:g.removeExtraLws & test
#@+node:ekr.20051014175117:g.adjustTripleString
def adjustTripleString (s,tab_width):

    '''Remove leading indentation from a triple-quoted string.

    This works around the fact that Leo nodes can't represent underindented strings.
    '''

    # Compute the minimum leading whitespace of all non-blank lines.
    trace = True and not g.unitTesting
    lines = g.splitLines(s)
    w = 0 ; val = -1
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w2 = g.computeWidth(lws,tab_width)
            # The sign of w does not matter.
            if w == 0 or abs(w2) < w:
                w = abs(w2)

    if w == 0: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    return result
#@+node:ekr.20090901175503.6098:@test g.adjustTripleString
if g.unitTesting:

    c,p = g.getTestVars()

    s = '''\
    a
      b

c
    d'''

    s2 = 'a\n  b\n\nc\nd'

    result = g.adjustTripleString(s,c.tab_width)
    assert result == s2,repr(result)


#@-node:ekr.20090901175503.6098:@test g.adjustTripleString
#@-node:ekr.20051014175117:g.adjustTripleString
#@+node:ekr.20031218072017.3202:removeLeadingWhitespace
# Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0 ; first_ws = abs(first_ws)
    for ch in s:
        if ws >= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j > 0:
        s = s[j:]
    return s
#@-node:ekr.20031218072017.3202:removeLeadingWhitespace
#@-node:ekr.20090901175503.6096:Fixed bug in g.adjustTripleString
#@+node:ekr.20090907140408.6123:Fixed startup reversion when .leoID.txt does not exist
#@+node:ekr.20041113113140:loadOnePlugin & test
def loadOnePlugin (moduleOrFileName,tag='open0',verbose=False):

    trace = False # and not g.unitTesting

    global loadedModules,loadingModuleNameStack

    # Prevent Leo from crashing if .leoID.txt does not exist.
    if g.app.config is None:
        print ('No g.app.config, making stub...')
        class StubConfig(g.nullObject):
            pass
        g.app.config = StubConfig()

    # Fixed reversion: do this after possibly creating stub config class.
    verbose = False or verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if trace or verbose:
            g.trace('plugin',moduleName,'already loaded',color="blue")
        return module

    assert g.app.loadDir

    plugins_path = g.os_path_finalize_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path,pluginName=moduleName,verbose=True)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)

        if tag == 'unit-test-load':
            pass # Keep the result, but do no more.
        elif hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                # g.trace('result',result,'init_result',init_result)
                if init_result:
                    loadedModules[moduleName] = result
                    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es_print('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.

            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                g.trace('no init()',moduleName)
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.app.batchMode or g.app.inBridge: # or g.unitTesting
        pass
    elif result:
        if trace or verbose:
            g.trace('loaded plugin:',moduleName,color="blue")
    else:
        if trace or warn_on_failure or (verbose and not g.app.initing):
            if trace or tag == 'open0':
                g.trace('can not load enabled plugin:',moduleName,color="red")

    return result
#@+node:ekr.20090522161156.5886:@test class StubConfig
if g.unitTesting:

    c,p = g.getTestVars()

    class StubConfig(g.nullObject):
        pass

    x = StubConfig()
    assert not x.getBool(c,'mySetting')
    assert not x.enabledPluginsFileName
#@nonl
#@-node:ekr.20090522161156.5886:@test class StubConfig
#@-node:ekr.20041113113140:loadOnePlugin & test
#@-node:ekr.20090907140408.6123:Fixed startup reversion when .leoID.txt does not exist
#@+node:ekr.20090930103947.6085:Fixed elisp bug
> Here is the fix:
> 'startsFunction' in 'elispScanner' should use
>    j = self.skipId(s,i)
> instead of
>    j = g.skip_id(s,i)
> skip_id doesn't take extraIdChars ('-' in elisp case) into
> consideration. 
#@nonl
#@+node:ekr.20070711060113:class elispScanner
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,unused_s,unused_i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False

    end = self.skipBlock(s,i)
    # g.trace('%3s %15s block: %s' % (i,repr(s[i:i+10]),repr(s[i:end])))
    if not g.match(s,end-1,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len('defun')
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = self.skipId(s,i) # Bug fix: 2009/09/30
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner
#@-node:ekr.20090930103947.6085:Fixed elisp bug
#@+node:ekr.20090930151626.6086:Made add-comments and delete-comments commands work with shortcuts
@language python

ab
#@nonl
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self,event=None):

    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('no text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',d3+' '

    # Comment out non-blank lines.
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            result.append(line[0:i]+openDelim+line[i:]+closeDelim)
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self,event=None):

    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('no text selected',color='blue')
        return

    if d1:
        # Remove the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in range(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es('',"'%s'" % (d2),"not found",color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es('',"'%s'" % (d3),"not found",color='blue')
                    return

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',
            repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        << handle special cases for plain keys >>

    << handle per-pane bindings >>

    if traceGC: g.printNewObjects('masterKey 5')

    return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.

if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function',k.state.kind) # k.state.handler)
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20080510153327.4:<< handle special cases for plain keys >>
#g.trace('plain key','state',k.unboundKeyAction,'stroke',stroke)

# Important: only keys bound somewhere have a stroke.
# All unbound plain keys will be handled by handleUnboundKeys.

if k.unboundKeyAction in ('insert','overwrite'):

    for key in (k.unboundKeyAction,'body','log','text','all'):
        # Ignore bindings for all plain keys in insert/overwrite mode *except* auto-complete.
        d = k.masterBindingsDict.get(key,{})
        if d:
            b = d.get(stroke)
            if b and b.commandName == 'auto-complete':
                if trace: g.trace('%s: auto-complete key in %s mode' % (stroke,k.unboundKeyAction))
                k.masterCommand(event,b.func,b.stroke,b.commandName)
                return 'break'

    if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
    k.masterCommand(event,func=None,stroke=stroke,commandName=None)
    return 'break'

# Bound   plain keys in command mode are by the per-pane logic.
# Unbound plain keys in command mode are ignored by handleUnboundKeys.

# This code ignores all command-state keys if we are not in a text widget.
elif k.unboundKeyAction == 'command':
    if not g.app.gui.isTextWidget(w):
        c.onCanvasKey(event)
        return 'break'
#@nonl
#@-node:ekr.20080510153327.4:<< handle special cases for plain keys >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
keyStatesTuple = ('command','insert','overwrite')

if True and trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
    'isTextWidget(w)',g.app.gui.isTextWidget(w))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None),
    ('all',None),
):
    if (
        # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        if trace: g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
        # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif keysym.find('Escape') != -1:
        # Never insert escape characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20061031131434.102:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c ; d = c.commandsDict

    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'keyboard-quit': g.trace(key,bunchList)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@-node:ekr.20061031131434.102:makeBindingsFromCommandsDict
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: g.trace(pane,shortcut,commandName)
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print ('redefining shortcut %30s from %s to %s in %s' % (
            shortcut,
            g.choose(pane=='button',z,commandName),
            g.choose(pane=='button',commandName,z),
            pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return

    trace = False
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        # Bug fix: 2009/09/30: use canonical stroke.
        accelerator = k.shortcutFromSetting(accel,addKey=False) or ''
        stroke = k.shortcutFromSetting(accel,addKey=True) or ''
        if accelerator:
            accelerator = g.stripBrackets(k.prettyPrintKey(accelerator))
        if trace: # and commandName == 'add-comments':
            g.trace(bunch.val,repr(stroke),repr(accelerator),commandName)
        def masterMenuCallback (c=c,k=k,stroke=stroke,command=command,commandName=commandName,event=None):
            # if trace: g.trace('stroke',stroke)
            return k.masterMenuHandler(stroke,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>

        # c.add_command ensures that c.outerUpdate is called.
        if menu:
            c.add_command(menu,label=realLabel,
                accelerator=accelerator,
                command=masterMenuCallback,
                underline=amp_index)
#@+node:ekr.20051021091958:<< get label & command or continue >>
if g.isString(data):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            if trace: g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            if trace: g.trace('2','%20s' % (bunch.val),commandName)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val
                    if trace: g.trace('3','%20s' % (bunch.val),commandName)
                    break
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
def shortcutFromSetting (self,setting,addKey=True):

    k = self

    trace = False and not g.unitTesting
    if not setting:return None

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    if trace: g.trace('%20s %s' % (setting,shortcut))
    return shortcut

canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting = shortcutFromSetting
#@+node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
meta  = s2.find("meta") >= 0
#@-node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
#@+node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
#@-node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
#@+node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@-node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
#@+node:ekr.20061031131434.188:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", s)
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
#@-node:ekr.20061031131434.188:<< compute the last field >>
#@+node:ekr.20061031131434.189:<< compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
#@-node:ekr.20061031131434.189:<< compute shortcut >>
#@-node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
#@-node:ekr.20090930151626.6086:Made add-comments and delete-comments commands work with shortcuts
#@+node:ekr.20091003171114.6465:Fixed contractOrGoRight
@nocolor-node

The culprit was the sparse_goto_parent option.
It never worked properly, and it caused the expansion
state of nodes as seen by Leo to get out-of-synch
with the expansion state as seen by the qt tree code.

To exercise the bug, do the following in test.leo:

- Expand the "prototypes" node.
- Expand any child node.
- Move beyond the now-expanded child node.
- Hit Alt-Left.  This will select the prototype node.
  The expanded child node will be marked by Leo as being contracted,
  but it *wont* be contracted actually, which confuses moveToVisNext.
#@nonl
#@+node:ekr.20031218072017.2996:selectVisNext
def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisNext(): return

    p.moveToVisNext(c)
    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2996:selectVisNext
#@+node:ekr.20031218072017.2995:selectVisBack
# This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisBack(): return

    p.moveToVisBack(c)

    # g.trace(p.h)
    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2995:selectVisBack
#@+node:ekr.20031218072017.2920:goToParent
def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.p

    # g.trace(p.parent())

    c.treeSelectHelper(p and p.parent())
#@-node:ekr.20031218072017.2920:goToParent
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    trace = False and not g.unitTesting
    c = self ; p = c.p
    redraw = False ; fullRedraw = False
    if p.hasChildren() and p.isExpanded():
        if trace: g.trace('contract',p.h)
        c.contractNode()
        redraw = True # New in one-node world.
    elif p.hasParent() and p.parent().isVisible(c):
        redraw = False
        p.contract() # Make sure we know this node is contracted.
        # This "feature" is dubious.
        # To work properly, it requires a full redraw.
        if False: # self.sparse_goto_parent:
            for child in p.self_and_siblings():
                if child != p and child.isExpanded():
                    child.contract()
                    redraw = True ; fullRedraw = True
        if trace: g.trace('goto parent',p.h)
        c.goToParent()

    if redraw:
        if fullRedraw or p.isCloned():
            if trace: g.trace('full redraw',p.h)
            c.redraw()
        else:
            c.redraw_after_contract(p=p,setFocus=True)
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    trace = False and not g.unitTesting
    c = self ; p = c.p

    # New code.
    if p.hasChildren():
        if p.isExpanded():
            p.moveToFirstChild()
            if trace: g.trace('select',p.h)
            c.selectPosition(p)
        else:
            if trace: g.trace('expand',p.h)
            c.expandNode() # Calls redraw_after_expand.
    elif p.hasNext():
        c.goToNextSibling()
    else:
        while p.hasParent():
            p.moveToParent()
            if p.hasNext():
                p.moveToNext()
                break
        c.selectPosition(p)
    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode() # Calls redraw_after_expand.
        else:
            c.redraw_after_expand(p.firstChild(),setFocus=True)
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20031218072017.2901:contractNode
def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.p

    p.contract()

    if p.isCloned():
        c.redraw() # A full redraw is necessary to handle clones.
    else:
        c.redraw_after_contract(p=p,setFocus=True)
#@-node:ekr.20031218072017.2901:contractNode
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    trace = False and not g.unitTesting
    c = self ; p = c.p

    p.expand()

    if p.isCloned():
        if trace: g.trace('***redraw')
        c.redraw() # Bug fix: 2009/10/03.
    else:
        c.redraw_after_expand(p,setFocus=True)

#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20070226113916: treeSelectHelper
def treeSelectHelper (self,p):

    c = self

    if not p: p = c.p

    if p:
        # Do not call expandAllAncestors here.
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeFocusHelper()
#@-node:ekr.20070226113916: treeSelectHelper
#@+node:ekr.20080416161551.210:p.moveToVisBack
def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    trace = False and not g.unitTesting
    verbose = True
    p = self ; limit,limitIsVisible = c.visLimit()
    if trace and verbose:
        g.trace(p,'limit',limit,'limitIsVisible',limitIsVisible)
    if trace: g.trace('***entry','parent',p.parent(),'p',p,g.callers(5))
    while p:
        # Short-circuit if possible.
        back = p.back()
        if trace: g.trace(
            'back',back,'hasChildren',bool(back and back.hasChildren()),
            'isExpanded',bool(back and back.isExpanded()))

        if back and back.hasChildren() and back.isExpanded():
            p.moveToThreadBack()
        elif back:
            p.moveToBack()
        else:
            p.moveToParent() # Same as p.moveToThreadBack()
        # if back and (not back.hasChildren() or not back.isExpanded()):
            # p.moveToBack()
        # else:
            # p.moveToThreadBack()
        if trace: g.trace(p.parent(),p)
        if p:
            if trace and verbose: g.trace('**p',p)
            done,val = self.checkVisBackLimit(limit,limitIsVisible,p)
            if done:
                if trace and verbose: g.trace('done',p)
                return val
            if p.isVisible(c):
                if trace and verbose: g.trace('isVisible',p)
                return p
    else:
        # assert not p.
        return p
#@+node:ekr.20090715145956.6166:checkVisBackLimit
def checkVisBackLimit (self,limit,limitIsVisible,p):

    '''Return done, return-val'''

    trace = True and not g.unitTesting
    c = p.v.context

    if limit:
        if limit == p:
            if trace: g.trace('at limit',p)
            if limitIsVisible and p.isVisible(c):
                return True,p
            else:
                return True,None
            #return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
        elif limit.isAncestorOf(p):
            return False,None
        else:
            if trace: g.trace('outside limit tree',limit,p)
            return True,None
    else:
        return False,None
#@-node:ekr.20090715145956.6166:checkVisBackLimit
#@-node:ekr.20080416161551.210:p.moveToVisBack
#@+node:ekr.20080416161551.211:p.moveToVisNext
def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    trace = False and not g.unitTesting
    verbose = False
    p = self ; limit,limitIsVisible = c.visLimit()
    while p:
        if trace: g.trace('1',p.h)
        # if trace: g.trace('hasChildren %s, isExpanded %s %s' % (
            # p.hasChildren(),p.isExpanded(),p.h))
        # Short-circuit if possible.
        if p.hasNext() and p.hasChildren() and p.isExpanded():
            p.moveToFirstChild()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToThreadNext()
        # if p.hasNext() and (not p.hasChildren() or not p.isExpanded()):
            # p.moveToNext()
        # else:
            # p.moveToThreadNext()
        if trace: g.trace('2',p.h)
        if p:
            done,val = self.checkVisNextLimit(limit,p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        # assert not p.
        return p
#@+node:ekr.20090715145956.6167:checkVisNextLimit
def checkVisNextLimit (self,limit,p):

    '''Return done, return-val'''

    trace = False and not g.unitTesting

    if limit:
        # Unlike moveToVisBack, being at the limit does not terminate.
        if limit == p:
            return False, None
        elif limit.isAncestorOf(p):
            return False,None
        else:
            if trace: g.trace('outside limit tree')
            return True,None
    else:
        return False,None
#@-node:ekr.20090715145956.6167:checkVisNextLimit
#@-node:ekr.20080416161551.211:p.moveToVisNext
#@-node:ekr.20091003171114.6465:Fixed contractOrGoRight
#@+node:ekr.20091007105735.6462:Fixed bug: @nosent should warn about orphan nodes
#@+node:ekr.20041005105605.154:asisWrite
def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        # Note: @asis always writes all nodes,
        # so there can be no orphan or ignored nodes.
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            # openFileForWriting calls root.setDirty() if there are errors.
            return
        for p in root.self_and_subtree():
            << Write p's headline if it starts with @@ >>
            << Write p's body >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
    except Exception:
        at.writeException(root) # Sets dirty and orphan bits.

silentWrite = asisWrite # Compatibility with old scripts.
#@+node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
s = p.h

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) > 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)
#@-node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
#@+node:ekr.20041005105605.156:<< Write p's body >>
s = p.b

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
#@-node:ekr.20041005105605.156:<< Write p's body >>
#@-node:ekr.20041005105605.154:asisWrite
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,
    nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v._bodyString)

    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
    if not toString:
        at.warnAboutOrphandAndIgnoredNodes()
#@-node:ekr.20041005105605.157:writeOpenFile
#@-node:ekr.20091007105735.6462:Fixed bug: @nosent should warn about orphan nodes
#@+node:ekr.20091016055503.6059:Color sections references in @root trees
#@+node:ekr.20090214075058.9:g.get_directives_dict (must be fast)
# The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

g_noweb_root = re.compile('<'+'<'+'*'+'>'+'>'+'=',re.MULTILINE)

def get_directives_dict(p,root=None):

    """Scan p for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    trace = False and not g.unitTesting

    if root: root_node = root[0]
    d = {}

    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat,re.MULTILINE)

    # The headline has higher precedence because it is more visible.
    for kind,s in (('body',p.h),('head',p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(0)[1:] # Omit the @
            i = m.start(0)
            if word.strip() not in d:
                j = i + 1 + len(word)
                k = g.skip_line(s,j)
                val = s[j:k].strip()
                if trace: g.trace(word,repr(val))
                d[word.strip()] = val

    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"]=0 # value not immportant
            else:
                g.es('%s= requires @root in the headline' % (
                    g.angleBrackets('*')))
            break

    if trace: g.trace('%4d' % (len(p.h) + len(p.b)),g.callers(5))
    return d
#@+node:ekr.20090214075058.10:compute_directives_re
def compute_directives_re ():

    '''Return an re pattern which will match all Leo directives.'''

    global globalDirectiveList

    aList = ['^@%s' % z for z in globalDirectiveList
                if z != 'others']

    # @others can have leading whitespace.
    aList.append(r'^\s@others')

    return '|'.join(aList)
#@-node:ekr.20090214075058.10:compute_directives_re
#@-node:ekr.20090214075058.9:g.get_directives_dict (must be fast)
#@+node:ekr.20031218072017.1385:g.findReference
# Called from the syntax coloring method that colorizes section references.

def findReference(c,name,root):

    '''Find the section definition for name.

    If a search of the descendants fails,
    and an ancestor is an @root node,
    search all the descendants of the @root node.
    '''

    for p in root.subtree():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # New in Leo 4.7: expand the search for @root trees.
    for p in root.self_and_parents():
        d = g.get_directives_dict(p)
        if 'root' in d:
            for p2 in p.subtree():
                if p2.matchHeadline(name) and not p2.isAtIgnoreNode():
                    return p2

    # g.trace("not found:",name,root)
    return c.nullPosition()
#@-node:ekr.20031218072017.1385:g.findReference
#@-node:ekr.20091016055503.6059:Color sections references in @root trees
#@+node:ekr.20091103082258.6084:Fixed bug: Sometimes 'redefining shortcut' message is backwards
#@+node:ekr.20061031131434.131:k.registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)

    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('redefining',commandName, color='red')

    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    if trace: g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName,g.callers(4))
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@-node:ekr.20061031131434.131:k.registerCommand
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: g.trace(pane,shortcut,commandName)
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print ('redefining shortcut %30s from %s to %s in %s' % (
            shortcut,
            g.choose(pane=='button',z,commandName),
            g.choose(pane=='button',commandName,z),
            pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@-node:ekr.20091103082258.6084:Fixed bug: Sometimes 'redefining shortcut' message is backwards
#@-node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090817080059.5996:Features
#@+node:ekr.20090815073537.5991:Added options to vim plugin
@nocolor-node

The setting::

    @string vim_trigger_event = icondclick2

is the default.  It opens vim when the user double-clicks the icon box.

Alternatives are::

    @string vim_trigger_event = iconclick2
    @string vim_trigger_event = select2

The former opens vim on single clicks in the icon bar.
The latter opens vim whenever a new node is selected in Leo.
#@nonl
#@-node:ekr.20090815073537.5991:Added options to vim plugin
#@+node:ekr.20090822054806.6002:Merged clean-sys-path branch
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b868abd65fb57759

I noted that leo adds all of its directories to sys.path. This is
considered "bad form" and can cause nasty surprises. I believe this is
an artifact of the old "leo-as-package" work; now that leo-as-package
stuff works well, I don't think this is needed anymore.

It's not a lot of work to fix either - it's just a matter of removing
the call to adjustSysPath in runLeo.py, and fixing some plugins. (yes,
I tried it). e.g. quicksearch.py needed this trivial change:

+++ leo/plugins/quicksearch.py  2009-08-15 20:22:20 +0000

-import qt_quicksearch
+from leo.plugins import qt_quicksearch 

What I did:

- disabled adjustSysPath.
- g.importModule now imports from 'extensions' and 'external' directories as needed.
- Modified two plugins to import from leo.plugins.
- Added __init__.py to 'extensions' folder.
#@nonl
#@-node:ekr.20090822054806.6002:Merged clean-sys-path branch
#@+node:ekr.20091007104807.6469:Added support for --version and --help
Actually, --help was supported already.
#@nonl
#@-node:ekr.20091007104807.6469:Added support for --version and --help
#@+node:ekr.20091005145253.6057:Convert @file nodes so they use file-like sentinels
@nocolor-node

Leo will now automatically write @file nodes as if they were @thin nodes
(thin-like sentinels). Leo will read @file correctly regardless of whether the
corresponding external file has file-like (legacy) or thin-like (recommended)
sentinels. Once thin-like sentinels are written, Leo deletes the problematic
tnodeList attribute in the .leo file.

**Important**: The conversion to thin-like sentinels happens *only* if Leo
actually writes the @file node, and that happens only if the @file node or one
of its descendants changes. As usual with @file nodes, writing any @file node
forces Leo to write the .leo file. This is necessary so that the tnodeList
attribute in the .leo file remains up- to-date. Thus, the conversion process
should be as safe as using @file nodes ever was, which is to say, *usually* safe
but subject to problems in a cooperative environment.

In short, I recommend that you use Shift-Ctrl-W (write-at-files-nodes)
to force the conversion of all your legacy @file nodes.  Please back
up your .leo file and all your external files first.
#@nonl
#@-node:ekr.20091005145253.6057:Convert @file nodes so they use file-like sentinels
#@+node:ekr.20091007105735.6463:Made show-fonts work with qt gui
#@-node:ekr.20091007105735.6463:Made show-fonts work with qt gui
#@+node:ekr.20091103082258.6085:Removed 'end of script' message
#@+node:ekr.20031218072017.2140:c.executeScript & helpers
def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # g.pr('*** script',script)
            try:
                p = c.p
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if args:
                    # g.trace('setting sys.argv',args)
                    sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                # g.trace('**** before',writeScriptFile)
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    ### execfile(scriptFile,d)
                    exec(script,d)
                    ### exec(compile(open(scriptFile).read(),scriptFile,'exec'),d)
                else:
                    exec(script,d)
                # g.trace('**** after')
                if 0: # This message switches panes, and can be disruptive.
                    if not script1 and not silent:
                        # Careful: the script may have changed the log tab.
                        tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                        g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143:redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@-node:ekr.20031218072017.2143:redirectScriptOutput
#@+node:EKR.20040627100424:unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@-node:EKR.20040627100424:unredirectScriptOutput
#@+node:ekr.20070115135502:writeScriptFile
def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.homeLeoDir,'scriptFile.py')                    

    # Write the file.
    try:
        f = open(path,'w')
        f.write(script)
        f.close()
    except Exception:
        g.es("Failed to write script to %s" % path)
        g.es("Check your configuration of script_file_path, currently %s" % c.config.getString('script_file_path'))
        path = None

    return path
#@nonl
#@-node:ekr.20070115135502:writeScriptFile
#@-node:ekr.20031218072017.2140:c.executeScript & helpers
#@-node:ekr.20091103082258.6085:Removed 'end of script' message
#@-node:ekr.20090817080059.5996:Features
#@+node:ekr.20091007104807.6470:Code
#@+node:ekr.20091001141621.6042:iters -> generators & code cleanup
@nocolor-node
@

What I did:

- Removed t from leoGui.leo.
- Removed t from scripts.leo.
- Renamed xTnodeY to xVnodeY in a few places.
- Removed putDescendantTnodeUas: it was redundant.
- Revised scripting chapter.

Will not do:

- Remove t from leoPlugins.leo.
  This could cause problems that I am not willing to solve.
- v.tnodeList will not change in this branch.
  This must be done in a separate branch as part of the deprecation of @file.



#@+node:ekr.20091003023754.6105:Not used
#@+node:ekr.20091001141621.6067:c.Old iterators
if not g.new_generators:

    @others
#@nonl
#@+node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
def allNodes_iter (self,copy=False):

    r = self.rootPosition()
    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p
    return r.iter_class(r, cp)

all_positions_iter = allNodes_iter
#@nonl
#@-node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
#@+node:EKR.20040529091232.1:c.all_tnodes_iter
def all_tnodes_iter (self):

    return self.rootPosition().tnodes_iter()
#@-node:EKR.20040529091232.1:c.all_tnodes_iter
#@+node:EKR.20040529091232.2:c.all_unique_tnodes_iter
def all_unique_tnodes_iter (self):

    return self.rootPosition().unique_tnodes_iter()
#@-node:EKR.20040529091232.2:c.all_unique_tnodes_iter
#@+node:EKR.20040529091232.3:c.all_vnodes_iter
def all_vnodes_iter (self):
    return self.rootPosition().vnodes_iter()
#@-node:EKR.20040529091232.3:c.all_vnodes_iter
#@+node:EKR.20040529091232.4:c.all_unique_vnodes_iter
def all_unique_vnodes_iter (self):

    return self.rootPosition().unique_vnodes_iter()
#@-node:EKR.20040529091232.4:c.all_unique_vnodes_iter
#@+node:sps.20080317144948.3:c.all_positions_with_unique_tnodes_iter
def all_positions_with_unique_tnodes_iter (self):

    r = self.rootPosition()
    return r.unique_iter_class(r, lambda p: p)
#@-node:sps.20080317144948.3:c.all_positions_with_unique_tnodes_iter
#@+node:sps.20080327174748.4:c.all_positions_with_unique_vnodes_iter
def all_positions_with_unique_vnodes_iter (self):

    r = self.rootPosition()
    return r.unique_iter_class(r, lambda p: p, lambda u: u.v)
#@-node:sps.20080327174748.4:c.all_positions_with_unique_vnodes_iter
#@-node:ekr.20091001141621.6067:c.Old iterators
#@+node:ekr.20091002072933.6096:p.Old iterators
if not g.new_generators:

    @others
#@+node:ekr.20040305172211.1:p.children_iter
class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):

    return self.children_iter_class(self,copy)
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:p.children_iter
#@+node:sps.20080331123552.3:p.iter
class iter_class:

    """Returns a list of mappings of positions in a subtree,
    possibly including the root of the subtree."""

    @others

def tnodes_iter (self):

    return self.iter_class(self, lambda p: p.v.t)

def vnodes_iter (self):

    return self.iter_class(self, lambda p: p.v)
#@+node:sps.20080331123552.1:__init__ & __iter__ (p.iter)
def __init__(self,p,mapping):

    # g.trace('p.tnodes_iter.__init','p',p)

    self.first = p.copy()
    self.p = None
    self.mapping = mapping

def __iter__(self):

    return self
#@-node:sps.20080331123552.1:__init__ & __iter__ (p.iter)
#@+node:sps.20080331123552.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None
    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.mapping(self.p)

    raise StopIteration

__next__ = next
#@nonl
#@-node:sps.20080331123552.2:next
#@-node:sps.20080331123552.3:p.iter
#@+node:ekr.20040305172855:p.parents_iter
class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)

def self_and_parents_iter(self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:p.parents_iter
#@+node:ekr.20040305173343:p.siblings_iter
class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):

    return self.siblings_iter_class(self,copy,following)

self_and_siblings_iter = siblings_iter

def following_siblings_iter (self,copy=False):

    return self.siblings_iter_class(self,copy,following=True)
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):

    # We always include p, even if following is True.

    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:p.siblings_iter
#@+node:ekr.20040305173559:p.subtree_iter
class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=False)

def self_and_subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:p.subtree_iter
#@+node:sps.20080331123552.12:p.subtree_unique_iter
class subtree_unique_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_with_unique_tnodes_iter (self,copy=False):

    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p

    return self.subtree_unique_iter_class(self,
        cp,
        lambda p: p.v.t,
        includeSelf=False)

def subtree_with_unique_vnodes_iter (self,copy=False):

    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p

    return self.subtree_unique_iter_class(self,
        cp,
        lambda p: p.v,
        includeSelf=False)
#@+node:sps.20080331123552.9:__init__ & __iter__
def __init__(self,p,mapping,unique,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.mapping = mapping
    self.unique = unique
    self.d = {}

def __iter__(self):

    return self
#@-node:sps.20080331123552.9:__init__ & __iter__
#@+node:sps.20080331123552.10:next
# moveToThreadNextUnique raises StopIteration
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.moveToThreadNextUnique()

    return self.mapping(self.p)

__next__ = next
#@nonl
#@-node:sps.20080331123552.10:next
#@+node:sps.20080331123552.11:moveToThreadNextUnique
def moveToThreadNextUnique (self):

    """Move a position to threadNext position."""

    p = self.p
    u = self.unique

    if p:
        # We've been visited
        self.d[u(p)]=True

        # First, try to find an unmarked child
        if p.v.t.children:
            p.moveToFirstChild()
            if p == self.after:
                raise StopIteration
            while p and self.d.get(u(p)):
                if p.hasNext():
                    p.moveToNext()
                else:
                    p.moveToParent()
                if p == self.after:
                    raise StopIteration

        # If we didn't find an unmarked child,
        # try to find an unmarked sibling
        if p and self.d.get(u(p)):
            while p.hasNext():
                p.moveToNext()
                if p == self.after:
                    raise StopIteration
                if not self.d.get(u(p)):
                    break

        # If we didn't find an unmarked sibling,
        # find a parent with an unmarked sibling
        if p and self.d.get(u(p)):
            p.moveToParent()
            # if p.equal(self.after):
            if p == self.after:
                raise StopIteration
            while p:
                while p.hasNext():
                    p.moveToNext()
                    if p == self.after:
                        raise StopIteration
                    if not self.d.get(u(p)):
                        break
                # if we run out of siblings, go to parent
                if self.d.get(u(p)):
                    p.moveToParent()
                    if p == self.after:
                        raise StopIteration
                else:
                    break # found
            # At this point, either (not p.d[p.v.t]) and found
            # or (not p) and we're finished

    return p 
#@-node:sps.20080331123552.11:moveToThreadNextUnique
#@-node:sps.20080331123552.12:p.subtree_unique_iter
#@+node:sps.20080331123552.8:p.unique_iter
class unique_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def unique_tnodes_iter (self):

    return self.unique_iter_class(self, lambda p: p.v.t)

def unique_vnodes_iter (self):

    return self.unique_iter_class(self, lambda p: p.v)
#@+node:sps.20080331123552.4:__init__ & __iter__ (p.unique_tnodes_iter)
def __init__(self,p,mapping,unique=lambda p: p.v.t):

    # g.trace('p.unique_tnodes_iter.__init','p',p,)

    self.d = {}
    self.first = p.copy()
    self.p = None
    self.mapping = mapping
    self.unique=unique

def __iter__(self):

    return self
#@-node:sps.20080331123552.4:__init__ & __iter__ (p.unique_tnodes_iter)
#@+node:sps.20080331123552.5:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.moveToThreadNextUnique()

    if self.p:
        return self.mapping(self.p)

    raise StopIteration

__next__ = next
#@-node:sps.20080331123552.5:next
#@+node:sps.20080331123552.7:moveToThreadNextUnique
def moveToThreadNextUnique (self):

    """Move a position to threadNext position."""

    p = self.p
    u = self.unique

    self_d_get = self.d.get
    if p:
        # We've been visited
        self.d[u(p)]=True

        # First, try to find an unmarked child
        if p.v.t.children:
            p.moveToFirstChild()
            while p and self_d_get(u(p)):
                if p.hasNext():
                    p.moveToNext()
                else:
                    p.moveToParent()

        # If we didn't find an unmarked child,
        # try to find an unmarked sibling
        if p and self_d_get(u(p)):
            while p.hasNext():
                p.moveToNext()
                if not self_d_get(u(p)):
                    break

        # If we didn't find an unmarked sibling,
        # find a parent with an unmarked sibling
        if p and self_d_get(u(p)):
            p.moveToParent()
            while p:
                while p.hasNext():
                    p.moveToNext()
                    if not self_d_get(u(p)):
                        break
                # if we run out of siblings, go to parent
                if self_d_get(u(p)):
                    p.moveToParent()
                else:
                    break # found
            # At this point, either (not p.d[p.v.t]) and found
            # or (not p) and we're finished

    return p 
#@-node:sps.20080331123552.7:moveToThreadNextUnique
#@-node:sps.20080331123552.8:p.unique_iter
#@-node:ekr.20091002072933.6096:p.Old iterators
#@+node:ekr.20031218072017.2009:newVnode (fileCommands) (not used)
def newVnode(self,index):

    c = self.c

    v = leoNodes.vnode(context=c)

    if index in self.tnodesDict:
        g.es("bad tnode index:",str(index),"using empty text.")
        return v
    else:
        # Create the tnode.
        # Use the _original_ index as the key in tnodesDict.
        self.tnodesDict[index] = v

        if not g.isString(index):
            g.es("newVnode: unexpected index type:",type(index),index,color="red")

        # Convert any pre-4.1 index to a gnx.
        junk,theTime,junk = gnx = g.app.nodeIndices.scanGnx(index,0)
        if theTime != None:
            v.fileIndex = gnx

        return v
#@-node:ekr.20031218072017.2009:newVnode (fileCommands) (not used)
#@-node:ekr.20091003023754.6105:Not used
#@+node:ekr.20091001141621.6061:c.generators
#@+node:ekr.20091001141621.6043:c.all_nodes & all_unique_nodes
def all_nodes(self):
    c = self
    for p in c.all_positions():
        yield p.v
    raise StopIteration

def all_unique_nodes(self):
    c = self
    for p in c.all_unique_positions():
        yield p.v
    raise StopIteration

# Compatibility with old code.
all_tnodes_iter = all_nodes
all_vnodes_iter = all_nodes
all_unique_tnodes_iter = all_unique_nodes
all_unique_vnodes_iter = all_unique_nodes
#@-node:ekr.20091001141621.6043:c.all_nodes & all_unique_nodes
#@+node:ekr.20091001141621.6062:c.all_unique_positions
def all_unique_positions(self):
    c = self
    p = c.rootPosition() # Make one copy.
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p
            p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
all_positions_with_unique_tnodes_iter = all_unique_positions
all_positions_with_unique_vnodes_iter = all_unique_positions
#@nonl
#@-node:ekr.20091001141621.6062:c.all_unique_positions
#@+node:ekr.20091001141621.6044:c.all_positions
def all_positions (self):
    c = self
    p = c.rootPosition() # Make one copy.
    while p:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
all_positions_iter = all_positions
allNodes_iter = all_positions
#@-node:ekr.20091001141621.6044:c.all_positions
#@-node:ekr.20091001141621.6061:c.generators
#@+node:ekr.20091001141621.6060:p.generators
#@+node:ekr.20091001141621.6055:p.children
def children(self):

    '''Return all children of p.'''

    p = self
    p = p.firstChild()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
children_iter = children
#@-node:ekr.20091001141621.6055:p.children
#@+node:ekr.20091002083910.6102:p.following_siblings
def following_siblings(self):
    '''
    Return all siblings that follow p, not including p.
    '''

    p = self
    p = p.copy() # Always include the original node.
    p = p.next()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
following_siblings_iter = following_siblings
#@-node:ekr.20091002083910.6102:p.following_siblings
#@+node:ekr.20091002083910.6104:p.nodes
def nodes (self):

    p = self
    p = p.copy()
    while p:
        yield p.v
        p.moveToThreadNext()

# Compatibility with old code.
tnodes_iter = nodes
vnodes_iter = nodes
#@-node:ekr.20091002083910.6104:p.nodes
#@+node:ekr.20091001141621.6058:p.parents
def parents(self):

    '''Return all parents of p.'''

    p = self
    p = p.parent()
    while p:
        yield p
        p.moveToParent()
    raise StopIteration

# Compatibility with old code.
parents_iter = parents
#@-node:ekr.20091001141621.6058:p.parents
#@+node:ekr.20091002083910.6099:p.self_and_parents
def self_and_parents(self):

    '''Return p and all parents of p.'''

    p = self
    p = p.copy()
    while p:
        yield p
        p.moveToParent()
    raise StopIteration

# Compatibility with old code.
self_and_parents_iter = self_and_parents
#@-node:ekr.20091002083910.6099:p.self_and_parents
#@+node:ekr.20091001141621.6057:p.self_and_siblings
def self_and_siblings(self):
    '''Return all siblings of p including p.
    '''

    p = self
    p = p.copy()
    while p.hasBack():
        p.moveToBack()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
self_and_siblings_iter = self_and_siblings
#@nonl
#@-node:ekr.20091001141621.6057:p.self_and_siblings
#@+node:ekr.20091001141621.6066:p.self_and_subtree
def self_and_subtree(self):

    '''Return p's entire subtree, including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
self_and_subtree_iter = self_and_subtree
#@-node:ekr.20091001141621.6066:p.self_and_subtree
#@+node:ekr.20091001141621.6056:p.subtree
def subtree(self):

    '''Return all descendants of p, not including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
subtree_iter = subtree
#@-node:ekr.20091001141621.6056:p.subtree
#@+node:ekr.20091002083910.6105:p.unique_nodes
def unique_nodes (self):

    p = self
    p = p.copy()
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p.v
            p.moveToThreadNext()

# Compatibility with old code.
unique_tnodes_iter = unique_nodes
unique_vnodes_iter = unique_nodes
#@-node:ekr.20091002083910.6105:p.unique_nodes
#@+node:ekr.20091002083910.6103:p.unique_subtree
def unique_subtree (self):
    '''Return unique positions in p's entire subtree, including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    seen = set()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p
            p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
subtree_with_unique_tnodes_iter = unique_subtree
subtree_with_unique_vnodes_iter = unique_subtree
#@-node:ekr.20091002083910.6103:p.unique_subtree
#@-node:ekr.20091001141621.6060:p.generators
#@+node:tbrown.20080119085249.1:setIconList & helpers
def setIconList(self, p, l):
    """Set list of icons for position p to l"""

    trace = False and not g.unitTesting

    current = self.getIconList(p)
    if not l and not current: return  # nothing to do
    lHash = ''.join([self.dHash(i) for i in l])
    cHash = ''.join([self.dHash(i) for i in current])
    # if trace: g.trace('lHash:',lHash)
    # if trace: g.trace('cHash:',cHash)
    if lHash == cHash:
        # no difference between original and current list of dictionaries
        return

    if trace: g.trace(l)

    self._setIconListHelper(p, l, p.v)

#@+node:ekr.20090701125429.6012:_setIconListHelper
def _setIconListHelper(self, p, subl, uaLoc):
    """icon setting code common between v and t nodes

    p - postion
    subl - list of icons for the v or t node
    uaLoc - the v or t node"""

    trace = False and not g.unitTesting

    if subl: # Update the uA.
        if not hasattr(uaLoc,'unknownAttributes'):
            uaLoc.unknownAttributes = {}
        uaLoc.unknownAttributes['icons'] = list(subl)
        # g.es((p.h,uaLoc.unknownAttributes['icons']))
        uaLoc.unknownAttributes["lineYOffset"] = 3
        uaLoc._p_changed = 1
        p.setDirty()
        if trace: g.trace('uA',uaLoc.u,uaLoc)
    else: # delete the uA.
        if hasattr(uaLoc,'unknownAttributes'):
            if 'icons' in uaLoc.unknownAttributes:
                del uaLoc.unknownAttributes['icons']
                uaLoc.unknownAttributes["lineYOffset"] = 0
                uaLoc._p_changed = 1
                p.setDirty()
        if trace: g.trace('del uA[icons]',uaLoc)
#@-node:ekr.20090701125429.6012:_setIconListHelper
#@-node:tbrown.20080119085249.1:setIconList & helpers
#@+node:ekr.20080805071954.1:putDescendentTnodeUas
def putDescendentTnodeUas (self,p):

    ### In the one-node world, there are no such things as independent tnodes.
    g.trace('*** ERROR: should not be called')
    return

    trace = False
    if trace: g.trace(p.h)

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = [] ; aList = []
    for p2 in p.self_and_subtree():
        v = p2.v
        if hasattr(v,"unknownAttributes"):
            if v not in tnodes :
                # g.trace(p2.h,v)
                tnodes.append(v)
                aList.append((p2.copy(),v),)

    # Create a list of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create s, an enclosing dict to hold all the inner dicts.
    d = {}
    nodeIndices = g.app.nodeIndices
    for v,d2 in aList:
        # Could be eliminated.
        # New in Leo 4.4.8.  Assign v.fileIndex here as needed.
        if not v.fileIndex:
            v.fileIndex = g.app.nodeIndices.getNewIndex()
        gnx = nodeIndices.toString(v.fileIndex)
        d[gnx]=d2

    if trace: g.trace(g.dictToString(d))

    # Pickle and hexlify d.
    return d and self.pickle(
        torv=p.v,val=d,tag="descendentTnodeUnknownAttributes") or ''
#@-node:ekr.20080805071954.1:putDescendentTnodeUas
#@-node:ekr.20091001141621.6042:iters -> generators & code cleanup
#@-node:ekr.20091007104807.6470:Code
#@-node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20091203060018.6100:leo-3k
@nocolor-node

Done:
- (mostly) Make the 2to3 changes.
- Use something better than repr to create item hash in qtGui.
#@nonl
#@+node:ekr.20091206180115.6235:Changed
#@+node:ekr.20090521175848.5881:<< define the nullObject class >>
# From the Python cookbook, recipe 5.23

class nullObject:

    """An object that does nothing, and does it very well."""

    def __init__   (self,*args,**keys): pass
    def __call__   (self,*args,**keys): return self
    # def __len__    (self): return 0 # Debatable.
    def __repr__   (self): return "nullObject"
    def __str__    (self): return "nullObject"
    if isPython3:
        def __bool__(self): return 0
    else:
        def __nonzero__(self): return 0
    def __delattr__(self,attr):     return None ### self
    def __getattr__(self,attr):     return None ### self
    def __setattr__(self,attr,val): return None ### self
#@-node:ekr.20090521175848.5881:<< define the nullObject class >>
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if not fileName and not script:
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    trace = False
    if trace: print('completeFileName',fileName)

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)

    # Bug fix: don't add .leo to existing files.
    if g.os_path_exists(fileName):
        pass # use the fileName as is.
    elif ext != '.leo':
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    if trace: print('completeFileName',fileName)

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.doubleClickFlag = False
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui
self.ipythonController = None # Set only by the ipython plugin.

# Interlock to prevent setting c.changed when switching chapters.
c.suppressHeadChanged = False

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None
self.timeStampDict = {} # New in Leo 4.6.

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False

# Default Tangle options
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = '' # Must always be a string.
self.navTime = None

# Controller-specific pickleshare db at /foo/bar.leo_db/

import leo.external.pickleshare
import hashlib
pth, bname = os.path.split(self.mFileName)

if pth and bname and g.enableDB:
    fn = self.mFileName.lower()
    fn = g.toEncodedString(fn,'utf-8')
    dbdirname = g.app.homeLeoDir + "/db/" + bname + "_" + hashlib.md5(fn).hexdigest()
    # use compressed pickles (handy for @thin caches)
    self.db = leo.external.pickleshare.PickleShareDB(dbdirname, protocol='picklez')

else:
    self.db = {}
    # if not g.app.silentMode and not g.unitTesting:
        # print('caching disabled')
#@-node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
#@+node:ekr.20090502071837.65:writeToDocutils (sets argv) & helper
def writeToDocutils (self,s):

    '''Send s to docutils using the writer implied by self.ext and return the result.'''

    trace = True and not g.unitTesting
    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }

    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()

    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.es_print('unknown docutils extension: %s' % (self.ext),color='red')
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if self.getOption('stylesheet_embed') == False:
        rel_path = g.os_path_join(
            rel_stylesheet_path,self.getOption('stylesheet_name'))
        overrides['stylesheet'] = rel_path
        overrides['stylesheet_path'] = None
        overrides['embed_stylesheet'] = None
    elif g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.es_print('stylesheet not found: %s' % (path),color='red')
    else:
        g.es_print('stylesheet not found\n',path,color='red')
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        if trace: g.trace('overrides',overrides)
        result = None # Ensure that result is defined.
        result = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError as error:
        # g.es_print('Docutils error (%s):' % (
            # error.__class__.__name__),color='red')
        g.es_print('Docutils error:',color='red')
        g.es_print(error,color='blue')
    except Exception:
        g.es_print('Unexpected docutils exception')
        g.es_exception()
    return result
#@+node:ekr.20090502071837.66:handleMissingStyleSheetArgs
def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    trace = False and not g.unitTesting
    force = False

    if force:
        # See http://docutils.sourceforge.net/docs/user/config.html#documentclass
        return {'documentclass':'report', 'documentoptions':'english,12pt,lettersize'}

    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return {}

    # Handle argument lists such as this:
    # --language=en,--documentclass=report,--documentoptions=[english,12pt,lettersize]
    d = {}
    while s:
        s = s.strip()
        if not s.startswith('--'): break
        s = s[2:] ; i = s.find('=')
        if i == -1: break
        key = s[:i] ; s = s[i+1:] ; i = s.find('--')
        if i == -1:
            val = s ; s = ''
        else:
            val = s[:i] ; s = s[i:]
        # g.trace('s',repr(s))
        if val.endswith(','): val = val[:-1]
        if val.startswith('[') and val.endswith(']'): val = val[1:-1]
        val = val.strip()
        if not val: val = '1'
        d[str(key)] = str(val)

    if trace: g.trace(d)
    return d

    # if args.find(',') == -1:
        # args = [args]
    # else:
        # args = args.split(',')

    # for arg in args:
        # data = arg.split('=')
        # if len(data) == 1:
            # key = data[0]
            # d[str(key)] = "1" # New in Leo 4.7: empty arg defaults to "1".
        # elif len(data) == 2:
            # key,value = data
            # value = value.strip()
            # if value.startswith('[') and value.endswith(']'):
                # value = value[1:-1]
            # d[str(key)] = str(value)
        # else:
            # g.es_print('bad option: %s' % s,color='red')
            # break

    # return d
#@-node:ekr.20090502071837.66:handleMissingStyleSheetArgs
#@-node:ekr.20090502071837.65:writeToDocutils (sets argv) & helper
#@+node:bob.20071231111744.2:get / getColor
def getColor(name, default=None):
    """ Translate a named color into #rrggbb' format.

    if 'name' is not a string it is returned unchanged.

    If 'name' is already in '#rrggbb' format then it is returned unchanged.

    If 'name' is not in global_color_database then getColor(default, None)
    is called and that result returned.


    """
    if g.isPython3:
        if not isinstance(name,str):
            return name
    else:
        if not isinstance(name,basestring):
            return name

    #g.trace(name, default)

    if name[0] == '#':
        return name

    name = name.replace(' ', '').lower()

    if name in leo_color_database:
        return leo_color_database[name]

    if default:
        return getColor(default, default=None)

    return None

get = getColor
#@nonl
#@-node:bob.20071231111744.2:get / getColor
#@+node:ekr.20080710101653.1:g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    nl = g.choose(newline,'\n','')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.
    if g.isPython3:
        s2 = s
    else:
        s2 = g.toEncodedString(s,encoding)

    if app.logInited:
        try: # We can't use any print keyword args in Python 2.x!
            sys.stdout.write(s2+nl)
        except Exception:
            if not g.pr_warning_given:
                g.pr_warning_given = True
                print('unexpected Exception in g.pr')
                print('make sure your sitecustomize.py contains::')
                print('    sys.setdefaultencoding("utf-8")')
                g.es_exception()
                g.trace(g.callers())
            s2 = s.encode('ascii',"replace")
            sys.stdout.write(s2+nl)
    else:
        app.printWaiting.append(s2)
#@-node:ekr.20080710101653.1:g.pr
#@+node:ville.20090606150238.6351:_contentHashFile (atFile)
def _contentHashFile(self, p, content):
    c = self.c
    m = hashlib.md5()
    # note that we also consider the headline in hash, to separate @auto foo.py from @thin foo.py
    if g.isPython3:
        m.update(g.toEncodedString(p.h,encoding='utf-8'))
        m.update(g.toEncodedString(content,encoding='utf-8'))
    else:
        m.update(p.h)
        m.update(content)
    return "fcache/" + m.hexdigest()




#@-node:ville.20090606150238.6351:_contentHashFile (atFile)
#@+node:ekr.20090520055433.5945:g.openWithFileName & helpers
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    trace = False and not g.unitTesting

    if not fileName: return False, None
    isLeo,fn,relFn = g.mungeFileName(fileName)

    # Return if the file is already open.
    c = g.findOpenFile(fn)
    if c: return True,c.frame

    # Open the file.
    if isLeo:
        c,f = g.openWithFileNameHelper(old_c,gui,fn,relFn)
    else:
        c,f = g.openWrapperLeoFile(old_c,fn,gui),None
    if not c: return False,None

    # Init the open file.
    assert c.frame and c.frame.c == c
    c.frame.log.enable(enableLog)
    g.app.writeWaitingLog(c,forceLog=not g.app.initing)
    ok = g.handleOpenHooks(c,old_c,gui,fn,f,readAtFileNodesFlag)
    if not ok: return False,None
    g.createMenu(c,fn)
    g.finishOpen(c)
    return True,c.frame
#@+node:ekr.20090520055433.5951:g.createMenu
def createMenu(c,fileName=None):

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.

    if not g.doHook("menu1",c=c,p=c.p,v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        c.updateRecentFiles(fileName)
        g.doHook("menu2",c=c,p=c.p,v=c.p)
        g.doHook("after-create-leo-frame",c=c)
#@-node:ekr.20090520055433.5951:g.createMenu
#@+node:ekr.20090520055433.5948:g.findOpenFile
def findOpenFile(fileName):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if munge(fileName) == munge(c.mFileName):
            frame.bringToFront()
            c.setLog()
            c.outerUpdate()
            return c
    return None
#@-node:ekr.20090520055433.5948:g.findOpenFile
#@+node:ekr.20090520055433.5952:g.finishOpen
def finishOpen(c):

    k = c.k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()
    c.frame.initCompleteHint()
    return True
#@-node:ekr.20090520055433.5952:g.finishOpen
#@+node:ekr.20090520055433.5950:g.handleOpenHooks
def handleOpenHooks(c,old_c,gui,fileName,theFile,readAtFileNodesFlag):

    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if theFile:
            app.lockLog()
            ok = c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(c.frame)
                return False
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)

    # Bug fix in 4.4.
    if not c.openDirectory:
        c.openDirectory = c.frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    return True
#@nonl
#@-node:ekr.20090520055433.5950:g.handleOpenHooks
#@+node:ekr.20090520055433.5954:g.mungeFileName
def mungeFileName(fileName):

    '''Create a full, normalized, Unicode path name, preserving case.'''

    relFn = g.os_path_normpath(fileName)
    fn = g.os_path_finalize(fileName)

    isZipped = fn and zipfile.is_zipfile(fn)
    isLeo = isZipped or fn.endswith('.leo')

    return isLeo,fn,relFn
#@-node:ekr.20090520055433.5954:g.mungeFileName
#@+node:ekr.20090520055433.5946:g.openWithFileNameHelper
def openWithFileNameHelper(old_c,gui,fileName,relativeFileName):

    if old_c: g.preRead(fileName)
    g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile:
        return None,None

    # This call will take 3/4 sec. to open a file from the leoBridge.
    # This is due to imports in c.__init__
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)

    c.isZipped = isZipped
    return c,theFile
#@+node:ekr.20090520055433.5949:preRead
def preRead(fileName):

    '''Read the file for the first time,
    setting the setting for a later call to finishCreate.
    '''

    c = g.app.config.openSettingsFile(fileName)
    if c:
        g.app.config.updateSettings(c,localFlag=True)
#@-node:ekr.20090520055433.5949:preRead
#@-node:ekr.20090520055433.5946:g.openWithFileNameHelper
#@+node:ekr.20080921154026.1:g.openWrapperLeoFile
def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''

    # This code is similar to c.new, but different enough to be separate.
    if not g.os_path_exists(fileName):
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    if 0: # This causes duplicate common buttons.
        g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    if True: # Just read the file into the node.
        try:
            fileName = g.os_path_finalize(fileName)
            f = open(fileName)
            s = f.read()
            f.close()
        except IOError:
            g.es_print("can not open: ",fileName,color='red')
            return None
        p = c.rootPosition()
        if p:
            p.setHeadString('@edit %s' % fileName)
            p.setBodyString(s)
            c.selectPosition(p)
    else:  # Import the file into the new outline.
        junk,ext = g.os_path_splitext(fileName)
        p = c.p
        p = c.importCommands.createOutline(fileName,parent=p,atAuto=False,ext=ext)
        c.setCurrentPosition(p)
        c.moveOutlineLeft()
        p = c.p
        c.setCurrentPosition(p.back())
        c.deleteOutline(op_name=None)
        p = c.p
        p.expand()

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(True) # Mark the outline dirty.
    return c
#@-node:ekr.20080921154026.1:g.openWrapperLeoFile
#@-node:ekr.20090520055433.5945:g.openWithFileName & helpers
#@+node:ville.20090620122043.6275:app.setGlobalDb
def setGlobalDb(self):
    """ Create global pickleshare db

    Usable by::

        g.app.db['hello'] = [1,2,5]

    """

    trace = False
    if trace: g.trace('g.enableDB',g.enableDB)

    if g.enableDB:
        dbdirname = self.homeLeoDir + "/db/global"
        self.db = leo.external.pickleshare.PickleShareDB(dbdirname, protocol='picklez')
        if trace: g.trace(self.db,dbdirname)
    else:
        self.db = {}
#@-node:ville.20090620122043.6275:app.setGlobalDb
#@+node:ville.20090606131405.6362:writeCachedTree (atFile)
def writeCachedTree(self, p, cachefile):

    trace = False and not g.unitTesting
    c = self.c

    if not g.enableDB:
        if trace: g.trace('cache disabled')
    elif cachefile in c.db:
        if trace: g.trace('already cached')
    else:
        if trace: g.trace('caching ',p.h)
        #tree = g.tree_at_position(p)
        #c.db[cachefile] = tree
        c.db[cachefile] = p.makeCacheList()
#@nonl
#@-node:ville.20090606131405.6362:writeCachedTree (atFile)
#@+node:ekr.20061003093021:getSaxUa
def getSaxUa(self,attr,val,kind=None): # Kind is for unit testing.

    """Parse an unknown attribute in a <v> or <t> element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        val = str(val)
    except UnicodeError:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()

    # g.trace(attr,repr(val))

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return val

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except Exception:
        # Python 2.x throws TypeError
        # Python 3.x throws binascii.Error
        # Assume that Leo 4.1 wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw','unit test failed: kind=' % repr(kind)
        else:
            g.trace('can not unhexlify %s=%s' % (attr,val))
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError,AttributeError):
        g.trace('can not unpickle %s=%s' % (
            attr,val),g.callers(3))
        return val
#@+node:ekr.20090702072557.6495:@test getSaxUa
if g.unitTesting:

    c,p = g.getTestVars()

    expectedIconDictList = [
    {
        'on': 'tnode',
        'where': 'beforeHeadline',
        'yoffset': 0,
        # 'file': u'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\add.png',
        'file': 'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\add.png',
        'xpad': 1,
        'type': 'file',
        'xoffset': 2,
        # 'relPath': u'Tango\\16x16\\actions\\add.png',
        'relPath': 'Tango\\16x16\\actions\\add.png',
    },
    {
        'on': 'tnode',
        'where': 'beforeHeadline',
        'yoffset': 0,
        # 'file': u'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\bottom.png',
        'file': 'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\bottom.png',
        'xpad': 1,
        'type': 'file',
        'xoffset': 2,
        # 'relPath': u'Tango\\16x16\\actions\\bottom.png',
        'relPath': 'Tango\\16x16\\actions\\bottom.png',
    }]
    table = (
('tx','raw',None,"ekr.20090701133940.1767"),
('lineYOffset',None,3,"4b032e"),
# A real icon
('icons',None,expectedIconDictList,
"5d7100287d71012855026f6e71025505746e6f6465710355047479\
70657104550466696c6571055507796f666673657471064b006805583700000\
0433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e\
676f5c31367831365c616374696f6e735c6164642e706e67710755047870616\
471084b01550577686572657109550e6265666f7265486561646c696e65710a\
5507786f6666736574710b4b02550772656c50617468710c581b00000054616\
e676f5c31367831365c616374696f6e735c6164642e706e67710d757d710e28\
55026f6e710f68035504747970657110550466696c6571115507796f6666736\
57471124b006811583a000000433a5c6c656f2e7265706f5c7472756e6b5c6c\
656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c626f7\
4746f6d2e706e67711355047870616471144b01550577686572657115550e62\
65666f7265486561646c696e6571165507786f666673657471174b025507726\
56c506174687118581e00000054616e676f5c31367831365c616374696f6e73\
5c626f74746f6d2e706e67711975652e"),
)
    for attr,kind,expected,val in table:
        result = c.fileCommands.getSaxUa(attr,val,kind=kind)
        if expected is None: expected = val
        assert expected==result,'expected %s got %s' % (
            expected,result)
#@nonl
#@-node:ekr.20090702072557.6495:@test getSaxUa
#@-node:ekr.20061003093021:getSaxUa
#@+node:ekr.20041005105605.204:os
def os (self,s):

    """Write a string to the output stream.

    All output produced by leoAtFile module goes here."""

    trace = False
    at = self ; tag = self.underindentEscapeString
    f = at.outputFile

    if s and f:
        try:
            if trace: g.trace(repr(s))
            if s.startswith(tag):
                junk,s = self.parseUnderindentTag(s)
            # Bug fix: this must be done last.
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            f.write(s)
        except Exception:
            at.exception("exception writing:" + s)
#@-node:ekr.20041005105605.204:os
#@+node:ekr.20031218072017.1386:g.getOutputNewline
def getOutputNewline (c=None,name=None):

    '''Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''

    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    # g.trace(c,name,c.config.output_newline,'returns',repr(s))

    if g.isPython3:
        s = str(s)
    return s
#@-node:ekr.20031218072017.1386:g.getOutputNewline
#@+node:ekr.20031218072017.3198:computeLeadingWhitespace
# Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace (width, tab_width):

    if width <= 0:
        return ""
    if tab_width > 1:
        tabs   = int(width / tab_width)
        blanks = int(width % tab_width)
        return ('\t' * tabs) + (' ' * blanks)
    else: # 7/3/02: negative tab width always gets converted to blanks.
        return (' ' * width)
#@-node:ekr.20031218072017.3198:computeLeadingWhitespace
#@+node:ekr.20091206161352.6232:g.u
def u(s,encoding='utf-8'):
    if g.isPython3:
        return str(s,encoding)
    else:
        return unicode(s,encoding)
#@nonl
#@-node:ekr.20091206161352.6232:g.u
#@+node:ekr.20050920084036.118:sortLines commands
def reverseSortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True,reverse=True)

def reverseSortLines(self,event):
    return self.sortLines(event,reverse=True)

def sortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True)

def sortLines (self,event,ignoreCase=False,reverse=False):

    '''Sort lines of the selected text by comparing the entire text of a line.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not self._chckSel(event): return

    undoType = g.choose(reverse,'reverse-sort-lines','sort-lines')
    self.beginCommand(undoType=undoType)
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        s2 = s[i:j]
        if not s2.endswith('\n'): s2 = s2+'\n'
        aList = g.splitLines(s2)
        if ignoreCase:
            def lower(s): return s.lower()
            aList.sort(key=lower)
        else:
            aList.sort()
        if reverse:
            aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.118:sortLines commands
#@-node:ekr.20091206180115.6235:Changed
#@+node:ekr.20091203060018.6067:2to3 output
#@+node:ekr.20091203165343.6144:2to3 args
Available transformations for the -f/--fix option:
apply
basestring
buffer
callable
dict
except
exec
execfile
filter
funcattrs
future
getcwdu
has_key
idioms
import
imports
imports2
input
intern
isinstance
itertools
itertools_imports
long
map
metaclass
methodattrs
ne
next
nonzero
numliterals
paren
### print
raise
raw_input
reduce
renames
repr
set_literal
standarderror
sys_exc
throw
tuple_params
types
unicode
urllib
ws_comma
xrange
xreadlines
zip
#@-node:ekr.20091203165343.6144:2to3 args
#@+node:ekr.20091203165343.6146:Run2
@nocolor-node

--- leo/core/leoApp.py (original)
+++ leo/core/leoApp.py (refactored)
@@ -667,7 +667,7 @@
         if g.app.gui is None:
             # tkinter broken/doesn't exist. Print error
             print("Please enter LeoID (e.g. your username, 'johndoe'...)")
-            leoid = raw_input('LeoID: ')
+            leoid = input('LeoID: ')

         else:
             leoid = g.app.gui.runAskLeoIDDialog()


--- leo/core/leoAtFile.py (original)
+++ leo/core/leoAtFile.py (refactored)
@@ -335,7 +335,7 @@
             if g.isPython3:
                 self.targetFileName = self.outputFileName = ''
             else:
-                self.targetFileName = self.outputFileName = unicode('')
+                self.targetFileName = self.outputFileName = str('')
#@verbatim
         #@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@verbatim
         #@nl

@@ -1837,7 +1837,7 @@

         tag = "@first"
         foundAtFirstYet = 0
-        outRange = range(len(out))
+        outRange = list(range(len(out)))
         j = 0
         for k in outRange:
             # skip leading whitespace lines
@@ -1865,7 +1865,7 @@

         tag = "@last"
         foundAtLastYet = 0
-        outRange = range(-1,-len(out),-1)
+        outRange = list(range(-1,-len(out),-1))
         j = -1
         for k in outRange:
             # skip trailing whitespace lines

@@ -4095,7 +4095,7 @@
             if g.isPython3:
                 at.outputFileName = ''
             else:
-                at.outputFileName = unicode('')
+                at.outputFileName = str('')

             at.shortFileName = ''
             at.targetFileName = None

--- leo/core/leoChapters.py (original)
+++ leo/core/leoChapters.py (refactored)
@@ -82,7 +82,7 @@
         state = k.getState(tag)

         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             prefix = 'Clone node to chapter: '
             k.setLabelBlue(prefix,protect=True)
             k.getArg(event,tag,1,self.cloneNodeToChapter,prefix=prefix,tabList=names)
@@ -147,7 +147,7 @@
             return

         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             k.setLabelBlue('Convert node to chapter: ',protect=True)
             k.getArg(event,tag,1,self.convertNodeToChapter,tabList=names)
         else:
@@ -167,7 +167,7 @@
         state = k.getState(tag)

         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             prefix = 'Copy node to chapter: '
             k.setLabelBlue(prefix,protect=True)
             k.getArg(event,tag,1,self.copyNodeToChapter,prefix=prefix,tabList=names)
@@ -216,7 +216,7 @@
         state = k.getState(tag)

         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             k.setLabelBlue('Create chapter: ',protect=True)
             k.getArg(event,tag,1,self.createChapter,tabList=names)
         else:
@@ -275,7 +275,7 @@
             return

         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             k.setLabelBlue('Create chapter from node: ',protect=True)
             k.getArg(event,tag,1,self.createChapterFromNode,tabList=names)
         else:
@@ -295,7 +295,7 @@
         state = k.getState(tag)

         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             prefix = 'Move node to chapter: '
             k.setLabelBlue(prefix,protect=True)
             k.getArg(event,tag,1,self.moveNodeToChapter,prefix=prefix,tabList=names)
@@ -402,7 +402,7 @@
         state = k.getState(tag)

         if state == 0 and not newName:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             prefix = 'Rename this chapter: '
             k.setLabelBlue(prefix,protect=True)
             k.getArg(event,tag,1,self.renameChapter,prefix=prefix,tabList=names)
@@ -433,7 +433,7 @@
         state = k.getState(tag)

         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             g.es('Chapters:\n' + '\n'.join(names))
             prefix = 'Select chapter: '
             k.setLabelBlue(prefix,protect=True)


--- leo/core/leoColor.py (original)
+++ leo/core/leoColor.py (refactored)

@@ -2060,7 +2060,7 @@
                             w.tag_config(key,font=font)
                             break
                 else: # Neither the general setting nor the language-specific setting exists.
-                    if len(self.fonts.keys()) > 1: # Restore the default font.
+                    if len(list(self.fonts.keys())) > 1: # Restore the default font.
                         # g.trace('default',key)
                         w.tag_config(key,font=defaultBodyfont)
#@verbatim
             #@nonl

--- leo/core/leoCommands.py (original)
+++ leo/core/leoCommands.py (refactored)
@@ -178,7 +178,7 @@

             # copy global commands to this controller    

-            for name,f in g.app.global_commands_dict.items():
+            for name,f in list(g.app.global_commands_dict.items()):
                 k.registerCommand(name,shortcut = None, func = f, pane='all',verbose=False)        

             k.finishCreate()
@@ -454,7 +454,7 @@
             m = re.finditer(pat, p.b)
             t1,t2 = itertools.tee(m,2)
             try:
-                first = t1.next()
+                first = next(t1)
             except StopIteration:
                 continue
             pc = p.copy()
@@ -851,7 +851,7 @@
                     # This clause by Jim Sizelove.
                     elif openType == "subprocess.Popen":
                         use_shell = True
-                        if isinstance(arg, basestring):
+                        if isinstance(arg, str):
                             vtuple = arg + " " + path
                         elif isinstance(arg, (list, tuple)):
                             vtuple = arg[:]
@@ -866,7 +866,7 @@
                                 g.es_exception()
                         else:
                             g.trace('Can not import subprocess.  Skipping: "%s"' % command)
-                    elif callable(openType):
+                    elif hasattr(openType, '__call__'):
                         # Invoke openWith like this:
                         # c.openWith(data=[f,None,None])
                         # f will be called with one arg, the filename
@@ -1806,7 +1806,7 @@
                     # g.trace('**** before',writeScriptFile)
                     if writeScriptFile:
                         scriptFile = self.writeScriptFile(script)
-                        execfile(scriptFile,d)
+                        exec(compile(open(scriptFile).read(), scriptFile, 'exec'),d)
                     else:
                         exec(script,d)
                     # g.trace('**** after')

--- leo/core/leoConfig.py (original)
+++ leo/core/leoConfig.py (refactored)

@@ -1922,7 +1922,7 @@
         if 0: # Good trace.
             if localFlag:
                 g.trace(c.fileName())
-                g.trace(d and d.keys())
+                g.trace(d and list(d.keys()))
#@verbatim
     #@-node:ekr.20051013161232:updateSettings
#@verbatim
     #@-node:ekr.20041120064303:readSettingsFiles & helpers (g.app.config)
#@verbatim
     #@+node:ekr.20041117083857.1:g.app.config.readSettings

--- leo/core/leoDebugger.py (original)
+++ leo/core/leoDebugger.py (refactored)
@@ -4,7 +4,7 @@

#@verbatim
 #@<< imports >>
#@verbatim
 #@+node:ekr.20060307120420:<< imports >>
-import leoGlobals as g
+from . import leoGlobals as g
 import pdb
 import sys
#@verbatim
 #@nonl


--- leo/core/leoEditCommands.py (original)
+++ leo/core/leoEditCommands.py (refactored)
@@ -15,11 +15,12 @@
 import leo.core.leoKeys as leoKeys
 import leo.core.leoPlugins as leoPlugins
 import leo.core.leoTest as leoTest
+from functools import reduce

@@ -2145,7 +2146,7 @@
     def _addPrefix (self,ntxt):

         ntxt = ntxt.split('.')
-        ntxt = map(lambda a: self.fillPrefix+a,ntxt)
+        ntxt = [self.fillPrefix+a for a in ntxt]
         ntxt = '.'.join(ntxt)
         return ntxt
#@verbatim
     #@-node:ekr.20050920084036.71:_addPrefix
@@ -4705,7 +4706,7 @@
             columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
                 for z in range(sint1,sint3+1)]
             aList = g.splitLines(txt)
-            zlist = zip(columns,aList)
+            zlist = list(zip(columns,aList))
             zlist.sort()
             s = g.joinLines([z[1] for z in zlist])
             w.delete(i,j)
@@ -4751,7 +4752,7 @@
                 if len(f) < i: return
                 i = i-1
                 fields.append(f[i])
-        nz = zip(fields,txt)
+        nz = list(zip(fields,txt))
         nz.sort()
         w.delete(i,j)
         int1 = i
@@ -5848,7 +5849,7 @@
             return self
#@verbatim
         #@-node:ekr.20071003160252.1:__init__ & __iter__
#@verbatim
         #@+node:ekr.20071003160252.2:next
-        def next(self):
+        def __next__(self):

             commands = self.c.killBufferCommands
             aList = commands.killBuffer
@@ -6013,7 +6014,7 @@
         try:
             if not pop or self.lastYankP and self.lastYankP != current:
                 self.reset = 0
-            s = self.kbiterator.next()
+            s = next(self.kbiterator)
             if s is None: s = clip_text or ''
             if i != j: w.deleteTextSelection()
             if s != s.lstrip(): # s contains leading whitespace.


--- leo/core/leoFileCommands.py (original)
+++ leo/core/leoFileCommands.py (refactored)

@@ -476,7 +476,7 @@
                         'tx':'ekr.123','testAttr':'abc',
                     }
                 def getNames(self):
-                    return self.attrs.keys()
+                    return list(self.attrs.keys())
                 def getValue(self,key):
                     return self.attrs.get(key)

@@ -572,7 +572,7 @@
             g.pr('\nnode: tnx: %s len(body): %d %s' % (
                 self.tnx,len(self.bodyString),self.headString))
             g.pr('children:',g.listToString(self.children))
-            g.pr('attrs:',self.attributes.values())
+            g.pr('attrs:',list(self.attributes.values()))
#@verbatim
         #@nonl
#@verbatim
         #@-node:ekr.20060919110638.18:node.dump
#@verbatim
         #@-others
@@ -1149,7 +1149,7 @@

         trace = False and not g.unitTesting
         d = sax_node.tnodeAttributes
-        if trace and d: g.trace(sax_node,d.keys())
+        if trace and d: g.trace(sax_node,list(d.keys()))

         aDict = {}
         for key in d:
@@ -1159,7 +1159,7 @@
             aDict[key] = val2

         if aDict:
-            if trace: g.trace('uA',v,aDict.keys())
+            if trace: g.trace('uA',v,list(aDict.keys()))
             v.unknownAttributes = aDict
#@verbatim
     #@+node:ekr.20090702070510.6028:@test handleTnodeSaxAttributes
     if g.unitTesting:
@@ -1454,7 +1454,7 @@
             else:
                 if theFile: s = theFile.read()
                 s = self.cleanSaxInputString(s)
-                theFile = cStringIO.StringIO(s)
+                theFile = io.StringIO(s)
             parser = xml.sax.make_parser()
             parser.setFeature(xml.sax.handler.feature_external_ges,1)
                 # Include external general entities, esp. xml-stylesheet lines.
@@ -2541,7 +2541,7 @@
             g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
             return ''
         else:
-            val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
+            val = ''.join([self.putUaHelper(torv,key,val) for key,val in list(attrDict.items())])
             # g.trace(torv,attrDict)
             return val
#@verbatim
     #@-node:EKR.20040526202501:putUnknownAttributes


--- leo/core/leoFind.py (original)
+++ leo/core/leoFind.py (refactored)

--- leo/core/leoFrame.py (original)
+++ leo/core/leoFrame.py (refactored)
@@ -856,7 +856,7 @@
         if self.numberOfEditors == 2:
             # Inject the ivars into the first editor.
             # Bug fix: Leo 4.4.8 rc1: The name of the last editor need not be '1'
-            d = self.editorWidgets ; keys = d.keys()
+            d = self.editorWidgets ; keys = list(d.keys())
             if len(keys) == 1:
                 w_old = d.get(keys[0])
                 self.updateInjectedIvars(w_old,p)
@@ -918,11 +918,11 @@
         '''Cycle keyboard focus between the body text editors.'''

         c = self.c ; d = self.editorWidgets ; w = c.frame.body.bodyCtrl
-        values = d.values()
+        values = list(d.values())
         if len(values) > 1:
             i = values.index(w) + 1
             if i == len(values): i = 0
-            w2 = d.values()[i]
+            w2 = list(d.values())[i]
             assert(w!=w2)
             self.selectEditor(w2)
             c.frame.body.bodyCtrl = w2
@@ -937,7 +937,7 @@

         c = self.c ; w = c.frame.body.bodyCtrl ; d = self.editorWidgets

-        if len(d.keys()) == 1: return
+        if len(list(d.keys())) == 1: return

         name = w.leo_name

@@ -950,7 +950,7 @@
             self.pb.configurepane(pane,size=minSize)

         # Select another editor.
-        w = d.values()[0]
+        w = list(d.values())[0]
         # c.frame.body.bodyCtrl = w # Don't do this now?
         self.numberOfEditors -= 1
         self.selectEditor(w)
@@ -960,7 +960,7 @@

         '''Return an editor to be assigned to chapter.'''

-        c = self.c ; d = self.editorWidgets ; values = d.values()
+        c = self.c ; d = self.editorWidgets ; values = list(d.values())

         # First, try to match both the chapter and position.
         if p:
@@ -1104,7 +1104,7 @@

         c = self.c ; p = c.p
         d = self.editorWidgets
-        if len(d.keys()) < 2: return # There is only the main widget.
+        if len(list(d.keys())) < 2: return # There is only the main widget.

         for key in d:
             w = d.get(key)
@@ -2157,11 +2157,11 @@
         w = d.get(self.tabName)
         # g.trace(self.tabName,w)

-        values = d.values()
+        values = list(d.values())
         if self.numberOfVisibleTabs() > 1:
             i = i2 = values.index(w) + 1
             if i == len(values): i = 0
-            tabName = d.keys()[i]
+            tabName = list(d.keys())[i]
             self.selectTab(tabName)
             return 
#@verbatim
     #@nonl
@@ -2207,7 +2207,7 @@
#@verbatim
     #@+node:ekr.20070302094848.9:numberOfVisibleTabs
     def numberOfVisibleTabs (self):

-        return len([val for val in self.frameDict.values() if val != None])
+        return len([val for val in list(self.frameDict.values()) if val != None])
#@verbatim
     #@-node:ekr.20070302094848.9:numberOfVisibleTabs
#@verbatim
     #@+node:ekr.20070302094848.10:renameTab
     def renameTab (self,oldName,newName):
@@ -3367,7 +3367,7 @@
         if not w:
             d[p.v] = w = stringTextWidget(
                 c=self.c,
-                name='head-%d' % (1 + len(d.keys())))
+                name='head-%d' % (1 + len(list(d.keys()))))
             w.setAllText(p.h)
         # g.trace('w',w,'p',p.h)
         return w


--- leo/core/leoGlobals.py (original)
+++ leo/core/leoGlobals.py (refactored)

@@ -46,6 +46,7 @@
 import re
 import sys
 import time
+from functools import reduce

 try:
     import zipfile
@@ -105,7 +106,7 @@
     # def __len__    (self): return 0 # Debatable.
     def __repr__   (self): return "nullObject"
     def __str__    (self): return "nullObject"
-    def __nonzero__(self): return 0
+    def __bool__(self): return 0
     def __delattr__(self,attr):     return None ### self
     def __getattr__(self,attr):     return None ### self
     def __setattr__(self,attr,val): return None ### self
@@ -135,7 +136,7 @@
     if not g.app:
         # Important: these references do not make Leo's core gui-dependent.
         # In other words, this function is called only when Tkinter should be the gui.
-        import Tkinter as Tk
+        import tkinter as Tk
         Pmw = g.importExtension('Pmw',pluginName=pluginName,verbose=True)
         if Tk and Pmw:
             import leo.core.leoApp as leoApp, leoGui

@@ -1971,7 +1972,7 @@

     g.pr(s)

-    i = 0 ; n = long(1000) * long(1000)
+    i = 0 ; n = int(1000) * int(1000)
     while i < n:
         i += 1
#@verbatim
 #@-node:ekr.20031218072017.3128:pause
@@ -2515,7 +2516,7 @@
     theFile,theFileName = g.create_temp_file()

     assert type(theFile) == types.FileType, 'not file type'
-    assert type(theFileName) in (types.StringType, types.UnicodeType), 'not string type'
+    assert type(theFileName) in (bytes, str), 'not string type'
#@verbatim
 #@-node:ekr.20090517020744.5873:@test g.create_temp_file
#@verbatim
 #@-node:ekr.20031218072017.3117:g.create_temp_file & test
#@verbatim
 #@+node:ekr.20031218072017.3118:g.ensure_extension
@@ -2734,7 +2735,7 @@
     try:
         isZipped = zipfile and zipfile.is_zipfile(fileName)
         if isZipped:
-            import StringIO
+            import io
             theFile = zipfile.ZipFile(fileName,'r')
             if not theFile: return None,False
             # New in Leo 4.6 b2: read the file into an StringIO file.
@@ -2742,7 +2743,7 @@
             name = aList and len(aList) == 1 and aList[0]
             if not name: return None,False
             s = theFile.read(name)
-            theStringFile =  StringIO.StringIO(s)
+            theStringFile =  io.StringIO(s)
             return theStringFile,True
         else:
             # mode = g.choose(g.isPython3,'r','rb')
@@ -3351,7 +3352,7 @@
         d[t] = d.get(t,0) + 1

     if 1: # Sort by n
-        items = d.items()
+        items = list(d.items())
         try:
             # Support for keword args to sort function exists in Python 2.4.
             # Support for None as an alternative to omitting cmp exists in Python 2.3.
@@ -3385,7 +3386,7 @@

         for obj in gc.get_objects():
             t = type(obj)
-            if t == 'instance' and t != types.UnicodeType:
+            if t == 'instance' and t != str:
                 try: t = obj.__class__
                 except Exception: pass
             if t != types.FrameType:
@@ -3695,7 +3696,7 @@
     if d is None: d = {}

     result = {}
-    for key,default_val in d.items():
+    for key,default_val in list(d.items()):
         isBool = default_val in (True,False)
         val = keys.get(key)
         if isBool and val in (True,'True','true'):
@@ -5094,7 +5095,7 @@

     subprocess = g.importExtension('subprocess',None,verbose=False)

-    cwd = os.getcwdu()
+    cwd = os.getcwd()
     fdir, fname = g.os_path_split(filename)

     if subprocess: # Only exists in Python 2.4.
@@ -5120,7 +5121,7 @@
     else:
         if fdir: os.chdir(fdir)
         d = {'__name__': '__main__'}
-        execfile(fname, d)  #, globals()
+        exec(compile(open(fname).read(), fname, 'exec'), d)  #, globals()
         os.system('%s %s' % (sys.executable, fname))
         if fdir: os.chdir(cwd)
#@verbatim
 #@-node:ekr.20050503112513.7:g.executeFile

@@ -5873,7 +5874,7 @@

     result = []
     for item in theList:
-        if type(item) == types.ListType:
+        if type(item) == list:
             result.extend(g.flattenList(item))
         else:
             result.append(item)
@@ -6389,7 +6390,7 @@
         return 'module'
     elif type(obj) == types.InstanceType:
         return 'object'
-    elif type(obj) in (types.UnicodeType,types.StringType):
+    elif type(obj) in (str,bytes):
         return 'string'
     else:
         theType = str(type(obj))
@@ -6618,7 +6619,7 @@

     # Requires minimal further imports.
     try:
-        import Tkinter as Tk
+        import tkinter as Tk
         root = g.app.root or Tk.Tk()
         title = 'Can not import %s' % moduleName
         top = createDialogFrame(Tk,root,title,message)


--- leo/core/leoGui.py (original)
+++ leo/core/leoGui.py (refactored)


--- leo/core/leoImport.py (original)
+++ leo/core/leoImport.py (refactored)

@@ -1831,7 +1831,7 @@

         if s1 is None and s2 is None:
             if self.isRst: # Errors writing file at present...
-                outputFile = StringIO.StringIO()
+                outputFile = io.StringIO()
                 c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
                 s1,s2 = self.file_s,outputFile.getvalue()
             else:


--- leo/core/leoKeys.py (original)
+++ leo/core/leoKeys.py (refactored)
@@ -22,6 +22,7 @@
 import string
 import sys
 import types
+from functools import reduce

 # The following imports _are_ used.

@@ -167,13 +168,13 @@

         for z in gc.get_objects():
             t = type(z)
-            if t == types.ClassType:
+            if t == type:
                 name = z.__name__
             elif t == types.InstanceType:
                 name = z.__class__.__name__
             elif repr(t).startswith('<class'): # A wretched kludge.
                 name = z.__class__.__name__
-            elif t == types.TypeType:
+            elif t == type:
                 name = z.__name__
             else:
                 name = None
@@ -212,7 +213,7 @@
         ]

         if 0: # Not useful at this point.
-            for key in __builtins__.keys():
+            for key in list(list(__builtins__.keys())):
                 obj = __builtins__.get(key)
                 if obj in (True,False,None): continue
                 data = [key],'object',obj
@@ -305,9 +306,9 @@
         elif keysym == '!':
             # Toggle between verbose and brief listing.
             self.verbose = not self.verbose
-            if type(self.theObject) == types.DictType:
-                self.membersList = self.theObject.keys()
-            elif type(self.theObject) in (types.ListType,types.TupleType):
+            if type(self.theObject) == dict:
+                self.membersList = list(list(self.theObject.keys()))
+            elif type(self.theObject) in (list,tuple):
                 self.membersList = self.theObject
             self.computeCompletionList(verbose=self.verbose)
         elif ch and ch in string.printable:
@@ -518,7 +519,7 @@
#@verbatim
             #@+node:ekr.20061031131434.21:<< try to set s from a Python global function >>
             # The first line of the docstring is good enough, except for classes.
             f = __builtins__.get(self.leadinWord)
-            doc = f and type(f) != types.ClassType and f.__doc__
+            doc = f and type(f) != type and f.__doc__
             if doc:
                 # g.trace(doc)
                 s = g.splitLines(doc)
@@ -533,7 +534,7 @@
         if not s:
#@verbatim
             #@        << get s using inspect >>
#@verbatim
             #@+node:ekr.20061031131434.22:<< get s using inspect >>
-            isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType
+            isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == bytes

             # g.trace(self.prevObjects)

@@ -980,7 +981,7 @@
             # Leading dot shows all classes.
             self.leadinWord = None
             self.theObject = sys.modules
-            self.membersList = sys.modules.keys()
+            self.membersList = list(list(sys.modules.keys()))
             self.beginTabName('Modules')
         elif word in ( "'",'"'):
             word = 'aString' # This is in the objectsDict.
@@ -1337,7 +1338,7 @@

         if 0: # Calling the real ctor is way too dangerous.
             # Set args to the list of required arguments.
-            args = inspect.getargs(theClass.__init__.im_func.func_code)
+            args = inspect.getargs(theClass.__init__.__func__.__code__)
             args = args[0] ; n = len(args)-1
             args = [None for z in range(n)]

@@ -2514,7 +2515,7 @@
         if k.regx.iter:
             try:
                 k.regXKey = keysym
-                k.regx.iter.next() # EKR: next() may throw StopIteration.
+                next(k.regx.iter) # EKR: next() may throw StopIteration.
             except StopIteration:
                 pass
             return 'break'
@@ -2650,11 +2651,11 @@
                 k.callAltXFunction(k.mb_event)
         elif keysym in ('Tab','\t'):
             if trace and verbose: g.trace('***Tab')
-            k.doTabCompletion(c.commandsDict.keys())
+            k.doTabCompletion(list(c.commandsDict.keys()))
             c.minibufferWantsFocus()
         elif keysym == 'BackSpace':
             if trace and verbose: g.trace('***BackSpace')
-            k.doBackSpace(c.commandsDict.keys())
+            k.doBackSpace(list(c.commandsDict.keys()))
             c.minibufferWantsFocus()
         elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
             # g.trace('non-ascii')
@@ -2695,7 +2696,7 @@
         else:
             if 1: # Useful.
                 if trace: g.trace('*** tab completion')
-                k.doTabCompletion(c.commandsDict.keys())
+                k.doTabCompletion(list(c.commandsDict.keys()))
             else: # Annoying.
                 k.keyboardQuit(event)
                 k.setLabel('Command does not exist: %s' % commandName)
@@ -3252,7 +3253,7 @@
         if commandName.startswith('press-') and commandName.endswith('-button'):
             d = c.config.getAbbrevDict()
                 # Keys are full command names, values are abbreviations.
-            if commandName in d.values():
+            if commandName in list(d.values()):
                 for key in d:
                     if d.get(key) == commandName:
                         c.commandsDict [key] = c.commandsDict.get(commandName)
@@ -4014,7 +4015,7 @@
         else:
             k.modeBindingsDict = d
             prompt = d.get('*command-prompt*') or modeName
-            if trace: g.trace('modeName',modeName,prompt,'d.keys()',d.keys())
+            if trace: g.trace('modeName',modeName,prompt,'d.keys()',list(d.keys()))

         k.inputModeName = modeName
         k.silentMode = False


--- leo/core/leoNodes.py (original)
+++ leo/core/leoNodes.py (refactored)

@@ -1819,7 +1819,7 @@

@@ -2839,7 +2839,7 @@
             m = re.finditer(pat, p.b)
             t1,t2 = itertools.tee(m,2)
             try:
-                first = t1.next()
+                first = next(t1)
                 # if does not raise StopIteration...
                 pc = p.copy()
                 pc.matchiter = t2


--- leo/core/leoPlugins.py (original)
+++ leo/core/leoPlugins.py (refactored)
@@ -303,7 +303,7 @@

     import types

-    if type(tags) in (types.TupleType,types.ListType):
+    if type(tags) in (tuple,list):
         result = []
         for tag in tags:
             aList = getHandlersForOneTag(tag) 
@@ -571,7 +571,7 @@

     import types

-    if type(tags) in (types.TupleType,types.ListType):
+    if type(tags) in (tuple,list):
         for tag in tags:
             registerOneExclusiveHandler(tag,fn)
     else:
@@ -606,7 +606,7 @@

     import types

-    if type(tags) in (types.TupleType,types.ListType):
+    if type(tags) in (tuple,list):
         for tag in tags:
             registerOneHandler(tag,fn)
     else:
@@ -659,7 +659,7 @@

     import types

-    if type(tags) in (types.TupleType,types.ListType):
+    if type(tags) in (tuple,list):
         for tag in tags:
             unregisterOneHandler(tag,fn)
     else:


--- leo/core/leoRst.py (original)
+++ leo/core/leoRst.py (refactored)

@@ -73,7 +73,7 @@
         module = SilverCity and getattr(SilverCity,language)
         generator = module and getattr(module,language+"HTMLGenerator")
         if generator:
-            io = StringIO.StringIO()
+            io = io.StringIO()
             generator().generate_html(io,'\n'.join(content))
             html = '<div class="code-block">\n%s\n</div>\n' % io.getvalue()
         else:
@@ -381,7 +381,7 @@

         if 0:
             g.trace(root.h)
-            for key in self.tnodeOptionDict.keys():
+            for key in list(self.tnodeOptionDict.keys()):
                 g.trace(key)
                 g.printDict(self.tnodeOptionDict.get(key))
#@verbatim
     #@nonl
@@ -531,7 +531,7 @@
         if data:
             name,val = data
             fullName = 'rst3_' + self.munge(name)
-            if fullName in self.defaultOptionsDict.keys():
+            if fullName in list(self.defaultOptionsDict.keys()):
                 if   val.lower() == 'true': val = True
                 elif val.lower() == 'false': val = False
                 # g.trace('%24s %8s %s' % (self.munge(name),val,p.h))
@@ -577,7 +577,7 @@
         for p in p.self_and_parents():
             d = self.tnodeOptionDict.get(p.v,{})
             # g.trace(p.h,d)
-            for key in d.keys():
+            for key in list(d.keys()):
                 ivar = self.munge(key)
                 if not ivar in seen:
                     seen.append(ivar)
@@ -740,7 +740,7 @@
         self.initWrite(p)

         # Always write to a string first.
-        self.outputFile = StringIO.StringIO()
+        self.outputFile = io.StringIO()
         self.writeTree(p)
         self.source = self.stringOutput = self.outputFile.getvalue()

@@ -821,7 +821,7 @@
                 g.es('SilverCity not present so no syntax highlighting')

         self.initWrite(p,encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
-        self.outputFile = StringIO.StringIO()
+        self.outputFile = io.StringIO()
         self.writeTree(p)
         self.source = self.outputFile.getvalue()
         self.outputFile = None

--- leo/core/leoTangle.py (original)
+++ leo/core/leoTangle.py (refactored)
@@ -2091,7 +2091,7 @@
         for name in sorted(self.ust):
             section = self.ust[name]
             s += "\n\n" + section.name
-            for part in section.parts.values():
+            for part in list(section.parts.values()):
                 assert(part.of == section.of)
                 s += "\n----- part %d of %d -----\n" % (part.part,part.of)
                 s += repr(g.get_line(part.code,0))
@@ -2163,9 +2163,9 @@
         """Issues a warning about any sections in the derived file for which
         no corresponding section has been seen in the outline."""

-        for section in self.ust.values():
+        for section in list(self.ust.values()):
             # g.trace(section)
-            for part in section.parts.values():
+            for part in list(section.parts.values()):
                 assert(part.of == section.of)
                 if not part.update_flag:
                     lp = g.choose(self.use_noweb_flag,"<< ","@< ")


--- leo/core/leoTest.py (original)
+++ leo/core/leoTest.py (refactored)
@@ -190,7 +190,7 @@

         if writeScriptFile:
             scriptFile = c.writeScriptFile(script)
-            execfile(scriptFile,d)
+            exec(compile(open(scriptFile).read(), scriptFile, 'exec'),d)
         else:
             exec(script,d)

@@ -1337,7 +1337,7 @@
 def checkFileTabs (fileName,s):

     try:
-        readline = g.readLinesClass(s).next
+        readline = g.readLinesClass(s).__next__
         tabnanny.process_tokens(tokenize.generate_tokens(readline))

     except tokenize.TokenError(msg):
@@ -1739,7 +1739,7 @@
         try:
             result *= factor
         except OverflowError:
-            result *= long(factor)
+            result *= int(factor)
         factor += 1
     return result
#@verbatim
 #@-node:ekr.20051104075904.97:factorial


--- leo/core/leoUndo.py (original)
+++ leo/core/leoUndo.py (refactored)
@@ -261,7 +261,7 @@
             g.pr('-' * 20)

         # bunch is not a dict, so bunch.keys() is required.
-        for key in bunch.keys(): 
+        for key in list(bunch.keys()): 
             val = bunch.get(key)
             # g.trace(key,val)
             setattr(u,key,val)


--- leo/core/leo_Debugger.py (original)
+++ leo/core/leo_Debugger.py (refactored)
@@ -2,12 +2,12 @@
#@verbatim
 #@+node:ekr.20060516135654.94:@thin leo_Debugger.py
#@verbatim
 #@<< imports >>
#@verbatim
 #@+node:ekr.20060516135654.95:<< imports >>
-import leoGlobals as g
-
-import leo_FileList
-import leo_run
-import leo_RemoteDebugger
-import leo_Shell
+from . import leoGlobals as g
+
+from . import leo_FileList
+from . import leo_run
+from . import leo_RemoteDebugger
+from . import leo_Shell

 import idlelib.ScrolledList as ScrolledList

@@ -18,8 +18,8 @@
 import time
 import types

-import Tkinter as Tk
-import tkMessageBox
+import tkinter as Tk
+import tkinter.messagebox

 import __main__
#@verbatim
 #@nonl
@@ -245,8 +245,8 @@
             height = 20*len(dict) # XXX 20 == observed height of Entry widget
         self.master = master
         self.title = title
-        import repr
-        self.repr = repr.Repr()
+        import reprlib
+        self.repr = reprlib.Repr()
         self.repr.maxstring = 60
         self.repr.maxother = 60
         self.frame = frame = Tk.Frame(master)
@@ -274,14 +274,14 @@
             return
         subframe = self.subframe
         frame = self.frame
-        for c in subframe.children.values():
+        for c in list(subframe.children.values()):
             c.destroy()
         self.dict = None
         if not dict:
             l = Tk.Label(subframe, text="None")
             l.grid(row=0, column=0)
         else:
-            names = dict.keys()
+            names = list(dict.keys())
             names.sort()
             row = 0
             for name in names:
@@ -372,7 +372,7 @@
         bl.append(b)
         self.bstep = b = Tk.Button(bframe, text="Step", command=self.step)
         bl.append(b)
-        self.bnext = b = Tk.Button(bframe, text="Over", command=self.next)
+        self.bnext = b = Tk.Button(bframe, text="Over", command=self.__next__)
         bl.append(b)
         self.bret = b = Tk.Button(bframe, text="Out", command=self.ret)
         bl.append(b)
@@ -553,7 +553,7 @@
         self.root.quit()
#@verbatim
     #@-node:ekr.20060516135654.197:step
#@verbatim
     #@+node:ekr.20060516135654.198:next
-    def next(self):
+    def __next__(self):
         self.idb.set_next(self.frame)
         self.root.quit()
#@verbatim
     #@-node:ekr.20060516135654.198:next
@@ -595,8 +595,9 @@
             self.sync_source_line()
#@verbatim
     #@-node:ekr.20060516135654.203:show_source
#@verbatim
     #@+node:ekr.20060516135654.204:show_frame
-    def show_frame(self, (frame, lineno)):
-    
+    def show_frame(self, xxx_todo_changeme):
+    
+        (frame, lineno) = xxx_todo_changeme
         self.frame = frame
         self.show_variables()
#@verbatim
     #@-node:ekr.20060516135654.204:show_frame
@@ -676,7 +677,7 @@
         g.trace()

         if 0: # "Load PyShellEditorWindow breakpoints into subprocess debugger"
-            pyshell_edit_windows = self.pyshell.flist.inversedict.keys()
+            pyshell_edit_windows = list(self.pyshell.flist.inversedict.keys())
             for editwin in pyshell_edit_windows:
                 filename = editwin.io.filename
                 try:


--- leo/core/leo_FileList.py (original)
+++ leo/core/leo_FileList.py (refactored)
@@ -3,7 +3,7 @@
#@verbatim
 #@@language python
#@verbatim
 #@@tabwidth -4

-import leoGlobals as g
+from . import leoGlobals as g

 import os
 # from Tkinter import *
@@ -61,7 +61,7 @@
         return key # EKR

         if 0:
-            if self.dict.has_key(key):
+            if key in self.dict:
                 edit = self.dict[key]
                 edit.top.wakeup()
                 return edit
@@ -104,7 +104,7 @@
         g.trace()

         if 0: # The Leo editor never closes
-            for edit in self.inversedict.keys():
+            for edit in list(self.inversedict.keys()):
                 reply = edit.close()
                 if reply == "cancel":
                     break
@@ -152,7 +152,7 @@
             newkey = os.path.normcase(filename)
             if newkey == key:
                 return
-            if self.dict.has_key(newkey):
+            if newkey in self.dict:
                 conflict = self.dict[newkey]
                 self.inversedict[conflict] = None
                 tkMessageBox.showerror(


#@+node:ekr.20091203165343.6150:leo_RemoteDebugger
@@ -30,7 +30,7 @@
#@verbatim
 #@@language python
#@verbatim
 #@@tabwidth -4

-import leo_Debugger
+from . import leo_Debugger

 # This probably can not access Leo directly.

@@ -216,7 +216,7 @@
#@verbatim
     #@+node:ekr.20060516135654.55:dict_keys
     def dict_keys(self, did):
         dict = dicttable[did]
-        return dict.keys()
+        return list(dict.keys())
#@verbatim
     #@-node:ekr.20060516135654.55:dict_keys
#@verbatim
     #@+node:ekr.20060516135654.56:dict_item
     def dict_item(self, did, key):
@@ -266,7 +266,7 @@
#@verbatim
     #@+node:ekr.20060516135654.61:__getattr__
     def __getattr__(self, name):
         if name[:1] == "_":
-            raise AttributeError, name
+            raise AttributeError(name)
         if name == "f_code":
             return self._get_f_code()
         if name == "f_globals":
@@ -295,7 +295,7 @@
#@verbatim
     #@-node:ekr.20060516135654.64:_get_f_locals
#@verbatim
     #@+node:ekr.20060516135654.65:_get_dict_proxy
     def _get_dict_proxy(self, did):
-        if self._dictcache.has_key(did):
+        if did in self._dictcache:
             return self._dictcache[did]
         dp = DictProxy(self._conn, self._oid, did)
         self._dictcache[did] = dp
@@ -346,7 +346,7 @@
#@verbatim
     #@+node:ekr.20060516135654.73:__getattr__
     def __getattr__(self, name):
         ##print >>sys.__stderr__, "failed DictProxy.__getattr__:", name
-        raise AttributeError, name
+        raise AttributeError(name)
#@verbatim
     #@-node:ekr.20060516135654.73:__getattr__
#@verbatim
     #@-others
#@verbatim
 #@-node:ekr.20060516135654.69:class DictProxy

#@nonl
#@-node:ekr.20091203165343.6150:leo_RemoteDebugger
#@+node:ekr.20091203165343.6149:leo_shell
@@ -5,9 +5,9 @@

#@verbatim
 #@<< imports >>
#@verbatim
 #@+node:ekr.20060517102458:<< imports >>
-import leoGlobals as g
-
-import leo_RemoteDebugger
+from . import leoGlobals as g
+
+from . import leo_RemoteDebugger

 from code import InteractiveInterpreter

@@ -100,7 +100,7 @@
                 self.rpcclt = MyRPCClient(addr)
                 g.trace(self.rpcclt)
                 break
-            except socket.error, err:
+            except socket.error as err:
                 pass
         else:
             self.display_port_binding_error()
@@ -109,7 +109,7 @@
         self.rpcclt.listening_sock.settimeout(10)
         try:
             self.rpcclt.accept()
-        except socket.timeout, err:
+        except socket.timeout as err:
             self.display_no_subprocess_error()
             return None
         self.rpcclt.register("stdin", self.tkconsole)
@@ -144,7 +144,7 @@
         self.spawn_subprocess()
         try:
             self.rpcclt.accept()
-        except socket.timeout, err:
+        except socket.timeout as err:
             self.display_no_subprocess_error()
             return None
         self.transfer_path()
@@ -328,7 +328,7 @@
         self.more = 0
         self.save_warnings_filters = warnings.filters[:]
         warnings.filterwarnings(action="error", category=SyntaxWarning)
-        if isinstance(source, types.UnicodeType):
+        if isinstance(source, str):
             import IOBinding
             try:
                 source = source.encode(IOBinding.encoding)
@@ -424,7 +424,7 @@
#@verbatim
     #@+node:ekr.20060516135654.121:checklinecache
     def checklinecache(self):
         c = linecache.cache
-        for key in c.keys():
+        for key in list(c.keys()):
             if key[:1] + key[-1:] != "<>":
                 del c[key]
#@verbatim
     #@-node:ekr.20060516135654.121:checklinecache
@@ -438,7 +438,7 @@
         if self.rpcclt:
             self.rpcclt.remotequeue("exec", "runcode", (code,), {})
         else:
-            exec code in self.locals
+            exec(code, self.locals)
         return 1
#@verbatim
     #@-node:ekr.20060516135654.122:runcommand
#@verbatim
     #@+node:ekr.20060516135654.123:runcode
@@ -460,7 +460,7 @@
                 elif debugger:
                     debugger.run(code, self.locals)
                 else:
-                    exec code in self.locals
+                    exec(code, self.locals)
             except SystemExit:
                 if tkMessageBox.askyesno(
                     "Exit?",
#@-node:ekr.20091203165343.6149:leo_shell
#@+node:ekr.20091203165343.6148:leo_run (tkinter: to be deleted?)
--- leo/core/leo_run.py (original)
+++ leo/core/leo_run.py (refactored)
@@ -7,7 +7,7 @@

#@verbatim
 #@<< imports >>
#@verbatim
 #@+node:ekr.20060516135654.2:<< imports >>
-import leoGlobals as g
+from . import leoGlobals as g

 import sys
 import os
@@ -15,12 +15,12 @@
 import time
 import socket
 import traceback
-import thread
+import _thread
 import threading
-import Queue
+import queue

 import idlelib.CallTips as CallTips
-import leo_RemoteDebugger as RemoteDebugger
+from . import leo_RemoteDebugger as RemoteDebugger
 import idlelib.RemoteObjectBrowser as RemoteObjectBrowser
 import idlelib.StackViewer as StackViewer
 import idlelib.rpc as rpc
@@ -111,7 +111,7 @@
                     continue
             try:
                 seq, request = rpc.request_queue.get(0)
-            except Queue.Empty:
+            except queue.Empty:
                 time.sleep(0.05)
                 continue
             method, args, kwargs = request
@@ -143,7 +143,7 @@
         try:
             server = MyRPCServer(address, MyHandler)
             break
-        except socket.error, err:
+        except socket.error as err:
             print>>sys.__stderr__,"Leo Subprocess: socket error: "\
                                         + err[1] + ", retrying...."
     else:
@@ -158,18 +158,18 @@
#@verbatim
 #@-node:ekr.20060516135654.5:manage_socket
#@verbatim
 #@+node:ekr.20060516135654.6:show_socket_error
 def show_socket_error(err, address):
-    import Tkinter
-    import tkMessageBox
-    root = Tkinter.Tk()
+    import tkinter
+    import tkinter.messagebox
+    root = tkinter.Tk()
     root.withdraw()
     if err[0] == 61: # connection refused
         msg = "Leo's subprocess can't connect to %s:%d.  This may be due "\
               "to your personal firewall configuration.  It is safe to "\
               "allow this internal connection because no data is visible on "\
               "external ports." % address
-        tkMessageBox.showerror("Leo Subprocess Error", msg, parent=root)
+        tkinter.messagebox.showerror("Leo Subprocess Error", msg, parent=root)
     else:
-        tkMessageBox.showerror("Leo Subprocess Error", "Socket Error: %s" % err[1])
+        tkinter.messagebox.showerror("Leo Subprocess Error", "Socket Error: %s" % err[1])
     root.destroy()
#@verbatim
 #@nonl
#@verbatim
 #@-node:ekr.20060516135654.6:show_socket_error
@@ -269,7 +269,7 @@
         except EOFError:
             global exit_now
             exit_now = True
-            thread.interrupt_main()
+            _thread.interrupt_main()
         except:
             erf = sys.__stderr__
             print>>erf, '\n' + '-'*40
@@ -281,7 +281,7 @@
             print>>erf, '\n*** Unrecoverable, server exiting!'
             print>>erf, '-'*40
             quitting = True
-            thread.interrupt_main()
+            _thread.interrupt_main()
#@verbatim
     #@-node:ekr.20060516135654.12:handle_error
#@verbatim
     #@-others
#@verbatim
 #@nonl
@@ -313,14 +313,14 @@
         "Override SocketIO method - terminate wait on callback and exit thread"
         global quitting
         quitting = True
-        thread.interrupt_main()
+        _thread.interrupt_main()
#@verbatim
     #@-node:ekr.20060516135654.16:EOFhook
#@verbatim
     #@+node:ekr.20060516135654.17:decode_interrupthook
     def decode_interrupthook(self):
         "interrupt awakened thread"
         global quitting
         quitting = True
-        thread.interrupt_main()
+        _thread.interrupt_main()
#@verbatim
     #@-node:ekr.20060516135654.17:decode_interrupthook
#@verbatim
     #@-others
#@verbatim
 #@nonl
@@ -344,7 +344,7 @@

         try:
             self.usr_exc_info = None
-            exec code in self.locals
+            exec(code, self.locals)
         except:
             self.usr_exc_info = sys.exc_info()
             if quitting:
@@ -360,7 +360,7 @@
#@verbatim
     #@+node:ekr.20060516135654.21:interrupt_the_server
     def interrupt_the_server(self):

-        thread.interrupt_main()
+        _thread.interrupt_main()

#@verbatim
     #@-node:ekr.20060516135654.21:interrupt_the_server
#@verbatim
     #@+node:ekr.20060516135654.22:leo_run.Executive.start_the_debugger

#@nonl
#@-node:ekr.20091203165343.6148:leo_run (tkinter: to be deleted?)
#@+node:ekr.20091203165343.6147:runLeo (tkinter: to be deleted?)

@@ -17,7 +17,7 @@
 import traceback

 try:
-    import Tkinter ; Tkinter.wantobjects = 0
+    import tkinter ; tkinter.wantobjects = 0
         # An ugly hack for Tk/Tkinter 8.5
         # See http://sourceforge.net/forum/message.php?msg_id=4078577
 except ImportError:
@@ -503,7 +503,7 @@
             print(message)
             try:
                 # g.app.gui does not exist yet.
-                import Tkinter as Tk
+                import tkinter as Tk
#@verbatim
                 #@                << define emergency dialog class >>
#@verbatim
                 #@+node:ekr.20080822065427.8:<< define emergency dialog class >>
                 class emergencyDialog:
#@-node:ekr.20091203165343.6147:runLeo (tkinter: to be deleted?)
#@-node:ekr.20091203165343.6146:Run2
#@-node:ekr.20091203060018.6067:2to3 output
#@+node:ekr.20091206084842.6197:Details, surprises
@nocolor-node

- add list for .keys(), .values(), .items()
- changes to library.

- opening .leo files from the command line didn't work.
- different exceptions get thrown.
#@-node:ekr.20091206084842.6197:Details, surprises
#@+node:ekr.20091206150342.6187:Failed unit tests
@nocolor
#@+node:ekr.20091206150342.6208:Real failures
FAIL: @test @asis
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 5, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 948, in runAtFileTest
    assert(result == expected)
AssertionError


FAIL: @test @shadow: shape of tree
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 15, in <module>
AssertionError

FAIL: @test @noref
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 5, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 948, in runAtFileTest
    assert(result == expected)
AssertionError

FAIL: @test putDescendentVnodeUas
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 19, in <module>
AssertionError: expected: ' descendentVnodeUnknownAttributes="7d7100285503302e3071017d7102550f756e69745f746573745f6368696c6471035504616263647104735505302e302e3071057d71065514756e69745f746573745f6772616e646368696c64710755047778797a710873752e"', got: ' descendentVnodeUnknownAttributes="b\'7d7100285803000000302e3071017d7102580f000000756e69745f746573745f6368696c6471035804000000616263647104735805000000302e302e3071057d71065814000000756e69745f746573745f6772616e646368696c64710758040000007778797a710873752e\'"'

FAIL: @test putUa
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 7, in <module>
AssertionError: expected: ' unit_test="55046162636471002e"', got: ' unit_test="b\'58040000006162636471002e\'"'

FAIL: @test paste-node
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 25, in <module>
AssertionError: fail 2

FAIL: @test paste-retaining-clones
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 18, in <module>
AssertionError: fail 2
#@-node:ekr.20091206150342.6208:Real failures
#@+node:ekr.20091206161352.6230:Fixed
#@+node:ekr.20091206150342.6202:print statement in unit tests
ERROR: @test unindent in triple string does not end function

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 32
    print 'h',h
            ^
SyntaxError: invalid syntax
#@-node:ekr.20091206150342.6202:print statement in unit tests
#@+node:ekr.20091206150342.6197:xrange in unit tests
ERROR: @test tkBody.onClick
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 5, in <module>
NameError: name 'xrange' is not defined
#@nonl
#@-node:ekr.20091206150342.6197:xrange in unit tests
#@+node:ekr.20091206150342.6193:u' in unit tests
======================================================================
ERROR: @test selfInsertCommand-1

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 12
    u = u'(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aBcz):\n'
                                          ^
SyntaxError: invalid syntax

ERROR: @test open non-existent non-ascii directory
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 6
    file = u''

ERROR: @test atFile.printError
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 9
    s = u'La Pe\xf1a'
                    ^
SyntaxError: invalid syntax

ERROR: @test failure to convert unicode characters to ascii
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 13
    s = u''
           ^
SyntaxError: invalid syntax

ERROR: @test g.reportBadChars
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 8
    (u'ab', 'ascii'),
             ^
SyntaxError: invalid syntax
#@-node:ekr.20091206150342.6193:u' in unit tests
#@+node:ekr.20091206150342.6207:string.strip does not exist
#@-node:ekr.20091206150342.6207:string.strip does not exist
#@+node:ekr.20091206150342.6192:sortLines: string.lower does not exist
======================================================================
ERROR: @test reverse-sort-lines-ignoring-case

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4650, in reverseSortLinesIgnoringCase
    return self.sortLines(event,ignoreCase=True,reverse=True)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4676, in sortLines
    if ignoreCase:  aList.sort(key=string.lower)
AttributeError: 'module' object has no attribute 'lower'
#@-node:ekr.20091206150342.6192:sortLines: string.lower does not exist
#@-node:ekr.20091206161352.6230:Fixed
#@+node:ekr.20091206150342.6185:crash in log pane during unit tests
@nocolor-node

Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 1356, in runUnitTestsLocally
    leoTest.doTests(c,all=False)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 116, in doTests
    archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 116, in <listcomp>
    archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
AttributeError: 'editBodyTestCase' object has no attribute 'p'
#@nonl
#@-node:ekr.20091206150342.6185:crash in log pane during unit tests
#@+node:ekr.20091206150342.6189:outputStringWithLineEndings
Traceback (most recent call last):

  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoAtFile.py", line 3175, in asisWrite
    at.outputStringWithLineEndings(s)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoAtFile.py", line 4324, in outputStringWithLineEndings
    self.os(s.replace('\n',self.output_newline))
TypeError: expected an object with the buffer interface
#@nonl
#@-node:ekr.20091206150342.6189:outputStringWithLineEndings
#@+node:ekr.20091206150342.6190:parse_leo_file
 File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoFileCommands.py", line 1445, in parse_leo_file
    theFile = StringIO(s)

TypeError: initial_value must be str or None, not bytes
#@-node:ekr.20091206150342.6190:parse_leo_file
#@+node:ekr.20091206150342.6191:centerRegion
ERROR: @test center-region

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 2125, in centerRegion
    w.insert(i,' '*n)
TypeError: can't multiply sequence by non-int of type 'float'
#@-node:ekr.20091206150342.6191:centerRegion
#@+node:ekr.20091206150342.6194:sortColumns
ERROR: @test sort-columns

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4709, in sortColumns
    zlist.sort()
AttributeError: 'zip' object has no attribute 'sort'

#@-node:ekr.20091206150342.6194:sortColumns
#@+node:ekr.20091206150342.6195:setInsertPoint
ERROR: @test moveUpOrDownHelper

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 7, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 1105, in setInsertPoint
    i = max(0,min(i,len(s)))
TypeError: unorderable types: int() < str()
#@nonl
#@-node:ekr.20091206150342.6195:setInsertPoint
#@+node:ekr.20091206150342.6196:setSelectionRangeHelper
======================================================================
ERROR: @test <Delete> key sticks in headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 12, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 382, in setSelectionRange
    return self.setSelectionRangeHelper(i,j,insert)
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 1582, in setSelectionRangeHelper
    insert = max(0,min(insert,n))
TypeError: unorderable types: int() < NoneType()
#@nonl
#@-node:ekr.20091206150342.6196:setSelectionRangeHelper
#@+node:ekr.20091206150342.6198:exportHeadlines
ERROR: ImportExportTestCase: exportHeadlines /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/output/exportHeadlines.txt
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1523, in exportHeadlines
    c.importCommands.exportHeadlines(fileName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 384, in exportHeadlines
    theFile.write(head + nl)
TypeError: can't concat bytes to str

#@-node:ekr.20091206150342.6198:exportHeadlines
#@+node:ekr.20091206150342.6199:flattenHeadline
ERROR: ImportExportTestCase: flattenOutline /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/output/flattenOutline.txt
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1545, in flattenOutline
    c.importCommands.flattenOutline(fileName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 409, in flattenOutline
    theFile.write(head + nl)
TypeError: can't concat bytes to str
#@-node:ekr.20091206150342.6199:flattenHeadline
#@+node:ekr.20091206150342.6200:scanWebFile
ERROR: ImportExportTestCase: importCWEBFiles /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/input/cweave.w
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1626, in importCWEBFiles
    c.importCommands.importWebCommand(names,"cweb")
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1212, in importWebCommand
    p = self.createOutlineFromWeb(fileName,current)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1195, in createOutlineFromWeb
    self.scanWebFile(path,p)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1332, in scanWebFile
    if k > -1: self.cstEnter(s[j:k])
TypeError: unorderable types: NoneType() > int()

#@-node:ekr.20091206150342.6200:scanWebFile
#@+node:ekr.20091206150342.6201:skipBlock
ERROR: @test elisp functions

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 23, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1506, in elispUnitTest
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.el')
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1557, in scannerUnitTest
    self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 862, in createOutline
    func(s,p,atAuto=atAuto)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1610, in scanElispText
    scanner.run(s,parent)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 3096, in run
    self.scan(s,parent)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2554, in scan
    i = self.skipDecls(s,0,len(s),inClass=False)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2786, in skipDecls
    elif self.startsFunction(s,i):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 3254, in startsFunction
    end = self.skipBlock(s,i)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2654, in skipBlock
    if indent < startIndent and line.strip():
TypeError: unorderable types: int() < NoneType()
#@-node:ekr.20091206150342.6201:skipBlock
#@+node:ekr.20091206150342.6204:toEncodedStringWithErrorCode
ERROR: @test of round-tripping toUnicode & toEncodedString

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 17, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoGlobals.py", line 5679, in toEncodedStringWithErrorCode
    if type(s) == types.UnicodeType:
AttributeError: 'module' object has no attribute 'UnicodeType'
#@nonl
#@-node:ekr.20091206150342.6204:toEncodedStringWithErrorCode
#@+node:ekr.20091206150342.6205:FileType not in Python3k
ERROR: @test g.create_temp_file

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 7, in <module>
AttributeError: 'module' object has no attribute 'FileType'
#@nonl
#@-node:ekr.20091206150342.6205:FileType not in Python3k
#@+node:ekr.20091206150342.6206:leoNodes iterators
ERROR: @test find_h / find_b / select_h / select_b

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 23, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoNodes.py", line 2842, in select_b
    first = t1.next()
AttributeError: 'itertools.tee' object has no attribute 'next'
#@-node:ekr.20091206150342.6206:leoNodes iterators
#@+node:ekr.20091206150342.6209:leoTest line 116
 File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 116, in <listcomp>
    archive = [(t.p.gnx, trace) for (t, trace) in res.errors]

AttributeError: 'editBodyTestCase' object has no attribute 'p'
#@-node:ekr.20091206150342.6209:leoTest line 116
#@-node:ekr.20091206150342.6187:Failed unit tests
#@-node:ekr.20091203060018.6100:leo-3k
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
